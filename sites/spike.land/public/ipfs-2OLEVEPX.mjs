import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  define_process_default,
  init_define_process
} from "./chunk-LVJWQ4UB.mjs";

// ../../node_modules/it-all/index.js
var require_it_all = __commonJS({
  "../../node_modules/it-all/index.js"(exports2, module2) {
    "use strict";
    init_define_process();
    var all2 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all2;
  }
});

// ../../node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    init_define_process();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w10 = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w10;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports2, module2) {
    init_define_process();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name2)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports2, module2) {
    init_define_process();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof define_process_default !== "undefined" && "env" in define_process_default) {
        r = false;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/err-code/index.js
var require_err_code = __commonJS({
  "../../node_modules/err-code/index.js"(exports2, module2) {
    "use strict";
    init_define_process();
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError2(err, code2, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code2 === "object") {
        props = code2;
        code2 = "";
      }
      if (code2) {
        props.code = code2;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError2;
  }
});

// ../../node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/varint/encode.js"(exports2, module2) {
    init_define_process();
    module2.exports = encode7;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode7(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode7.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode7.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/varint/decode.js"(exports2, module2) {
    init_define_process();
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/varint/length.js"(exports2, module2) {
    init_define_process();
    var N13 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N33 = Math.pow(2, 21);
    var N43 = Math.pow(2, 28);
    var N53 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N93 = Math.pow(2, 63);
    module2.exports = function(value2) {
      return value2 < N13 ? 1 : value2 < N22 ? 2 : value2 < N33 ? 3 : value2 < N43 ? 4 : value2 < N53 ? 5 : value2 < N62 ? 6 : value2 < N72 ? 7 : value2 < N82 ? 8 : value2 < N93 ? 9 : 10;
    };
  }
});

// ../../node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/varint/index.js"(exports2, module2) {
    init_define_process();
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS({
  "../../node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    "use strict";
    init_define_process();
    var MAX_BYTES = 65536;
    function randomBytes2(size) {
      const bytes = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(bytes.subarray(generated, generated + (size - generated)));
              generated += size - generated;
            } else {
              crypto.getRandomValues(bytes.subarray(generated, generated + MAX_BYTES));
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      return bytes;
    }
    module2.exports = randomBytes2;
  }
});

// ../../node_modules/delay/index.js
var require_delay = __commonJS({
  "../../node_modules/delay/index.js"(exports2, module2) {
    "use strict";
    init_define_process();
    var randomInteger = (minimum, maximum) => Math.floor(Math.random() * (maximum - minimum + 1) + minimum);
    var createAbortError = () => {
      const error = new Error("Delay aborted");
      error.name = "AbortError";
      return error;
    };
    var createDelay = ({ clearTimeout: defaultClear, setTimeout: set, willResolve }) => (ms, { value: value2, signal } = {}) => {
      if (signal && signal.aborted) {
        return Promise.reject(createAbortError());
      }
      let timeoutId;
      let settle;
      let rejectFn;
      const clear = defaultClear || clearTimeout;
      const signalListener = () => {
        clear(timeoutId);
        rejectFn(createAbortError());
      };
      const cleanup = () => {
        if (signal) {
          signal.removeEventListener("abort", signalListener);
        }
      };
      const delayPromise = new Promise((resolve, reject) => {
        settle = () => {
          cleanup();
          if (willResolve) {
            resolve(value2);
          } else {
            reject(value2);
          }
        };
        rejectFn = reject;
        timeoutId = (set || setTimeout)(settle, ms);
      });
      if (signal) {
        signal.addEventListener("abort", signalListener, { once: true });
      }
      delayPromise.clear = () => {
        clear(timeoutId);
        timeoutId = null;
        settle();
      };
      return delayPromise;
    };
    var createWithTimers = (clearAndSet) => {
      const delay4 = createDelay({ ...clearAndSet, willResolve: true });
      delay4.reject = createDelay({ ...clearAndSet, willResolve: false });
      delay4.range = (minimum, maximum, options) => delay4(randomInteger(minimum, maximum), options);
      return delay4;
    };
    var delay3 = createWithTimers();
    delay3.createWithTimers = createWithTimers;
    module2.exports = delay3;
    module2.exports.default = delay3;
  }
});

// ../../node_modules/ipfs-core/dist/index.min.js
var index_min_exports = {};
var init_index_min = __esm({
  "../../node_modules/ipfs-core/dist/index.min.js"() {
    "use strict";
    init_define_process();
    (function(root, factory) {
      typeof module === "object" && module.exports ? module.exports = factory() : root.IpfsCore = factory();
    })(typeof self !== "undefined" ? self : void 0, function() {
      var IpfsCore = (() => {
        var npe = Object.create;
        var S4 = Object.defineProperty;
        var ipe = Object.getOwnPropertyDescriptor;
        var ope = Object.getOwnPropertyNames;
        var spe = Object.getPrototypeOf, ape = Object.prototype.hasOwnProperty;
        var jd = ((t) => typeof __require != "undefined" ? __require : typeof Proxy != "undefined" ? new Proxy(t, { get: (e, r) => (typeof __require != "undefined" ? __require : e)[r] }) : t)(function(t) {
          if (typeof __require != "undefined")
            return __require.apply(this, arguments);
          throw new Error('Dynamic require of "' + t + '" is not supported');
        });
        var Fe = (t, e) => () => (t && (e = t(t = 0)), e);
        var A = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), ct = (t, e) => {
          for (var r in e)
            S4(t, r, { get: e[r], enumerable: true });
        }, SN = (t, e, r, n) => {
          if (e && typeof e == "object" || typeof e == "function")
            for (let i2 of ope(e))
              !ape.call(t, i2) && i2 !== r && S4(t, i2, { get: () => e[i2], enumerable: !(n = ipe(e, i2)) || n.enumerable });
          return t;
        };
        var w = (t, e, r) => (r = t != null ? npe(spe(t)) : {}, SN(e || !t || !t.__esModule ? S4(r, "default", { value: t, enumerable: true }) : r, t)), cr = (t) => SN(S4({}, "__esModule", { value: true }), t);
        var AN = A((x4) => {
          "use strict";
          c();
          x4.byteLength = upe;
          x4.toByteArray = fpe;
          x4.fromByteArray = ppe;
          var fa = [], Mo = [], cpe = typeof Uint8Array < "u" ? Uint8Array : Array, C7 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (Nf = 0, xN = C7.length; Nf < xN; ++Nf)
            fa[Nf] = C7[Nf], Mo[C7.charCodeAt(Nf)] = Nf;
          var Nf, xN;
          Mo["-".charCodeAt(0)] = 62;
          Mo["_".charCodeAt(0)] = 63;
          function RN(t) {
            var e = t.length;
            if (e % 4 > 0)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r = t.indexOf("=");
            r === -1 && (r = e);
            var n = r === e ? 0 : 4 - r % 4;
            return [r, n];
          }
          function upe(t) {
            var e = RN(t), r = e[0], n = e[1];
            return (r + n) * 3 / 4 - n;
          }
          function lpe(t, e, r) {
            return (e + r) * 3 / 4 - r;
          }
          function fpe(t) {
            var e, r = RN(t), n = r[0], i2 = r[1], o = new cpe(lpe(t, n, i2)), s = 0, a = i2 > 0 ? n - 4 : n, u;
            for (u = 0; u < a; u += 4)
              e = Mo[t.charCodeAt(u)] << 18 | Mo[t.charCodeAt(u + 1)] << 12 | Mo[t.charCodeAt(u + 2)] << 6 | Mo[t.charCodeAt(u + 3)], o[s++] = e >> 16 & 255, o[s++] = e >> 8 & 255, o[s++] = e & 255;
            return i2 === 2 && (e = Mo[t.charCodeAt(u)] << 2 | Mo[t.charCodeAt(u + 1)] >> 4, o[s++] = e & 255), i2 === 1 && (e = Mo[t.charCodeAt(u)] << 10 | Mo[t.charCodeAt(u + 1)] << 4 | Mo[t.charCodeAt(u + 2)] >> 2, o[s++] = e >> 8 & 255, o[s++] = e & 255), o;
          }
          function hpe(t) {
            return fa[t >> 18 & 63] + fa[t >> 12 & 63] + fa[t >> 6 & 63] + fa[t & 63];
          }
          function dpe(t, e, r) {
            for (var n, i2 = [], o = e; o < r; o += 3)
              n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), i2.push(hpe(n));
            return i2.join("");
          }
          function ppe(t) {
            for (var e, r = t.length, n = r % 3, i2 = [], o = 16383, s = 0, a = r - n; s < a; s += o)
              i2.push(dpe(t, s, s + o > a ? a : s + o));
            return n === 1 ? (e = t[r - 1], i2.push(fa[e >> 2] + fa[e << 4 & 63] + "==")) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], i2.push(fa[e >> 10] + fa[e >> 4 & 63] + fa[e << 2 & 63] + "=")), i2.join("");
          }
        });
        var TN = A((P7) => {
          c();
          P7.read = function(t, e, r, n, i2) {
            var o, s, a = i2 * 8 - n - 1, u = (1 << a) - 1, l = u >> 1, f = -7, h = r ? i2 - 1 : 0, p = r ? -1 : 1, d = t[e + h];
            for (h += p, o = d & (1 << -f) - 1, d >>= -f, f += a; f > 0; o = o * 256 + t[e + h], h += p, f -= 8)
              ;
            for (s = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; s = s * 256 + t[e + h], h += p, f -= 8)
              ;
            if (o === 0)
              o = 1 - l;
            else {
              if (o === u)
                return s ? NaN : (d ? -1 : 1) * (1 / 0);
              s = s + Math.pow(2, n), o = o - l;
            }
            return (d ? -1 : 1) * s * Math.pow(2, o - n);
          };
          P7.write = function(t, e, r, n, i2, o) {
            var s, a, u, l = o * 8 - i2 - 1, f = (1 << l) - 1, h = f >> 1, p = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : o - 1, m = n ? 1 : -1, y = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
            for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = f) : (s = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), s + h >= 1 ? e += p / u : e += p * Math.pow(2, 1 - h), e * u >= 2 && (s++, u /= 2), s + h >= f ? (a = 0, s = f) : s + h >= 1 ? (a = (e * u - 1) * Math.pow(2, i2), s = s + h) : (a = e * Math.pow(2, h - 1) * Math.pow(2, i2), s = 0)); i2 >= 8; t[r + d] = a & 255, d += m, a /= 256, i2 -= 8)
              ;
            for (s = s << i2 | a, l += i2; l > 0; t[r + d] = s & 255, d += m, s /= 256, l -= 8)
              ;
            t[r + d - m] |= y * 128;
          };
        });
        var _i = A((Zd) => {
          "use strict";
          c();
          var D7 = AN(), Qd = TN(), IN = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          Zd.Buffer = $;
          Zd.SlowBuffer = bpe;
          Zd.INSPECT_MAX_BYTES = 50;
          var R4 = 2147483647;
          Zd.kMaxLength = R4;
          $.TYPED_ARRAY_SUPPORT = mpe();
          !$.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
          function mpe() {
            try {
              let t = new Uint8Array(1), e = { foo: function() {
                return 42;
              } };
              return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
            } catch {
              return false;
            }
          }
          Object.defineProperty($.prototype, "parent", { enumerable: true, get: function() {
            if (!!$.isBuffer(this))
              return this.buffer;
          } });
          Object.defineProperty($.prototype, "offset", { enumerable: true, get: function() {
            if (!!$.isBuffer(this))
              return this.byteOffset;
          } });
          function pc(t) {
            if (t > R4)
              throw new RangeError('The value "' + t + '" is invalid for option "size"');
            let e = new Uint8Array(t);
            return Object.setPrototypeOf(e, $.prototype), e;
          }
          function $(t, e, r) {
            if (typeof t == "number") {
              if (typeof e == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return L7(t);
            }
            return kN(t, e, r);
          }
          $.poolSize = 8192;
          function kN(t, e, r) {
            if (typeof t == "string")
              return gpe(t, e);
            if (ArrayBuffer.isView(t))
              return wpe(t);
            if (t == null)
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
            if (ha(t, ArrayBuffer) || t && ha(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ha(t, SharedArrayBuffer) || t && ha(t.buffer, SharedArrayBuffer)))
              return N72(t, e, r);
            if (typeof t == "number")
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            let n = t.valueOf && t.valueOf();
            if (n != null && n !== t)
              return $.from(n, e, r);
            let i2 = Epe(t);
            if (i2)
              return i2;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
              return $.from(t[Symbol.toPrimitive]("string"), e, r);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
          }
          $.from = function(t, e, r) {
            return kN(t, e, r);
          };
          Object.setPrototypeOf($.prototype, Uint8Array.prototype);
          Object.setPrototypeOf($, Uint8Array);
          function NN(t) {
            if (typeof t != "number")
              throw new TypeError('"size" argument must be of type number');
            if (t < 0)
              throw new RangeError('The value "' + t + '" is invalid for option "size"');
          }
          function ype(t, e, r) {
            return NN(t), t <= 0 ? pc(t) : e !== void 0 ? typeof r == "string" ? pc(t).fill(e, r) : pc(t).fill(e) : pc(t);
          }
          $.alloc = function(t, e, r) {
            return ype(t, e, r);
          };
          function L7(t) {
            return NN(t), pc(t < 0 ? 0 : B7(t) | 0);
          }
          $.allocUnsafe = function(t) {
            return L7(t);
          };
          $.allocUnsafeSlow = function(t) {
            return L7(t);
          };
          function gpe(t, e) {
            if ((typeof e != "string" || e === "") && (e = "utf8"), !$.isEncoding(e))
              throw new TypeError("Unknown encoding: " + e);
            let r = ON(t, e) | 0, n = pc(r), i2 = n.write(t, e);
            return i2 !== r && (n = n.slice(0, i2)), n;
          }
          function k7(t) {
            let e = t.length < 0 ? 0 : B7(t.length) | 0, r = pc(e);
            for (let n = 0; n < e; n += 1)
              r[n] = t[n] & 255;
            return r;
          }
          function wpe(t) {
            if (ha(t, Uint8Array)) {
              let e = new Uint8Array(t);
              return N72(e.buffer, e.byteOffset, e.byteLength);
            }
            return k7(t);
          }
          function N72(t, e, r) {
            if (e < 0 || t.byteLength < e)
              throw new RangeError('"offset" is outside of buffer bounds');
            if (t.byteLength < e + (r || 0))
              throw new RangeError('"length" is outside of buffer bounds');
            let n;
            return e === void 0 && r === void 0 ? n = new Uint8Array(t) : r === void 0 ? n = new Uint8Array(t, e) : n = new Uint8Array(t, e, r), Object.setPrototypeOf(n, $.prototype), n;
          }
          function Epe(t) {
            if ($.isBuffer(t)) {
              let e = B7(t.length) | 0, r = pc(e);
              return r.length === 0 || t.copy(r, 0, 0, e), r;
            }
            if (t.length !== void 0)
              return typeof t.length != "number" || U7(t.length) ? pc(0) : k7(t);
            if (t.type === "Buffer" && Array.isArray(t.data))
              return k7(t.data);
          }
          function B7(t) {
            if (t >= R4)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + R4.toString(16) + " bytes");
            return t | 0;
          }
          function bpe(t) {
            return +t != t && (t = 0), $.alloc(+t);
          }
          $.isBuffer = function(e) {
            return e != null && e._isBuffer === true && e !== $.prototype;
          };
          $.compare = function(e, r) {
            if (ha(e, Uint8Array) && (e = $.from(e, e.offset, e.byteLength)), ha(r, Uint8Array) && (r = $.from(r, r.offset, r.byteLength)), !$.isBuffer(e) || !$.isBuffer(r))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (e === r)
              return 0;
            let n = e.length, i2 = r.length;
            for (let o = 0, s = Math.min(n, i2); o < s; ++o)
              if (e[o] !== r[o]) {
                n = e[o], i2 = r[o];
                break;
              }
            return n < i2 ? -1 : i2 < n ? 1 : 0;
          };
          $.isEncoding = function(e) {
            switch (String(e).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          $.concat = function(e, r) {
            if (!Array.isArray(e))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (e.length === 0)
              return $.alloc(0);
            let n;
            if (r === void 0)
              for (r = 0, n = 0; n < e.length; ++n)
                r += e[n].length;
            let i2 = $.allocUnsafe(r), o = 0;
            for (n = 0; n < e.length; ++n) {
              let s = e[n];
              if (ha(s, Uint8Array))
                o + s.length > i2.length ? ($.isBuffer(s) || (s = $.from(s)), s.copy(i2, o)) : Uint8Array.prototype.set.call(i2, s, o);
              else if ($.isBuffer(s))
                s.copy(i2, o);
              else
                throw new TypeError('"list" argument must be an Array of Buffers');
              o += s.length;
            }
            return i2;
          };
          function ON(t, e) {
            if ($.isBuffer(t))
              return t.length;
            if (ArrayBuffer.isView(t) || ha(t, ArrayBuffer))
              return t.byteLength;
            if (typeof t != "string")
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
            let r = t.length, n = arguments.length > 2 && arguments[2] === true;
            if (!n && r === 0)
              return 0;
            let i2 = false;
            for (; ; )
              switch (e) {
                case "ascii":
                case "latin1":
                case "binary":
                  return r;
                case "utf8":
                case "utf-8":
                  return O7(t).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return r * 2;
                case "hex":
                  return r >>> 1;
                case "base64":
                  return zN(t).length;
                default:
                  if (i2)
                    return n ? -1 : O7(t).length;
                  e = ("" + e).toLowerCase(), i2 = true;
              }
          }
          $.byteLength = ON;
          function _pe(t, e, r) {
            let n = false;
            if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
              return "";
            for (t || (t = "utf8"); ; )
              switch (t) {
                case "hex":
                  return Dpe(this, e, r);
                case "utf8":
                case "utf-8":
                  return BN(this, e, r);
                case "ascii":
                  return Cpe(this, e, r);
                case "latin1":
                case "binary":
                  return Ppe(this, e, r);
                case "base64":
                  return Tpe(this, e, r);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return kpe(this, e, r);
                default:
                  if (n)
                    throw new TypeError("Unknown encoding: " + t);
                  t = (t + "").toLowerCase(), n = true;
              }
          }
          $.prototype._isBuffer = true;
          function Of(t, e, r) {
            let n = t[e];
            t[e] = t[r], t[r] = n;
          }
          $.prototype.swap16 = function() {
            let e = this.length;
            if (e % 2 !== 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let r = 0; r < e; r += 2)
              Of(this, r, r + 1);
            return this;
          };
          $.prototype.swap32 = function() {
            let e = this.length;
            if (e % 4 !== 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let r = 0; r < e; r += 4)
              Of(this, r, r + 3), Of(this, r + 1, r + 2);
            return this;
          };
          $.prototype.swap64 = function() {
            let e = this.length;
            if (e % 8 !== 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let r = 0; r < e; r += 8)
              Of(this, r, r + 7), Of(this, r + 1, r + 6), Of(this, r + 2, r + 5), Of(this, r + 3, r + 4);
            return this;
          };
          $.prototype.toString = function() {
            let e = this.length;
            return e === 0 ? "" : arguments.length === 0 ? BN(this, 0, e) : _pe.apply(this, arguments);
          };
          $.prototype.toLocaleString = $.prototype.toString;
          $.prototype.equals = function(e) {
            if (!$.isBuffer(e))
              throw new TypeError("Argument must be a Buffer");
            return this === e ? true : $.compare(this, e) === 0;
          };
          $.prototype.inspect = function() {
            let e = "", r = Zd.INSPECT_MAX_BYTES;
            return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
          };
          IN && ($.prototype[IN] = $.prototype.inspect);
          $.prototype.compare = function(e, r, n, i2, o) {
            if (ha(e, Uint8Array) && (e = $.from(e, e.offset, e.byteLength)), !$.isBuffer(e))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
            if (r === void 0 && (r = 0), n === void 0 && (n = e ? e.length : 0), i2 === void 0 && (i2 = 0), o === void 0 && (o = this.length), r < 0 || n > e.length || i2 < 0 || o > this.length)
              throw new RangeError("out of range index");
            if (i2 >= o && r >= n)
              return 0;
            if (i2 >= o)
              return -1;
            if (r >= n)
              return 1;
            if (r >>>= 0, n >>>= 0, i2 >>>= 0, o >>>= 0, this === e)
              return 0;
            let s = o - i2, a = n - r, u = Math.min(s, a), l = this.slice(i2, o), f = e.slice(r, n);
            for (let h = 0; h < u; ++h)
              if (l[h] !== f[h]) {
                s = l[h], a = f[h];
                break;
              }
            return s < a ? -1 : a < s ? 1 : 0;
          };
          function LN(t, e, r, n, i2) {
            if (t.length === 0)
              return -1;
            if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, U7(r) && (r = i2 ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
              if (i2)
                return -1;
              r = t.length - 1;
            } else if (r < 0)
              if (i2)
                r = 0;
              else
                return -1;
            if (typeof e == "string" && (e = $.from(e, n)), $.isBuffer(e))
              return e.length === 0 ? -1 : CN(t, e, r, n, i2);
            if (typeof e == "number")
              return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i2 ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : CN(t, [e], r, n, i2);
            throw new TypeError("val must be string, number or Buffer");
          }
          function CN(t, e, r, n, i2) {
            let o = 1, s = t.length, a = e.length;
            if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
              if (t.length < 2 || e.length < 2)
                return -1;
              o = 2, s /= 2, a /= 2, r /= 2;
            }
            function u(f, h) {
              return o === 1 ? f[h] : f.readUInt16BE(h * o);
            }
            let l;
            if (i2) {
              let f = -1;
              for (l = r; l < s; l++)
                if (u(t, l) === u(e, f === -1 ? 0 : l - f)) {
                  if (f === -1 && (f = l), l - f + 1 === a)
                    return f * o;
                } else
                  f !== -1 && (l -= l - f), f = -1;
            } else
              for (r + a > s && (r = s - a), l = r; l >= 0; l--) {
                let f = true;
                for (let h = 0; h < a; h++)
                  if (u(t, l + h) !== u(e, h)) {
                    f = false;
                    break;
                  }
                if (f)
                  return l;
              }
            return -1;
          }
          $.prototype.includes = function(e, r, n) {
            return this.indexOf(e, r, n) !== -1;
          };
          $.prototype.indexOf = function(e, r, n) {
            return LN(this, e, r, n, true);
          };
          $.prototype.lastIndexOf = function(e, r, n) {
            return LN(this, e, r, n, false);
          };
          function vpe(t, e, r, n) {
            r = Number(r) || 0;
            let i2 = t.length - r;
            n ? (n = Number(n), n > i2 && (n = i2)) : n = i2;
            let o = e.length;
            n > o / 2 && (n = o / 2);
            let s;
            for (s = 0; s < n; ++s) {
              let a = parseInt(e.substr(s * 2, 2), 16);
              if (U7(a))
                return s;
              t[r + s] = a;
            }
            return s;
          }
          function Spe(t, e, r, n) {
            return A4(O7(e, t.length - r), t, r, n);
          }
          function xpe(t, e, r, n) {
            return A4(Bpe(e), t, r, n);
          }
          function Rpe(t, e, r, n) {
            return A4(zN(e), t, r, n);
          }
          function Ape(t, e, r, n) {
            return A4(Mpe(e, t.length - r), t, r, n);
          }
          $.prototype.write = function(e, r, n, i2) {
            if (r === void 0)
              i2 = "utf8", n = this.length, r = 0;
            else if (n === void 0 && typeof r == "string")
              i2 = r, n = this.length, r = 0;
            else if (isFinite(r))
              r = r >>> 0, isFinite(n) ? (n = n >>> 0, i2 === void 0 && (i2 = "utf8")) : (i2 = n, n = void 0);
            else
              throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            let o = this.length - r;
            if ((n === void 0 || n > o) && (n = o), e.length > 0 && (n < 0 || r < 0) || r > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            i2 || (i2 = "utf8");
            let s = false;
            for (; ; )
              switch (i2) {
                case "hex":
                  return vpe(this, e, r, n);
                case "utf8":
                case "utf-8":
                  return Spe(this, e, r, n);
                case "ascii":
                case "latin1":
                case "binary":
                  return xpe(this, e, r, n);
                case "base64":
                  return Rpe(this, e, r, n);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return Ape(this, e, r, n);
                default:
                  if (s)
                    throw new TypeError("Unknown encoding: " + i2);
                  i2 = ("" + i2).toLowerCase(), s = true;
              }
          };
          $.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          function Tpe(t, e, r) {
            return e === 0 && r === t.length ? D7.fromByteArray(t) : D7.fromByteArray(t.slice(e, r));
          }
          function BN(t, e, r) {
            r = Math.min(t.length, r);
            let n = [], i2 = e;
            for (; i2 < r; ) {
              let o = t[i2], s = null, a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
              if (i2 + a <= r) {
                let u, l, f, h;
                switch (a) {
                  case 1:
                    o < 128 && (s = o);
                    break;
                  case 2:
                    u = t[i2 + 1], (u & 192) === 128 && (h = (o & 31) << 6 | u & 63, h > 127 && (s = h));
                    break;
                  case 3:
                    u = t[i2 + 1], l = t[i2 + 2], (u & 192) === 128 && (l & 192) === 128 && (h = (o & 15) << 12 | (u & 63) << 6 | l & 63, h > 2047 && (h < 55296 || h > 57343) && (s = h));
                    break;
                  case 4:
                    u = t[i2 + 1], l = t[i2 + 2], f = t[i2 + 3], (u & 192) === 128 && (l & 192) === 128 && (f & 192) === 128 && (h = (o & 15) << 18 | (u & 63) << 12 | (l & 63) << 6 | f & 63, h > 65535 && h < 1114112 && (s = h));
                }
              }
              s === null ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), i2 += a;
            }
            return Ipe(n);
          }
          var PN = 4096;
          function Ipe(t) {
            let e = t.length;
            if (e <= PN)
              return String.fromCharCode.apply(String, t);
            let r = "", n = 0;
            for (; n < e; )
              r += String.fromCharCode.apply(String, t.slice(n, n += PN));
            return r;
          }
          function Cpe(t, e, r) {
            let n = "";
            r = Math.min(t.length, r);
            for (let i2 = e; i2 < r; ++i2)
              n += String.fromCharCode(t[i2] & 127);
            return n;
          }
          function Ppe(t, e, r) {
            let n = "";
            r = Math.min(t.length, r);
            for (let i2 = e; i2 < r; ++i2)
              n += String.fromCharCode(t[i2]);
            return n;
          }
          function Dpe(t, e, r) {
            let n = t.length;
            (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
            let i2 = "";
            for (let o = e; o < r; ++o)
              i2 += Upe[t[o]];
            return i2;
          }
          function kpe(t, e, r) {
            let n = t.slice(e, r), i2 = "";
            for (let o = 0; o < n.length - 1; o += 2)
              i2 += String.fromCharCode(n[o] + n[o + 1] * 256);
            return i2;
          }
          $.prototype.slice = function(e, r) {
            let n = this.length;
            e = ~~e, r = r === void 0 ? n : ~~r, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < e && (r = e);
            let i2 = this.subarray(e, r);
            return Object.setPrototypeOf(i2, $.prototype), i2;
          };
          function kn(t, e, r) {
            if (t % 1 !== 0 || t < 0)
              throw new RangeError("offset is not uint");
            if (t + e > r)
              throw new RangeError("Trying to access beyond buffer length");
          }
          $.prototype.readUintLE = $.prototype.readUIntLE = function(e, r, n) {
            e = e >>> 0, r = r >>> 0, n || kn(e, r, this.length);
            let i2 = this[e], o = 1, s = 0;
            for (; ++s < r && (o *= 256); )
              i2 += this[e + s] * o;
            return i2;
          };
          $.prototype.readUintBE = $.prototype.readUIntBE = function(e, r, n) {
            e = e >>> 0, r = r >>> 0, n || kn(e, r, this.length);
            let i2 = this[e + --r], o = 1;
            for (; r > 0 && (o *= 256); )
              i2 += this[e + --r] * o;
            return i2;
          };
          $.prototype.readUint8 = $.prototype.readUInt8 = function(e, r) {
            return e = e >>> 0, r || kn(e, 1, this.length), this[e];
          };
          $.prototype.readUint16LE = $.prototype.readUInt16LE = function(e, r) {
            return e = e >>> 0, r || kn(e, 2, this.length), this[e] | this[e + 1] << 8;
          };
          $.prototype.readUint16BE = $.prototype.readUInt16BE = function(e, r) {
            return e = e >>> 0, r || kn(e, 2, this.length), this[e] << 8 | this[e + 1];
          };
          $.prototype.readUint32LE = $.prototype.readUInt32LE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
          };
          $.prototype.readUint32BE = $.prototype.readUInt32BE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
          };
          $.prototype.readBigUInt64LE = Bu(function(e) {
            e = e >>> 0, Xd(e, "offset");
            let r = this[e], n = this[e + 7];
            (r === void 0 || n === void 0) && Fm(e, this.length - 8);
            let i2 = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, o = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
            return BigInt(i2) + (BigInt(o) << BigInt(32));
          });
          $.prototype.readBigUInt64BE = Bu(function(e) {
            e = e >>> 0, Xd(e, "offset");
            let r = this[e], n = this[e + 7];
            (r === void 0 || n === void 0) && Fm(e, this.length - 8);
            let i2 = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], o = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
            return (BigInt(i2) << BigInt(32)) + BigInt(o);
          });
          $.prototype.readIntLE = function(e, r, n) {
            e = e >>> 0, r = r >>> 0, n || kn(e, r, this.length);
            let i2 = this[e], o = 1, s = 0;
            for (; ++s < r && (o *= 256); )
              i2 += this[e + s] * o;
            return o *= 128, i2 >= o && (i2 -= Math.pow(2, 8 * r)), i2;
          };
          $.prototype.readIntBE = function(e, r, n) {
            e = e >>> 0, r = r >>> 0, n || kn(e, r, this.length);
            let i2 = r, o = 1, s = this[e + --i2];
            for (; i2 > 0 && (o *= 256); )
              s += this[e + --i2] * o;
            return o *= 128, s >= o && (s -= Math.pow(2, 8 * r)), s;
          };
          $.prototype.readInt8 = function(e, r) {
            return e = e >>> 0, r || kn(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
          };
          $.prototype.readInt16LE = function(e, r) {
            e = e >>> 0, r || kn(e, 2, this.length);
            let n = this[e] | this[e + 1] << 8;
            return n & 32768 ? n | 4294901760 : n;
          };
          $.prototype.readInt16BE = function(e, r) {
            e = e >>> 0, r || kn(e, 2, this.length);
            let n = this[e + 1] | this[e] << 8;
            return n & 32768 ? n | 4294901760 : n;
          };
          $.prototype.readInt32LE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
          };
          $.prototype.readInt32BE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
          };
          $.prototype.readBigInt64LE = Bu(function(e) {
            e = e >>> 0, Xd(e, "offset");
            let r = this[e], n = this[e + 7];
            (r === void 0 || n === void 0) && Fm(e, this.length - 8);
            let i2 = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
            return (BigInt(i2) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
          });
          $.prototype.readBigInt64BE = Bu(function(e) {
            e = e >>> 0, Xd(e, "offset");
            let r = this[e], n = this[e + 7];
            (r === void 0 || n === void 0) && Fm(e, this.length - 8);
            let i2 = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
            return (BigInt(i2) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n);
          });
          $.prototype.readFloatLE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), Qd.read(this, e, true, 23, 4);
          };
          $.prototype.readFloatBE = function(e, r) {
            return e = e >>> 0, r || kn(e, 4, this.length), Qd.read(this, e, false, 23, 4);
          };
          $.prototype.readDoubleLE = function(e, r) {
            return e = e >>> 0, r || kn(e, 8, this.length), Qd.read(this, e, true, 52, 8);
          };
          $.prototype.readDoubleBE = function(e, r) {
            return e = e >>> 0, r || kn(e, 8, this.length), Qd.read(this, e, false, 52, 8);
          };
          function Bi(t, e, r, n, i2, o) {
            if (!$.isBuffer(t))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (e > i2 || e < o)
              throw new RangeError('"value" argument is out of bounds');
            if (r + n > t.length)
              throw new RangeError("Index out of range");
          }
          $.prototype.writeUintLE = $.prototype.writeUIntLE = function(e, r, n, i2) {
            if (e = +e, r = r >>> 0, n = n >>> 0, !i2) {
              let a = Math.pow(2, 8 * n) - 1;
              Bi(this, e, r, n, a, 0);
            }
            let o = 1, s = 0;
            for (this[r] = e & 255; ++s < n && (o *= 256); )
              this[r + s] = e / o & 255;
            return r + n;
          };
          $.prototype.writeUintBE = $.prototype.writeUIntBE = function(e, r, n, i2) {
            if (e = +e, r = r >>> 0, n = n >>> 0, !i2) {
              let a = Math.pow(2, 8 * n) - 1;
              Bi(this, e, r, n, a, 0);
            }
            let o = n - 1, s = 1;
            for (this[r + o] = e & 255; --o >= 0 && (s *= 256); )
              this[r + o] = e / s & 255;
            return r + n;
          };
          $.prototype.writeUint8 = $.prototype.writeUInt8 = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
          };
          $.prototype.writeUint16LE = $.prototype.writeUInt16LE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
          };
          $.prototype.writeUint16BE = $.prototype.writeUInt16BE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
          };
          $.prototype.writeUint32LE = $.prototype.writeUInt32LE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
          };
          $.prototype.writeUint32BE = $.prototype.writeUInt32BE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
          };
          function MN(t, e, r, n, i2) {
            qN(e, n, i2, t, r, 7);
            let o = Number(e & BigInt(4294967295));
            t[r++] = o, o = o >> 8, t[r++] = o, o = o >> 8, t[r++] = o, o = o >> 8, t[r++] = o;
            let s = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, r;
          }
          function UN(t, e, r, n, i2) {
            qN(e, n, i2, t, r, 7);
            let o = Number(e & BigInt(4294967295));
            t[r + 7] = o, o = o >> 8, t[r + 6] = o, o = o >> 8, t[r + 5] = o, o = o >> 8, t[r + 4] = o;
            let s = Number(e >> BigInt(32) & BigInt(4294967295));
            return t[r + 3] = s, s = s >> 8, t[r + 2] = s, s = s >> 8, t[r + 1] = s, s = s >> 8, t[r] = s, r + 8;
          }
          $.prototype.writeBigUInt64LE = Bu(function(e, r = 0) {
            return MN(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
          });
          $.prototype.writeBigUInt64BE = Bu(function(e, r = 0) {
            return UN(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
          });
          $.prototype.writeIntLE = function(e, r, n, i2) {
            if (e = +e, r = r >>> 0, !i2) {
              let u = Math.pow(2, 8 * n - 1);
              Bi(this, e, r, n, u - 1, -u);
            }
            let o = 0, s = 1, a = 0;
            for (this[r] = e & 255; ++o < n && (s *= 256); )
              e < 0 && a === 0 && this[r + o - 1] !== 0 && (a = 1), this[r + o] = (e / s >> 0) - a & 255;
            return r + n;
          };
          $.prototype.writeIntBE = function(e, r, n, i2) {
            if (e = +e, r = r >>> 0, !i2) {
              let u = Math.pow(2, 8 * n - 1);
              Bi(this, e, r, n, u - 1, -u);
            }
            let o = n - 1, s = 1, a = 0;
            for (this[r + o] = e & 255; --o >= 0 && (s *= 256); )
              e < 0 && a === 0 && this[r + o + 1] !== 0 && (a = 1), this[r + o] = (e / s >> 0) - a & 255;
            return r + n;
          };
          $.prototype.writeInt8 = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
          };
          $.prototype.writeInt16LE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
          };
          $.prototype.writeInt16BE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
          };
          $.prototype.writeInt32LE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
          };
          $.prototype.writeInt32BE = function(e, r, n) {
            return e = +e, r = r >>> 0, n || Bi(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
          };
          $.prototype.writeBigInt64LE = Bu(function(e, r = 0) {
            return MN(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          });
          $.prototype.writeBigInt64BE = Bu(function(e, r = 0) {
            return UN(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
          });
          function FN(t, e, r, n, i2, o) {
            if (r + n > t.length)
              throw new RangeError("Index out of range");
            if (r < 0)
              throw new RangeError("Index out of range");
          }
          function KN(t, e, r, n, i2) {
            return e = +e, r = r >>> 0, i2 || FN(t, e, r, 4, 34028234663852886e22, -34028234663852886e22), Qd.write(t, e, r, n, 23, 4), r + 4;
          }
          $.prototype.writeFloatLE = function(e, r, n) {
            return KN(this, e, r, true, n);
          };
          $.prototype.writeFloatBE = function(e, r, n) {
            return KN(this, e, r, false, n);
          };
          function VN(t, e, r, n, i2) {
            return e = +e, r = r >>> 0, i2 || FN(t, e, r, 8, 17976931348623157e292, -17976931348623157e292), Qd.write(t, e, r, n, 52, 8), r + 8;
          }
          $.prototype.writeDoubleLE = function(e, r, n) {
            return VN(this, e, r, true, n);
          };
          $.prototype.writeDoubleBE = function(e, r, n) {
            return VN(this, e, r, false, n);
          };
          $.prototype.copy = function(e, r, n, i2) {
            if (!$.isBuffer(e))
              throw new TypeError("argument should be a Buffer");
            if (n || (n = 0), !i2 && i2 !== 0 && (i2 = this.length), r >= e.length && (r = e.length), r || (r = 0), i2 > 0 && i2 < n && (i2 = n), i2 === n || e.length === 0 || this.length === 0)
              return 0;
            if (r < 0)
              throw new RangeError("targetStart out of bounds");
            if (n < 0 || n >= this.length)
              throw new RangeError("Index out of range");
            if (i2 < 0)
              throw new RangeError("sourceEnd out of bounds");
            i2 > this.length && (i2 = this.length), e.length - r < i2 - n && (i2 = e.length - r + n);
            let o = i2 - n;
            return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i2) : Uint8Array.prototype.set.call(e, this.subarray(n, i2), r), o;
          };
          $.prototype.fill = function(e, r, n, i2) {
            if (typeof e == "string") {
              if (typeof r == "string" ? (i2 = r, r = 0, n = this.length) : typeof n == "string" && (i2 = n, n = this.length), i2 !== void 0 && typeof i2 != "string")
                throw new TypeError("encoding must be a string");
              if (typeof i2 == "string" && !$.isEncoding(i2))
                throw new TypeError("Unknown encoding: " + i2);
              if (e.length === 1) {
                let s = e.charCodeAt(0);
                (i2 === "utf8" && s < 128 || i2 === "latin1") && (e = s);
              }
            } else
              typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
            if (r < 0 || this.length < r || this.length < n)
              throw new RangeError("Out of range index");
            if (n <= r)
              return this;
            r = r >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
            let o;
            if (typeof e == "number")
              for (o = r; o < n; ++o)
                this[o] = e;
            else {
              let s = $.isBuffer(e) ? e : $.from(e, i2), a = s.length;
              if (a === 0)
                throw new TypeError('The value "' + e + '" is invalid for argument "value"');
              for (o = 0; o < n - r; ++o)
                this[o + r] = s[o % a];
            }
            return this;
          };
          var Yd = {};
          function M7(t, e, r) {
            Yd[t] = class extends r {
              constructor() {
                super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
              }
              get code() {
                return t;
              }
              set code(i2) {
                Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i2, writable: true });
              }
              toString() {
                return `${this.name} [${t}]: ${this.message}`;
              }
            };
          }
          M7("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
            return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
          }, RangeError);
          M7("ERR_INVALID_ARG_TYPE", function(t, e) {
            return `The "${t}" argument must be of type number. Received type ${typeof e}`;
          }, TypeError);
          M7("ERR_OUT_OF_RANGE", function(t, e, r) {
            let n = `The value of "${t}" is out of range.`, i2 = r;
            return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i2 = DN(String(r)) : typeof r == "bigint" && (i2 = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i2 = DN(i2)), i2 += "n"), n += ` It must be ${e}. Received ${i2}`, n;
          }, RangeError);
          function DN(t) {
            let e = "", r = t.length, n = t[0] === "-" ? 1 : 0;
            for (; r >= n + 4; r -= 3)
              e = `_${t.slice(r - 3, r)}${e}`;
            return `${t.slice(0, r)}${e}`;
          }
          function Npe(t, e, r) {
            Xd(e, "offset"), (t[e] === void 0 || t[e + r] === void 0) && Fm(e, t.length - (r + 1));
          }
          function qN(t, e, r, n, i2, o) {
            if (t > r || t < e) {
              let s = typeof e == "bigint" ? "n" : "", a;
              throw o > 3 ? e === 0 || e === BigInt(0) ? a = `>= 0${s} and < 2${s} ** ${(o + 1) * 8}${s}` : a = `>= -(2${s} ** ${(o + 1) * 8 - 1}${s}) and < 2 ** ${(o + 1) * 8 - 1}${s}` : a = `>= ${e}${s} and <= ${r}${s}`, new Yd.ERR_OUT_OF_RANGE("value", a, t);
            }
            Npe(n, i2, o);
          }
          function Xd(t, e) {
            if (typeof t != "number")
              throw new Yd.ERR_INVALID_ARG_TYPE(e, "number", t);
          }
          function Fm(t, e, r) {
            throw Math.floor(t) !== t ? (Xd(t, r), new Yd.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new Yd.ERR_BUFFER_OUT_OF_BOUNDS() : new Yd.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
          }
          var Ope = /[^+/0-9A-Za-z-_]/g;
          function Lpe(t) {
            if (t = t.split("=")[0], t = t.trim().replace(Ope, ""), t.length < 2)
              return "";
            for (; t.length % 4 !== 0; )
              t = t + "=";
            return t;
          }
          function O7(t, e) {
            e = e || 1 / 0;
            let r, n = t.length, i2 = null, o = [];
            for (let s = 0; s < n; ++s) {
              if (r = t.charCodeAt(s), r > 55295 && r < 57344) {
                if (!i2) {
                  if (r > 56319) {
                    (e -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  } else if (s + 1 === n) {
                    (e -= 3) > -1 && o.push(239, 191, 189);
                    continue;
                  }
                  i2 = r;
                  continue;
                }
                if (r < 56320) {
                  (e -= 3) > -1 && o.push(239, 191, 189), i2 = r;
                  continue;
                }
                r = (i2 - 55296 << 10 | r - 56320) + 65536;
              } else
                i2 && (e -= 3) > -1 && o.push(239, 191, 189);
              if (i2 = null, r < 128) {
                if ((e -= 1) < 0)
                  break;
                o.push(r);
              } else if (r < 2048) {
                if ((e -= 2) < 0)
                  break;
                o.push(r >> 6 | 192, r & 63 | 128);
              } else if (r < 65536) {
                if ((e -= 3) < 0)
                  break;
                o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
              } else if (r < 1114112) {
                if ((e -= 4) < 0)
                  break;
                o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
              } else
                throw new Error("Invalid code point");
            }
            return o;
          }
          function Bpe(t) {
            let e = [];
            for (let r = 0; r < t.length; ++r)
              e.push(t.charCodeAt(r) & 255);
            return e;
          }
          function Mpe(t, e) {
            let r, n, i2, o = [];
            for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
              r = t.charCodeAt(s), n = r >> 8, i2 = r % 256, o.push(i2), o.push(n);
            return o;
          }
          function zN(t) {
            return D7.toByteArray(Lpe(t));
          }
          function A4(t, e, r, n) {
            let i2;
            for (i2 = 0; i2 < n && !(i2 + r >= e.length || i2 >= t.length); ++i2)
              e[i2 + r] = t[i2];
            return i2;
          }
          function ha(t, e) {
            return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
          }
          function U7(t) {
            return t !== t;
          }
          var Upe = function() {
            let t = "0123456789abcdef", e = new Array(256);
            for (let r = 0; r < 16; ++r) {
              let n = r * 16;
              for (let i2 = 0; i2 < 16; ++i2)
                e[n + i2] = t[r] + t[i2];
            }
            return e;
          }();
          function Bu(t) {
            return typeof BigInt > "u" ? Fpe : t;
          }
          function Fpe() {
            throw new Error("BigInt not supported");
          }
        });
        var jN = A(($Le, WN) => {
          c();
          var tn = WN.exports = {}, da, pa;
          function F7() {
            throw new Error("setTimeout has not been defined");
          }
          function K7() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              typeof setTimeout == "function" ? da = setTimeout : da = F7;
            } catch {
              da = F7;
            }
            try {
              typeof clearTimeout == "function" ? pa = clearTimeout : pa = K7;
            } catch {
              pa = K7;
            }
          })();
          function HN(t) {
            if (da === setTimeout)
              return setTimeout(t, 0);
            if ((da === F7 || !da) && setTimeout)
              return da = setTimeout, setTimeout(t, 0);
            try {
              return da(t, 0);
            } catch {
              try {
                return da.call(null, t, 0);
              } catch {
                return da.call(this, t, 0);
              }
            }
          }
          function Kpe(t) {
            if (pa === clearTimeout)
              return clearTimeout(t);
            if ((pa === K7 || !pa) && clearTimeout)
              return pa = clearTimeout, clearTimeout(t);
            try {
              return pa(t);
            } catch {
              try {
                return pa.call(null, t);
              } catch {
                return pa.call(this, t);
              }
            }
          }
          var mc = [], Jd = false, Lf, T4 = -1;
          function Vpe() {
            !Jd || !Lf || (Jd = false, Lf.length ? mc = Lf.concat(mc) : T4 = -1, mc.length && $N());
          }
          function $N() {
            if (!Jd) {
              var t = HN(Vpe);
              Jd = true;
              for (var e = mc.length; e; ) {
                for (Lf = mc, mc = []; ++T4 < e; )
                  Lf && Lf[T4].run();
                T4 = -1, e = mc.length;
              }
              Lf = null, Jd = false, Kpe(t);
            }
          }
          tn.nextTick = function(t) {
            var e = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var r = 1; r < arguments.length; r++)
                e[r - 1] = arguments[r];
            mc.push(new GN(t, e)), mc.length === 1 && !Jd && HN($N);
          };
          function GN(t, e) {
            this.fun = t, this.array = e;
          }
          GN.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          tn.title = "browser";
          tn.browser = true;
          tn.env = {};
          tn.argv = [];
          tn.version = "";
          tn.versions = {};
          function yc() {
          }
          tn.on = yc;
          tn.addListener = yc;
          tn.once = yc;
          tn.off = yc;
          tn.removeListener = yc;
          tn.removeAllListeners = yc;
          tn.emit = yc;
          tn.prependListener = yc;
          tn.prependOnceListener = yc;
          tn.listeners = function(t) {
            return [];
          };
          tn.binding = function(t) {
            throw new Error("process.binding is not supported");
          };
          tn.cwd = function() {
            return "/";
          };
          tn.chdir = function(t) {
            throw new Error("process.chdir is not supported");
          };
          tn.umask = function() {
            return 0;
          };
        });
        var Buffer, process, c = Fe(() => {
          ({ Buffer } = _i()), process = jN();
        });
        var V7 = A((WLe, YN) => {
          "use strict";
          c();
          YN.exports = (t) => {
            if (Object.prototype.toString.call(t) !== "[object Object]")
              return false;
            let e = Object.getPrototypeOf(t);
            return e === null || e === Object.prototype;
          };
        });
        var z7 = A((JN, eO) => {
          "use strict";
          c();
          var I4 = V7(), { hasOwnProperty: XN } = Object.prototype, { propertyIsEnumerable: qpe } = Object, ep = (t, e, r) => Object.defineProperty(t, e, { value: r, writable: true, enumerable: true, configurable: true }), zpe = JN, QN = { concatArrays: false, ignoreUndefined: false }, C4 = (t) => {
            let e = [];
            for (let r in t)
              XN.call(t, r) && e.push(r);
            if (Object.getOwnPropertySymbols) {
              let r = Object.getOwnPropertySymbols(t);
              for (let n of r)
                qpe.call(t, n) && e.push(n);
            }
            return e;
          };
          function tp(t) {
            return Array.isArray(t) ? Hpe(t) : I4(t) ? $pe(t) : t;
          }
          function Hpe(t) {
            let e = t.slice(0, 0);
            return C4(t).forEach((r) => {
              ep(e, r, tp(t[r]));
            }), e;
          }
          function $pe(t) {
            let e = Object.getPrototypeOf(t) === null ? /* @__PURE__ */ Object.create(null) : {};
            return C4(t).forEach((r) => {
              ep(e, r, tp(t[r]));
            }), e;
          }
          var ZN = (t, e, r, n) => (r.forEach((i2) => {
            typeof e[i2] > "u" && n.ignoreUndefined || (i2 in t && t[i2] !== Object.getPrototypeOf(t) ? ep(t, i2, q7(t[i2], e[i2], n)) : ep(t, i2, tp(e[i2])));
          }), t), Gpe = (t, e, r) => {
            let n = t.slice(0, 0), i2 = 0;
            return [t, e].forEach((o) => {
              let s = [];
              for (let a = 0; a < o.length; a++)
                !XN.call(o, a) || (s.push(String(a)), o === t ? ep(n, i2++, o[a]) : ep(n, i2++, tp(o[a])));
              n = ZN(n, o, C4(o).filter((a) => !s.includes(a)), r);
            }), n;
          };
          function q7(t, e, r) {
            return r.concatArrays && Array.isArray(t) && Array.isArray(e) ? Gpe(t, e, r) : !I4(e) || !I4(t) ? tp(e) : ZN(t, e, C4(e), r);
          }
          eO.exports = function(...t) {
            let e = q7(tp(QN), this !== zpe && this || {}, QN), r = { _: {} };
            for (let n of t)
              if (n !== void 0) {
                if (!I4(n))
                  throw new TypeError("`" + n + "` is not an Option Object");
                r = q7(r, { _: n }, e);
              }
            return r._;
          };
        });
        var H7 = A((YLe, rO) => {
          c();
          function Wpe() {
            return typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && !!process.versions.electron || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0;
          }
          rO.exports = Wpe;
        });
        var $7 = A((QLe, nO) => {
          "use strict";
          c();
          var jpe = H7(), P4 = typeof window == "object" && typeof document == "object" && document.nodeType === 9, Km = jpe(), Ype = P4 && !Km, Qpe = Km && !P4, Xpe = Km && P4, Zpe = typeof jd == "function" && typeof process < "u" && typeof process.release < "u" && process.release.name === "node" && !Km, Jpe = typeof importScripts == "function" && typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, e0e = typeof process < "u" && typeof process.env < "u" && false, t0e = typeof navigator < "u" && navigator.product === "ReactNative";
          nO.exports = { isTest: e0e, isElectron: Km, isElectronMain: Qpe, isElectronRenderer: Xpe, isNode: Zpe, isBrowser: Ype, isWebWorker: Jpe, isEnvWithDom: P4, isReactNative: t0e };
        });
        var G7 = A((XLe, iO) => {
          c();
          var rp = 1e3, np = rp * 60, ip = np * 60, Bf = ip * 24, r0e = Bf * 7, n0e = Bf * 365.25;
          iO.exports = function(t, e) {
            e = e || {};
            var r = typeof t;
            if (r === "string" && t.length > 0)
              return i0e(t);
            if (r === "number" && isFinite(t))
              return e.long ? s0e(t) : o0e(t);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
          };
          function i0e(t) {
            if (t = String(t), !(t.length > 100)) {
              var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
              if (!!e) {
                var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
                switch (n) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return r * n0e;
                  case "weeks":
                  case "week":
                  case "w":
                    return r * r0e;
                  case "days":
                  case "day":
                  case "d":
                    return r * Bf;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return r * ip;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return r * np;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return r * rp;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return r;
                  default:
                    return;
                }
              }
            }
          }
          function o0e(t) {
            var e = Math.abs(t);
            return e >= Bf ? Math.round(t / Bf) + "d" : e >= ip ? Math.round(t / ip) + "h" : e >= np ? Math.round(t / np) + "m" : e >= rp ? Math.round(t / rp) + "s" : t + "ms";
          }
          function s0e(t) {
            var e = Math.abs(t);
            return e >= Bf ? D4(t, e, Bf, "day") : e >= ip ? D4(t, e, ip, "hour") : e >= np ? D4(t, e, np, "minute") : e >= rp ? D4(t, e, rp, "second") : t + " ms";
          }
          function D4(t, e, r, n) {
            var i2 = e >= r * 1.5;
            return Math.round(t / r) + " " + n + (i2 ? "s" : "");
          }
        });
        var sO = A((ZLe, oO) => {
          c();
          function a0e(t) {
            r.debug = r, r.default = r, r.coerce = u, r.disable = o, r.enable = i2, r.enabled = s, r.humanize = G7(), r.destroy = l, Object.keys(t).forEach((f) => {
              r[f] = t[f];
            }), r.names = [], r.skips = [], r.formatters = {};
            function e(f) {
              let h = 0;
              for (let p = 0; p < f.length; p++)
                h = (h << 5) - h + f.charCodeAt(p), h |= 0;
              return r.colors[Math.abs(h) % r.colors.length];
            }
            r.selectColor = e;
            function r(f) {
              let h, p = null, d, m;
              function y(...g) {
                if (!y.enabled)
                  return;
                let E = y, b = Number(new Date()), v = b - (h || b);
                E.diff = v, E.prev = h, E.curr = b, h = b, g[0] = r.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
                let S = 0;
                g[0] = g[0].replace(/%([a-zA-Z%])/g, (T, R) => {
                  if (T === "%%")
                    return "%";
                  S++;
                  let O = r.formatters[R];
                  if (typeof O == "function") {
                    let F = g[S];
                    T = O.call(E, F), g.splice(S, 1), S--;
                  }
                  return T;
                }), r.formatArgs.call(E, g), (E.log || r.log).apply(E, g);
              }
              return y.namespace = f, y.useColors = r.useColors(), y.color = r.selectColor(f), y.extend = n, y.destroy = r.destroy, Object.defineProperty(y, "enabled", { enumerable: true, configurable: false, get: () => p !== null ? p : (d !== r.namespaces && (d = r.namespaces, m = r.enabled(f)), m), set: (g) => {
                p = g;
              } }), typeof r.init == "function" && r.init(y), y;
            }
            function n(f, h) {
              let p = r(this.namespace + (typeof h > "u" ? ":" : h) + f);
              return p.log = this.log, p;
            }
            function i2(f) {
              r.save(f), r.namespaces = f, r.names = [], r.skips = [];
              let h, p = (typeof f == "string" ? f : "").split(/[\s,]+/), d = p.length;
              for (h = 0; h < d; h++)
                !p[h] || (f = p[h].replace(/\*/g, ".*?"), f[0] === "-" ? r.skips.push(new RegExp("^" + f.slice(1) + "$")) : r.names.push(new RegExp("^" + f + "$")));
            }
            function o() {
              let f = [...r.names.map(a), ...r.skips.map(a).map((h) => "-" + h)].join(",");
              return r.enable(""), f;
            }
            function s(f) {
              if (f[f.length - 1] === "*")
                return true;
              let h, p;
              for (h = 0, p = r.skips.length; h < p; h++)
                if (r.skips[h].test(f))
                  return false;
              for (h = 0, p = r.names.length; h < p; h++)
                if (r.names[h].test(f))
                  return true;
              return false;
            }
            function a(f) {
              return f.toString().substring(2, f.toString().length - 2).replace(/\.\*\?$/, "*");
            }
            function u(f) {
              return f instanceof Error ? f.stack || f.message : f;
            }
            function l() {
              console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
            }
            return r.enable(r.load()), r;
          }
          oO.exports = a0e;
        });
        var Mi = A((eo, k4) => {
          c();
          eo.formatArgs = u0e;
          eo.save = l0e;
          eo.load = f0e;
          eo.useColors = c0e;
          eo.storage = h0e();
          eo.destroy = (() => {
            let t = false;
            return () => {
              t || (t = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })();
          eo.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
          function c0e() {
            return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }
          function u0e(t) {
            if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + k4.exports.humanize(this.diff), !this.useColors)
              return;
            let e = "color: " + this.color;
            t.splice(1, 0, e, "color: inherit");
            let r = 0, n = 0;
            t[0].replace(/%[a-zA-Z%]/g, (i2) => {
              i2 !== "%%" && (r++, i2 === "%c" && (n = r));
            }), t.splice(n, 0, e);
          }
          eo.log = console.debug || console.log || (() => {
          });
          function l0e(t) {
            try {
              t ? eo.storage.setItem("debug", t) : eo.storage.removeItem("debug");
            } catch {
            }
          }
          function f0e() {
            let t;
            try {
              t = eo.storage.getItem("debug");
            } catch {
            }
            return !t && typeof process < "u" && "env" in process && (t = process.env.DEBUG), t;
          }
          function h0e() {
            try {
              return localStorage;
            } catch {
            }
          }
          k4.exports = sO()(eo);
          var { formatters: d0e } = k4.exports;
          d0e.j = function(t) {
            try {
              return JSON.stringify(t);
            } catch (e) {
              return "[UnexpectedJSONParseError]: " + e.message;
            }
          };
        });
        function p0e(t, e) {
          if (t.length >= 255)
            throw new TypeError("Alphabet too long");
          for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
            r[n] = 255;
          for (var i2 = 0; i2 < t.length; i2++) {
            var o = t.charAt(i2), s = o.charCodeAt(0);
            if (r[s] !== 255)
              throw new TypeError(o + " is ambiguous");
            r[s] = i2;
          }
          var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), f = Math.log(256) / Math.log(a);
          function h(m) {
            if (m instanceof Uint8Array || (ArrayBuffer.isView(m) ? m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength) : Array.isArray(m) && (m = Uint8Array.from(m))), !(m instanceof Uint8Array))
              throw new TypeError("Expected Uint8Array");
            if (m.length === 0)
              return "";
            for (var y = 0, g = 0, E = 0, b = m.length; E !== b && m[E] === 0; )
              E++, y++;
            for (var v = (b - E) * f + 1 >>> 0, S = new Uint8Array(v); E !== b; ) {
              for (var x = m[E], T = 0, R = v - 1; (x !== 0 || T < g) && R !== -1; R--, T++)
                x += 256 * S[R] >>> 0, S[R] = x % a >>> 0, x = x / a >>> 0;
              if (x !== 0)
                throw new Error("Non-zero carry");
              g = T, E++;
            }
            for (var O = v - g; O !== v && S[O] === 0; )
              O++;
            for (var F = u.repeat(y); O < v; ++O)
              F += t.charAt(S[O]);
            return F;
          }
          function p(m) {
            if (typeof m != "string")
              throw new TypeError("Expected String");
            if (m.length === 0)
              return new Uint8Array();
            var y = 0;
            if (m[y] !== " ") {
              for (var g = 0, E = 0; m[y] === u; )
                g++, y++;
              for (var b = (m.length - y) * l + 1 >>> 0, v = new Uint8Array(b); m[y]; ) {
                var S = r[m.charCodeAt(y)];
                if (S === 255)
                  return;
                for (var x = 0, T = b - 1; (S !== 0 || x < E) && T !== -1; T--, x++)
                  S += a * v[T] >>> 0, v[T] = S % 256 >>> 0, S = S / 256 >>> 0;
                if (S !== 0)
                  throw new Error("Non-zero carry");
                E = x, y++;
              }
              if (m[y] !== " ") {
                for (var R = b - E; R !== b && v[R] === 0; )
                  R++;
                for (var O = new Uint8Array(g + (b - R)), F = g; R !== b; )
                  O[F++] = v[R++];
                return O;
              }
            }
          }
          function d(m) {
            var y = p(m);
            if (y)
              return y;
            throw new Error(`Non-${e} character`);
          }
          return { encode: h, decodeUnsafe: p, decode: d };
        }
        var m0e, y0e, aO, cO = Fe(() => {
          c();
          m0e = p0e, y0e = m0e, aO = y0e;
        });
        var op = {};
        ct(op, { coerce: () => Uo, empty: () => uO, equals: () => W7, fromHex: () => w0e, fromString: () => j7, isBinary: () => E0e, toHex: () => g0e, toString: () => Y7 });
        var uO, g0e, w0e, W7, Uo, E0e, j7, Y7, Mu = Fe(() => {
          c();
          uO = new Uint8Array(0), g0e = (t) => t.reduce((e, r) => e + r.toString(16).padStart(2, "0"), ""), w0e = (t) => {
            let e = t.match(/../g);
            return e ? new Uint8Array(e.map((r) => parseInt(r, 16))) : uO;
          }, W7 = (t, e) => {
            if (t === e)
              return true;
            if (t.byteLength !== e.byteLength)
              return false;
            for (let r = 0; r < t.byteLength; r++)
              if (t[r] !== e[r])
                return false;
            return true;
          }, Uo = (t) => {
            if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
              return t;
            if (t instanceof ArrayBuffer)
              return new Uint8Array(t);
            if (ArrayBuffer.isView(t))
              return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
            throw new Error("Unknown type, must be binary type");
          }, E0e = (t) => t instanceof ArrayBuffer || ArrayBuffer.isView(t), j7 = (t) => new TextEncoder().encode(t), Y7 = (t) => new TextDecoder().decode(t);
        });
        var Q7, X7, Z7, lO, J7, sp, Uu, b0e, _0e, zr, _s = Fe(() => {
          c();
          cO();
          Mu();
          Q7 = class {
            constructor(e, r, n) {
              this.name = e, this.prefix = r, this.baseEncode = n;
            }
            encode(e) {
              if (e instanceof Uint8Array)
                return `${this.prefix}${this.baseEncode(e)}`;
              throw Error("Unknown type, must be binary type");
            }
          }, X7 = class {
            constructor(e, r, n) {
              if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
                throw new Error("Invalid prefix character");
              this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
            }
            decode(e) {
              if (typeof e == "string") {
                if (e.codePointAt(0) !== this.prefixCodePoint)
                  throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
                return this.baseDecode(e.slice(this.prefix.length));
              } else
                throw Error("Can only multibase decode strings");
            }
            or(e) {
              return lO(this, e);
            }
          }, Z7 = class {
            constructor(e) {
              this.decoders = e;
            }
            or(e) {
              return lO(this, e);
            }
            decode(e) {
              let r = e[0], n = this.decoders[r];
              if (n)
                return n.decode(e);
              throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
            }
          }, lO = (t, e) => new Z7({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } }), J7 = class {
            constructor(e, r, n, i2) {
              this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i2, this.encoder = new Q7(e, r, n), this.decoder = new X7(e, r, i2);
            }
            encode(e) {
              return this.encoder.encode(e);
            }
            decode(e) {
              return this.decoder.decode(e);
            }
          }, sp = ({ name: t, prefix: e, encode: r, decode: n }) => new J7(t, e, r, n), Uu = ({ prefix: t, name: e, alphabet: r }) => {
            let { encode: n, decode: i2 } = aO(r, e);
            return sp({ prefix: t, name: e, encode: n, decode: (o) => Uo(i2(o)) });
          }, b0e = (t, e, r, n) => {
            let i2 = {};
            for (let f = 0; f < e.length; ++f)
              i2[e[f]] = f;
            let o = t.length;
            for (; t[o - 1] === "="; )
              --o;
            let s = new Uint8Array(o * r / 8 | 0), a = 0, u = 0, l = 0;
            for (let f = 0; f < o; ++f) {
              let h = i2[t[f]];
              if (h === void 0)
                throw new SyntaxError(`Non-${n} character`);
              u = u << r | h, a += r, a >= 8 && (a -= 8, s[l++] = 255 & u >> a);
            }
            if (a >= r || 255 & u << 8 - a)
              throw new SyntaxError("Unexpected end of data");
            return s;
          }, _0e = (t, e, r) => {
            let n = e[e.length - 1] === "=", i2 = (1 << r) - 1, o = "", s = 0, a = 0;
            for (let u = 0; u < t.length; ++u)
              for (a = a << 8 | t[u], s += 8; s > r; )
                s -= r, o += e[i2 & a >> s];
            if (s && (o += e[i2 & a << r - s]), n)
              for (; o.length * r & 7; )
                o += "=";
            return o;
          }, zr = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => sp({ prefix: e, name: t, encode(i2) {
            return _0e(i2, n, r);
          }, decode(i2) {
            return b0e(i2, n, r, t);
          } });
        });
        var ap = {};
        ct(ap, { base58btc: () => Ne, base58flickr: () => v0e });
        var Ne, v0e, Hr = Fe(() => {
          c();
          _s();
          Ne = Uu({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), v0e = Uu({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
        });
        var Vm = {};
        ct(Vm, { base32: () => xt, base32hex: () => x0e, base32hexpad: () => A0e, base32hexpadupper: () => T0e, base32hexupper: () => R0e, base32pad: () => t9, base32padupper: () => S0e, base32upper: () => e9, base32z: () => I0e });
        var xt, e9, t9, S0e, x0e, R0e, A0e, T0e, I0e, si = Fe(() => {
          c();
          _s();
          xt = zr({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), e9 = zr({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), t9 = zr({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), S0e = zr({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), x0e = zr({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), R0e = zr({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), A0e = zr({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), T0e = zr({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), I0e = zr({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
        });
        var N4 = {};
        ct(N4, { base64: () => to, base64pad: () => C0e, base64url: () => qm, base64urlpad: () => P0e });
        var to, C0e, qm, P0e, ma = Fe(() => {
          c();
          _s();
          to = zr({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), C0e = zr({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), qm = zr({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), P0e = zr({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
        });
        var K = A((lBe, hO) => {
          "use strict";
          c();
          function fO(t, e) {
            for (let r in e)
              Object.defineProperty(t, r, { value: e[r], enumerable: true, configurable: true });
            return t;
          }
          function D0e(t, e, r) {
            if (!t || typeof t == "string")
              throw new TypeError("Please pass an Error to err-code");
            r || (r = {}), typeof e == "object" && (r = e, e = ""), e && (r.code = e);
            try {
              return fO(t, r);
            } catch {
              r.message = t.message, r.stack = t.stack;
              let i2 = function() {
              };
              return i2.prototype = Object.create(Object.getPrototypeOf(t)), fO(new i2(), r);
            }
          }
          hO.exports = D0e;
        });
        var pO = A((fBe, dO) => {
          "use strict";
          c();
          dO.exports = k0e;
          function k0e(t, e) {
            for (var r = new Array(arguments.length - 1), n = 0, i2 = 2, o = true; i2 < arguments.length; )
              r[n++] = arguments[i2++];
            return new Promise(function(a, u) {
              r[n] = function(f) {
                if (o)
                  if (o = false, f)
                    u(f);
                  else {
                    for (var h = new Array(arguments.length - 1), p = 0; p < h.length; )
                      h[p++] = arguments[p];
                    a.apply(null, h);
                  }
              };
              try {
                t.apply(e || null, r);
              } catch (l) {
                o && (o = false, u(l));
              }
            });
          }
        });
        var wO = A((gO) => {
          "use strict";
          c();
          var O4 = gO;
          O4.length = function(e) {
            var r = e.length;
            if (!r)
              return 0;
            for (var n = 0; --r % 4 > 1 && e.charAt(r) === "="; )
              ++n;
            return Math.ceil(e.length * 3) / 4 - n;
          };
          var cp = new Array(64), yO = new Array(123);
          for (vs = 0; vs < 64; )
            yO[cp[vs] = vs < 26 ? vs + 65 : vs < 52 ? vs + 71 : vs < 62 ? vs - 4 : vs - 59 | 43] = vs++;
          var vs;
          O4.encode = function(e, r, n) {
            for (var i2 = null, o = [], s = 0, a = 0, u; r < n; ) {
              var l = e[r++];
              switch (a) {
                case 0:
                  o[s++] = cp[l >> 2], u = (l & 3) << 4, a = 1;
                  break;
                case 1:
                  o[s++] = cp[u | l >> 4], u = (l & 15) << 2, a = 2;
                  break;
                case 2:
                  o[s++] = cp[u | l >> 6], o[s++] = cp[l & 63], a = 0;
                  break;
              }
              s > 8191 && ((i2 || (i2 = [])).push(String.fromCharCode.apply(String, o)), s = 0);
            }
            return a && (o[s++] = cp[u], o[s++] = 61, a === 1 && (o[s++] = 61)), i2 ? (s && i2.push(String.fromCharCode.apply(String, o.slice(0, s))), i2.join("")) : String.fromCharCode.apply(String, o.slice(0, s));
          };
          var mO = "invalid encoding";
          O4.decode = function(e, r, n) {
            for (var i2 = n, o = 0, s, a = 0; a < e.length; ) {
              var u = e.charCodeAt(a++);
              if (u === 61 && o > 1)
                break;
              if ((u = yO[u]) === void 0)
                throw Error(mO);
              switch (o) {
                case 0:
                  s = u, o = 1;
                  break;
                case 1:
                  r[n++] = s << 2 | (u & 48) >> 4, s = u, o = 2;
                  break;
                case 2:
                  r[n++] = (s & 15) << 4 | (u & 60) >> 2, s = u, o = 3;
                  break;
                case 3:
                  r[n++] = (s & 3) << 6 | u, o = 0;
                  break;
              }
            }
            if (o === 1)
              throw Error(mO);
            return n - i2;
          };
          O4.test = function(e) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e);
          };
        });
        var bO = A((dBe, EO) => {
          "use strict";
          c();
          EO.exports = L4;
          function L4() {
            this._listeners = {};
          }
          L4.prototype.on = function(e, r, n) {
            return (this._listeners[e] || (this._listeners[e] = [])).push({ fn: r, ctx: n || this }), this;
          };
          L4.prototype.off = function(e, r) {
            if (e === void 0)
              this._listeners = {};
            else if (r === void 0)
              this._listeners[e] = [];
            else
              for (var n = this._listeners[e], i2 = 0; i2 < n.length; )
                n[i2].fn === r ? n.splice(i2, 1) : ++i2;
            return this;
          };
          L4.prototype.emit = function(e) {
            var r = this._listeners[e];
            if (r) {
              for (var n = [], i2 = 1; i2 < arguments.length; )
                n.push(arguments[i2++]);
              for (i2 = 0; i2 < r.length; )
                r[i2].fn.apply(r[i2++].ctx, n);
            }
            return this;
          };
        });
        var TO = A((pBe, AO) => {
          "use strict";
          c();
          AO.exports = _O(_O);
          function _O(t) {
            return typeof Float32Array < "u" ? function() {
              var e = new Float32Array([-0]), r = new Uint8Array(e.buffer), n = r[3] === 128;
              function i2(u, l, f) {
                e[0] = u, l[f] = r[0], l[f + 1] = r[1], l[f + 2] = r[2], l[f + 3] = r[3];
              }
              function o(u, l, f) {
                e[0] = u, l[f] = r[3], l[f + 1] = r[2], l[f + 2] = r[1], l[f + 3] = r[0];
              }
              t.writeFloatLE = n ? i2 : o, t.writeFloatBE = n ? o : i2;
              function s(u, l) {
                return r[0] = u[l], r[1] = u[l + 1], r[2] = u[l + 2], r[3] = u[l + 3], e[0];
              }
              function a(u, l) {
                return r[3] = u[l], r[2] = u[l + 1], r[1] = u[l + 2], r[0] = u[l + 3], e[0];
              }
              t.readFloatLE = n ? s : a, t.readFloatBE = n ? a : s;
            }() : function() {
              function e(n, i2, o, s) {
                var a = i2 < 0 ? 1 : 0;
                if (a && (i2 = -i2), i2 === 0)
                  n(1 / i2 > 0 ? 0 : 2147483648, o, s);
                else if (isNaN(i2))
                  n(2143289344, o, s);
                else if (i2 > 34028234663852886e22)
                  n((a << 31 | 2139095040) >>> 0, o, s);
                else if (i2 < 11754943508222875e-54)
                  n((a << 31 | Math.round(i2 / 1401298464324817e-60)) >>> 0, o, s);
                else {
                  var u = Math.floor(Math.log(i2) / Math.LN2), l = Math.round(i2 * Math.pow(2, -u) * 8388608) & 8388607;
                  n((a << 31 | u + 127 << 23 | l) >>> 0, o, s);
                }
              }
              t.writeFloatLE = e.bind(null, vO), t.writeFloatBE = e.bind(null, SO);
              function r(n, i2, o) {
                var s = n(i2, o), a = (s >> 31) * 2 + 1, u = s >>> 23 & 255, l = s & 8388607;
                return u === 255 ? l ? NaN : a * (1 / 0) : u === 0 ? a * 1401298464324817e-60 * l : a * Math.pow(2, u - 150) * (l + 8388608);
              }
              t.readFloatLE = r.bind(null, xO), t.readFloatBE = r.bind(null, RO);
            }(), typeof Float64Array < "u" ? function() {
              var e = new Float64Array([-0]), r = new Uint8Array(e.buffer), n = r[7] === 128;
              function i2(u, l, f) {
                e[0] = u, l[f] = r[0], l[f + 1] = r[1], l[f + 2] = r[2], l[f + 3] = r[3], l[f + 4] = r[4], l[f + 5] = r[5], l[f + 6] = r[6], l[f + 7] = r[7];
              }
              function o(u, l, f) {
                e[0] = u, l[f] = r[7], l[f + 1] = r[6], l[f + 2] = r[5], l[f + 3] = r[4], l[f + 4] = r[3], l[f + 5] = r[2], l[f + 6] = r[1], l[f + 7] = r[0];
              }
              t.writeDoubleLE = n ? i2 : o, t.writeDoubleBE = n ? o : i2;
              function s(u, l) {
                return r[0] = u[l], r[1] = u[l + 1], r[2] = u[l + 2], r[3] = u[l + 3], r[4] = u[l + 4], r[5] = u[l + 5], r[6] = u[l + 6], r[7] = u[l + 7], e[0];
              }
              function a(u, l) {
                return r[7] = u[l], r[6] = u[l + 1], r[5] = u[l + 2], r[4] = u[l + 3], r[3] = u[l + 4], r[2] = u[l + 5], r[1] = u[l + 6], r[0] = u[l + 7], e[0];
              }
              t.readDoubleLE = n ? s : a, t.readDoubleBE = n ? a : s;
            }() : function() {
              function e(n, i2, o, s, a, u) {
                var l = s < 0 ? 1 : 0;
                if (l && (s = -s), s === 0)
                  n(0, a, u + i2), n(1 / s > 0 ? 0 : 2147483648, a, u + o);
                else if (isNaN(s))
                  n(0, a, u + i2), n(2146959360, a, u + o);
                else if (s > 17976931348623157e292)
                  n(0, a, u + i2), n((l << 31 | 2146435072) >>> 0, a, u + o);
                else {
                  var f;
                  if (s < 22250738585072014e-324)
                    f = s / 5e-324, n(f >>> 0, a, u + i2), n((l << 31 | f / 4294967296) >>> 0, a, u + o);
                  else {
                    var h = Math.floor(Math.log(s) / Math.LN2);
                    h === 1024 && (h = 1023), f = s * Math.pow(2, -h), n(f * 4503599627370496 >>> 0, a, u + i2), n((l << 31 | h + 1023 << 20 | f * 1048576 & 1048575) >>> 0, a, u + o);
                  }
                }
              }
              t.writeDoubleLE = e.bind(null, vO, 0, 4), t.writeDoubleBE = e.bind(null, SO, 4, 0);
              function r(n, i2, o, s, a) {
                var u = n(s, a + i2), l = n(s, a + o), f = (l >> 31) * 2 + 1, h = l >>> 20 & 2047, p = 4294967296 * (l & 1048575) + u;
                return h === 2047 ? p ? NaN : f * (1 / 0) : h === 0 ? f * 5e-324 * p : f * Math.pow(2, h - 1075) * (p + 4503599627370496);
              }
              t.readDoubleLE = r.bind(null, xO, 0, 4), t.readDoubleBE = r.bind(null, RO, 4, 0);
            }(), t;
          }
          function vO(t, e, r) {
            e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;
          }
          function SO(t, e, r) {
            e[r] = t >>> 24, e[r + 1] = t >>> 16 & 255, e[r + 2] = t >>> 8 & 255, e[r + 3] = t & 255;
          }
          function xO(t, e) {
            return (t[e] | t[e + 1] << 8 | t[e + 2] << 16 | t[e + 3] << 24) >>> 0;
          }
          function RO(t, e) {
            return (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
          }
        });
        var IO = A((exports, module) => {
          "use strict";
          c();
          module.exports = inquire;
          function inquire(moduleName) {
            try {
              var mod = eval("quire".replace(/^/, "re"))(moduleName);
              if (mod && (mod.length || Object.keys(mod).length))
                return mod;
            } catch (t) {
            }
            return null;
          }
        });
        var PO = A((CO) => {
          "use strict";
          c();
          var r9 = CO;
          r9.length = function(e) {
            for (var r = 0, n = 0, i2 = 0; i2 < e.length; ++i2)
              n = e.charCodeAt(i2), n < 128 ? r += 1 : n < 2048 ? r += 2 : (n & 64512) === 55296 && (e.charCodeAt(i2 + 1) & 64512) === 56320 ? (++i2, r += 4) : r += 3;
            return r;
          };
          r9.read = function(e, r, n) {
            var i2 = n - r;
            if (i2 < 1)
              return "";
            for (var o = null, s = [], a = 0, u; r < n; )
              u = e[r++], u < 128 ? s[a++] = u : u > 191 && u < 224 ? s[a++] = (u & 31) << 6 | e[r++] & 63 : u > 239 && u < 365 ? (u = ((u & 7) << 18 | (e[r++] & 63) << 12 | (e[r++] & 63) << 6 | e[r++] & 63) - 65536, s[a++] = 55296 + (u >> 10), s[a++] = 56320 + (u & 1023)) : s[a++] = (u & 15) << 12 | (e[r++] & 63) << 6 | e[r++] & 63, a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, s)), a = 0);
            return o ? (a && o.push(String.fromCharCode.apply(String, s.slice(0, a))), o.join("")) : String.fromCharCode.apply(String, s.slice(0, a));
          };
          r9.write = function(e, r, n) {
            for (var i2 = n, o, s, a = 0; a < e.length; ++a)
              o = e.charCodeAt(a), o < 128 ? r[n++] = o : o < 2048 ? (r[n++] = o >> 6 | 192, r[n++] = o & 63 | 128) : (o & 64512) === 55296 && ((s = e.charCodeAt(a + 1)) & 64512) === 56320 ? (o = 65536 + ((o & 1023) << 10) + (s & 1023), ++a, r[n++] = o >> 18 | 240, r[n++] = o >> 12 & 63 | 128, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128) : (r[n++] = o >> 12 | 224, r[n++] = o >> 6 & 63 | 128, r[n++] = o & 63 | 128);
            return n - i2;
          };
        });
        var kO = A((yBe, DO) => {
          "use strict";
          c();
          DO.exports = N0e;
          function N0e(t, e, r) {
            var n = r || 8192, i2 = n >>> 1, o = null, s = n;
            return function(u) {
              if (u < 1 || u > i2)
                return t(u);
              s + u > n && (o = t(n), s = 0);
              var l = e.call(o, s, s += u);
              return s & 7 && (s = (s | 7) + 1), l;
            };
          }
        });
        var OO = A((gBe, NO) => {
          "use strict";
          c();
          NO.exports = Nn;
          var zm = Ku();
          function Nn(t, e) {
            this.lo = t >>> 0, this.hi = e >>> 0;
          }
          var Mf = Nn.zero = new Nn(0, 0);
          Mf.toNumber = function() {
            return 0;
          };
          Mf.zzEncode = Mf.zzDecode = function() {
            return this;
          };
          Mf.length = function() {
            return 1;
          };
          var O0e = Nn.zeroHash = "\0\0\0\0\0\0\0\0";
          Nn.fromNumber = function(e) {
            if (e === 0)
              return Mf;
            var r = e < 0;
            r && (e = -e);
            var n = e >>> 0, i2 = (e - n) / 4294967296 >>> 0;
            return r && (i2 = ~i2 >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++i2 > 4294967295 && (i2 = 0))), new Nn(n, i2);
          };
          Nn.from = function(e) {
            if (typeof e == "number")
              return Nn.fromNumber(e);
            if (zm.isString(e))
              if (zm.Long)
                e = zm.Long.fromString(e);
              else
                return Nn.fromNumber(parseInt(e, 10));
            return e.low || e.high ? new Nn(e.low >>> 0, e.high >>> 0) : Mf;
          };
          Nn.prototype.toNumber = function(e) {
            if (!e && this.hi >>> 31) {
              var r = ~this.lo + 1 >>> 0, n = ~this.hi >>> 0;
              return r || (n = n + 1 >>> 0), -(r + n * 4294967296);
            }
            return this.lo + this.hi * 4294967296;
          };
          Nn.prototype.toLong = function(e) {
            return zm.Long ? new zm.Long(this.lo | 0, this.hi | 0, Boolean(e)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(e) };
          };
          var Fu = String.prototype.charCodeAt;
          Nn.fromHash = function(e) {
            return e === O0e ? Mf : new Nn((Fu.call(e, 0) | Fu.call(e, 1) << 8 | Fu.call(e, 2) << 16 | Fu.call(e, 3) << 24) >>> 0, (Fu.call(e, 4) | Fu.call(e, 5) << 8 | Fu.call(e, 6) << 16 | Fu.call(e, 7) << 24) >>> 0);
          };
          Nn.prototype.toHash = function() {
            return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
          };
          Nn.prototype.zzEncode = function() {
            var e = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, this.lo = (this.lo << 1 ^ e) >>> 0, this;
          };
          Nn.prototype.zzDecode = function() {
            var e = -(this.lo & 1);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, this.hi = (this.hi >>> 1 ^ e) >>> 0, this;
          };
          Nn.prototype.length = function() {
            var e = this.lo, r = (this.lo >>> 28 | this.hi << 4) >>> 0, n = this.hi >>> 24;
            return n === 0 ? r === 0 ? e < 16384 ? e < 128 ? 1 : 2 : e < 2097152 ? 3 : 4 : r < 16384 ? r < 128 ? 5 : 6 : r < 2097152 ? 7 : 8 : n < 128 ? 9 : 10;
          };
        });
        var Ku = A((n9) => {
          "use strict";
          c();
          var De = n9;
          De.asPromise = pO();
          De.base64 = wO();
          De.EventEmitter = bO();
          De.float = TO();
          De.inquire = IO();
          De.utf8 = PO();
          De.pool = kO();
          De.LongBits = OO();
          De.isNode = Boolean(typeof globalThis < "u" && globalThis && globalThis.process && globalThis.process.versions && globalThis.process.versions.node);
          De.global = De.isNode && globalThis || typeof window < "u" && window || typeof self < "u" && self || n9;
          De.emptyArray = Object.freeze ? Object.freeze([]) : [];
          De.emptyObject = Object.freeze ? Object.freeze({}) : {};
          De.isInteger = Number.isInteger || function(e) {
            return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
          };
          De.isString = function(e) {
            return typeof e == "string" || e instanceof String;
          };
          De.isObject = function(e) {
            return e && typeof e == "object";
          };
          De.isset = De.isSet = function(e, r) {
            var n = e[r];
            return n != null && e.hasOwnProperty(r) ? typeof n != "object" || (Array.isArray(n) ? n.length : Object.keys(n).length) > 0 : false;
          };
          De.Buffer = function() {
            try {
              var t = De.inquire("buffer").Buffer;
              return t.prototype.utf8Write ? t : null;
            } catch {
              return null;
            }
          }();
          De._Buffer_from = null;
          De._Buffer_allocUnsafe = null;
          De.newBuffer = function(e) {
            return typeof e == "number" ? De.Buffer ? De._Buffer_allocUnsafe(e) : new De.Array(e) : De.Buffer ? De._Buffer_from(e) : typeof Uint8Array > "u" ? e : new Uint8Array(e);
          };
          De.Array = typeof Uint8Array < "u" ? Uint8Array : Array;
          De.Long = De.global.dcodeIO && De.global.dcodeIO.Long || De.global.Long || De.inquire("long");
          De.key2Re = /^true|false|0|1$/;
          De.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
          De.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
          De.longToHash = function(e) {
            return e ? De.LongBits.from(e).toHash() : De.LongBits.zeroHash;
          };
          De.longFromHash = function(e, r) {
            var n = De.LongBits.fromHash(e);
            return De.Long ? De.Long.fromBits(n.lo, n.hi, r) : n.toNumber(Boolean(r));
          };
          function LO(t, e, r) {
            for (var n = Object.keys(e), i2 = 0; i2 < n.length; ++i2)
              (t[n[i2]] === void 0 || !r) && (t[n[i2]] = e[n[i2]]);
            return t;
          }
          De.merge = LO;
          De.lcFirst = function(e) {
            return e.charAt(0).toLowerCase() + e.substring(1);
          };
          function BO(t) {
            function e(r, n) {
              if (!(this instanceof e))
                return new e(r, n);
              Object.defineProperty(this, "message", { get: function() {
                return r;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, e) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n && LO(this, n);
            }
            return (e.prototype = Object.create(Error.prototype)).constructor = e, Object.defineProperty(e.prototype, "name", { get: function() {
              return t;
            } }), e.prototype.toString = function() {
              return this.name + ": " + this.message;
            }, e;
          }
          De.newError = BO;
          De.ProtocolError = BO("ProtocolError");
          De.oneOfGetter = function(e) {
            for (var r = {}, n = 0; n < e.length; ++n)
              r[e[n]] = 1;
            return function() {
              for (var i2 = Object.keys(this), o = i2.length - 1; o > -1; --o)
                if (r[i2[o]] === 1 && this[i2[o]] !== void 0 && this[i2[o]] !== null)
                  return i2[o];
            };
          };
          De.oneOfSetter = function(e) {
            return function(r) {
              for (var n = 0; n < e.length; ++n)
                e[n] !== r && delete this[e[n]];
            };
          };
          De.toJSONOptions = { longs: String, enums: String, bytes: String, json: true };
          De._configure = function() {
            var t = De.Buffer;
            if (!t) {
              De._Buffer_from = De._Buffer_allocUnsafe = null;
              return;
            }
            De._Buffer_from = t.from !== Uint8Array.from && t.from || function(r, n) {
              return new t(r, n);
            }, De._Buffer_allocUnsafe = t.allocUnsafe || function(r) {
              return new t(r);
            };
          };
        });
        var l9 = A((EBe, KO) => {
          "use strict";
          c();
          KO.exports = Mt;
          var Fo = Ku(), i9, B4 = Fo.LongBits, MO = Fo.base64, UO = Fo.utf8;
          function Hm(t, e, r) {
            this.fn = t, this.len = e, this.next = void 0, this.val = r;
          }
          function s9() {
          }
          function L0e(t) {
            this.head = t.head, this.tail = t.tail, this.len = t.len, this.next = t.states;
          }
          function Mt() {
            this.len = 0, this.head = new Hm(s9, 0, 0), this.tail = this.head, this.states = null;
          }
          var FO = function() {
            return Fo.Buffer ? function() {
              return (Mt.create = function() {
                return new i9();
              })();
            } : function() {
              return new Mt();
            };
          };
          Mt.create = FO();
          Mt.alloc = function(e) {
            return new Fo.Array(e);
          };
          Fo.Array !== Array && (Mt.alloc = Fo.pool(Mt.alloc, Fo.Array.prototype.subarray));
          Mt.prototype._push = function(e, r, n) {
            return this.tail = this.tail.next = new Hm(e, r, n), this.len += r, this;
          };
          function a9(t, e, r) {
            e[r] = t & 255;
          }
          function B0e(t, e, r) {
            for (; t > 127; )
              e[r++] = t & 127 | 128, t >>>= 7;
            e[r] = t;
          }
          function c9(t, e) {
            this.len = t, this.next = void 0, this.val = e;
          }
          c9.prototype = Object.create(Hm.prototype);
          c9.prototype.fn = B0e;
          Mt.prototype.uint32 = function(e) {
            return this.len += (this.tail = this.tail.next = new c9((e = e >>> 0) < 128 ? 1 : e < 16384 ? 2 : e < 2097152 ? 3 : e < 268435456 ? 4 : 5, e)).len, this;
          };
          Mt.prototype.int32 = function(e) {
            return e < 0 ? this._push(u9, 10, B4.fromNumber(e)) : this.uint32(e);
          };
          Mt.prototype.sint32 = function(e) {
            return this.uint32((e << 1 ^ e >> 31) >>> 0);
          };
          function u9(t, e, r) {
            for (; t.hi; )
              e[r++] = t.lo & 127 | 128, t.lo = (t.lo >>> 7 | t.hi << 25) >>> 0, t.hi >>>= 7;
            for (; t.lo > 127; )
              e[r++] = t.lo & 127 | 128, t.lo = t.lo >>> 7;
            e[r++] = t.lo;
          }
          Mt.prototype.uint64 = function(e) {
            var r = B4.from(e);
            return this._push(u9, r.length(), r);
          };
          Mt.prototype.int64 = Mt.prototype.uint64;
          Mt.prototype.sint64 = function(e) {
            var r = B4.from(e).zzEncode();
            return this._push(u9, r.length(), r);
          };
          Mt.prototype.bool = function(e) {
            return this._push(a9, 1, e ? 1 : 0);
          };
          function o9(t, e, r) {
            e[r] = t & 255, e[r + 1] = t >>> 8 & 255, e[r + 2] = t >>> 16 & 255, e[r + 3] = t >>> 24;
          }
          Mt.prototype.fixed32 = function(e) {
            return this._push(o9, 4, e >>> 0);
          };
          Mt.prototype.sfixed32 = Mt.prototype.fixed32;
          Mt.prototype.fixed64 = function(e) {
            var r = B4.from(e);
            return this._push(o9, 4, r.lo)._push(o9, 4, r.hi);
          };
          Mt.prototype.sfixed64 = Mt.prototype.fixed64;
          Mt.prototype.float = function(e) {
            return this._push(Fo.float.writeFloatLE, 4, e);
          };
          Mt.prototype.double = function(e) {
            return this._push(Fo.float.writeDoubleLE, 8, e);
          };
          var M0e = Fo.Array.prototype.set ? function(e, r, n) {
            r.set(e, n);
          } : function(e, r, n) {
            for (var i2 = 0; i2 < e.length; ++i2)
              r[n + i2] = e[i2];
          };
          Mt.prototype.bytes = function(e) {
            var r = e.length >>> 0;
            if (!r)
              return this._push(a9, 1, 0);
            if (Fo.isString(e)) {
              var n = Mt.alloc(r = MO.length(e));
              MO.decode(e, n, 0), e = n;
            }
            return this.uint32(r)._push(M0e, r, e);
          };
          Mt.prototype.string = function(e) {
            var r = UO.length(e);
            return r ? this.uint32(r)._push(UO.write, r, e) : this._push(a9, 1, 0);
          };
          Mt.prototype.fork = function() {
            return this.states = new L0e(this), this.head = this.tail = new Hm(s9, 0, 0), this.len = 0, this;
          };
          Mt.prototype.reset = function() {
            return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Hm(s9, 0, 0), this.len = 0), this;
          };
          Mt.prototype.ldelim = function() {
            var e = this.head, r = this.tail, n = this.len;
            return this.reset().uint32(n), n && (this.tail.next = e.next, this.tail = r, this.len += n), this;
          };
          Mt.prototype.finish = function() {
            for (var e = this.head.next, r = this.constructor.alloc(this.len), n = 0; e; )
              e.fn(e.val, r, n), n += e.len, e = e.next;
            return r;
          };
          Mt._configure = function(t) {
            i9 = t, Mt.create = FO(), i9._configure();
          };
        });
        var zO = A((bBe, qO) => {
          "use strict";
          c();
          qO.exports = ga;
          var VO = l9();
          (ga.prototype = Object.create(VO.prototype)).constructor = ga;
          var Vu = Ku();
          function ga() {
            VO.call(this);
          }
          ga._configure = function() {
            ga.alloc = Vu._Buffer_allocUnsafe, ga.writeBytesBuffer = Vu.Buffer && Vu.Buffer.prototype instanceof Uint8Array && Vu.Buffer.prototype.set.name === "set" ? function(e, r, n) {
              r.set(e, n);
            } : function(e, r, n) {
              if (e.copy)
                e.copy(r, n, 0, e.length);
              else
                for (var i2 = 0; i2 < e.length; )
                  r[n++] = e[i2++];
            };
          };
          ga.prototype.bytes = function(e) {
            Vu.isString(e) && (e = Vu._Buffer_from(e, "base64"));
            var r = e.length >>> 0;
            return this.uint32(r), r && this._push(ga.writeBytesBuffer, r, e), this;
          };
          function U0e(t, e, r) {
            t.length < 40 ? Vu.utf8.write(t, e, r) : e.utf8Write ? e.utf8Write(t, r) : e.write(t, r);
          }
          ga.prototype.string = function(e) {
            var r = Vu.Buffer.byteLength(e);
            return this.uint32(r), r && this._push(U0e, r, e), this;
          };
          ga._configure();
        });
        var d9 = A((_Be, jO) => {
          "use strict";
          c();
          jO.exports = rn;
          var wa = Ku(), h9, GO = wa.LongBits, F0e = wa.utf8;
          function Ss(t, e) {
            return RangeError("index out of range: " + t.pos + " + " + (e || 1) + " > " + t.len);
          }
          function rn(t) {
            this.buf = t, this.pos = 0, this.len = t.length;
          }
          var HO = typeof Uint8Array < "u" ? function(e) {
            if (e instanceof Uint8Array || Array.isArray(e))
              return new rn(e);
            throw Error("illegal buffer");
          } : function(e) {
            if (Array.isArray(e))
              return new rn(e);
            throw Error("illegal buffer");
          }, WO = function() {
            return wa.Buffer ? function(r) {
              return (rn.create = function(i2) {
                return wa.Buffer.isBuffer(i2) ? new h9(i2) : HO(i2);
              })(r);
            } : HO;
          };
          rn.create = WO();
          rn.prototype._slice = wa.Array.prototype.subarray || wa.Array.prototype.slice;
          rn.prototype.uint32 = function() {
            var e = 4294967295;
            return function() {
              if (e = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (e = (e | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (e = (e | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
                return e;
              if ((this.pos += 5) > this.len)
                throw this.pos = this.len, Ss(this, 10);
              return e;
            };
          }();
          rn.prototype.int32 = function() {
            return this.uint32() | 0;
          };
          rn.prototype.sint32 = function() {
            var e = this.uint32();
            return e >>> 1 ^ -(e & 1) | 0;
          };
          function f9() {
            var t = new GO(0, 0), e = 0;
            if (this.len - this.pos > 4) {
              for (; e < 4; ++e)
                if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
                  return t;
              if (t.lo = (t.lo | (this.buf[this.pos] & 127) << 28) >>> 0, t.hi = (t.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
                return t;
              e = 0;
            } else {
              for (; e < 3; ++e) {
                if (this.pos >= this.len)
                  throw Ss(this);
                if (t.lo = (t.lo | (this.buf[this.pos] & 127) << e * 7) >>> 0, this.buf[this.pos++] < 128)
                  return t;
              }
              return t.lo = (t.lo | (this.buf[this.pos++] & 127) << e * 7) >>> 0, t;
            }
            if (this.len - this.pos > 4) {
              for (; e < 5; ++e)
                if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
                  return t;
            } else
              for (; e < 5; ++e) {
                if (this.pos >= this.len)
                  throw Ss(this);
                if (t.hi = (t.hi | (this.buf[this.pos] & 127) << e * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
                  return t;
              }
            throw Error("invalid varint encoding");
          }
          rn.prototype.bool = function() {
            return this.uint32() !== 0;
          };
          function M4(t, e) {
            return (t[e - 4] | t[e - 3] << 8 | t[e - 2] << 16 | t[e - 1] << 24) >>> 0;
          }
          rn.prototype.fixed32 = function() {
            if (this.pos + 4 > this.len)
              throw Ss(this, 4);
            return M4(this.buf, this.pos += 4);
          };
          rn.prototype.sfixed32 = function() {
            if (this.pos + 4 > this.len)
              throw Ss(this, 4);
            return M4(this.buf, this.pos += 4) | 0;
          };
          function $O() {
            if (this.pos + 8 > this.len)
              throw Ss(this, 8);
            return new GO(M4(this.buf, this.pos += 4), M4(this.buf, this.pos += 4));
          }
          rn.prototype.float = function() {
            if (this.pos + 4 > this.len)
              throw Ss(this, 4);
            var e = wa.float.readFloatLE(this.buf, this.pos);
            return this.pos += 4, e;
          };
          rn.prototype.double = function() {
            if (this.pos + 8 > this.len)
              throw Ss(this, 4);
            var e = wa.float.readDoubleLE(this.buf, this.pos);
            return this.pos += 8, e;
          };
          rn.prototype.bytes = function() {
            var e = this.uint32(), r = this.pos, n = this.pos + e;
            if (n > this.len)
              throw Ss(this, e);
            return this.pos += e, Array.isArray(this.buf) ? this.buf.slice(r, n) : r === n ? new this.buf.constructor(0) : this._slice.call(this.buf, r, n);
          };
          rn.prototype.string = function() {
            var e = this.bytes();
            return F0e.read(e, 0, e.length);
          };
          rn.prototype.skip = function(e) {
            if (typeof e == "number") {
              if (this.pos + e > this.len)
                throw Ss(this, e);
              this.pos += e;
            } else
              do
                if (this.pos >= this.len)
                  throw Ss(this);
              while (this.buf[this.pos++] & 128);
            return this;
          };
          rn.prototype.skipType = function(t) {
            switch (t) {
              case 0:
                this.skip();
                break;
              case 1:
                this.skip(8);
                break;
              case 2:
                this.skip(this.uint32());
                break;
              case 3:
                for (; (t = this.uint32() & 7) !== 4; )
                  this.skipType(t);
                break;
              case 5:
                this.skip(4);
                break;
              default:
                throw Error("invalid wire type " + t + " at offset " + this.pos);
            }
            return this;
          };
          rn._configure = function(t) {
            h9 = t, rn.create = WO(), h9._configure();
            var e = wa.Long ? "toLong" : "toNumber";
            wa.merge(rn.prototype, { int64: function() {
              return f9.call(this)[e](false);
            }, uint64: function() {
              return f9.call(this)[e](true);
            }, sint64: function() {
              return f9.call(this).zzDecode()[e](false);
            }, fixed64: function() {
              return $O.call(this)[e](true);
            }, sfixed64: function() {
              return $O.call(this)[e](false);
            } });
          };
        });
        var ZO = A((vBe, XO) => {
          "use strict";
          c();
          XO.exports = Uf;
          var QO = d9();
          (Uf.prototype = Object.create(QO.prototype)).constructor = Uf;
          var YO = Ku();
          function Uf(t) {
            QO.call(this, t);
          }
          Uf._configure = function() {
            YO.Buffer && (Uf.prototype._slice = YO.Buffer.prototype.slice);
          };
          Uf.prototype.string = function() {
            var e = this.uint32();
            return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e, this.len));
          };
          Uf._configure();
        });
        var eL = A((SBe, JO) => {
          "use strict";
          c();
          JO.exports = $m;
          var p9 = Ku();
          ($m.prototype = Object.create(p9.EventEmitter.prototype)).constructor = $m;
          function $m(t, e, r) {
            if (typeof t != "function")
              throw TypeError("rpcImpl must be a function");
            p9.EventEmitter.call(this), this.rpcImpl = t, this.requestDelimited = Boolean(e), this.responseDelimited = Boolean(r);
          }
          $m.prototype.rpcCall = function t(e, r, n, i2, o) {
            if (!i2)
              throw TypeError("request must be specified");
            var s = this;
            if (!o)
              return p9.asPromise(t, s, e, r, n, i2);
            if (!s.rpcImpl) {
              setTimeout(function() {
                o(Error("already ended"));
              }, 0);
              return;
            }
            try {
              return s.rpcImpl(e, r[s.requestDelimited ? "encodeDelimited" : "encode"](i2).finish(), function(u, l) {
                if (u)
                  return s.emit("error", u, e), o(u);
                if (l === null) {
                  s.end(true);
                  return;
                }
                if (!(l instanceof n))
                  try {
                    l = n[s.responseDelimited ? "decodeDelimited" : "decode"](l);
                  } catch (f) {
                    return s.emit("error", f, e), o(f);
                  }
                return s.emit("data", l, e), o(null, l);
              });
            } catch (a) {
              s.emit("error", a, e), setTimeout(function() {
                o(a);
              }, 0);
              return;
            }
          };
          $m.prototype.end = function(e) {
            return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
          };
        });
        var rL = A((tL) => {
          "use strict";
          c();
          var K0e = tL;
          K0e.Service = eL();
        });
        var iL = A((RBe, nL) => {
          "use strict";
          c();
          nL.exports = {};
        });
        var aL = A((sL) => {
          "use strict";
          c();
          var Ui = sL;
          Ui.build = "minimal";
          Ui.Writer = l9();
          Ui.BufferWriter = zO();
          Ui.Reader = d9();
          Ui.BufferReader = ZO();
          Ui.util = Ku();
          Ui.rpc = rL();
          Ui.roots = iL();
          Ui.configure = oL;
          function oL() {
            Ui.util._configure(), Ui.Writer._configure(Ui.BufferWriter), Ui.Reader._configure(Ui.BufferReader);
          }
          oL();
        });
        var Ea = A((TBe, cL) => {
          "use strict";
          c();
          cL.exports = aL();
        });
        function mL(t, e, r) {
          e = e || [], r = r || 0;
          for (var n = r; t >= G0e; )
            e[r++] = t & 255 | dL, t /= 128;
          for (; t & $0e; )
            e[r++] = t & 255 | dL, t >>>= 7;
          return e[r] = t | 0, mL.bytes = r - n + 1, e;
        }
        function y9(t, n) {
          var r = 0, n = n || 0, i2 = 0, o = n, s, a = t.length;
          do {
            if (o >= a)
              throw y9.bytes = 0, new RangeError("Could not decode varint");
            s = t[o++], r += i2 < 28 ? (s & pL) << i2 : (s & pL) * Math.pow(2, i2), i2 += 7;
          } while (s >= j0e);
          return y9.bytes = o - n, r;
        }
        var z0e, dL, H0e, $0e, G0e, W0e, j0e, pL, Y0e, Q0e, X0e, Z0e, J0e, e1e, t1e, r1e, n1e, i1e, o1e, s1e, Gm, yL = Fe(() => {
          c();
          z0e = mL, dL = 128, H0e = 127, $0e = ~H0e, G0e = Math.pow(2, 31);
          W0e = y9, j0e = 128, pL = 127;
          Y0e = Math.pow(2, 7), Q0e = Math.pow(2, 14), X0e = Math.pow(2, 21), Z0e = Math.pow(2, 28), J0e = Math.pow(2, 35), e1e = Math.pow(2, 42), t1e = Math.pow(2, 49), r1e = Math.pow(2, 56), n1e = Math.pow(2, 63), i1e = function(t) {
            return t < Y0e ? 1 : t < Q0e ? 2 : t < X0e ? 3 : t < Z0e ? 4 : t < J0e ? 5 : t < e1e ? 6 : t < t1e ? 7 : t < r1e ? 8 : t < n1e ? 9 : 10;
          }, o1e = { encode: z0e, decode: W0e, encodingLength: i1e }, s1e = o1e, Gm = s1e;
        });
        var Wm, lp, fp, K4 = Fe(() => {
          c();
          yL();
          Wm = (t) => [Gm.decode(t), Gm.decode.bytes], lp = (t, e, r = 0) => (Gm.encode(t, e, r), e), fp = (t) => Gm.encodingLength(t);
        });
        var xn = {};
        ct(xn, { Digest: () => Ff, create: () => xs, decode: () => _r, equals: () => g9 });
        var xs, _r, g9, Ff, On = Fe(() => {
          c();
          Mu();
          K4();
          xs = (t, e) => {
            let r = e.byteLength, n = fp(t), i2 = n + fp(r), o = new Uint8Array(i2 + r);
            return lp(t, o, 0), lp(r, o, n), o.set(e, i2), new Ff(t, r, e, o);
          }, _r = (t) => {
            let e = Uo(t), [r, n] = Wm(e), [i2, o] = Wm(e.subarray(n)), s = e.subarray(n + o);
            if (s.byteLength !== i2)
              throw new Error("Incorrect length");
            return new Ff(r, i2, s, e);
          }, g9 = (t, e) => t === e ? true : t.code === e.code && t.size === e.size && W7(t.bytes, e.bytes), Ff = class {
            constructor(e, r, n, i2) {
              this.code = e, this.size = r, this.digest = n, this.bytes = i2;
            }
          };
        });
        var Ym = {};
        ct(Ym, { CID: () => I });
        var I, a1e, c1e, u1e, jm, l1e, gL, wL, V4, q4, f1e, h1e, d1e, te = Fe(() => {
          c();
          K4();
          On();
          Hr();
          si();
          Mu();
          I = class {
            constructor(e, r, n, i2) {
              this.code = r, this.version = e, this.multihash = n, this.bytes = i2, this.byteOffset = i2.byteOffset, this.byteLength = i2.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, { byteOffset: q4, byteLength: q4, code: V4, version: V4, multihash: V4, bytes: V4, _baseCache: q4, asCID: q4 });
            }
            toV0() {
              switch (this.version) {
                case 0:
                  return this;
                default: {
                  let { code: e, multihash: r } = this;
                  if (e !== jm)
                    throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                  if (r.code !== l1e)
                    throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                  return I.createV0(r);
                }
              }
            }
            toV1() {
              switch (this.version) {
                case 0: {
                  let { code: e, digest: r } = this.multihash, n = xs(e, r);
                  return I.createV1(this.code, n);
                }
                case 1:
                  return this;
                default:
                  throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
              }
            }
            equals(e) {
              return e && this.code === e.code && this.version === e.version && g9(this.multihash, e.multihash);
            }
            toString(e) {
              let { bytes: r, version: n, _baseCache: i2 } = this;
              switch (n) {
                case 0:
                  return c1e(r, i2, e || Ne.encoder);
                default:
                  return u1e(r, i2, e || xt.encoder);
              }
            }
            toJSON() {
              return { code: this.code, version: this.version, hash: this.multihash.bytes };
            }
            get [Symbol.toStringTag]() {
              return "CID";
            }
            [Symbol.for("nodejs.util.inspect.custom")]() {
              return "CID(" + this.toString() + ")";
            }
            static isCID(e) {
              return h1e(/^0\.0/, d1e), !!(e && (e[wL] || e.asCID === e));
            }
            get toBaseEncodedString() {
              throw new Error("Deprecated, use .toString()");
            }
            get codec() {
              throw new Error('"codec" property is deprecated, use integer "code" property instead');
            }
            get buffer() {
              throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
            }
            get multibaseName() {
              throw new Error('"multibaseName" property is deprecated');
            }
            get prefix() {
              throw new Error('"prefix" property is deprecated');
            }
            static asCID(e) {
              if (e instanceof I)
                return e;
              if (e != null && e.asCID === e) {
                let { version: r, code: n, multihash: i2, bytes: o } = e;
                return new I(r, n, i2, o || gL(r, n, i2.bytes));
              } else if (e != null && e[wL] === true) {
                let { version: r, multihash: n, code: i2 } = e, o = _r(n);
                return I.create(r, i2, o);
              } else
                return null;
            }
            static create(e, r, n) {
              if (typeof r != "number")
                throw new Error("String codecs are no longer supported");
              switch (e) {
                case 0: {
                  if (r !== jm)
                    throw new Error(`Version 0 CID must use dag-pb (code: ${jm}) block encoding`);
                  return new I(e, r, n, n.bytes);
                }
                case 1: {
                  let i2 = gL(e, r, n.bytes);
                  return new I(e, r, n, i2);
                }
                default:
                  throw new Error("Invalid version");
              }
            }
            static createV0(e) {
              return I.create(0, jm, e);
            }
            static createV1(e, r) {
              return I.create(1, e, r);
            }
            static decode(e) {
              let [r, n] = I.decodeFirst(e);
              if (n.length)
                throw new Error("Incorrect length");
              return r;
            }
            static decodeFirst(e) {
              let r = I.inspectBytes(e), n = r.size - r.multihashSize, i2 = Uo(e.subarray(n, n + r.multihashSize));
              if (i2.byteLength !== r.multihashSize)
                throw new Error("Incorrect length");
              let o = i2.subarray(r.multihashSize - r.digestSize), s = new Ff(r.multihashCode, r.digestSize, o, i2);
              return [r.version === 0 ? I.createV0(s) : I.createV1(r.codec, s), e.subarray(r.size)];
            }
            static inspectBytes(e) {
              let r = 0, n = () => {
                let [h, p] = Wm(e.subarray(r));
                return r += p, h;
              }, i2 = n(), o = jm;
              if (i2 === 18 ? (i2 = 0, r = 0) : i2 === 1 && (o = n()), i2 !== 0 && i2 !== 1)
                throw new RangeError(`Invalid CID version ${i2}`);
              let s = r, a = n(), u = n(), l = r + u, f = l - s;
              return { version: i2, codec: o, multihashCode: a, digestSize: u, multihashSize: f, size: l };
            }
            static parse(e, r) {
              let [n, i2] = a1e(e, r), o = I.decode(i2);
              return o._baseCache.set(n, e), o;
            }
          }, a1e = (t, e) => {
            switch (t[0]) {
              case "Q": {
                let r = e || Ne;
                return [Ne.prefix, r.decode(`${Ne.prefix}${t}`)];
              }
              case Ne.prefix: {
                let r = e || Ne;
                return [Ne.prefix, r.decode(t)];
              }
              case xt.prefix: {
                let r = e || xt;
                return [xt.prefix, r.decode(t)];
              }
              default: {
                if (e == null)
                  throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                return [t[0], e.decode(t)];
              }
            }
          }, c1e = (t, e, r) => {
            let { prefix: n } = r;
            if (n !== Ne.prefix)
              throw Error(`Cannot string encode V0 in ${r.name} encoding`);
            let i2 = e.get(n);
            if (i2 == null) {
              let o = r.encode(t).slice(1);
              return e.set(n, o), o;
            } else
              return i2;
          }, u1e = (t, e, r) => {
            let { prefix: n } = r, i2 = e.get(n);
            if (i2 == null) {
              let o = r.encode(t);
              return e.set(n, o), o;
            } else
              return i2;
          }, jm = 112, l1e = 18, gL = (t, e, r) => {
            let n = fp(t), i2 = n + fp(e), o = new Uint8Array(i2 + r.byteLength);
            return lp(t, o, 0), lp(e, o, n), o.set(r, i2), o;
          }, wL = Symbol.for("@ipld/js-cid/CID"), V4 = { writable: false, configurable: false, enumerable: true }, q4 = { writable: false, enumerable: false, configurable: false }, f1e = "0.0.0-dev", h1e = (t, e) => {
            if (t.test(f1e))
              console.warn(e);
            else
              throw new Error(e);
          }, d1e = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
        });
        function CL(t) {
          if (t === null)
            return "null";
          if (t === void 0)
            return "undefined";
          if (t === true || t === false)
            return "boolean";
          let e = typeof t;
          if (R1e.includes(e))
            return e;
          if (e === "function")
            return "Function";
          if (Array.isArray(t))
            return "Array";
          if (T1e(t))
            return "Buffer";
          let r = I1e(t);
          return r || "Object";
        }
        function T1e(t) {
          return t && t.constructor && t.constructor.isBuffer && t.constructor.isBuffer.call(null, t);
        }
        function I1e(t) {
          let e = Object.prototype.toString.call(t).slice(8, -1);
          if (A1e.includes(e))
            return e;
        }
        var R1e, A1e, PL = Fe(() => {
          c();
          R1e = ["string", "number", "bigint", "symbol"], A1e = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"];
        });
        var L, Q, vi = Fe(() => {
          c();
          L = class {
            constructor(e, r, n) {
              this.major = e, this.majorEncoded = e << 5, this.name = r, this.terminal = n;
            }
            toString() {
              return `Type[${this.major}].${this.name}`;
            }
            compare(e) {
              return this.major < e.major ? -1 : this.major > e.major ? 1 : 0;
            }
          };
          L.uint = new L(0, "uint", true);
          L.negint = new L(1, "negint", true);
          L.bytes = new L(2, "bytes", true);
          L.string = new L(3, "string", true);
          L.array = new L(4, "array", false);
          L.map = new L(5, "map", false);
          L.tag = new L(6, "tag", false);
          L.float = new L(7, "float", true);
          L.false = new L(7, "false", true);
          L.true = new L(7, "true", true);
          L.null = new L(7, "null", true);
          L.undefined = new L(7, "undefined", true);
          L.break = new L(7, "break", true);
          Q = class {
            constructor(e, r, n) {
              this.type = e, this.value = r, this.encodedLength = n, this.encodedBytes = void 0, this.byteValue = void 0;
            }
            toString() {
              return `Token[${this.type}].${this.value}`;
            }
          };
        });
        function H4(t) {
          return dp && globalThis.Buffer.isBuffer(t);
        }
        function Xm(t) {
          return t instanceof Uint8Array ? H4(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t : Uint8Array.from(t);
        }
        function ML(t, e) {
          if (H4(t) && H4(e))
            return t.compare(e);
          for (let r = 0; r < t.length; r++)
            if (t[r] !== e[r])
              return t[r] < e[r] ? -1 : 1;
          return 0;
        }
        function DL(t, e = 1 / 0) {
          let r, n = t.length, i2 = null, o = [];
          for (let s = 0; s < n; ++s) {
            if (r = t.charCodeAt(s), r > 55295 && r < 57344) {
              if (!i2) {
                if (r > 56319) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                } else if (s + 1 === n) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue;
                }
                i2 = r;
                continue;
              }
              if (r < 56320) {
                (e -= 3) > -1 && o.push(239, 191, 189), i2 = r;
                continue;
              }
              r = (i2 - 55296 << 10 | r - 56320) + 65536;
            } else
              i2 && (e -= 3) > -1 && o.push(239, 191, 189);
            if (i2 = null, r < 128) {
              if ((e -= 1) < 0)
                break;
              o.push(r);
            } else if (r < 2048) {
              if ((e -= 2) < 0)
                break;
              o.push(r >> 6 | 192, r & 63 | 128);
            } else if (r < 65536) {
              if ((e -= 3) < 0)
                break;
              o.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
            } else if (r < 1114112) {
              if ((e -= 4) < 0)
                break;
              o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
            } else
              throw new Error("Invalid code point");
          }
          return o;
        }
        function kL(t, e, r) {
          let n = [];
          for (; e < r; ) {
            let i2 = t[e], o = null, s = i2 > 239 ? 4 : i2 > 223 ? 3 : i2 > 191 ? 2 : 1;
            if (e + s <= r) {
              let a, u, l, f;
              switch (s) {
                case 1:
                  i2 < 128 && (o = i2);
                  break;
                case 2:
                  a = t[e + 1], (a & 192) === 128 && (f = (i2 & 31) << 6 | a & 63, f > 127 && (o = f));
                  break;
                case 3:
                  a = t[e + 1], u = t[e + 2], (a & 192) === 128 && (u & 192) === 128 && (f = (i2 & 15) << 12 | (a & 63) << 6 | u & 63, f > 2047 && (f < 55296 || f > 57343) && (o = f));
                  break;
                case 4:
                  a = t[e + 1], u = t[e + 2], l = t[e + 3], (a & 192) === 128 && (u & 192) === 128 && (l & 192) === 128 && (f = (i2 & 15) << 18 | (a & 63) << 12 | (u & 63) << 6 | l & 63, f > 65535 && f < 1114112 && (o = f));
              }
            }
            o === null ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), e += s;
          }
          return _9(n);
        }
        function _9(t) {
          let e = t.length;
          if (e <= NL)
            return String.fromCharCode.apply(String, t);
          let r = "", n = 0;
          for (; n < e; )
            r += String.fromCharCode.apply(String, t.slice(n, n += NL));
          return r;
        }
        var dp, C1e, P1e, OL, $4, ba, pp, LL, BL, NL, zu = Fe(() => {
          c();
          dp = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", C1e = new TextDecoder(), P1e = new TextEncoder();
          OL = dp ? (t, e, r) => r - e > 64 ? globalThis.Buffer.from(t.subarray(e, r)).toString("utf8") : kL(t, e, r) : (t, e, r) => r - e > 64 ? C1e.decode(t.subarray(e, r)) : kL(t, e, r), $4 = dp ? (t) => t.length > 64 ? globalThis.Buffer.from(t) : DL(t) : (t) => t.length > 64 ? P1e.encode(t) : DL(t), ba = (t) => Uint8Array.from(t), pp = dp ? (t, e, r) => H4(t) ? new Uint8Array(t.subarray(e, r)) : t.slice(e, r) : (t, e, r) => t.slice(e, r), LL = dp ? (t, e) => (t = t.map((r) => r instanceof Uint8Array ? r : globalThis.Buffer.from(r)), Xm(globalThis.Buffer.concat(t, e))) : (t, e) => {
            let r = new Uint8Array(e), n = 0;
            for (let i2 of t)
              n + i2.length > r.length && (i2 = i2.subarray(0, r.length - n)), r.set(i2, n), n += i2.length;
            return r;
          }, BL = dp ? (t) => globalThis.Buffer.allocUnsafe(t) : (t) => new Uint8Array(t);
          NL = 4096;
        });
        var D1e, Zm, UL = Fe(() => {
          c();
          zu();
          D1e = 256, Zm = class {
            constructor(e = D1e) {
              this.chunkSize = e, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;
            }
            reset() {
              this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);
            }
            push(e) {
              let r = this.chunks[this.chunks.length - 1];
              if (this.cursor + e.length <= this.maxCursor + 1) {
                let i2 = r.length - (this.maxCursor - this.cursor) - 1;
                r.set(e, i2);
              } else {
                if (r) {
                  let i2 = r.length - (this.maxCursor - this.cursor) - 1;
                  i2 < r.length && (this.chunks[this.chunks.length - 1] = r.subarray(0, i2), this.maxCursor = this.cursor - 1);
                }
                e.length < 64 && e.length < this.chunkSize ? (r = BL(this.chunkSize), this.chunks.push(r), this.maxCursor += r.length, this._initReuseChunk === null && (this._initReuseChunk = r), r.set(e, 0)) : (this.chunks.push(e), this.maxCursor += e.length);
              }
              this.cursor += e.length;
            }
            toBytes(e = false) {
              let r;
              if (this.chunks.length === 1) {
                let n = this.chunks[0];
                e && this.cursor > n.length / 2 ? (r = this.cursor === n.length ? n : n.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : r = pp(n, 0, this.cursor);
              } else
                r = LL(this.chunks, this.cursor);
              return e && this.reset(), r;
            }
          };
        });
        function _c(t, e, r) {
          if (t.length - e < r)
            throw new Error(`${Ie} not enough data for type`);
        }
        var Ie, bc, Jm, ro = Fe(() => {
          c();
          Ie = "CBOR decode error:", bc = "CBOR encode error:", Jm = [];
          Jm[23] = 1;
          Jm[24] = 2;
          Jm[25] = 3;
          Jm[26] = 5;
          Jm[27] = 9;
        });
        function no(t, e, r) {
          _c(t, e, 1);
          let n = t[e];
          if (r.strict === true && n < Bn[0])
            throw new Error(`${Ie} integer encoded in more bytes than necessary (strict decode)`);
          return n;
        }
        function io(t, e, r) {
          _c(t, e, 2);
          let n = t[e] << 8 | t[e + 1];
          if (r.strict === true && n < Bn[1])
            throw new Error(`${Ie} integer encoded in more bytes than necessary (strict decode)`);
          return n;
        }
        function oo(t, e, r) {
          _c(t, e, 4);
          let n = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3];
          if (r.strict === true && n < Bn[2])
            throw new Error(`${Ie} integer encoded in more bytes than necessary (strict decode)`);
          return n;
        }
        function so(t, e, r) {
          _c(t, e, 8);
          let n = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3], i2 = t[e + 4] * 16777216 + (t[e + 5] << 16) + (t[e + 6] << 8) + t[e + 7], o = (BigInt(n) << BigInt(32)) + BigInt(i2);
          if (r.strict === true && o < Bn[3])
            throw new Error(`${Ie} integer encoded in more bytes than necessary (strict decode)`);
          if (o <= Number.MAX_SAFE_INTEGER)
            return Number(o);
          if (r.allowBigInt === true)
            return o;
          throw new Error(`${Ie} integers outside of the safe integer range are not supported`);
        }
        function FL(t, e, r, n) {
          return new Q(L.uint, no(t, e + 1, n), 2);
        }
        function KL(t, e, r, n) {
          return new Q(L.uint, io(t, e + 1, n), 3);
        }
        function VL(t, e, r, n) {
          return new Q(L.uint, oo(t, e + 1, n), 5);
        }
        function qL(t, e, r, n) {
          return new Q(L.uint, so(t, e + 1, n), 9);
        }
        function Ko(t, e) {
          return Zn(t, 0, e.value);
        }
        function Zn(t, e, r) {
          if (r < Bn[0]) {
            let n = Number(r);
            t.push([e | n]);
          } else if (r < Bn[1]) {
            let n = Number(r);
            t.push([e | 24, n]);
          } else if (r < Bn[2]) {
            let n = Number(r);
            t.push([e | 25, n >>> 8, n & 255]);
          } else if (r < Bn[3]) {
            let n = Number(r);
            t.push([e | 26, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n & 255]);
          } else {
            let n = BigInt(r);
            if (n < Bn[4]) {
              let i2 = [e | 27, 0, 0, 0, 0, 0, 0, 0], o = Number(n & BigInt(4294967295)), s = Number(n >> BigInt(32) & BigInt(4294967295));
              i2[8] = o & 255, o = o >> 8, i2[7] = o & 255, o = o >> 8, i2[6] = o & 255, o = o >> 8, i2[5] = o & 255, i2[4] = s & 255, s = s >> 8, i2[3] = s & 255, s = s >> 8, i2[2] = s & 255, s = s >> 8, i2[1] = s & 255, t.push(i2);
            } else
              throw new Error(`${Ie} encountered BigInt larger than allowable range`);
          }
        }
        var Bn, _a = Fe(() => {
          c();
          vi();
          ro();
          Bn = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
          Ko.encodedSize = function(e) {
            return Zn.encodedSize(e.value);
          };
          Zn.encodedSize = function(e) {
            return e < Bn[0] ? 1 : e < Bn[1] ? 2 : e < Bn[2] ? 3 : e < Bn[3] ? 5 : 9;
          };
          Ko.compareTokens = function(e, r) {
            return e.value < r.value ? -1 : e.value > r.value ? 1 : 0;
          };
        });
        function zL(t, e, r, n) {
          return new Q(L.negint, -1 - no(t, e + 1, n), 2);
        }
        function HL(t, e, r, n) {
          return new Q(L.negint, -1 - io(t, e + 1, n), 3);
        }
        function $L(t, e, r, n) {
          return new Q(L.negint, -1 - oo(t, e + 1, n), 5);
        }
        function WL(t, e, r, n) {
          let i2 = so(t, e + 1, n);
          if (typeof i2 != "bigint") {
            let o = -1 - i2;
            if (o >= Number.MIN_SAFE_INTEGER)
              return new Q(L.negint, o, 9);
          }
          if (n.allowBigInt !== true)
            throw new Error(`${Ie} integers outside of the safe integer range are not supported`);
          return new Q(L.negint, v9 - BigInt(i2), 9);
        }
        function G4(t, e) {
          let r = e.value, n = typeof r == "bigint" ? r * v9 - GL : r * -1 - 1;
          Zn(t, e.type.majorEncoded, n);
        }
        var v9, GL, S9 = Fe(() => {
          c();
          vi();
          _a();
          ro();
          v9 = BigInt(-1), GL = BigInt(1);
          G4.encodedSize = function(e) {
            let r = e.value, n = typeof r == "bigint" ? r * v9 - GL : r * -1 - 1;
            return n < Bn[0] ? 1 : n < Bn[1] ? 2 : n < Bn[2] ? 3 : n < Bn[3] ? 5 : 9;
          };
          G4.compareTokens = function(e, r) {
            return e.value < r.value ? 1 : e.value > r.value ? -1 : 0;
          };
        });
        function e2(t, e, r, n) {
          _c(t, e, r + n);
          let i2 = pp(t, e + r, e + r + n);
          return new Q(L.bytes, i2, r + n);
        }
        function jL(t, e, r, n) {
          return e2(t, e, 1, r);
        }
        function YL(t, e, r, n) {
          return e2(t, e, 2, no(t, e + 1, n));
        }
        function QL(t, e, r, n) {
          return e2(t, e, 3, io(t, e + 1, n));
        }
        function XL(t, e, r, n) {
          return e2(t, e, 5, oo(t, e + 1, n));
        }
        function ZL(t, e, r, n) {
          let i2 = so(t, e + 1, n);
          if (typeof i2 == "bigint")
            throw new Error(`${Ie} 64-bit integer bytes lengths not supported`);
          return e2(t, e, 9, i2);
        }
        function W4(t) {
          return t.encodedBytes === void 0 && (t.encodedBytes = t.type === L.string ? $4(t.value) : t.value), t.encodedBytes;
        }
        function mp(t, e) {
          let r = W4(e);
          Zn(t, e.type.majorEncoded, r.length), t.push(r);
        }
        function N1e(t, e) {
          return t.length < e.length ? -1 : t.length > e.length ? 1 : ML(t, e);
        }
        var j4 = Fe(() => {
          c();
          vi();
          ro();
          _a();
          zu();
          mp.encodedSize = function(e) {
            let r = W4(e);
            return Zn.encodedSize(r.length) + r.length;
          };
          mp.compareTokens = function(e, r) {
            return N1e(W4(e), W4(r));
          };
        });
        function t2(t, e, r, n, i2) {
          let o = r + n;
          _c(t, e, o);
          let s = new Q(L.string, OL(t, e + r, e + o), o);
          return i2.retainStringBytes === true && (s.byteValue = pp(t, e + r, e + o)), s;
        }
        function JL(t, e, r, n) {
          return t2(t, e, 1, r, n);
        }
        function eB(t, e, r, n) {
          return t2(t, e, 2, no(t, e + 1, n), n);
        }
        function tB(t, e, r, n) {
          return t2(t, e, 3, io(t, e + 1, n), n);
        }
        function rB(t, e, r, n) {
          return t2(t, e, 5, oo(t, e + 1, n), n);
        }
        function nB(t, e, r, n) {
          let i2 = so(t, e + 1, n);
          if (typeof i2 == "bigint")
            throw new Error(`${Ie} 64-bit integer string lengths not supported`);
          return t2(t, e, 9, i2, n);
        }
        var iB, x9 = Fe(() => {
          c();
          vi();
          ro();
          _a();
          j4();
          zu();
          iB = mp;
        });
        function yp(t, e, r, n) {
          return new Q(L.array, n, r);
        }
        function oB(t, e, r, n) {
          return yp(t, e, 1, r);
        }
        function sB(t, e, r, n) {
          return yp(t, e, 2, no(t, e + 1, n));
        }
        function aB(t, e, r, n) {
          return yp(t, e, 3, io(t, e + 1, n));
        }
        function cB(t, e, r, n) {
          return yp(t, e, 5, oo(t, e + 1, n));
        }
        function uB(t, e, r, n) {
          let i2 = so(t, e + 1, n);
          if (typeof i2 == "bigint")
            throw new Error(`${Ie} 64-bit integer array lengths not supported`);
          return yp(t, e, 9, i2);
        }
        function lB(t, e, r, n) {
          if (n.allowIndefinite === false)
            throw new Error(`${Ie} indefinite length items not allowed`);
          return yp(t, e, 1, 1 / 0);
        }
        function Y4(t, e) {
          Zn(t, L.array.majorEncoded, e.value);
        }
        var R9 = Fe(() => {
          c();
          vi();
          _a();
          ro();
          Y4.compareTokens = Ko.compareTokens;
          Y4.encodedSize = function(e) {
            return Zn.encodedSize(e.value);
          };
        });
        function gp(t, e, r, n) {
          return new Q(L.map, n, r);
        }
        function fB(t, e, r, n) {
          return gp(t, e, 1, r);
        }
        function hB(t, e, r, n) {
          return gp(t, e, 2, no(t, e + 1, n));
        }
        function dB(t, e, r, n) {
          return gp(t, e, 3, io(t, e + 1, n));
        }
        function pB(t, e, r, n) {
          return gp(t, e, 5, oo(t, e + 1, n));
        }
        function mB(t, e, r, n) {
          let i2 = so(t, e + 1, n);
          if (typeof i2 == "bigint")
            throw new Error(`${Ie} 64-bit integer map lengths not supported`);
          return gp(t, e, 9, i2);
        }
        function yB(t, e, r, n) {
          if (n.allowIndefinite === false)
            throw new Error(`${Ie} indefinite length items not allowed`);
          return gp(t, e, 1, 1 / 0);
        }
        function Q4(t, e) {
          Zn(t, L.map.majorEncoded, e.value);
        }
        var A9 = Fe(() => {
          c();
          vi();
          _a();
          ro();
          Q4.compareTokens = Ko.compareTokens;
          Q4.encodedSize = function(e) {
            return Zn.encodedSize(e.value);
          };
        });
        function gB(t, e, r, n) {
          return new Q(L.tag, r, 1);
        }
        function wB(t, e, r, n) {
          return new Q(L.tag, no(t, e + 1, n), 2);
        }
        function EB(t, e, r, n) {
          return new Q(L.tag, io(t, e + 1, n), 3);
        }
        function bB(t, e, r, n) {
          return new Q(L.tag, oo(t, e + 1, n), 5);
        }
        function _B(t, e, r, n) {
          return new Q(L.tag, so(t, e + 1, n), 9);
        }
        function X4(t, e) {
          Zn(t, L.tag.majorEncoded, e.value);
        }
        var T9 = Fe(() => {
          c();
          vi();
          _a();
          X4.compareTokens = Ko.compareTokens;
          X4.encodedSize = function(e) {
            return Zn.encodedSize(e.value);
          };
        });
        function vB(t, e, r, n) {
          if (n.allowUndefined === false)
            throw new Error(`${Ie} undefined values are not supported`);
          return n.coerceUndefinedToNull === true ? new Q(L.null, null, 1) : new Q(L.undefined, void 0, 1);
        }
        function SB(t, e, r, n) {
          if (n.allowIndefinite === false)
            throw new Error(`${Ie} indefinite length items not allowed`);
          return new Q(L.break, void 0, 1);
        }
        function I9(t, e, r) {
          if (r) {
            if (r.allowNaN === false && Number.isNaN(t))
              throw new Error(`${Ie} NaN values are not supported`);
            if (r.allowInfinity === false && (t === 1 / 0 || t === -1 / 0))
              throw new Error(`${Ie} Infinity values are not supported`);
          }
          return new Q(L.float, t, e);
        }
        function xB(t, e, r, n) {
          return I9(C9(t, e + 1), 3, n);
        }
        function RB(t, e, r, n) {
          return I9(P9(t, e + 1), 5, n);
        }
        function AB(t, e, r, n) {
          return I9(PB(t, e + 1), 9, n);
        }
        function Z4(t, e, r) {
          let n = e.value;
          if (n === false)
            t.push([L.float.majorEncoded | F1e]);
          else if (n === true)
            t.push([L.float.majorEncoded | K1e]);
          else if (n === null)
            t.push([L.float.majorEncoded | V1e]);
          else if (n === void 0)
            t.push([L.float.majorEncoded | q1e]);
          else {
            let i2, o = false;
            (!r || r.float64 !== true) && (IB(n), i2 = C9(Rs, 1), n === i2 || Number.isNaN(n) ? (Rs[0] = 249, t.push(Rs.slice(0, 3)), o = true) : (CB(n), i2 = P9(Rs, 1), n === i2 && (Rs[0] = 250, t.push(Rs.slice(0, 5)), o = true))), o || (z1e(n), i2 = PB(Rs, 1), Rs[0] = 251, t.push(Rs.slice(0, 9)));
          }
        }
        function IB(t) {
          if (t === 1 / 0)
            Vo.setUint16(0, 31744, false);
          else if (t === -1 / 0)
            Vo.setUint16(0, 64512, false);
          else if (Number.isNaN(t))
            Vo.setUint16(0, 32256, false);
          else {
            Vo.setFloat32(0, t);
            let e = Vo.getUint32(0), r = (e & 2139095040) >> 23, n = e & 8388607;
            if (r === 255)
              Vo.setUint16(0, 31744, false);
            else if (r === 0)
              Vo.setUint16(0, (t & 2147483648) >> 16 | n >> 13, false);
            else {
              let i2 = r - 127;
              i2 < -24 ? Vo.setUint16(0, 0) : i2 < -14 ? Vo.setUint16(0, (e & 2147483648) >> 16 | 1 << 24 + i2, false) : Vo.setUint16(0, (e & 2147483648) >> 16 | i2 + 15 << 10 | n >> 13, false);
            }
          }
        }
        function C9(t, e) {
          if (t.length - e < 2)
            throw new Error(`${Ie} not enough data for float16`);
          let r = (t[e] << 8) + t[e + 1];
          if (r === 31744)
            return 1 / 0;
          if (r === 64512)
            return -1 / 0;
          if (r === 32256)
            return NaN;
          let n = r >> 10 & 31, i2 = r & 1023, o;
          return n === 0 ? o = i2 * 2 ** -24 : n !== 31 ? o = (i2 + 1024) * 2 ** (n - 25) : o = i2 === 0 ? 1 / 0 : NaN, r & 32768 ? -o : o;
        }
        function CB(t) {
          Vo.setFloat32(0, t, false);
        }
        function P9(t, e) {
          if (t.length - e < 4)
            throw new Error(`${Ie} not enough data for float32`);
          let r = (t.byteOffset || 0) + e;
          return new DataView(t.buffer, r, 4).getFloat32(0, false);
        }
        function z1e(t) {
          Vo.setFloat64(0, t, false);
        }
        function PB(t, e) {
          if (t.length - e < 8)
            throw new Error(`${Ie} not enough data for float64`);
          let r = (t.byteOffset || 0) + e;
          return new DataView(t.buffer, r, 8).getFloat64(0, false);
        }
        var F1e, K1e, V1e, q1e, TB, Vo, Rs, D9 = Fe(() => {
          c();
          vi();
          ro();
          _a();
          F1e = 20, K1e = 21, V1e = 22, q1e = 23;
          Z4.encodedSize = function(e, r) {
            let n = e.value;
            if (n === false || n === true || n === null || n === void 0)
              return 1;
            if (!r || r.float64 !== true) {
              IB(n);
              let i2 = C9(Rs, 1);
              if (n === i2 || Number.isNaN(n))
                return 3;
              if (CB(n), i2 = P9(Rs, 1), n === i2)
                return 5;
            }
            return 9;
          };
          TB = new ArrayBuffer(9), Vo = new DataView(TB, 1), Rs = new Uint8Array(TB, 0);
          Z4.compareTokens = Ko.compareTokens;
        });
        function Vt(t, e, r) {
          throw new Error(`${Ie} encountered invalid minor (${r}) for major ${t[e] >>> 5}`);
        }
        function J4(t) {
          return () => {
            throw new Error(`${Ie} ${t}`);
          };
        }
        function DB(t) {
          switch (t.type) {
            case L.false:
              return ba([244]);
            case L.true:
              return ba([245]);
            case L.null:
              return ba([246]);
            case L.bytes:
              return t.value.length ? void 0 : ba([64]);
            case L.string:
              return t.value === "" ? ba([96]) : void 0;
            case L.array:
              return t.value === 0 ? ba([128]) : void 0;
            case L.map:
              return t.value === 0 ? ba([160]) : void 0;
            case L.uint:
              return t.value < 24 ? ba([Number(t.value)]) : void 0;
            case L.negint:
              if (t.value >= -24)
                return ba([31 - Number(t.value)]);
          }
        }
        var ie, As, k9 = Fe(() => {
          c();
          vi();
          _a();
          S9();
          j4();
          x9();
          R9();
          A9();
          T9();
          D9();
          ro();
          zu();
          ie = [];
          for (let t = 0; t <= 23; t++)
            ie[t] = Vt;
          ie[24] = FL;
          ie[25] = KL;
          ie[26] = VL;
          ie[27] = qL;
          ie[28] = Vt;
          ie[29] = Vt;
          ie[30] = Vt;
          ie[31] = Vt;
          for (let t = 32; t <= 55; t++)
            ie[t] = Vt;
          ie[56] = zL;
          ie[57] = HL;
          ie[58] = $L;
          ie[59] = WL;
          ie[60] = Vt;
          ie[61] = Vt;
          ie[62] = Vt;
          ie[63] = Vt;
          for (let t = 64; t <= 87; t++)
            ie[t] = jL;
          ie[88] = YL;
          ie[89] = QL;
          ie[90] = XL;
          ie[91] = ZL;
          ie[92] = Vt;
          ie[93] = Vt;
          ie[94] = Vt;
          ie[95] = J4("indefinite length bytes/strings are not supported");
          for (let t = 96; t <= 119; t++)
            ie[t] = JL;
          ie[120] = eB;
          ie[121] = tB;
          ie[122] = rB;
          ie[123] = nB;
          ie[124] = Vt;
          ie[125] = Vt;
          ie[126] = Vt;
          ie[127] = J4("indefinite length bytes/strings are not supported");
          for (let t = 128; t <= 151; t++)
            ie[t] = oB;
          ie[152] = sB;
          ie[153] = aB;
          ie[154] = cB;
          ie[155] = uB;
          ie[156] = Vt;
          ie[157] = Vt;
          ie[158] = Vt;
          ie[159] = lB;
          for (let t = 160; t <= 183; t++)
            ie[t] = fB;
          ie[184] = hB;
          ie[185] = dB;
          ie[186] = pB;
          ie[187] = mB;
          ie[188] = Vt;
          ie[189] = Vt;
          ie[190] = Vt;
          ie[191] = yB;
          for (let t = 192; t <= 215; t++)
            ie[t] = gB;
          ie[216] = wB;
          ie[217] = EB;
          ie[218] = bB;
          ie[219] = _B;
          ie[220] = Vt;
          ie[221] = Vt;
          ie[222] = Vt;
          ie[223] = Vt;
          for (let t = 224; t <= 243; t++)
            ie[t] = J4("simple values are not supported");
          ie[244] = Vt;
          ie[245] = Vt;
          ie[246] = Vt;
          ie[247] = vB;
          ie[248] = J4("simple values are not supported");
          ie[249] = xB;
          ie[250] = RB;
          ie[251] = AB;
          ie[252] = Vt;
          ie[253] = Vt;
          ie[254] = Vt;
          ie[255] = SB;
          As = [];
          for (let t = 0; t < 24; t++)
            As[t] = new Q(L.uint, t, 1);
          for (let t = -1; t >= -24; t--)
            As[31 - t] = new Q(L.negint, t, 1);
          As[64] = new Q(L.bytes, new Uint8Array(0), 1);
          As[96] = new Q(L.string, "", 1);
          As[128] = new Q(L.array, 0, 1);
          As[160] = new Q(L.map, 0, 1);
          As[244] = new Q(L.false, false, 1);
          As[245] = new Q(L.true, true, 1);
          As[246] = new Q(L.null, null, 1);
        });
        function G1e() {
          let t = [];
          return t[L.uint.major] = Ko, t[L.negint.major] = G4, t[L.bytes.major] = mp, t[L.string.major] = iB, t[L.array.major] = Y4, t[L.map.major] = Q4, t[L.tag.major] = X4, t[L.float.major] = Z4, t;
        }
        function ew(t, e = {}, r) {
          let n = CL(t), i2 = e && e.typeEncoders && e.typeEncoders[n] || $u[n];
          if (typeof i2 == "function") {
            let s = i2(t, n, e, r);
            if (s != null)
              return s;
          }
          let o = $u[n];
          if (!o)
            throw new Error(`${bc} unsupported type: ${n}`);
          return o(t, n, e, r);
        }
        function W1e(t, e) {
          e.mapSorter && t.sort(e.mapSorter);
        }
        function j1e(t, e) {
          let r = Array.isArray(t[0]) ? t[0][0] : t[0], n = Array.isArray(e[0]) ? e[0][0] : e[0];
          if (r.type !== n.type)
            return r.type.compare(n.type);
          let i2 = r.type.major, o = kB[i2].compareTokens(r, n);
          return o === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), o;
        }
        function NB(t, e, r, n) {
          if (Array.isArray(e))
            for (let i2 of e)
              NB(t, i2, r, n);
          else
            r[e.type.major](t, e, n);
        }
        function O9(t, e, r) {
          let n = ew(t, r);
          if (!Array.isArray(n) && r.quickEncodeToken) {
            let i2 = r.quickEncodeToken(n);
            if (i2)
              return i2;
            let o = e[n.type.major];
            if (o.encodedSize) {
              let s = o.encodedSize(n, r), a = new Zm(s);
              if (o(a, n, r), a.chunks.length !== 1)
                throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);
              return Xm(a.chunks[0]);
            }
          }
          return N9.reset(), NB(N9, n, e, r), N9.toBytes(true);
        }
        function ao(t, e) {
          return e = Object.assign({}, $1e, e), O9(t, kB, e);
        }
        var $1e, kB, N9, wp, Hu, $u, L9 = Fe(() => {
          c();
          PL();
          vi();
          UL();
          ro();
          k9();
          zu();
          _a();
          S9();
          j4();
          x9();
          R9();
          A9();
          T9();
          D9();
          $1e = { float64: false, mapSorter: j1e, quickEncodeToken: DB };
          kB = G1e(), N9 = new Zm(), wp = class {
            constructor(e, r) {
              this.obj = e, this.parent = r;
            }
            includes(e) {
              let r = this;
              do
                if (r.obj === e)
                  return true;
              while (r = r.parent);
              return false;
            }
            static createCheck(e, r) {
              if (e && e.includes(r))
                throw new Error(`${bc} object contains circular references`);
              return new wp(r, e);
            }
          }, Hu = { null: new Q(L.null, null), undefined: new Q(L.undefined, void 0), true: new Q(L.true, true), false: new Q(L.false, false), emptyArray: new Q(L.array, 0), emptyMap: new Q(L.map, 0) }, $u = { number(t, e, r, n) {
            return !Number.isInteger(t) || !Number.isSafeInteger(t) ? new Q(L.float, t) : t >= 0 ? new Q(L.uint, t) : new Q(L.negint, t);
          }, bigint(t, e, r, n) {
            return t >= BigInt(0) ? new Q(L.uint, t) : new Q(L.negint, t);
          }, Uint8Array(t, e, r, n) {
            return new Q(L.bytes, t);
          }, string(t, e, r, n) {
            return new Q(L.string, t);
          }, boolean(t, e, r, n) {
            return t ? Hu.true : Hu.false;
          }, null(t, e, r, n) {
            return Hu.null;
          }, undefined(t, e, r, n) {
            return Hu.undefined;
          }, ArrayBuffer(t, e, r, n) {
            return new Q(L.bytes, new Uint8Array(t));
          }, DataView(t, e, r, n) {
            return new Q(L.bytes, new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
          }, Array(t, e, r, n) {
            if (!t.length)
              return r.addBreakTokens === true ? [Hu.emptyArray, new Q(L.break)] : Hu.emptyArray;
            n = wp.createCheck(n, t);
            let i2 = [], o = 0;
            for (let s of t)
              i2[o++] = ew(s, r, n);
            return r.addBreakTokens ? [new Q(L.array, t.length), i2, new Q(L.break)] : [new Q(L.array, t.length), i2];
          }, Object(t, e, r, n) {
            let i2 = e !== "Object", o = i2 ? t.keys() : Object.keys(t), s = i2 ? t.size : o.length;
            if (!s)
              return r.addBreakTokens === true ? [Hu.emptyMap, new Q(L.break)] : Hu.emptyMap;
            n = wp.createCheck(n, t);
            let a = [], u = 0;
            for (let l of o)
              a[u++] = [ew(l, r, n), ew(i2 ? t.get(l) : t[l], r, n)];
            return W1e(a, r), r.addBreakTokens ? [new Q(L.map, s), a, new Q(L.break)] : [new Q(L.map, s), a];
          } };
          $u.Map = $u.Object;
          $u.Buffer = $u.Uint8Array;
          for (let t of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))
            $u[`${t}Array`] = $u.DataView;
        });
        function Q1e(t, e, r) {
          let n = [];
          for (let i2 = 0; i2 < t.value; i2++) {
            let o = n2(e, r);
            if (o === tw) {
              if (t.value === 1 / 0)
                break;
              throw new Error(`${Ie} got unexpected break to lengthed array`);
            }
            if (o === r2)
              throw new Error(`${Ie} found array but not enough entries (got ${i2}, expected ${t.value})`);
            n[i2] = o;
          }
          return n;
        }
        function X1e(t, e, r) {
          let n = r.useMaps === true, i2 = n ? void 0 : {}, o = n ? /* @__PURE__ */ new Map() : void 0;
          for (let s = 0; s < t.value; s++) {
            let a = n2(e, r);
            if (a === tw) {
              if (t.value === 1 / 0)
                break;
              throw new Error(`${Ie} got unexpected break to lengthed map`);
            }
            if (a === r2)
              throw new Error(`${Ie} found map but not enough entries (got ${s} [no key], expected ${t.value})`);
            if (n !== true && typeof a != "string")
              throw new Error(`${Ie} non-string keys not supported (got ${typeof a})`);
            let u = n2(e, r);
            if (u === r2)
              throw new Error(`${Ie} found map but not enough entries (got ${s} [no value], expected ${t.value})`);
            n ? o.set(a, u) : i2[a] = u;
          }
          return n ? o : i2;
        }
        function n2(t, e) {
          if (t.done())
            return r2;
          let r = t.next();
          if (r.type === L.break)
            return tw;
          if (r.type.terminal)
            return r.value;
          if (r.type === L.array)
            return Q1e(r, t, e);
          if (r.type === L.map)
            return X1e(r, t, e);
          if (r.type === L.tag) {
            if (e.tags && typeof e.tags[r.value] == "function") {
              let n = n2(t, e);
              return e.tags[r.value](n);
            }
            throw new Error(`${Ie} tag not supported (${r.value})`);
          }
          throw new Error("unsupported");
        }
        function Mn(t, e) {
          if (!(t instanceof Uint8Array))
            throw new Error(`${Ie} data to decode must be a Uint8Array`);
          e = Object.assign({}, Y1e, e);
          let r = e.tokenizer || new B9(t, e), n = n2(r, e);
          if (n === r2)
            throw new Error(`${Ie} did not find any content to decode`);
          if (n === tw)
            throw new Error(`${Ie} got unexpected break`);
          if (!r.done())
            throw new Error(`${Ie} too many terminals, data makes no sense`);
          return n;
        }
        var Y1e, B9, r2, tw, M9 = Fe(() => {
          c();
          ro();
          vi();
          k9();
          Y1e = { strict: false, allowIndefinite: true, allowUndefined: true, allowBigInt: true }, B9 = class {
            constructor(e, r = {}) {
              this.pos = 0, this.data = e, this.options = r;
            }
            done() {
              return this.pos >= this.data.length;
            }
            next() {
              let e = this.data[this.pos], r = As[e];
              if (r === void 0) {
                let n = ie[e];
                if (!n)
                  throw new Error(`${Ie} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, "0")})`);
                let i2 = e & 31;
                r = n(this.data, this.pos, i2, this.options);
              }
              return this.pos += r.encodedLength, r;
            }
          }, r2 = Symbol.for("DONE"), tw = Symbol.for("BREAK");
        });
        var Vf = Fe(() => {
          c();
          L9();
          M9();
          vi();
        });
        var Ep, F9, rw = Fe(() => {
          c();
          On();
          Ep = ({ name: t, code: e, encode: r }) => new F9(t, e, r), F9 = class {
            constructor(e, r, n) {
              this.name = e, this.code = r, this.encode = n;
            }
            digest(e) {
              if (e instanceof Uint8Array) {
                let r = this.encode(e);
                return r instanceof Uint8Array ? xs(this.code, r) : r.then((n) => xs(this.code, n));
              } else
                throw Error("Unknown type, must be binary type");
            }
          };
        });
        var bp = Fe(() => {
          c();
          te();
          K4();
          Mu();
          rw();
          On();
        });
        var G9 = A((Sp) => {
          "use strict";
          c();
          Object.defineProperty(Sp, "__esModule", { value: true });
          Sp.fromBase64url = Sp.toBase64url = void 0;
          var UB = (ma(), cr(N4));
          function pme(t) {
            return UB.base64url.encode(t).slice(1);
          }
          Sp.toBase64url = pme;
          function mme(t) {
            return UB.base64url.decode(`u${t}`);
          }
          Sp.fromBase64url = mme;
        });
        var FB = A((j9) => {
          "use strict";
          c();
          Object.defineProperty(j9, "__esModule", { value: true });
          var Hf = G9(), W9 = (te(), cr(Ym));
          function yme(t) {
            let [e, r, n] = t;
            return { payload: r, signatures: [{ protected: e, signature: n }], link: W9.CID.decode(Hf.fromBase64url(r)) };
          }
          function gme(t) {
            let e = { signature: Hf.fromBase64url(t.signature) };
            return t.header && (e.header = t.header), t.protected && (e.protected = Hf.fromBase64url(t.protected)), e;
          }
          function wme(t) {
            let e = Hf.fromBase64url(t.payload);
            try {
              W9.CID.decode(e);
            } catch {
              throw new Error("Not a valid DagJWS");
            }
            return { payload: e, signatures: t.signatures.map(gme) };
          }
          function Eme(t) {
            let e = { signature: Hf.toBase64url(t.signature) };
            return t.header && (e.header = t.header), t.protected && (e.protected = Hf.toBase64url(t.protected)), e;
          }
          function bme(t) {
            let e = { payload: Hf.toBase64url(t.payload), signatures: t.signatures.map(Eme) };
            return e.link = W9.CID.decode(new Uint8Array(t.payload)), e;
          }
          j9.default = { fromSplit: yme, encode: wme, decode: bme };
        });
        var KB = A((Y9) => {
          "use strict";
          c();
          Object.defineProperty(Y9, "__esModule", { value: true });
          var qo = G9();
          function _me(t) {
            let [e, r, n, i2, o] = t, s = { ciphertext: i2, iv: n, protected: e, tag: o };
            return r && (s.recipients = [{ encrypted_key: r }]), s;
          }
          function vme(t) {
            let e = {};
            return t.encrypted_key && (e.encrypted_key = qo.fromBase64url(t.encrypted_key)), t.header && (e.header = t.header), e;
          }
          function Sme(t) {
            let e = { ciphertext: qo.fromBase64url(t.ciphertext), protected: qo.fromBase64url(t.protected), iv: qo.fromBase64url(t.iv), tag: qo.fromBase64url(t.tag) };
            return t.aad && (e.aad = qo.fromBase64url(t.aad)), t.recipients && (e.recipients = t.recipients.map(vme)), t.unprotected && (e.unprotected = t.unprotected), e;
          }
          function xme(t) {
            let e = {};
            return t.encrypted_key && (e.encrypted_key = qo.toBase64url(t.encrypted_key)), t.header && (e.header = t.header), e;
          }
          function Rme(t) {
            let e = { ciphertext: qo.toBase64url(t.ciphertext), protected: qo.toBase64url(t.protected), iv: qo.toBase64url(t.iv), tag: qo.toBase64url(t.tag) };
            return t.aad && (e.aad = qo.toBase64url(t.aad)), t.recipients && (e.recipients = t.recipients.map(xme)), t.unprotected && (e.unprotected = t.unprotected), e;
          }
          Y9.default = { fromSplit: _me, decode: Rme, encode: Sme };
        });
        var zB = {};
        ct(zB, { code: () => kme, decode: () => Ome, encode: () => Nme, name: () => Dme });
        function Ame(t) {
          if (t.asCID !== t)
            return null;
          let e = I.asCID(t);
          if (!e)
            return null;
          let r = new Uint8Array(e.bytes.byteLength + 1);
          return r.set(e.bytes, 1), [new Q(L.tag, VB), new Q(L.bytes, r)];
        }
        function Tme() {
          throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
        }
        function Ime(t) {
          if (Number.isNaN(t))
            throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
          if (t === 1 / 0 || t === -1 / 0)
            throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
          return null;
        }
        function Pme(t) {
          if (t[0] !== 0)
            throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
          return I.decode(t.subarray(1));
        }
        var VB, Cme, qB, Dme, kme, Nme, Ome, HB = Fe(() => {
          c();
          Vf();
          te();
          VB = 42;
          Cme = { float64: true, typeEncoders: { Object: Ame, undefined: Tme, number: Ime } };
          qB = { allowIndefinite: false, allowUndefined: false, allowNaN: false, allowInfinity: false, allowBigInt: true, strict: true, useMaps: false, tags: [] };
          qB.tags[VB] = Pme;
          Dme = "dag-cbor", kme = 113, Nme = (t) => ao(t, Cme), Ome = (t) => Mn(t, qB);
        });
        var Z9 = A((hn) => {
          "use strict";
          c();
          var Lme = hn && hn.__createBinding || (Object.create ? function(t, e, r, n) {
            n === void 0 && (n = r), Object.defineProperty(t, n, { enumerable: true, get: function() {
              return e[r];
            } });
          } : function(t, e, r, n) {
            n === void 0 && (n = r), t[n] = e[r];
          }), Bme = hn && hn.__setModuleDefault || (Object.create ? function(t, e) {
            Object.defineProperty(t, "default", { enumerable: true, value: e });
          } : function(t, e) {
            t.default = e;
          }), Mme = hn && hn.__importStar || function(t) {
            if (t && t.__esModule)
              return t;
            var e = {};
            if (t != null)
              for (var r in t)
                r !== "default" && Object.prototype.hasOwnProperty.call(t, r) && Lme(e, t, r);
            return Bme(e, t), e;
          }, $B = hn && hn.__importDefault || function(t) {
            return t && t.__esModule ? t : { default: t };
          };
          Object.defineProperty(hn, "__esModule", { value: true });
          hn.decode = hn.encode = hn.toGeneral = hn.code = hn.name = void 0;
          var Q9 = $B(FB()), X9 = $B(KB()), GB = Mme((HB(), cr(zB)));
          hn.name = "dag-jose";
          hn.code = 133;
          function WB(t) {
            return "payload" in t && typeof t.payload == "string" && "signatures" in t && Array.isArray(t.signatures);
          }
          function Ume(t) {
            return "payload" in t && t.payload instanceof Uint8Array && "signatures" in t && Array.isArray(t.signatures);
          }
          function Fme(t) {
            return "ciphertext" in t && t.ciphertext instanceof Uint8Array && "iv" in t && t.iv instanceof Uint8Array && "protected" in t && t.protected instanceof Uint8Array && "tag" in t && t.tag instanceof Uint8Array;
          }
          function jB(t) {
            return "ciphertext" in t && typeof t.ciphertext == "string" && "iv" in t && typeof t.iv == "string" && "protected" in t && typeof t.protected == "string" && "tag" in t && typeof t.tag == "string";
          }
          function YB(t) {
            if (typeof t == "string") {
              let e = t.split(".");
              if (e.length === 3)
                return Q9.default.fromSplit(e);
              if (e.length === 5)
                return X9.default.fromSplit(e);
              throw new Error("Not a valid JOSE string");
            }
            if (WB(t) || jB(t))
              return t;
            throw new Error("Not a valid unencoded JOSE object");
          }
          hn.toGeneral = YB;
          function Kme(t) {
            typeof t == "string" && (t = YB(t));
            let e;
            if (WB(t))
              e = Q9.default.encode(t);
            else if (jB(t))
              e = X9.default.encode(t);
            else
              throw new Error("Not a valid JOSE object");
            return new Uint8Array(GB.encode(e));
          }
          hn.encode = Kme;
          function Vme(t) {
            let e;
            try {
              e = GB.decode(t);
            } catch {
              throw new Error("Not a valid DAG-JOSE object");
            }
            if (Ume(e))
              return Q9.default.decode(e);
            if (Fme(e))
              return X9.default.decode(e);
            throw new Error("Not a valid DAG-JOSE object");
          }
          hn.decode = Vme;
        });
        var J9 = {};
        ct(J9, { identity: () => $r });
        var QB, qme, XB, zme, $r, va = Fe(() => {
          c();
          Mu();
          On();
          QB = 0, qme = "identity", XB = Uo, zme = (t) => xs(QB, XB(t)), $r = { code: QB, name: qme, encode: XB, digest: zme };
        });
        var eS = {};
        ct(eS, { identity: () => Hme });
        var Hme, ZB = Fe(() => {
          c();
          _s();
          Mu();
          Hme = sp({ prefix: "\0", name: "identity", encode: (t) => Y7(t), decode: (t) => j7(t) });
        });
        var tS = {};
        ct(tS, { base2: () => $me });
        var $me, JB = Fe(() => {
          c();
          _s();
          $me = zr({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
        });
        var rS = {};
        ct(rS, { base8: () => Gme });
        var Gme, eM = Fe(() => {
          c();
          _s();
          Gme = zr({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
        });
        var nS = {};
        ct(nS, { base10: () => Wme });
        var Wme, tM = Fe(() => {
          c();
          _s();
          Wme = Uu({ prefix: "9", name: "base10", alphabet: "0123456789" });
        });
        var iS = {};
        ct(iS, { base16: () => jme, base16upper: () => Yme });
        var jme, Yme, rM = Fe(() => {
          c();
          _s();
          jme = zr({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Yme = zr({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
        });
        var oS = {};
        ct(oS, { base36: () => xp, base36upper: () => Qme });
        var xp, Qme, nw = Fe(() => {
          c();
          _s();
          xp = Uu({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), Qme = Uu({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
        });
        var sS = {};
        ct(sS, { base256emoji: () => t2e });
        function Jme(t) {
          return t.reduce((e, r) => (e += Xme[r], e), "");
        }
        function e2e(t) {
          let e = [];
          for (let r of t) {
            let n = Zme[r.codePointAt(0)];
            if (n === void 0)
              throw new Error(`Non-base256emoji character: ${r}`);
            e.push(n);
          }
          return new Uint8Array(e);
        }
        var nM, Xme, Zme, t2e, iM = Fe(() => {
          c();
          _s();
          nM = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), Xme = nM.reduce((t, e, r) => (t[r] = e, t), []), Zme = nM.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
          t2e = sp({ prefix: "\u{1F680}", name: "base256emoji", encode: Jme, decode: e2e });
        });
        var aS = {};
        ct(aS, { sha256: () => xe, sha512: () => r2e });
        var oM, xe, r2e, vr = Fe(() => {
          c();
          rw();
          oM = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), xe = Ep({ name: "sha2-256", code: 18, encode: oM("SHA-256") }), r2e = Ep({ name: "sha2-512", code: 19, encode: oM("SHA-512") });
        });
        var Fi = {};
        ct(Fi, { code: () => Un, decode: () => o2e, encode: () => i2e, name: () => n2e });
        var n2e, Un, i2e, o2e, zo = Fe(() => {
          c();
          Mu();
          n2e = "raw", Un = 85, i2e = (t) => Uo(t), o2e = (t) => Uo(t);
        });
        var iw = {};
        ct(iw, { code: () => cS, decode: () => l2e, encode: () => u2e, name: () => c2e });
        var s2e, a2e, c2e, cS, u2e, l2e, uS = Fe(() => {
          c();
          s2e = new TextEncoder(), a2e = new TextDecoder(), c2e = "json", cS = 512, u2e = (t) => s2e.encode(JSON.stringify(t)), l2e = (t) => JSON.parse(a2e.decode(t));
        });
        var Sa, ow, sw, o2 = Fe(() => {
          c();
          ZB();
          JB();
          eM();
          tM();
          rM();
          si();
          nw();
          Hr();
          ma();
          iM();
          vr();
          va();
          zo();
          uS();
          bp();
          Sa = { ...eS, ...tS, ...rS, ...nS, ...iS, ...Vm, ...oS, ...ap, ...N4, ...sS }, ow = { ...aS, ...J9 }, sw = { raw: Fi, json: iw };
        });
        function aM(t, e, r, n) {
          return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
        }
        var sM, fS, f2e, aw, hS = Fe(() => {
          c();
          o2();
          sM = aM("utf8", "u", (t) => {
            let e = new TextDecoder("utf8");
            return "u" + e.decode(t);
          }, (t) => new TextEncoder().encode(t.substring(1))), fS = aM("ascii", "a", (t) => {
            let e = "a";
            for (let r = 0; r < t.length; r++)
              e += String.fromCharCode(t[r]);
            return e;
          }, (t) => {
            t = t.substring(1);
            let e = new Uint8Array(t.length);
            for (let r = 0; r < t.length; r++)
              e[r] = t.charCodeAt(r);
            return e;
          }), f2e = { utf8: sM, "utf-8": sM, hex: Sa.base16, latin1: fS, ascii: fS, binary: fS, ...Sa }, aw = f2e;
        });
        var dS = {};
        ct(dS, { fromString: () => U });
        function U(t, e = "utf8") {
          let r = aw[e];
          if (!r)
            throw new Error(`Unsupported encoding "${e}"`);
          return r.decoder.decode(`${r.prefix}${t}`);
        }
        var Re = Fe(() => {
          c();
          hS();
        });
        var lM = A((CUe, uM) => {
          "use strict";
          c();
          var cM = "[a-fA-F\\d:]", Gu = (t) => t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${cM})|(?<=${cM})(?=\\s|$))` : "", Cs = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", dn = "[a-fA-F\\d]{1,4}", cw = `
(?:
(?:${dn}:){7}(?:${dn}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${dn}:){6}(?:${Cs}|:${dn}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${dn}:){5}(?::${Cs}|(?::${dn}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${dn}:){4}(?:(?::${dn}){0,1}:${Cs}|(?::${dn}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${dn}:){3}(?:(?::${dn}){0,2}:${Cs}|(?::${dn}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${dn}:){2}(?:(?::${dn}){0,3}:${Cs}|(?::${dn}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${dn}:){1}(?:(?::${dn}){0,4}:${Cs}|(?::${dn}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${dn}){0,5}:${Cs}|(?::${dn}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), h2e = new RegExp(`(?:^${Cs}$)|(?:^${cw}$)`), d2e = new RegExp(`^${Cs}$`), p2e = new RegExp(`^${cw}$`), pS = (t) => t && t.exact ? h2e : new RegExp(`(?:${Gu(t)}${Cs}${Gu(t)})|(?:${Gu(t)}${cw}${Gu(t)})`, "g");
          pS.v4 = (t) => t && t.exact ? d2e : new RegExp(`${Gu(t)}${Cs}${Gu(t)}`, "g");
          pS.v6 = (t) => t && t.exact ? p2e : new RegExp(`${Gu(t)}${cw}${Gu(t)}`, "g");
          uM.exports = pS;
        });
        var hM = A((PUe, fM) => {
          "use strict";
          c();
          var mS = lM(), Rp = (t) => mS({ exact: true }).test(t);
          Rp.v4 = (t) => mS.v4({ exact: true }).test(t);
          Rp.v6 = (t) => mS.v6({ exact: true }).test(t);
          Rp.version = (t) => Rp(t) ? Rp.v4(t) ? 4 : 6 : void 0;
          fM.exports = Rp;
        });
        var Ap = {};
        ct(Ap, { toString: () => M });
        function M(t, e = "utf8") {
          let r = aw[e];
          if (!r)
            throw new Error(`Unsupported encoding "${e}"`);
          return r.encoder.encode(t).substring(1);
        }
        var me = Fe(() => {
          c();
          hS();
        });
        var gM = A((kUe, yM) => {
          "use strict";
          c();
          var gS = hM(), { toString: dM } = (me(), cr(Ap)), m2e = gS, yS = gS.v4, pM = gS.v6, mM = function(t, e, r) {
            r = ~~r;
            let n;
            if (yS(t))
              n = e || new Uint8Array(r + 4), t.split(/\./g).map(function(i2) {
                n[r++] = parseInt(i2, 10) & 255;
              });
            else if (pM(t)) {
              let i2 = t.split(":", 8), o;
              for (o = 0; o < i2.length; o++) {
                let s = yS(i2[o]), a;
                s && (a = mM(i2[o]), i2[o] = dM(a.slice(0, 2), "base16")), a && ++o < 8 && i2.splice(o, 0, dM(a.slice(2, 4), "base16"));
              }
              if (i2[0] === "")
                for (; i2.length < 8; )
                  i2.unshift("0");
              else if (i2[i2.length - 1] === "")
                for (; i2.length < 8; )
                  i2.push("0");
              else if (i2.length < 8) {
                for (o = 0; o < i2.length && i2[o] !== ""; o++)
                  ;
                let s = [o, "1"];
                for (o = 9 - i2.length; o > 0; o--)
                  s.push("0");
                i2.splice.apply(i2, s);
              }
              for (n = e || new Uint8Array(r + 16), o = 0; o < i2.length; o++) {
                let s = parseInt(i2[o], 16);
                n[r++] = s >> 8 & 255, n[r++] = s & 255;
              }
            }
            if (!n)
              throw Error("Invalid ip address: " + t);
            return n;
          }, y2e = function(t, e, r) {
            e = ~~e, r = r || t.length - e;
            let n = [], i2, o = new DataView(t.buffer);
            if (r === 4) {
              for (let s = 0; s < r; s++)
                n.push(t[e + s]);
              i2 = n.join(".");
            } else if (r === 16) {
              for (let s = 0; s < r; s += 2)
                n.push(o.getUint16(e + s).toString(16));
              i2 = n.join(":"), i2 = i2.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), i2 = i2.replace(/:{3,4}/, "::");
            }
            return i2;
          };
          yM.exports = { isIP: m2e, isV4: yS, isV6: pM, toBytes: mM, toString: y2e };
        });
        var uw = A((NUe, EM) => {
          "use strict";
          c();
          function Ki(t) {
            if (typeof t == "number") {
              if (Ki.codes[t])
                return Ki.codes[t];
              throw new Error("no protocol with code: " + t);
            } else if (typeof t == "string") {
              if (Ki.names[t])
                return Ki.names[t];
              throw new Error("no protocol with name: " + t);
            }
            throw new Error("invalid protocol id type: " + t);
          }
          var Ho = -1;
          Ki.lengthPrefixedVarSize = Ho;
          Ki.V = Ho;
          Ki.table = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, Ho, "ip6zone"], [53, Ho, "dns", "resolvable"], [54, Ho, "dns4", "resolvable"], [55, Ho, "dns6", "resolvable"], [56, Ho, "dnsaddr", "resolvable"], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, Ho, "unix", false, "path"], [421, Ho, "ipfs"], [421, Ho, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, Ho, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, Ho, "memory"]];
          Ki.names = {};
          Ki.codes = {};
          Ki.table.map((t) => {
            let e = wM.apply(null, t);
            return Ki.codes[e.code] = e, Ki.names[e.name] = e, null;
          });
          Ki.object = wM;
          function wM(t, e, r, n, i2) {
            return { code: t, size: e, name: r, resolvable: Boolean(n), path: Boolean(i2) };
          }
          EM.exports = Ki;
        });
        var vM = A((OUe, _M) => {
          c();
          _M.exports = wS;
          var bM = 128, g2e = 127, w2e = ~g2e, E2e = Math.pow(2, 31);
          function wS(t, e, r) {
            if (Number.MAX_SAFE_INTEGER && t > Number.MAX_SAFE_INTEGER)
              throw wS.bytes = 0, new RangeError("Could not encode varint");
            e = e || [], r = r || 0;
            for (var n = r; t >= E2e; )
              e[r++] = t & 255 | bM, t /= 128;
            for (; t & w2e; )
              e[r++] = t & 255 | bM, t >>>= 7;
            return e[r] = t | 0, wS.bytes = r - n + 1, e;
          }
        });
        var RM = A((LUe, xM) => {
          c();
          xM.exports = ES;
          var b2e = 128, SM = 127;
          function ES(t, n) {
            var r = 0, n = n || 0, i2 = 0, o = n, s, a = t.length;
            do {
              if (o >= a || i2 > 49)
                throw ES.bytes = 0, new RangeError("Could not decode varint");
              s = t[o++], r += i2 < 28 ? (s & SM) << i2 : (s & SM) * Math.pow(2, i2), i2 += 7;
            } while (s >= b2e);
            return ES.bytes = o - n, r;
          }
        });
        var TM = A((BUe, AM) => {
          c();
          var _2e = Math.pow(2, 7), v2e = Math.pow(2, 14), S2e = Math.pow(2, 21), x2e = Math.pow(2, 28), R2e = Math.pow(2, 35), A2e = Math.pow(2, 42), T2e = Math.pow(2, 49), I2e = Math.pow(2, 56), C2e = Math.pow(2, 63);
          AM.exports = function(t) {
            return t < _2e ? 1 : t < v2e ? 2 : t < S2e ? 3 : t < x2e ? 4 : t < R2e ? 5 : t < A2e ? 6 : t < T2e ? 7 : t < I2e ? 8 : t < C2e ? 9 : 10;
          };
        });
        var ai = A((MUe, IM) => {
          c();
          IM.exports = { encode: vM(), decode: RM(), encodingLength: TM() };
        });
        var s2 = {};
        ct(s2, { concat: () => Ae });
        function Ae(t, e) {
          e || (e = t.reduce((i2, o) => i2 + o.length, 0));
          let r = new Uint8Array(e), n = 0;
          for (let i2 of t)
            r.set(i2, n), n += i2.length;
          return r;
        }
        var ur = Fe(() => {
          c();
        });
        var BM = A((UUe, LM) => {
          "use strict";
          c();
          var lw = gM(), DM = uw(), { CID: P2e } = (te(), cr(Ym)), { base32: kM } = (si(), cr(Vm)), { base58btc: D2e } = (Hr(), cr(ap)), k2e = (On(), cr(xn)), Tp = ai(), { toString: fw } = (me(), cr(Ap)), { fromString: NM } = (Re(), cr(dS)), { concat: hw } = (ur(), cr(s2));
          LM.exports = a2;
          function a2(t, e) {
            return e instanceof Uint8Array ? a2.toString(t, e) : a2.toBytes(t, e);
          }
          a2.toString = function(e, r) {
            switch (DM(e).code) {
              case 4:
              case 41:
                return N2e(r);
              case 6:
              case 273:
              case 33:
              case 132:
                return OM(r).toString();
              case 53:
              case 54:
              case 55:
              case 56:
              case 400:
              case 777:
                return L2e(r);
              case 421:
                return M2e(r);
              case 444:
                return PM(r);
              case 445:
                return PM(r);
              default:
                return fw(r, "base16");
            }
          };
          a2.toBytes = function(e, r) {
            switch (DM(e).code) {
              case 4:
                return CM(r);
              case 41:
                return CM(r);
              case 6:
              case 273:
              case 33:
              case 132:
                return bS(parseInt(r, 10));
              case 53:
              case 54:
              case 55:
              case 56:
              case 400:
              case 777:
                return O2e(r);
              case 421:
                return B2e(r);
              case 444:
                return U2e(r);
              case 445:
                return F2e(r);
              default:
                return NM(r, "base16");
            }
          };
          function CM(t) {
            if (!lw.isIP(t))
              throw new Error("invalid ip address");
            return lw.toBytes(t);
          }
          function N2e(t) {
            let e = lw.toString(t);
            if (!e || !lw.isIP(e))
              throw new Error("invalid ip address");
            return e;
          }
          function bS(t) {
            let e = new ArrayBuffer(2);
            return new DataView(e).setUint16(0, t), new Uint8Array(e);
          }
          function OM(t) {
            return new DataView(t.buffer).getUint16(t.byteOffset);
          }
          function O2e(t) {
            let e = NM(t), r = Uint8Array.from(Tp.encode(e.length));
            return hw([r, e], r.length + e.length);
          }
          function L2e(t) {
            let e = Tp.decode(t);
            if (t = t.slice(Tp.decode.bytes), t.length !== e)
              throw new Error("inconsistent lengths");
            return fw(t);
          }
          function B2e(t) {
            let e;
            t[0] === "Q" || t[0] === "1" ? e = k2e.decode(D2e.decode(`z${t}`)).bytes : e = P2e.parse(t).multihash.bytes;
            let r = Uint8Array.from(Tp.encode(e.length));
            return hw([r, e], r.length + e.length);
          }
          function M2e(t) {
            let e = Tp.decode(t), r = t.slice(Tp.decode.bytes);
            if (r.length !== e)
              throw new Error("inconsistent lengths");
            return fw(r, "base58btc");
          }
          function U2e(t) {
            let e = t.split(":");
            if (e.length !== 2)
              throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
            if (e[0].length !== 16)
              throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion address.");
            let r = kM.decode("b" + e[0]), n = parseInt(e[1], 10);
            if (n < 1 || n > 65536)
              throw new Error("Port number is not in range(1, 65536)");
            let i2 = bS(n);
            return hw([r, i2], r.length + i2.length);
          }
          function F2e(t) {
            let e = t.split(":");
            if (e.length !== 2)
              throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
            if (e[0].length !== 56)
              throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion3 address.");
            let r = kM.decode("b" + e[0]), n = parseInt(e[1], 10);
            if (n < 1 || n > 65536)
              throw new Error("Port number is not in range(1, 65536)");
            let i2 = bS(n);
            return hw([r, i2], r.length + i2.length);
          }
          function PM(t) {
            let e = t.slice(0, t.length - 2), r = t.slice(t.length - 2), n = fw(e, "base32"), i2 = OM(r);
            return n + ":" + i2;
          }
        });
        var jM = A((FUe, WM) => {
          "use strict";
          c();
          var UM = BM(), _S = uw(), c2 = ai(), { concat: MM } = (ur(), cr(s2)), { toString: K2e } = (me(), cr(Ap));
          WM.exports = { stringToStringTuples: FM, stringTuplesToString: KM, tuplesToStringTuples: qM, stringTuplesToTuples: VM, bytesToTuples: vS, tuplesToBytes: zM, bytesToString: V2e, stringToBytes: $M, fromString: q2e, fromBytes: GM, validateBytes: SS, isValidBytes: z2e, cleanPath: dw, ParseError: xS, protoFromTuple: u2, sizeForAddr: HM };
          function FM(t) {
            let e = [], r = t.split("/").slice(1);
            if (r.length === 1 && r[0] === "")
              return [];
            for (let n = 0; n < r.length; n++) {
              let i2 = r[n], o = _S(i2);
              if (o.size === 0) {
                e.push([i2]);
                continue;
              }
              if (n++, n >= r.length)
                throw xS("invalid address: " + t);
              if (o.path) {
                e.push([i2, dw(r.slice(n).join("/"))]);
                break;
              }
              e.push([i2, r[n]]);
            }
            return e;
          }
          function KM(t) {
            let e = [];
            return t.map((r) => {
              let n = u2(r);
              return e.push(n.name), r.length > 1 && e.push(r[1]), null;
            }), dw(e.join("/"));
          }
          function VM(t) {
            return t.map((e) => {
              Array.isArray(e) || (e = [e]);
              let r = u2(e);
              return e.length > 1 ? [r.code, UM.toBytes(r.code, e[1])] : [r.code];
            });
          }
          function qM(t) {
            return t.map((e) => {
              let r = u2(e);
              return e[1] ? [r.code, UM.toString(r.code, e[1])] : [r.code];
            });
          }
          function zM(t) {
            return GM(MM(t.map((e) => {
              let r = u2(e), n = Uint8Array.from(c2.encode(r.code));
              return e.length > 1 && (n = MM([n, e[1]])), n;
            })));
          }
          function HM(t, e) {
            return t.size > 0 ? t.size / 8 : t.size === 0 ? 0 : c2.decode(e) + c2.decode.bytes;
          }
          function vS(t) {
            let e = [], r = 0;
            for (; r < t.length; ) {
              let n = c2.decode(t, r), i2 = c2.decode.bytes, o = _S(n), s = HM(o, t.slice(r + i2));
              if (s === 0) {
                e.push([n]), r += i2;
                continue;
              }
              let a = t.slice(r + i2, r + i2 + s);
              if (r += s + i2, r > t.length)
                throw xS("Invalid address Uint8Array: " + K2e(t, "base16"));
              e.push([n, a]);
            }
            return e;
          }
          function V2e(t) {
            let e = vS(t), r = qM(e);
            return KM(r);
          }
          function $M(t) {
            t = dw(t);
            let e = FM(t), r = VM(e);
            return zM(r);
          }
          function q2e(t) {
            return $M(t);
          }
          function GM(t) {
            let e = SS(t);
            if (e)
              throw e;
            return Uint8Array.from(t);
          }
          function SS(t) {
            try {
              vS(t);
            } catch (e) {
              return e;
            }
          }
          function z2e(t) {
            return SS(t) === void 0;
          }
          function dw(t) {
            return "/" + t.trim().split("/").filter((e) => e).join("/");
          }
          function xS(t) {
            return new Error("Error parsing address: " + t);
          }
          function u2(t) {
            return _S(t[0]);
          }
        });
        var YM = {};
        ct(YM, { equals: () => Ce });
        function Ce(t, e) {
          if (t === e)
            return true;
          if (t.byteLength !== e.byteLength)
            return false;
          for (let r = 0; r < t.byteLength; r++)
            if (t[r] !== e[r])
              return false;
          return true;
        }
        var yr = Fe(() => {
          c();
        });
        var mw = A((KUe, ZM) => {
          "use strict";
          c();
          var Ps = jM(), Ip = uw(), QM = ai(), { CID: H2e } = (te(), cr(Ym)), { base58btc: $2e } = (Hr(), cr(ap)), G2e = K(), W2e = Symbol.for("nodejs.util.inspect.custom"), { toString: pw } = (me(), cr(Ap)), { equals: j2e } = (yr(), cr(YM)), RS = /* @__PURE__ */ new Map(), XM = Symbol.for("@multiformats/js-multiaddr/multiaddr"), ci = class {
            constructor(e) {
              if (e == null && (e = ""), Object.defineProperty(this, XM, { value: true }), e instanceof Uint8Array)
                this.bytes = Ps.fromBytes(e);
              else if (typeof e == "string") {
                if (e.length > 0 && e.charAt(0) !== "/")
                  throw new Error(`multiaddr "${e}" must start with a "/"`);
                this.bytes = Ps.fromString(e);
              } else if (ci.isMultiaddr(e))
                this.bytes = Ps.fromBytes(e.bytes);
              else
                throw new Error("addr must be a string, Buffer, or another Multiaddr");
            }
            toString() {
              return Ps.bytesToString(this.bytes);
            }
            toJSON() {
              return this.toString();
            }
            toOptions() {
              let e = {}, r = this.toString().split("/");
              return e.family = r[1] === "ip4" ? 4 : 6, e.host = r[2], e.transport = r[3], e.port = parseInt(r[4]), e;
            }
            protos() {
              return this.protoCodes().map((e) => Object.assign({}, Ip(e)));
            }
            protoCodes() {
              let e = [], r = this.bytes, n = 0;
              for (; n < r.length; ) {
                let i2 = QM.decode(r, n), o = QM.decode.bytes, s = Ip(i2);
                n += Ps.sizeForAddr(s, r.slice(n + o)) + o, e.push(i2);
              }
              return e;
            }
            protoNames() {
              return this.protos().map((e) => e.name);
            }
            tuples() {
              return Ps.bytesToTuples(this.bytes);
            }
            stringTuples() {
              let e = Ps.bytesToTuples(this.bytes);
              return Ps.tuplesToStringTuples(e);
            }
            encapsulate(e) {
              return e = new ci(e), new ci(this.toString() + e.toString());
            }
            decapsulate(e) {
              let r = e.toString(), n = this.toString(), i2 = n.lastIndexOf(r);
              if (i2 < 0)
                throw new Error("Address " + this + " does not contain subaddress: " + e);
              return new ci(n.slice(0, i2));
            }
            decapsulateCode(e) {
              let r = this.tuples();
              for (let n = r.length - 1; n >= 0; n--)
                if (r[n][0] === e)
                  return new ci(Ps.tuplesToBytes(r.slice(0, n)));
              return this;
            }
            getPeerId() {
              try {
                let r = this.stringTuples().filter((n) => n[0] === Ip.names.ipfs.code).pop();
                if (r && r[1]) {
                  let n = r[1];
                  return n[0] === "Q" || n[0] === "1" ? pw($2e.decode(`z${n}`), "base58btc") : pw(H2e.parse(n).multihash.bytes, "base58btc");
                }
                return null;
              } catch {
                return null;
              }
            }
            getPath() {
              let e = null;
              try {
                e = this.stringTuples().filter((r) => !!Ip(r[0]).path)[0][1], e || (e = null);
              } catch {
                e = null;
              }
              return e;
            }
            equals(e) {
              return j2e(this.bytes, e.bytes);
            }
            async resolve() {
              let e = this.protos().find((i2) => i2.resolvable);
              if (!e)
                return [this];
              let r = RS.get(e.name);
              if (!r)
                throw G2e(new Error(`no available resolver for ${e.name}`), "ERR_NO_AVAILABLE_RESOLVER");
              return (await r(this)).map((i2) => new ci(i2));
            }
            nodeAddress() {
              let e = this.protoCodes(), r = this.protoNames(), n = this.toString().split("/").slice(1);
              if (n.length < 4)
                throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
              if (e[0] !== 4 && e[0] !== 41 && e[0] !== 54 && e[0] !== 55)
                throw new Error(`no protocol with name: "'${r[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
              if (n[2] !== "tcp" && n[2] !== "udp")
                throw new Error(`no protocol with name: "'${r[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
              return { family: e[0] === 41 || e[0] === 55 ? 6 : 4, address: n[1], port: parseInt(n[3]) };
            }
            isThinWaistAddress(e) {
              let r = (e || this).protos();
              return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273);
            }
            static fromNodeAddress(e, r) {
              if (!e)
                throw new Error("requires node address object");
              if (!r)
                throw new Error("requires transport protocol");
              let n;
              switch (e.family) {
                case 4:
                  n = "ip4";
                  break;
                case 6:
                  n = "ip6";
                  break;
                default:
                  throw Error(`Invalid addr family. Got '${e.family}' instead of 4 or 6`);
              }
              return new ci("/" + [n, e.address, r, e.port].join("/"));
            }
            static isName(e) {
              return ci.isMultiaddr(e) ? e.protos().some((r) => r.resolvable) : false;
            }
            static isMultiaddr(e) {
              return e instanceof ci || Boolean(e && e[XM]);
            }
            [W2e]() {
              return "<Multiaddr " + pw(this.bytes, "base16") + " - " + Ps.bytesToString(this.bytes) + ">";
            }
            inspect() {
              return "<Multiaddr " + pw(this.bytes, "base16") + " - " + Ps.bytesToString(this.bytes) + ">";
            }
          };
          ci.protocols = Ip;
          ci.resolvers = RS;
          function Y2e(t) {
            return new ci(t);
          }
          ZM.exports = { Multiaddr: ci, multiaddr: Y2e, protocols: Ip, resolvers: RS };
        });
        var uU = A((VUe, cU) => {
          "use strict";
          c();
          var { Multiaddr: AS } = mw(), tU = Ve("dns4"), rU = Ve("dns6"), nU = Ve("dnsaddr"), Wf = ui(Ve("dns"), nU, tU, rU), l2 = ui(Ve("ip4"), Ve("ip6")), Np = ui(ht(l2, Ve("tcp")), ht(Wf, Ve("tcp"))), TS = ht(l2, Ve("udp")), iU = ht(TS, Ve("utp")), oU = ht(TS, Ve("quic")), Pp = ui(ht(Np, Ve("ws")), ht(Wf, Ve("ws"))), Dp = ui(ht(Np, Ve("wss")), ht(Wf, Ve("wss"))), yw = ui(ht(Np, Ve("http")), ht(l2, Ve("http")), ht(Wf, Ve("http"))), gw = ui(ht(Np, Ve("https")), ht(l2, Ve("https")), ht(Wf, Ve("https"))), IS = ui(ht(Pp, Ve("p2p-webrtc-star"), Ve("p2p")), ht(Dp, Ve("p2p-webrtc-star"), Ve("p2p")), ht(Pp, Ve("p2p-webrtc-star")), ht(Dp, Ve("p2p-webrtc-star"))), Q2e = ui(ht(Pp, Ve("p2p-websocket-star"), Ve("p2p")), ht(Dp, Ve("p2p-websocket-star"), Ve("p2p")), ht(Pp, Ve("p2p-websocket-star")), ht(Dp, Ve("p2p-websocket-star"))), CS = ui(ht(yw, Ve("p2p-webrtc-direct"), Ve("p2p")), ht(gw, Ve("p2p-webrtc-direct"), Ve("p2p")), ht(yw, Ve("p2p-webrtc-direct")), ht(gw, Ve("p2p-webrtc-direct"))), kp = ui(Pp, Dp, yw, gw, IS, CS, Np, iU, oU, Wf), X2e = ui(ht(kp, Ve("p2p-stardust"), Ve("p2p")), ht(kp, Ve("p2p-stardust"))), Wu = ui(ht(kp, Ve("p2p")), IS, CS, Ve("p2p")), JM = ui(ht(Wu, Ve("p2p-circuit"), Wu), ht(Wu, Ve("p2p-circuit")), ht(Ve("p2p-circuit"), Wu), ht(kp, Ve("p2p-circuit")), ht(Ve("p2p-circuit"), kp), Ve("p2p-circuit")), sU = () => ui(ht(JM, sU), JM), Cp = sU(), eU = ui(ht(Cp, Wu, Cp), ht(Wu, Cp), ht(Cp, Wu), Cp, Wu);
          cU.exports = { DNS: Wf, DNS4: tU, DNS6: rU, DNSADDR: nU, IP: l2, TCP: Np, UDP: TS, QUIC: oU, UTP: iU, HTTP: yw, HTTPS: gw, WebSockets: Pp, WebSocketsSecure: Dp, WebSocketStar: Q2e, WebRTCStar: IS, WebRTCDirect: CS, Reliable: kp, Stardust: X2e, Circuit: Cp, P2P: eU, IPFS: eU };
          function aU(t) {
            function e(r) {
              if (!AS.isMultiaddr(r))
                try {
                  r = new AS(r);
                } catch {
                  return false;
                }
              let n = t(r.protoNames());
              return n === null ? false : n === true || n === false ? n : n.length === 0;
            }
            return e;
          }
          function ht(...t) {
            function e(r) {
              if (r.length < t.length)
                return null;
              let n = r;
              return t.some((i2) => (n = typeof i2 == "function" ? i2().partialMatch(r) : i2.partialMatch(r), Array.isArray(n) && (r = n), n === null)), n;
            }
            return { toString: function() {
              return "{ " + t.join(" ") + " }";
            }, input: t, matches: aU(e), partialMatch: e };
          }
          function ui(...t) {
            function e(n) {
              let i2 = null;
              return t.some((o) => {
                let s = typeof o == "function" ? o().partialMatch(n) : o.partialMatch(n);
                return s ? (i2 = s, true) : false;
              }), i2;
            }
            return { toString: function() {
              return "{ " + t.join(" ") + " }";
            }, input: t, matches: aU(e), partialMatch: e };
          }
          function Ve(t) {
            let e = t;
            function r(i2) {
              let o;
              if (typeof i2 == "string" || i2 instanceof Uint8Array)
                try {
                  o = new AS(i2);
                } catch {
                  return false;
                }
              else
                o = i2;
              let s = o.protoNames();
              return s.length === 1 && s[0] === e;
            }
            function n(i2) {
              return i2.length === 0 ? null : i2[0] === e ? i2.slice(1) : null;
            }
            return { toString: function() {
              return e;
            }, matches: r, partialMatch: n };
          }
        });
        var DS = A((qUe, fU) => {
          "use strict";
          c();
          var Z2e = typeof navigator < "u" && navigator.product === "ReactNative";
          function J2e() {
            return Z2e ? "http://localhost" : self.location ? self.location.protocol + "//" + self.location.host : "";
          }
          var f2 = self.URL, lU = J2e(), PS = class {
            constructor(e = "", r = lU) {
              this.super = new f2(e, r), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
            }
            get hash() {
              return this.super.hash;
            }
            get host() {
              return this.super.host;
            }
            get hostname() {
              return this.super.hostname;
            }
            get href() {
              return this.super.href;
            }
            get origin() {
              return this.super.origin;
            }
            get password() {
              return this.super.password;
            }
            get pathname() {
              return this.super.pathname;
            }
            get port() {
              return this.super.port;
            }
            get protocol() {
              return this.super.protocol;
            }
            get search() {
              return this.super.search;
            }
            get searchParams() {
              return this.super.searchParams;
            }
            get username() {
              return this.super.username;
            }
            set hash(e) {
              this.super.hash = e;
            }
            set host(e) {
              this.super.host = e;
            }
            set hostname(e) {
              this.super.hostname = e;
            }
            set href(e) {
              this.super.href = e;
            }
            set password(e) {
              this.super.password = e;
            }
            set pathname(e) {
              this.super.pathname = e;
            }
            set port(e) {
              this.super.port = e;
            }
            set protocol(e) {
              this.super.protocol = e;
            }
            set search(e) {
              this.super.search = e;
            }
            set username(e) {
              this.super.username = e;
            }
            static createObjectURL(e) {
              return f2.createObjectURL(e);
            }
            static revokeObjectURL(e) {
              f2.revokeObjectURL(e);
            }
            toJSON() {
              return this.super.toJSON();
            }
            toString() {
              return this.super.toString();
            }
            format() {
              return this.toString();
            }
          };
          function eye(t) {
            if (typeof t == "string")
              return new f2(t).toString();
            if (!(t instanceof f2)) {
              let e = t.username && t.password ? `${t.username}:${t.password}@` : "", r = t.auth ? t.auth + "@" : "", n = t.port ? ":" + t.port : "", i2 = t.protocol ? t.protocol + "//" : "", o = t.host || "", s = t.hostname || "", a = t.search || (t.query ? "?" + t.query : ""), u = t.hash || "", l = t.pathname || "", f = t.path || l + a;
              return `${i2}${e || r}${o || s + n}${f}${u}`;
            }
          }
          fU.exports = { URLWithLegacySupport: PS, URLSearchParams: self.URLSearchParams, defaultBase: lU, format: eye };
        });
        var pU = A((zUe, dU) => {
          "use strict";
          c();
          var { URLWithLegacySupport: hU, format: tye } = DS();
          dU.exports = (t, e = {}, r = {}, n) => {
            let i2 = e.protocol ? e.protocol.replace(":", "") : "http";
            i2 = (r[i2] || n || i2) + ":";
            let o;
            try {
              o = new hU(t);
            } catch {
              o = {};
            }
            let s = Object.assign({}, e, { protocol: i2 || o.protocol, host: e.host || o.host });
            return new hU(t, tye(s)).toString();
          };
        });
        var ww = A((HUe, mU) => {
          "use strict";
          c();
          var { URLWithLegacySupport: rye, format: nye, URLSearchParams: iye, defaultBase: oye } = DS(), sye = pU();
          mU.exports = { URL: rye, URLSearchParams: iye, format: nye, relative: sye, defaultBase: oye };
        });
        var m2 = A(($Ue, IU) => {
          "use strict";
          c();
          var { base58btc: aye } = (Hr(), cr(ap)), { base32: cye } = (si(), cr(Vm)), uye = (On(), cr(xn)), { Multiaddr: yU } = mw(), lye = uU(), { CID: kS } = (te(), cr(Ym)), { URL: fye } = ww(), { toString: hye } = (me(), cr(Ap)), NS = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/, Op = /^\/(ip[fn]s)\/([^/?#]+)/, EU = 1, bU = 2, p2 = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/, _U = 1, vU = 2, dye = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
          function pye(t) {
            let e = OS(t);
            try {
              uye.decode(aye.decode("z" + e));
            } catch {
              return false;
            }
            return true;
          }
          function mye(t) {
            try {
              cye.decode(t);
            } catch {
              return false;
            }
            return true;
          }
          function h2(t) {
            try {
              return typeof t == "string" ? Boolean(kS.parse(t)) : t instanceof Uint8Array ? Boolean(kS.decode(t)) : Boolean(kS.asCID(t));
            } catch {
              return false;
            }
          }
          function SU(t) {
            if (!t)
              return false;
            if (yU.isMultiaddr(t))
              return true;
            try {
              return new yU(t), true;
            } catch {
              return false;
            }
          }
          function yye(t) {
            return SU(t) && lye.P2P.matches(t);
          }
          function d2(t, e, r = EU, n = bU) {
            let i2 = OS(t);
            if (!i2)
              return false;
            let o = i2.match(e);
            if (!o || o[r] !== "ipfs")
              return false;
            let s = o[n];
            return s && e === p2 && (s = s.toLowerCase()), h2(s);
          }
          function Ew(t, e, r = EU, n = bU) {
            let i2 = OS(t);
            if (!i2)
              return false;
            let o = i2.match(e);
            if (!o || o[r] !== "ipns")
              return false;
            let s = o[n];
            if (s && e === p2) {
              if (s = s.toLowerCase(), h2(s))
                return true;
              try {
                !s.includes(".") && s.includes("-") && (s = s.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-"));
                let { hostname: a } = new fye(`http://${s}`);
                return dye.test(a);
              } catch {
                return false;
              }
            }
            return true;
          }
          function xU(t) {
            return typeof t == "string";
          }
          function OS(t) {
            return t instanceof Uint8Array ? hye(t, "base58btc") : xU(t) ? t : false;
          }
          var LS = (t) => d2(t, p2, vU, _U), BS = (t) => Ew(t, p2, vU, _U), RU = (t) => LS(t) || BS(t), AU = (t) => d2(t, NS) || LS(t), TU = (t) => Ew(t, NS) || BS(t), gU = (t) => AU(t) || TU(t) || RU(t), wU = (t) => d2(t, Op) || Ew(t, Op);
          IU.exports = { multihash: pye, multiaddr: SU, peerMultiaddr: yye, cid: h2, base32cid: (t) => mye(t) && h2(t), ipfsSubdomain: LS, ipnsSubdomain: BS, subdomain: RU, subdomainGatewayPattern: p2, ipfsUrl: AU, ipnsUrl: TU, url: gU, pathGatewayPattern: NS, ipfsPath: (t) => d2(t, Op), ipnsPath: (t) => Ew(t, Op), path: wU, pathPattern: Op, urlOrPath: (t) => gU(t) || wU(t), cidPath: (t) => xU(t) && !h2(t) && d2(`/ipfs/${t}`, Op) };
        });
        var CU, PU = Fe(() => {
          c();
          CU = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
        });
        var MS = {};
        ct(MS, { customAlphabet: () => gye, customRandom: () => kU, nanoid: () => jf, random: () => DU, urlAlphabet: () => CU });
        var DU, kU, gye, jf, Lp = Fe(() => {
          c();
          PU();
          DU = (t) => crypto.getRandomValues(new Uint8Array(t)), kU = (t, e, r) => {
            let n = (2 << Math.log(t.length - 1) / Math.LN2) - 1, i2 = -~(1.6 * n * e / t.length);
            return (o = e) => {
              let s = "";
              for (; ; ) {
                let a = r(i2), u = i2;
                for (; u--; )
                  if (s += t[a[u] & n] || "", s.length === o)
                    return s;
              }
            };
          }, gye = (t, e = 21) => kU(t, e, DU), jf = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, r) => (r &= 63, r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r > 62 ? e += "-" : e += "_", e), "");
        });
        var LU = A((ZUe, OU) => {
          "use strict";
          c();
          OU.exports = function() {
            return Date.now();
          };
        });
        var y2 = A((JUe, BU) => {
          "use strict";
          c();
          var _w = LU(), US = class {
            constructor(e, r, n) {
              let i2 = this;
              this._started = _w(), this._rescheduled = 0, this._scheduled = r, this._args = n, this._triggered = false, this._timerWrapper = () => {
                i2._rescheduled > 0 ? (i2._scheduled = i2._rescheduled - (_w() - i2._started), i2._schedule(i2._scheduled)) : (i2._triggered = true, e.apply(null, i2._args));
              }, this._timer = setTimeout(this._timerWrapper, r);
            }
            reschedule(e) {
              e || (e = this._scheduled);
              let r = _w();
              r + e - (this._started + this._scheduled) < 0 ? (clearTimeout(this._timer), this._schedule(e)) : this._triggered ? this._schedule(e) : (this._started = r, this._rescheduled = e);
            }
            _schedule(e) {
              this._triggered = false, this._started = _w(), this._rescheduled = 0, this._scheduled = e, this._timer = setTimeout(this._timerWrapper, e);
            }
            clear() {
              clearTimeout(this._timer);
            }
          };
          function _ye() {
            if (typeof arguments[0] != "function")
              throw new Error("callback needed");
            if (typeof arguments[1] != "number")
              throw new Error("timeout needed");
            let t;
            if (arguments.length > 0) {
              t = new Array(arguments.length - 2);
              for (var e = 0; e < t.length; e++)
                t[e] = arguments[e + 2];
            }
            return new US(arguments[0], arguments[1], t);
          }
          BU.exports = _ye;
        });
        var $o = A((eFe, UU) => {
          "use strict";
          c();
          var { AbortController: vye } = globalThis, MU = y2(), g2 = class extends vye {
            constructor(e) {
              super(), this._ms = e, this._timer = MU(() => this.abort(), e), Object.setPrototypeOf(this, g2.prototype);
            }
            abort() {
              return this._timer.clear(), super.abort();
            }
            clear() {
              this._timer.clear();
            }
            reset() {
              this._timer.clear(), this._timer = MU(() => this.abort(), this._ms);
            }
          };
          UU.exports = { TimeoutController: g2 };
        });
        var Vi = A((tFe, FS) => {
          c();
          function FU(t) {
            let e = new globalThis.AbortController();
            function r() {
              e.abort();
              for (let n of t)
                !n || !n.removeEventListener || n.removeEventListener("abort", r);
            }
            for (let n of t)
              if (!(!n || !n.addEventListener)) {
                if (n.aborted) {
                  r();
                  break;
                }
                n.addEventListener("abort", r);
              }
            return e.signal;
          }
          FS.exports = FU;
          FS.exports.anySignal = FU;
        });
        var Mp = A((_Fe, YU) => {
          c();
          YU.exports = function(t) {
            if (!t)
              throw Error("hashlru must have a max value, of type number, greater than 0");
            var e = 0, r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
            function i2(o, s) {
              r[o] = s, e++, e >= t && (e = 0, n = r, r = /* @__PURE__ */ Object.create(null));
            }
            return { has: function(o) {
              return r[o] !== void 0 || n[o] !== void 0;
            }, remove: function(o) {
              r[o] !== void 0 && (r[o] = void 0), n[o] !== void 0 && (n[o] = void 0);
            }, get: function(o) {
              var s = r[o];
              if (s !== void 0)
                return s;
              if ((s = n[o]) !== void 0)
                return i2(o, s), s;
            }, set: function(o, s) {
              r[o] !== void 0 ? r[o] = s : i2(o, s);
            }, clear: function() {
              r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
            } };
          };
        });
        var Xu = A((SFe, qS) => {
          "use strict";
          c();
          var Rye = Object.prototype.hasOwnProperty, Si = "~";
          function b2() {
          }
          Object.create && (b2.prototype = /* @__PURE__ */ Object.create(null), new b2().__proto__ || (Si = false));
          function Aye(t, e, r) {
            this.fn = t, this.context = e, this.once = r || false;
          }
          function XU(t, e, r, n, i2) {
            if (typeof r != "function")
              throw new TypeError("The listener must be a function");
            var o = new Aye(r, n || t, i2), s = Si ? Si + e : e;
            return t._events[s] ? t._events[s].fn ? t._events[s] = [t._events[s], o] : t._events[s].push(o) : (t._events[s] = o, t._eventsCount++), t;
          }
          function Rw(t, e) {
            --t._eventsCount === 0 ? t._events = new b2() : delete t._events[e];
          }
          function fi() {
            this._events = new b2(), this._eventsCount = 0;
          }
          fi.prototype.eventNames = function() {
            var e = [], r, n;
            if (this._eventsCount === 0)
              return e;
            for (n in r = this._events)
              Rye.call(r, n) && e.push(Si ? n.slice(1) : n);
            return Object.getOwnPropertySymbols ? e.concat(Object.getOwnPropertySymbols(r)) : e;
          };
          fi.prototype.listeners = function(e) {
            var r = Si ? Si + e : e, n = this._events[r];
            if (!n)
              return [];
            if (n.fn)
              return [n.fn];
            for (var i2 = 0, o = n.length, s = new Array(o); i2 < o; i2++)
              s[i2] = n[i2].fn;
            return s;
          };
          fi.prototype.listenerCount = function(e) {
            var r = Si ? Si + e : e, n = this._events[r];
            return n ? n.fn ? 1 : n.length : 0;
          };
          fi.prototype.emit = function(e, r, n, i2, o, s) {
            var a = Si ? Si + e : e;
            if (!this._events[a])
              return false;
            var u = this._events[a], l = arguments.length, f, h;
            if (u.fn) {
              switch (u.once && this.removeListener(e, u.fn, void 0, true), l) {
                case 1:
                  return u.fn.call(u.context), true;
                case 2:
                  return u.fn.call(u.context, r), true;
                case 3:
                  return u.fn.call(u.context, r, n), true;
                case 4:
                  return u.fn.call(u.context, r, n, i2), true;
                case 5:
                  return u.fn.call(u.context, r, n, i2, o), true;
                case 6:
                  return u.fn.call(u.context, r, n, i2, o, s), true;
              }
              for (h = 1, f = new Array(l - 1); h < l; h++)
                f[h - 1] = arguments[h];
              u.fn.apply(u.context, f);
            } else {
              var p = u.length, d;
              for (h = 0; h < p; h++)
                switch (u[h].once && this.removeListener(e, u[h].fn, void 0, true), l) {
                  case 1:
                    u[h].fn.call(u[h].context);
                    break;
                  case 2:
                    u[h].fn.call(u[h].context, r);
                    break;
                  case 3:
                    u[h].fn.call(u[h].context, r, n);
                    break;
                  case 4:
                    u[h].fn.call(u[h].context, r, n, i2);
                    break;
                  default:
                    if (!f)
                      for (d = 1, f = new Array(l - 1); d < l; d++)
                        f[d - 1] = arguments[d];
                    u[h].fn.apply(u[h].context, f);
                }
            }
            return true;
          };
          fi.prototype.on = function(e, r, n) {
            return XU(this, e, r, n, false);
          };
          fi.prototype.once = function(e, r, n) {
            return XU(this, e, r, n, true);
          };
          fi.prototype.removeListener = function(e, r, n, i2) {
            var o = Si ? Si + e : e;
            if (!this._events[o])
              return this;
            if (!r)
              return Rw(this, o), this;
            var s = this._events[o];
            if (s.fn)
              s.fn === r && (!i2 || s.once) && (!n || s.context === n) && Rw(this, o);
            else {
              for (var a = 0, u = [], l = s.length; a < l; a++)
                (s[a].fn !== r || i2 && !s[a].once || n && s[a].context !== n) && u.push(s[a]);
              u.length ? this._events[o] = u.length === 1 ? u[0] : u : Rw(this, o);
            }
            return this;
          };
          fi.prototype.removeAllListeners = function(e) {
            var r;
            return e ? (r = Si ? Si + e : e, this._events[r] && Rw(this, r)) : (this._events = new b2(), this._eventsCount = 0), this;
          };
          fi.prototype.off = fi.prototype.removeListener;
          fi.prototype.addListener = fi.prototype.on;
          fi.prefixed = Si;
          fi.EventEmitter = fi;
          typeof qS < "u" && (qS.exports = fi);
        });
        var XS = A((Nw) => {
          "use strict";
          c();
          var jS = class extends Error {
            constructor(e = "Request timed out") {
              super(e), this.name = "TimeoutError";
            }
          };
          Nw.TimeoutError = jS;
          var YS = class extends Error {
            constructor(e = "The operation was aborted.") {
              super(e), this.name = "AbortError";
            }
          };
          Nw.AbortError = YS;
          var QS = class extends Error {
            constructor(e) {
              super(e.statusText), this.name = "HTTPError", this.response = e;
            }
          };
          Nw.HTTPError = QS;
        });
        var T2 = A((Kp, aF) => {
          "use strict";
          c();
          var Iye = function() {
            if (typeof self < "u")
              return self;
            if (typeof window < "u")
              return window;
            if (typeof Cc < "u")
              return Cc;
            throw new Error("unable to locate global object");
          }, Cc = Iye();
          aF.exports = Kp = Cc.fetch;
          Cc.fetch && (Kp.default = Cc.fetch.bind(Cc));
          Kp.Headers = Cc.Headers;
          Kp.Request = Cc.Request;
          Kp.Response = Cc.Response;
        });
        var cF = A((kFe, ZS) => {
          "use strict";
          c();
          globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response ? ZS.exports = { default: globalThis.fetch, Headers: globalThis.Headers, Request: globalThis.Request, Response: globalThis.Response } : ZS.exports = { default: T2().default, Headers: T2().Headers, Request: T2().Request, Response: T2().Response };
        });
        var lF = A((NFe, uF) => {
          "use strict";
          c();
          uF.exports = cF();
        });
        var dF = A((OFe, hF) => {
          "use strict";
          c();
          var { TimeoutError: Cye, AbortError: Pye } = XS(), { Response: fF, Request: Dye, Headers: ex, default: kye } = lF(), Nye = (t, e = {}) => {
            let r = new XMLHttpRequest();
            r.open(e.method || "GET", t.toString(), true);
            let { timeout: n, headers: i2 } = e;
            if (n && n > 0 && n < 1 / 0 && (r.timeout = n), e.overrideMimeType != null && r.overrideMimeType(e.overrideMimeType), i2)
              for (let [o, s] of new ex(i2))
                r.setRequestHeader(o, s);
            return e.signal && (e.signal.onabort = () => r.abort()), e.onUploadProgress && (r.upload.onprogress = e.onUploadProgress), r.responseType = "arraybuffer", new Promise((o, s) => {
              let a = (u) => {
                switch (u.type) {
                  case "error": {
                    o(fF.error());
                    break;
                  }
                  case "load": {
                    o(new JS(r.responseURL, r.response, { status: r.status, statusText: r.statusText, headers: Bye(r.getAllResponseHeaders()) }));
                    break;
                  }
                  case "timeout": {
                    s(new Cye());
                    break;
                  }
                  case "abort": {
                    s(new Pye());
                    break;
                  }
                  default:
                    break;
                }
              };
              r.onerror = a, r.onload = a, r.ontimeout = a, r.onabort = a, r.send(e.body);
            });
          }, Oye = kye, Lye = (t, e = {}) => e.onUploadProgress != null ? Nye(t, e) : Oye(t, e), Bye = (t) => {
            let e = new ex();
            for (let r of t.trim().split(/[\r\n]+/)) {
              let n = r.indexOf(": ");
              n > 0 && e.set(r.slice(0, n), r.slice(n + 1));
            }
            return e;
          }, JS = class extends fF {
            constructor(e, r, n) {
              super(r, n), Object.defineProperty(this, "url", { value: e });
            }
          };
          hF.exports = { fetch: Lye, Request: Dye, Headers: ex };
        });
        var Vp = A((LFe, EF) => {
          "use strict";
          c();
          var { fetch: Mye, Request: Uye, Headers: Fye } = dF(), { TimeoutError: tx, HTTPError: gF } = XS(), pF = z7().bind({ ignoreUndefined: true }), { URL: mF, URLSearchParams: yF } = ww(), Kye = Vi(), Vye = (t, e, r) => {
            if (e === void 0)
              return t;
            let n = Date.now(), i2 = () => Date.now() - n >= e;
            return new Promise((o, s) => {
              let a = setTimeout(() => {
                i2() && (s(new tx()), r.abort());
              }, e), u = (l) => (h) => {
                if (clearTimeout(a), i2()) {
                  s(new tx());
                  return;
                }
                l(h);
              };
              t.then(u(o), u(s));
            });
          }, qye = { throwHttpErrors: true, credentials: "same-origin" }, di = class {
            constructor(e = {}) {
              this.opts = pF(qye, e);
            }
            async fetch(e, r = {}) {
              let n = pF(this.opts, r), i2 = new Fye(n.headers);
              if (typeof e != "string" && !(e instanceof mF || e instanceof Uye))
                throw new TypeError("`resource` must be a string, URL, or Request");
              let o = new mF(e.toString(), n.base), { searchParams: s, transformSearchParams: a, json: u } = n;
              s && (typeof a == "function" ? o.search = a(new yF(n.searchParams)) : o.search = new yF(n.searchParams)), u && (n.body = JSON.stringify(n.json), i2.set("content-type", "application/json"));
              let l = new AbortController(), f = Kye([l.signal, n.signal]), h = await Vye(Mye(o.toString(), { ...n, signal: f, timeout: void 0, headers: i2 }), n.timeout, l);
              if (!h.ok && n.throwHttpErrors)
                throw n.handleError && await n.handleError(h), new gF(h);
              return h.iterator = async function* () {
                yield* wF(h.body);
              }, h.ndjson = async function* () {
                for await (let p of zye(h.iterator()))
                  r.transform ? yield r.transform(p) : yield p;
              }, h;
            }
            post(e, r = {}) {
              return this.fetch(e, { ...r, method: "POST" });
            }
            get(e, r = {}) {
              return this.fetch(e, { ...r, method: "GET" });
            }
            put(e, r = {}) {
              return this.fetch(e, { ...r, method: "PUT" });
            }
            delete(e, r = {}) {
              return this.fetch(e, { ...r, method: "DELETE" });
            }
            options(e, r = {}) {
              return this.fetch(e, { ...r, method: "OPTIONS" });
            }
          }, zye = async function* (t) {
            let e = new TextDecoder(), r = "";
            for await (let n of t) {
              r += e.decode(n, { stream: true });
              let i2 = r.split(/\r?\n/);
              for (let o = 0; o < i2.length - 1; o++) {
                let s = i2[o].trim();
                s.length > 0 && (yield JSON.parse(s));
              }
              r = i2[i2.length - 1];
            }
            r += e.decode(), r = r.trim(), r.length !== 0 && (yield JSON.parse(r));
          }, wF = (t) => {
            if (Gye(t)) {
              let e = t[Symbol.asyncIterator]();
              return { [Symbol.asyncIterator]() {
                return { next: e.next.bind(e), return(r) {
                  return t.destroy(), typeof e.return == "function" ? e.return() : Promise.resolve({ done: true, value: r });
                } };
              } };
            }
            if ($ye(t)) {
              let e = t.getReader();
              return async function* () {
                try {
                  for (; ; ) {
                    let { done: r, value: n } = await e.read();
                    if (r)
                      return;
                    n && (yield n);
                  }
                } finally {
                  e.releaseLock();
                }
              }();
            }
            if (Hye(t))
              return t;
            throw new TypeError("Body can't be converted to AsyncIterable");
          }, Hye = (t) => typeof t == "object" && t !== null && typeof t[Symbol.asyncIterator] == "function", $ye = (t) => t && typeof t.getReader == "function", Gye = (t) => Object.prototype.hasOwnProperty.call(t, "readable") && Object.prototype.hasOwnProperty.call(t, "writable");
          di.HTTPError = gF;
          di.TimeoutError = tx;
          di.streamToAsyncIterator = wF;
          di.post = (t, e) => new di(e).post(t, e);
          di.get = (t, e) => new di(e).get(t, e);
          di.put = (t, e) => new di(e).put(t, e);
          di.delete = (t, e) => new di(e).delete(t, e);
          di.options = (t, e) => new di(e).options(t, e);
          EF.exports = di;
        });
        var qi = A((nKe, PF) => {
          "use strict";
          c();
          var Jye = async (t) => {
            let e;
            for await (let r of t)
              e = r;
            return e;
          };
          PF.exports = Jye;
        });
        var UF = A((NKe, ax) => {
          c();
          var kKe = function() {
            typeof ax < "u" && (ax.exports = E);
            var t = 24 * 3600, e = 3200, r = (365 * 400 + 97) * e / 400, n = t * r, i2 = n * 1e3, o = 1e3 * 1e4 * 1e4 * t, s = 16777216, a = 65536 * 65536, u = 1e3 * 1e3, l = 1e3 * 1e3 * 1e3, f = "000000000", h = Math.trunc || $e, p = E.prototype;
            E.fromDate = F, E.fromInt64BE = ke(0, 1, 2, 3, 0, 4), E.fromInt64LE = ke(3, 2, 1, 0, 4, 0), E.fromString = O, E.fromTimeT = z, p.year = 0, p.time = 0, p.nano = 0, p.addNano = T, p.getNano = R, p.getTimeT = se, p.getYear = b, p.toDate = S, p.toJSON = re2, p.toString = Ge, p.writeInt64BE = ge(0, 1, 2, 3, 0, 4), p.writeInt64LE = ge(3, 2, 1, 0, 4, 0);
            var d = "%Y-%m-%dT%H:%M:%S.%NZ", m = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], y = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], g = { "%": "%", F: "%Y-%m-%d", n: `
`, R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
            return E;
            function E(J, fe, ce) {
              var Pe = this;
              if (!(Pe instanceof E))
                return new E(J, fe, ce);
              Pe.time = +J || 0, Pe.nano = +fe || 0, Pe.year = +ce || 0, v(Pe);
            }
            function b() {
              var J = this.toDate().getUTCFullYear();
              return J + this.year;
            }
            function v(J) {
              var fe = J.year, ce = J.time, Pe = J.nano, Me, Be;
              if (Pe < 0 || u <= Pe) {
                var $t = Math.floor(Pe / u);
                Pe -= $t * u, ce += $t, Me = 1;
              }
              var sr = fe % e;
              if (ce < -o || o < ce || sr) {
                Be = h(ce / i2), Be && (fe += Be * e, ce -= Be * i2);
                var et = x(ce);
                et.setUTCFullYear(sr + et.getUTCFullYear()), fe -= sr, ce = +et, Be = h(fe / e);
                var ft = ce + Be * i2;
                Be && -o <= ft && ft <= o && (fe -= Be * e, ce = ft), Me = 1;
              }
              return Me && (J.year = fe, J.time = ce, J.nano = Pe), J;
            }
            function S() {
              var J = v(this);
              return x(J.time);
            }
            function x(J) {
              var fe = new Date(0);
              return fe.setTime(J), fe;
            }
            function T(J) {
              return this.nano += +J || 0, this;
            }
            function R() {
              var J = v(this);
              return (J.time % 1e3 * u + +J.nano + l) % l;
            }
            function O(J) {
              var fe, ce = new E();
              J += "";
              var Pe = J.replace(/^\s*[+\-]?\d+/, function(Me) {
                var Be = +Me, $t = 1970 + (Be - 1970) % 400;
                return ce.year = Be - $t, $t;
              }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(Me, Be, $t) {
                return Be < 0 && ($t *= -1), fe = (+Be * 60 + +$t) * 6e4, "";
              }).replace(/\.\d+$/, function(Me) {
                return ce.nano = +(Me + f).substr(1, 9), "";
              }).split(/\D+/);
              if (Pe.length > 1 ? Pe[1]-- : Pe[1] = 0, ce.time = fe = Date.UTC.apply(Date, Pe) - (fe || 0), isNaN(fe))
                throw new TypeError("Invalid Date");
              return v(ce);
            }
            function F(J) {
              return new E(+J);
            }
            function z(J) {
              return W(J, 0);
            }
            function W(J, fe) {
              fe |= 0, fe *= a, J = +J || 0;
              var ce = h(fe / n) + h(J / n), Pe = fe % n + J % n, Me = h(Pe / n);
              return Me && (ce += Me, Pe -= Me * n), new E(Pe * 1e3, 0, ce * e);
            }
            function se() {
              var J = v(this), fe = Math.floor(J.time / 1e3), ce = J.year;
              return ce && (fe += ce * r * t / e), fe;
            }
            function re2() {
              return this.toString().replace(/0{1,6}Z$/, "Z");
            }
            function Ge(J) {
              var fe = this, ce = fe.toDate(), Pe = { H: ft, L: Jr, M: ar, N: en, S: Ur, Y: Be, a: Mm, b: Um, d: sr, e: et, m: $t };
              return Me(J || d);
              function Me(bs) {
                return bs.replace(/%./g, function(EN) {
                  var bN = EN[1], _N = g[bN], vN = Pe[bN];
                  return _N ? Me(_N) : vN ? vN() : EN;
                });
              }
              function Be() {
                var bs = fe.getYear();
                return bs > 999999 ? "+" + bs : bs > 9999 ? "+" + it(bs, 6) : bs >= 0 ? it(bs, 4) : bs >= -999999 ? "-" + it(-bs, 6) : bs;
              }
              function $t() {
                return nt(ce.getUTCMonth() + 1);
              }
              function sr() {
                return nt(ce.getUTCDate());
              }
              function et() {
                return or3(ce.getUTCDate());
              }
              function ft() {
                return nt(ce.getUTCHours());
              }
              function ar() {
                return nt(ce.getUTCMinutes());
              }
              function Ur() {
                return nt(ce.getUTCSeconds());
              }
              function Jr() {
                return it(ce.getUTCMilliseconds(), 3);
              }
              function en() {
                return it(fe.getNano(), 9);
              }
              function Mm() {
                return y[ce.getUTCDay()];
              }
              function Um() {
                return m[ce.getUTCMonth()];
              }
            }
            function ge(J, fe, ce, Pe, Me, Be) {
              return $t;
              function $t(et, ft) {
                var ar = v(this);
                et || (et = new Array(8)), H(et, ft |= 0);
                var Ur = Math.floor(ar.time / 1e3), Jr = ar.year * (r * t / e), en = h(Jr / a) + h(Ur / a), Mm = Jr % a + Ur % a, Um = Math.floor(Mm / a);
                return Um && (en += Um, Mm -= Um * a), sr(et, ft + Me, en), sr(et, ft + Be, Mm), et;
              }
              function sr(et, ft, ar) {
                et[ft + J] = ar >> 24 & 255, et[ft + fe] = ar >> 16 & 255, et[ft + ce] = ar >> 8 & 255, et[ft + Pe] = ar & 255;
              }
            }
            function ke(J, fe, ce, Pe, Me, Be) {
              return $t;
              function $t(et, ft) {
                H(et, ft |= 0);
                var ar = sr(et, ft + Me), Ur = sr(et, ft + Be);
                return W(Ur, ar);
              }
              function sr(et, ft) {
                return et[ft + J] * s + (et[ft + fe] << 16 | et[ft + ce] << 8 | et[ft + Pe]);
              }
            }
            function H(J, fe) {
              var ce = J && J.length;
              if (ce == null)
                throw new TypeError("Invalid Buffer");
              if (ce < fe + 8)
                throw new RangeError("Out of range");
            }
            function $e(J) {
              var fe = J - J % 1;
              return fe === 0 && (J < 0 || J === 0 && 1 / J !== 1 / 0) ? -0 : fe;
            }
            function or3(J) {
              return (J > 9 ? "" : " ") + (J | 0);
            }
            function nt(J) {
              return (J > 9 ? "" : "0") + (J | 0);
            }
            function it(J, fe) {
              return (f + (J | 0)).substr(-fe);
            }
          }();
        });
        var st = A((Iqe, tK) => {
          c();
          tK.exports = { options: { usePureJavaScript: false } };
        });
        var iK = A((Cqe, nK) => {
          c();
          var lx = {};
          nK.exports = lx;
          var rK = {};
          lx.encode = function(t, e, r) {
            if (typeof e != "string")
              throw new TypeError('"alphabet" must be a string.');
            if (r !== void 0 && typeof r != "number")
              throw new TypeError('"maxline" must be a number.');
            var n = "";
            if (!(t instanceof Uint8Array))
              n = i3e(t, e);
            else {
              var i2 = 0, o = e.length, s = e.charAt(0), a = [0];
              for (i2 = 0; i2 < t.length; ++i2) {
                for (var u = 0, l = t[i2]; u < a.length; ++u)
                  l += a[u] << 8, a[u] = l % o, l = l / o | 0;
                for (; l > 0; )
                  a.push(l % o), l = l / o | 0;
              }
              for (i2 = 0; t[i2] === 0 && i2 < t.length - 1; ++i2)
                n += s;
              for (i2 = a.length - 1; i2 >= 0; --i2)
                n += e[a[i2]];
            }
            if (r) {
              var f = new RegExp(".{1," + r + "}", "g");
              n = n.match(f).join(`\r
`);
            }
            return n;
          };
          lx.decode = function(t, e) {
            if (typeof t != "string")
              throw new TypeError('"input" must be a string.');
            if (typeof e != "string")
              throw new TypeError('"alphabet" must be a string.');
            var r = rK[e];
            if (!r) {
              r = rK[e] = [];
              for (var n = 0; n < e.length; ++n)
                r[e.charCodeAt(n)] = n;
            }
            t = t.replace(/\s/g, "");
            for (var i2 = e.length, o = e.charAt(0), s = [0], n = 0; n < t.length; n++) {
              var a = r[t.charCodeAt(n)];
              if (a === void 0)
                return;
              for (var u = 0, l = a; u < s.length; ++u)
                l += s[u] * i2, s[u] = l & 255, l >>= 8;
              for (; l > 0; )
                s.push(l & 255), l >>= 8;
            }
            for (var f = 0; t[f] === o && f < t.length - 1; ++f)
              s.push(0);
            return typeof Buffer < "u" ? Buffer.from(s.reverse()) : new Uint8Array(s.reverse());
          };
          function i3e(t, e) {
            var r = 0, n = e.length, i2 = e.charAt(0), o = [0];
            for (r = 0; r < t.length(); ++r) {
              for (var s = 0, a = t.at(r); s < o.length; ++s)
                a += o[s] << 8, o[s] = a % n, a = a / n | 0;
              for (; a > 0; )
                o.push(a % n), a = a / n | 0;
            }
            var u = "";
            for (r = 0; t.at(r) === 0 && r < t.length() - 1; ++r)
              u += i2;
            for (r = o.length - 1; r >= 0; --r)
              u += e[o[r]];
            return u;
          }
        });
        var gr = A((Pqe, cK) => {
          c();
          var oK = st(), sK = iK(), N = cK.exports = oK.util = oK.util || {};
          (function() {
            if (typeof process < "u" && process.nextTick && !process.browser) {
              N.nextTick = process.nextTick, typeof setImmediate == "function" ? N.setImmediate = setImmediate : N.setImmediate = N.nextTick;
              return;
            }
            if (typeof setImmediate == "function") {
              N.setImmediate = function() {
                return setImmediate.apply(void 0, arguments);
              }, N.nextTick = function(a) {
                return setImmediate(a);
              };
              return;
            }
            if (N.setImmediate = function(a) {
              setTimeout(a, 0);
            }, typeof window < "u" && typeof window.postMessage == "function") {
              let a = function(u) {
                if (u.source === window && u.data === t) {
                  u.stopPropagation();
                  var l = e.slice();
                  e.length = 0, l.forEach(function(f) {
                    f();
                  });
                }
              };
              var s = a, t = "forge.setImmediate", e = [];
              N.setImmediate = function(u) {
                e.push(u), e.length === 1 && window.postMessage(t, "*");
              }, window.addEventListener("message", a, true);
            }
            if (typeof MutationObserver < "u") {
              var r = Date.now(), n = true, i2 = document.createElement("div"), e = [];
              new MutationObserver(function() {
                var u = e.slice();
                e.length = 0, u.forEach(function(l) {
                  l();
                });
              }).observe(i2, { attributes: true });
              var o = N.setImmediate;
              N.setImmediate = function(u) {
                Date.now() - r > 15 ? (r = Date.now(), o(u)) : (e.push(u), e.length === 1 && i2.setAttribute("a", n = !n));
              };
            }
            N.nextTick = N.setImmediate;
          })();
          N.isNodejs = typeof process < "u" && process.versions && process.versions.node;
          N.globalScope = function() {
            return N.isNodejs ? globalThis : typeof self > "u" ? window : self;
          }();
          N.isArray = Array.isArray || function(t) {
            return Object.prototype.toString.call(t) === "[object Array]";
          };
          N.isArrayBuffer = function(t) {
            return typeof ArrayBuffer < "u" && t instanceof ArrayBuffer;
          };
          N.isArrayBufferView = function(t) {
            return t && N.isArrayBuffer(t.buffer) && t.byteLength !== void 0;
          };
          function D2(t) {
            if (!(t === 8 || t === 16 || t === 24 || t === 32))
              throw new Error("Only 8, 16, 24, or 32 bits supported: " + t);
          }
          N.ByteBuffer = fx;
          function fx(t) {
            if (this.data = "", this.read = 0, typeof t == "string")
              this.data = t;
            else if (N.isArrayBuffer(t) || N.isArrayBufferView(t))
              if (typeof Buffer < "u" && t instanceof Buffer)
                this.data = t.toString("binary");
              else {
                var e = new Uint8Array(t);
                try {
                  this.data = String.fromCharCode.apply(null, e);
                } catch {
                  for (var r = 0; r < e.length; ++r)
                    this.putByte(e[r]);
                }
              }
            else
              (t instanceof fx || typeof t == "object" && typeof t.data == "string" && typeof t.read == "number") && (this.data = t.data, this.read = t.read);
            this._constructedStringLength = 0;
          }
          N.ByteStringBuffer = fx;
          var o3e = 4096;
          N.ByteStringBuffer.prototype._optimizeConstructedString = function(t) {
            this._constructedStringLength += t, this._constructedStringLength > o3e && (this.data.substr(0, 1), this._constructedStringLength = 0);
          };
          N.ByteStringBuffer.prototype.length = function() {
            return this.data.length - this.read;
          };
          N.ByteStringBuffer.prototype.isEmpty = function() {
            return this.length() <= 0;
          };
          N.ByteStringBuffer.prototype.putByte = function(t) {
            return this.putBytes(String.fromCharCode(t));
          };
          N.ByteStringBuffer.prototype.fillWithByte = function(t, e) {
            t = String.fromCharCode(t);
            for (var r = this.data; e > 0; )
              e & 1 && (r += t), e >>>= 1, e > 0 && (t += t);
            return this.data = r, this._optimizeConstructedString(e), this;
          };
          N.ByteStringBuffer.prototype.putBytes = function(t) {
            return this.data += t, this._optimizeConstructedString(t.length), this;
          };
          N.ByteStringBuffer.prototype.putString = function(t) {
            return this.putBytes(N.encodeUtf8(t));
          };
          N.ByteStringBuffer.prototype.putInt16 = function(t) {
            return this.putBytes(String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255));
          };
          N.ByteStringBuffer.prototype.putInt24 = function(t) {
            return this.putBytes(String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255));
          };
          N.ByteStringBuffer.prototype.putInt32 = function(t) {
            return this.putBytes(String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255));
          };
          N.ByteStringBuffer.prototype.putInt16Le = function(t) {
            return this.putBytes(String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255));
          };
          N.ByteStringBuffer.prototype.putInt24Le = function(t) {
            return this.putBytes(String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255));
          };
          N.ByteStringBuffer.prototype.putInt32Le = function(t) {
            return this.putBytes(String.fromCharCode(t & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 24 & 255));
          };
          N.ByteStringBuffer.prototype.putInt = function(t, e) {
            D2(e);
            var r = "";
            do
              e -= 8, r += String.fromCharCode(t >> e & 255);
            while (e > 0);
            return this.putBytes(r);
          };
          N.ByteStringBuffer.prototype.putSignedInt = function(t, e) {
            return t < 0 && (t += 2 << e - 1), this.putInt(t, e);
          };
          N.ByteStringBuffer.prototype.putBuffer = function(t) {
            return this.putBytes(t.getBytes());
          };
          N.ByteStringBuffer.prototype.getByte = function() {
            return this.data.charCodeAt(this.read++);
          };
          N.ByteStringBuffer.prototype.getInt16 = function() {
            var t = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
            return this.read += 2, t;
          };
          N.ByteStringBuffer.prototype.getInt24 = function() {
            var t = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
            return this.read += 3, t;
          };
          N.ByteStringBuffer.prototype.getInt32 = function() {
            var t = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
            return this.read += 4, t;
          };
          N.ByteStringBuffer.prototype.getInt16Le = function() {
            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
            return this.read += 2, t;
          };
          N.ByteStringBuffer.prototype.getInt24Le = function() {
            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
            return this.read += 3, t;
          };
          N.ByteStringBuffer.prototype.getInt32Le = function() {
            var t = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
            return this.read += 4, t;
          };
          N.ByteStringBuffer.prototype.getInt = function(t) {
            D2(t);
            var e = 0;
            do
              e = (e << 8) + this.data.charCodeAt(this.read++), t -= 8;
            while (t > 0);
            return e;
          };
          N.ByteStringBuffer.prototype.getSignedInt = function(t) {
            var e = this.getInt(t), r = 2 << t - 2;
            return e >= r && (e -= r << 1), e;
          };
          N.ByteStringBuffer.prototype.getBytes = function(t) {
            var e;
            return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : t === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
          };
          N.ByteStringBuffer.prototype.bytes = function(t) {
            return typeof t > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t);
          };
          N.ByteStringBuffer.prototype.at = function(t) {
            return this.data.charCodeAt(this.read + t);
          };
          N.ByteStringBuffer.prototype.setAt = function(t, e) {
            return this.data = this.data.substr(0, this.read + t) + String.fromCharCode(e) + this.data.substr(this.read + t + 1), this;
          };
          N.ByteStringBuffer.prototype.last = function() {
            return this.data.charCodeAt(this.data.length - 1);
          };
          N.ByteStringBuffer.prototype.copy = function() {
            var t = N.createBuffer(this.data);
            return t.read = this.read, t;
          };
          N.ByteStringBuffer.prototype.compact = function() {
            return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
          };
          N.ByteStringBuffer.prototype.clear = function() {
            return this.data = "", this.read = 0, this;
          };
          N.ByteStringBuffer.prototype.truncate = function(t) {
            var e = Math.max(0, this.length() - t);
            return this.data = this.data.substr(this.read, e), this.read = 0, this;
          };
          N.ByteStringBuffer.prototype.toHex = function() {
            for (var t = "", e = this.read; e < this.data.length; ++e) {
              var r = this.data.charCodeAt(e);
              r < 16 && (t += "0"), t += r.toString(16);
            }
            return t;
          };
          N.ByteStringBuffer.prototype.toString = function() {
            return N.decodeUtf8(this.bytes());
          };
          function s3e(t, e) {
            e = e || {}, this.read = e.readOffset || 0, this.growSize = e.growSize || 1024;
            var r = N.isArrayBuffer(t), n = N.isArrayBufferView(t);
            if (r || n) {
              r ? this.data = new DataView(t) : this.data = new DataView(t.buffer, t.byteOffset, t.byteLength), this.write = "writeOffset" in e ? e.writeOffset : this.data.byteLength;
              return;
            }
            this.data = new DataView(new ArrayBuffer(0)), this.write = 0, t != null && this.putBytes(t), "writeOffset" in e && (this.write = e.writeOffset);
          }
          N.DataBuffer = s3e;
          N.DataBuffer.prototype.length = function() {
            return this.write - this.read;
          };
          N.DataBuffer.prototype.isEmpty = function() {
            return this.length() <= 0;
          };
          N.DataBuffer.prototype.accommodate = function(t, e) {
            if (this.length() >= t)
              return this;
            e = Math.max(e || this.growSize, t);
            var r = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), n = new Uint8Array(this.length() + e);
            return n.set(r), this.data = new DataView(n.buffer), this;
          };
          N.DataBuffer.prototype.putByte = function(t) {
            return this.accommodate(1), this.data.setUint8(this.write++, t), this;
          };
          N.DataBuffer.prototype.fillWithByte = function(t, e) {
            this.accommodate(e);
            for (var r = 0; r < e; ++r)
              this.data.setUint8(t);
            return this;
          };
          N.DataBuffer.prototype.putBytes = function(t, e) {
            if (N.isArrayBufferView(t)) {
              var r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), n = r.byteLength - r.byteOffset;
              this.accommodate(n);
              var i2 = new Uint8Array(this.data.buffer, this.write);
              return i2.set(r), this.write += n, this;
            }
            if (N.isArrayBuffer(t)) {
              var r = new Uint8Array(t);
              this.accommodate(r.byteLength);
              var i2 = new Uint8Array(this.data.buffer);
              return i2.set(r, this.write), this.write += r.byteLength, this;
            }
            if (t instanceof N.DataBuffer || typeof t == "object" && typeof t.read == "number" && typeof t.write == "number" && N.isArrayBufferView(t.data)) {
              var r = new Uint8Array(t.data.byteLength, t.read, t.length());
              this.accommodate(r.byteLength);
              var i2 = new Uint8Array(t.data.byteLength, this.write);
              return i2.set(r), this.write += r.byteLength, this;
            }
            if (t instanceof N.ByteStringBuffer && (t = t.data, e = "binary"), e = e || "binary", typeof t == "string") {
              var o;
              if (e === "hex")
                return this.accommodate(Math.ceil(t.length / 2)), o = new Uint8Array(this.data.buffer, this.write), this.write += N.binary.hex.decode(t, o, this.write), this;
              if (e === "base64")
                return this.accommodate(Math.ceil(t.length / 4) * 3), o = new Uint8Array(this.data.buffer, this.write), this.write += N.binary.base64.decode(t, o, this.write), this;
              if (e === "utf8" && (t = N.encodeUtf8(t), e = "binary"), e === "binary" || e === "raw")
                return this.accommodate(t.length), o = new Uint8Array(this.data.buffer, this.write), this.write += N.binary.raw.decode(o), this;
              if (e === "utf16")
                return this.accommodate(t.length * 2), o = new Uint16Array(this.data.buffer, this.write), this.write += N.text.utf16.encode(o), this;
              throw new Error("Invalid encoding: " + e);
            }
            throw Error("Invalid parameter: " + t);
          };
          N.DataBuffer.prototype.putBuffer = function(t) {
            return this.putBytes(t), t.clear(), this;
          };
          N.DataBuffer.prototype.putString = function(t) {
            return this.putBytes(t, "utf16");
          };
          N.DataBuffer.prototype.putInt16 = function(t) {
            return this.accommodate(2), this.data.setInt16(this.write, t), this.write += 2, this;
          };
          N.DataBuffer.prototype.putInt24 = function(t) {
            return this.accommodate(3), this.data.setInt16(this.write, t >> 8 & 65535), this.data.setInt8(this.write, t >> 16 & 255), this.write += 3, this;
          };
          N.DataBuffer.prototype.putInt32 = function(t) {
            return this.accommodate(4), this.data.setInt32(this.write, t), this.write += 4, this;
          };
          N.DataBuffer.prototype.putInt16Le = function(t) {
            return this.accommodate(2), this.data.setInt16(this.write, t, true), this.write += 2, this;
          };
          N.DataBuffer.prototype.putInt24Le = function(t) {
            return this.accommodate(3), this.data.setInt8(this.write, t >> 16 & 255), this.data.setInt16(this.write, t >> 8 & 65535, true), this.write += 3, this;
          };
          N.DataBuffer.prototype.putInt32Le = function(t) {
            return this.accommodate(4), this.data.setInt32(this.write, t, true), this.write += 4, this;
          };
          N.DataBuffer.prototype.putInt = function(t, e) {
            D2(e), this.accommodate(e / 8);
            do
              e -= 8, this.data.setInt8(this.write++, t >> e & 255);
            while (e > 0);
            return this;
          };
          N.DataBuffer.prototype.putSignedInt = function(t, e) {
            return D2(e), this.accommodate(e / 8), t < 0 && (t += 2 << e - 1), this.putInt(t, e);
          };
          N.DataBuffer.prototype.getByte = function() {
            return this.data.getInt8(this.read++);
          };
          N.DataBuffer.prototype.getInt16 = function() {
            var t = this.data.getInt16(this.read);
            return this.read += 2, t;
          };
          N.DataBuffer.prototype.getInt24 = function() {
            var t = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
            return this.read += 3, t;
          };
          N.DataBuffer.prototype.getInt32 = function() {
            var t = this.data.getInt32(this.read);
            return this.read += 4, t;
          };
          N.DataBuffer.prototype.getInt16Le = function() {
            var t = this.data.getInt16(this.read, true);
            return this.read += 2, t;
          };
          N.DataBuffer.prototype.getInt24Le = function() {
            var t = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
            return this.read += 3, t;
          };
          N.DataBuffer.prototype.getInt32Le = function() {
            var t = this.data.getInt32(this.read, true);
            return this.read += 4, t;
          };
          N.DataBuffer.prototype.getInt = function(t) {
            D2(t);
            var e = 0;
            do
              e = (e << 8) + this.data.getInt8(this.read++), t -= 8;
            while (t > 0);
            return e;
          };
          N.DataBuffer.prototype.getSignedInt = function(t) {
            var e = this.getInt(t), r = 2 << t - 2;
            return e >= r && (e -= r << 1), e;
          };
          N.DataBuffer.prototype.getBytes = function(t) {
            var e;
            return t ? (t = Math.min(this.length(), t), e = this.data.slice(this.read, this.read + t), this.read += t) : t === 0 ? e = "" : (e = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), e;
          };
          N.DataBuffer.prototype.bytes = function(t) {
            return typeof t > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + t);
          };
          N.DataBuffer.prototype.at = function(t) {
            return this.data.getUint8(this.read + t);
          };
          N.DataBuffer.prototype.setAt = function(t, e) {
            return this.data.setUint8(t, e), this;
          };
          N.DataBuffer.prototype.last = function() {
            return this.data.getUint8(this.write - 1);
          };
          N.DataBuffer.prototype.copy = function() {
            return new N.DataBuffer(this);
          };
          N.DataBuffer.prototype.compact = function() {
            if (this.read > 0) {
              var t = new Uint8Array(this.data.buffer, this.read), e = new Uint8Array(t.byteLength);
              e.set(t), this.data = new DataView(e), this.write -= this.read, this.read = 0;
            }
            return this;
          };
          N.DataBuffer.prototype.clear = function() {
            return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
          };
          N.DataBuffer.prototype.truncate = function(t) {
            return this.write = Math.max(0, this.length() - t), this.read = Math.min(this.read, this.write), this;
          };
          N.DataBuffer.prototype.toHex = function() {
            for (var t = "", e = this.read; e < this.data.byteLength; ++e) {
              var r = this.data.getUint8(e);
              r < 16 && (t += "0"), t += r.toString(16);
            }
            return t;
          };
          N.DataBuffer.prototype.toString = function(t) {
            var e = new Uint8Array(this.data, this.read, this.length());
            if (t = t || "utf8", t === "binary" || t === "raw")
              return N.binary.raw.encode(e);
            if (t === "hex")
              return N.binary.hex.encode(e);
            if (t === "base64")
              return N.binary.base64.encode(e);
            if (t === "utf8")
              return N.text.utf8.decode(e);
            if (t === "utf16")
              return N.text.utf16.decode(e);
            throw new Error("Invalid encoding: " + t);
          };
          N.createBuffer = function(t, e) {
            return e = e || "raw", t !== void 0 && e === "utf8" && (t = N.encodeUtf8(t)), new N.ByteBuffer(t);
          };
          N.fillString = function(t, e) {
            for (var r = ""; e > 0; )
              e & 1 && (r += t), e >>>= 1, e > 0 && (t += t);
            return r;
          };
          N.xorBytes = function(t, e, r) {
            for (var n = "", i2 = "", o = "", s = 0, a = 0; r > 0; --r, ++s)
              i2 = t.charCodeAt(s) ^ e.charCodeAt(s), a >= 10 && (n += o, o = "", a = 0), o += String.fromCharCode(i2), ++a;
            return n += o, n;
          };
          N.hexToBytes = function(t) {
            var e = "", r = 0;
            for (t.length & true && (r = 1, e += String.fromCharCode(parseInt(t[0], 16))); r < t.length; r += 2)
              e += String.fromCharCode(parseInt(t.substr(r, 2), 16));
            return e;
          };
          N.bytesToHex = function(t) {
            return N.createBuffer(t).toHex();
          };
          N.int32ToBytes = function(t) {
            return String.fromCharCode(t >> 24 & 255) + String.fromCharCode(t >> 16 & 255) + String.fromCharCode(t >> 8 & 255) + String.fromCharCode(t & 255);
          };
          var il = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", ol = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], aK = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
          N.encode64 = function(t, e) {
            for (var r = "", n = "", i2, o, s, a = 0; a < t.length; )
              i2 = t.charCodeAt(a++), o = t.charCodeAt(a++), s = t.charCodeAt(a++), r += il.charAt(i2 >> 2), r += il.charAt((i2 & 3) << 4 | o >> 4), isNaN(o) ? r += "==" : (r += il.charAt((o & 15) << 2 | s >> 6), r += isNaN(s) ? "=" : il.charAt(s & 63)), e && r.length > e && (n += r.substr(0, e) + `\r
`, r = r.substr(e));
            return n += r, n;
          };
          N.decode64 = function(t) {
            t = t.replace(/[^A-Za-z0-9\+\/\=]/g, "");
            for (var e = "", r, n, i2, o, s = 0; s < t.length; )
              r = ol[t.charCodeAt(s++) - 43], n = ol[t.charCodeAt(s++) - 43], i2 = ol[t.charCodeAt(s++) - 43], o = ol[t.charCodeAt(s++) - 43], e += String.fromCharCode(r << 2 | n >> 4), i2 !== 64 && (e += String.fromCharCode((n & 15) << 4 | i2 >> 2), o !== 64 && (e += String.fromCharCode((i2 & 3) << 6 | o)));
            return e;
          };
          N.encodeUtf8 = function(t) {
            return unescape(encodeURIComponent(t));
          };
          N.decodeUtf8 = function(t) {
            return decodeURIComponent(escape(t));
          };
          N.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: sK.encode, decode: sK.decode } };
          N.binary.raw.encode = function(t) {
            return String.fromCharCode.apply(null, t);
          };
          N.binary.raw.decode = function(t, e, r) {
            var n = e;
            n || (n = new Uint8Array(t.length)), r = r || 0;
            for (var i2 = r, o = 0; o < t.length; ++o)
              n[i2++] = t.charCodeAt(o);
            return e ? i2 - r : n;
          };
          N.binary.hex.encode = N.bytesToHex;
          N.binary.hex.decode = function(t, e, r) {
            var n = e;
            n || (n = new Uint8Array(Math.ceil(t.length / 2))), r = r || 0;
            var i2 = 0, o = r;
            for (t.length & 1 && (i2 = 1, n[o++] = parseInt(t[0], 16)); i2 < t.length; i2 += 2)
              n[o++] = parseInt(t.substr(i2, 2), 16);
            return e ? o - r : n;
          };
          N.binary.base64.encode = function(t, e) {
            for (var r = "", n = "", i2, o, s, a = 0; a < t.byteLength; )
              i2 = t[a++], o = t[a++], s = t[a++], r += il.charAt(i2 >> 2), r += il.charAt((i2 & 3) << 4 | o >> 4), isNaN(o) ? r += "==" : (r += il.charAt((o & 15) << 2 | s >> 6), r += isNaN(s) ? "=" : il.charAt(s & 63)), e && r.length > e && (n += r.substr(0, e) + `\r
`, r = r.substr(e));
            return n += r, n;
          };
          N.binary.base64.decode = function(t, e, r) {
            var n = e;
            n || (n = new Uint8Array(Math.ceil(t.length / 4) * 3)), t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""), r = r || 0;
            for (var i2, o, s, a, u = 0, l = r; u < t.length; )
              i2 = ol[t.charCodeAt(u++) - 43], o = ol[t.charCodeAt(u++) - 43], s = ol[t.charCodeAt(u++) - 43], a = ol[t.charCodeAt(u++) - 43], n[l++] = i2 << 2 | o >> 4, s !== 64 && (n[l++] = (o & 15) << 4 | s >> 2, a !== 64 && (n[l++] = (s & 3) << 6 | a));
            return e ? l - r : n.subarray(0, l);
          };
          N.binary.base58.encode = function(t, e) {
            return N.binary.baseN.encode(t, aK, e);
          };
          N.binary.base58.decode = function(t, e) {
            return N.binary.baseN.decode(t, aK, e);
          };
          N.text = { utf8: {}, utf16: {} };
          N.text.utf8.encode = function(t, e, r) {
            t = N.encodeUtf8(t);
            var n = e;
            n || (n = new Uint8Array(t.length)), r = r || 0;
            for (var i2 = r, o = 0; o < t.length; ++o)
              n[i2++] = t.charCodeAt(o);
            return e ? i2 - r : n;
          };
          N.text.utf8.decode = function(t) {
            return N.decodeUtf8(String.fromCharCode.apply(null, t));
          };
          N.text.utf16.encode = function(t, e, r) {
            var n = e;
            n || (n = new Uint8Array(t.length * 2));
            var i2 = new Uint16Array(n.buffer);
            r = r || 0;
            for (var o = r, s = r, a = 0; a < t.length; ++a)
              i2[s++] = t.charCodeAt(a), o += 2;
            return e ? o - r : n;
          };
          N.text.utf16.decode = function(t) {
            return String.fromCharCode.apply(null, new Uint16Array(t.buffer));
          };
          N.deflate = function(t, e, r) {
            if (e = N.decode64(t.deflate(N.encode64(e)).rval), r) {
              var n = 2, i2 = e.charCodeAt(1);
              i2 & 32 && (n = 6), e = e.substring(n, e.length - 4);
            }
            return e;
          };
          N.inflate = function(t, e, r) {
            var n = t.inflate(N.encode64(e)).rval;
            return n === null ? null : N.decode64(n);
          };
          var hx = function(t, e, r) {
            if (!t)
              throw new Error("WebStorage not available.");
            var n;
            if (r === null ? n = t.removeItem(e) : (r = N.encode64(JSON.stringify(r)), n = t.setItem(e, r)), typeof n < "u" && n.rval !== true) {
              var i2 = new Error(n.error.message);
              throw i2.id = n.error.id, i2.name = n.error.name, i2;
            }
          }, dx = function(t, e) {
            if (!t)
              throw new Error("WebStorage not available.");
            var r = t.getItem(e);
            if (t.init)
              if (r.rval === null) {
                if (r.error) {
                  var n = new Error(r.error.message);
                  throw n.id = r.error.id, n.name = r.error.name, n;
                }
                r = null;
              } else
                r = r.rval;
            return r !== null && (r = JSON.parse(N.decode64(r))), r;
          }, a3e = function(t, e, r, n) {
            var i2 = dx(t, e);
            i2 === null && (i2 = {}), i2[r] = n, hx(t, e, i2);
          }, c3e = function(t, e, r) {
            var n = dx(t, e);
            return n !== null && (n = r in n ? n[r] : null), n;
          }, u3e = function(t, e, r) {
            var n = dx(t, e);
            if (n !== null && r in n) {
              delete n[r];
              var i2 = true;
              for (var o in n) {
                i2 = false;
                break;
              }
              i2 && (n = null), hx(t, e, n);
            }
          }, l3e = function(t, e) {
            hx(t, e, null);
          }, qw = function(t, e, r) {
            var n = null;
            typeof r > "u" && (r = ["web", "flash"]);
            var i2, o = false, s = null;
            for (var a in r) {
              i2 = r[a];
              try {
                if (i2 === "flash" || i2 === "both") {
                  if (e[0] === null)
                    throw new Error("Flash local storage not available.");
                  n = t.apply(this, e), o = i2 === "flash";
                }
                (i2 === "web" || i2 === "both") && (e[0] = localStorage, n = t.apply(this, e), o = true);
              } catch (u) {
                s = u;
              }
              if (o)
                break;
            }
            if (!o)
              throw s;
            return n;
          };
          N.setItem = function(t, e, r, n, i2) {
            qw(a3e, arguments, i2);
          };
          N.getItem = function(t, e, r, n) {
            return qw(c3e, arguments, n);
          };
          N.removeItem = function(t, e, r, n) {
            qw(u3e, arguments, n);
          };
          N.clearItems = function(t, e, r) {
            qw(l3e, arguments, r);
          };
          N.isEmpty = function(t) {
            for (var e in t)
              if (t.hasOwnProperty(e))
                return false;
            return true;
          };
          N.format = function(t) {
            for (var e = /%./g, r, n, i2 = 0, o = [], s = 0; r = e.exec(t); ) {
              n = t.substring(s, e.lastIndex - 2), n.length > 0 && o.push(n), s = e.lastIndex;
              var a = r[0][1];
              switch (a) {
                case "s":
                case "o":
                  i2 < arguments.length ? o.push(arguments[i2++ + 1]) : o.push("<?>");
                  break;
                case "%":
                  o.push("%");
                  break;
                default:
                  o.push("<%" + a + "?>");
              }
            }
            return o.push(t.substring(s)), o.join("");
          };
          N.formatNumber = function(t, e, r, n) {
            var i2 = t, o = isNaN(e = Math.abs(e)) ? 2 : e, s = r === void 0 ? "," : r, a = n === void 0 ? "." : n, u = i2 < 0 ? "-" : "", l = parseInt(i2 = Math.abs(+i2 || 0).toFixed(o), 10) + "", f = l.length > 3 ? l.length % 3 : 0;
            return u + (f ? l.substr(0, f) + a : "") + l.substr(f).replace(/(\d{3})(?=\d)/g, "$1" + a) + (o ? s + Math.abs(i2 - l).toFixed(o).slice(2) : "");
          };
          N.formatSize = function(t) {
            return t >= 1073741824 ? t = N.formatNumber(t / 1073741824, 2, ".", "") + " GiB" : t >= 1048576 ? t = N.formatNumber(t / 1048576, 2, ".", "") + " MiB" : t >= 1024 ? t = N.formatNumber(t / 1024, 0) + " KiB" : t = N.formatNumber(t, 0) + " bytes", t;
          };
          N.bytesFromIP = function(t) {
            return t.indexOf(".") !== -1 ? N.bytesFromIPv4(t) : t.indexOf(":") !== -1 ? N.bytesFromIPv6(t) : null;
          };
          N.bytesFromIPv4 = function(t) {
            if (t = t.split("."), t.length !== 4)
              return null;
            for (var e = N.createBuffer(), r = 0; r < t.length; ++r) {
              var n = parseInt(t[r], 10);
              if (isNaN(n))
                return null;
              e.putByte(n);
            }
            return e.getBytes();
          };
          N.bytesFromIPv6 = function(t) {
            var e = 0;
            t = t.split(":").filter(function(s) {
              return s.length === 0 && ++e, true;
            });
            for (var r = (8 - t.length + e) * 2, n = N.createBuffer(), i2 = 0; i2 < 8; ++i2) {
              if (!t[i2] || t[i2].length === 0) {
                n.fillWithByte(0, r), r = 0;
                continue;
              }
              var o = N.hexToBytes(t[i2]);
              o.length < 2 && n.putByte(0), n.putBytes(o);
            }
            return n.getBytes();
          };
          N.bytesToIP = function(t) {
            return t.length === 4 ? N.bytesToIPv4(t) : t.length === 16 ? N.bytesToIPv6(t) : null;
          };
          N.bytesToIPv4 = function(t) {
            if (t.length !== 4)
              return null;
            for (var e = [], r = 0; r < t.length; ++r)
              e.push(t.charCodeAt(r));
            return e.join(".");
          };
          N.bytesToIPv6 = function(t) {
            if (t.length !== 16)
              return null;
            for (var e = [], r = [], n = 0, i2 = 0; i2 < t.length; i2 += 2) {
              for (var o = N.bytesToHex(t[i2] + t[i2 + 1]); o[0] === "0" && o !== "0"; )
                o = o.substr(1);
              if (o === "0") {
                var s = r[r.length - 1], a = e.length;
                !s || a !== s.end + 1 ? r.push({ start: a, end: a }) : (s.end = a, s.end - s.start > r[n].end - r[n].start && (n = r.length - 1));
              }
              e.push(o);
            }
            if (r.length > 0) {
              var u = r[n];
              u.end - u.start > 0 && (e.splice(u.start, u.end - u.start + 1, ""), u.start === 0 && e.unshift(""), u.end === 7 && e.push(""));
            }
            return e.join(":");
          };
          N.estimateCores = function(t, e) {
            if (typeof t == "function" && (e = t, t = {}), t = t || {}, "cores" in N && !t.update)
              return e(null, N.cores);
            if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
              return N.cores = navigator.hardwareConcurrency, e(null, N.cores);
            if (typeof Worker > "u")
              return N.cores = 1, e(null, N.cores);
            if (typeof Blob > "u")
              return N.cores = 2, e(null, N.cores);
            var r = URL.createObjectURL(new Blob(["(", function() {
              self.addEventListener("message", function(s) {
                for (var a = Date.now(), u = a + 4; Date.now() < u; )
                  ;
                self.postMessage({ st: a, et: u });
              });
            }.toString(), ")()"], { type: "application/javascript" }));
            n([], 5, 16);
            function n(s, a, u) {
              if (a === 0) {
                var l = Math.floor(s.reduce(function(f, h) {
                  return f + h;
                }, 0) / s.length);
                return N.cores = Math.max(1, l), URL.revokeObjectURL(r), e(null, N.cores);
              }
              i2(u, function(f, h) {
                s.push(o(u, h)), n(s, a - 1, u);
              });
            }
            function i2(s, a) {
              for (var u = [], l = [], f = 0; f < s; ++f) {
                var h = new Worker(r);
                h.addEventListener("message", function(p) {
                  if (l.push(p.data), l.length === s) {
                    for (var d = 0; d < s; ++d)
                      u[d].terminate();
                    a(null, l);
                  }
                }), u.push(h);
              }
              for (var f = 0; f < s; ++f)
                u[f].postMessage(f);
            }
            function o(s, a) {
              for (var u = [], l = 0; l < s; ++l)
                for (var f = a[l], h = u[l] = [], p = 0; p < s; ++p)
                  if (l !== p) {
                    var d = a[p];
                    (f.st > d.st && f.st < d.et || d.st > f.st && d.st < f.et) && h.push(p);
                  }
              return u.reduce(function(m, y) {
                return Math.max(m, y.length);
              }, 0);
            }
          };
        });
        var $p = A((Dqe, uK) => {
          c();
          var k2 = st();
          k2.pki = k2.pki || {};
          var px = uK.exports = k2.pki.oids = k2.oids = k2.oids || {};
          function Z(t, e) {
            px[t] = e, px[e] = t;
          }
          function Wt(t, e) {
            px[t] = e;
          }
          Z("1.2.840.113549.1.1.1", "rsaEncryption");
          Z("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
          Z("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
          Z("1.2.840.113549.1.1.7", "RSAES-OAEP");
          Z("1.2.840.113549.1.1.8", "mgf1");
          Z("1.2.840.113549.1.1.9", "pSpecified");
          Z("1.2.840.113549.1.1.10", "RSASSA-PSS");
          Z("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
          Z("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
          Z("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
          Z("1.3.101.112", "EdDSA25519");
          Z("1.2.840.10040.4.3", "dsa-with-sha1");
          Z("1.3.14.3.2.7", "desCBC");
          Z("1.3.14.3.2.26", "sha1");
          Z("1.3.14.3.2.29", "sha1WithRSASignature");
          Z("2.16.840.1.101.3.4.2.1", "sha256");
          Z("2.16.840.1.101.3.4.2.2", "sha384");
          Z("2.16.840.1.101.3.4.2.3", "sha512");
          Z("2.16.840.1.101.3.4.2.4", "sha224");
          Z("2.16.840.1.101.3.4.2.5", "sha512-224");
          Z("2.16.840.1.101.3.4.2.6", "sha512-256");
          Z("1.2.840.113549.2.2", "md2");
          Z("1.2.840.113549.2.5", "md5");
          Z("1.2.840.113549.1.7.1", "data");
          Z("1.2.840.113549.1.7.2", "signedData");
          Z("1.2.840.113549.1.7.3", "envelopedData");
          Z("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
          Z("1.2.840.113549.1.7.5", "digestedData");
          Z("1.2.840.113549.1.7.6", "encryptedData");
          Z("1.2.840.113549.1.9.1", "emailAddress");
          Z("1.2.840.113549.1.9.2", "unstructuredName");
          Z("1.2.840.113549.1.9.3", "contentType");
          Z("1.2.840.113549.1.9.4", "messageDigest");
          Z("1.2.840.113549.1.9.5", "signingTime");
          Z("1.2.840.113549.1.9.6", "counterSignature");
          Z("1.2.840.113549.1.9.7", "challengePassword");
          Z("1.2.840.113549.1.9.8", "unstructuredAddress");
          Z("1.2.840.113549.1.9.14", "extensionRequest");
          Z("1.2.840.113549.1.9.20", "friendlyName");
          Z("1.2.840.113549.1.9.21", "localKeyId");
          Z("1.2.840.113549.1.9.22.1", "x509Certificate");
          Z("1.2.840.113549.1.12.10.1.1", "keyBag");
          Z("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
          Z("1.2.840.113549.1.12.10.1.3", "certBag");
          Z("1.2.840.113549.1.12.10.1.4", "crlBag");
          Z("1.2.840.113549.1.12.10.1.5", "secretBag");
          Z("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
          Z("1.2.840.113549.1.5.13", "pkcs5PBES2");
          Z("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
          Z("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
          Z("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
          Z("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
          Z("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
          Z("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
          Z("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
          Z("1.2.840.113549.2.7", "hmacWithSHA1");
          Z("1.2.840.113549.2.8", "hmacWithSHA224");
          Z("1.2.840.113549.2.9", "hmacWithSHA256");
          Z("1.2.840.113549.2.10", "hmacWithSHA384");
          Z("1.2.840.113549.2.11", "hmacWithSHA512");
          Z("1.2.840.113549.3.7", "des-EDE3-CBC");
          Z("2.16.840.1.101.3.4.1.2", "aes128-CBC");
          Z("2.16.840.1.101.3.4.1.22", "aes192-CBC");
          Z("2.16.840.1.101.3.4.1.42", "aes256-CBC");
          Z("2.5.4.3", "commonName");
          Z("2.5.4.4", "surname");
          Z("2.5.4.5", "serialNumber");
          Z("2.5.4.6", "countryName");
          Z("2.5.4.7", "localityName");
          Z("2.5.4.8", "stateOrProvinceName");
          Z("2.5.4.9", "streetAddress");
          Z("2.5.4.10", "organizationName");
          Z("2.5.4.11", "organizationalUnitName");
          Z("2.5.4.12", "title");
          Z("2.5.4.13", "description");
          Z("2.5.4.15", "businessCategory");
          Z("2.5.4.17", "postalCode");
          Z("2.5.4.42", "givenName");
          Z("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
          Z("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
          Z("2.16.840.1.113730.1.1", "nsCertType");
          Z("2.16.840.1.113730.1.13", "nsComment");
          Wt("2.5.29.1", "authorityKeyIdentifier");
          Wt("2.5.29.2", "keyAttributes");
          Wt("2.5.29.3", "certificatePolicies");
          Wt("2.5.29.4", "keyUsageRestriction");
          Wt("2.5.29.5", "policyMapping");
          Wt("2.5.29.6", "subtreesConstraint");
          Wt("2.5.29.7", "subjectAltName");
          Wt("2.5.29.8", "issuerAltName");
          Wt("2.5.29.9", "subjectDirectoryAttributes");
          Wt("2.5.29.10", "basicConstraints");
          Wt("2.5.29.11", "nameConstraints");
          Wt("2.5.29.12", "policyConstraints");
          Wt("2.5.29.13", "basicConstraints");
          Z("2.5.29.14", "subjectKeyIdentifier");
          Z("2.5.29.15", "keyUsage");
          Wt("2.5.29.16", "privateKeyUsagePeriod");
          Z("2.5.29.17", "subjectAltName");
          Z("2.5.29.18", "issuerAltName");
          Z("2.5.29.19", "basicConstraints");
          Wt("2.5.29.20", "cRLNumber");
          Wt("2.5.29.21", "cRLReason");
          Wt("2.5.29.22", "expirationDate");
          Wt("2.5.29.23", "instructionCode");
          Wt("2.5.29.24", "invalidityDate");
          Wt("2.5.29.25", "cRLDistributionPoints");
          Wt("2.5.29.26", "issuingDistributionPoint");
          Wt("2.5.29.27", "deltaCRLIndicator");
          Wt("2.5.29.28", "issuingDistributionPoint");
          Wt("2.5.29.29", "certificateIssuer");
          Wt("2.5.29.30", "nameConstraints");
          Z("2.5.29.31", "cRLDistributionPoints");
          Z("2.5.29.32", "certificatePolicies");
          Wt("2.5.29.33", "policyMappings");
          Wt("2.5.29.34", "policyConstraints");
          Z("2.5.29.35", "authorityKeyIdentifier");
          Wt("2.5.29.36", "policyConstraints");
          Z("2.5.29.37", "extKeyUsage");
          Wt("2.5.29.46", "freshestCRL");
          Wt("2.5.29.54", "inhibitAnyPolicy");
          Z("1.3.6.1.4.1.11129.2.4.2", "timestampList");
          Z("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
          Z("1.3.6.1.5.5.7.3.1", "serverAuth");
          Z("1.3.6.1.5.5.7.3.2", "clientAuth");
          Z("1.3.6.1.5.5.7.3.3", "codeSigning");
          Z("1.3.6.1.5.5.7.3.4", "emailProtection");
          Z("1.3.6.1.5.5.7.3.8", "timeStamping");
        });
        var Aa = A((kqe, fK) => {
          c();
          var Cr = st();
          gr();
          $p();
          var le = fK.exports = Cr.asn1 = Cr.asn1 || {};
          le.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 };
          le.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 };
          le.create = function(t, e, r, n, i2) {
            if (Cr.util.isArray(n)) {
              for (var o = [], s = 0; s < n.length; ++s)
                n[s] !== void 0 && o.push(n[s]);
              n = o;
            }
            var a = { tagClass: t, type: e, constructed: r, composed: r || Cr.util.isArray(n), value: n };
            return i2 && "bitStringContents" in i2 && (a.bitStringContents = i2.bitStringContents, a.original = le.copy(a)), a;
          };
          le.copy = function(t, e) {
            var r;
            if (Cr.util.isArray(t)) {
              r = [];
              for (var n = 0; n < t.length; ++n)
                r.push(le.copy(t[n], e));
              return r;
            }
            return typeof t == "string" ? t : (r = { tagClass: t.tagClass, type: t.type, constructed: t.constructed, composed: t.composed, value: le.copy(t.value, e) }, e && !e.excludeBitStringContents && (r.bitStringContents = t.bitStringContents), r);
          };
          le.equals = function(t, e, r) {
            if (Cr.util.isArray(t)) {
              if (!Cr.util.isArray(e) || t.length !== e.length)
                return false;
              for (var n = 0; n < t.length; ++n)
                if (!le.equals(t[n], e[n]))
                  return false;
              return true;
            }
            if (typeof t != typeof e)
              return false;
            if (typeof t == "string")
              return t === e;
            var i2 = t.tagClass === e.tagClass && t.type === e.type && t.constructed === e.constructed && t.composed === e.composed && le.equals(t.value, e.value);
            return r && r.includeBitStringContents && (i2 = i2 && t.bitStringContents === e.bitStringContents), i2;
          };
          le.getBerValueLength = function(t) {
            var e = t.getByte();
            if (e !== 128) {
              var r, n = e & 128;
              return n ? r = t.getInt((e & 127) << 3) : r = e, r;
            }
          };
          function N22(t, e, r) {
            if (r > e) {
              var n = new Error("Too few bytes to parse DER.");
              throw n.available = t.length(), n.remaining = e, n.requested = r, n;
            }
          }
          var f3e = function(t, e) {
            var r = t.getByte();
            if (e--, r !== 128) {
              var n, i2 = r & 128;
              if (!i2)
                n = r;
              else {
                var o = r & 127;
                N22(t, e, o), n = t.getInt(o << 3);
              }
              if (n < 0)
                throw new Error("Negative length: " + n);
              return n;
            }
          };
          le.fromDer = function(t, e) {
            e === void 0 && (e = { strict: true, parseAllBytes: true, decodeBitStrings: true }), typeof e == "boolean" && (e = { strict: e, parseAllBytes: true, decodeBitStrings: true }), "strict" in e || (e.strict = true), "parseAllBytes" in e || (e.parseAllBytes = true), "decodeBitStrings" in e || (e.decodeBitStrings = true), typeof t == "string" && (t = Cr.util.createBuffer(t));
            var r = t.length(), n = zw(t, t.length(), 0, e);
            if (e.parseAllBytes && t.length() !== 0) {
              var i2 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
              throw i2.byteCount = r, i2.remaining = t.length(), i2;
            }
            return n;
          };
          function zw(t, e, r, n) {
            var i2;
            N22(t, e, 2);
            var o = t.getByte();
            e--;
            var s = o & 192, a = o & 31;
            i2 = t.length();
            var u = f3e(t, e);
            if (e -= i2 - t.length(), u !== void 0 && u > e) {
              if (n.strict) {
                var l = new Error("Too few bytes to read ASN.1 value.");
                throw l.available = t.length(), l.remaining = e, l.requested = u, l;
              }
              u = e;
            }
            var f, h, p = (o & 32) === 32;
            if (p)
              if (f = [], u === void 0)
                for (; ; ) {
                  if (N22(t, e, 2), t.bytes(2) === String.fromCharCode(0, 0)) {
                    t.getBytes(2), e -= 2;
                    break;
                  }
                  i2 = t.length(), f.push(zw(t, e, r + 1, n)), e -= i2 - t.length();
                }
              else
                for (; u > 0; )
                  i2 = t.length(), f.push(zw(t, u, r + 1, n)), e -= i2 - t.length(), u -= i2 - t.length();
            if (f === void 0 && s === le.Class.UNIVERSAL && a === le.Type.BITSTRING && (h = t.bytes(u)), f === void 0 && n.decodeBitStrings && s === le.Class.UNIVERSAL && a === le.Type.BITSTRING && u > 1) {
              var d = t.read, m = e, y = 0;
              if (a === le.Type.BITSTRING && (N22(t, e, 1), y = t.getByte(), e--), y === 0)
                try {
                  i2 = t.length();
                  var g = { strict: true, decodeBitStrings: true }, E = zw(t, e, r + 1, g), b = i2 - t.length();
                  e -= b, a == le.Type.BITSTRING && b++;
                  var v = E.tagClass;
                  b === u && (v === le.Class.UNIVERSAL || v === le.Class.CONTEXT_SPECIFIC) && (f = [E]);
                } catch {
                }
              f === void 0 && (t.read = d, e = m);
            }
            if (f === void 0) {
              if (u === void 0) {
                if (n.strict)
                  throw new Error("Non-constructed ASN.1 object of indefinite length.");
                u = e;
              }
              if (a === le.Type.BMPSTRING)
                for (f = ""; u > 0; u -= 2)
                  N22(t, e, 2), f += String.fromCharCode(t.getInt16()), e -= 2;
              else
                f = t.getBytes(u), e -= u;
            }
            var S = h === void 0 ? null : { bitStringContents: h };
            return le.create(s, a, p, f, S);
          }
          le.toDer = function(t) {
            var e = Cr.util.createBuffer(), r = t.tagClass | t.type, n = Cr.util.createBuffer(), i2 = false;
            if ("bitStringContents" in t && (i2 = true, t.original && (i2 = le.equals(t, t.original))), i2)
              n.putBytes(t.bitStringContents);
            else if (t.composed) {
              t.constructed ? r |= 32 : n.putByte(0);
              for (var o = 0; o < t.value.length; ++o)
                t.value[o] !== void 0 && n.putBuffer(le.toDer(t.value[o]));
            } else if (t.type === le.Type.BMPSTRING)
              for (var o = 0; o < t.value.length; ++o)
                n.putInt16(t.value.charCodeAt(o));
            else
              t.type === le.Type.INTEGER && t.value.length > 1 && (t.value.charCodeAt(0) === 0 && (t.value.charCodeAt(1) & 128) === 0 || t.value.charCodeAt(0) === 255 && (t.value.charCodeAt(1) & 128) === 128) ? n.putBytes(t.value.substr(1)) : n.putBytes(t.value);
            if (e.putByte(r), n.length() <= 127)
              e.putByte(n.length() & 127);
            else {
              var s = n.length(), a = "";
              do
                a += String.fromCharCode(s & 255), s = s >>> 8;
              while (s > 0);
              e.putByte(a.length | 128);
              for (var o = a.length - 1; o >= 0; --o)
                e.putByte(a.charCodeAt(o));
            }
            return e.putBuffer(n), e;
          };
          le.oidToDer = function(t) {
            var e = t.split("."), r = Cr.util.createBuffer();
            r.putByte(40 * parseInt(e[0], 10) + parseInt(e[1], 10));
            for (var n, i2, o, s, a = 2; a < e.length; ++a) {
              n = true, i2 = [], o = parseInt(e[a], 10);
              do
                s = o & 127, o = o >>> 7, n || (s |= 128), i2.push(s), n = false;
              while (o > 0);
              for (var u = i2.length - 1; u >= 0; --u)
                r.putByte(i2[u]);
            }
            return r;
          };
          le.derToOid = function(t) {
            var e;
            typeof t == "string" && (t = Cr.util.createBuffer(t));
            var r = t.getByte();
            e = Math.floor(r / 40) + "." + r % 40;
            for (var n = 0; t.length() > 0; )
              r = t.getByte(), n = n << 7, r & 128 ? n += r & 127 : (e += "." + (n + r), n = 0);
            return e;
          };
          le.utcTimeToDate = function(t) {
            var e = new Date(), r = parseInt(t.substr(0, 2), 10);
            r = r >= 50 ? 1900 + r : 2e3 + r;
            var n = parseInt(t.substr(2, 2), 10) - 1, i2 = parseInt(t.substr(4, 2), 10), o = parseInt(t.substr(6, 2), 10), s = parseInt(t.substr(8, 2), 10), a = 0;
            if (t.length > 11) {
              var u = t.charAt(10), l = 10;
              u !== "+" && u !== "-" && (a = parseInt(t.substr(10, 2), 10), l += 2);
            }
            if (e.setUTCFullYear(r, n, i2), e.setUTCHours(o, s, a, 0), l && (u = t.charAt(l), u === "+" || u === "-")) {
              var f = parseInt(t.substr(l + 1, 2), 10), h = parseInt(t.substr(l + 4, 2), 10), p = f * 60 + h;
              p *= 6e4, u === "+" ? e.setTime(+e - p) : e.setTime(+e + p);
            }
            return e;
          };
          le.generalizedTimeToDate = function(t) {
            var e = new Date(), r = parseInt(t.substr(0, 4), 10), n = parseInt(t.substr(4, 2), 10) - 1, i2 = parseInt(t.substr(6, 2), 10), o = parseInt(t.substr(8, 2), 10), s = parseInt(t.substr(10, 2), 10), a = parseInt(t.substr(12, 2), 10), u = 0, l = 0, f = false;
            t.charAt(t.length - 1) === "Z" && (f = true);
            var h = t.length - 5, p = t.charAt(h);
            if (p === "+" || p === "-") {
              var d = parseInt(t.substr(h + 1, 2), 10), m = parseInt(t.substr(h + 4, 2), 10);
              l = d * 60 + m, l *= 6e4, p === "+" && (l *= -1), f = true;
            }
            return t.charAt(14) === "." && (u = parseFloat(t.substr(14), 10) * 1e3), f ? (e.setUTCFullYear(r, n, i2), e.setUTCHours(o, s, a, u), e.setTime(+e + l)) : (e.setFullYear(r, n, i2), e.setHours(o, s, a, u)), e;
          };
          le.dateToUtcTime = function(t) {
            if (typeof t == "string")
              return t;
            var e = "", r = [];
            r.push(("" + t.getUTCFullYear()).substr(2)), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
            for (var n = 0; n < r.length; ++n)
              r[n].length < 2 && (e += "0"), e += r[n];
            return e += "Z", e;
          };
          le.dateToGeneralizedTime = function(t) {
            if (typeof t == "string")
              return t;
            var e = "", r = [];
            r.push("" + t.getUTCFullYear()), r.push("" + (t.getUTCMonth() + 1)), r.push("" + t.getUTCDate()), r.push("" + t.getUTCHours()), r.push("" + t.getUTCMinutes()), r.push("" + t.getUTCSeconds());
            for (var n = 0; n < r.length; ++n)
              r[n].length < 2 && (e += "0"), e += r[n];
            return e += "Z", e;
          };
          le.integerToDer = function(t) {
            var e = Cr.util.createBuffer();
            if (t >= -128 && t < 128)
              return e.putSignedInt(t, 8);
            if (t >= -32768 && t < 32768)
              return e.putSignedInt(t, 16);
            if (t >= -8388608 && t < 8388608)
              return e.putSignedInt(t, 24);
            if (t >= -2147483648 && t < 2147483648)
              return e.putSignedInt(t, 32);
            var r = new Error("Integer too large; max is 32-bits.");
            throw r.integer = t, r;
          };
          le.derToInteger = function(t) {
            typeof t == "string" && (t = Cr.util.createBuffer(t));
            var e = t.length() * 8;
            if (e > 32)
              throw new Error("Integer too large; max is 32-bits.");
            return t.getSignedInt(e);
          };
          le.validate = function(t, e, r, n) {
            var i2 = false;
            if ((t.tagClass === e.tagClass || typeof e.tagClass > "u") && (t.type === e.type || typeof e.type > "u"))
              if (t.constructed === e.constructed || typeof e.constructed > "u") {
                if (i2 = true, e.value && Cr.util.isArray(e.value))
                  for (var o = 0, s = 0; i2 && s < e.value.length; ++s)
                    i2 = e.value[s].optional || false, t.value[o] && (i2 = le.validate(t.value[o], e.value[s], r, n), i2 ? ++o : e.value[s].optional && (i2 = true)), !i2 && n && n.push("[" + e.name + '] Tag class "' + e.tagClass + '", type "' + e.type + '" expected value length "' + e.value.length + '", got "' + t.value.length + '"');
                if (i2 && r && (e.capture && (r[e.capture] = t.value), e.captureAsn1 && (r[e.captureAsn1] = t), e.captureBitStringContents && "bitStringContents" in t && (r[e.captureBitStringContents] = t.bitStringContents), e.captureBitStringValue && "bitStringContents" in t)) {
                  var a;
                  if (t.bitStringContents.length < 2)
                    r[e.captureBitStringValue] = "";
                  else {
                    var u = t.bitStringContents.charCodeAt(0);
                    if (u !== 0)
                      throw new Error("captureBitStringValue only supported for zero unused bits");
                    r[e.captureBitStringValue] = t.bitStringContents.slice(1);
                  }
                }
              } else
                n && n.push("[" + e.name + '] Expected constructed "' + e.constructed + '", got "' + t.constructed + '"');
            else
              n && (t.tagClass !== e.tagClass && n.push("[" + e.name + '] Expected tag class "' + e.tagClass + '", got "' + t.tagClass + '"'), t.type !== e.type && n.push("[" + e.name + '] Expected type "' + e.type + '", got "' + t.type + '"'));
            return i2;
          };
          var lK = /[^\\u0000-\\u00ff]/;
          le.prettyPrint = function(t, e, r) {
            var n = "";
            e = e || 0, r = r || 2, e > 0 && (n += `
`);
            for (var i2 = "", o = 0; o < e * r; ++o)
              i2 += " ";
            switch (n += i2 + "Tag: ", t.tagClass) {
              case le.Class.UNIVERSAL:
                n += "Universal:";
                break;
              case le.Class.APPLICATION:
                n += "Application:";
                break;
              case le.Class.CONTEXT_SPECIFIC:
                n += "Context-Specific:";
                break;
              case le.Class.PRIVATE:
                n += "Private:";
                break;
            }
            if (t.tagClass === le.Class.UNIVERSAL)
              switch (n += t.type, t.type) {
                case le.Type.NONE:
                  n += " (None)";
                  break;
                case le.Type.BOOLEAN:
                  n += " (Boolean)";
                  break;
                case le.Type.INTEGER:
                  n += " (Integer)";
                  break;
                case le.Type.BITSTRING:
                  n += " (Bit string)";
                  break;
                case le.Type.OCTETSTRING:
                  n += " (Octet string)";
                  break;
                case le.Type.NULL:
                  n += " (Null)";
                  break;
                case le.Type.OID:
                  n += " (Object Identifier)";
                  break;
                case le.Type.ODESC:
                  n += " (Object Descriptor)";
                  break;
                case le.Type.EXTERNAL:
                  n += " (External or Instance of)";
                  break;
                case le.Type.REAL:
                  n += " (Real)";
                  break;
                case le.Type.ENUMERATED:
                  n += " (Enumerated)";
                  break;
                case le.Type.EMBEDDED:
                  n += " (Embedded PDV)";
                  break;
                case le.Type.UTF8:
                  n += " (UTF8)";
                  break;
                case le.Type.ROID:
                  n += " (Relative Object Identifier)";
                  break;
                case le.Type.SEQUENCE:
                  n += " (Sequence)";
                  break;
                case le.Type.SET:
                  n += " (Set)";
                  break;
                case le.Type.PRINTABLESTRING:
                  n += " (Printable String)";
                  break;
                case le.Type.IA5String:
                  n += " (IA5String (ASCII))";
                  break;
                case le.Type.UTCTIME:
                  n += " (UTC time)";
                  break;
                case le.Type.GENERALIZEDTIME:
                  n += " (Generalized time)";
                  break;
                case le.Type.BMPSTRING:
                  n += " (BMP String)";
                  break;
              }
            else
              n += t.type;
            if (n += `
`, n += i2 + "Constructed: " + t.constructed + `
`, t.composed) {
              for (var s = 0, a = "", o = 0; o < t.value.length; ++o)
                t.value[o] !== void 0 && (s += 1, a += le.prettyPrint(t.value[o], e + 1, r), o + 1 < t.value.length && (a += ","));
              n += i2 + "Sub values: " + s + a;
            } else {
              if (n += i2 + "Value: ", t.type === le.Type.OID) {
                var u = le.derToOid(t.value);
                n += u, Cr.pki && Cr.pki.oids && u in Cr.pki.oids && (n += " (" + Cr.pki.oids[u] + ") ");
              }
              if (t.type === le.Type.INTEGER)
                try {
                  n += le.derToInteger(t.value);
                } catch {
                  n += "0x" + Cr.util.bytesToHex(t.value);
                }
              else if (t.type === le.Type.BITSTRING) {
                if (t.value.length > 1 ? n += "0x" + Cr.util.bytesToHex(t.value.slice(1)) : n += "(none)", t.value.length > 0) {
                  var l = t.value.charCodeAt(0);
                  l == 1 ? n += " (1 unused bit shown)" : l > 1 && (n += " (" + l + " unused bits shown)");
                }
              } else if (t.type === le.Type.OCTETSTRING)
                lK.test(t.value) || (n += "(" + t.value + ") "), n += "0x" + Cr.util.bytesToHex(t.value);
              else if (t.type === le.Type.UTF8)
                try {
                  n += Cr.util.decodeUtf8(t.value);
                } catch (f) {
                  if (f.message === "URI malformed")
                    n += "0x" + Cr.util.bytesToHex(t.value) + " (malformed UTF8)";
                  else
                    throw f;
                }
              else
                t.type === le.Type.PRINTABLESTRING || t.type === le.Type.IA5String ? n += t.value : lK.test(t.value) ? n += "0x" + Cr.util.bytesToHex(t.value) : t.value.length === 0 ? n += "[null]" : n += t.value;
            }
            return n;
          };
        });
        var yx = A((Nqe, hK) => {
          c();
          var Vn = st();
          gr();
          hK.exports = Vn.cipher = Vn.cipher || {};
          Vn.cipher.algorithms = Vn.cipher.algorithms || {};
          Vn.cipher.createCipher = function(t, e) {
            var r = t;
            if (typeof r == "string" && (r = Vn.cipher.getAlgorithm(r), r && (r = r())), !r)
              throw new Error("Unsupported algorithm: " + t);
            return new Vn.cipher.BlockCipher({ algorithm: r, key: e, decrypt: false });
          };
          Vn.cipher.createDecipher = function(t, e) {
            var r = t;
            if (typeof r == "string" && (r = Vn.cipher.getAlgorithm(r), r && (r = r())), !r)
              throw new Error("Unsupported algorithm: " + t);
            return new Vn.cipher.BlockCipher({ algorithm: r, key: e, decrypt: true });
          };
          Vn.cipher.registerAlgorithm = function(t, e) {
            t = t.toUpperCase(), Vn.cipher.algorithms[t] = e;
          };
          Vn.cipher.getAlgorithm = function(t) {
            return t = t.toUpperCase(), t in Vn.cipher.algorithms ? Vn.cipher.algorithms[t] : null;
          };
          var mx = Vn.cipher.BlockCipher = function(t) {
            this.algorithm = t.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = false, this._input = null, this.output = null, this._op = t.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = t.decrypt, this.algorithm.initialize(t);
          };
          mx.prototype.start = function(t) {
            t = t || {};
            var e = {};
            for (var r in t)
              e[r] = t[r];
            e.decrypt = this._decrypt, this._finish = false, this._input = Vn.util.createBuffer(), this.output = t.output || Vn.util.createBuffer(), this.mode.start(e);
          };
          mx.prototype.update = function(t) {
            for (t && this._input.putBuffer(t); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
              ;
            this._input.compact();
          };
          mx.prototype.finish = function(t) {
            t && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(r) {
              return t(this.blockSize, r, false);
            }, this.mode.unpad = function(r) {
              return t(this.blockSize, r, true);
            });
            var e = {};
            return e.decrypt = this._decrypt, e.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, e) || (this._finish = true, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, e)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, e));
          };
        });
        var wx = A((Oqe, dK) => {
          c();
          var qn = st();
          gr();
          qn.cipher = qn.cipher || {};
          var bt = dK.exports = qn.cipher.modes = qn.cipher.modes || {};
          bt.ecb = function(t) {
            t = t || {}, this.name = "ECB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
          };
          bt.ecb.prototype.start = function(t) {
          };
          bt.ecb.prototype.encrypt = function(t, e, r) {
            if (t.length() < this.blockSize && !(r && t.length() > 0))
              return true;
            for (var n = 0; n < this._ints; ++n)
              this._inBlock[n] = t.getInt32();
            this.cipher.encrypt(this._inBlock, this._outBlock);
            for (var n = 0; n < this._ints; ++n)
              e.putInt32(this._outBlock[n]);
          };
          bt.ecb.prototype.decrypt = function(t, e, r) {
            if (t.length() < this.blockSize && !(r && t.length() > 0))
              return true;
            for (var n = 0; n < this._ints; ++n)
              this._inBlock[n] = t.getInt32();
            this.cipher.decrypt(this._inBlock, this._outBlock);
            for (var n = 0; n < this._ints; ++n)
              e.putInt32(this._outBlock[n]);
          };
          bt.ecb.prototype.pad = function(t, e) {
            var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
            return t.fillWithByte(r, r), true;
          };
          bt.ecb.prototype.unpad = function(t, e) {
            if (e.overflow > 0)
              return false;
            var r = t.length(), n = t.at(r - 1);
            return n > this.blockSize << 2 ? false : (t.truncate(n), true);
          };
          bt.cbc = function(t) {
            t = t || {}, this.name = "CBC", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
          };
          bt.cbc.prototype.start = function(t) {
            if (t.iv === null) {
              if (!this._prev)
                throw new Error("Invalid IV parameter.");
              this._iv = this._prev.slice(0);
            } else if ("iv" in t)
              this._iv = Hw(t.iv, this.blockSize), this._prev = this._iv.slice(0);
            else
              throw new Error("Invalid IV parameter.");
          };
          bt.cbc.prototype.encrypt = function(t, e, r) {
            if (t.length() < this.blockSize && !(r && t.length() > 0))
              return true;
            for (var n = 0; n < this._ints; ++n)
              this._inBlock[n] = this._prev[n] ^ t.getInt32();
            this.cipher.encrypt(this._inBlock, this._outBlock);
            for (var n = 0; n < this._ints; ++n)
              e.putInt32(this._outBlock[n]);
            this._prev = this._outBlock;
          };
          bt.cbc.prototype.decrypt = function(t, e, r) {
            if (t.length() < this.blockSize && !(r && t.length() > 0))
              return true;
            for (var n = 0; n < this._ints; ++n)
              this._inBlock[n] = t.getInt32();
            this.cipher.decrypt(this._inBlock, this._outBlock);
            for (var n = 0; n < this._ints; ++n)
              e.putInt32(this._prev[n] ^ this._outBlock[n]);
            this._prev = this._inBlock.slice(0);
          };
          bt.cbc.prototype.pad = function(t, e) {
            var r = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length();
            return t.fillWithByte(r, r), true;
          };
          bt.cbc.prototype.unpad = function(t, e) {
            if (e.overflow > 0)
              return false;
            var r = t.length(), n = t.at(r - 1);
            return n > this.blockSize << 2 ? false : (t.truncate(n), true);
          };
          bt.cfb = function(t) {
            t = t || {}, this.name = "CFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = qn.util.createBuffer(), this._partialBytes = 0;
          };
          bt.cfb.prototype.start = function(t) {
            if (!("iv" in t))
              throw new Error("Invalid IV parameter.");
            this._iv = Hw(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
          };
          bt.cfb.prototype.encrypt = function(t, e, r) {
            var n = t.length();
            if (n === 0)
              return true;
            if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._inBlock[i2] = t.getInt32() ^ this._outBlock[i2], e.putInt32(this._inBlock[i2]);
              return;
            }
            var o = (this.blockSize - n) % this.blockSize;
            o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
            for (var i2 = 0; i2 < this._ints; ++i2)
              this._partialBlock[i2] = t.getInt32() ^ this._outBlock[i2], this._partialOutput.putInt32(this._partialBlock[i2]);
            if (o > 0)
              t.read -= this.blockSize;
            else
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._inBlock[i2] = this._partialBlock[i2];
            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
              return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), this._partialBytes = o, true;
            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0;
          };
          bt.cfb.prototype.decrypt = function(t, e, r) {
            var n = t.length();
            if (n === 0)
              return true;
            if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._inBlock[i2] = t.getInt32(), e.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
              return;
            }
            var o = (this.blockSize - n) % this.blockSize;
            o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
            for (var i2 = 0; i2 < this._ints; ++i2)
              this._partialBlock[i2] = t.getInt32(), this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
            if (o > 0)
              t.read -= this.blockSize;
            else
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._inBlock[i2] = this._partialBlock[i2];
            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
              return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), this._partialBytes = o, true;
            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0;
          };
          bt.ofb = function(t) {
            t = t || {}, this.name = "OFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = qn.util.createBuffer(), this._partialBytes = 0;
          };
          bt.ofb.prototype.start = function(t) {
            if (!("iv" in t))
              throw new Error("Invalid IV parameter.");
            this._iv = Hw(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
          };
          bt.ofb.prototype.encrypt = function(t, e, r) {
            var n = t.length();
            if (t.length() === 0)
              return true;
            if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
              for (var i2 = 0; i2 < this._ints; ++i2)
                e.putInt32(t.getInt32() ^ this._outBlock[i2]), this._inBlock[i2] = this._outBlock[i2];
              return;
            }
            var o = (this.blockSize - n) % this.blockSize;
            o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
            for (var i2 = 0; i2 < this._ints; ++i2)
              this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i2]);
            if (o > 0)
              t.read -= this.blockSize;
            else
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._inBlock[i2] = this._outBlock[i2];
            if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
              return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), this._partialBytes = o, true;
            e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0;
          };
          bt.ofb.prototype.decrypt = bt.ofb.prototype.encrypt;
          bt.ctr = function(t) {
            t = t || {}, this.name = "CTR", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = qn.util.createBuffer(), this._partialBytes = 0;
          };
          bt.ctr.prototype.start = function(t) {
            if (!("iv" in t))
              throw new Error("Invalid IV parameter.");
            this._iv = Hw(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
          };
          bt.ctr.prototype.encrypt = function(t, e, r) {
            var n = t.length();
            if (n === 0)
              return true;
            if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize)
              for (var i2 = 0; i2 < this._ints; ++i2)
                e.putInt32(t.getInt32() ^ this._outBlock[i2]);
            else {
              var o = (this.blockSize - n) % this.blockSize;
              o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i2]);
              if (o > 0 && (t.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
                return e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), this._partialBytes = o, true;
              e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0;
            }
            $w(this._inBlock);
          };
          bt.ctr.prototype.decrypt = bt.ctr.prototype.encrypt;
          bt.gcm = function(t) {
            t = t || {}, this.name = "GCM", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = qn.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
          };
          bt.gcm.prototype.start = function(t) {
            if (!("iv" in t))
              throw new Error("Invalid IV parameter.");
            var e = qn.util.createBuffer(t.iv);
            this._cipherLength = 0;
            var r;
            if ("additionalData" in t ? r = qn.util.createBuffer(t.additionalData) : r = qn.util.createBuffer(), "tagLength" in t ? this._tagLength = t.tagLength : this._tagLength = 128, this._tag = null, t.decrypt && (this._tag = qn.util.createBuffer(t.tag).getBytes(), this._tag.length !== this._tagLength / 8))
              throw new Error("Authentication tag does not match tag length.");
            this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
            var n = e.length();
            if (n === 12)
              this._j0 = [e.getInt32(), e.getInt32(), e.getInt32(), 1];
            else {
              for (this._j0 = [0, 0, 0, 0]; e.length() > 0; )
                this._j0 = this.ghash(this._hashSubkey, this._j0, [e.getInt32(), e.getInt32(), e.getInt32(), e.getInt32()]);
              this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(gx(n * 8)));
            }
            this._inBlock = this._j0.slice(0), $w(this._inBlock), this._partialBytes = 0, r = qn.util.createBuffer(r), this._aDataLength = gx(r.length() * 8);
            var i2 = r.length() % this.blockSize;
            for (i2 && r.fillWithByte(0, this.blockSize - i2), this._s = [0, 0, 0, 0]; r.length() > 0; )
              this._s = this.ghash(this._hashSubkey, this._s, [r.getInt32(), r.getInt32(), r.getInt32(), r.getInt32()]);
          };
          bt.gcm.prototype.encrypt = function(t, e, r) {
            var n = t.length();
            if (n === 0)
              return true;
            if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && n >= this.blockSize) {
              for (var i2 = 0; i2 < this._ints; ++i2)
                e.putInt32(this._outBlock[i2] ^= t.getInt32());
              this._cipherLength += this.blockSize;
            } else {
              var o = (this.blockSize - n) % this.blockSize;
              o > 0 && (o = this.blockSize - o), this._partialOutput.clear();
              for (var i2 = 0; i2 < this._ints; ++i2)
                this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[i2]);
              if (o <= 0 || r) {
                if (r) {
                  var s = n % this.blockSize;
                  this._cipherLength += s, this._partialOutput.truncate(this.blockSize - s);
                } else
                  this._cipherLength += this.blockSize;
                for (var i2 = 0; i2 < this._ints; ++i2)
                  this._outBlock[i2] = this._partialOutput.getInt32();
                this._partialOutput.read -= this.blockSize;
              }
              if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), o > 0 && !r)
                return t.read -= this.blockSize, e.putBytes(this._partialOutput.getBytes(o - this._partialBytes)), this._partialBytes = o, true;
              e.putBytes(this._partialOutput.getBytes(n - this._partialBytes)), this._partialBytes = 0;
            }
            this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), $w(this._inBlock);
          };
          bt.gcm.prototype.decrypt = function(t, e, r) {
            var n = t.length();
            if (n < this.blockSize && !(r && n > 0))
              return true;
            this.cipher.encrypt(this._inBlock, this._outBlock), $w(this._inBlock), this._hashBlock[0] = t.getInt32(), this._hashBlock[1] = t.getInt32(), this._hashBlock[2] = t.getInt32(), this._hashBlock[3] = t.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
            for (var i2 = 0; i2 < this._ints; ++i2)
              e.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
            n < this.blockSize ? this._cipherLength += n % this.blockSize : this._cipherLength += this.blockSize;
          };
          bt.gcm.prototype.afterFinish = function(t, e) {
            var r = true;
            e.decrypt && e.overflow && t.truncate(this.blockSize - e.overflow), this.tag = qn.util.createBuffer();
            var n = this._aDataLength.concat(gx(this._cipherLength * 8));
            this._s = this.ghash(this._hashSubkey, this._s, n);
            var i2 = [];
            this.cipher.encrypt(this._j0, i2);
            for (var o = 0; o < this._ints; ++o)
              this.tag.putInt32(this._s[o] ^ i2[o]);
            return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), e.decrypt && this.tag.bytes() !== this._tag && (r = false), r;
          };
          bt.gcm.prototype.multiply = function(t, e) {
            for (var r = [0, 0, 0, 0], n = e.slice(0), i2 = 0; i2 < 128; ++i2) {
              var o = t[i2 / 32 | 0] & 1 << 31 - i2 % 32;
              o && (r[0] ^= n[0], r[1] ^= n[1], r[2] ^= n[2], r[3] ^= n[3]), this.pow(n, n);
            }
            return r;
          };
          bt.gcm.prototype.pow = function(t, e) {
            for (var r = t[3] & 1, n = 3; n > 0; --n)
              e[n] = t[n] >>> 1 | (t[n - 1] & 1) << 31;
            e[0] = t[0] >>> 1, r && (e[0] ^= this._R);
          };
          bt.gcm.prototype.tableMultiply = function(t) {
            for (var e = [0, 0, 0, 0], r = 0; r < 32; ++r) {
              var n = r / 8 | 0, i2 = t[n] >>> (7 - r % 8) * 4 & 15, o = this._m[r][i2];
              e[0] ^= o[0], e[1] ^= o[1], e[2] ^= o[2], e[3] ^= o[3];
            }
            return e;
          };
          bt.gcm.prototype.ghash = function(t, e, r) {
            return e[0] ^= r[0], e[1] ^= r[1], e[2] ^= r[2], e[3] ^= r[3], this.tableMultiply(e);
          };
          bt.gcm.prototype.generateHashTable = function(t, e) {
            for (var r = 8 / e, n = 4 * r, i2 = 16 * r, o = new Array(i2), s = 0; s < i2; ++s) {
              var a = [0, 0, 0, 0], u = s / n | 0, l = (n - 1 - s % n) * e;
              a[u] = 1 << e - 1 << l, o[s] = this.generateSubHashTable(this.multiply(a, t), e);
            }
            return o;
          };
          bt.gcm.prototype.generateSubHashTable = function(t, e) {
            var r = 1 << e, n = r >>> 1, i2 = new Array(r);
            i2[n] = t.slice(0);
            for (var o = n >>> 1; o > 0; )
              this.pow(i2[2 * o], i2[o] = []), o >>= 1;
            for (o = 2; o < n; ) {
              for (var s = 1; s < o; ++s) {
                var a = i2[o], u = i2[s];
                i2[o + s] = [a[0] ^ u[0], a[1] ^ u[1], a[2] ^ u[2], a[3] ^ u[3]];
              }
              o *= 2;
            }
            for (i2[0] = [0, 0, 0, 0], o = n + 1; o < r; ++o) {
              var l = i2[o ^ n];
              i2[o] = [t[0] ^ l[0], t[1] ^ l[1], t[2] ^ l[2], t[3] ^ l[3]];
            }
            return i2;
          };
          function Hw(t, e) {
            if (typeof t == "string" && (t = qn.util.createBuffer(t)), qn.util.isArray(t) && t.length > 4) {
              var r = t;
              t = qn.util.createBuffer();
              for (var n = 0; n < r.length; ++n)
                t.putByte(r[n]);
            }
            if (t.length() < e)
              throw new Error("Invalid IV length; got " + t.length() + " bytes and expected " + e + " bytes.");
            if (!qn.util.isArray(t)) {
              for (var i2 = [], o = e / 4, n = 0; n < o; ++n)
                i2.push(t.getInt32());
              t = i2;
            }
            return t;
          }
          function $w(t) {
            t[t.length - 1] = t[t.length - 1] + 1 & 4294967295;
          }
          function gx(t) {
            return [t / 4294967296 | 0, t & 4294967295];
          }
        });
        var jp = A((Lqe, gK) => {
          c();
          var Sr = st();
          yx();
          wx();
          gr();
          gK.exports = Sr.aes = Sr.aes || {};
          Sr.aes.startEncrypting = function(t, e, r, n) {
            var i2 = Gw({ key: t, output: r, decrypt: false, mode: n });
            return i2.start(e), i2;
          };
          Sr.aes.createEncryptionCipher = function(t, e) {
            return Gw({ key: t, output: null, decrypt: false, mode: e });
          };
          Sr.aes.startDecrypting = function(t, e, r, n) {
            var i2 = Gw({ key: t, output: r, decrypt: true, mode: n });
            return i2.start(e), i2;
          };
          Sr.aes.createDecryptionCipher = function(t, e) {
            return Gw({ key: t, output: null, decrypt: true, mode: e });
          };
          Sr.aes.Algorithm = function(t, e) {
            _x || mK();
            var r = this;
            r.name = t, r.mode = new e({ blockSize: 16, cipher: { encrypt: function(n, i2) {
              return bx(r._w, n, i2, false);
            }, decrypt: function(n, i2) {
              return bx(r._w, n, i2, true);
            } } }), r._init = false;
          };
          Sr.aes.Algorithm.prototype.initialize = function(t) {
            if (!this._init) {
              var e = t.key, r;
              if (typeof e == "string" && (e.length === 16 || e.length === 24 || e.length === 32))
                e = Sr.util.createBuffer(e);
              else if (Sr.util.isArray(e) && (e.length === 16 || e.length === 24 || e.length === 32)) {
                r = e, e = Sr.util.createBuffer();
                for (var n = 0; n < r.length; ++n)
                  e.putByte(r[n]);
              }
              if (!Sr.util.isArray(e)) {
                r = e, e = [];
                var i2 = r.length();
                if (i2 === 16 || i2 === 24 || i2 === 32) {
                  i2 = i2 >>> 2;
                  for (var n = 0; n < i2; ++n)
                    e.push(r.getInt32());
                }
              }
              if (!Sr.util.isArray(e) || !(e.length === 4 || e.length === 6 || e.length === 8))
                throw new Error("Invalid key parameter.");
              var o = this.mode.name, s = ["CFB", "OFB", "CTR", "GCM"].indexOf(o) !== -1;
              this._w = yK(e, t.decrypt && !s), this._init = true;
            }
          };
          Sr.aes._expandKey = function(t, e) {
            return _x || mK(), yK(t, e);
          };
          Sr.aes._updateBlock = bx;
          Wp("AES-ECB", Sr.cipher.modes.ecb);
          Wp("AES-CBC", Sr.cipher.modes.cbc);
          Wp("AES-CFB", Sr.cipher.modes.cfb);
          Wp("AES-OFB", Sr.cipher.modes.ofb);
          Wp("AES-CTR", Sr.cipher.modes.ctr);
          Wp("AES-GCM", Sr.cipher.modes.gcm);
          function Wp(t, e) {
            var r = function() {
              return new Sr.aes.Algorithm(t, e);
            };
            Sr.cipher.registerAlgorithm(t, r);
          }
          var _x = false, Gp = 4, Ri, Ex, pK, th, Bs;
          function mK() {
            _x = true, pK = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
            for (var t = new Array(256), e = 0; e < 128; ++e)
              t[e] = e << 1, t[e + 128] = e + 128 << 1 ^ 283;
            Ri = new Array(256), Ex = new Array(256), th = new Array(4), Bs = new Array(4);
            for (var e = 0; e < 4; ++e)
              th[e] = new Array(256), Bs[e] = new Array(256);
            for (var r = 0, n = 0, i2, o, s, a, u, l, f, e = 0; e < 256; ++e) {
              a = n ^ n << 1 ^ n << 2 ^ n << 3 ^ n << 4, a = a >> 8 ^ a & 255 ^ 99, Ri[r] = a, Ex[a] = r, u = t[a], i2 = t[r], o = t[i2], s = t[o], l = u << 24 ^ a << 16 ^ a << 8 ^ (a ^ u), f = (i2 ^ o ^ s) << 24 ^ (r ^ s) << 16 ^ (r ^ o ^ s) << 8 ^ (r ^ i2 ^ s);
              for (var h = 0; h < 4; ++h)
                th[h][r] = l, Bs[h][a] = f, l = l << 24 | l >>> 8, f = f << 24 | f >>> 8;
              r === 0 ? r = n = 1 : (r = i2 ^ t[t[t[i2 ^ s]]], n ^= t[t[n]]);
            }
          }
          function yK(t, e) {
            for (var r = t.slice(0), n, i2 = 1, o = r.length, s = o + 6 + 1, a = Gp * s, u = o; u < a; ++u)
              n = r[u - 1], u % o === 0 ? (n = Ri[n >>> 16 & 255] << 24 ^ Ri[n >>> 8 & 255] << 16 ^ Ri[n & 255] << 8 ^ Ri[n >>> 24] ^ pK[i2] << 24, i2++) : o > 6 && u % o === 4 && (n = Ri[n >>> 24] << 24 ^ Ri[n >>> 16 & 255] << 16 ^ Ri[n >>> 8 & 255] << 8 ^ Ri[n & 255]), r[u] = r[u - o] ^ n;
            if (e) {
              var l, f = Bs[0], h = Bs[1], p = Bs[2], d = Bs[3], m = r.slice(0);
              a = r.length;
              for (var u = 0, y = a - Gp; u < a; u += Gp, y -= Gp)
                if (u === 0 || u === a - Gp)
                  m[u] = r[y], m[u + 1] = r[y + 3], m[u + 2] = r[y + 2], m[u + 3] = r[y + 1];
                else
                  for (var g = 0; g < Gp; ++g)
                    l = r[y + g], m[u + (3 & -g)] = f[Ri[l >>> 24]] ^ h[Ri[l >>> 16 & 255]] ^ p[Ri[l >>> 8 & 255]] ^ d[Ri[l & 255]];
              r = m;
            }
            return r;
          }
          function bx(t, e, r, n) {
            var i2 = t.length / 4 - 1, o, s, a, u, l;
            n ? (o = Bs[0], s = Bs[1], a = Bs[2], u = Bs[3], l = Ex) : (o = th[0], s = th[1], a = th[2], u = th[3], l = Ri);
            var f, h, p, d, m, y, g;
            f = e[0] ^ t[0], h = e[n ? 3 : 1] ^ t[1], p = e[2] ^ t[2], d = e[n ? 1 : 3] ^ t[3];
            for (var E = 3, b = 1; b < i2; ++b)
              m = o[f >>> 24] ^ s[h >>> 16 & 255] ^ a[p >>> 8 & 255] ^ u[d & 255] ^ t[++E], y = o[h >>> 24] ^ s[p >>> 16 & 255] ^ a[d >>> 8 & 255] ^ u[f & 255] ^ t[++E], g = o[p >>> 24] ^ s[d >>> 16 & 255] ^ a[f >>> 8 & 255] ^ u[h & 255] ^ t[++E], d = o[d >>> 24] ^ s[f >>> 16 & 255] ^ a[h >>> 8 & 255] ^ u[p & 255] ^ t[++E], f = m, h = y, p = g;
            r[0] = l[f >>> 24] << 24 ^ l[h >>> 16 & 255] << 16 ^ l[p >>> 8 & 255] << 8 ^ l[d & 255] ^ t[++E], r[n ? 3 : 1] = l[h >>> 24] << 24 ^ l[p >>> 16 & 255] << 16 ^ l[d >>> 8 & 255] << 8 ^ l[f & 255] ^ t[++E], r[2] = l[p >>> 24] << 24 ^ l[d >>> 16 & 255] << 16 ^ l[f >>> 8 & 255] << 8 ^ l[h & 255] ^ t[++E], r[n ? 1 : 3] = l[d >>> 24] << 24 ^ l[f >>> 16 & 255] << 16 ^ l[h >>> 8 & 255] << 8 ^ l[p & 255] ^ t[++E];
          }
          function Gw(t) {
            t = t || {};
            var e = (t.mode || "CBC").toUpperCase(), r = "AES-" + e, n;
            t.decrypt ? n = Sr.cipher.createDecipher(r, t.key) : n = Sr.cipher.createCipher(r, t.key);
            var i2 = n.start;
            return n.start = function(o, s) {
              var a = null;
              s instanceof Sr.util.ByteBuffer && (a = s, s = {}), s = s || {}, s.output = a, s.iv = o, i2.call(n, s);
            }, n;
          }
        });
        var jw = A((Bqe, EK) => {
          c();
          var Nr = st();
          yx();
          wx();
          gr();
          EK.exports = Nr.des = Nr.des || {};
          Nr.des.startEncrypting = function(t, e, r, n) {
            var i2 = Ww({ key: t, output: r, decrypt: false, mode: n || (e === null ? "ECB" : "CBC") });
            return i2.start(e), i2;
          };
          Nr.des.createEncryptionCipher = function(t, e) {
            return Ww({ key: t, output: null, decrypt: false, mode: e });
          };
          Nr.des.startDecrypting = function(t, e, r, n) {
            var i2 = Ww({ key: t, output: r, decrypt: true, mode: n || (e === null ? "ECB" : "CBC") });
            return i2.start(e), i2;
          };
          Nr.des.createDecryptionCipher = function(t, e) {
            return Ww({ key: t, output: null, decrypt: true, mode: e });
          };
          Nr.des.Algorithm = function(t, e) {
            var r = this;
            r.name = t, r.mode = new e({ blockSize: 8, cipher: { encrypt: function(n, i2) {
              return wK(r._keys, n, i2, false);
            }, decrypt: function(n, i2) {
              return wK(r._keys, n, i2, true);
            } } }), r._init = false;
          };
          Nr.des.Algorithm.prototype.initialize = function(t) {
            if (!this._init) {
              var e = Nr.util.createBuffer(t.key);
              if (this.name.indexOf("3DES") === 0 && e.length() !== 24)
                throw new Error("Invalid Triple-DES key size: " + e.length() * 8);
              this._keys = b3e(e), this._init = true;
            }
          };
          Ta("DES-ECB", Nr.cipher.modes.ecb);
          Ta("DES-CBC", Nr.cipher.modes.cbc);
          Ta("DES-CFB", Nr.cipher.modes.cfb);
          Ta("DES-OFB", Nr.cipher.modes.ofb);
          Ta("DES-CTR", Nr.cipher.modes.ctr);
          Ta("3DES-ECB", Nr.cipher.modes.ecb);
          Ta("3DES-CBC", Nr.cipher.modes.cbc);
          Ta("3DES-CFB", Nr.cipher.modes.cfb);
          Ta("3DES-OFB", Nr.cipher.modes.ofb);
          Ta("3DES-CTR", Nr.cipher.modes.ctr);
          function Ta(t, e) {
            var r = function() {
              return new Nr.des.Algorithm(t, e);
            };
            Nr.cipher.registerAlgorithm(t, r);
          }
          var h3e = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], d3e = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], p3e = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], m3e = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], y3e = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], g3e = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], w3e = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], E3e = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
          function b3e(t) {
            for (var e = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], r = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], n = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], i2 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], o = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], s = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], a = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], u = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], l = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], f = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], h = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], p = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], d = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], m = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], y = t.length() > 8 ? 3 : 1, g = [], E = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], b = 0, v, S = 0; S < y; S++) {
              var x = t.getInt32(), T = t.getInt32();
              v = (x >>> 4 ^ T) & 252645135, T ^= v, x ^= v << 4, v = (T >>> -16 ^ x) & 65535, x ^= v, T ^= v << -16, v = (x >>> 2 ^ T) & 858993459, T ^= v, x ^= v << 2, v = (T >>> -16 ^ x) & 65535, x ^= v, T ^= v << -16, v = (x >>> 1 ^ T) & 1431655765, T ^= v, x ^= v << 1, v = (T >>> 8 ^ x) & 16711935, x ^= v, T ^= v << 8, v = (x >>> 1 ^ T) & 1431655765, T ^= v, x ^= v << 1, v = x << 8 | T >>> 20 & 240, x = T << 24 | T << 8 & 16711680 | T >>> 8 & 65280 | T >>> 24 & 240, T = v;
              for (var R = 0; R < E.length; ++R) {
                E[R] ? (x = x << 2 | x >>> 26, T = T << 2 | T >>> 26) : (x = x << 1 | x >>> 27, T = T << 1 | T >>> 27), x &= -15, T &= -15;
                var O = e[x >>> 28] | r[x >>> 24 & 15] | n[x >>> 20 & 15] | i2[x >>> 16 & 15] | o[x >>> 12 & 15] | s[x >>> 8 & 15] | a[x >>> 4 & 15], F = u[T >>> 28] | l[T >>> 24 & 15] | f[T >>> 20 & 15] | h[T >>> 16 & 15] | p[T >>> 12 & 15] | d[T >>> 8 & 15] | m[T >>> 4 & 15];
                v = (F >>> 16 ^ O) & 65535, g[b++] = O ^ v, g[b++] = F ^ v << 16;
              }
            }
            return g;
          }
          function wK(t, e, r, n) {
            var i2 = t.length === 32 ? 3 : 9, o;
            i2 === 3 ? o = n ? [30, -2, -2] : [0, 32, 2] : o = n ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
            var s, a = e[0], u = e[1];
            s = (a >>> 4 ^ u) & 252645135, u ^= s, a ^= s << 4, s = (a >>> 16 ^ u) & 65535, u ^= s, a ^= s << 16, s = (u >>> 2 ^ a) & 858993459, a ^= s, u ^= s << 2, s = (u >>> 8 ^ a) & 16711935, a ^= s, u ^= s << 8, s = (a >>> 1 ^ u) & 1431655765, u ^= s, a ^= s << 1, a = a << 1 | a >>> 31, u = u << 1 | u >>> 31;
            for (var l = 0; l < i2; l += 3) {
              for (var f = o[l + 1], h = o[l + 2], p = o[l]; p != f; p += h) {
                var d = u ^ t[p], m = (u >>> 4 | u << 28) ^ t[p + 1];
                s = a, a = u, u = s ^ (d3e[d >>> 24 & 63] | m3e[d >>> 16 & 63] | g3e[d >>> 8 & 63] | E3e[d & 63] | h3e[m >>> 24 & 63] | p3e[m >>> 16 & 63] | y3e[m >>> 8 & 63] | w3e[m & 63]);
              }
              s = a, a = u, u = s;
            }
            a = a >>> 1 | a << 31, u = u >>> 1 | u << 31, s = (a >>> 1 ^ u) & 1431655765, u ^= s, a ^= s << 1, s = (u >>> 8 ^ a) & 16711935, a ^= s, u ^= s << 8, s = (u >>> 2 ^ a) & 858993459, a ^= s, u ^= s << 2, s = (a >>> 16 ^ u) & 65535, u ^= s, a ^= s << 16, s = (a >>> 4 ^ u) & 252645135, u ^= s, a ^= s << 4, r[0] = a, r[1] = u;
          }
          function Ww(t) {
            t = t || {};
            var e = (t.mode || "CBC").toUpperCase(), r = "DES-" + e, n;
            t.decrypt ? n = Nr.cipher.createDecipher(r, t.key) : n = Nr.cipher.createCipher(r, t.key);
            var i2 = n.start;
            return n.start = function(o, s) {
              var a = null;
              s instanceof Nr.util.ByteBuffer && (a = s, s = {}), s = s || {}, s.output = a, s.iv = o, i2.call(n, s);
            }, n;
          }
        });
        var sl = A((Mqe, bK) => {
          c();
          var Yw = st();
          bK.exports = Yw.md = Yw.md || {};
          Yw.md.algorithms = Yw.md.algorithms || {};
        });
        var vK = A((Uqe, _K) => {
          c();
          var Dc = st();
          sl();
          gr();
          var _3e = _K.exports = Dc.hmac = Dc.hmac || {};
          _3e.create = function() {
            var t = null, e = null, r = null, n = null, i2 = {};
            return i2.start = function(o, s) {
              if (o !== null)
                if (typeof o == "string")
                  if (o = o.toLowerCase(), o in Dc.md.algorithms)
                    e = Dc.md.algorithms[o].create();
                  else
                    throw new Error('Unknown hash algorithm "' + o + '"');
                else
                  e = o;
              if (s === null)
                s = t;
              else {
                if (typeof s == "string")
                  s = Dc.util.createBuffer(s);
                else if (Dc.util.isArray(s)) {
                  var a = s;
                  s = Dc.util.createBuffer();
                  for (var u = 0; u < a.length; ++u)
                    s.putByte(a[u]);
                }
                var l = s.length();
                l > e.blockLength && (e.start(), e.update(s.bytes()), s = e.digest()), r = Dc.util.createBuffer(), n = Dc.util.createBuffer(), l = s.length();
                for (var u = 0; u < l; ++u) {
                  var a = s.at(u);
                  r.putByte(54 ^ a), n.putByte(92 ^ a);
                }
                if (l < e.blockLength)
                  for (var a = e.blockLength - l, u = 0; u < a; ++u)
                    r.putByte(54), n.putByte(92);
                t = s, r = r.bytes(), n = n.bytes();
              }
              e.start(), e.update(r);
            }, i2.update = function(o) {
              e.update(o);
            }, i2.getMac = function() {
              var o = e.digest().bytes();
              return e.start(), e.update(n), e.update(o), e.digest();
            }, i2.digest = i2.getMac, i2;
          };
        });
        var rh = A(() => {
          c();
        });
        var vx = A((Vqe, SK) => {
          c();
          var Ai = st();
          vK();
          sl();
          gr();
          var v3e = Ai.pkcs5 = Ai.pkcs5 || {}, kc;
          Ai.util.isNodejs && !Ai.options.usePureJavaScript && (kc = rh());
          SK.exports = Ai.pbkdf2 = v3e.pbkdf2 = function(t, e, r, n, i2, o) {
            if (typeof i2 == "function" && (o = i2, i2 = null), Ai.util.isNodejs && !Ai.options.usePureJavaScript && kc.pbkdf2 && (i2 === null || typeof i2 != "object") && (kc.pbkdf2Sync.length > 4 || !i2 || i2 === "sha1"))
              return typeof i2 != "string" && (i2 = "sha1"), t = Buffer.from(t, "binary"), e = Buffer.from(e, "binary"), o ? kc.pbkdf2Sync.length === 4 ? kc.pbkdf2(t, e, r, n, function(v, S) {
                if (v)
                  return o(v);
                o(null, S.toString("binary"));
              }) : kc.pbkdf2(t, e, r, n, i2, function(v, S) {
                if (v)
                  return o(v);
                o(null, S.toString("binary"));
              }) : kc.pbkdf2Sync.length === 4 ? kc.pbkdf2Sync(t, e, r, n).toString("binary") : kc.pbkdf2Sync(t, e, r, n, i2).toString("binary");
            if ((typeof i2 > "u" || i2 === null) && (i2 = "sha1"), typeof i2 == "string") {
              if (!(i2 in Ai.md.algorithms))
                throw new Error("Unknown hash algorithm: " + i2);
              i2 = Ai.md[i2].create();
            }
            var s = i2.digestLength;
            if (n > 4294967295 * s) {
              var a = new Error("Derived key is too long.");
              if (o)
                return o(a);
              throw a;
            }
            var u = Math.ceil(n / s), l = n - (u - 1) * s, f = Ai.hmac.create();
            f.start(i2, t);
            var h = "", p, d, m;
            if (!o) {
              for (var y = 1; y <= u; ++y) {
                f.start(null, null), f.update(e), f.update(Ai.util.int32ToBytes(y)), p = m = f.digest().getBytes();
                for (var g = 2; g <= r; ++g)
                  f.start(null, null), f.update(m), d = f.digest().getBytes(), p = Ai.util.xorBytes(p, d, s), m = d;
                h += y < u ? p : p.substr(0, l);
              }
              return h;
            }
            var y = 1, g;
            function E() {
              if (y > u)
                return o(null, h);
              f.start(null, null), f.update(e), f.update(Ai.util.int32ToBytes(y)), p = m = f.digest().getBytes(), g = 2, b();
            }
            function b() {
              if (g <= r)
                return f.start(null, null), f.update(m), d = f.digest().getBytes(), p = Ai.util.xorBytes(p, d, s), m = d, ++g, Ai.util.setImmediate(b);
              h += y < u ? p : p.substr(0, l), ++y, E();
            }
            E();
          };
        });
        var Zw = A((qqe, RK) => {
          c();
          var Xw = st();
          gr();
          var xK = RK.exports = Xw.pem = Xw.pem || {};
          xK.encode = function(t, e) {
            e = e || {};
            var r = "-----BEGIN " + t.type + `-----\r
`, n;
            if (t.procType && (n = { name: "Proc-Type", values: [String(t.procType.version), t.procType.type] }, r += Qw(n)), t.contentDomain && (n = { name: "Content-Domain", values: [t.contentDomain] }, r += Qw(n)), t.dekInfo && (n = { name: "DEK-Info", values: [t.dekInfo.algorithm] }, t.dekInfo.parameters && n.values.push(t.dekInfo.parameters), r += Qw(n)), t.headers)
              for (var i2 = 0; i2 < t.headers.length; ++i2)
                r += Qw(t.headers[i2]);
            return t.procType && (r += `\r
`), r += Xw.util.encode64(t.body, e.maxline || 64) + `\r
`, r += "-----END " + t.type + `-----\r
`, r;
          };
          xK.decode = function(t) {
            for (var e = [], r = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, n = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, i2 = /\r?\n/, o; o = r.exec(t), !!o; ) {
              var s = o[1];
              s === "NEW CERTIFICATE REQUEST" && (s = "CERTIFICATE REQUEST");
              var a = { type: s, procType: null, contentDomain: null, dekInfo: null, headers: [], body: Xw.util.decode64(o[3]) };
              if (e.push(a), !!o[2]) {
                for (var u = o[2].split(i2), l = 0; o && l < u.length; ) {
                  for (var f = u[l].replace(/\s+$/, ""), h = l + 1; h < u.length; ++h) {
                    var p = u[h];
                    if (!/\s/.test(p[0]))
                      break;
                    f += p, l = h;
                  }
                  if (o = f.match(n), o) {
                    for (var d = { name: o[1], values: [] }, m = o[2].split(","), y = 0; y < m.length; ++y)
                      d.values.push(S3e(m[y]));
                    if (a.procType)
                      if (!a.contentDomain && d.name === "Content-Domain")
                        a.contentDomain = m[0] || "";
                      else if (!a.dekInfo && d.name === "DEK-Info") {
                        if (d.values.length === 0)
                          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                        a.dekInfo = { algorithm: m[0], parameters: m[1] || null };
                      } else
                        a.headers.push(d);
                    else {
                      if (d.name !== "Proc-Type")
                        throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                      if (d.values.length !== 2)
                        throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                      a.procType = { version: m[0], type: m[1] };
                    }
                  }
                  ++l;
                }
                if (a.procType === "ENCRYPTED" && !a.dekInfo)
                  throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
              }
            }
            if (e.length === 0)
              throw new Error("Invalid PEM formatted message.");
            return e;
          };
          function Qw(t) {
            for (var e = t.name + ": ", r = [], n = function(u, l) {
              return " " + l;
            }, i2 = 0; i2 < t.values.length; ++i2)
              r.push(t.values[i2].replace(/^(\S+\r\n)/, n));
            e += r.join(",") + `\r
`;
            for (var o = 0, s = -1, i2 = 0; i2 < e.length; ++i2, ++o)
              if (o > 65 && s !== -1) {
                var a = e[s];
                a === "," ? (++s, e = e.substr(0, s) + `\r
 ` + e.substr(s)) : e = e.substr(0, s) + `\r
` + a + e.substr(s + 1), o = i2 - s - 1, s = -1, ++i2;
              } else
                (e[i2] === " " || e[i2] === "	" || e[i2] === ",") && (s = i2);
            return e;
          }
          function S3e(t) {
            return t.replace(/^\s+/, "");
          }
        });
        var DK = A((zqe, PK) => {
          c();
          var Ia = st();
          sl();
          gr();
          var TK = PK.exports = Ia.sha256 = Ia.sha256 || {};
          Ia.md.sha256 = Ia.md.algorithms.sha256 = TK;
          TK.create = function() {
            IK || x3e();
            var t = null, e = Ia.util.createBuffer(), r = new Array(64), n = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 };
            return n.start = function() {
              n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
              for (var i2 = n.messageLengthSize / 4, o = 0; o < i2; ++o)
                n.fullMessageLength.push(0);
              return e = Ia.util.createBuffer(), t = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }, n;
            }, n.start(), n.update = function(i2, o) {
              o === "utf8" && (i2 = Ia.util.encodeUtf8(i2));
              var s = i2.length;
              n.messageLength += s, s = [s / 4294967296 >>> 0, s >>> 0];
              for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
                n.fullMessageLength[a] += s[1], s[1] = s[0] + (n.fullMessageLength[a] / 4294967296 >>> 0), n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0, s[0] = s[1] / 4294967296 >>> 0;
              return e.putBytes(i2), AK(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n;
            }, n.digest = function() {
              var i2 = Ia.util.createBuffer();
              i2.putBytes(e.bytes());
              var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, s = o & n.blockLength - 1;
              i2.putBytes(Sx.substr(0, n.blockLength - s));
              for (var a, u, l = n.fullMessageLength[0] * 8, f = 0; f < n.fullMessageLength.length - 1; ++f)
                a = n.fullMessageLength[f + 1] * 8, u = a / 4294967296 >>> 0, l += u, i2.putInt32(l >>> 0), l = a >>> 0;
              i2.putInt32(l);
              var h = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3, h4: t.h4, h5: t.h5, h6: t.h6, h7: t.h7 };
              AK(h, r, i2);
              var p = Ia.util.createBuffer();
              return p.putInt32(h.h0), p.putInt32(h.h1), p.putInt32(h.h2), p.putInt32(h.h3), p.putInt32(h.h4), p.putInt32(h.h5), p.putInt32(h.h6), p.putInt32(h.h7), p;
            }, n;
          };
          var Sx = null, IK = false, CK = null;
          function x3e() {
            Sx = String.fromCharCode(128), Sx += Ia.util.fillString(String.fromCharCode(0), 64), CK = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], IK = true;
          }
          function AK(t, e, r) {
            for (var n, i2, o, s, a, u, l, f, h, p, d, m, y, g, E, b = r.length(); b >= 64; ) {
              for (l = 0; l < 16; ++l)
                e[l] = r.getInt32();
              for (; l < 64; ++l)
                n = e[l - 2], n = (n >>> 17 | n << 15) ^ (n >>> 19 | n << 13) ^ n >>> 10, i2 = e[l - 15], i2 = (i2 >>> 7 | i2 << 25) ^ (i2 >>> 18 | i2 << 14) ^ i2 >>> 3, e[l] = n + e[l - 7] + i2 + e[l - 16] | 0;
              for (f = t.h0, h = t.h1, p = t.h2, d = t.h3, m = t.h4, y = t.h5, g = t.h6, E = t.h7, l = 0; l < 64; ++l)
                s = (m >>> 6 | m << 26) ^ (m >>> 11 | m << 21) ^ (m >>> 25 | m << 7), a = g ^ m & (y ^ g), o = (f >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), u = f & h | p & (f ^ h), n = E + s + a + CK[l] + e[l], i2 = o + u, E = g, g = y, y = m, m = d + n >>> 0, d = p, p = h, h = f, f = n + i2 >>> 0;
              t.h0 = t.h0 + f | 0, t.h1 = t.h1 + h | 0, t.h2 = t.h2 + p | 0, t.h3 = t.h3 + d | 0, t.h4 = t.h4 + m | 0, t.h5 = t.h5 + y | 0, t.h6 = t.h6 + g | 0, t.h7 = t.h7 + E | 0, b -= 64;
            }
          }
        });
        var NK = A((Hqe, kK) => {
          c();
          var Ca = st();
          gr();
          var Jw = null;
          Ca.util.isNodejs && !Ca.options.usePureJavaScript && !process.versions["node-webkit"] && (Jw = rh());
          var R3e = kK.exports = Ca.prng = Ca.prng || {};
          R3e.create = function(t) {
            for (var e = { plugin: t, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: "" }, r = t.md, n = new Array(32), i2 = 0; i2 < 32; ++i2)
              n[i2] = r.create();
            e.pools = n, e.pool = 0, e.generate = function(l, f) {
              if (!f)
                return e.generateSync(l);
              var h = e.plugin.cipher, p = e.plugin.increment, d = e.plugin.formatKey, m = e.plugin.formatSeed, y = Ca.util.createBuffer();
              e.key = null, g();
              function g(E) {
                if (E)
                  return f(E);
                if (y.length() >= l)
                  return f(null, y.getBytes(l));
                if (e.generated > 1048575 && (e.key = null), e.key === null)
                  return Ca.util.nextTick(function() {
                    o(g);
                  });
                var b = h(e.key, e.seed);
                e.generated += b.length, y.putBytes(b), e.key = d(h(e.key, p(e.seed))), e.seed = m(h(e.key, e.seed)), Ca.util.setImmediate(g);
              }
            }, e.generateSync = function(l) {
              var f = e.plugin.cipher, h = e.plugin.increment, p = e.plugin.formatKey, d = e.plugin.formatSeed;
              e.key = null;
              for (var m = Ca.util.createBuffer(); m.length() < l; ) {
                e.generated > 1048575 && (e.key = null), e.key === null && s();
                var y = f(e.key, e.seed);
                e.generated += y.length, m.putBytes(y), e.key = p(f(e.key, h(e.seed))), e.seed = d(f(e.key, e.seed));
              }
              return m.getBytes(l);
            };
            function o(l) {
              if (e.pools[0].messageLength >= 32)
                return a(), l();
              var f = 32 - e.pools[0].messageLength << 5;
              e.seedFile(f, function(h, p) {
                if (h)
                  return l(h);
                e.collect(p), a(), l();
              });
            }
            function s() {
              if (e.pools[0].messageLength >= 32)
                return a();
              var l = 32 - e.pools[0].messageLength << 5;
              e.collect(e.seedFileSync(l)), a();
            }
            function a() {
              e.reseeds = e.reseeds === 4294967295 ? 0 : e.reseeds + 1;
              var l = e.plugin.md.create();
              l.update(e.keyBytes);
              for (var f = 1, h = 0; h < 32; ++h)
                e.reseeds % f === 0 && (l.update(e.pools[h].digest().getBytes()), e.pools[h].start()), f = f << 1;
              e.keyBytes = l.digest().getBytes(), l.start(), l.update(e.keyBytes);
              var p = l.digest().getBytes();
              e.key = e.plugin.formatKey(e.keyBytes), e.seed = e.plugin.formatSeed(p), e.generated = 0;
            }
            function u(l) {
              var f = null, h = Ca.util.globalScope, p = h.crypto || h.msCrypto;
              p && p.getRandomValues && (f = function(x) {
                return p.getRandomValues(x);
              });
              var d = Ca.util.createBuffer();
              if (f)
                for (; d.length() < l; ) {
                  var m = Math.max(1, Math.min(l - d.length(), 65536) / 4), y = new Uint32Array(Math.floor(m));
                  try {
                    f(y);
                    for (var g = 0; g < y.length; ++g)
                      d.putInt32(y[g]);
                  } catch (x) {
                    if (!(typeof QuotaExceededError < "u" && x instanceof QuotaExceededError))
                      throw x;
                  }
                }
              if (d.length() < l)
                for (var E, b, v, S = Math.floor(Math.random() * 65536); d.length() < l; ) {
                  b = 16807 * (S & 65535), E = 16807 * (S >> 16), b += (E & 32767) << 16, b += E >> 15, b = (b & 2147483647) + (b >> 31), S = b & 4294967295;
                  for (var g = 0; g < 3; ++g)
                    v = S >>> (g << 3), v ^= Math.floor(Math.random() * 256), d.putByte(v & 255);
                }
              return d.getBytes(l);
            }
            return Jw ? (e.seedFile = function(l, f) {
              Jw.randomBytes(l, function(h, p) {
                if (h)
                  return f(h);
                f(null, p.toString());
              });
            }, e.seedFileSync = function(l) {
              return Jw.randomBytes(l).toString();
            }) : (e.seedFile = function(l, f) {
              try {
                f(null, u(l));
              } catch (h) {
                f(h);
              }
            }, e.seedFileSync = u), e.collect = function(l) {
              for (var f = l.length, h = 0; h < f; ++h)
                e.pools[e.pool].update(l.substr(h, 1)), e.pool = e.pool === 31 ? 0 : e.pool + 1;
            }, e.collectInt = function(l, f) {
              for (var h = "", p = 0; p < f; p += 8)
                h += String.fromCharCode(l >> p & 255);
              e.collect(h);
            }, e.registerWorker = function(l) {
              if (l === self)
                e.seedFile = function(h, p) {
                  function d(m) {
                    var y = m.data;
                    y.forge && y.forge.prng && (self.removeEventListener("message", d), p(y.forge.prng.err, y.forge.prng.bytes));
                  }
                  self.addEventListener("message", d), self.postMessage({ forge: { prng: { needed: h } } });
                };
              else {
                var f = function(h) {
                  var p = h.data;
                  p.forge && p.forge.prng && e.seedFile(p.forge.prng.needed, function(d, m) {
                    l.postMessage({ forge: { prng: { err: d, bytes: m } } });
                  });
                };
                l.addEventListener("message", f);
              }
            }, e;
          };
        });
        var nh = A(($qe, xx) => {
          c();
          var zn = st();
          jp();
          DK();
          NK();
          gr();
          (function() {
            if (zn.random && zn.random.getBytes) {
              xx.exports = zn.random;
              return;
            }
            (function(t) {
              var e = {}, r = new Array(4), n = zn.util.createBuffer();
              e.formatKey = function(h) {
                var p = zn.util.createBuffer(h);
                return h = new Array(4), h[0] = p.getInt32(), h[1] = p.getInt32(), h[2] = p.getInt32(), h[3] = p.getInt32(), zn.aes._expandKey(h, false);
              }, e.formatSeed = function(h) {
                var p = zn.util.createBuffer(h);
                return h = new Array(4), h[0] = p.getInt32(), h[1] = p.getInt32(), h[2] = p.getInt32(), h[3] = p.getInt32(), h;
              }, e.cipher = function(h, p) {
                return zn.aes._updateBlock(h, p, r, false), n.putInt32(r[0]), n.putInt32(r[1]), n.putInt32(r[2]), n.putInt32(r[3]), n.getBytes();
              }, e.increment = function(h) {
                return ++h[3], h;
              }, e.md = zn.md.sha256;
              function i2() {
                var h = zn.prng.create(e);
                return h.getBytes = function(p, d) {
                  return h.generate(p, d);
                }, h.getBytesSync = function(p) {
                  return h.generate(p);
                }, h;
              }
              var o = i2(), s = null, a = zn.util.globalScope, u = a.crypto || a.msCrypto;
              if (u && u.getRandomValues && (s = function(h) {
                return u.getRandomValues(h);
              }), zn.options.usePureJavaScript || !zn.util.isNodejs && !s) {
                if (typeof window > "u" || window.document, o.collectInt(+new Date(), 32), typeof navigator < "u") {
                  var l = "";
                  for (var f in navigator)
                    try {
                      typeof navigator[f] == "string" && (l += navigator[f]);
                    } catch {
                    }
                  o.collect(l), l = null;
                }
                t && (t().mousemove(function(h) {
                  o.collectInt(h.clientX, 16), o.collectInt(h.clientY, 16);
                }), t().keypress(function(h) {
                  o.collectInt(h.charCode, 8);
                }));
              }
              if (!zn.random)
                zn.random = o;
              else
                for (var f in o)
                  zn.random[f] = o[f];
              zn.random.createInstance = i2, xx.exports = zn.random;
            })(typeof jQuery < "u" ? jQuery : null);
          })();
        });
        var MK = A((Gqe, BK) => {
          c();
          var zi = st();
          gr();
          var Rx = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173], OK = [1, 2, 3, 5], A3e = function(t, e) {
            return t << e & 65535 | (t & 65535) >> 16 - e;
          }, T3e = function(t, e) {
            return (t & 65535) >> e | t << 16 - e & 65535;
          };
          BK.exports = zi.rc2 = zi.rc2 || {};
          zi.rc2.expandKey = function(t, e) {
            typeof t == "string" && (t = zi.util.createBuffer(t)), e = e || 128;
            var r = t, n = t.length(), i2 = e, o = Math.ceil(i2 / 8), s = 255 >> (i2 & 7), a;
            for (a = n; a < 128; a++)
              r.putByte(Rx[r.at(a - 1) + r.at(a - n) & 255]);
            for (r.setAt(128 - o, Rx[r.at(128 - o) & s]), a = 127 - o; a >= 0; a--)
              r.setAt(a, Rx[r.at(a + 1) ^ r.at(a + o)]);
            return r;
          };
          var LK = function(t, e, r) {
            var n = false, i2 = null, o = null, s = null, a, u, l, f, h = [];
            for (t = zi.rc2.expandKey(t, e), l = 0; l < 64; l++)
              h.push(t.getInt16Le());
            r ? (a = function(m) {
              for (l = 0; l < 4; l++)
                m[l] += h[f] + (m[(l + 3) % 4] & m[(l + 2) % 4]) + (~m[(l + 3) % 4] & m[(l + 1) % 4]), m[l] = A3e(m[l], OK[l]), f++;
            }, u = function(m) {
              for (l = 0; l < 4; l++)
                m[l] += h[m[(l + 3) % 4] & 63];
            }) : (a = function(m) {
              for (l = 3; l >= 0; l--)
                m[l] = T3e(m[l], OK[l]), m[l] -= h[f] + (m[(l + 3) % 4] & m[(l + 2) % 4]) + (~m[(l + 3) % 4] & m[(l + 1) % 4]), f--;
            }, u = function(m) {
              for (l = 3; l >= 0; l--)
                m[l] -= h[m[(l + 3) % 4] & 63];
            });
            var p = function(m) {
              var y = [];
              for (l = 0; l < 4; l++) {
                var g = i2.getInt16Le();
                s !== null && (r ? g ^= s.getInt16Le() : s.putInt16Le(g)), y.push(g & 65535);
              }
              f = r ? 0 : 63;
              for (var E = 0; E < m.length; E++)
                for (var b = 0; b < m[E][0]; b++)
                  m[E][1](y);
              for (l = 0; l < 4; l++)
                s !== null && (r ? s.putInt16Le(y[l]) : y[l] ^= s.getInt16Le()), o.putInt16Le(y[l]);
            }, d = null;
            return d = { start: function(m, y) {
              m && typeof m == "string" && (m = zi.util.createBuffer(m)), n = false, i2 = zi.util.createBuffer(), o = y || new zi.util.createBuffer(), s = m, d.output = o;
            }, update: function(m) {
              for (n || i2.putBuffer(m); i2.length() >= 8; )
                p([[5, a], [1, u], [6, a], [1, u], [5, a]]);
            }, finish: function(m) {
              var y = true;
              if (r)
                if (m)
                  y = m(8, i2, !r);
                else {
                  var g = i2.length() === 8 ? 8 : 8 - i2.length();
                  i2.fillWithByte(g, g);
                }
              if (y && (n = true, d.update()), !r && (y = i2.length() === 0, y))
                if (m)
                  y = m(8, o, !r);
                else {
                  var E = o.length(), b = o.at(E - 1);
                  b > E ? y = false : o.truncate(b);
                }
              return y;
            } }, d;
          };
          zi.rc2.startEncrypting = function(t, e, r) {
            var n = zi.rc2.createEncryptionCipher(t, 128);
            return n.start(e, r), n;
          };
          zi.rc2.createEncryptionCipher = function(t, e) {
            return LK(t, e, true);
          };
          zi.rc2.startDecrypting = function(t, e, r) {
            var n = zi.rc2.createDecryptionCipher(t, 128);
            return n.start(e, r), n;
          };
          zi.rc2.createDecryptionCipher = function(t, e) {
            return LK(t, e, false);
          };
        });
        var L2 = A((Wqe, $K) => {
          c();
          var Ax = st();
          $K.exports = Ax.jsbn = Ax.jsbn || {};
          var Nc, I3e = 244837814094590, UK = (I3e & 16777215) == 15715070;
          function Y(t, e, r) {
            this.data = [], t != null && (typeof t == "number" ? this.fromNumber(t, e, r) : e == null && typeof t != "string" ? this.fromString(t, 256) : this.fromString(t, e));
          }
          Ax.jsbn.BigInteger = Y;
          function Ut() {
            return new Y(null);
          }
          function C3e(t, e, r, n, i2, o) {
            for (; --o >= 0; ) {
              var s = e * this.data[t++] + r.data[n] + i2;
              i2 = Math.floor(s / 67108864), r.data[n++] = s & 67108863;
            }
            return i2;
          }
          function P3e(t, e, r, n, i2, o) {
            for (var s = e & 32767, a = e >> 15; --o >= 0; ) {
              var u = this.data[t] & 32767, l = this.data[t++] >> 15, f = a * u + l * s;
              u = s * u + ((f & 32767) << 15) + r.data[n] + (i2 & 1073741823), i2 = (u >>> 30) + (f >>> 15) + a * l + (i2 >>> 30), r.data[n++] = u & 1073741823;
            }
            return i2;
          }
          function FK(t, e, r, n, i2, o) {
            for (var s = e & 16383, a = e >> 14; --o >= 0; ) {
              var u = this.data[t] & 16383, l = this.data[t++] >> 14, f = a * u + l * s;
              u = s * u + ((f & 16383) << 14) + r.data[n] + i2, i2 = (u >> 28) + (f >> 14) + a * l, r.data[n++] = u & 268435455;
            }
            return i2;
          }
          typeof navigator > "u" ? (Y.prototype.am = FK, Nc = 28) : UK && navigator.appName == "Microsoft Internet Explorer" ? (Y.prototype.am = P3e, Nc = 30) : UK && navigator.appName != "Netscape" ? (Y.prototype.am = C3e, Nc = 26) : (Y.prototype.am = FK, Nc = 28);
          Y.prototype.DB = Nc;
          Y.prototype.DM = (1 << Nc) - 1;
          Y.prototype.DV = 1 << Nc;
          var Tx = 52;
          Y.prototype.FV = Math.pow(2, Tx);
          Y.prototype.F1 = Tx - Nc;
          Y.prototype.F2 = 2 * Nc - Tx;
          var D3e = "0123456789abcdefghijklmnopqrstuvwxyz", e6 = new Array(), Yp, Wo;
          Yp = "0".charCodeAt(0);
          for (Wo = 0; Wo <= 9; ++Wo)
            e6[Yp++] = Wo;
          Yp = "a".charCodeAt(0);
          for (Wo = 10; Wo < 36; ++Wo)
            e6[Yp++] = Wo;
          Yp = "A".charCodeAt(0);
          for (Wo = 10; Wo < 36; ++Wo)
            e6[Yp++] = Wo;
          function KK(t) {
            return D3e.charAt(t);
          }
          function VK(t, e) {
            var r = e6[t.charCodeAt(e)];
            return r ?? -1;
          }
          function k3e(t) {
            for (var e = this.t - 1; e >= 0; --e)
              t.data[e] = this.data[e];
            t.t = this.t, t.s = this.s;
          }
          function N3e(t) {
            this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this.data[0] = t : t < -1 ? this.data[0] = t + this.DV : this.t = 0;
          }
          function al(t) {
            var e = Ut();
            return e.fromInt(t), e;
          }
          function O3e(t, e) {
            var r;
            if (e == 16)
              r = 4;
            else if (e == 8)
              r = 3;
            else if (e == 256)
              r = 8;
            else if (e == 2)
              r = 1;
            else if (e == 32)
              r = 5;
            else if (e == 4)
              r = 2;
            else {
              this.fromRadix(t, e);
              return;
            }
            this.t = 0, this.s = 0;
            for (var n = t.length, i2 = false, o = 0; --n >= 0; ) {
              var s = r == 8 ? t[n] & 255 : VK(t, n);
              if (s < 0) {
                t.charAt(n) == "-" && (i2 = true);
                continue;
              }
              i2 = false, o == 0 ? this.data[this.t++] = s : o + r > this.DB ? (this.data[this.t - 1] |= (s & (1 << this.DB - o) - 1) << o, this.data[this.t++] = s >> this.DB - o) : this.data[this.t - 1] |= s << o, o += r, o >= this.DB && (o -= this.DB);
            }
            r == 8 && (t[0] & 128) != 0 && (this.s = -1, o > 0 && (this.data[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), i2 && Y.ZERO.subTo(this, this);
          }
          function L3e() {
            for (var t = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == t; )
              --this.t;
          }
          function B3e(t) {
            if (this.s < 0)
              return "-" + this.negate().toString(t);
            var e;
            if (t == 16)
              e = 4;
            else if (t == 8)
              e = 3;
            else if (t == 2)
              e = 1;
            else if (t == 32)
              e = 5;
            else if (t == 4)
              e = 2;
            else
              return this.toRadix(t);
            var r = (1 << e) - 1, n, i2 = false, o = "", s = this.t, a = this.DB - s * this.DB % e;
            if (s-- > 0)
              for (a < this.DB && (n = this.data[s] >> a) > 0 && (i2 = true, o = KK(n)); s >= 0; )
                a < e ? (n = (this.data[s] & (1 << a) - 1) << e - a, n |= this.data[--s] >> (a += this.DB - e)) : (n = this.data[s] >> (a -= e) & r, a <= 0 && (a += this.DB, --s)), n > 0 && (i2 = true), i2 && (o += KK(n));
            return i2 ? o : "0";
          }
          function M3e() {
            var t = Ut();
            return Y.ZERO.subTo(this, t), t;
          }
          function U3e() {
            return this.s < 0 ? this.negate() : this;
          }
          function F3e(t) {
            var e = this.s - t.s;
            if (e != 0)
              return e;
            var r = this.t;
            if (e = r - t.t, e != 0)
              return this.s < 0 ? -e : e;
            for (; --r >= 0; )
              if ((e = this.data[r] - t.data[r]) != 0)
                return e;
            return 0;
          }
          function t6(t) {
            var e = 1, r;
            return (r = t >>> 16) != 0 && (t = r, e += 16), (r = t >> 8) != 0 && (t = r, e += 8), (r = t >> 4) != 0 && (t = r, e += 4), (r = t >> 2) != 0 && (t = r, e += 2), (r = t >> 1) != 0 && (t = r, e += 1), e;
          }
          function K3e() {
            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + t6(this.data[this.t - 1] ^ this.s & this.DM);
          }
          function V3e(t, e) {
            var r;
            for (r = this.t - 1; r >= 0; --r)
              e.data[r + t] = this.data[r];
            for (r = t - 1; r >= 0; --r)
              e.data[r] = 0;
            e.t = this.t + t, e.s = this.s;
          }
          function q3e(t, e) {
            for (var r = t; r < this.t; ++r)
              e.data[r - t] = this.data[r];
            e.t = Math.max(this.t - t, 0), e.s = this.s;
          }
          function z3e(t, e) {
            var r = t % this.DB, n = this.DB - r, i2 = (1 << n) - 1, o = Math.floor(t / this.DB), s = this.s << r & this.DM, a;
            for (a = this.t - 1; a >= 0; --a)
              e.data[a + o + 1] = this.data[a] >> n | s, s = (this.data[a] & i2) << r;
            for (a = o - 1; a >= 0; --a)
              e.data[a] = 0;
            e.data[o] = s, e.t = this.t + o + 1, e.s = this.s, e.clamp();
          }
          function H3e(t, e) {
            e.s = this.s;
            var r = Math.floor(t / this.DB);
            if (r >= this.t) {
              e.t = 0;
              return;
            }
            var n = t % this.DB, i2 = this.DB - n, o = (1 << n) - 1;
            e.data[0] = this.data[r] >> n;
            for (var s = r + 1; s < this.t; ++s)
              e.data[s - r - 1] |= (this.data[s] & o) << i2, e.data[s - r] = this.data[s] >> n;
            n > 0 && (e.data[this.t - r - 1] |= (this.s & o) << i2), e.t = this.t - r, e.clamp();
          }
          function $3e(t, e) {
            for (var r = 0, n = 0, i2 = Math.min(t.t, this.t); r < i2; )
              n += this.data[r] - t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
            if (t.t < this.t) {
              for (n -= t.s; r < this.t; )
                n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
              n += this.s;
            } else {
              for (n += this.s; r < t.t; )
                n -= t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
              n -= t.s;
            }
            e.s = n < 0 ? -1 : 0, n < -1 ? e.data[r++] = this.DV + n : n > 0 && (e.data[r++] = n), e.t = r, e.clamp();
          }
          function G3e(t, e) {
            var r = this.abs(), n = t.abs(), i2 = r.t;
            for (e.t = i2 + n.t; --i2 >= 0; )
              e.data[i2] = 0;
            for (i2 = 0; i2 < n.t; ++i2)
              e.data[i2 + r.t] = r.am(0, n.data[i2], e, i2, 0, r.t);
            e.s = 0, e.clamp(), this.s != t.s && Y.ZERO.subTo(e, e);
          }
          function W3e(t) {
            for (var e = this.abs(), r = t.t = 2 * e.t; --r >= 0; )
              t.data[r] = 0;
            for (r = 0; r < e.t - 1; ++r) {
              var n = e.am(r, e.data[r], t, 2 * r, 0, 1);
              (t.data[r + e.t] += e.am(r + 1, 2 * e.data[r], t, 2 * r + 1, n, e.t - r - 1)) >= e.DV && (t.data[r + e.t] -= e.DV, t.data[r + e.t + 1] = 1);
            }
            t.t > 0 && (t.data[t.t - 1] += e.am(r, e.data[r], t, 2 * r, 0, 1)), t.s = 0, t.clamp();
          }
          function j3e(t, e, r) {
            var n = t.abs();
            if (!(n.t <= 0)) {
              var i2 = this.abs();
              if (i2.t < n.t) {
                e?.fromInt(0), r != null && this.copyTo(r);
                return;
              }
              r == null && (r = Ut());
              var o = Ut(), s = this.s, a = t.s, u = this.DB - t6(n.data[n.t - 1]);
              u > 0 ? (n.lShiftTo(u, o), i2.lShiftTo(u, r)) : (n.copyTo(o), i2.copyTo(r));
              var l = o.t, f = o.data[l - 1];
              if (f != 0) {
                var h = f * (1 << this.F1) + (l > 1 ? o.data[l - 2] >> this.F2 : 0), p = this.FV / h, d = (1 << this.F1) / h, m = 1 << this.F2, y = r.t, g = y - l, E = e ?? Ut();
                for (o.dlShiftTo(g, E), r.compareTo(E) >= 0 && (r.data[r.t++] = 1, r.subTo(E, r)), Y.ONE.dlShiftTo(l, E), E.subTo(o, o); o.t < l; )
                  o.data[o.t++] = 0;
                for (; --g >= 0; ) {
                  var b = r.data[--y] == f ? this.DM : Math.floor(r.data[y] * p + (r.data[y - 1] + m) * d);
                  if ((r.data[y] += o.am(0, b, r, g, 0, l)) < b)
                    for (o.dlShiftTo(g, E), r.subTo(E, r); r.data[y] < --b; )
                      r.subTo(E, r);
                }
                e != null && (r.drShiftTo(l, e), s != a && Y.ZERO.subTo(e, e)), r.t = l, r.clamp(), u > 0 && r.rShiftTo(u, r), s < 0 && Y.ZERO.subTo(r, r);
              }
            }
          }
          function Y3e(t) {
            var e = Ut();
            return this.abs().divRemTo(t, null, e), this.s < 0 && e.compareTo(Y.ZERO) > 0 && t.subTo(e, e), e;
          }
          function ih(t) {
            this.m = t;
          }
          function Q3e(t) {
            return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t;
          }
          function X3e(t) {
            return t;
          }
          function Z3e(t) {
            t.divRemTo(this.m, null, t);
          }
          function J3e(t, e, r) {
            t.multiplyTo(e, r), this.reduce(r);
          }
          function e4e(t, e) {
            t.squareTo(e), this.reduce(e);
          }
          ih.prototype.convert = Q3e;
          ih.prototype.revert = X3e;
          ih.prototype.reduce = Z3e;
          ih.prototype.mulTo = J3e;
          ih.prototype.sqrTo = e4e;
          function t4e() {
            if (this.t < 1)
              return 0;
            var t = this.data[0];
            if ((t & 1) == 0)
              return 0;
            var e = t & 3;
            return e = e * (2 - (t & 15) * e) & 15, e = e * (2 - (t & 255) * e) & 255, e = e * (2 - ((t & 65535) * e & 65535)) & 65535, e = e * (2 - t * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e;
          }
          function oh(t) {
            this.m = t, this.mp = t.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t;
          }
          function r4e(t) {
            var e = Ut();
            return t.abs().dlShiftTo(this.m.t, e), e.divRemTo(this.m, null, e), t.s < 0 && e.compareTo(Y.ZERO) > 0 && this.m.subTo(e, e), e;
          }
          function n4e(t) {
            var e = Ut();
            return t.copyTo(e), this.reduce(e), e;
          }
          function i4e(t) {
            for (; t.t <= this.mt2; )
              t.data[t.t++] = 0;
            for (var e = 0; e < this.m.t; ++e) {
              var r = t.data[e] & 32767, n = r * this.mpl + ((r * this.mph + (t.data[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
              for (r = e + this.m.t, t.data[r] += this.m.am(0, n, t, e, 0, this.m.t); t.data[r] >= t.DV; )
                t.data[r] -= t.DV, t.data[++r]++;
            }
            t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t);
          }
          function o4e(t, e) {
            t.squareTo(e), this.reduce(e);
          }
          function s4e(t, e, r) {
            t.multiplyTo(e, r), this.reduce(r);
          }
          oh.prototype.convert = r4e;
          oh.prototype.revert = n4e;
          oh.prototype.reduce = i4e;
          oh.prototype.mulTo = s4e;
          oh.prototype.sqrTo = o4e;
          function a4e() {
            return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
          }
          function c4e(t, e) {
            if (t > 4294967295 || t < 1)
              return Y.ONE;
            var r = Ut(), n = Ut(), i2 = e.convert(this), o = t6(t) - 1;
            for (i2.copyTo(r); --o >= 0; )
              if (e.sqrTo(r, n), (t & 1 << o) > 0)
                e.mulTo(n, i2, r);
              else {
                var s = r;
                r = n, n = s;
              }
            return e.revert(r);
          }
          function u4e(t, e) {
            var r;
            return t < 256 || e.isEven() ? r = new ih(e) : r = new oh(e), this.exp(t, r);
          }
          Y.prototype.copyTo = k3e;
          Y.prototype.fromInt = N3e;
          Y.prototype.fromString = O3e;
          Y.prototype.clamp = L3e;
          Y.prototype.dlShiftTo = V3e;
          Y.prototype.drShiftTo = q3e;
          Y.prototype.lShiftTo = z3e;
          Y.prototype.rShiftTo = H3e;
          Y.prototype.subTo = $3e;
          Y.prototype.multiplyTo = G3e;
          Y.prototype.squareTo = W3e;
          Y.prototype.divRemTo = j3e;
          Y.prototype.invDigit = t4e;
          Y.prototype.isEven = a4e;
          Y.prototype.exp = c4e;
          Y.prototype.toString = B3e;
          Y.prototype.negate = M3e;
          Y.prototype.abs = U3e;
          Y.prototype.compareTo = F3e;
          Y.prototype.bitLength = K3e;
          Y.prototype.mod = Y3e;
          Y.prototype.modPowInt = u4e;
          Y.ZERO = al(0);
          Y.ONE = al(1);
          function l4e() {
            var t = Ut();
            return this.copyTo(t), t;
          }
          function f4e() {
            if (this.s < 0) {
              if (this.t == 1)
                return this.data[0] - this.DV;
              if (this.t == 0)
                return -1;
            } else {
              if (this.t == 1)
                return this.data[0];
              if (this.t == 0)
                return 0;
            }
            return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
          }
          function h4e() {
            return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
          }
          function d4e() {
            return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
          }
          function p4e(t) {
            return Math.floor(Math.LN2 * this.DB / Math.log(t));
          }
          function m4e() {
            return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
          }
          function y4e(t) {
            if (t == null && (t = 10), this.signum() == 0 || t < 2 || t > 36)
              return "0";
            var e = this.chunkSize(t), r = Math.pow(t, e), n = al(r), i2 = Ut(), o = Ut(), s = "";
            for (this.divRemTo(n, i2, o); i2.signum() > 0; )
              s = (r + o.intValue()).toString(t).substr(1) + s, i2.divRemTo(n, i2, o);
            return o.intValue().toString(t) + s;
          }
          function g4e(t, e) {
            this.fromInt(0), e == null && (e = 10);
            for (var r = this.chunkSize(e), n = Math.pow(e, r), i2 = false, o = 0, s = 0, a = 0; a < t.length; ++a) {
              var u = VK(t, a);
              if (u < 0) {
                t.charAt(a) == "-" && this.signum() == 0 && (i2 = true);
                continue;
              }
              s = e * s + u, ++o >= r && (this.dMultiply(n), this.dAddOffset(s, 0), o = 0, s = 0);
            }
            o > 0 && (this.dMultiply(Math.pow(e, o)), this.dAddOffset(s, 0)), i2 && Y.ZERO.subTo(this, this);
          }
          function w4e(t, e, r) {
            if (typeof e == "number")
              if (t < 2)
                this.fromInt(1);
              else
                for (this.fromNumber(t, r), this.testBit(t - 1) || this.bitwiseTo(Y.ONE.shiftLeft(t - 1), Ix, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(e); )
                  this.dAddOffset(2, 0), this.bitLength() > t && this.subTo(Y.ONE.shiftLeft(t - 1), this);
            else {
              var n = new Array(), i2 = t & 7;
              n.length = (t >> 3) + 1, e.nextBytes(n), i2 > 0 ? n[0] &= (1 << i2) - 1 : n[0] = 0, this.fromString(n, 256);
            }
          }
          function E4e() {
            var t = this.t, e = new Array();
            e[0] = this.s;
            var r = this.DB - t * this.DB % 8, n, i2 = 0;
            if (t-- > 0)
              for (r < this.DB && (n = this.data[t] >> r) != (this.s & this.DM) >> r && (e[i2++] = n | this.s << this.DB - r); t >= 0; )
                r < 8 ? (n = (this.data[t] & (1 << r) - 1) << 8 - r, n |= this.data[--t] >> (r += this.DB - 8)) : (n = this.data[t] >> (r -= 8) & 255, r <= 0 && (r += this.DB, --t)), (n & 128) != 0 && (n |= -256), i2 == 0 && (this.s & 128) != (n & 128) && ++i2, (i2 > 0 || n != this.s) && (e[i2++] = n);
            return e;
          }
          function b4e(t) {
            return this.compareTo(t) == 0;
          }
          function _4e(t) {
            return this.compareTo(t) < 0 ? this : t;
          }
          function v4e(t) {
            return this.compareTo(t) > 0 ? this : t;
          }
          function S4e(t, e, r) {
            var n, i2, o = Math.min(t.t, this.t);
            for (n = 0; n < o; ++n)
              r.data[n] = e(this.data[n], t.data[n]);
            if (t.t < this.t) {
              for (i2 = t.s & this.DM, n = o; n < this.t; ++n)
                r.data[n] = e(this.data[n], i2);
              r.t = this.t;
            } else {
              for (i2 = this.s & this.DM, n = o; n < t.t; ++n)
                r.data[n] = e(i2, t.data[n]);
              r.t = t.t;
            }
            r.s = e(this.s, t.s), r.clamp();
          }
          function x4e(t, e) {
            return t & e;
          }
          function R4e(t) {
            var e = Ut();
            return this.bitwiseTo(t, x4e, e), e;
          }
          function Ix(t, e) {
            return t | e;
          }
          function A4e(t) {
            var e = Ut();
            return this.bitwiseTo(t, Ix, e), e;
          }
          function qK(t, e) {
            return t ^ e;
          }
          function T4e(t) {
            var e = Ut();
            return this.bitwiseTo(t, qK, e), e;
          }
          function zK(t, e) {
            return t & ~e;
          }
          function I4e(t) {
            var e = Ut();
            return this.bitwiseTo(t, zK, e), e;
          }
          function C4e() {
            for (var t = Ut(), e = 0; e < this.t; ++e)
              t.data[e] = this.DM & ~this.data[e];
            return t.t = this.t, t.s = ~this.s, t;
          }
          function P4e(t) {
            var e = Ut();
            return t < 0 ? this.rShiftTo(-t, e) : this.lShiftTo(t, e), e;
          }
          function D4e(t) {
            var e = Ut();
            return t < 0 ? this.lShiftTo(-t, e) : this.rShiftTo(t, e), e;
          }
          function k4e(t) {
            if (t == 0)
              return -1;
            var e = 0;
            return (t & 65535) == 0 && (t >>= 16, e += 16), (t & 255) == 0 && (t >>= 8, e += 8), (t & 15) == 0 && (t >>= 4, e += 4), (t & 3) == 0 && (t >>= 2, e += 2), (t & 1) == 0 && ++e, e;
          }
          function N4e() {
            for (var t = 0; t < this.t; ++t)
              if (this.data[t] != 0)
                return t * this.DB + k4e(this.data[t]);
            return this.s < 0 ? this.t * this.DB : -1;
          }
          function O4e(t) {
            for (var e = 0; t != 0; )
              t &= t - 1, ++e;
            return e;
          }
          function L4e() {
            for (var t = 0, e = this.s & this.DM, r = 0; r < this.t; ++r)
              t += O4e(this.data[r] ^ e);
            return t;
          }
          function B4e(t) {
            var e = Math.floor(t / this.DB);
            return e >= this.t ? this.s != 0 : (this.data[e] & 1 << t % this.DB) != 0;
          }
          function M4e(t, e) {
            var r = Y.ONE.shiftLeft(t);
            return this.bitwiseTo(r, e, r), r;
          }
          function U4e(t) {
            return this.changeBit(t, Ix);
          }
          function F4e(t) {
            return this.changeBit(t, zK);
          }
          function K4e(t) {
            return this.changeBit(t, qK);
          }
          function V4e(t, e) {
            for (var r = 0, n = 0, i2 = Math.min(t.t, this.t); r < i2; )
              n += this.data[r] + t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
            if (t.t < this.t) {
              for (n += t.s; r < this.t; )
                n += this.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
              n += this.s;
            } else {
              for (n += this.s; r < t.t; )
                n += t.data[r], e.data[r++] = n & this.DM, n >>= this.DB;
              n += t.s;
            }
            e.s = n < 0 ? -1 : 0, n > 0 ? e.data[r++] = n : n < -1 && (e.data[r++] = this.DV + n), e.t = r, e.clamp();
          }
          function q4e(t) {
            var e = Ut();
            return this.addTo(t, e), e;
          }
          function z4e(t) {
            var e = Ut();
            return this.subTo(t, e), e;
          }
          function H4e(t) {
            var e = Ut();
            return this.multiplyTo(t, e), e;
          }
          function $4e(t) {
            var e = Ut();
            return this.divRemTo(t, e, null), e;
          }
          function G4e(t) {
            var e = Ut();
            return this.divRemTo(t, null, e), e;
          }
          function W4e(t) {
            var e = Ut(), r = Ut();
            return this.divRemTo(t, e, r), new Array(e, r);
          }
          function j4e(t) {
            this.data[this.t] = this.am(0, t - 1, this, 0, 0, this.t), ++this.t, this.clamp();
          }
          function Y4e(t, e) {
            if (t != 0) {
              for (; this.t <= e; )
                this.data[this.t++] = 0;
              for (this.data[e] += t; this.data[e] >= this.DV; )
                this.data[e] -= this.DV, ++e >= this.t && (this.data[this.t++] = 0), ++this.data[e];
            }
          }
          function O2() {
          }
          function HK(t) {
            return t;
          }
          function Q4e(t, e, r) {
            t.multiplyTo(e, r);
          }
          function X4e(t, e) {
            t.squareTo(e);
          }
          O2.prototype.convert = HK;
          O2.prototype.revert = HK;
          O2.prototype.mulTo = Q4e;
          O2.prototype.sqrTo = X4e;
          function Z4e(t) {
            return this.exp(t, new O2());
          }
          function J4e(t, e, r) {
            var n = Math.min(this.t + t.t, e);
            for (r.s = 0, r.t = n; n > 0; )
              r.data[--n] = 0;
            var i2;
            for (i2 = r.t - this.t; n < i2; ++n)
              r.data[n + this.t] = this.am(0, t.data[n], r, n, 0, this.t);
            for (i2 = Math.min(t.t, e); n < i2; ++n)
              this.am(0, t.data[n], r, n, 0, e - n);
            r.clamp();
          }
          function ewe(t, e, r) {
            --e;
            var n = r.t = this.t + t.t - e;
            for (r.s = 0; --n >= 0; )
              r.data[n] = 0;
            for (n = Math.max(e - this.t, 0); n < t.t; ++n)
              r.data[this.t + n - e] = this.am(e - n, t.data[n], r, 0, 0, this.t + n - e);
            r.clamp(), r.drShiftTo(1, r);
          }
          function Qp(t) {
            this.r2 = Ut(), this.q3 = Ut(), Y.ONE.dlShiftTo(2 * t.t, this.r2), this.mu = this.r2.divide(t), this.m = t;
          }
          function twe(t) {
            if (t.s < 0 || t.t > 2 * this.m.t)
              return t.mod(this.m);
            if (t.compareTo(this.m) < 0)
              return t;
            var e = Ut();
            return t.copyTo(e), this.reduce(e), e;
          }
          function rwe(t) {
            return t;
          }
          function nwe(t) {
            for (t.drShiftTo(this.m.t - 1, this.r2), t.t > this.m.t + 1 && (t.t = this.m.t + 1, t.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); t.compareTo(this.r2) < 0; )
              t.dAddOffset(1, this.m.t + 1);
            for (t.subTo(this.r2, t); t.compareTo(this.m) >= 0; )
              t.subTo(this.m, t);
          }
          function iwe(t, e) {
            t.squareTo(e), this.reduce(e);
          }
          function owe(t, e, r) {
            t.multiplyTo(e, r), this.reduce(r);
          }
          Qp.prototype.convert = twe;
          Qp.prototype.revert = rwe;
          Qp.prototype.reduce = nwe;
          Qp.prototype.mulTo = owe;
          Qp.prototype.sqrTo = iwe;
          function swe(t, e) {
            var r = t.bitLength(), n, i2 = al(1), o;
            if (r <= 0)
              return i2;
            r < 18 ? n = 1 : r < 48 ? n = 3 : r < 144 ? n = 4 : r < 768 ? n = 5 : n = 6, r < 8 ? o = new ih(e) : e.isEven() ? o = new Qp(e) : o = new oh(e);
            var s = new Array(), a = 3, u = n - 1, l = (1 << n) - 1;
            if (s[1] = o.convert(this), n > 1) {
              var f = Ut();
              for (o.sqrTo(s[1], f); a <= l; )
                s[a] = Ut(), o.mulTo(f, s[a - 2], s[a]), a += 2;
            }
            var h = t.t - 1, p, d = true, m = Ut(), y;
            for (r = t6(t.data[h]) - 1; h >= 0; ) {
              for (r >= u ? p = t.data[h] >> r - u & l : (p = (t.data[h] & (1 << r + 1) - 1) << u - r, h > 0 && (p |= t.data[h - 1] >> this.DB + r - u)), a = n; (p & 1) == 0; )
                p >>= 1, --a;
              if ((r -= a) < 0 && (r += this.DB, --h), d)
                s[p].copyTo(i2), d = false;
              else {
                for (; a > 1; )
                  o.sqrTo(i2, m), o.sqrTo(m, i2), a -= 2;
                a > 0 ? o.sqrTo(i2, m) : (y = i2, i2 = m, m = y), o.mulTo(m, s[p], i2);
              }
              for (; h >= 0 && (t.data[h] & 1 << r) == 0; )
                o.sqrTo(i2, m), y = i2, i2 = m, m = y, --r < 0 && (r = this.DB - 1, --h);
            }
            return o.revert(i2);
          }
          function awe(t) {
            var e = this.s < 0 ? this.negate() : this.clone(), r = t.s < 0 ? t.negate() : t.clone();
            if (e.compareTo(r) < 0) {
              var n = e;
              e = r, r = n;
            }
            var i2 = e.getLowestSetBit(), o = r.getLowestSetBit();
            if (o < 0)
              return e;
            for (i2 < o && (o = i2), o > 0 && (e.rShiftTo(o, e), r.rShiftTo(o, r)); e.signum() > 0; )
              (i2 = e.getLowestSetBit()) > 0 && e.rShiftTo(i2, e), (i2 = r.getLowestSetBit()) > 0 && r.rShiftTo(i2, r), e.compareTo(r) >= 0 ? (e.subTo(r, e), e.rShiftTo(1, e)) : (r.subTo(e, r), r.rShiftTo(1, r));
            return o > 0 && r.lShiftTo(o, r), r;
          }
          function cwe(t) {
            if (t <= 0)
              return 0;
            var e = this.DV % t, r = this.s < 0 ? t - 1 : 0;
            if (this.t > 0)
              if (e == 0)
                r = this.data[0] % t;
              else
                for (var n = this.t - 1; n >= 0; --n)
                  r = (e * r + this.data[n]) % t;
            return r;
          }
          function uwe(t) {
            var e = t.isEven();
            if (this.isEven() && e || t.signum() == 0)
              return Y.ZERO;
            for (var r = t.clone(), n = this.clone(), i2 = al(1), o = al(0), s = al(0), a = al(1); r.signum() != 0; ) {
              for (; r.isEven(); )
                r.rShiftTo(1, r), e ? ((!i2.isEven() || !o.isEven()) && (i2.addTo(this, i2), o.subTo(t, o)), i2.rShiftTo(1, i2)) : o.isEven() || o.subTo(t, o), o.rShiftTo(1, o);
              for (; n.isEven(); )
                n.rShiftTo(1, n), e ? ((!s.isEven() || !a.isEven()) && (s.addTo(this, s), a.subTo(t, a)), s.rShiftTo(1, s)) : a.isEven() || a.subTo(t, a), a.rShiftTo(1, a);
              r.compareTo(n) >= 0 ? (r.subTo(n, r), e && i2.subTo(s, i2), o.subTo(a, o)) : (n.subTo(r, n), e && s.subTo(i2, s), a.subTo(o, a));
            }
            if (n.compareTo(Y.ONE) != 0)
              return Y.ZERO;
            if (a.compareTo(t) >= 0)
              return a.subtract(t);
            if (a.signum() < 0)
              a.addTo(t, a);
            else
              return a;
            return a.signum() < 0 ? a.add(t) : a;
          }
          var Ms = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], lwe = (1 << 26) / Ms[Ms.length - 1];
          function fwe(t) {
            var e, r = this.abs();
            if (r.t == 1 && r.data[0] <= Ms[Ms.length - 1]) {
              for (e = 0; e < Ms.length; ++e)
                if (r.data[0] == Ms[e])
                  return true;
              return false;
            }
            if (r.isEven())
              return false;
            for (e = 1; e < Ms.length; ) {
              for (var n = Ms[e], i2 = e + 1; i2 < Ms.length && n < lwe; )
                n *= Ms[i2++];
              for (n = r.modInt(n); e < i2; )
                if (n % Ms[e++] == 0)
                  return false;
            }
            return r.millerRabin(t);
          }
          function hwe(t) {
            var e = this.subtract(Y.ONE), r = e.getLowestSetBit();
            if (r <= 0)
              return false;
            for (var n = e.shiftRight(r), i2 = dwe(), o, s = 0; s < t; ++s) {
              do
                o = new Y(this.bitLength(), i2);
              while (o.compareTo(Y.ONE) <= 0 || o.compareTo(e) >= 0);
              var a = o.modPow(n, this);
              if (a.compareTo(Y.ONE) != 0 && a.compareTo(e) != 0) {
                for (var u = 1; u++ < r && a.compareTo(e) != 0; )
                  if (a = a.modPowInt(2, this), a.compareTo(Y.ONE) == 0)
                    return false;
                if (a.compareTo(e) != 0)
                  return false;
              }
            }
            return true;
          }
          function dwe() {
            return { nextBytes: function(t) {
              for (var e = 0; e < t.length; ++e)
                t[e] = Math.floor(Math.random() * 256);
            } };
          }
          Y.prototype.chunkSize = p4e;
          Y.prototype.toRadix = y4e;
          Y.prototype.fromRadix = g4e;
          Y.prototype.fromNumber = w4e;
          Y.prototype.bitwiseTo = S4e;
          Y.prototype.changeBit = M4e;
          Y.prototype.addTo = V4e;
          Y.prototype.dMultiply = j4e;
          Y.prototype.dAddOffset = Y4e;
          Y.prototype.multiplyLowerTo = J4e;
          Y.prototype.multiplyUpperTo = ewe;
          Y.prototype.modInt = cwe;
          Y.prototype.millerRabin = hwe;
          Y.prototype.clone = l4e;
          Y.prototype.intValue = f4e;
          Y.prototype.byteValue = h4e;
          Y.prototype.shortValue = d4e;
          Y.prototype.signum = m4e;
          Y.prototype.toByteArray = E4e;
          Y.prototype.equals = b4e;
          Y.prototype.min = _4e;
          Y.prototype.max = v4e;
          Y.prototype.and = R4e;
          Y.prototype.or = A4e;
          Y.prototype.xor = T4e;
          Y.prototype.andNot = I4e;
          Y.prototype.not = C4e;
          Y.prototype.shiftLeft = P4e;
          Y.prototype.shiftRight = D4e;
          Y.prototype.getLowestSetBit = N4e;
          Y.prototype.bitCount = L4e;
          Y.prototype.testBit = B4e;
          Y.prototype.setBit = U4e;
          Y.prototype.clearBit = F4e;
          Y.prototype.flipBit = K4e;
          Y.prototype.add = q4e;
          Y.prototype.subtract = z4e;
          Y.prototype.multiply = H4e;
          Y.prototype.divide = $4e;
          Y.prototype.remainder = G4e;
          Y.prototype.divideAndRemainder = W4e;
          Y.prototype.modPow = swe;
          Y.prototype.modInverse = uwe;
          Y.prototype.pow = Z4e;
          Y.prototype.gcd = awe;
          Y.prototype.isProbablePrime = fwe;
        });
        var QK = A((jqe, YK) => {
          c();
          var Pa = st();
          sl();
          gr();
          var WK = YK.exports = Pa.sha1 = Pa.sha1 || {};
          Pa.md.sha1 = Pa.md.algorithms.sha1 = WK;
          WK.create = function() {
            jK || pwe();
            var t = null, e = Pa.util.createBuffer(), r = new Array(80), n = { algorithm: "sha1", blockLength: 64, digestLength: 20, messageLength: 0, fullMessageLength: null, messageLengthSize: 8 };
            return n.start = function() {
              n.messageLength = 0, n.fullMessageLength = n.messageLength64 = [];
              for (var i2 = n.messageLengthSize / 4, o = 0; o < i2; ++o)
                n.fullMessageLength.push(0);
              return e = Pa.util.createBuffer(), t = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }, n;
            }, n.start(), n.update = function(i2, o) {
              o === "utf8" && (i2 = Pa.util.encodeUtf8(i2));
              var s = i2.length;
              n.messageLength += s, s = [s / 4294967296 >>> 0, s >>> 0];
              for (var a = n.fullMessageLength.length - 1; a >= 0; --a)
                n.fullMessageLength[a] += s[1], s[1] = s[0] + (n.fullMessageLength[a] / 4294967296 >>> 0), n.fullMessageLength[a] = n.fullMessageLength[a] >>> 0, s[0] = s[1] / 4294967296 >>> 0;
              return e.putBytes(i2), GK(t, r, e), (e.read > 2048 || e.length() === 0) && e.compact(), n;
            }, n.digest = function() {
              var i2 = Pa.util.createBuffer();
              i2.putBytes(e.bytes());
              var o = n.fullMessageLength[n.fullMessageLength.length - 1] + n.messageLengthSize, s = o & n.blockLength - 1;
              i2.putBytes(Cx.substr(0, n.blockLength - s));
              for (var a, u, l = n.fullMessageLength[0] * 8, f = 0; f < n.fullMessageLength.length - 1; ++f)
                a = n.fullMessageLength[f + 1] * 8, u = a / 4294967296 >>> 0, l += u, i2.putInt32(l >>> 0), l = a >>> 0;
              i2.putInt32(l);
              var h = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3, h4: t.h4 };
              GK(h, r, i2);
              var p = Pa.util.createBuffer();
              return p.putInt32(h.h0), p.putInt32(h.h1), p.putInt32(h.h2), p.putInt32(h.h3), p.putInt32(h.h4), p;
            }, n;
          };
          var Cx = null, jK = false;
          function pwe() {
            Cx = String.fromCharCode(128), Cx += Pa.util.fillString(String.fromCharCode(0), 64), jK = true;
          }
          function GK(t, e, r) {
            for (var n, i2, o, s, a, u, l, f, h = r.length(); h >= 64; ) {
              for (i2 = t.h0, o = t.h1, s = t.h2, a = t.h3, u = t.h4, f = 0; f < 16; ++f)
                n = r.getInt32(), e[f] = n, l = a ^ o & (s ^ a), n = (i2 << 5 | i2 >>> 27) + l + u + 1518500249 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              for (; f < 20; ++f)
                n = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], n = n << 1 | n >>> 31, e[f] = n, l = a ^ o & (s ^ a), n = (i2 << 5 | i2 >>> 27) + l + u + 1518500249 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              for (; f < 32; ++f)
                n = e[f - 3] ^ e[f - 8] ^ e[f - 14] ^ e[f - 16], n = n << 1 | n >>> 31, e[f] = n, l = o ^ s ^ a, n = (i2 << 5 | i2 >>> 27) + l + u + 1859775393 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              for (; f < 40; ++f)
                n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, l = o ^ s ^ a, n = (i2 << 5 | i2 >>> 27) + l + u + 1859775393 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              for (; f < 60; ++f)
                n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, l = o & s | a & (o ^ s), n = (i2 << 5 | i2 >>> 27) + l + u + 2400959708 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              for (; f < 80; ++f)
                n = e[f - 6] ^ e[f - 16] ^ e[f - 28] ^ e[f - 32], n = n << 2 | n >>> 30, e[f] = n, l = o ^ s ^ a, n = (i2 << 5 | i2 >>> 27) + l + u + 3395469782 + n, u = a, a = s, s = (o << 30 | o >>> 2) >>> 0, o = i2, i2 = n;
              t.h0 = t.h0 + i2 | 0, t.h1 = t.h1 + o | 0, t.h2 = t.h2 + s | 0, t.h3 = t.h3 + a | 0, t.h4 = t.h4 + u | 0, h -= 64;
            }
          }
        });
        var JK = A((Yqe, ZK) => {
          c();
          var Da = st();
          gr();
          nh();
          QK();
          var XK = ZK.exports = Da.pkcs1 = Da.pkcs1 || {};
          XK.encode_rsa_oaep = function(t, e, r) {
            var n, i2, o, s;
            typeof r == "string" ? (n = r, i2 = arguments[3] || void 0, o = arguments[4] || void 0) : r && (n = r.label || void 0, i2 = r.seed || void 0, o = r.md || void 0, r.mgf1 && r.mgf1.md && (s = r.mgf1.md)), o ? o.start() : o = Da.md.sha1.create(), s || (s = o);
            var a = Math.ceil(t.n.bitLength() / 8), u = a - 2 * o.digestLength - 2;
            if (e.length > u) {
              var l = new Error("RSAES-OAEP input message length is too long.");
              throw l.length = e.length, l.maxLength = u, l;
            }
            n || (n = ""), o.update(n, "raw");
            for (var f = o.digest(), h = "", p = u - e.length, d = 0; d < p; d++)
              h += "\0";
            var m = f.getBytes() + h + "" + e;
            if (!i2)
              i2 = Da.random.getBytes(o.digestLength);
            else if (i2.length !== o.digestLength) {
              var l = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
              throw l.seedLength = i2.length, l.digestLength = o.digestLength, l;
            }
            var y = r6(i2, a - o.digestLength - 1, s), g = Da.util.xorBytes(m, y, m.length), E = r6(g, o.digestLength, s), b = Da.util.xorBytes(i2, E, i2.length);
            return "\0" + b + g;
          };
          XK.decode_rsa_oaep = function(t, e, r) {
            var n, i2, o;
            typeof r == "string" ? (n = r, i2 = arguments[3] || void 0) : r && (n = r.label || void 0, i2 = r.md || void 0, r.mgf1 && r.mgf1.md && (o = r.mgf1.md));
            var s = Math.ceil(t.n.bitLength() / 8);
            if (e.length !== s) {
              var g = new Error("RSAES-OAEP encoded message length is invalid.");
              throw g.length = e.length, g.expectedLength = s, g;
            }
            if (i2 === void 0 ? i2 = Da.md.sha1.create() : i2.start(), o || (o = i2), s < 2 * i2.digestLength + 2)
              throw new Error("RSAES-OAEP key is too short for the hash function.");
            n || (n = ""), i2.update(n, "raw");
            for (var a = i2.digest().getBytes(), u = e.charAt(0), l = e.substring(1, i2.digestLength + 1), f = e.substring(1 + i2.digestLength), h = r6(f, i2.digestLength, o), p = Da.util.xorBytes(l, h, l.length), d = r6(p, s - i2.digestLength - 1, o), m = Da.util.xorBytes(f, d, f.length), y = m.substring(0, i2.digestLength), g = u !== "\0", E = 0; E < i2.digestLength; ++E)
              g |= a.charAt(E) !== y.charAt(E);
            for (var b = 1, v = i2.digestLength, S = i2.digestLength; S < m.length; S++) {
              var x = m.charCodeAt(S), T = x & 1 ^ 1, R = b ? 65534 : 0;
              g |= x & R, b = b & T, v += b;
            }
            if (g || m.charCodeAt(v) !== 1)
              throw new Error("Invalid RSAES-OAEP padding.");
            return m.substring(v + 1);
          };
          function r6(t, e, r) {
            r || (r = Da.md.sha1.create());
            for (var n = "", i2 = Math.ceil(e / r.digestLength), o = 0; o < i2; ++o) {
              var s = String.fromCharCode(o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, o & 255);
              r.start(), r.update(t + s), n += r.digest().getBytes();
            }
            return n.substring(0, e);
          }
        });
        var eV = A((Qqe, Px) => {
          c();
          var cl = st();
          gr();
          L2();
          nh();
          (function() {
            if (cl.prime) {
              Px.exports = cl.prime;
              return;
            }
            var t = Px.exports = cl.prime = cl.prime || {}, e = cl.jsbn.BigInteger, r = [6, 4, 2, 4, 2, 4, 6, 2], n = new e(null);
            n.fromInt(30);
            var i2 = function(h, p) {
              return h | p;
            };
            t.generateProbablePrime = function(h, p, d) {
              typeof p == "function" && (d = p, p = {}), p = p || {};
              var m = p.algorithm || "PRIMEINC";
              typeof m == "string" && (m = { name: m }), m.options = m.options || {};
              var y = p.prng || cl.random, g = { nextBytes: function(E) {
                for (var b = y.getBytesSync(E.length), v = 0; v < E.length; ++v)
                  E[v] = b.charCodeAt(v);
              } };
              if (m.name === "PRIMEINC")
                return o(h, g, m.options, d);
              throw new Error("Invalid prime generation algorithm: " + m.name);
            };
            function o(h, p, d, m) {
              return "workers" in d ? u(h, p, d, m) : s(h, p, d, m);
            }
            function s(h, p, d, m) {
              var y = l(h, p), g = 0, E = f(y.bitLength());
              "millerRabinTests" in d && (E = d.millerRabinTests);
              var b = 10;
              "maxBlockTime" in d && (b = d.maxBlockTime), a(y, h, p, g, E, b, m);
            }
            function a(h, p, d, m, y, g, E) {
              var b = +new Date();
              do {
                if (h.bitLength() > p && (h = l(p, d)), h.isProbablePrime(y))
                  return E(null, h);
                h.dAddOffset(r[m++ % 8], 0);
              } while (g < 0 || +new Date() - b < g);
              cl.util.setImmediate(function() {
                a(h, p, d, m, y, g, E);
              });
            }
            function u(h, p, d, m) {
              if (typeof Worker > "u")
                return s(h, p, d, m);
              var y = l(h, p), g = d.workers, E = d.workLoad || 100, b = E * 30 / 8, v = d.workerScript || "forge/prime.worker.js";
              if (g === -1)
                return cl.util.estimateCores(function(x, T) {
                  x && (T = 2), g = T - 1, S();
                });
              S();
              function S() {
                g = Math.max(1, g);
                for (var x = [], T = 0; T < g; ++T)
                  x[T] = new Worker(v);
                for (var R = g, T = 0; T < g; ++T)
                  x[T].addEventListener("message", F);
                var O = false;
                function F(z) {
                  if (!O) {
                    --R;
                    var W = z.data;
                    if (W.found) {
                      for (var se = 0; se < x.length; ++se)
                        x[se].terminate();
                      return O = true, m(null, new e(W.prime, 16));
                    }
                    y.bitLength() > h && (y = l(h, p));
                    var re2 = y.toString(16);
                    z.target.postMessage({ hex: re2, workLoad: E }), y.dAddOffset(b, 0);
                  }
                }
              }
            }
            function l(h, p) {
              var d = new e(h, p), m = h - 1;
              return d.testBit(m) || d.bitwiseTo(e.ONE.shiftLeft(m), i2, d), d.dAddOffset(31 - d.mod(n).byteValue(), 0), d;
            }
            function f(h) {
              return h <= 100 ? 27 : h <= 150 ? 18 : h <= 200 ? 15 : h <= 250 ? 12 : h <= 300 ? 9 : h <= 350 ? 8 : h <= 400 ? 7 : h <= 500 ? 6 : h <= 600 ? 5 : h <= 800 ? 4 : h <= 1250 ? 3 : 2;
            }
          })();
        });
        var sh = A((Xqe, aV) => {
          c();
          var Oe = st();
          Aa();
          L2();
          $p();
          JK();
          eV();
          nh();
          gr();
          typeof Dt > "u" && (Dt = Oe.jsbn.BigInteger);
          var Dt, Dx = Oe.util.isNodejs ? rh() : null, V8 = Oe.asn1, jo = Oe.util;
          Oe.pki = Oe.pki || {};
          aV.exports = Oe.pki.rsa = Oe.rsa = Oe.rsa || {};
          var tt = Oe.pki, mwe = [6, 4, 2, 4, 2, 4, 6, 2], ywe = { name: "PrivateKeyInfo", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "PrivateKeyInfo.version", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: V8.Class.UNIVERSAL, type: V8.Type.OID, constructed: false, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: V8.Class.UNIVERSAL, type: V8.Type.OCTETSTRING, constructed: false, capture: "privateKey" }] }, gwe = { name: "RSAPrivateKey", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPrivateKey.version", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyVersion" }, { name: "RSAPrivateKey.modulus", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyModulus" }, { name: "RSAPrivateKey.publicExponent", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyPublicExponent" }, { name: "RSAPrivateKey.privateExponent", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyPrivateExponent" }, { name: "RSAPrivateKey.prime1", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyPrime1" }, { name: "RSAPrivateKey.prime2", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyPrime2" }, { name: "RSAPrivateKey.exponent1", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyExponent1" }, { name: "RSAPrivateKey.exponent2", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyExponent2" }, { name: "RSAPrivateKey.coefficient", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "privateKeyCoefficient" }] }, wwe = { name: "RSAPublicKey", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "RSAPublicKey.modulus", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "publicKeyModulus" }, { name: "RSAPublicKey.exponent", tagClass: V8.Class.UNIVERSAL, type: V8.Type.INTEGER, constructed: false, capture: "publicKeyExponent" }] }, Ewe = Oe.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: V8.Class.UNIVERSAL, type: V8.Type.OID, constructed: false, capture: "publicKeyOid" }] }, { name: "SubjectPublicKeyInfo.subjectPublicKey", tagClass: V8.Class.UNIVERSAL, type: V8.Type.BITSTRING, constructed: false, value: [{ name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, optional: true, captureAsn1: "rsaPublicKey" }] }] }, bwe = { name: "DigestInfo", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "DigestInfo.DigestAlgorithm", tagClass: V8.Class.UNIVERSAL, type: V8.Type.SEQUENCE, constructed: true, value: [{ name: "DigestInfo.DigestAlgorithm.algorithmIdentifier", tagClass: V8.Class.UNIVERSAL, type: V8.Type.OID, constructed: false, capture: "algorithmIdentifier" }, { name: "DigestInfo.DigestAlgorithm.parameters", tagClass: V8.Class.UNIVERSAL, type: V8.Type.NULL, capture: "parameters", optional: true, constructed: false }] }, { name: "DigestInfo.digest", tagClass: V8.Class.UNIVERSAL, type: V8.Type.OCTETSTRING, constructed: false, capture: "digest" }] }, _we = function(t) {
            var e;
            if (t.algorithm in tt.oids)
              e = tt.oids[t.algorithm];
            else {
              var r = new Error("Unknown message digest algorithm.");
              throw r.algorithm = t.algorithm, r;
            }
            var n = V8.oidToDer(e).getBytes(), i2 = V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, []), o = V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, []);
            o.value.push(V8.create(V8.Class.UNIVERSAL, V8.Type.OID, false, n)), o.value.push(V8.create(V8.Class.UNIVERSAL, V8.Type.NULL, false, ""));
            var s = V8.create(V8.Class.UNIVERSAL, V8.Type.OCTETSTRING, false, t.digest().getBytes());
            return i2.value.push(o), i2.value.push(s), V8.toDer(i2).getBytes();
          }, oV = function(t, e, r) {
            if (r)
              return t.modPow(e.e, e.n);
            if (!e.p || !e.q)
              return t.modPow(e.d, e.n);
            e.dP || (e.dP = e.d.mod(e.p.subtract(Dt.ONE))), e.dQ || (e.dQ = e.d.mod(e.q.subtract(Dt.ONE))), e.qInv || (e.qInv = e.q.modInverse(e.p));
            var n;
            do
              n = new Dt(Oe.util.bytesToHex(Oe.random.getBytes(e.n.bitLength() / 8)), 16);
            while (n.compareTo(e.n) >= 0 || !n.gcd(e.n).equals(Dt.ONE));
            t = t.multiply(n.modPow(e.e, e.n)).mod(e.n);
            for (var i2 = t.mod(e.p).modPow(e.dP, e.p), o = t.mod(e.q).modPow(e.dQ, e.q); i2.compareTo(o) < 0; )
              i2 = i2.add(e.p);
            var s = i2.subtract(o).multiply(e.qInv).mod(e.p).multiply(e.q).add(o);
            return s = s.multiply(n.modInverse(e.n)).mod(e.n), s;
          };
          tt.rsa.encrypt = function(t, e, r) {
            var n = r, i2, o = Math.ceil(e.n.bitLength() / 8);
            r !== false && r !== true ? (n = r === 2, i2 = sV(t, e, r)) : (i2 = Oe.util.createBuffer(), i2.putBytes(t));
            for (var s = new Dt(i2.toHex(), 16), a = oV(s, e, n), u = a.toString(16), l = Oe.util.createBuffer(), f = o - Math.ceil(u.length / 2); f > 0; )
              l.putByte(0), --f;
            return l.putBytes(Oe.util.hexToBytes(u)), l.getBytes();
          };
          tt.rsa.decrypt = function(t, e, r, n) {
            var i2 = Math.ceil(e.n.bitLength() / 8);
            if (t.length !== i2) {
              var o = new Error("Encrypted message length is invalid.");
              throw o.length = t.length, o.expected = i2, o;
            }
            var s = new Dt(Oe.util.createBuffer(t).toHex(), 16);
            if (s.compareTo(e.n) >= 0)
              throw new Error("Encrypted message is invalid.");
            for (var a = oV(s, e, r), u = a.toString(16), l = Oe.util.createBuffer(), f = i2 - Math.ceil(u.length / 2); f > 0; )
              l.putByte(0), --f;
            return l.putBytes(Oe.util.hexToBytes(u)), n !== false ? n6(l.getBytes(), e, r) : l.getBytes();
          };
          tt.rsa.createKeyPairGenerationState = function(t, e, r) {
            typeof t == "string" && (t = parseInt(t, 10)), t = t || 2048, r = r || {};
            var n = r.prng || Oe.random, i2 = { nextBytes: function(a) {
              for (var u = n.getBytesSync(a.length), l = 0; l < a.length; ++l)
                a[l] = u.charCodeAt(l);
            } }, o = r.algorithm || "PRIMEINC", s;
            if (o === "PRIMEINC")
              s = { algorithm: o, state: 0, bits: t, rng: i2, eInt: e || 65537, e: new Dt(null), p: null, q: null, qBits: t >> 1, pBits: t - (t >> 1), pqState: 0, num: null, keys: null }, s.e.fromInt(s.eInt);
            else
              throw new Error("Invalid key generation algorithm: " + o);
            return s;
          };
          tt.rsa.stepKeyPairGenerationState = function(t, e) {
            "algorithm" in t || (t.algorithm = "PRIMEINC");
            var r = new Dt(null);
            r.fromInt(30);
            for (var n = 0, i2 = function(h, p) {
              return h | p;
            }, o = +new Date(), s, a = 0; t.keys === null && (e <= 0 || a < e); ) {
              if (t.state === 0) {
                var u = t.p === null ? t.pBits : t.qBits, l = u - 1;
                t.pqState === 0 ? (t.num = new Dt(u, t.rng), t.num.testBit(l) || t.num.bitwiseTo(Dt.ONE.shiftLeft(l), i2, t.num), t.num.dAddOffset(31 - t.num.mod(r).byteValue(), 0), n = 0, ++t.pqState) : t.pqState === 1 ? t.num.bitLength() > u ? t.pqState = 0 : t.num.isProbablePrime(Swe(t.num.bitLength())) ? ++t.pqState : t.num.dAddOffset(mwe[n++ % 8], 0) : t.pqState === 2 ? t.pqState = t.num.subtract(Dt.ONE).gcd(t.e).compareTo(Dt.ONE) === 0 ? 3 : 0 : t.pqState === 3 && (t.pqState = 0, t.p === null ? t.p = t.num : t.q = t.num, t.p !== null && t.q !== null && ++t.state, t.num = null);
              } else if (t.state === 1)
                t.p.compareTo(t.q) < 0 && (t.num = t.p, t.p = t.q, t.q = t.num), ++t.state;
              else if (t.state === 2)
                t.p1 = t.p.subtract(Dt.ONE), t.q1 = t.q.subtract(Dt.ONE), t.phi = t.p1.multiply(t.q1), ++t.state;
              else if (t.state === 3)
                t.phi.gcd(t.e).compareTo(Dt.ONE) === 0 ? ++t.state : (t.p = null, t.q = null, t.state = 0);
              else if (t.state === 4)
                t.n = t.p.multiply(t.q), t.n.bitLength() === t.bits ? ++t.state : (t.q = null, t.state = 0);
              else if (t.state === 5) {
                var f = t.e.modInverse(t.phi);
                t.keys = { privateKey: tt.rsa.setPrivateKey(t.n, t.e, f, t.p, t.q, f.mod(t.p1), f.mod(t.q1), t.q.modInverse(t.p)), publicKey: tt.rsa.setPublicKey(t.n, t.e) };
              }
              s = +new Date(), a += s - o, o = s;
            }
            return t.keys !== null;
          };
          tt.rsa.generateKeyPair = function(t, e, r, n) {
            if (arguments.length === 1 ? typeof t == "object" ? (r = t, t = void 0) : typeof t == "function" && (n = t, t = void 0) : arguments.length === 2 ? typeof t == "number" ? typeof e == "function" ? (n = e, e = void 0) : typeof e != "number" && (r = e, e = void 0) : (r = t, n = e, t = void 0, e = void 0) : arguments.length === 3 && (typeof e == "number" ? typeof r == "function" && (n = r, r = void 0) : (n = r, r = e, e = void 0)), r = r || {}, t === void 0 && (t = r.bits || 2048), e === void 0 && (e = r.e || 65537), !Oe.options.usePureJavaScript && !r.prng && t >= 256 && t <= 16384 && (e === 65537 || e === 3)) {
              if (n) {
                if (tV("generateKeyPair"))
                  return Dx.generateKeyPair("rsa", { modulusLength: t, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function(a, u, l) {
                    if (a)
                      return n(a);
                    n(null, { privateKey: tt.privateKeyFromPem(l), publicKey: tt.publicKeyFromPem(u) });
                  });
                if (rV("generateKey") && rV("exportKey"))
                  return jo.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t, publicExponent: iV(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]).then(function(a) {
                    return jo.globalScope.crypto.subtle.exportKey("pkcs8", a.privateKey);
                  }).then(void 0, function(a) {
                    n(a);
                  }).then(function(a) {
                    if (a) {
                      var u = tt.privateKeyFromAsn1(V8.fromDer(Oe.util.createBuffer(a)));
                      n(null, { privateKey: u, publicKey: tt.setRsaPublicKey(u.n, u.e) });
                    }
                  });
                if (nV("generateKey") && nV("exportKey")) {
                  var i2 = jo.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t, publicExponent: iV(e), hash: { name: "SHA-256" } }, true, ["sign", "verify"]);
                  i2.oncomplete = function(a) {
                    var u = a.target.result, l = jo.globalScope.msCrypto.subtle.exportKey("pkcs8", u.privateKey);
                    l.oncomplete = function(f) {
                      var h = f.target.result, p = tt.privateKeyFromAsn1(V8.fromDer(Oe.util.createBuffer(h)));
                      n(null, { privateKey: p, publicKey: tt.setRsaPublicKey(p.n, p.e) });
                    }, l.onerror = function(f) {
                      n(f);
                    };
                  }, i2.onerror = function(a) {
                    n(a);
                  };
                  return;
                }
              } else if (tV("generateKeyPairSync")) {
                var o = Dx.generateKeyPairSync("rsa", { modulusLength: t, publicExponent: e, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
                return { privateKey: tt.privateKeyFromPem(o.privateKey), publicKey: tt.publicKeyFromPem(o.publicKey) };
              }
            }
            var s = tt.rsa.createKeyPairGenerationState(t, e, r);
            if (!n)
              return tt.rsa.stepKeyPairGenerationState(s, 0), s.keys;
            vwe(s, r, n);
          };
          tt.setRsaPublicKey = tt.rsa.setPublicKey = function(t, e) {
            var r = { n: t, e };
            return r.encrypt = function(n, i2, o) {
              if (typeof i2 == "string" ? i2 = i2.toUpperCase() : i2 === void 0 && (i2 = "RSAES-PKCS1-V1_5"), i2 === "RSAES-PKCS1-V1_5")
                i2 = { encode: function(a, u, l) {
                  return sV(a, u, 2).getBytes();
                } };
              else if (i2 === "RSA-OAEP" || i2 === "RSAES-OAEP")
                i2 = { encode: function(a, u) {
                  return Oe.pkcs1.encode_rsa_oaep(u, a, o);
                } };
              else if (["RAW", "NONE", "NULL", null].indexOf(i2) !== -1)
                i2 = { encode: function(a) {
                  return a;
                } };
              else if (typeof i2 == "string")
                throw new Error('Unsupported encryption scheme: "' + i2 + '".');
              var s = i2.encode(n, r, true);
              return tt.rsa.encrypt(s, r, true);
            }, r.verify = function(n, i2, o, s) {
              typeof o == "string" ? o = o.toUpperCase() : o === void 0 && (o = "RSASSA-PKCS1-V1_5"), s === void 0 && (s = { _parseAllDigestBytes: true }), "_parseAllDigestBytes" in s || (s._parseAllDigestBytes = true), o === "RSASSA-PKCS1-V1_5" ? o = { verify: function(u, l) {
                l = n6(l, r, true);
                var f = V8.fromDer(l, { parseAllBytes: s._parseAllDigestBytes }), h = {}, p = [];
                if (!V8.validate(f, bwe, h, p)) {
                  var d = new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");
                  throw d.errors = p, d;
                }
                var m = V8.derToOid(h.algorithmIdentifier);
                if (!(m === Oe.oids.md2 || m === Oe.oids.md5 || m === Oe.oids.sha1 || m === Oe.oids.sha224 || m === Oe.oids.sha256 || m === Oe.oids.sha384 || m === Oe.oids.sha512 || m === Oe.oids["sha512-224"] || m === Oe.oids["sha512-256"])) {
                  var d = new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");
                  throw d.oid = m, d;
                }
                if ((m === Oe.oids.md2 || m === Oe.oids.md5) && !("parameters" in h))
                  throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");
                return u === h.digest;
              } } : (o === "NONE" || o === "NULL" || o === null) && (o = { verify: function(u, l) {
                return l = n6(l, r, true), u === l;
              } });
              var a = tt.rsa.decrypt(i2, r, true, false);
              return o.verify(n, a, r.n.bitLength());
            }, r;
          };
          tt.setRsaPrivateKey = tt.rsa.setPrivateKey = function(t, e, r, n, i2, o, s, a) {
            var u = { n: t, e, d: r, p: n, q: i2, dP: o, dQ: s, qInv: a };
            return u.decrypt = function(l, f, h) {
              typeof f == "string" ? f = f.toUpperCase() : f === void 0 && (f = "RSAES-PKCS1-V1_5");
              var p = tt.rsa.decrypt(l, u, false, false);
              if (f === "RSAES-PKCS1-V1_5")
                f = { decode: n6 };
              else if (f === "RSA-OAEP" || f === "RSAES-OAEP")
                f = { decode: function(d, m) {
                  return Oe.pkcs1.decode_rsa_oaep(m, d, h);
                } };
              else if (["RAW", "NONE", "NULL", null].indexOf(f) !== -1)
                f = { decode: function(d) {
                  return d;
                } };
              else
                throw new Error('Unsupported encryption scheme: "' + f + '".');
              return f.decode(p, u, false);
            }, u.sign = function(l, f) {
              var h = false;
              typeof f == "string" && (f = f.toUpperCase()), f === void 0 || f === "RSASSA-PKCS1-V1_5" ? (f = { encode: _we }, h = 1) : (f === "NONE" || f === "NULL" || f === null) && (f = { encode: function() {
                return l;
              } }, h = 1);
              var p = f.encode(l, u.n.bitLength());
              return tt.rsa.encrypt(p, u, h);
            }, u;
          };
          tt.wrapRsaPrivateKey = function(t) {
            return V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, V8.integerToDer(0).getBytes()), V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.OID, false, V8.oidToDer(tt.oids.rsaEncryption).getBytes()), V8.create(V8.Class.UNIVERSAL, V8.Type.NULL, false, "")]), V8.create(V8.Class.UNIVERSAL, V8.Type.OCTETSTRING, false, V8.toDer(t).getBytes())]);
          };
          tt.privateKeyFromAsn1 = function(t) {
            var e = {}, r = [];
            if (V8.validate(t, ywe, e, r) && (t = V8.fromDer(Oe.util.createBuffer(e.privateKey))), e = {}, r = [], !V8.validate(t, gwe, e, r)) {
              var n = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
              throw n.errors = r, n;
            }
            var i2, o, s, a, u, l, f, h;
            return i2 = Oe.util.createBuffer(e.privateKeyModulus).toHex(), o = Oe.util.createBuffer(e.privateKeyPublicExponent).toHex(), s = Oe.util.createBuffer(e.privateKeyPrivateExponent).toHex(), a = Oe.util.createBuffer(e.privateKeyPrime1).toHex(), u = Oe.util.createBuffer(e.privateKeyPrime2).toHex(), l = Oe.util.createBuffer(e.privateKeyExponent1).toHex(), f = Oe.util.createBuffer(e.privateKeyExponent2).toHex(), h = Oe.util.createBuffer(e.privateKeyCoefficient).toHex(), tt.setRsaPrivateKey(new Dt(i2, 16), new Dt(o, 16), new Dt(s, 16), new Dt(a, 16), new Dt(u, 16), new Dt(l, 16), new Dt(f, 16), new Dt(h, 16));
          };
          tt.privateKeyToAsn1 = tt.privateKeyToRSAPrivateKey = function(t) {
            return V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, V8.integerToDer(0).getBytes()), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.n)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.e)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.d)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.p)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.q)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.dP)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.dQ)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.qInv))]);
          };
          tt.publicKeyFromAsn1 = function(t) {
            var e = {}, r = [];
            if (V8.validate(t, Ewe, e, r)) {
              var n = V8.derToOid(e.publicKeyOid);
              if (n !== tt.oids.rsaEncryption) {
                var i2 = new Error("Cannot read public key. Unknown OID.");
                throw i2.oid = n, i2;
              }
              t = e.rsaPublicKey;
            }
            if (r = [], !V8.validate(t, wwe, e, r)) {
              var i2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
              throw i2.errors = r, i2;
            }
            var o = Oe.util.createBuffer(e.publicKeyModulus).toHex(), s = Oe.util.createBuffer(e.publicKeyExponent).toHex();
            return tt.setRsaPublicKey(new Dt(o, 16), new Dt(s, 16));
          };
          tt.publicKeyToAsn1 = tt.publicKeyToSubjectPublicKeyInfo = function(t) {
            return V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.OID, false, V8.oidToDer(tt.oids.rsaEncryption).getBytes()), V8.create(V8.Class.UNIVERSAL, V8.Type.NULL, false, "")]), V8.create(V8.Class.UNIVERSAL, V8.Type.BITSTRING, false, [tt.publicKeyToRSAPublicKey(t)])]);
          };
          tt.publicKeyToRSAPublicKey = function(t) {
            return V8.create(V8.Class.UNIVERSAL, V8.Type.SEQUENCE, true, [V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.n)), V8.create(V8.Class.UNIVERSAL, V8.Type.INTEGER, false, ka(t.e))]);
          };
          function sV(t, e, r) {
            var n = Oe.util.createBuffer(), i2 = Math.ceil(e.n.bitLength() / 8);
            if (t.length > i2 - 11) {
              var o = new Error("Message is too long for PKCS#1 v1.5 padding.");
              throw o.length = t.length, o.max = i2 - 11, o;
            }
            n.putByte(0), n.putByte(r);
            var s = i2 - 3 - t.length, a;
            if (r === 0 || r === 1) {
              a = r === 0 ? 0 : 255;
              for (var u = 0; u < s; ++u)
                n.putByte(a);
            } else
              for (; s > 0; ) {
                for (var l = 0, f = Oe.random.getBytes(s), u = 0; u < s; ++u)
                  a = f.charCodeAt(u), a === 0 ? ++l : n.putByte(a);
                s = l;
              }
            return n.putByte(0), n.putBytes(t), n;
          }
          function n6(t, e, r, n) {
            var i2 = Math.ceil(e.n.bitLength() / 8), o = Oe.util.createBuffer(t), s = o.getByte(), a = o.getByte();
            if (s !== 0 || r && a !== 0 && a !== 1 || !r && a != 2 || r && a === 0 && typeof n > "u")
              throw new Error("Encryption block is invalid.");
            var u = 0;
            if (a === 0) {
              u = i2 - 3 - n;
              for (var l = 0; l < u; ++l)
                if (o.getByte() !== 0)
                  throw new Error("Encryption block is invalid.");
            } else if (a === 1)
              for (u = 0; o.length() > 1; ) {
                if (o.getByte() !== 255) {
                  --o.read;
                  break;
                }
                ++u;
              }
            else if (a === 2)
              for (u = 0; o.length() > 1; ) {
                if (o.getByte() === 0) {
                  --o.read;
                  break;
                }
                ++u;
              }
            var f = o.getByte();
            if (f !== 0 || u !== i2 - 3 - o.length())
              throw new Error("Encryption block is invalid.");
            return o.getBytes();
          }
          function vwe(t, e, r) {
            typeof e == "function" && (r = e, e = {}), e = e || {};
            var n = { algorithm: { name: e.algorithm || "PRIMEINC", options: { workers: e.workers || 2, workLoad: e.workLoad || 100, workerScript: e.workerScript } } };
            "prng" in e && (n.prng = e.prng), i2();
            function i2() {
              o(t.pBits, function(a, u) {
                if (a)
                  return r(a);
                if (t.p = u, t.q !== null)
                  return s(a, t.q);
                o(t.qBits, s);
              });
            }
            function o(a, u) {
              Oe.prime.generateProbablePrime(a, n, u);
            }
            function s(a, u) {
              if (a)
                return r(a);
              if (t.q = u, t.p.compareTo(t.q) < 0) {
                var l = t.p;
                t.p = t.q, t.q = l;
              }
              if (t.p.subtract(Dt.ONE).gcd(t.e).compareTo(Dt.ONE) !== 0) {
                t.p = null, i2();
                return;
              }
              if (t.q.subtract(Dt.ONE).gcd(t.e).compareTo(Dt.ONE) !== 0) {
                t.q = null, o(t.qBits, s);
                return;
              }
              if (t.p1 = t.p.subtract(Dt.ONE), t.q1 = t.q.subtract(Dt.ONE), t.phi = t.p1.multiply(t.q1), t.phi.gcd(t.e).compareTo(Dt.ONE) !== 0) {
                t.p = t.q = null, i2();
                return;
              }
              if (t.n = t.p.multiply(t.q), t.n.bitLength() !== t.bits) {
                t.q = null, o(t.qBits, s);
                return;
              }
              var f = t.e.modInverse(t.phi);
              t.keys = { privateKey: tt.rsa.setPrivateKey(t.n, t.e, f, t.p, t.q, f.mod(t.p1), f.mod(t.q1), t.q.modInverse(t.p)), publicKey: tt.rsa.setPublicKey(t.n, t.e) }, r(null, t.keys);
            }
          }
          function ka(t) {
            var e = t.toString(16);
            e[0] >= "8" && (e = "00" + e);
            var r = Oe.util.hexToBytes(e);
            return r.length > 1 && (r.charCodeAt(0) === 0 && (r.charCodeAt(1) & 128) === 0 || r.charCodeAt(0) === 255 && (r.charCodeAt(1) & 128) === 128) ? r.substr(1) : r;
          }
          function Swe(t) {
            return t <= 100 ? 27 : t <= 150 ? 18 : t <= 200 ? 15 : t <= 250 ? 12 : t <= 300 ? 9 : t <= 350 ? 8 : t <= 400 ? 7 : t <= 500 ? 6 : t <= 600 ? 5 : t <= 800 ? 4 : t <= 1250 ? 3 : 2;
          }
          function tV(t) {
            return Oe.util.isNodejs && typeof Dx[t] == "function";
          }
          function rV(t) {
            return typeof jo.globalScope < "u" && typeof jo.globalScope.crypto == "object" && typeof jo.globalScope.crypto.subtle == "object" && typeof jo.globalScope.crypto.subtle[t] == "function";
          }
          function nV(t) {
            return typeof jo.globalScope < "u" && typeof jo.globalScope.msCrypto == "object" && typeof jo.globalScope.msCrypto.subtle == "object" && typeof jo.globalScope.msCrypto.subtle[t] == "function";
          }
          function iV(t) {
            for (var e = Oe.util.hexToBytes(t.toString(16)), r = new Uint8Array(e.length), n = 0; n < e.length; ++n)
              r[n] = e.charCodeAt(n);
            return r;
          }
        });
        var i6 = A((Zqe, hV) => {
          c();
          var de = st();
          jp();
          Aa();
          jw();
          sl();
          $p();
          vx();
          Zw();
          nh();
          MK();
          sh();
          gr();
          typeof cV > "u" && (cV = de.jsbn.BigInteger);
          var cV, G = de.asn1, ut = de.pki = de.pki || {};
          hV.exports = ut.pbe = de.pbe = de.pbe || {};
          var ah = ut.oids, xwe = { name: "EncryptedPrivateKeyInfo", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: G.Class.UNIVERSAL, type: G.Type.OID, constructed: false, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, captureAsn1: "encryptionParams" }] }, { name: "EncryptedPrivateKeyInfo.encryptedData", tagClass: G.Class.UNIVERSAL, type: G.Type.OCTETSTRING, constructed: false, capture: "encryptedData" }] }, Rwe = { name: "PBES2Algorithms", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: G.Class.UNIVERSAL, type: G.Type.OID, constructed: false, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.params.salt", tagClass: G.Class.UNIVERSAL, type: G.Type.OCTETSTRING, constructed: false, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: G.Class.UNIVERSAL, type: G.Type.INTEGER, constructed: false, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: G.Class.UNIVERSAL, type: G.Type.INTEGER, constructed: false, optional: true, capture: "keyLength" }, { name: "PBES2Algorithms.params.prf", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, optional: true, value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: G.Class.UNIVERSAL, type: G.Type.OID, constructed: false, capture: "prfOid" }] }] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: G.Class.UNIVERSAL, type: G.Type.OID, constructed: false, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: G.Class.UNIVERSAL, type: G.Type.OCTETSTRING, constructed: false, capture: "encIv" }] }] }, Awe = { name: "pkcs-12PbeParams", tagClass: G.Class.UNIVERSAL, type: G.Type.SEQUENCE, constructed: true, value: [{ name: "pkcs-12PbeParams.salt", tagClass: G.Class.UNIVERSAL, type: G.Type.OCTETSTRING, constructed: false, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: G.Class.UNIVERSAL, type: G.Type.INTEGER, constructed: false, capture: "iterations" }] };
          ut.encryptPrivateKeyInfo = function(t, e, r) {
            r = r || {}, r.saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || "aes128", r.prfAlgorithm = r.prfAlgorithm || "sha1";
            var n = de.random.getBytesSync(r.saltSize), i2 = r.count, o = G.integerToDer(i2), s, a, u;
            if (r.algorithm.indexOf("aes") === 0 || r.algorithm === "des") {
              var l, f, h;
              switch (r.algorithm) {
                case "aes128":
                  s = 16, l = 16, f = ah["aes128-CBC"], h = de.aes.createEncryptionCipher;
                  break;
                case "aes192":
                  s = 24, l = 16, f = ah["aes192-CBC"], h = de.aes.createEncryptionCipher;
                  break;
                case "aes256":
                  s = 32, l = 16, f = ah["aes256-CBC"], h = de.aes.createEncryptionCipher;
                  break;
                case "des":
                  s = 8, l = 8, f = ah.desCBC, h = de.des.createEncryptionCipher;
                  break;
                default:
                  var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
                  throw p.algorithm = r.algorithm, p;
              }
              var d = "hmacWith" + r.prfAlgorithm.toUpperCase(), m = fV(d), y = de.pkcs5.pbkdf2(e, n, i2, s, m), g = de.random.getBytesSync(l), E = h(y);
              E.start(g), E.update(G.toDer(t)), E.finish(), u = E.output.getBytes();
              var b = Twe(n, o, s, d);
              a = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OID, false, G.oidToDer(ah.pkcs5PBES2).getBytes()), G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OID, false, G.oidToDer(ah.pkcs5PBKDF2).getBytes()), b]), G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OID, false, G.oidToDer(f).getBytes()), G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, g)])])]);
            } else if (r.algorithm === "3des") {
              s = 24;
              var v = new de.util.ByteBuffer(n), y = ut.pbe.generatePkcs12Key(e, v, 1, i2, s), g = ut.pbe.generatePkcs12Key(e, v, 2, i2, s), E = de.des.createEncryptionCipher(y);
              E.start(g), E.update(G.toDer(t)), E.finish(), u = E.output.getBytes(), a = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OID, false, G.oidToDer(ah["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, n), G.create(G.Class.UNIVERSAL, G.Type.INTEGER, false, o.getBytes())])]);
            } else {
              var p = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
              throw p.algorithm = r.algorithm, p;
            }
            var S = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [a, G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, u)]);
            return S;
          };
          ut.decryptPrivateKeyInfo = function(t, e) {
            var r = null, n = {}, i2 = [];
            if (!G.validate(t, xwe, n, i2)) {
              var o = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
              throw o.errors = i2, o;
            }
            var s = G.derToOid(n.encryptionOid), a = ut.pbe.getCipher(s, n.encryptionParams, e), u = de.util.createBuffer(n.encryptedData);
            return a.update(u), a.finish() && (r = G.fromDer(a.output)), r;
          };
          ut.encryptedPrivateKeyToPem = function(t, e) {
            var r = { type: "ENCRYPTED PRIVATE KEY", body: G.toDer(t).getBytes() };
            return de.pem.encode(r, { maxline: e });
          };
          ut.encryptedPrivateKeyFromPem = function(t) {
            var e = de.pem.decode(t)[0];
            if (e.type !== "ENCRYPTED PRIVATE KEY") {
              var r = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
              throw r.headerType = e.type, r;
            }
            if (e.procType && e.procType.type === "ENCRYPTED")
              throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
            return G.fromDer(e.body);
          };
          ut.encryptRsaPrivateKey = function(t, e, r) {
            if (r = r || {}, !r.legacy) {
              var n = ut.wrapRsaPrivateKey(ut.privateKeyToAsn1(t));
              return n = ut.encryptPrivateKeyInfo(n, e, r), ut.encryptedPrivateKeyToPem(n);
            }
            var i2, o, s, a;
            switch (r.algorithm) {
              case "aes128":
                i2 = "AES-128-CBC", s = 16, o = de.random.getBytesSync(16), a = de.aes.createEncryptionCipher;
                break;
              case "aes192":
                i2 = "AES-192-CBC", s = 24, o = de.random.getBytesSync(16), a = de.aes.createEncryptionCipher;
                break;
              case "aes256":
                i2 = "AES-256-CBC", s = 32, o = de.random.getBytesSync(16), a = de.aes.createEncryptionCipher;
                break;
              case "3des":
                i2 = "DES-EDE3-CBC", s = 24, o = de.random.getBytesSync(8), a = de.des.createEncryptionCipher;
                break;
              case "des":
                i2 = "DES-CBC", s = 8, o = de.random.getBytesSync(8), a = de.des.createEncryptionCipher;
                break;
              default:
                var u = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + r.algorithm + '".');
                throw u.algorithm = r.algorithm, u;
            }
            var l = de.pbe.opensslDeriveBytes(e, o.substr(0, 8), s), f = a(l);
            f.start(o), f.update(G.toDer(ut.privateKeyToAsn1(t))), f.finish();
            var h = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: i2, parameters: de.util.bytesToHex(o).toUpperCase() }, body: f.output.getBytes() };
            return de.pem.encode(h);
          };
          ut.decryptRsaPrivateKey = function(t, e) {
            var r = null, n = de.pem.decode(t)[0];
            if (n.type !== "ENCRYPTED PRIVATE KEY" && n.type !== "PRIVATE KEY" && n.type !== "RSA PRIVATE KEY") {
              var i2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
              throw i2.headerType = i2, i2;
            }
            if (n.procType && n.procType.type === "ENCRYPTED") {
              var o, s;
              switch (n.dekInfo.algorithm) {
                case "DES-CBC":
                  o = 8, s = de.des.createDecryptionCipher;
                  break;
                case "DES-EDE3-CBC":
                  o = 24, s = de.des.createDecryptionCipher;
                  break;
                case "AES-128-CBC":
                  o = 16, s = de.aes.createDecryptionCipher;
                  break;
                case "AES-192-CBC":
                  o = 24, s = de.aes.createDecryptionCipher;
                  break;
                case "AES-256-CBC":
                  o = 32, s = de.aes.createDecryptionCipher;
                  break;
                case "RC2-40-CBC":
                  o = 5, s = function(h) {
                    return de.rc2.createDecryptionCipher(h, 40);
                  };
                  break;
                case "RC2-64-CBC":
                  o = 8, s = function(h) {
                    return de.rc2.createDecryptionCipher(h, 64);
                  };
                  break;
                case "RC2-128-CBC":
                  o = 16, s = function(h) {
                    return de.rc2.createDecryptionCipher(h, 128);
                  };
                  break;
                default:
                  var i2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + n.dekInfo.algorithm + '".');
                  throw i2.algorithm = n.dekInfo.algorithm, i2;
              }
              var a = de.util.hexToBytes(n.dekInfo.parameters), u = de.pbe.opensslDeriveBytes(e, a.substr(0, 8), o), l = s(u);
              if (l.start(a), l.update(de.util.createBuffer(n.body)), l.finish())
                r = l.output.getBytes();
              else
                return r;
            } else
              r = n.body;
            return n.type === "ENCRYPTED PRIVATE KEY" ? r = ut.decryptPrivateKeyInfo(G.fromDer(r), e) : r = G.fromDer(r), r !== null && (r = ut.privateKeyFromAsn1(r)), r;
          };
          ut.pbe.generatePkcs12Key = function(t, e, r, n, i2, o) {
            var s, a;
            if (typeof o > "u" || o === null) {
              if (!("sha1" in de.md))
                throw new Error('"sha1" hash algorithm unavailable.');
              o = de.md.sha1.create();
            }
            var u = o.digestLength, l = o.blockLength, f = new de.util.ByteBuffer(), h = new de.util.ByteBuffer();
            if (t != null) {
              for (a = 0; a < t.length; a++)
                h.putInt16(t.charCodeAt(a));
              h.putInt16(0);
            }
            var p = h.length(), d = e.length(), m = new de.util.ByteBuffer();
            m.fillWithByte(r, l);
            var y = l * Math.ceil(d / l), g = new de.util.ByteBuffer();
            for (a = 0; a < y; a++)
              g.putByte(e.at(a % d));
            var E = l * Math.ceil(p / l), b = new de.util.ByteBuffer();
            for (a = 0; a < E; a++)
              b.putByte(h.at(a % p));
            var v = g;
            v.putBuffer(b);
            for (var S = Math.ceil(i2 / u), x = 1; x <= S; x++) {
              var T = new de.util.ByteBuffer();
              T.putBytes(m.bytes()), T.putBytes(v.bytes());
              for (var R = 0; R < n; R++)
                o.start(), o.update(T.getBytes()), T = o.digest();
              var O = new de.util.ByteBuffer();
              for (a = 0; a < l; a++)
                O.putByte(T.at(a % u));
              var F = Math.ceil(d / l) + Math.ceil(p / l), z = new de.util.ByteBuffer();
              for (s = 0; s < F; s++) {
                var W = new de.util.ByteBuffer(v.getBytes(l)), se = 511;
                for (a = O.length() - 1; a >= 0; a--)
                  se = se >> 8, se += O.at(a) + W.at(a), W.setAt(a, se & 255);
                z.putBuffer(W);
              }
              v = z, f.putBuffer(T);
            }
            return f.truncate(f.length() - i2), f;
          };
          ut.pbe.getCipher = function(t, e, r) {
            switch (t) {
              case ut.oids.pkcs5PBES2:
                return ut.pbe.getCipherForPBES2(t, e, r);
              case ut.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
              case ut.oids["pbewithSHAAnd40BitRC2-CBC"]:
                return ut.pbe.getCipherForPKCS12PBE(t, e, r);
              default:
                var n = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
                throw n.oid = t, n.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], n;
            }
          };
          ut.pbe.getCipherForPBES2 = function(t, e, r) {
            var n = {}, i2 = [];
            if (!G.validate(e, Rwe, n, i2)) {
              var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
              throw o.errors = i2, o;
            }
            if (t = G.derToOid(n.kdfOid), t !== ut.oids.pkcs5PBKDF2) {
              var o = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
              throw o.oid = t, o.supportedOids = ["pkcs5PBKDF2"], o;
            }
            if (t = G.derToOid(n.encOid), t !== ut.oids["aes128-CBC"] && t !== ut.oids["aes192-CBC"] && t !== ut.oids["aes256-CBC"] && t !== ut.oids["des-EDE3-CBC"] && t !== ut.oids.desCBC) {
              var o = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
              throw o.oid = t, o.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], o;
            }
            var s = n.kdfSalt, a = de.util.createBuffer(n.kdfIterationCount);
            a = a.getInt(a.length() << 3);
            var u, l;
            switch (ut.oids[t]) {
              case "aes128-CBC":
                u = 16, l = de.aes.createDecryptionCipher;
                break;
              case "aes192-CBC":
                u = 24, l = de.aes.createDecryptionCipher;
                break;
              case "aes256-CBC":
                u = 32, l = de.aes.createDecryptionCipher;
                break;
              case "des-EDE3-CBC":
                u = 24, l = de.des.createDecryptionCipher;
                break;
              case "desCBC":
                u = 8, l = de.des.createDecryptionCipher;
                break;
            }
            var f = lV(n.prfOid), h = de.pkcs5.pbkdf2(r, s, a, u, f), p = n.encIv, d = l(h);
            return d.start(p), d;
          };
          ut.pbe.getCipherForPKCS12PBE = function(t, e, r) {
            var n = {}, i2 = [];
            if (!G.validate(e, Awe, n, i2)) {
              var o = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
              throw o.errors = i2, o;
            }
            var s = de.util.createBuffer(n.salt), a = de.util.createBuffer(n.iterations);
            a = a.getInt(a.length() << 3);
            var u, l, f;
            switch (t) {
              case ut.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                u = 24, l = 8, f = de.des.startDecrypting;
                break;
              case ut.oids["pbewithSHAAnd40BitRC2-CBC"]:
                u = 5, l = 8, f = function(y, g) {
                  var E = de.rc2.createDecryptionCipher(y, 40);
                  return E.start(g, null), E;
                };
                break;
              default:
                var o = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
                throw o.oid = t, o;
            }
            var h = lV(n.prfOid), p = ut.pbe.generatePkcs12Key(r, s, 1, a, u, h);
            h.start();
            var d = ut.pbe.generatePkcs12Key(r, s, 2, a, l, h);
            return f(p, d);
          };
          ut.pbe.opensslDeriveBytes = function(t, e, r, n) {
            if (typeof n > "u" || n === null) {
              if (!("md5" in de.md))
                throw new Error('"md5" hash algorithm unavailable.');
              n = de.md.md5.create();
            }
            e === null && (e = "");
            for (var i2 = [uV(n, t + e)], o = 16, s = 1; o < r; ++s, o += 16)
              i2.push(uV(n, i2[s - 1] + t + e));
            return i2.join("").substr(0, r);
          };
          function uV(t, e) {
            return t.start().update(e).digest().getBytes();
          }
          function lV(t) {
            var e;
            if (!t)
              e = "hmacWithSHA1";
            else if (e = ut.oids[G.derToOid(t)], !e) {
              var r = new Error("Unsupported PRF OID.");
              throw r.oid = t, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r;
            }
            return fV(e);
          }
          function fV(t) {
            var e = de.md;
            switch (t) {
              case "hmacWithSHA224":
                e = de.md.sha512;
              case "hmacWithSHA1":
              case "hmacWithSHA256":
              case "hmacWithSHA384":
              case "hmacWithSHA512":
                t = t.substr(8).toLowerCase();
                break;
              default:
                var r = new Error("Unsupported PRF algorithm.");
                throw r.algorithm = t, r.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], r;
            }
            if (!e || !(t in e))
              throw new Error("Unknown hash algorithm: " + t);
            return e[t].create();
          }
          function Twe(t, e, r, n) {
            var i2 = G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OCTETSTRING, false, t), G.create(G.Class.UNIVERSAL, G.Type.INTEGER, false, e.getBytes())]);
            return n !== "hmacWithSHA1" && i2.value.push(G.create(G.Class.UNIVERSAL, G.Type.INTEGER, false, de.util.hexToBytes(r.toString(16))), G.create(G.Class.UNIVERSAL, G.Type.SEQUENCE, true, [G.create(G.Class.UNIVERSAL, G.Type.OID, false, G.oidToDer(ut.oids[n]).getBytes()), G.create(G.Class.UNIVERSAL, G.Type.NULL, false, "")])), i2;
          }
        });
        var Bx = A((Rze, CV) => {
          c();
          var Pr = st();
          sl();
          gr();
          var B2 = CV.exports = Pr.sha512 = Pr.sha512 || {};
          Pr.md.sha512 = Pr.md.algorithms.sha512 = B2;
          var TV = Pr.sha384 = Pr.sha512.sha384 = Pr.sha512.sha384 || {};
          TV.create = function() {
            return B2.create("SHA-384");
          };
          Pr.md.sha384 = Pr.md.algorithms.sha384 = TV;
          Pr.sha512.sha256 = Pr.sha512.sha256 || { create: function() {
            return B2.create("SHA-512/256");
          } };
          Pr.md["sha512/256"] = Pr.md.algorithms["sha512/256"] = Pr.sha512.sha256;
          Pr.sha512.sha224 = Pr.sha512.sha224 || { create: function() {
            return B2.create("SHA-512/224");
          } };
          Pr.md["sha512/224"] = Pr.md.algorithms["sha512/224"] = Pr.sha512.sha224;
          B2.create = function(t) {
            if (IV || Nwe(), typeof t > "u" && (t = "SHA-512"), !(t in ch))
              throw new Error("Invalid SHA-512 algorithm: " + t);
            for (var e = ch[t], r = null, n = Pr.util.createBuffer(), i2 = new Array(80), o = 0; o < 80; ++o)
              i2[o] = new Array(2);
            var s = 64;
            switch (t) {
              case "SHA-384":
                s = 48;
                break;
              case "SHA-512/256":
                s = 32;
                break;
              case "SHA-512/224":
                s = 28;
                break;
            }
            var a = { algorithm: t.replace("-", "").toLowerCase(), blockLength: 128, digestLength: s, messageLength: 0, fullMessageLength: null, messageLengthSize: 16 };
            return a.start = function() {
              a.messageLength = 0, a.fullMessageLength = a.messageLength128 = [];
              for (var u = a.messageLengthSize / 4, l = 0; l < u; ++l)
                a.fullMessageLength.push(0);
              n = Pr.util.createBuffer(), r = new Array(e.length);
              for (var l = 0; l < e.length; ++l)
                r[l] = e[l].slice(0);
              return a;
            }, a.start(), a.update = function(u, l) {
              l === "utf8" && (u = Pr.util.encodeUtf8(u));
              var f = u.length;
              a.messageLength += f, f = [f / 4294967296 >>> 0, f >>> 0];
              for (var h = a.fullMessageLength.length - 1; h >= 0; --h)
                a.fullMessageLength[h] += f[1], f[1] = f[0] + (a.fullMessageLength[h] / 4294967296 >>> 0), a.fullMessageLength[h] = a.fullMessageLength[h] >>> 0, f[0] = f[1] / 4294967296 >>> 0;
              return n.putBytes(u), AV(r, i2, n), (n.read > 2048 || n.length() === 0) && n.compact(), a;
            }, a.digest = function() {
              var u = Pr.util.createBuffer();
              u.putBytes(n.bytes());
              var l = a.fullMessageLength[a.fullMessageLength.length - 1] + a.messageLengthSize, f = l & a.blockLength - 1;
              u.putBytes(Ox.substr(0, a.blockLength - f));
              for (var h, p, d = a.fullMessageLength[0] * 8, m = 0; m < a.fullMessageLength.length - 1; ++m)
                h = a.fullMessageLength[m + 1] * 8, p = h / 4294967296 >>> 0, d += p, u.putInt32(d >>> 0), d = h >>> 0;
              u.putInt32(d);
              for (var y = new Array(r.length), m = 0; m < r.length; ++m)
                y[m] = r[m].slice(0);
              AV(y, i2, u);
              var g = Pr.util.createBuffer(), E;
              t === "SHA-512" ? E = y.length : t === "SHA-384" ? E = y.length - 2 : E = y.length - 4;
              for (var m = 0; m < E; ++m)
                g.putInt32(y[m][0]), (m !== E - 1 || t !== "SHA-512/224") && g.putInt32(y[m][1]);
              return g;
            }, a;
          };
          var Ox = null, IV = false, Lx = null, ch = null;
          function Nwe() {
            Ox = String.fromCharCode(128), Ox += Pr.util.fillString(String.fromCharCode(0), 128), Lx = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]], ch = {}, ch["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]], ch["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]], ch["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]], ch["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]], IV = true;
          }
          function AV(t, e, r) {
            for (var n, i2, o, s, a, u, l, f, h, p, d, m, y, g, E, b, v, S, x, T, R, O, F, z, W, se, re2, Ge, ge, ke, H, $e, or3, nt, it, J = r.length(); J >= 128; ) {
              for (ge = 0; ge < 16; ++ge)
                e[ge][0] = r.getInt32() >>> 0, e[ge][1] = r.getInt32() >>> 0;
              for (; ge < 80; ++ge)
                $e = e[ge - 2], ke = $e[0], H = $e[1], n = ((ke >>> 19 | H << 13) ^ (H >>> 29 | ke << 3) ^ ke >>> 6) >>> 0, i2 = ((ke << 13 | H >>> 19) ^ (H << 3 | ke >>> 29) ^ (ke << 26 | H >>> 6)) >>> 0, nt = e[ge - 15], ke = nt[0], H = nt[1], o = ((ke >>> 1 | H << 31) ^ (ke >>> 8 | H << 24) ^ ke >>> 7) >>> 0, s = ((ke << 31 | H >>> 1) ^ (ke << 24 | H >>> 8) ^ (ke << 25 | H >>> 7)) >>> 0, or3 = e[ge - 7], it = e[ge - 16], H = i2 + or3[1] + s + it[1], e[ge][0] = n + or3[0] + o + it[0] + (H / 4294967296 >>> 0) >>> 0, e[ge][1] = H >>> 0;
              for (y = t[0][0], g = t[0][1], E = t[1][0], b = t[1][1], v = t[2][0], S = t[2][1], x = t[3][0], T = t[3][1], R = t[4][0], O = t[4][1], F = t[5][0], z = t[5][1], W = t[6][0], se = t[6][1], re2 = t[7][0], Ge = t[7][1], ge = 0; ge < 80; ++ge)
                l = ((R >>> 14 | O << 18) ^ (R >>> 18 | O << 14) ^ (O >>> 9 | R << 23)) >>> 0, f = ((R << 18 | O >>> 14) ^ (R << 14 | O >>> 18) ^ (O << 23 | R >>> 9)) >>> 0, h = (W ^ R & (F ^ W)) >>> 0, p = (se ^ O & (z ^ se)) >>> 0, a = ((y >>> 28 | g << 4) ^ (g >>> 2 | y << 30) ^ (g >>> 7 | y << 25)) >>> 0, u = ((y << 4 | g >>> 28) ^ (g << 30 | y >>> 2) ^ (g << 25 | y >>> 7)) >>> 0, d = (y & E | v & (y ^ E)) >>> 0, m = (g & b | S & (g ^ b)) >>> 0, H = Ge + f + p + Lx[ge][1] + e[ge][1], n = re2 + l + h + Lx[ge][0] + e[ge][0] + (H / 4294967296 >>> 0) >>> 0, i2 = H >>> 0, H = u + m, o = a + d + (H / 4294967296 >>> 0) >>> 0, s = H >>> 0, re2 = W, Ge = se, W = F, se = z, F = R, z = O, H = T + i2, R = x + n + (H / 4294967296 >>> 0) >>> 0, O = H >>> 0, x = v, T = S, v = E, S = b, E = y, b = g, H = i2 + s, y = n + o + (H / 4294967296 >>> 0) >>> 0, g = H >>> 0;
              H = t[0][1] + g, t[0][0] = t[0][0] + y + (H / 4294967296 >>> 0) >>> 0, t[0][1] = H >>> 0, H = t[1][1] + b, t[1][0] = t[1][0] + E + (H / 4294967296 >>> 0) >>> 0, t[1][1] = H >>> 0, H = t[2][1] + S, t[2][0] = t[2][0] + v + (H / 4294967296 >>> 0) >>> 0, t[2][1] = H >>> 0, H = t[3][1] + T, t[3][0] = t[3][0] + x + (H / 4294967296 >>> 0) >>> 0, t[3][1] = H >>> 0, H = t[4][1] + O, t[4][0] = t[4][0] + R + (H / 4294967296 >>> 0) >>> 0, t[4][1] = H >>> 0, H = t[5][1] + z, t[5][0] = t[5][0] + F + (H / 4294967296 >>> 0) >>> 0, t[5][1] = H >>> 0, H = t[6][1] + se, t[6][0] = t[6][0] + W + (H / 4294967296 >>> 0) >>> 0, t[6][1] = H >>> 0, H = t[7][1] + Ge, t[7][0] = t[7][0] + re2 + (H / 4294967296 >>> 0) >>> 0, t[7][1] = H >>> 0, J -= 128;
            }
          }
        });
        var uh = A((Aze, PV) => {
          "use strict";
          c();
          function Owe(t) {
            let e = new Uint8Array(t), r = 0;
            if (t > 0)
              if (t > 65536)
                for (; r < t; )
                  r + 65536 > t ? (crypto.getRandomValues(e.subarray(r, r + (t - r))), r += t - r) : (crypto.getRandomValues(e.subarray(r, r + 65536)), r += 65536);
              else
                crypto.getRandomValues(e);
            return e;
          }
          PV.exports = Owe;
        });
        var Vs = A((f$e, Hq) => {
          "use strict";
          c();
          var N6e = async (t) => {
            let e = [];
            for await (let r of t)
              e.push(r);
            return e;
          };
          Hq.exports = N6e;
        });
        var Ci = A((d$e, Gq) => {
          "use strict";
          c();
          var O6e = async (t) => {
            for await (let e of t)
              ;
          };
          Gq.exports = O6e;
        });
        var Gi = A((p$e, Wq) => {
          "use strict";
          c();
          var L6e = async function* (t, e) {
            for await (let r of t)
              await e(r) && (yield r);
          };
          Wq.exports = L6e;
        });
        var h0 = A((m$e, jq) => {
          "use strict";
          c();
          var B6e = async function* (t, e) {
            let r = 0;
            if (!(e < 1)) {
              for await (let n of t)
                if (yield n, r++, r === e)
                  return;
            }
          };
          jq.exports = B6e;
        });
        var Qq = A((E$e, Yq) => {
          c();
          Yq.exports = class {
            constructor(e) {
              if (!(e > 0) || (e - 1 & e) !== 0)
                throw new Error("Max size for a FixedFIFO should be a power of two");
              this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
            }
            push(e) {
              return this.buffer[this.top] !== void 0 ? false : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, true);
            }
            shift() {
              let e = this.buffer[this.btm];
              if (e !== void 0)
                return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
            }
            peek() {
              return this.buffer[this.btm];
            }
            isEmpty() {
              return this.buffer[this.btm] === void 0;
            }
          };
        });
        var d0 = A((_$e, Zq) => {
          c();
          var Xq = Qq();
          Zq.exports = class {
            constructor(e) {
              this.hwm = e || 16, this.head = new Xq(this.hwm), this.tail = this.head;
            }
            push(e) {
              if (!this.head.push(e)) {
                let r = this.head;
                this.head = r.next = new Xq(2 * this.head.buffer.length), this.head.push(e);
              }
            }
            shift() {
              let e = this.tail.shift();
              if (e === void 0 && this.tail.next) {
                let r = this.tail.next;
                return this.tail.next = null, this.tail = r, this.tail.shift();
              }
              return e;
            }
            peek() {
              return this.tail.peek();
            }
            isEmpty() {
              return this.head.isEmpty();
            }
          };
        });
        var ez = A((v$e, Jq) => {
          c();
          var yR = d0();
          Jq.exports = (t) => {
            t = t || {};
            let e;
            typeof t == "function" ? (e = t, t = {}) : e = t.onEnd;
            let r = new yR(), n, i2, o, s = () => {
              if (!r.isEmpty()) {
                if (t.writev) {
                  let y, g = [];
                  for (; !r.isEmpty(); ) {
                    if (y = r.shift(), y.error)
                      throw y.error;
                    g.push(y.value);
                  }
                  return { done: y.done, value: g };
                }
                let m = r.shift();
                if (m.error)
                  throw m.error;
                return m;
              }
              return o ? { done: true } : new Promise((m, y) => {
                i2 = (g) => (i2 = null, g.error ? y(g.error) : t.writev && !g.done ? m({ done: g.done, value: [g.value] }) : m(g), n);
              });
            }, a = (m) => i2 ? i2(m) : (r.push(m), n), u = (m) => (r = new yR(), i2 ? i2({ error: m }) : (r.push({ error: m }), n)), l = (m) => o ? n : a({ done: false, value: m }), f = (m) => o ? n : (o = true, m ? u(m) : a({ done: true })), h = () => (r = new yR(), f(), { done: true }), p = (m) => (f(m), { done: true });
            if (n = { [Symbol.asyncIterator]() {
              return this;
            }, next: s, return: h, throw: p, push: l, end: f }, !e)
              return n;
            let d = n;
            return n = { [Symbol.asyncIterator]() {
              return this;
            }, next() {
              return d.next();
            }, throw(m) {
              return d.throw(m), e && (e(m), e = null), { done: true };
            }, return() {
              return d.return(), e && (e(), e = null), { done: true };
            }, push: l, end(m) {
              return d.end(m), e && (e(m), e = null), n;
            } }, n;
          };
        });
        var D6 = A((ER, bR) => {
          c();
          (function(t, e) {
            typeof ER == "object" && typeof bR < "u" ? bR.exports = function(r, n, i2, o, s) {
              for (n = n.split ? n.split(".") : n, o = 0; o < n.length; o++)
                r = r ? r[n[o]] : s;
              return r === s ? i2 : r;
            } : typeof define == "function" && define.amd ? define(function() {
              return function(r, n, i2, o, s) {
                for (n = n.split ? n.split(".") : n, o = 0; o < n.length; o++)
                  r = r ? r[n[o]] : s;
                return r === s ? i2 : r;
              };
            }) : t.dlv = function(r, n, i2, o, s) {
              for (n = n.split ? n.split(".") : n, o = 0; o < n.length; o++)
                r = r ? r[n[o]] : s;
              return r === s ? i2 : r;
            };
          })(ER);
        });
        var ei = A((F$e, iz) => {
          "use strict";
          c();
          var K6e = async function* (t, e) {
            for await (let r of t)
              yield e(r);
          };
          iz.exports = K6e;
        });
        var az = A((K$e, p0) => {
          c();
          var oz = (...t) => {
            let e;
            for (; t.length; )
              e = t.shift()(e);
            return e;
          }, _R = (t) => t && (typeof t[Symbol.asyncIterator] == "function" || typeof t[Symbol.iterator] == "function" || typeof t.next == "function"), N62 = (t) => t && typeof t.sink == "function" && _R(t.source), V6e = (t) => (e) => (t.sink(e), t.source), sz = (...t) => {
            if (N62(t[0])) {
              let e = t[0];
              t[0] = () => e.source;
            } else if (_R(t[0])) {
              let e = t[0];
              t[0] = () => e;
            }
            if (t.length > 1 && N62(t[t.length - 1]) && (t[t.length - 1] = t[t.length - 1].sink), t.length > 2)
              for (let e = 1; e < t.length - 1; e++)
                N62(t[e]) && (t[e] = V6e(t[e]));
            return oz(...t);
          };
          p0.exports = sz;
          p0.exports.pipe = sz;
          p0.exports.rawPipe = oz;
          p0.exports.isIterable = _R;
          p0.exports.isDuplex = N62;
        });
        var lz = A((X$e, uz) => {
          c();
          var vR = d0();
          uz.exports = (t) => {
            t = t || {};
            let e;
            typeof t == "function" ? (e = t, t = {}) : e = t.onEnd;
            let r = new vR(), n, i2, o, s = () => {
              if (!r.isEmpty()) {
                if (t.writev) {
                  let y, g = [];
                  for (; !r.isEmpty(); ) {
                    if (y = r.shift(), y.error)
                      throw y.error;
                    g.push(y.value);
                  }
                  return { done: y.done, value: g };
                }
                let m = r.shift();
                if (m.error)
                  throw m.error;
                return m;
              }
              return o ? { done: true } : new Promise((m, y) => {
                i2 = (g) => (i2 = null, g.error ? y(g.error) : t.writev && !g.done ? m({ done: g.done, value: [g.value] }) : m(g), n);
              });
            }, a = (m) => i2 ? i2(m) : (r.push(m), n), u = (m) => (r = new vR(), i2 ? i2({ error: m }) : (r.push({ error: m }), n)), l = (m) => o ? n : a({ done: false, value: m }), f = (m) => o ? n : (o = true, m ? u(m) : a({ done: true })), h = () => (r = new vR(), f(), { done: true }), p = (m) => (f(m), { done: true });
            if (n = { [Symbol.asyncIterator]() {
              return this;
            }, next: s, return: h, throw: p, push: l, end: f }, !e)
              return n;
            let d = n;
            return n = { [Symbol.asyncIterator]() {
              return this;
            }, next() {
              return d.next();
            }, throw(m) {
              return d.throw(m), e && (e(m), e = null), { done: true };
            }, return() {
              return d.return(), e && (e(), e = null), { done: true };
            }, push: l, end(m) {
              return d.end(m), e && (e(m), e = null), n;
            } }, n;
          };
        });
        var Fc = A((Z$e, fz) => {
          "use strict";
          c();
          var H6e = lz(), $6e = async function* (...t) {
            let e = H6e();
            setTimeout(async () => {
              try {
                await Promise.all(t.map(async (r) => {
                  for await (let n of r)
                    e.push(n);
                })), e.end();
              } catch (r) {
                e.end(r);
              }
            }, 0), yield* e;
          };
          fz.exports = $6e;
        });
        var Sz = A((gWe, vz) => {
          "use strict";
          c();
          var Z6e = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
          vz.exports = function(e, r) {
            if (r == null && (r = false), e.length < 2 || e.length > 255)
              return false;
            var n = e[e.length - 1];
            if (r) {
              if (n !== ".")
                return false;
            } else if (n === ".")
              return false;
            return Z6e.test(e);
          };
        });
        var hH = A((mYe, fH) => {
          "use strict";
          c();
          var N5e = () => {
            let t = {};
            return t.promise = new Promise((e, r) => {
              t.resolve = e, t.reject = r;
            }), t;
          };
          fH.exports = N5e;
        });
        var In = A((yYe, HR) => {
          "use strict";
          c();
          var b0 = typeof Reflect == "object" ? Reflect : null, dH = b0 && typeof b0.apply == "function" ? b0.apply : function(e, r, n) {
            return Function.prototype.apply.call(e, r, n);
          }, e5;
          b0 && typeof b0.ownKeys == "function" ? e5 = b0.ownKeys : Object.getOwnPropertySymbols ? e5 = function(e) {
            return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
          } : e5 = function(e) {
            return Object.getOwnPropertyNames(e);
          };
          function O5e(t) {
            console && console.warn && console.warn(t);
          }
          var mH = Number.isNaN || function(e) {
            return e !== e;
          };
          function lr() {
            lr.init.call(this);
          }
          HR.exports = lr;
          HR.exports.once = U5e;
          lr.EventEmitter = lr;
          lr.prototype._events = void 0;
          lr.prototype._eventsCount = 0;
          lr.prototype._maxListeners = void 0;
          var pH = 10;
          function t5(t) {
            if (typeof t != "function")
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
          }
          Object.defineProperty(lr, "defaultMaxListeners", { enumerable: true, get: function() {
            return pH;
          }, set: function(t) {
            if (typeof t != "number" || t < 0 || mH(t))
              throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            pH = t;
          } });
          lr.init = function() {
            (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
          };
          lr.prototype.setMaxListeners = function(e) {
            if (typeof e != "number" || e < 0 || mH(e))
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
            return this._maxListeners = e, this;
          };
          function yH(t) {
            return t._maxListeners === void 0 ? lr.defaultMaxListeners : t._maxListeners;
          }
          lr.prototype.getMaxListeners = function() {
            return yH(this);
          };
          lr.prototype.emit = function(e) {
            for (var r = [], n = 1; n < arguments.length; n++)
              r.push(arguments[n]);
            var i2 = e === "error", o = this._events;
            if (o !== void 0)
              i2 = i2 && o.error === void 0;
            else if (!i2)
              return false;
            if (i2) {
              var s;
              if (r.length > 0 && (s = r[0]), s instanceof Error)
                throw s;
              var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
              throw a.context = s, a;
            }
            var u = o[e];
            if (u === void 0)
              return false;
            if (typeof u == "function")
              dH(u, this, r);
            else
              for (var l = u.length, f = _H(u, l), n = 0; n < l; ++n)
                dH(f[n], this, r);
            return true;
          };
          function gH(t, e, r, n) {
            var i2, o, s;
            if (t5(r), o = t._events, o === void 0 ? (o = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (o.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), o = t._events), s = o[e]), s === void 0)
              s = o[e] = r, ++t._eventsCount;
            else if (typeof s == "function" ? s = o[e] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), i2 = yH(t), i2 > 0 && s.length > i2 && !s.warned) {
              s.warned = true;
              var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
              a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = s.length, O5e(a);
            }
            return t;
          }
          lr.prototype.addListener = function(e, r) {
            return gH(this, e, r, false);
          };
          lr.prototype.on = lr.prototype.addListener;
          lr.prototype.prependListener = function(e, r) {
            return gH(this, e, r, true);
          };
          function L5e() {
            if (!this.fired)
              return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
          }
          function wH(t, e, r) {
            var n = { fired: false, wrapFn: void 0, target: t, type: e, listener: r }, i2 = L5e.bind(n);
            return i2.listener = r, n.wrapFn = i2, i2;
          }
          lr.prototype.once = function(e, r) {
            return t5(r), this.on(e, wH(this, e, r)), this;
          };
          lr.prototype.prependOnceListener = function(e, r) {
            return t5(r), this.prependListener(e, wH(this, e, r)), this;
          };
          lr.prototype.removeListener = function(e, r) {
            var n, i2, o, s, a;
            if (t5(r), i2 = this._events, i2 === void 0)
              return this;
            if (n = i2[e], n === void 0)
              return this;
            if (n === r || n.listener === r)
              --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i2[e], i2.removeListener && this.emit("removeListener", e, n.listener || r));
            else if (typeof n != "function") {
              for (o = -1, s = n.length - 1; s >= 0; s--)
                if (n[s] === r || n[s].listener === r) {
                  a = n[s].listener, o = s;
                  break;
                }
              if (o < 0)
                return this;
              o === 0 ? n.shift() : B5e(n, o), n.length === 1 && (i2[e] = n[0]), i2.removeListener !== void 0 && this.emit("removeListener", e, a || r);
            }
            return this;
          };
          lr.prototype.off = lr.prototype.removeListener;
          lr.prototype.removeAllListeners = function(e) {
            var r, n, i2;
            if (n = this._events, n === void 0)
              return this;
            if (n.removeListener === void 0)
              return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
            if (arguments.length === 0) {
              var o = Object.keys(n), s;
              for (i2 = 0; i2 < o.length; ++i2)
                s = o[i2], s !== "removeListener" && this.removeAllListeners(s);
              return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
            }
            if (r = n[e], typeof r == "function")
              this.removeListener(e, r);
            else if (r !== void 0)
              for (i2 = r.length - 1; i2 >= 0; i2--)
                this.removeListener(e, r[i2]);
            return this;
          };
          function EH(t, e, r) {
            var n = t._events;
            if (n === void 0)
              return [];
            var i2 = n[e];
            return i2 === void 0 ? [] : typeof i2 == "function" ? r ? [i2.listener || i2] : [i2] : r ? M5e(i2) : _H(i2, i2.length);
          }
          lr.prototype.listeners = function(e) {
            return EH(this, e, true);
          };
          lr.prototype.rawListeners = function(e) {
            return EH(this, e, false);
          };
          lr.listenerCount = function(t, e) {
            return typeof t.listenerCount == "function" ? t.listenerCount(e) : bH.call(t, e);
          };
          lr.prototype.listenerCount = bH;
          function bH(t) {
            var e = this._events;
            if (e !== void 0) {
              var r = e[t];
              if (typeof r == "function")
                return 1;
              if (r !== void 0)
                return r.length;
            }
            return 0;
          }
          lr.prototype.eventNames = function() {
            return this._eventsCount > 0 ? e5(this._events) : [];
          };
          function _H(t, e) {
            for (var r = new Array(e), n = 0; n < e; ++n)
              r[n] = t[n];
            return r;
          }
          function B5e(t, e) {
            for (; e + 1 < t.length; e++)
              t[e] = t[e + 1];
            t.pop();
          }
          function M5e(t) {
            for (var e = new Array(t.length), r = 0; r < e.length; ++r)
              e[r] = t[r].listener || t[r];
            return e;
          }
          function U5e(t, e) {
            return new Promise(function(r, n) {
              function i2(s) {
                t.removeListener(e, o), n(s);
              }
              function o() {
                typeof t.removeListener == "function" && t.removeListener("error", i2), r([].slice.call(arguments));
              }
              vH(t, e, o, { once: true }), e !== "error" && F5e(t, i2, { once: true });
            });
          }
          function F5e(t, e, r) {
            typeof t.on == "function" && vH(t, "error", e, r);
          }
          function vH(t, e, r, n) {
            if (typeof t.on == "function")
              n.once ? t.once(e, r) : t.on(e, r);
            else if (typeof t.addEventListener == "function")
              t.addEventListener(e, function i2(o) {
                n.once && t.removeEventListener(e, i2), r(o);
              });
            else
              throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
          }
        });
        var n5 = A((gYe, SH) => {
          "use strict";
          c();
          var r5 = hH(), K5e = In().EventEmitter;
          async function* V5e(t, e = {}) {
            let r = e.concurrency || 1 / 0;
            r < 1 && (r = 1 / 0);
            let n = e.ordered == null ? false : e.ordered, i2 = new K5e(), o = [], s = r5(), a = r5(), u = false, l, f = false;
            i2.on("task-complete", () => {
              a.resolve();
            }), Promise.resolve().then(async () => {
              try {
                for await (let m of t) {
                  if (o.length === r && (s = r5(), await s.promise), f)
                    break;
                  let y = { done: false };
                  o.push(y), m().then((g) => {
                    y.done = true, y.ok = true, y.value = g, i2.emit("task-complete");
                  }, (g) => {
                    y.done = true, y.err = g, i2.emit("task-complete");
                  });
                }
                u = true, i2.emit("task-complete");
              } catch (m) {
                l = m, i2.emit("task-complete");
              }
            });
            function h() {
              return Boolean(n ? o[0] && o[0].done : o.find((m) => m.done));
            }
            function* p() {
              for (; o.length && o[0].done; ) {
                let m = o[0];
                if (o.shift(), m.ok)
                  yield m.value;
                else
                  throw f = true, s.resolve(), m.err;
                s.resolve();
              }
            }
            function* d() {
              for (; h(); )
                for (let m = 0; m < o.length; m++)
                  if (o[m].done) {
                    let y = o[m];
                    if (o.splice(m, 1), m--, y.ok)
                      yield y.value;
                    else
                      throw f = true, s.resolve(), y.err;
                    s.resolve();
                  }
            }
            for (; ; ) {
              if (h() || (a = r5(), await a.promise), l)
                throw l;
              if (n ? yield* p() : yield* d(), u && o.length === 0)
                break;
            }
          }
          SH.exports = V5e;
        });
        var v0 = A((MYe, kH) => {
          "use strict";
          c();
          async function* G5e(t, e = {}) {
            let r = t.getReader();
            try {
              for (; ; ) {
                let n = await r.read();
                if (n.done)
                  return;
                yield n.value;
              }
            } finally {
              e.preventCancel !== true && r.cancel(), r.releaseLock();
            }
          }
          kH.exports = G5e;
        });
        var LH = A((UYe, OH) => {
          "use strict";
          c();
          var NH = v0();
          function W5e(t) {
            return typeof t.stream == "function" ? NH(t.stream()) : NH(new Response(t).body);
          }
          OH.exports = W5e;
        });
        var S0 = A((FYe, BH) => {
          "use strict";
          c();
          function j5e(t) {
            let [e, r] = t[Symbol.asyncIterator] ? [t[Symbol.asyncIterator](), Symbol.asyncIterator] : [t[Symbol.iterator](), Symbol.iterator], n = [];
            return { peek: () => e.next(), push: (i2) => {
              n.push(i2);
            }, next: () => n.length ? { done: false, value: n.shift() } : e.next(), [r]() {
              return this;
            } };
          }
          BH.exports = j5e;
        });
        var h5 = A((ZYe, jH) => {
          "use strict";
          c();
          async function* Y5e(t, e = 1) {
            let r = [];
            e < 1 && (e = 1);
            for await (let n of t)
              for (r.push(n); r.length >= e; )
                yield r.slice(0, e), r = r.slice(e);
            for (; r.length; )
              yield r.slice(0, e), r = r.slice(e);
          }
          jH.exports = Y5e;
        });
        var d5 = A((JYe, YH) => {
          "use strict";
          c();
          var Q5e = h5();
          async function* X5e(t, e = 1) {
            for await (let r of Q5e(t, e)) {
              let n = r.map((i2) => i2().then((o) => ({ ok: true, value: o }), (o) => ({ ok: false, err: o })));
              for (let i2 = 0; i2 < n.length; i2++) {
                let o = await n[i2];
                if (o.ok)
                  yield o.value;
                else
                  throw o.err;
              }
            }
          }
          YH.exports = X5e;
        });
        var QH = A((hy, p5) => {
          c();
          (function(t, e) {
            "use strict";
            var r = { version: "3.0.0", x86: {}, x64: {}, inputValidation: true };
            function n(d) {
              if (!Array.isArray(d) && !ArrayBuffer.isView(d))
                return false;
              for (var m = 0; m < d.length; m++)
                if (!Number.isInteger(d[m]) || d[m] < 0 || d[m] > 255)
                  return false;
              return true;
            }
            function i2(d, m) {
              return (d & 65535) * m + (((d >>> 16) * m & 65535) << 16);
            }
            function o(d, m) {
              return d << m | d >>> 32 - m;
            }
            function s(d) {
              return d ^= d >>> 16, d = i2(d, 2246822507), d ^= d >>> 13, d = i2(d, 3266489909), d ^= d >>> 16, d;
            }
            function a(d, m) {
              d = [d[0] >>> 16, d[0] & 65535, d[1] >>> 16, d[1] & 65535], m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
              var y = [0, 0, 0, 0];
              return y[3] += d[3] + m[3], y[2] += y[3] >>> 16, y[3] &= 65535, y[2] += d[2] + m[2], y[1] += y[2] >>> 16, y[2] &= 65535, y[1] += d[1] + m[1], y[0] += y[1] >>> 16, y[1] &= 65535, y[0] += d[0] + m[0], y[0] &= 65535, [y[0] << 16 | y[1], y[2] << 16 | y[3]];
            }
            function u(d, m) {
              d = [d[0] >>> 16, d[0] & 65535, d[1] >>> 16, d[1] & 65535], m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
              var y = [0, 0, 0, 0];
              return y[3] += d[3] * m[3], y[2] += y[3] >>> 16, y[3] &= 65535, y[2] += d[2] * m[3], y[1] += y[2] >>> 16, y[2] &= 65535, y[2] += d[3] * m[2], y[1] += y[2] >>> 16, y[2] &= 65535, y[1] += d[1] * m[3], y[0] += y[1] >>> 16, y[1] &= 65535, y[1] += d[2] * m[2], y[0] += y[1] >>> 16, y[1] &= 65535, y[1] += d[3] * m[1], y[0] += y[1] >>> 16, y[1] &= 65535, y[0] += d[0] * m[3] + d[1] * m[2] + d[2] * m[1] + d[3] * m[0], y[0] &= 65535, [y[0] << 16 | y[1], y[2] << 16 | y[3]];
            }
            function l(d, m) {
              return m %= 64, m === 32 ? [d[1], d[0]] : m < 32 ? [d[0] << m | d[1] >>> 32 - m, d[1] << m | d[0] >>> 32 - m] : (m -= 32, [d[1] << m | d[0] >>> 32 - m, d[0] << m | d[1] >>> 32 - m]);
            }
            function f(d, m) {
              return m %= 64, m === 0 ? d : m < 32 ? [d[0] << m | d[1] >>> 32 - m, d[1] << m] : [d[1] << m - 32, 0];
            }
            function h(d, m) {
              return [d[0] ^ m[0], d[1] ^ m[1]];
            }
            function p(d) {
              return d = h(d, [0, d[0] >>> 1]), d = u(d, [4283543511, 3981806797]), d = h(d, [0, d[0] >>> 1]), d = u(d, [3301882366, 444984403]), d = h(d, [0, d[0] >>> 1]), d;
            }
            r.x86.hash32 = function(d, m) {
              if (r.inputValidation && !n(d))
                return e;
              m = m || 0;
              for (var y = d.length % 4, g = d.length - y, E = m, b = 0, v = 3432918353, S = 461845907, x = 0; x < g; x = x + 4)
                b = d[x] | d[x + 1] << 8 | d[x + 2] << 16 | d[x + 3] << 24, b = i2(b, v), b = o(b, 15), b = i2(b, S), E ^= b, E = o(E, 13), E = i2(E, 5) + 3864292196;
              switch (b = 0, y) {
                case 3:
                  b ^= d[x + 2] << 16;
                case 2:
                  b ^= d[x + 1] << 8;
                case 1:
                  b ^= d[x], b = i2(b, v), b = o(b, 15), b = i2(b, S), E ^= b;
              }
              return E ^= d.length, E = s(E), E >>> 0;
            }, r.x86.hash128 = function(d, m) {
              if (r.inputValidation && !n(d))
                return e;
              m = m || 0;
              for (var y = d.length % 16, g = d.length - y, E = m, b = m, v = m, S = m, x = 0, T = 0, R = 0, O = 0, F = 597399067, z = 2869860233, W = 951274213, se = 2716044179, re2 = 0; re2 < g; re2 = re2 + 16)
                x = d[re2] | d[re2 + 1] << 8 | d[re2 + 2] << 16 | d[re2 + 3] << 24, T = d[re2 + 4] | d[re2 + 5] << 8 | d[re2 + 6] << 16 | d[re2 + 7] << 24, R = d[re2 + 8] | d[re2 + 9] << 8 | d[re2 + 10] << 16 | d[re2 + 11] << 24, O = d[re2 + 12] | d[re2 + 13] << 8 | d[re2 + 14] << 16 | d[re2 + 15] << 24, x = i2(x, F), x = o(x, 15), x = i2(x, z), E ^= x, E = o(E, 19), E += b, E = i2(E, 5) + 1444728091, T = i2(T, z), T = o(T, 16), T = i2(T, W), b ^= T, b = o(b, 17), b += v, b = i2(b, 5) + 197830471, R = i2(R, W), R = o(R, 17), R = i2(R, se), v ^= R, v = o(v, 15), v += S, v = i2(v, 5) + 2530024501, O = i2(O, se), O = o(O, 18), O = i2(O, F), S ^= O, S = o(S, 13), S += E, S = i2(S, 5) + 850148119;
              switch (x = 0, T = 0, R = 0, O = 0, y) {
                case 15:
                  O ^= d[re2 + 14] << 16;
                case 14:
                  O ^= d[re2 + 13] << 8;
                case 13:
                  O ^= d[re2 + 12], O = i2(O, se), O = o(O, 18), O = i2(O, F), S ^= O;
                case 12:
                  R ^= d[re2 + 11] << 24;
                case 11:
                  R ^= d[re2 + 10] << 16;
                case 10:
                  R ^= d[re2 + 9] << 8;
                case 9:
                  R ^= d[re2 + 8], R = i2(R, W), R = o(R, 17), R = i2(R, se), v ^= R;
                case 8:
                  T ^= d[re2 + 7] << 24;
                case 7:
                  T ^= d[re2 + 6] << 16;
                case 6:
                  T ^= d[re2 + 5] << 8;
                case 5:
                  T ^= d[re2 + 4], T = i2(T, z), T = o(T, 16), T = i2(T, W), b ^= T;
                case 4:
                  x ^= d[re2 + 3] << 24;
                case 3:
                  x ^= d[re2 + 2] << 16;
                case 2:
                  x ^= d[re2 + 1] << 8;
                case 1:
                  x ^= d[re2], x = i2(x, F), x = o(x, 15), x = i2(x, z), E ^= x;
              }
              return E ^= d.length, b ^= d.length, v ^= d.length, S ^= d.length, E += b, E += v, E += S, b += E, v += E, S += E, E = s(E), b = s(b), v = s(v), S = s(S), E += b, E += v, E += S, b += E, v += E, S += E, ("00000000" + (E >>> 0).toString(16)).slice(-8) + ("00000000" + (b >>> 0).toString(16)).slice(-8) + ("00000000" + (v >>> 0).toString(16)).slice(-8) + ("00000000" + (S >>> 0).toString(16)).slice(-8);
            }, r.x64.hash128 = function(d, m) {
              if (r.inputValidation && !n(d))
                return e;
              m = m || 0;
              for (var y = d.length % 16, g = d.length - y, E = [0, m], b = [0, m], v = [0, 0], S = [0, 0], x = [2277735313, 289559509], T = [1291169091, 658871167], R = 0; R < g; R = R + 16)
                v = [d[R + 4] | d[R + 5] << 8 | d[R + 6] << 16 | d[R + 7] << 24, d[R] | d[R + 1] << 8 | d[R + 2] << 16 | d[R + 3] << 24], S = [d[R + 12] | d[R + 13] << 8 | d[R + 14] << 16 | d[R + 15] << 24, d[R + 8] | d[R + 9] << 8 | d[R + 10] << 16 | d[R + 11] << 24], v = u(v, x), v = l(v, 31), v = u(v, T), E = h(E, v), E = l(E, 27), E = a(E, b), E = a(u(E, [0, 5]), [0, 1390208809]), S = u(S, T), S = l(S, 33), S = u(S, x), b = h(b, S), b = l(b, 31), b = a(b, E), b = a(u(b, [0, 5]), [0, 944331445]);
              switch (v = [0, 0], S = [0, 0], y) {
                case 15:
                  S = h(S, f([0, d[R + 14]], 48));
                case 14:
                  S = h(S, f([0, d[R + 13]], 40));
                case 13:
                  S = h(S, f([0, d[R + 12]], 32));
                case 12:
                  S = h(S, f([0, d[R + 11]], 24));
                case 11:
                  S = h(S, f([0, d[R + 10]], 16));
                case 10:
                  S = h(S, f([0, d[R + 9]], 8));
                case 9:
                  S = h(S, [0, d[R + 8]]), S = u(S, T), S = l(S, 33), S = u(S, x), b = h(b, S);
                case 8:
                  v = h(v, f([0, d[R + 7]], 56));
                case 7:
                  v = h(v, f([0, d[R + 6]], 48));
                case 6:
                  v = h(v, f([0, d[R + 5]], 40));
                case 5:
                  v = h(v, f([0, d[R + 4]], 32));
                case 4:
                  v = h(v, f([0, d[R + 3]], 24));
                case 3:
                  v = h(v, f([0, d[R + 2]], 16));
                case 2:
                  v = h(v, f([0, d[R + 1]], 8));
                case 1:
                  v = h(v, [0, d[R]]), v = u(v, x), v = l(v, 31), v = u(v, T), E = h(E, v);
              }
              return E = h(E, [0, d.length]), b = h(b, [0, d.length]), E = a(E, b), b = a(b, E), E = p(E), b = p(b), E = a(E, b), b = a(b, E), ("00000000" + (E[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (E[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (b[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (b[1] >>> 0).toString(16)).slice(-8);
            }, typeof hy < "u" ? (typeof p5 < "u" && p5.exports && (hy = p5.exports = r), hy.murmurHash3 = r) : typeof define == "function" && define.amd ? define([], function() {
              return r;
            }) : (r._murmurHash3 = t.murmurHash3, r.noConflict = function() {
              return t.murmurHash3 = r._murmurHash3, r._murmurHash3 = e, r.noConflict = e, r;
            }, t.murmurHash3 = r);
          })(hy);
        });
        var ZH = A((eQe, XH) => {
          c();
          XH.exports = QH();
        });
        var YR = A((PQe, d$) => {
          "use strict";
          c();
          var { Buffer: $s } = _i(), h$ = Symbol.for("BufferList");
          function Rr(t) {
            if (!(this instanceof Rr))
              return new Rr(t);
            Rr._init.call(this, t);
          }
          Rr._init = function(e) {
            Object.defineProperty(this, h$, { value: true }), this._bufs = [], this.length = 0, e && this.append(e);
          };
          Rr.prototype._new = function(e) {
            return new Rr(e);
          };
          Rr.prototype._offset = function(e) {
            if (e === 0)
              return [0, 0];
            let r = 0;
            for (let n = 0; n < this._bufs.length; n++) {
              let i2 = r + this._bufs[n].length;
              if (e < i2 || n === this._bufs.length - 1)
                return [n, e - r];
              r = i2;
            }
          };
          Rr.prototype._reverseOffset = function(t) {
            let e = t[0], r = t[1];
            for (let n = 0; n < e; n++)
              r += this._bufs[n].length;
            return r;
          };
          Rr.prototype.get = function(e) {
            if (e > this.length || e < 0)
              return;
            let r = this._offset(e);
            return this._bufs[r[0]][r[1]];
          };
          Rr.prototype.slice = function(e, r) {
            return typeof e == "number" && e < 0 && (e += this.length), typeof r == "number" && r < 0 && (r += this.length), this.copy(null, 0, e, r);
          };
          Rr.prototype.copy = function(e, r, n, i2) {
            if ((typeof n != "number" || n < 0) && (n = 0), (typeof i2 != "number" || i2 > this.length) && (i2 = this.length), n >= this.length || i2 <= 0)
              return e || $s.alloc(0);
            let o = !!e, s = this._offset(n), a = i2 - n, u = a, l = o && r || 0, f = s[1];
            if (n === 0 && i2 === this.length) {
              if (!o)
                return this._bufs.length === 1 ? this._bufs[0] : $s.concat(this._bufs, this.length);
              for (let h = 0; h < this._bufs.length; h++)
                this._bufs[h].copy(e, l), l += this._bufs[h].length;
              return e;
            }
            if (u <= this._bufs[s[0]].length - f)
              return o ? this._bufs[s[0]].copy(e, r, f, f + u) : this._bufs[s[0]].slice(f, f + u);
            o || (e = $s.allocUnsafe(a));
            for (let h = s[0]; h < this._bufs.length; h++) {
              let p = this._bufs[h].length - f;
              if (u > p)
                this._bufs[h].copy(e, l, f), l += p;
              else {
                this._bufs[h].copy(e, l, f, f + u), l += p;
                break;
              }
              u -= p, f && (f = 0);
            }
            return e.length > l ? e.slice(0, l) : e;
          };
          Rr.prototype.shallowSlice = function(e, r) {
            if (e = e || 0, r = typeof r != "number" ? this.length : r, e < 0 && (e += this.length), r < 0 && (r += this.length), e === r)
              return this._new();
            let n = this._offset(e), i2 = this._offset(r), o = this._bufs.slice(n[0], i2[0] + 1);
            return i2[1] === 0 ? o.pop() : o[o.length - 1] = o[o.length - 1].slice(0, i2[1]), n[1] !== 0 && (o[0] = o[0].slice(n[1])), this._new(o);
          };
          Rr.prototype.toString = function(e, r, n) {
            return this.slice(r, n).toString(e);
          };
          Rr.prototype.consume = function(e) {
            if (e = Math.trunc(e), Number.isNaN(e) || e <= 0)
              return this;
            for (; this._bufs.length; )
              if (e >= this._bufs[0].length)
                e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
              else {
                this._bufs[0] = this._bufs[0].slice(e), this.length -= e;
                break;
              }
            return this;
          };
          Rr.prototype.duplicate = function() {
            let e = this._new();
            for (let r = 0; r < this._bufs.length; r++)
              e.append(this._bufs[r]);
            return e;
          };
          Rr.prototype.append = function(e) {
            if (e == null)
              return this;
            if (e.buffer)
              this._appendBuffer($s.from(e.buffer, e.byteOffset, e.byteLength));
            else if (Array.isArray(e))
              for (let r = 0; r < e.length; r++)
                this.append(e[r]);
            else if (this._isBufferList(e))
              for (let r = 0; r < e._bufs.length; r++)
                this.append(e._bufs[r]);
            else
              typeof e == "number" && (e = e.toString()), this._appendBuffer($s.from(e));
            return this;
          };
          Rr.prototype._appendBuffer = function(e) {
            this._bufs.push(e), this.length += e.length;
          };
          Rr.prototype.indexOf = function(t, e, r) {
            if (r === void 0 && typeof e == "string" && (r = e, e = void 0), typeof t == "function" || Array.isArray(t))
              throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
            if (typeof t == "number" ? t = $s.from([t]) : typeof t == "string" ? t = $s.from(t, r) : this._isBufferList(t) ? t = t.slice() : Array.isArray(t.buffer) ? t = $s.from(t.buffer, t.byteOffset, t.byteLength) : $s.isBuffer(t) || (t = $s.from(t)), e = Number(e || 0), isNaN(e) && (e = 0), e < 0 && (e = this.length + e), e < 0 && (e = 0), t.length === 0)
              return e > this.length ? this.length : e;
            let n = this._offset(e), i2 = n[0], o = n[1];
            for (; i2 < this._bufs.length; i2++) {
              let s = this._bufs[i2];
              for (; o < s.length; )
                if (s.length - o >= t.length) {
                  let u = s.indexOf(t, o);
                  if (u !== -1)
                    return this._reverseOffset([i2, u]);
                  o = s.length - t.length + 1;
                } else {
                  let u = this._reverseOffset([i2, o]);
                  if (this._match(u, t))
                    return u;
                  o++;
                }
              o = 0;
            }
            return -1;
          };
          Rr.prototype._match = function(t, e) {
            if (this.length - t < e.length)
              return false;
            for (let r = 0; r < e.length; r++)
              if (this.get(t + r) !== e[r])
                return false;
            return true;
          };
          (function() {
            let t = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
            for (let e in t)
              (function(r) {
                t[r] === null ? Rr.prototype[r] = function(n, i2) {
                  return this.slice(n, n + i2)[r](0, i2);
                } : Rr.prototype[r] = function(n = 0) {
                  return this.slice(n, n + t[r])[r](0);
                };
              })(e);
          })();
          Rr.prototype._isBufferList = function(e) {
            return e instanceof Rr || Rr.isBufferList(e);
          };
          Rr.isBufferList = function(e) {
            return e != null && e[h$];
          };
          d$.exports = Rr;
        });
        var m$ = A((DQe, p$) => {
          c();
          var QR = class {
            constructor(e, r = 12, n = 8 * 1024, i2 = 32 * 1024, o = 64, s) {
              this.bits = r, this.min = n, this.max = i2, this.asModule = e, this.rabin = new e.Rabin(r, n, i2, o, s), this.polynomial = s;
            }
            fingerprint(e) {
              let { __retain: r, __release: n, __allocArray: i2, __getInt32Array: o, Int32Array_ID: s, Uint8Array_ID: a } = this.asModule, u = new Int32Array(Math.ceil(e.length / this.min)), l = r(i2(s, u)), f = r(i2(a, e)), h = this.rabin.fingerprint(f, l), p = o(h);
              n(f), n(l);
              let d = p.indexOf(0);
              return d >= 0 ? p.subarray(0, d) : p;
            }
          };
          p$.exports = QR;
        });
        var _$ = A((my) => {
          "use strict";
          c();
          var f8e = typeof BigUint64Array < "u", dy = Symbol(), py = 1024;
          function y$(t, e) {
            let r = new Uint32Array(t), n = new Uint16Array(t);
            var i2 = r[e + -4 >>> 2] >>> 1, o = e >>> 1;
            if (i2 <= py)
              return String.fromCharCode.apply(String, n.subarray(o, o + i2));
            let s = [];
            do {
              let a = n[o + py - 1], u = a >= 55296 && a < 56320 ? py - 1 : py;
              s.push(String.fromCharCode.apply(String, n.subarray(o, o += u))), i2 -= u;
            } while (i2 > py);
            return s.join("") + String.fromCharCode.apply(String, n.subarray(o, o + i2));
          }
          function XR(t) {
            let e = {};
            function r(i2, o) {
              return i2 ? y$(i2.buffer, o) : "<yet unknown>";
            }
            let n = t.env = t.env || {};
            return n.abort = n.abort || function(o, s, a, u) {
              let l = e.memory || n.memory;
              throw Error("abort: " + r(l, o) + " at " + r(l, s) + ":" + a + ":" + u);
            }, n.trace = n.trace || function(o, s) {
              let a = e.memory || n.memory;
              console.log("trace: " + r(a, o) + (s ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + s).join(", "));
            }, t.Math = t.Math || Math, t.Date = t.Date || Date, e;
          }
          function ZR(t, e) {
            let r = e.exports, n = r.memory, i2 = r.table, o = r.__alloc, s = r.__retain, a = r.__rtti_base || -1;
            function u(T) {
              let R = new Uint32Array(n.buffer), O = R[a >>> 2];
              if ((T >>>= 0) >= O)
                throw Error("invalid id: " + T);
              return R[(a + 4 >>> 2) + T * 2];
            }
            function l(T) {
              let R = new Uint32Array(n.buffer), O = R[a >>> 2];
              if ((T >>>= 0) >= O)
                throw Error("invalid id: " + T);
              return R[(a + 4 >>> 2) + T * 2 + 1];
            }
            function f(T) {
              return 31 - Math.clz32(T >>> 5 & 31);
            }
            function h(T) {
              return 31 - Math.clz32(T >>> 14 & 31);
            }
            function p(T) {
              let R = T.length, O = o(R << 1, 1), F = new Uint16Array(n.buffer);
              for (var z = 0, W = O >>> 1; z < R; ++z)
                F[W + z] = T.charCodeAt(z);
              return O;
            }
            t.__allocString = p;
            function d(T) {
              let R = n.buffer;
              if (new Uint32Array(R)[T + -8 >>> 2] !== 1)
                throw Error("not a string: " + T);
              return y$(R, T);
            }
            t.__getString = d;
            function m(T, R, O) {
              let F = n.buffer;
              if (O)
                switch (T) {
                  case 2:
                    return new Float32Array(F);
                  case 3:
                    return new Float64Array(F);
                }
              else
                switch (T) {
                  case 0:
                    return new (R ? Int8Array : Uint8Array)(F);
                  case 1:
                    return new (R ? Int16Array : Uint16Array)(F);
                  case 2:
                    return new (R ? Int32Array : Uint32Array)(F);
                  case 3:
                    return new (R ? BigInt64Array : BigUint64Array)(F);
                }
              throw Error("unsupported align: " + T);
            }
            function y(T, R) {
              let O = u(T);
              if (!(O & 3))
                throw Error("not an array: " + T + " @ " + O);
              let F = f(O), z = R.length, W = o(z << F, 0), se = o(O & 2 ? 16 : 12, T), re2 = new Uint32Array(n.buffer);
              re2[se + 0 >>> 2] = s(W), re2[se + 4 >>> 2] = W, re2[se + 8 >>> 2] = z << F, O & 2 && (re2[se + 12 >>> 2] = z);
              let Ge = m(F, O & 1024, O & 2048);
              if (O & 8192)
                for (let ge = 0; ge < z; ++ge)
                  Ge[(W >>> F) + ge] = s(R[ge]);
              else
                Ge.set(R, W >>> F);
              return se;
            }
            t.__allocArray = y;
            function g(T) {
              let R = new Uint32Array(n.buffer), O = R[T + -8 >>> 2], F = u(O);
              if (!(F & 1))
                throw Error("not an array: " + O);
              let z = f(F);
              var W = R[T + 4 >>> 2];
              let se = F & 2 ? R[T + 12 >>> 2] : R[W + -4 >>> 2] >>> z;
              return m(z, F & 1024, F & 2048).subarray(W >>>= z, W + se);
            }
            t.__getArrayView = g;
            function E(T) {
              let R = g(T), O = R.length, F = new Array(O);
              for (let z = 0; z < O; z++)
                F[z] = R[z];
              return F;
            }
            t.__getArray = E;
            function b(T) {
              let R = n.buffer, O = new Uint32Array(R)[T + -4 >>> 2];
              return R.slice(T, T + O);
            }
            t.__getArrayBuffer = b;
            function v(T, R, O) {
              return new T(S(T, R, O));
            }
            function S(T, R, O) {
              let F = n.buffer, z = new Uint32Array(F), W = z[O + 4 >>> 2];
              return new T(F, W, z[W + -4 >>> 2] >>> R);
            }
            t.__getInt8Array = v.bind(null, Int8Array, 0), t.__getInt8ArrayView = S.bind(null, Int8Array, 0), t.__getUint8Array = v.bind(null, Uint8Array, 0), t.__getUint8ArrayView = S.bind(null, Uint8Array, 0), t.__getUint8ClampedArray = v.bind(null, Uint8ClampedArray, 0), t.__getUint8ClampedArrayView = S.bind(null, Uint8ClampedArray, 0), t.__getInt16Array = v.bind(null, Int16Array, 1), t.__getInt16ArrayView = S.bind(null, Int16Array, 1), t.__getUint16Array = v.bind(null, Uint16Array, 1), t.__getUint16ArrayView = S.bind(null, Uint16Array, 1), t.__getInt32Array = v.bind(null, Int32Array, 2), t.__getInt32ArrayView = S.bind(null, Int32Array, 2), t.__getUint32Array = v.bind(null, Uint32Array, 2), t.__getUint32ArrayView = S.bind(null, Uint32Array, 2), f8e && (t.__getInt64Array = v.bind(null, BigInt64Array, 3), t.__getInt64ArrayView = S.bind(null, BigInt64Array, 3), t.__getUint64Array = v.bind(null, BigUint64Array, 3), t.__getUint64ArrayView = S.bind(null, BigUint64Array, 3)), t.__getFloat32Array = v.bind(null, Float32Array, 2), t.__getFloat32ArrayView = S.bind(null, Float32Array, 2), t.__getFloat64Array = v.bind(null, Float64Array, 3), t.__getFloat64ArrayView = S.bind(null, Float64Array, 3);
            function x(T, R) {
              let O = new Uint32Array(n.buffer);
              var F = O[T + -8 >>> 2];
              if (F <= O[a >>> 2])
                do
                  if (F == R)
                    return true;
                while (F = l(F));
              return false;
            }
            return t.__instanceof = x, t.memory = t.memory || n, t.table = t.table || i2, b$(r, t);
          }
          function g$(t) {
            return typeof Response < "u" && t instanceof Response;
          }
          async function w$(t, e) {
            return g$(t = await t) ? E$(t, e) : ZR(XR(e || (e = {})), await WebAssembly.instantiate(t instanceof WebAssembly.Module ? t : await WebAssembly.compile(t), e));
          }
          my.instantiate = w$;
          function h8e(t, e) {
            return ZR(XR(e || (e = {})), new WebAssembly.Instance(t instanceof WebAssembly.Module ? t : new WebAssembly.Module(t), e));
          }
          my.instantiateSync = h8e;
          async function E$(t, e) {
            return WebAssembly.instantiateStreaming ? ZR(XR(e || (e = {})), (await WebAssembly.instantiateStreaming(t, e)).instance) : w$(g$(t = await t) ? t.arrayBuffer() : t, e);
          }
          my.instantiateStreaming = E$;
          function b$(t, e) {
            var r = e ? Object.create(e) : {}, n = t.__argumentsLength ? function(i2) {
              t.__argumentsLength.value = i2;
            } : t.__setArgumentsLength || t.__setargc || function() {
            };
            for (let i2 in t) {
              if (!Object.prototype.hasOwnProperty.call(t, i2))
                continue;
              let o = t[i2], s = i2.split("."), a = r;
              for (; s.length > 1; ) {
                let f = s.shift();
                Object.prototype.hasOwnProperty.call(a, f) || (a[f] = {}), a = a[f];
              }
              let u = s[0], l = u.indexOf("#");
              if (l >= 0) {
                let f = u.substring(0, l), h = a[f];
                if (typeof h > "u" || !h.prototype) {
                  let p = function(...d) {
                    return p.wrap(p.prototype.constructor(0, ...d));
                  };
                  p.prototype = { valueOf: function() {
                    return this[dy];
                  } }, p.wrap = function(d) {
                    return Object.create(p.prototype, { [dy]: { value: d, writable: false } });
                  }, h && Object.getOwnPropertyNames(h).forEach((d) => Object.defineProperty(p, d, Object.getOwnPropertyDescriptor(h, d))), a[f] = p;
                }
                if (u = u.substring(l + 1), a = a[f].prototype, /^(get|set):/.test(u)) {
                  if (!Object.prototype.hasOwnProperty.call(a, u = u.substring(4))) {
                    let p = t[i2.replace("set:", "get:")], d = t[i2.replace("get:", "set:")];
                    Object.defineProperty(a, u, { get: function() {
                      return p(this[dy]);
                    }, set: function(m) {
                      d(this[dy], m);
                    }, enumerable: true });
                  }
                } else
                  u === "constructor" ? (a[u] = (...p) => (n(p.length), o(...p))).original = o : (a[u] = function(...p) {
                    return n(p.length), o(this[dy], ...p);
                  }).original = o;
              } else
                /^(get|set):/.test(u) ? Object.prototype.hasOwnProperty.call(a, u = u.substring(4)) || Object.defineProperty(a, u, { get: t[i2.replace("set:", "get:")], set: t[i2.replace("get:", "set:")], enumerable: true }) : typeof o == "function" && o !== n ? (a[u] = (...f) => (n(f.length), o(...f))).original = o : a[u] = o;
            }
            return r;
          }
          my.demangle = b$;
        });
        var S$ = A((NQe, v$) => {
          c();
          var { instantiate: d8e } = _$();
          JR.supported = typeof WebAssembly < "u";
          function JR(t = {}) {
            if (!JR.supported)
              return null;
            var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
            return d8e(new Response(new Blob([e], { type: "application/wasm" })), t);
          }
          v$.exports = JR;
        });
        var A$ = A((OQe, R$) => {
          c();
          var x$ = m$(), p8e = S$(), m8e = async (t, e, r, n, i2) => {
            let o = await p8e();
            return new x$(o, t, e, r, n, i2);
          };
          R$.exports = { Rabin: x$, create: m8e };
        });
        var L$ = A((ZQe, O$) => {
          "use strict";
          c();
          O$.exports = class {
            constructor() {
              this._bitArrays = [], this._data = [], this._length = 0, this._changedLength = false, this._changedData = false;
            }
            set(e, r) {
              let n = this._internalPositionFor(e, false);
              if (r === void 0)
                n !== -1 && (this._unsetInternalPos(n), this._unsetBit(e), this._changedLength = true, this._changedData = true);
              else {
                let i2 = false;
                n === -1 ? (n = this._data.length, this._setBit(e), this._changedData = true) : i2 = true, this._setInternalPos(n, e, r, i2), this._changedLength = true;
              }
            }
            unset(e) {
              this.set(e, void 0);
            }
            get(e) {
              this._sortData();
              let r = this._internalPositionFor(e, true);
              if (r !== -1)
                return this._data[r][1];
            }
            push(e) {
              return this.set(this.length, e), this.length;
            }
            get length() {
              if (this._sortData(), this._changedLength) {
                let e = this._data[this._data.length - 1];
                this._length = e ? e[0] + 1 : 0, this._changedLength = false;
              }
              return this._length;
            }
            forEach(e) {
              let r = 0;
              for (; r < this.length; )
                e(this.get(r), r, this), r++;
            }
            map(e) {
              let r = 0, n = new Array(this.length);
              for (; r < this.length; )
                n[r] = e(this.get(r), r, this), r++;
              return n;
            }
            reduce(e, r) {
              let n = 0, i2 = r;
              for (; n < this.length; ) {
                let o = this.get(n);
                i2 = e(i2, o, n), n++;
              }
              return i2;
            }
            find(e) {
              let r = 0, n, i2;
              for (; r < this.length && !n; )
                i2 = this.get(r), n = e(i2), r++;
              return n ? i2 : void 0;
            }
            _internalPositionFor(e, r) {
              let n = this._bytePosFor(e, r);
              if (n >= this._bitArrays.length)
                return -1;
              let i2 = this._bitArrays[n], o = e - n * 7;
              if (!((i2 & 1 << o) > 0))
                return -1;
              let a = this._bitArrays.slice(0, n).reduce(x8e, 0), u = ~(4294967295 << o + 1), l = N$(i2 & u);
              return a + l - 1;
            }
            _bytePosFor(e, r) {
              let n = Math.floor(e / 7), i2 = n + 1;
              for (; !r && this._bitArrays.length < i2; )
                this._bitArrays.push(0);
              return n;
            }
            _setBit(e) {
              let r = this._bytePosFor(e, false);
              this._bitArrays[r] |= 1 << e - r * 7;
            }
            _unsetBit(e) {
              let r = this._bytePosFor(e, false);
              this._bitArrays[r] &= ~(1 << e - r * 7);
            }
            _setInternalPos(e, r, n, i2) {
              let o = this._data, s = [r, n];
              if (i2)
                this._sortData(), o[e] = s;
              else {
                if (o.length)
                  if (o[o.length - 1][0] >= r)
                    o.push(s);
                  else if (o[0][0] <= r)
                    o.unshift(s);
                  else {
                    let a = Math.round(o.length / 2);
                    this._data = o.slice(0, a).concat(s).concat(o.slice(a));
                  }
                else
                  this._data.push(s);
                this._changedData = true, this._changedLength = true;
              }
            }
            _unsetInternalPos(e) {
              this._data.splice(e, 1);
            }
            _sortData() {
              this._changedData && this._data.sort(R8e), this._changedData = false;
            }
            bitField() {
              let e = [], r = 8, n = 0, i2 = 0, o, s = this._bitArrays.slice();
              for (; s.length || n; ) {
                n === 0 && (o = s.shift(), n = 7);
                let u = Math.min(n, r), l = ~(255 << u);
                i2 |= (o & l) << 8 - r, o = o >>> u, n -= u, r -= u, (!r || !n && !s.length) && (e.push(i2), i2 = 0, r = 8);
              }
              for (var a = e.length - 1; a > 0 && e[a] === 0; a--)
                e.pop();
              return e;
            }
            compactArray() {
              return this._sortData(), this._data.map(A8e);
            }
          };
          function x8e(t, e) {
            return t + N$(e);
          }
          function N$(t) {
            let e = t;
            return e = e - (e >> 1 & 1431655765), e = (e & 858993459) + (e >> 2 & 858993459), (e + (e >> 4) & 252645135) * 16843009 >> 24;
          }
          function R8e(t, e) {
            return t[0] - e[0];
          }
          function A8e(t) {
            return t[1];
          }
        });
        var U$ = A((JQe, M$) => {
          "use strict";
          c();
          var T8e = L$(), { fromString: I8e } = (Re(), cr(dS)), es = class {
            constructor(e, r, n = 0) {
              this._options = e, this._popCount = 0, this._parent = r, this._posAtParent = n, this._children = new T8e(), this.key = null;
            }
            async put(e, r) {
              let n = await this._findNewBucketAndPos(e);
              await n.bucket._putAt(n, e, r);
            }
            async get(e) {
              let r = await this._findChild(e);
              if (r)
                return r.value;
            }
            async del(e) {
              let r = await this._findPlace(e), n = r.bucket._at(r.pos);
              n && n.key === e && r.bucket._delAt(r.pos);
            }
            leafCount() {
              return this._children.compactArray().reduce((r, n) => n instanceof es ? r + n.leafCount() : r + 1, 0);
            }
            childrenCount() {
              return this._children.length;
            }
            onlyChild() {
              return this._children.get(0);
            }
            *eachLeafSeries() {
              let e = this._children.compactArray();
              for (let r of e)
                r instanceof es ? yield* r.eachLeafSeries() : yield r;
              return [];
            }
            serialize(e, r) {
              let n = [];
              return r(this._children.reduce((i2, o, s) => (o && (o instanceof es ? i2.push(o.serialize(e, r)) : i2.push(e(o, s))), i2), n));
            }
            asyncTransform(e, r) {
              return B$(this, e, r);
            }
            toJSON() {
              return this.serialize(P8e, D8e);
            }
            prettyPrint() {
              return JSON.stringify(this.toJSON(), null, "  ");
            }
            tableSize() {
              return Math.pow(2, this._options.bits);
            }
            async _findChild(e) {
              let r = await this._findPlace(e), n = r.bucket._at(r.pos);
              if (!(n instanceof es) && n && n.key === e)
                return n;
            }
            async _findPlace(e) {
              let r = this._options.hash(typeof e == "string" ? I8e(e) : e), n = await r.take(this._options.bits), i2 = this._children.get(n);
              return i2 instanceof es ? i2._findPlace(r) : { bucket: this, pos: n, hash: r, existingChild: i2 };
            }
            async _findNewBucketAndPos(e) {
              let r = await this._findPlace(e);
              if (r.existingChild && r.existingChild.key !== e) {
                let n = new es(this._options, r.bucket, r.pos);
                r.bucket._putObjectAt(r.pos, n);
                let i2 = await n._findPlace(r.existingChild.hash);
                return i2.bucket._putAt(i2, r.existingChild.key, r.existingChild.value), n._findNewBucketAndPos(r.hash);
              }
              return r;
            }
            _putAt(e, r, n) {
              this._putObjectAt(e.pos, { key: r, value: n, hash: e.hash });
            }
            _putObjectAt(e, r) {
              this._children.get(e) || this._popCount++, this._children.set(e, r);
            }
            _delAt(e) {
              if (e === -1)
                throw new Error("Invalid position");
              this._children.get(e) && this._popCount--, this._children.unset(e), this._level();
            }
            _level() {
              if (this._parent && this._popCount <= 1)
                if (this._popCount === 1) {
                  let e = this._children.find(C8e);
                  if (e && !(e instanceof es)) {
                    let r = e.hash;
                    r.untake(this._options.bits);
                    let n = { pos: this._posAtParent, hash: r, bucket: this._parent };
                    this._parent._putAt(n, e.key, e.value);
                  }
                } else
                  this._parent._delAt(this._posAtParent);
            }
            _at(e) {
              return this._children.get(e);
            }
          };
          function C8e(t) {
            return Boolean(t);
          }
          function P8e(t, e) {
            return t.key;
          }
          function D8e(t) {
            return t;
          }
          async function B$(t, e, r) {
            let n = [];
            for (let i2 of t._children.compactArray())
              if (i2 instanceof es)
                await B$(i2, e, r);
              else {
                let o = await e(i2);
                n.push({ bitField: t._children.bitField(), children: o });
              }
            return r(n);
          }
          M$.exports = es;
        });
        var K$ = A((tXe, F$) => {
          "use strict";
          c();
          var k8e = [255, 254, 252, 248, 240, 224, 192, 128], N8e = [1, 3, 7, 15, 31, 63, 127, 255];
          F$.exports = class {
            constructor(e) {
              this._value = e, this._currentBytePos = e.length - 1, this._currentBitPos = 7;
            }
            availableBits() {
              return this._currentBitPos + 1 + this._currentBytePos * 8;
            }
            totalBits() {
              return this._value.length * 8;
            }
            take(e) {
              let r = e, n = 0;
              for (; r && this._haveBits(); ) {
                let i2 = this._value[this._currentBytePos], o = this._currentBitPos + 1, s = Math.min(o, r), a = O8e(i2, o - s, s);
                n = (n << s) + a, r -= s, this._currentBitPos -= s, this._currentBitPos < 0 && (this._currentBitPos = 7, this._currentBytePos--);
              }
              return n;
            }
            untake(e) {
              for (this._currentBitPos += e; this._currentBitPos > 7; )
                this._currentBitPos -= 8, this._currentBytePos += 1;
            }
            _haveBits() {
              return this._currentBytePos >= 0;
            }
          };
          function O8e(t, e, r) {
            let n = L8e(e, r);
            return (t & n) >>> e;
          }
          function L8e(t, e) {
            return k8e[t] & N8e[Math.min(e + t - 1, 7)];
          }
        });
        var V$ = A((rXe, oA) => {
          "use strict";
          c();
          var B8e = K$(), { concat: M8e } = (ur(), cr(s2));
          function U8e(t) {
            function e(r) {
              return r instanceof gy ? r : new gy(r, t);
            }
            return e;
          }
          var gy = class {
            constructor(e, r) {
              if (!(e instanceof Uint8Array))
                throw new Error("can only hash Uint8Arrays");
              this._value = e, this._hashFn = r, this._depth = -1, this._availableBits = 0, this._currentBufferIndex = 0, this._buffers = [];
            }
            async take(e) {
              let r = e;
              for (; this._availableBits < r; )
                await this._produceMoreBits();
              let n = 0;
              for (; r > 0; ) {
                let i2 = this._buffers[this._currentBufferIndex], o = Math.min(i2.availableBits(), r), s = i2.take(o);
                n = (n << o) + s, r -= o, this._availableBits -= o, i2.availableBits() === 0 && this._currentBufferIndex++;
              }
              return n;
            }
            untake(e) {
              let r = e;
              for (; r > 0; ) {
                let n = this._buffers[this._currentBufferIndex], i2 = Math.min(n.totalBits() - n.availableBits(), r);
                n.untake(i2), r -= i2, this._availableBits += i2, this._currentBufferIndex > 0 && n.totalBits() === n.availableBits() && (this._depth--, this._currentBufferIndex--);
              }
            }
            async _produceMoreBits() {
              this._depth++;
              let e = this._depth ? M8e([this._value, Uint8Array.from([this._depth])]) : this._value, r = await this._hashFn(e), n = new B8e(r);
              this._buffers.push(n), this._availableBits += n.availableBits();
            }
          };
          oA.exports = U8e;
          oA.exports.InfiniteHash = gy;
        });
        var wy = A((nXe, z$) => {
          "use strict";
          c();
          var q$ = U$(), F8e = V$();
          function K8e(t) {
            if (!t || !t.hashFn)
              throw new Error("please define an options.hashFn");
            let e = { bits: t.bits || 8, hash: F8e(t.hashFn) };
            return new q$(e);
          }
          z$.exports = { createHAMT: K8e, Bucket: q$ };
        });
        var SG = A((HZe, vG) => {
          "use strict";
          c();
          vG.exports = { RTLD_LAZY: 1, RTLD_NOW: 2, RTLD_GLOBAL: 256, RTLD_LOCAL: 0, RTLD_DEEPBIND: 8, E2BIG: 7, EACCES: 13, EADDRINUSE: 98, EADDRNOTAVAIL: 99, EAFNOSUPPORT: 97, EAGAIN: 11, EALREADY: 114, EBADF: 9, EBADMSG: 74, EBUSY: 16, ECANCELED: 125, ECHILD: 10, ECONNABORTED: 103, ECONNREFUSED: 111, ECONNRESET: 104, EDEADLK: 35, EDESTADDRREQ: 89, EDOM: 33, EDQUOT: 122, EEXIST: 17, EFAULT: 14, EFBIG: 27, EHOSTUNREACH: 113, EIDRM: 43, EILSEQ: 84, EINPROGRESS: 115, EINTR: 4, EINVAL: 22, EIO: 5, EISCONN: 106, EISDIR: 21, ELOOP: 40, EMFILE: 24, EMLINK: 31, EMSGSIZE: 90, EMULTIHOP: 72, ENAMETOOLONG: 36, ENETDOWN: 100, ENETRESET: 102, ENETUNREACH: 101, ENFILE: 23, ENOBUFS: 105, ENODATA: 61, ENODEV: 19, ENOENT: 2, ENOEXEC: 8, ENOLCK: 37, ENOLINK: 67, ENOMEM: 12, ENOMSG: 42, ENOPROTOOPT: 92, ENOSPC: 28, ENOSR: 63, ENOSTR: 60, ENOSYS: 38, ENOTCONN: 107, ENOTDIR: 20, ENOTEMPTY: 39, ENOTSOCK: 88, ENOTSUP: 95, ENOTTY: 25, ENXIO: 6, EOPNOTSUPP: 95, EOVERFLOW: 75, EPERM: 1, EPIPE: 32, EPROTO: 71, EPROTONOSUPPORT: 93, EPROTOTYPE: 91, ERANGE: 34, EROFS: 30, ESPIPE: 29, ESRCH: 3, ESTALE: 116, ETIME: 62, ETIMEDOUT: 110, ETXTBSY: 26, EWOULDBLOCK: 11, EXDEV: 18, PRIORITY_LOW: 19, PRIORITY_BELOW_NORMAL: 10, PRIORITY_NORMAL: 0, PRIORITY_ABOVE_NORMAL: -7, PRIORITY_HIGH: -14, PRIORITY_HIGHEST: -20, SIGHUP: 1, SIGINT: 2, SIGQUIT: 3, SIGILL: 4, SIGTRAP: 5, SIGABRT: 6, SIGIOT: 6, SIGBUS: 7, SIGFPE: 8, SIGKILL: 9, SIGUSR1: 10, SIGSEGV: 11, SIGUSR2: 12, SIGPIPE: 13, SIGALRM: 14, SIGTERM: 15, SIGCHLD: 17, SIGSTKFLT: 16, SIGCONT: 18, SIGSTOP: 19, SIGTSTP: 20, SIGTTIN: 21, SIGTTOU: 22, SIGURG: 23, SIGXCPU: 24, SIGXFSZ: 25, SIGVTALRM: 26, SIGPROF: 27, SIGWINCH: 28, SIGIO: 29, SIGPOLL: 29, SIGPWR: 30, SIGSYS: 31, SIGUNUSED: 31, UV_FS_SYMLINK_DIR: 1, UV_FS_SYMLINK_JUNCTION: 2, O_RDONLY: 0, O_WRONLY: 1, O_RDWR: 2, UV_DIRENT_UNKNOWN: 0, UV_DIRENT_FILE: 1, UV_DIRENT_DIR: 2, UV_DIRENT_LINK: 3, UV_DIRENT_FIFO: 4, UV_DIRENT_SOCKET: 5, UV_DIRENT_CHAR: 6, UV_DIRENT_BLOCK: 7, S_IFMT: 61440, S_IFREG: 32768, S_IFDIR: 16384, S_IFCHR: 8192, S_IFBLK: 24576, S_IFIFO: 4096, S_IFLNK: 40960, S_IFSOCK: 49152, O_CREAT: 64, O_EXCL: 128, UV_FS_O_FILEMAP: 0, O_NOCTTY: 256, O_TRUNC: 512, O_APPEND: 1024, O_DIRECTORY: 65536, O_NOATIME: 262144, O_NOFOLLOW: 131072, O_SYNC: 1052672, O_DSYNC: 4096, O_DIRECT: 16384, O_NONBLOCK: 2048, S_IRWXU: 448, S_IRUSR: 256, S_IWUSR: 128, S_IXUSR: 64, S_IRWXG: 56, S_IRGRP: 32, S_IWGRP: 16, S_IXGRP: 8, S_IRWXO: 7, S_IROTH: 4, S_IWOTH: 2, S_IXOTH: 1, F_OK: 0, R_OK: 4, W_OK: 2, X_OK: 1, UV_FS_COPYFILE_EXCL: 1, COPYFILE_EXCL: 1, UV_FS_COPYFILE_FICLONE: 2, COPYFILE_FICLONE: 2, UV_FS_COPYFILE_FICLONE_FORCE: 4, COPYFILE_FICLONE_FORCE: 4, OPENSSL_VERSION_NUMBER: 269488383, SSL_OP_ALL: 2147485780, SSL_OP_ALLOW_NO_DHE_KEX: 1024, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144, SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304, SSL_OP_CISCO_ANYCONNECT: 32768, SSL_OP_COOKIE_EXCHANGE: 8192, SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048, SSL_OP_EPHEMERAL_RSA: 0, SSL_OP_LEGACY_SERVER_CONNECT: 4, SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0, SSL_OP_MICROSOFT_SESS_ID_BUG: 0, SSL_OP_MSIE_SSLV2_RSA_PADDING: 0, SSL_OP_NETSCAPE_CA_DN_BUG: 0, SSL_OP_NETSCAPE_CHALLENGE_BUG: 0, SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0, SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0, SSL_OP_NO_COMPRESSION: 131072, SSL_OP_NO_ENCRYPT_THEN_MAC: 524288, SSL_OP_NO_QUERY_MTU: 4096, SSL_OP_NO_RENEGOTIATION: 1073741824, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536, SSL_OP_NO_SSLv2: 0, SSL_OP_NO_SSLv3: 33554432, SSL_OP_NO_TICKET: 16384, SSL_OP_NO_TLSv1: 67108864, SSL_OP_NO_TLSv1_1: 268435456, SSL_OP_NO_TLSv1_2: 134217728, SSL_OP_NO_TLSv1_3: 536870912, SSL_OP_PKCS1_CHECK_1: 0, SSL_OP_PKCS1_CHECK_2: 0, SSL_OP_PRIORITIZE_CHACHA: 2097152, SSL_OP_SINGLE_DH_USE: 0, SSL_OP_SINGLE_ECDH_USE: 0, SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0, SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0, SSL_OP_TLS_BLOCK_PADDING_BUG: 0, SSL_OP_TLS_D5_BUG: 0, SSL_OP_TLS_ROLLBACK_BUG: 8388608, ENGINE_METHOD_RSA: 1, ENGINE_METHOD_DSA: 2, ENGINE_METHOD_DH: 4, ENGINE_METHOD_RAND: 8, ENGINE_METHOD_EC: 2048, ENGINE_METHOD_CIPHERS: 64, ENGINE_METHOD_DIGESTS: 128, ENGINE_METHOD_PKEY_METHS: 512, ENGINE_METHOD_PKEY_ASN1_METHS: 1024, ENGINE_METHOD_ALL: 65535, ENGINE_METHOD_NONE: 0, DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, RSA_PSS_SALTLEN_DIGEST: -1, RSA_PSS_SALTLEN_MAX_SIGN: -2, RSA_PSS_SALTLEN_AUTO: -2, defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA", TLS1_VERSION: 769, TLS1_1_VERSION: 770, TLS1_2_VERSION: 771, TLS1_3_VERSION: 772, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
        });
        var hA = A(($Ze, xG) => {
          "use strict";
          c();
          var { concat: yEe } = (ur(), cr(s2));
          async function gEe(t) {
            let e = new Uint8Array(0);
            for await (let r of t)
              e = yEe([e, r], e.length + r.length);
            return e;
          }
          xG.exports = gEe;
        });
        var Gc = A((fet, dj) => {
          "use strict";
          c();
          var t7e = async (t) => {
            for await (let e of t)
              return e;
          };
          dj.exports = t7e;
        });
        var _T = A((nst, WY) => {
          c();
          WY.exports = c9e;
          function c9e(t, e, r) {
            if (!t)
              return r;
            var n, i2;
            if (Array.isArray(e) && (n = e.slice(0)), typeof e == "string" && (n = e.split(".")), typeof e == "symbol" && (n = [e]), !Array.isArray(n))
              throw new Error("props arg must be an array, a string or a symbol");
            for (; n.length; )
              if (i2 = n.shift(), !t || (t = t[i2], t === void 0))
                return r;
            return t;
          }
        });
        var Jy = A((ist, jY) => {
          "use strict";
          c();
          var u9e = async (t) => {
            let e = 0;
            for await (let r of t)
              e++;
            return e;
          };
          jY.exports = u9e;
        });
        var nQ = A((vT, rQ) => {
          "use strict";
          c();
          Object.defineProperty(vT, "__esModule", { value: true });
          _8.BASE = 2166136261;
          function _8(t, e = _8.BASE) {
            let r = t.length;
            for (let n = 0; n < r; n++)
              e ^= t.charCodeAt(n), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
            return e >>> 0;
          }
          vT.default = _8;
          rQ.exports = _8;
        });
        var CQ = A((dat, P8) => {
          "use strict";
          c();
          P8.exports = M9e;
          P8.exports.format = TQ;
          P8.exports.parse = IQ;
          var O9e = /\B(?=(\d{3})+(?!\d))/g, L9e = /(?:\.0*|(\.[^0]+)0+)$/, Kl = { b: 1, kb: 1 << 10, mb: 1 << 20, gb: 1 << 30, tb: Math.pow(1024, 4), pb: Math.pow(1024, 5) }, B9e = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
          function M9e(t, e) {
            return typeof t == "string" ? IQ(t) : typeof t == "number" ? TQ(t, e) : null;
          }
          function TQ(t, e) {
            if (!Number.isFinite(t))
              return null;
            var r = Math.abs(t), n = e && e.thousandsSeparator || "", i2 = e && e.unitSeparator || "", o = e && e.decimalPlaces !== void 0 ? e.decimalPlaces : 2, s = Boolean(e && e.fixedDecimals), a = e && e.unit || "";
            (!a || !Kl[a.toLowerCase()]) && (r >= Kl.pb ? a = "PB" : r >= Kl.tb ? a = "TB" : r >= Kl.gb ? a = "GB" : r >= Kl.mb ? a = "MB" : r >= Kl.kb ? a = "KB" : a = "B");
            var u = t / Kl[a.toLowerCase()], l = u.toFixed(o);
            return s || (l = l.replace(L9e, "$1")), n && (l = l.split(".").map(function(f, h) {
              return h === 0 ? f.replace(O9e, n) : f;
            }).join(".")), l + i2 + a;
          }
          function IQ(t) {
            if (typeof t == "number" && !isNaN(t))
              return t;
            if (typeof t != "string")
              return null;
            var e = B9e.exec(t), r, n = "b";
            return e ? (r = parseFloat(e[1]), n = e[4].toLowerCase()) : (r = parseInt(t, 10), n = "b"), isNaN(r) ? null : Math.floor(Kl[n] * r);
          }
        });
        var BQ = A((_at, LQ) => {
          "use strict";
          c();
          LQ.exports = (t, e) => (e = e || (() => {
          }), t.then((r) => new Promise((n) => {
            n(e());
          }).then(() => r), (r) => new Promise((n) => {
            n(e());
          }).then(() => {
            throw r;
          })));
        });
        var UQ = A((vat, O8) => {
          "use strict";
          c();
          var K9e = BQ(), N82 = class extends Error {
            constructor(e) {
              super(e), this.name = "TimeoutError";
            }
          }, MQ = (t, e, r) => new Promise((n, i2) => {
            if (typeof e != "number" || e < 0)
              throw new TypeError("Expected `milliseconds` to be a positive number");
            if (e === 1 / 0) {
              n(t);
              return;
            }
            let o = setTimeout(() => {
              if (typeof r == "function") {
                try {
                  n(r());
                } catch (u) {
                  i2(u);
                }
                return;
              }
              let s = typeof r == "string" ? r : `Promise timed out after ${e} milliseconds`, a = r instanceof Error ? r : new N82(s);
              typeof t.cancel == "function" && t.cancel(), i2(a);
            }, e);
            K9e(t.then(n, i2), () => {
              clearTimeout(o);
            });
          });
          O8.exports = MQ;
          O8.exports.default = MQ;
          O8.exports.TimeoutError = N82;
        });
        var FQ = A((FT) => {
          "use strict";
          c();
          Object.defineProperty(FT, "__esModule", { value: true });
          function V9e(t, e, r) {
            let n = 0, i2 = t.length;
            for (; i2 > 0; ) {
              let o = i2 / 2 | 0, s = n + o;
              r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
            }
            return n;
          }
          FT.default = V9e;
        });
        var KQ = A((VT) => {
          "use strict";
          c();
          Object.defineProperty(VT, "__esModule", { value: true });
          var q9e = FQ(), KT = class {
            constructor() {
              this._queue = [];
            }
            enqueue(e, r) {
              r = Object.assign({ priority: 0 }, r);
              let n = { priority: r.priority, run: e };
              if (this.size && this._queue[this.size - 1].priority >= r.priority) {
                this._queue.push(n);
                return;
              }
              let i2 = q9e.default(this._queue, n, (o, s) => s.priority - o.priority);
              this._queue.splice(i2, 0, n);
            }
            dequeue() {
              let e = this._queue.shift();
              return e?.run;
            }
            filter(e) {
              return this._queue.filter((r) => r.priority === e.priority).map((r) => r.run);
            }
            get size() {
              return this._queue.length;
            }
          };
          VT.default = KT;
        });
        var HT = A((zT) => {
          "use strict";
          c();
          Object.defineProperty(zT, "__esModule", { value: true });
          var z9e = Xu(), VQ = UQ(), H9e = KQ(), L8 = () => {
          }, $9e = new VQ.TimeoutError(), qT = class extends z9e {
            constructor(e) {
              var r, n, i2, o;
              if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = L8, this._resolveIdle = L8, e = Object.assign({ carryoverConcurrencyCount: false, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: true, queueClass: H9e.default }, e), !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
                throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
              if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
                throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
              this._carryoverConcurrencyCount = e.carryoverConcurrencyCount, this._isIntervalIgnored = e.intervalCap === 1 / 0 || e.interval === 0, this._intervalCap = e.intervalCap, this._interval = e.interval, this._queue = new e.queueClass(), this._queueClass = e.queueClass, this.concurrency = e.concurrency, this._timeout = e.timeout, this._throwOnTimeout = e.throwOnTimeout === true, this._isPaused = e.autoStart === false;
            }
            get _doesIntervalAllowAnother() {
              return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
            }
            get _doesConcurrentAllowAnother() {
              return this._pendingCount < this._concurrency;
            }
            _next() {
              this._pendingCount--, this._tryToStartAnother(), this.emit("next");
            }
            _resolvePromises() {
              this._resolveEmpty(), this._resolveEmpty = L8, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = L8, this.emit("idle"));
            }
            _onResumeInterval() {
              this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0;
            }
            _isIntervalPaused() {
              let e = Date.now();
              if (this._intervalId === void 0) {
                let r = this._intervalEnd - e;
                if (r < 0)
                  this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                else
                  return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => {
                    this._onResumeInterval();
                  }, r)), true;
              }
              return false;
            }
            _tryToStartAnother() {
              if (this._queue.size === 0)
                return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), false;
              if (!this._isPaused) {
                let e = !this._isIntervalPaused();
                if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                  let r = this._queue.dequeue();
                  return r ? (this.emit("active"), r(), e && this._initializeIntervalIfNeeded(), true) : false;
                }
              }
              return false;
            }
            _initializeIntervalIfNeeded() {
              this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => {
                this._onInterval();
              }, this._interval), this._intervalEnd = Date.now() + this._interval);
            }
            _onInterval() {
              this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue();
            }
            _processQueue() {
              for (; this._tryToStartAnother(); )
                ;
            }
            get concurrency() {
              return this._concurrency;
            }
            set concurrency(e) {
              if (!(typeof e == "number" && e >= 1))
                throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
              this._concurrency = e, this._processQueue();
            }
            async add(e, r = {}) {
              return new Promise((n, i2) => {
                let o = async () => {
                  this._pendingCount++, this._intervalCount++;
                  try {
                    let s = this._timeout === void 0 && r.timeout === void 0 ? e() : VQ.default(Promise.resolve(e()), r.timeout === void 0 ? this._timeout : r.timeout, () => {
                      (r.throwOnTimeout === void 0 ? this._throwOnTimeout : r.throwOnTimeout) && i2($9e);
                    });
                    n(await s);
                  } catch (s) {
                    i2(s);
                  }
                  this._next();
                };
                this._queue.enqueue(o, r), this._tryToStartAnother(), this.emit("add");
              });
            }
            async addAll(e, r) {
              return Promise.all(e.map(async (n) => this.add(n, r)));
            }
            start() {
              return this._isPaused ? (this._isPaused = false, this._processQueue(), this) : this;
            }
            pause() {
              this._isPaused = true;
            }
            clear() {
              this._queue = new this._queueClass();
            }
            async onEmpty() {
              if (this._queue.size !== 0)
                return new Promise((e) => {
                  let r = this._resolveEmpty;
                  this._resolveEmpty = () => {
                    r(), e();
                  };
                });
            }
            async onIdle() {
              if (!(this._pendingCount === 0 && this._queue.size === 0))
                return new Promise((e) => {
                  let r = this._resolveIdle;
                  this._resolveIdle = () => {
                    r(), e();
                  };
                });
            }
            get size() {
              return this._queue.size;
            }
            sizeBy(e) {
              return this._queue.filter(e).length;
            }
            get pending() {
              return this._pendingCount;
            }
            get isPaused() {
              return this._isPaused;
            }
            get timeout() {
              return this._timeout;
            }
            set timeout(e) {
              this._timeout = e;
            }
          };
          zT.default = qT;
        });
        var HQ = A((Aat, zQ) => {
          c();
          zQ.exports = G9e;
          function G9e(t, e, r) {
            var n, i2;
            if (Array.isArray(e) && (n = e.slice(0)), typeof e == "string" && (n = e.split(".")), typeof e == "symbol" && (n = [e]), !Array.isArray(n))
              throw new Error("props arg must be an array, a string or a symbol");
            if (i2 = n.pop(), !i2)
              return false;
            qQ(i2);
            for (var o; o = n.shift(); )
              if (qQ(o), typeof t[o] > "u" && (t[o] = {}), t = t[o], !t || typeof t != "object")
                return false;
            return t[i2] = r, true;
          }
          function qQ(t) {
            if (t === "__proto__" || t === "constructor" || t === "prototype")
              throw new Error("setting of prototype values not supported");
          }
        });
        var YQ = A((Nat, jQ) => {
          "use strict";
          c();
          var GT = V7();
          jQ.exports = (t, e = {}) => {
            if (!GT(t) && !Array.isArray(t))
              throw new TypeError("Expected a plain object or array");
            let { deep: r } = e, n = [], i2 = [], o = (a) => {
              let u = n.indexOf(a);
              if (u !== -1)
                return i2[u];
              let l = [];
              return n.push(a), i2.push(l), l.push(...a.map((f) => Array.isArray(f) ? o(f) : GT(f) ? s(f) : f)), l;
            }, s = (a) => {
              let u = n.indexOf(a);
              if (u !== -1)
                return i2[u];
              let l = {}, f = Object.keys(a).sort(e.compare);
              n.push(a), i2.push(l);
              for (let h of f) {
                let p = a[h], d;
                r && Array.isArray(p) ? d = o(p) : d = r && GT(p) ? s(p) : p, Object.defineProperty(l, h, { ...Object.getOwnPropertyDescriptor(a, h), value: d });
              }
              return l;
            };
            return Array.isArray(t) ? r ? o(t) : t.slice() : s(t);
          };
        });
        var eX = A((Vat, JQ) => {
          c();
          var YT = d0();
          JQ.exports = (t) => {
            t = t || {};
            let e;
            typeof t == "function" ? (e = t, t = {}) : e = t.onEnd;
            let r = new YT(), n, i2, o, s = () => {
              if (!r.isEmpty()) {
                if (t.writev) {
                  let y, g = [];
                  for (; !r.isEmpty(); ) {
                    if (y = r.shift(), y.error)
                      throw y.error;
                    g.push(y.value);
                  }
                  return { done: y.done, value: g };
                }
                let m = r.shift();
                if (m.error)
                  throw m.error;
                return m;
              }
              return o ? { done: true } : new Promise((m, y) => {
                i2 = (g) => (i2 = null, g.error ? y(g.error) : t.writev && !g.done ? m({ done: g.done, value: [g.value] }) : m(g), n);
              });
            }, a = (m) => i2 ? i2(m) : (r.push(m), n), u = (m) => (r = new YT(), i2 ? i2({ error: m }) : (r.push({ error: m }), n)), l = (m) => o ? n : a({ done: false, value: m }), f = (m) => o ? n : (o = true, m ? u(m) : a({ done: true })), h = () => (r = new YT(), f(), { done: true }), p = (m) => (f(m), { done: true });
            if (n = { [Symbol.asyncIterator]() {
              return this;
            }, next: s, return: h, throw: p, push: l, end: f }, !e)
              return n;
            let d = n;
            return n = { [Symbol.asyncIterator]() {
              return this;
            }, next() {
              return d.next();
            }, throw(m) {
              return d.throw(m), e && (e(m), e = null), { done: true };
            }, return() {
              return d.return(), e && (e(), e = null), { done: true };
            }, push: l, end(m) {
              return d.end(m), e && (e(m), e = null), n;
            } }, n;
          };
        });
        var JT = A((lct, wX) => {
          c();
          wX.exports = { WORKER_REQUEST_READ_LOCK: "lock:worker:request-read", WORKER_RELEASE_READ_LOCK: "lock:worker:release-read", MASTER_GRANT_READ_LOCK: "lock:master:grant-read", WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write", WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write", MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write" };
        });
        var EX = A(() => {
          c();
        });
        var CX = A((dct, IX) => {
          c();
          var Z9e = In().EventEmitter, { nanoid: J9e } = (Lp(), cr(MS)), { WORKER_REQUEST_READ_LOCK: bX, WORKER_RELEASE_READ_LOCK: _X, MASTER_GRANT_READ_LOCK: vX, WORKER_REQUEST_WRITE_LOCK: SX, WORKER_RELEASE_WRITE_LOCK: xX, MASTER_GRANT_WRITE_LOCK: RX } = JT(), ag, AX = (t, e, r, n, i2) => (o, s) => {
            s && s.type === r && t.emit(e, s.name, () => (o.send({ type: i2, name: s.name, identifier: s.identifier }), new Promise((a) => {
              let u = (l) => {
                l && l.type === n && l.identifier === s.identifier && (o.removeListener("message", u), a());
              };
              o.on("message", u);
            })));
          }, TX = (t, e, r, n) => () => {
            let i2 = J9e();
            return process.send({ type: e, identifier: i2, name: t }), new Promise((o) => {
              let s = (a) => {
                a && a.type === r && a.identifier === i2 && (process.removeListener("message", s), o(() => {
                  process.send({ type: n, identifier: i2, name: t });
                }));
              };
              process.on("message", s);
            });
          };
          IX.exports = (t) => {
            try {
              if (ag = EX(), !Object.keys(ag).length)
                return;
            } catch {
              return;
            }
            if (ag.isMaster || t.singleProcess) {
              let e = new Z9e();
              return ag.on("message", AX(e, "requestReadLock", bX, _X, vX)), ag.on("message", AX(e, "requestWriteLock", SX, xX, RX)), e;
            }
            return { isWorker: true, readLock: (e) => TX(e, bX, vX, _X), writeLock: (e) => TX(e, SX, RX, xX) };
          };
        });
        var eI = A((pct, PX) => {
          c();
          var ql = {}, e1 = (t) => {
            t.addEventListener("message", (e) => {
              e1.dispatchEvent("message", t, e);
            }), t.port && t.port.addEventListener("message", (e) => {
              e1.dispatchEvent("message", t, e);
            });
          };
          e1.addEventListener = (t, e) => {
            ql[t] || (ql[t] = []), ql[t].push(e);
          };
          e1.removeEventListener = (t, e) => {
            !ql[t] || (ql[t] = ql[t].filter((r) => r === e));
          };
          e1.dispatchEvent = function() {
            let t = Array.prototype.slice.call(arguments), e = t.shift();
            !ql[e] || ql[e].forEach((r) => r.apply(null, t));
          };
          PX.exports = e1;
        });
        var VX = A((mct, KX) => {
          c();
          var eSe = In().EventEmitter, { nanoid: tSe } = (Lp(), cr(MS)), { WORKER_REQUEST_READ_LOCK: DX, WORKER_RELEASE_READ_LOCK: kX, MASTER_GRANT_READ_LOCK: NX, WORKER_REQUEST_WRITE_LOCK: OX, WORKER_RELEASE_WRITE_LOCK: LX, MASTER_GRANT_WRITE_LOCK: BX } = JT(), MX = eI(), UX = (t, e, r, n, i2) => (o, s) => {
            if (!s || !s.data || s.data.type !== r)
              return;
            let a = { type: s.data.type, name: s.data.name, identifier: s.data.identifier };
            t.emit(e, a.name, () => (o.postMessage({ type: i2, name: a.name, identifier: a.identifier }), new Promise((u) => {
              let l = (f) => {
                if (!f || !f.data)
                  return;
                let h = { type: f.data.type, name: f.data.name, identifier: f.data.identifier };
                h && h.type === n && h.identifier === a.identifier && (o.removeEventListener("message", l), u());
              };
              o.addEventListener("message", l);
            })));
          }, FX = (t, e, r, n) => () => {
            let i2 = tSe();
            return globalThis.postMessage({ type: e, identifier: i2, name: t }), new Promise((o) => {
              let s = (a) => {
                if (!a || !a.data)
                  return;
                let u = { type: a.data.type, identifier: a.data.identifier };
                u && u.type === r && u.identifier === i2 && (globalThis.removeEventListener("message", s), o(() => {
                  globalThis.postMessage({ type: n, identifier: i2, name: t });
                }));
              };
              globalThis.addEventListener("message", s);
            });
          }, rSe = { singleProcess: false };
          KX.exports = (t) => {
            if (t = Object.assign({}, rSe, t), !!globalThis.document || t.singleProcess) {
              let r = new eSe();
              return MX.addEventListener("message", UX(r, "requestReadLock", DX, kX, NX)), MX.addEventListener("message", UX(r, "requestWriteLock", OX, LX, BX)), r;
            }
            return { isWorker: true, readLock: (r) => FX(r, DX, NX, kX), writeLock: (r) => FX(r, OX, BX, LX) };
          };
        });
        var qX = A((gct, tI) => {
          "use strict";
          c();
          var K8, yct = tI.exports.timeout = function(t, e) {
            var r = new K8(), n;
            return Promise.race([t, new Promise(function(i2, o) {
              n = setTimeout(function() {
                o(r);
              }, e);
            })]).then(function(i2) {
              return clearTimeout(n), i2;
            }, function(i2) {
              throw clearTimeout(n), i2;
            });
          };
          K8 = tI.exports.TimeoutError = function() {
            Error.call(this), this.stack = Error().stack, this.message = "Timeout";
          };
          K8.prototype = Object.create(Error.prototype);
          K8.prototype.name = "TimeoutError";
        });
        var HX = A((wct, nI) => {
          c();
          var nSe = CX(), iSe = VX(), { default: zX } = HT(), { timeout: oSe } = qX(), sSe = eI(), Qh = {}, zl;
          function rI(t, e) {
            let r, n = new Promise((i2) => {
              r = i2;
            });
            return t.add(() => oSe((() => new Promise((i2) => {
              r(() => {
                i2();
              });
            }))(), e.timeout)), n;
          }
          var aSe = (t, e) => {
            if (zl.isWorker)
              return { readLock: zl.readLock(t, e), writeLock: zl.writeLock(t, e) };
            let r = new zX({ concurrency: 1 }), n = null;
            return { readLock: () => {
              if (n)
                return rI(n, e);
              n = new zX({ concurrency: e.concurrency, autoStart: false });
              let i2 = n, o = rI(n, e);
              return r.add(() => (i2.start(), i2.onIdle().then(() => {
                n === i2 && (n = null);
              }))), o;
            }, writeLock: () => (n = null, rI(r, e)) };
          }, cSe = { concurrency: 1 / 0, timeout: 846e5, global: globalThis, singleProcess: false };
          nI.exports = (t, e) => (e || (e = {}), typeof t == "object" && (e = t, t = "lock"), t || (t = "lock"), e = Object.assign({}, cSe, e), zl || (zl = nSe(e) || iSe(e), zl.isWorker || (zl.on("requestReadLock", (r, n) => {
            !Qh[r] || Qh[r].readLock().then((i2) => n().finally(() => i2()));
          }), zl.on("requestWriteLock", async (r, n) => {
            !Qh[r] || Qh[r].writeLock().then((i2) => n().finally(() => i2()));
          }))), Qh[t] || (Qh[t] = aSe(t, e)), Qh[t]);
          nI.exports.Worker = function(t, e) {
            e = e || globalThis.Worker;
            let r;
            try {
              r = new e(t);
            } catch (n) {
              n.message.includes("not a constructor") && (r = e(t));
            }
            if (!r)
              throw new Error("Could not create Worker from", e);
            return sSe(r), r;
          };
        });
        var WX = A((Ect, t1) => {
          c();
          var $X = (...t) => {
            let e;
            for (; t.length; )
              e = t.shift()(e);
            return e;
          }, iI = (t) => t && (typeof t[Symbol.asyncIterator] == "function" || typeof t[Symbol.iterator] == "function" || typeof t.next == "function"), V8 = (t) => t && typeof t.sink == "function" && iI(t.source), uSe = (t) => (e) => (t.sink(e), t.source), GX = (...t) => {
            if (V8(t[0])) {
              let e = t[0];
              t[0] = () => e.source;
            } else if (iI(t[0])) {
              let e = t[0];
              t[0] = () => e;
            }
            if (t.length > 1 && V8(t[t.length - 1]) && (t[t.length - 1] = t[t.length - 1].sink), t.length > 2)
              for (let e = 1; e < t.length - 1; e++)
                V8(t[e]) && (t[e] = uSe(t[e]));
            return $X(...t);
          };
          t1.exports = GX;
          t1.exports.pipe = GX;
          t1.exports.rawPipe = $X;
          t1.exports.isIterable = iI;
          t1.exports.isDuplex = V8;
        });
        var ug = A((Uct, iZ) => {
          "use strict";
          c();
          var ESe = Vs(), bSe = async function* (t, e) {
            yield* (await ESe(t)).sort(e);
          };
          iZ.exports = bSe;
        });
        var sZ = A((Fct, oZ) => {
          c();
          oZ.exports = function(e) {
            return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
          };
        });
        var aZ = A((Kct, cI) => {
          c();
          typeof Object.create == "function" ? cI.exports = function(e, r) {
            e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } });
          } : cI.exports = function(e, r) {
            e.super_ = r;
            var n = function() {
            };
            n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
          };
        });
        var fZ = A((jt) => {
          c();
          var _Se = /%[sdj%]/g;
          jt.format = function(t) {
            if (!Y8(t)) {
              for (var e = [], r = 0; r < arguments.length; r++)
                e.push(Hl(arguments[r]));
              return e.join(" ");
            }
            for (var r = 1, n = arguments, i2 = n.length, o = String(t).replace(_Se, function(a) {
              if (a === "%%")
                return "%";
              if (r >= i2)
                return a;
              switch (a) {
                case "%s":
                  return String(n[r++]);
                case "%d":
                  return Number(n[r++]);
                case "%j":
                  try {
                    return JSON.stringify(n[r++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return a;
              }
            }), s = n[r]; r < i2; s = n[++r])
              j8(s) || !r1(s) ? o += " " + s : o += " " + Hl(s);
            return o;
          };
          jt.deprecate = function(t, e) {
            if (Qc(globalThis.process))
              return function() {
                return jt.deprecate(t, e).apply(this, arguments);
              };
            if (process.noDeprecation === true)
              return t;
            var r = false;
            function n() {
              if (!r) {
                if (process.throwDeprecation)
                  throw new Error(e);
                process.traceDeprecation ? console.trace(e) : console.error(e), r = true;
              }
              return t.apply(this, arguments);
            }
            return n;
          };
          var z8 = {}, uI;
          jt.debuglog = function(t) {
            if (Qc(uI) && (uI = process.env.NODE_DEBUG || ""), t = t.toUpperCase(), !z8[t])
              if (new RegExp("\\b" + t + "\\b", "i").test(uI)) {
                var e = process.pid;
                z8[t] = function() {
                  var r = jt.format.apply(jt, arguments);
                  console.error("%s %d: %s", t, e, r);
                };
              } else
                z8[t] = function() {
                };
            return z8[t];
          };
          function Hl(t, e) {
            var r = { seen: [], stylize: SSe };
            return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), pI(e) ? r.showHidden = e : e && jt._extend(r, e), Qc(r.showHidden) && (r.showHidden = false), Qc(r.depth) && (r.depth = 2), Qc(r.colors) && (r.colors = false), Qc(r.customInspect) && (r.customInspect = true), r.colors && (r.stylize = vSe), W8(r, t, r.depth);
          }
          jt.inspect = Hl;
          Hl.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
          Hl.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
          function vSe(t, e) {
            var r = Hl.styles[e];
            return r ? "\x1B[" + Hl.colors[r][0] + "m" + t + "\x1B[" + Hl.colors[r][1] + "m" : t;
          }
          function SSe(t, e) {
            return t;
          }
          function xSe(t) {
            var e = {};
            return t.forEach(function(r, n) {
              e[r] = true;
            }), e;
          }
          function W8(t, e, r) {
            if (t.customInspect && e && G8(e.inspect) && e.inspect !== jt.inspect && !(e.constructor && e.constructor.prototype === e)) {
              var n = e.inspect(r, t);
              return Y8(n) || (n = W8(t, n, r)), n;
            }
            var i2 = RSe(t, e);
            if (i2)
              return i2;
            var o = Object.keys(e), s = xSe(o);
            if (t.showHidden && (o = Object.getOwnPropertyNames(e)), $8(e) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0))
              return lI(e);
            if (o.length === 0) {
              if (G8(e)) {
                var a = e.name ? ": " + e.name : "";
                return t.stylize("[Function" + a + "]", "special");
              }
              if (H8(e))
                return t.stylize(RegExp.prototype.toString.call(e), "regexp");
              if (dI(e))
                return t.stylize(Date.prototype.toString.call(e), "date");
              if ($8(e))
                return lI(e);
            }
            var u = "", l = false, f = ["{", "}"];
            if (cZ(e) && (l = true, f = ["[", "]"]), G8(e)) {
              var h = e.name ? ": " + e.name : "";
              u = " [Function" + h + "]";
            }
            if (H8(e) && (u = " " + RegExp.prototype.toString.call(e)), dI(e) && (u = " " + Date.prototype.toUTCString.call(e)), $8(e) && (u = " " + lI(e)), o.length === 0 && (!l || e.length == 0))
              return f[0] + u + f[1];
            if (r < 0)
              return H8(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
            t.seen.push(e);
            var p;
            return l ? p = ASe(t, e, r, s, o) : p = o.map(function(d) {
              return hI(t, e, r, s, d, l);
            }), t.seen.pop(), TSe(p, u, f);
          }
          function RSe(t, e) {
            if (Qc(e))
              return t.stylize("undefined", "undefined");
            if (Y8(e)) {
              var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return t.stylize(r, "string");
            }
            if (uZ(e))
              return t.stylize("" + e, "number");
            if (pI(e))
              return t.stylize("" + e, "boolean");
            if (j8(e))
              return t.stylize("null", "null");
          }
          function lI(t) {
            return "[" + Error.prototype.toString.call(t) + "]";
          }
          function ASe(t, e, r, n, i2) {
            for (var o = [], s = 0, a = e.length; s < a; ++s)
              lZ(e, String(s)) ? o.push(hI(t, e, r, n, String(s), true)) : o.push("");
            return i2.forEach(function(u) {
              u.match(/^\d+$/) || o.push(hI(t, e, r, n, u, true));
            }), o;
          }
          function hI(t, e, r, n, i2, o) {
            var s, a, u;
            if (u = Object.getOwnPropertyDescriptor(e, i2) || { value: e[i2] }, u.get ? u.set ? a = t.stylize("[Getter/Setter]", "special") : a = t.stylize("[Getter]", "special") : u.set && (a = t.stylize("[Setter]", "special")), lZ(n, i2) || (s = "[" + i2 + "]"), a || (t.seen.indexOf(u.value) < 0 ? (j8(r) ? a = W8(t, u.value, null) : a = W8(t, u.value, r - 1), a.indexOf(`
`) > -1 && (o ? a = a.split(`
`).map(function(l) {
              return "  " + l;
            }).join(`
`).substr(2) : a = `
` + a.split(`
`).map(function(l) {
              return "   " + l;
            }).join(`
`))) : a = t.stylize("[Circular]", "special")), Qc(s)) {
              if (o && i2.match(/^\d+$/))
                return a;
              s = JSON.stringify("" + i2), s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = t.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = t.stylize(s, "string"));
            }
            return s + ": " + a;
          }
          function TSe(t, e, r) {
            var n = 0, i2 = t.reduce(function(o, s) {
              return n++, s.indexOf(`
`) >= 0 && n++, o + s.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return i2 > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1];
          }
          function cZ(t) {
            return Array.isArray(t);
          }
          jt.isArray = cZ;
          function pI(t) {
            return typeof t == "boolean";
          }
          jt.isBoolean = pI;
          function j8(t) {
            return t === null;
          }
          jt.isNull = j8;
          function ISe(t) {
            return t == null;
          }
          jt.isNullOrUndefined = ISe;
          function uZ(t) {
            return typeof t == "number";
          }
          jt.isNumber = uZ;
          function Y8(t) {
            return typeof t == "string";
          }
          jt.isString = Y8;
          function CSe(t) {
            return typeof t == "symbol";
          }
          jt.isSymbol = CSe;
          function Qc(t) {
            return t === void 0;
          }
          jt.isUndefined = Qc;
          function H8(t) {
            return r1(t) && mI(t) === "[object RegExp]";
          }
          jt.isRegExp = H8;
          function r1(t) {
            return typeof t == "object" && t !== null;
          }
          jt.isObject = r1;
          function dI(t) {
            return r1(t) && mI(t) === "[object Date]";
          }
          jt.isDate = dI;
          function $8(t) {
            return r1(t) && (mI(t) === "[object Error]" || t instanceof Error);
          }
          jt.isError = $8;
          function G8(t) {
            return typeof t == "function";
          }
          jt.isFunction = G8;
          function PSe(t) {
            return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || typeof t > "u";
          }
          jt.isPrimitive = PSe;
          jt.isBuffer = sZ();
          function mI(t) {
            return Object.prototype.toString.call(t);
          }
          function fI(t) {
            return t < 10 ? "0" + t.toString(10) : t.toString(10);
          }
          var DSe = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function kSe() {
            var t = new Date(), e = [fI(t.getHours()), fI(t.getMinutes()), fI(t.getSeconds())].join(":");
            return [t.getDate(), DSe[t.getMonth()], e].join(" ");
          }
          jt.log = function() {
            console.log("%s - %s", kSe(), jt.format.apply(jt, arguments));
          };
          jt.inherits = aZ();
          jt._extend = function(t, e) {
            if (!e || !r1(e))
              return t;
            for (var r = Object.keys(e), n = r.length; n--; )
              t[r[n]] = e[r[n]];
            return t;
          };
          function lZ(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e);
          }
        });
        var yI = A((qct, dZ) => {
          "use strict";
          c();
          dZ.exports = function(...e) {
            let r = e.reduce((n, i2) => Object.assign(n, i2), {});
            return Object.assign(r, { bufferKeys: r.bufferKeys || false, snapshots: r.snapshots || false, permanence: r.permanence || false, seek: r.seek || false, clear: r.clear || false, getMany: r.getMany || false, keyIterator: r.keyIterator || false, valueIterator: r.valueIterator || false, iteratorNextv: r.iteratorNextv || false, iteratorAll: r.iteratorAll || false, status: r.status || false, idempotentOpen: r.idempotentOpen || false, passiveOpen: r.passiveOpen || false, serialize: r.serialize || false, createIfMissing: r.createIfMissing || false, errorIfExists: r.errorIfExists || false, deferredOpen: r.deferredOpen || false, openCallback: r.openCallback || false, promises: r.promises || false, streams: r.streams || false, encodings: hZ(r.encodings), events: hZ(r.events), additionalMethods: Object.assign({}, r.additionalMethods) });
          };
          function hZ(t) {
            return t ? Object.assign({}, t) : false;
          }
        });
        var mZ = A((zct, pZ) => {
          c();
          pZ.exports = function(e) {
            return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);
          };
        });
        var gZ = A((Hct, yZ) => {
          c();
          yZ.exports = typeof queueMicrotask == "function" ? queueMicrotask : (t) => Promise.resolve().then(t);
        });
        var Q8 = A((gI) => {
          "use strict";
          c();
          var wZ = gZ();
          gI.fromCallback = function(t, e) {
            if (t === void 0) {
              var r = new Promise(function(n, i2) {
                t = function(o, s) {
                  o ? i2(o) : n(s);
                };
              });
              t[e !== void 0 ? e : "promise"] = r;
            } else if (typeof t != "function")
              throw new TypeError("Callback must be a function");
            return t;
          };
          gI.fromPromise = function(t, e) {
            if (e === void 0)
              return t;
            t.then(function(r) {
              wZ(() => e(null, r));
            }).catch(function(r) {
              wZ(() => e(r));
            });
          };
        });
        var X8 = A((Gct, bZ) => {
          c();
          var EZ;
          bZ.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : globalThis) : (t) => (EZ || (EZ = Promise.resolve())).then(t).catch((e) => setTimeout(() => {
            throw e;
          }, 0));
        });
        var Z8 = A((Wct, vZ) => {
          "use strict";
          c();
          var _Z = X8();
          vZ.exports = function(t, ...e) {
            e.length === 0 ? _Z(t) : _Z(() => t(...e));
          };
        });
        var wI = A((jct, SZ) => {
          "use strict";
          c();
          function Xc(t) {
            if (typeof t != "object" || t === null)
              throw new TypeError("First argument must be an abstract-leveldown compliant store");
            this.db = t, this._ended = false, this._nexting = false;
          }
          Xc.prototype.next = function(t) {
            let e = this;
            if (t === void 0)
              e = new Promise(function(r, n) {
                t = function(i2, o, s) {
                  i2 ? n(i2) : o === void 0 && s === void 0 ? r() : r([o, s]);
                };
              });
            else if (typeof t != "function")
              throw new Error("next() requires a callback argument");
            return this._ended ? (this._nextTick(t, new Error("cannot call next() after end()")), e) : this._nexting ? (this._nextTick(t, new Error("cannot call next() before previous next() has completed")), e) : (this._nexting = true, this._next((r, ...n) => {
              this._nexting = false, t(r, ...n);
            }), e);
          };
          Xc.prototype._next = function(t) {
            this._nextTick(t);
          };
          Xc.prototype.seek = function(t) {
            if (this._ended)
              throw new Error("cannot call seek() after end()");
            if (this._nexting)
              throw new Error("cannot call seek() before next() has completed");
            t = this.db._serializeKey(t), this._seek(t);
          };
          Xc.prototype._seek = function(t) {
          };
          Xc.prototype.end = function(t) {
            let e;
            if (t === void 0)
              e = new Promise(function(r, n) {
                t = function(i2) {
                  i2 ? n(i2) : r();
                };
              });
            else if (typeof t != "function")
              throw new Error("end() requires a callback argument");
            return this._ended ? (this._nextTick(t, new Error("end() already called on iterator")), e) : (this._ended = true, this._end(t), e);
          };
          Xc.prototype._end = function(t) {
            this._nextTick(t);
          };
          Xc.prototype[Symbol.asyncIterator] = async function* () {
            try {
              let t;
              for (; (t = await this.next()) !== void 0; )
                yield t;
            } finally {
              this._ended || await this.end();
            }
          };
          Xc.prototype._nextTick = Z8();
          SZ.exports = Xc;
        });
        var EI = A((Yct, RZ) => {
          "use strict";
          c();
          var xZ = Object.freeze({});
          function Qs(t) {
            if (typeof t != "object" || t === null)
              throw new TypeError("First argument must be an abstract-leveldown compliant store");
            this.db = t, this._operations = [], this._written = false;
          }
          Qs.prototype._checkWritten = function() {
            if (this._written)
              throw new Error("write() already called on this batch");
          };
          Qs.prototype.put = function(t, e, r) {
            this._checkWritten();
            let n = this.db._checkKey(t) || this.db._checkValue(e);
            if (n)
              throw n;
            return t = this.db._serializeKey(t), e = this.db._serializeValue(e), this._put(t, e, r ?? xZ), this;
          };
          Qs.prototype._put = function(t, e, r) {
            this._operations.push({ ...r, type: "put", key: t, value: e });
          };
          Qs.prototype.del = function(t, e) {
            this._checkWritten();
            let r = this.db._checkKey(t);
            if (r)
              throw r;
            return t = this.db._serializeKey(t), this._del(t, e ?? xZ), this;
          };
          Qs.prototype._del = function(t, e) {
            this._operations.push({ ...e, type: "del", key: t });
          };
          Qs.prototype.clear = function() {
            return this._checkWritten(), this._clear(), this;
          };
          Qs.prototype._clear = function() {
            this._operations = [];
          };
          Qs.prototype.write = function(t, e) {
            if (this._checkWritten(), typeof t == "function" && (e = t), typeof e != "function")
              throw new Error("write() requires a callback argument");
            (typeof t != "object" || t === null) && (t = {}), this._written = true, this._write(t, e);
          };
          Qs.prototype._write = function(t, e) {
            this.db._batch(this._operations, t, e);
          };
          Qs.prototype._nextTick = Z8();
          RZ.exports = Qs;
        });
        var _I = A((bI) => {
          "use strict";
          c();
          bI.getCallback = function(t, e) {
            return typeof t == "function" ? t : e;
          };
          bI.getOptions = function(t) {
            return typeof t == "object" && t !== null ? t : {};
          };
        });
        var IZ = A((Xct, TZ) => {
          "use strict";
          c();
          var NSe = yI(), OSe = mZ(), LSe = Q8(), BSe = wI(), MSe = EI(), USe = _I().getCallback, FSe = _I().getOptions, KSe = Object.prototype.hasOwnProperty, VSe = ["lt", "lte", "gt", "gte"];
          function fr(t) {
            this.status = "new", this.supports = NSe(t, { status: true });
          }
          fr.prototype.open = function(t, e) {
            let r = this.status;
            if (typeof t == "function" && (e = t), typeof e != "function")
              throw new Error("open() requires a callback argument");
            (typeof t != "object" || t === null) && (t = {}), t.createIfMissing = t.createIfMissing !== false, t.errorIfExists = !!t.errorIfExists, this.status = "opening", this._open(t, (n) => {
              if (n)
                return this.status = r, e(n);
              this.status = "open", e();
            });
          };
          fr.prototype._open = function(t, e) {
            this._nextTick(e);
          };
          fr.prototype.close = function(t) {
            let e = this.status;
            if (typeof t != "function")
              throw new Error("close() requires a callback argument");
            this.status = "closing", this._close((r) => {
              if (r)
                return this.status = e, t(r);
              this.status = "closed", t();
            });
          };
          fr.prototype._close = function(t) {
            this._nextTick(t);
          };
          fr.prototype.get = function(t, e, r) {
            if (typeof e == "function" && (r = e), typeof r != "function")
              throw new Error("get() requires a callback argument");
            let n = this._checkKey(t);
            if (n)
              return this._nextTick(r, n);
            t = this._serializeKey(t), (typeof e != "object" || e === null) && (e = {}), e.asBuffer = e.asBuffer !== false, this._get(t, e, r);
          };
          fr.prototype._get = function(t, e, r) {
            this._nextTick(function() {
              r(new Error("NotFound"));
            });
          };
          fr.prototype.getMany = function(t, e, r) {
            if (r = USe(e, r), r = LSe.fromCallback(r), e = FSe(e), zSe(this, r))
              return r.promise;
            if (!Array.isArray(t))
              return this._nextTick(r, new Error("getMany() requires an array argument")), r.promise;
            if (t.length === 0)
              return this._nextTick(r, null, []), r.promise;
            typeof e.asBuffer != "boolean" && (e = { ...e, asBuffer: true });
            let n = new Array(t.length);
            for (let i2 = 0; i2 < t.length; i2++) {
              let o = t[i2], s = this._checkKey(o);
              if (s)
                return this._nextTick(r, s), r.promise;
              n[i2] = this._serializeKey(o);
            }
            return this._getMany(n, e, r), r.promise;
          };
          fr.prototype._getMany = function(t, e, r) {
            this._nextTick(r, null, new Array(t.length).fill(void 0));
          };
          fr.prototype.put = function(t, e, r, n) {
            if (typeof r == "function" && (n = r), typeof n != "function")
              throw new Error("put() requires a callback argument");
            let i2 = this._checkKey(t) || this._checkValue(e);
            if (i2)
              return this._nextTick(n, i2);
            t = this._serializeKey(t), e = this._serializeValue(e), (typeof r != "object" || r === null) && (r = {}), this._put(t, e, r, n);
          };
          fr.prototype._put = function(t, e, r, n) {
            this._nextTick(n);
          };
          fr.prototype.del = function(t, e, r) {
            if (typeof e == "function" && (r = e), typeof r != "function")
              throw new Error("del() requires a callback argument");
            let n = this._checkKey(t);
            if (n)
              return this._nextTick(r, n);
            t = this._serializeKey(t), (typeof e != "object" || e === null) && (e = {}), this._del(t, e, r);
          };
          fr.prototype._del = function(t, e, r) {
            this._nextTick(r);
          };
          fr.prototype.batch = function(t, e, r) {
            if (!arguments.length)
              return this._chainedBatch();
            if (typeof e == "function" && (r = e), typeof t == "function" && (r = t), typeof r != "function")
              throw new Error("batch(array) requires a callback argument");
            if (!Array.isArray(t))
              return this._nextTick(r, new Error("batch(array) requires an array argument"));
            if (t.length === 0)
              return this._nextTick(r);
            (typeof e != "object" || e === null) && (e = {});
            let n = new Array(t.length);
            for (let i2 = 0; i2 < t.length; i2++) {
              if (typeof t[i2] != "object" || t[i2] === null)
                return this._nextTick(r, new Error("batch(array) element must be an object and not `null`"));
              let o = Object.assign({}, t[i2]);
              if (o.type !== "put" && o.type !== "del")
                return this._nextTick(r, new Error("`type` must be 'put' or 'del'"));
              let s = this._checkKey(o.key);
              if (s)
                return this._nextTick(r, s);
              if (o.key = this._serializeKey(o.key), o.type === "put") {
                let a = this._checkValue(o.value);
                if (a)
                  return this._nextTick(r, a);
                o.value = this._serializeValue(o.value);
              }
              n[i2] = o;
            }
            this._batch(n, e, r);
          };
          fr.prototype._batch = function(t, e, r) {
            this._nextTick(r);
          };
          fr.prototype.clear = function(t, e) {
            if (typeof t == "function")
              e = t;
            else if (typeof e != "function")
              throw new Error("clear() requires a callback argument");
            t = AZ(this, t), t.reverse = !!t.reverse, t.limit = "limit" in t ? t.limit : -1, this._clear(t, e);
          };
          fr.prototype._clear = function(t, e) {
            t.keys = true, t.values = false, t.keyAsBuffer = true, t.valueAsBuffer = true;
            let r = this._iterator(t), n = {}, i2 = (o) => {
              if (o)
                return r.end(function() {
                  e(o);
                });
              r.next((s, a) => {
                if (s)
                  return i2(s);
                if (a === void 0)
                  return r.end(e);
                this._del(a, n, i2);
              });
            };
            i2();
          };
          fr.prototype._setupIteratorOptions = function(t) {
            return t = AZ(this, t), t.reverse = !!t.reverse, t.keys = t.keys !== false, t.values = t.values !== false, t.limit = "limit" in t ? t.limit : -1, t.keyAsBuffer = t.keyAsBuffer !== false, t.valueAsBuffer = t.valueAsBuffer !== false, t;
          };
          function AZ(t, e) {
            let r = {};
            for (let n in e) {
              if (!KSe.call(e, n))
                continue;
              if (n === "start" || n === "end")
                throw new Error('Legacy range options ("start" and "end") have been removed');
              let i2 = e[n];
              qSe(n) && (i2 = t._serializeKey(i2)), r[n] = i2;
            }
            return r;
          }
          function qSe(t) {
            return VSe.indexOf(t) !== -1;
          }
          fr.prototype.iterator = function(t) {
            return (typeof t != "object" || t === null) && (t = {}), t = this._setupIteratorOptions(t), this._iterator(t);
          };
          fr.prototype._iterator = function(t) {
            return new BSe(this);
          };
          fr.prototype._chainedBatch = function() {
            return new MSe(this);
          };
          fr.prototype._serializeKey = function(t) {
            return t;
          };
          fr.prototype._serializeValue = function(t) {
            return t;
          };
          fr.prototype._checkKey = function(t) {
            if (t == null)
              return new Error("key cannot be `null` or `undefined`");
            if (OSe(t) && t.length === 0)
              return new Error("key cannot be an empty Buffer");
            if (t === "")
              return new Error("key cannot be an empty String");
            if (Array.isArray(t) && t.length === 0)
              return new Error("key cannot be an empty Array");
          };
          fr.prototype._checkValue = function(t) {
            if (t == null)
              return new Error("value cannot be `null` or `undefined`");
          };
          fr.prototype.isOperational = function() {
            return this.status === "open" || this._isOperational();
          };
          fr.prototype._isOperational = function() {
            return false;
          };
          fr.prototype._nextTick = Z8();
          TZ.exports = fr;
          function zSe(t, e) {
            return t.isOperational() ? false : (t._nextTick(e, new Error("Database is not open")), true);
          }
        });
        var Zc = A((J8) => {
          "use strict";
          c();
          J8.AbstractLevelDOWN = IZ();
          J8.AbstractIterator = wI();
          J8.AbstractChainedBatch = EI();
        });
        var ni = A((Jct, vI) => {
          c();
          typeof Object.create == "function" ? vI.exports = function(e, r) {
            r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
          } : vI.exports = function(e, r) {
            if (r) {
              e.super_ = r;
              var n = function() {
              };
              n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
            }
          };
        });
        var SI = A((CZ) => {
          "use strict";
          c();
          CZ.getCallback = function(t, e, r) {
            let n = t[t.length - 1];
            if (typeof n != "function") {
              let i2 = new Promise((o, s) => {
                t.push(n = function(a, ...u) {
                  a ? s(a) : o(r ? r(...u) : u[0]);
                });
              });
              n[e] = i2;
            }
            return n;
          };
        });
        var OZ = A((tut, NZ) => {
          "use strict";
          c();
          var { AbstractIterator: PZ } = Zc(), HSe = ni(), DZ = SI().getCallback, kZ = Symbol("options"), n1 = Symbol("iterator"), i1 = Symbol("operations"), eE = Symbol("promise");
          function Zh(t, e) {
            PZ.call(this, t), this[kZ] = e, this[n1] = null, this[i1] = [];
          }
          HSe(Zh, PZ);
          Zh.prototype.setDb = function(t) {
            this[n1] = t.iterator(this[kZ]);
            for (let e of this[i1].splice(0, this[i1].length))
              this[n1][e.method](...e.args);
          };
          Zh.prototype.next = function(...t) {
            if (this.db.status === "open")
              return this[n1].next(...t);
            let e = DZ(t, eE, function(n, i2) {
              if (!(n === void 0 && i2 === void 0))
                return [n, i2];
            });
            return this.db.status === "opening" ? this[i1].push({ method: "next", args: t }) : this._nextTick(e, new Error("Database is not open")), e[eE] || this;
          };
          Zh.prototype.seek = function(...t) {
            if (this.db.status === "open")
              this[n1].seek(...t);
            else if (this.db.status === "opening")
              this[i1].push({ method: "seek", args: t });
            else
              throw new Error("Database is not open");
          };
          Zh.prototype.end = function(...t) {
            if (this.db.status === "open")
              return this[n1].end(...t);
            let e = DZ(t, eE);
            return this.db.status === "opening" ? this[i1].push({ method: "end", args: t }) : this._nextTick(e, new Error("Database is not open")), e[eE] || this;
          };
          for (let t of ["next", "seek", "end"])
            Zh.prototype["_" + t] = function() {
              throw new Error("Did not expect private method to be called: " + t);
            };
          NZ.exports = Zh;
        });
        var BZ = A((nut, LZ) => {
          "use strict";
          c();
          var { AbstractChainedBatch: $Se } = Zc(), lg = Symbol("operations");
          LZ.exports = class extends $Se {
            constructor(e) {
              super(e), this[lg] = [];
            }
            _put(e, r, n) {
              this[lg].push({ ...n, type: "put", key: e, value: r });
            }
            _del(e, r) {
              this[lg].push({ ...r, type: "del", key: e });
            }
            _clear() {
              this[lg] = [];
            }
            _write(e, r) {
              this.db.batch(this[lg], e, r);
            }
          };
        });
        var VZ = A((iut, xI) => {
          "use strict";
          c();
          var { AbstractLevelDOWN: FZ } = Zc(), GSe = ni(), KZ = OZ(), WSe = BZ(), jSe = SI().getCallback, MZ = ["put", "get", "getMany", "del", "batch", "clear"], YSe = ["approximateSize", "compactRange"], Xs = Symbol("innerDb"), o1 = Symbol("operations"), UZ = Symbol("promise");
          function Jh(t) {
            FZ.call(this, t.supports || {});
            for (let e of YSe)
              typeof t[e] == "function" && !this.supports.additionalMethods[e] && (this.supports.additionalMethods[e] = true);
            this[Xs] = t, this[o1] = [], QSe(this);
          }
          GSe(Jh, FZ);
          Jh.prototype.type = "deferred-leveldown";
          Object.defineProperty(Jh.prototype, "_db", { enumerable: true, get() {
            return this[Xs];
          } });
          Jh.prototype._open = function(t, e) {
            let r = (n) => {
              if (n || this[Xs].status !== "open")
                return e(n || new Error("Database is not open"));
              let i2 = this[o1];
              this[o1] = [];
              for (let o of i2)
                o.iterator ? o.iterator.setDb(this[Xs]) : this[Xs][o.method](...o.args);
              if (this[o1].length > 0)
                throw new Error("Did not expect further operations");
              e();
            };
            this[Xs].status === "new" || this[Xs].status === "closed" ? this[Xs].open(t, r) : this._nextTick(r);
          };
          Jh.prototype._close = function(t) {
            this[Xs].close(t);
          };
          Jh.prototype._isOperational = function() {
            return this.status === "opening";
          };
          function QSe(t) {
            let e = Object.keys(t.supports.additionalMethods);
            for (let r of MZ.concat(e))
              t[r] = function(...n) {
                if (r === "batch" && n.length === 0)
                  return new WSe(this);
                if (this.status === "open")
                  return this[Xs][r](...n);
                let i2 = jSe(n, UZ);
                return this.status === "opening" ? this[o1].push({ method: r, args: n }) : this._nextTick(i2, new Error("Database is not open")), i2[UZ];
              };
            t.iterator = function(r) {
              if (this.status === "open")
                return this[Xs].iterator(r);
              if (this.status === "opening") {
                let n = new KZ(this, r);
                return this[o1].push({ iterator: n }), n;
              } else
                throw new Error("Database is not open");
            };
            for (let r of MZ.concat(["iterator"]))
              t["_" + r] = function() {
                throw new Error("Did not expect private method to be called: " + r);
              };
          }
          xI.exports = Jh;
          xI.exports.DeferredIterator = KZ;
        });
        var RI = A((out, qZ) => {
          c();
          qZ.exports = In().EventEmitter;
        });
        var fg = A(() => {
          c();
        });
        var GZ = A((cut, $Z) => {
          "use strict";
          c();
          function zZ(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(t);
              e && (n = n.filter(function(i2) {
                return Object.getOwnPropertyDescriptor(t, i2).enumerable;
              })), r.push.apply(r, n);
            }
            return r;
          }
          function XSe(t) {
            for (var e = 1; e < arguments.length; e++) {
              var r = arguments[e] != null ? arguments[e] : {};
              e % 2 ? zZ(Object(r), true).forEach(function(n) {
                ZSe(t, n, r[n]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : zZ(Object(r)).forEach(function(n) {
                Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
              });
            }
            return t;
          }
          function ZSe(t, e, r) {
            return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
          }
          function JSe(t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          }
          function HZ(t, e) {
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
            }
          }
          function exe(t, e, r) {
            return e && HZ(t.prototype, e), r && HZ(t, r), t;
          }
          var txe = _i(), tE = txe.Buffer, rxe = fg(), AI = rxe.inspect, nxe = AI && AI.custom || "inspect";
          function ixe(t, e, r) {
            tE.prototype.copy.call(t, e, r);
          }
          $Z.exports = function() {
            function t() {
              JSe(this, t), this.head = null, this.tail = null, this.length = 0;
            }
            return exe(t, [{ key: "push", value: function(r) {
              var n = { data: r, next: null };
              this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
            } }, { key: "unshift", value: function(r) {
              var n = { data: r, next: this.head };
              this.length === 0 && (this.tail = n), this.head = n, ++this.length;
            } }, { key: "shift", value: function() {
              if (this.length !== 0) {
                var r = this.head.data;
                return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
              }
            } }, { key: "clear", value: function() {
              this.head = this.tail = null, this.length = 0;
            } }, { key: "join", value: function(r) {
              if (this.length === 0)
                return "";
              for (var n = this.head, i2 = "" + n.data; n = n.next; )
                i2 += r + n.data;
              return i2;
            } }, { key: "concat", value: function(r) {
              if (this.length === 0)
                return tE.alloc(0);
              for (var n = tE.allocUnsafe(r >>> 0), i2 = this.head, o = 0; i2; )
                ixe(i2.data, n, o), o += i2.data.length, i2 = i2.next;
              return n;
            } }, { key: "consume", value: function(r, n) {
              var i2;
              return r < this.head.data.length ? (i2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i2 = this.shift() : i2 = n ? this._getString(r) : this._getBuffer(r), i2;
            } }, { key: "first", value: function() {
              return this.head.data;
            } }, { key: "_getString", value: function(r) {
              var n = this.head, i2 = 1, o = n.data;
              for (r -= o.length; n = n.next; ) {
                var s = n.data, a = r > s.length ? s.length : r;
                if (a === s.length ? o += s : o += s.slice(0, r), r -= a, r === 0) {
                  a === s.length ? (++i2, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = s.slice(a));
                  break;
                }
                ++i2;
              }
              return this.length -= i2, o;
            } }, { key: "_getBuffer", value: function(r) {
              var n = tE.allocUnsafe(r), i2 = this.head, o = 1;
              for (i2.data.copy(n), r -= i2.data.length; i2 = i2.next; ) {
                var s = i2.data, a = r > s.length ? s.length : r;
                if (s.copy(n, n.length - r, 0, a), r -= a, r === 0) {
                  a === s.length ? (++o, i2.next ? this.head = i2.next : this.head = this.tail = null) : (this.head = i2, i2.data = s.slice(a));
                  break;
                }
                ++o;
              }
              return this.length -= o, n;
            } }, { key: nxe, value: function(r, n) {
              return AI(this, XSe({}, n, { depth: 0, customInspect: false }));
            } }]), t;
          }();
        });
        var II = A((uut, jZ) => {
          "use strict";
          c();
          function oxe(t, e) {
            var r = this, n = this._readableState && this._readableState.destroyed, i2 = this._writableState && this._writableState.destroyed;
            return n || i2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(TI, this, t)) : process.nextTick(TI, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(o) {
              !e && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(rE, r) : (r._writableState.errorEmitted = true, process.nextTick(WZ, r, o)) : process.nextTick(WZ, r, o) : e ? (process.nextTick(rE, r), e(o)) : process.nextTick(rE, r);
            }), this);
          }
          function WZ(t, e) {
            TI(t, e), rE(t);
          }
          function rE(t) {
            t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
          }
          function sxe() {
            this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
          }
          function TI(t, e) {
            t.emit("error", e);
          }
          function axe(t, e) {
            var r = t._readableState, n = t._writableState;
            r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e);
          }
          jZ.exports = { destroy: oxe, undestroy: sxe, errorOrDestroy: axe };
        });
        var ed = A((lut, XZ) => {
          "use strict";
          c();
          function cxe(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }
          var QZ = {};
          function os(t, e, r) {
            r || (r = Error);
            function n(o, s, a) {
              return typeof e == "string" ? e : e(o, s, a);
            }
            var i2 = function(o) {
              cxe(s, o);
              function s(a, u, l) {
                return o.call(this, n(a, u, l)) || this;
              }
              return s;
            }(r);
            i2.prototype.name = r.name, i2.prototype.code = t, QZ[t] = i2;
          }
          function YZ(t, e) {
            if (Array.isArray(t)) {
              var r = t.length;
              return t = t.map(function(n) {
                return String(n);
              }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
            } else
              return "of ".concat(e, " ").concat(String(t));
          }
          function uxe(t, e, r) {
            return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
          }
          function lxe(t, e, r) {
            return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
          }
          function fxe(t, e, r) {
            return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
          }
          os("ERR_INVALID_OPT_VALUE", function(t, e) {
            return 'The value "' + e + '" is invalid for option "' + t + '"';
          }, TypeError);
          os("ERR_INVALID_ARG_TYPE", function(t, e, r) {
            var n;
            typeof e == "string" && uxe(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
            var i2;
            if (lxe(t, " argument"))
              i2 = "The ".concat(t, " ").concat(n, " ").concat(YZ(e, "type"));
            else {
              var o = fxe(t, ".") ? "property" : "argument";
              i2 = 'The "'.concat(t, '" ').concat(o, " ").concat(n, " ").concat(YZ(e, "type"));
            }
            return i2 += ". Received type ".concat(typeof r), i2;
          }, TypeError);
          os("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
          os("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
            return "The " + t + " method is not implemented";
          });
          os("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
          os("ERR_STREAM_DESTROYED", function(t) {
            return "Cannot call " + t + " after a stream was destroyed";
          });
          os("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
          os("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
          os("ERR_STREAM_WRITE_AFTER_END", "write after end");
          os("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
          os("ERR_UNKNOWN_ENCODING", function(t) {
            return "Unknown encoding: " + t;
          }, TypeError);
          os("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
          XZ.exports.codes = QZ;
        });
        var CI = A((fut, ZZ) => {
          "use strict";
          c();
          var hxe = ed().codes.ERR_INVALID_OPT_VALUE;
          function dxe(t, e, r) {
            return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
          }
          function pxe(t, e, r, n) {
            var i2 = dxe(e, n, r);
            if (i2 != null) {
              if (!(isFinite(i2) && Math.floor(i2) === i2) || i2 < 0) {
                var o = n ? r : "highWaterMark";
                throw new hxe(o, i2);
              }
              return Math.floor(i2);
            }
            return t.objectMode ? 16 : 16 * 1024;
          }
          ZZ.exports = { getHighWaterMark: pxe };
        });
        var DI = A((hut, JZ) => {
          c();
          JZ.exports = mxe;
          function mxe(t, e) {
            if (PI("noDeprecation"))
              return t;
            var r = false;
            function n() {
              if (!r) {
                if (PI("throwDeprecation"))
                  throw new Error(e);
                PI("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
              }
              return t.apply(this, arguments);
            }
            return n;
          }
          function PI(t) {
            try {
              if (!globalThis.localStorage)
                return false;
            } catch {
              return false;
            }
            var e = globalThis.localStorage[t];
            return e == null ? false : String(e).toLowerCase() === "true";
          }
        });
        var OI = A((dut, oJ) => {
          "use strict";
          c();
          oJ.exports = Yr;
          function tJ(t) {
            var e = this;
            this.next = null, this.entry = null, this.finish = function() {
              qxe(e, t);
            };
          }
          var s1;
          Yr.WritableState = dg;
          var yxe = { deprecate: DI() }, rJ = RI(), iE = _i().Buffer, gxe = globalThis.Uint8Array || function() {
          };
          function wxe(t) {
            return iE.from(t);
          }
          function Exe(t) {
            return iE.isBuffer(t) || t instanceof gxe;
          }
          var NI = II(), bxe = CI(), _xe = bxe.getHighWaterMark, $l = ed().codes, vxe = $l.ERR_INVALID_ARG_TYPE, Sxe = $l.ERR_METHOD_NOT_IMPLEMENTED, xxe = $l.ERR_MULTIPLE_CALLBACK, Rxe = $l.ERR_STREAM_CANNOT_PIPE, Axe = $l.ERR_STREAM_DESTROYED, Txe = $l.ERR_STREAM_NULL_VALUES, Ixe = $l.ERR_STREAM_WRITE_AFTER_END, Cxe = $l.ERR_UNKNOWN_ENCODING, a1 = NI.errorOrDestroy;
          ni()(Yr, rJ);
          function Pxe() {
          }
          function dg(t, e, r) {
            s1 = s1 || td(), t = t || {}, typeof r != "boolean" && (r = e instanceof s1), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = _xe(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
            var n = t.decodeStrings === false;
            this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i2) {
              Mxe(e, i2);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new tJ(this);
          }
          dg.prototype.getBuffer = function() {
            for (var e = this.bufferedRequest, r = []; e; )
              r.push(e), e = e.next;
            return r;
          };
          (function() {
            try {
              Object.defineProperty(dg.prototype, "buffer", { get: yxe.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch {
            }
          })();
          var nE;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (nE = Function.prototype[Symbol.hasInstance], Object.defineProperty(Yr, Symbol.hasInstance, { value: function(e) {
            return nE.call(this, e) ? true : this !== Yr ? false : e && e._writableState instanceof dg;
          } })) : nE = function(e) {
            return e instanceof this;
          };
          function Yr(t) {
            s1 = s1 || td();
            var e = this instanceof s1;
            if (!e && !nE.call(Yr, this))
              return new Yr(t);
            this._writableState = new dg(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), rJ.call(this);
          }
          Yr.prototype.pipe = function() {
            a1(this, new Rxe());
          };
          function Dxe(t, e) {
            var r = new Ixe();
            a1(t, r), process.nextTick(e, r);
          }
          function kxe(t, e, r, n) {
            var i2;
            return r === null ? i2 = new Txe() : typeof r != "string" && !e.objectMode && (i2 = new vxe("chunk", ["string", "Buffer"], r)), i2 ? (a1(t, i2), process.nextTick(n, i2), false) : true;
          }
          Yr.prototype.write = function(t, e, r) {
            var n = this._writableState, i2 = false, o = !n.objectMode && Exe(t);
            return o && !iE.isBuffer(t) && (t = wxe(t)), typeof e == "function" && (r = e, e = null), o ? e = "buffer" : e || (e = n.defaultEncoding), typeof r != "function" && (r = Pxe), n.ending ? Dxe(this, r) : (o || kxe(this, n, t, r)) && (n.pendingcb++, i2 = Oxe(this, n, o, t, e, r)), i2;
          };
          Yr.prototype.cork = function() {
            this._writableState.corked++;
          };
          Yr.prototype.uncork = function() {
            var t = this._writableState;
            t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && nJ(this, t));
          };
          Yr.prototype.setDefaultEncoding = function(e) {
            if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
              throw new Cxe(e);
            return this._writableState.defaultEncoding = e, this;
          };
          Object.defineProperty(Yr.prototype, "writableBuffer", { enumerable: false, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } });
          function Nxe(t, e, r) {
            return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = iE.from(e, r)), e;
          }
          Object.defineProperty(Yr.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
            return this._writableState.highWaterMark;
          } });
          function Oxe(t, e, r, n, i2, o) {
            if (!r) {
              var s = Nxe(e, n, i2);
              n !== s && (r = true, i2 = "buffer", n = s);
            }
            var a = e.objectMode ? 1 : n.length;
            e.length += a;
            var u = e.length < e.highWaterMark;
            if (u || (e.needDrain = true), e.writing || e.corked) {
              var l = e.lastBufferedRequest;
              e.lastBufferedRequest = { chunk: n, encoding: i2, isBuf: r, callback: o, next: null }, l ? l.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
            } else
              kI(t, e, false, a, n, i2, o);
            return u;
          }
          function kI(t, e, r, n, i2, o, s) {
            e.writelen = n, e.writecb = s, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new Axe("write")) : r ? t._writev(i2, e.onwrite) : t._write(i2, o, e.onwrite), e.sync = false;
          }
          function Lxe(t, e, r, n, i2) {
            --e.pendingcb, r ? (process.nextTick(i2, n), process.nextTick(hg, t, e), t._writableState.errorEmitted = true, a1(t, n)) : (i2(n), t._writableState.errorEmitted = true, a1(t, n), hg(t, e));
          }
          function Bxe(t) {
            t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
          }
          function Mxe(t, e) {
            var r = t._writableState, n = r.sync, i2 = r.writecb;
            if (typeof i2 != "function")
              throw new xxe();
            if (Bxe(r), e)
              Lxe(t, r, n, e, i2);
            else {
              var o = iJ(r) || t.destroyed;
              !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && nJ(t, r), n ? process.nextTick(eJ, t, r, o, i2) : eJ(t, r, o, i2);
            }
          }
          function eJ(t, e, r, n) {
            r || Uxe(t, e), e.pendingcb--, n(), hg(t, e);
          }
          function Uxe(t, e) {
            e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
          }
          function nJ(t, e) {
            e.bufferProcessing = true;
            var r = e.bufferedRequest;
            if (t._writev && r && r.next) {
              var n = e.bufferedRequestCount, i2 = new Array(n), o = e.corkedRequestsFree;
              o.entry = r;
              for (var s = 0, a = true; r; )
                i2[s] = r, r.isBuf || (a = false), r = r.next, s += 1;
              i2.allBuffers = a, kI(t, e, true, e.length, i2, "", o.finish), e.pendingcb++, e.lastBufferedRequest = null, o.next ? (e.corkedRequestsFree = o.next, o.next = null) : e.corkedRequestsFree = new tJ(e), e.bufferedRequestCount = 0;
            } else {
              for (; r; ) {
                var u = r.chunk, l = r.encoding, f = r.callback, h = e.objectMode ? 1 : u.length;
                if (kI(t, e, false, h, u, l, f), r = r.next, e.bufferedRequestCount--, e.writing)
                  break;
              }
              r === null && (e.lastBufferedRequest = null);
            }
            e.bufferedRequest = r, e.bufferProcessing = false;
          }
          Yr.prototype._write = function(t, e, r) {
            r(new Sxe("_write()"));
          };
          Yr.prototype._writev = null;
          Yr.prototype.end = function(t, e, r) {
            var n = this._writableState;
            return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || Vxe(this, n, r), this;
          };
          Object.defineProperty(Yr.prototype, "writableLength", { enumerable: false, get: function() {
            return this._writableState.length;
          } });
          function iJ(t) {
            return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
          }
          function Fxe(t, e) {
            t._final(function(r) {
              e.pendingcb--, r && a1(t, r), e.prefinished = true, t.emit("prefinish"), hg(t, e);
            });
          }
          function Kxe(t, e) {
            !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(Fxe, t, e)) : (e.prefinished = true, t.emit("prefinish")));
          }
          function hg(t, e) {
            var r = iJ(e);
            if (r && (Kxe(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
              var n = t._readableState;
              (!n || n.autoDestroy && n.endEmitted) && t.destroy();
            }
            return r;
          }
          function Vxe(t, e, r) {
            e.ending = true, hg(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
          }
          function qxe(t, e, r) {
            var n = t.entry;
            for (t.entry = null; n; ) {
              var i2 = n.callback;
              e.pendingcb--, i2(r), n = n.next;
            }
            e.corkedRequestsFree.next = t;
          }
          Object.defineProperty(Yr.prototype, "destroyed", { enumerable: false, get: function() {
            return this._writableState === void 0 ? false : this._writableState.destroyed;
          }, set: function(e) {
            !this._writableState || (this._writableState.destroyed = e);
          } });
          Yr.prototype.destroy = NI.destroy;
          Yr.prototype._undestroy = NI.undestroy;
          Yr.prototype._destroy = function(t, e) {
            e(t);
          };
        });
        var td = A((put, aJ) => {
          "use strict";
          c();
          var zxe = Object.keys || function(t) {
            var e = [];
            for (var r in t)
              e.push(r);
            return e;
          };
          aJ.exports = Ga;
          var sJ = MI(), BI = OI();
          ni()(Ga, sJ);
          for (LI = zxe(BI.prototype), oE = 0; oE < LI.length; oE++)
            sE = LI[oE], Ga.prototype[sE] || (Ga.prototype[sE] = BI.prototype[sE]);
          var LI, sE, oE;
          function Ga(t) {
            if (!(this instanceof Ga))
              return new Ga(t);
            sJ.call(this, t), BI.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Hxe)));
          }
          Object.defineProperty(Ga.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
            return this._writableState.highWaterMark;
          } });
          Object.defineProperty(Ga.prototype, "writableBuffer", { enumerable: false, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } });
          Object.defineProperty(Ga.prototype, "writableLength", { enumerable: false, get: function() {
            return this._writableState.length;
          } });
          function Hxe() {
            this._writableState.ended || process.nextTick($xe, this);
          }
          function $xe(t) {
            t.end();
          }
          Object.defineProperty(Ga.prototype, "destroyed", { enumerable: false, get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(e) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
          } });
        });
        var lJ = A((UI, uJ) => {
          c();
          var aE = _i(), Jc = aE.Buffer;
          function cJ(t, e) {
            for (var r in t)
              e[r] = t[r];
          }
          Jc.from && Jc.alloc && Jc.allocUnsafe && Jc.allocUnsafeSlow ? uJ.exports = aE : (cJ(aE, UI), UI.Buffer = c1);
          function c1(t, e, r) {
            return Jc(t, e, r);
          }
          cJ(Jc, c1);
          c1.from = function(t, e, r) {
            if (typeof t == "number")
              throw new TypeError("Argument must not be a number");
            return Jc(t, e, r);
          };
          c1.alloc = function(t, e, r) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            var n = Jc(t);
            return e !== void 0 ? typeof r == "string" ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
          };
          c1.allocUnsafe = function(t) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            return Jc(t);
          };
          c1.allocUnsafeSlow = function(t) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            return aE.SlowBuffer(t);
          };
        });
        var mg = A((hJ) => {
          "use strict";
          c();
          var KI = lJ().Buffer, fJ = KI.isEncoding || function(t) {
            switch (t = "" + t, t && t.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };
          function Gxe(t) {
            if (!t)
              return "utf8";
            for (var e; ; )
              switch (t) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return t;
                default:
                  if (e)
                    return;
                  t = ("" + t).toLowerCase(), e = true;
              }
          }
          function Wxe(t) {
            var e = Gxe(t);
            if (typeof e != "string" && (KI.isEncoding === fJ || !fJ(t)))
              throw new Error("Unknown encoding: " + t);
            return e || t;
          }
          hJ.StringDecoder = pg;
          function pg(t) {
            this.encoding = Wxe(t);
            var e;
            switch (this.encoding) {
              case "utf16le":
                this.text = Jxe, this.end = eRe, e = 4;
                break;
              case "utf8":
                this.fillLast = Qxe, e = 4;
                break;
              case "base64":
                this.text = tRe, this.end = rRe, e = 3;
                break;
              default:
                this.write = nRe, this.end = iRe;
                return;
            }
            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = KI.allocUnsafe(e);
          }
          pg.prototype.write = function(t) {
            if (t.length === 0)
              return "";
            var e, r;
            if (this.lastNeed) {
              if (e = this.fillLast(t), e === void 0)
                return "";
              r = this.lastNeed, this.lastNeed = 0;
            } else
              r = 0;
            return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
          };
          pg.prototype.end = Zxe;
          pg.prototype.text = Xxe;
          pg.prototype.fillLast = function(t) {
            if (this.lastNeed <= t.length)
              return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
            t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
          };
          function FI(t) {
            return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
          }
          function jxe(t, e, r) {
            var n = e.length - 1;
            if (n < r)
              return 0;
            var i2 = FI(e[n]);
            return i2 >= 0 ? (i2 > 0 && (t.lastNeed = i2 - 1), i2) : --n < r || i2 === -2 ? 0 : (i2 = FI(e[n]), i2 >= 0 ? (i2 > 0 && (t.lastNeed = i2 - 2), i2) : --n < r || i2 === -2 ? 0 : (i2 = FI(e[n]), i2 >= 0 ? (i2 > 0 && (i2 === 2 ? i2 = 0 : t.lastNeed = i2 - 3), i2) : 0));
          }
          function Yxe(t, e, r) {
            if ((e[0] & 192) !== 128)
              return t.lastNeed = 0, "\uFFFD";
            if (t.lastNeed > 1 && e.length > 1) {
              if ((e[1] & 192) !== 128)
                return t.lastNeed = 1, "\uFFFD";
              if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
                return t.lastNeed = 2, "\uFFFD";
            }
          }
          function Qxe(t) {
            var e = this.lastTotal - this.lastNeed, r = Yxe(this, t, e);
            if (r !== void 0)
              return r;
            if (this.lastNeed <= t.length)
              return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
            t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
          }
          function Xxe(t, e) {
            var r = jxe(this, t, e);
            if (!this.lastNeed)
              return t.toString("utf8", e);
            this.lastTotal = r;
            var n = t.length - (r - this.lastNeed);
            return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n);
          }
          function Zxe(t) {
            var e = t && t.length ? this.write(t) : "";
            return this.lastNeed ? e + "\uFFFD" : e;
          }
          function Jxe(t, e) {
            if ((t.length - e) % 2 === 0) {
              var r = t.toString("utf16le", e);
              if (r) {
                var n = r.charCodeAt(r.length - 1);
                if (n >= 55296 && n <= 56319)
                  return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
              }
              return r;
            }
            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
          }
          function eRe(t) {
            var e = t && t.length ? this.write(t) : "";
            if (this.lastNeed) {
              var r = this.lastTotal - this.lastNeed;
              return e + this.lastChar.toString("utf16le", 0, r);
            }
            return e;
          }
          function tRe(t, e) {
            var r = (t.length - e) % 3;
            return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
          }
          function rRe(t) {
            var e = t && t.length ? this.write(t) : "";
            return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
          }
          function nRe(t) {
            return t.toString(this.encoding);
          }
          function iRe(t) {
            return t && t.length ? this.write(t) : "";
          }
        });
        var cE = A((yut, mJ) => {
          "use strict";
          c();
          var dJ = ed().codes.ERR_STREAM_PREMATURE_CLOSE;
          function oRe(t) {
            var e = false;
            return function() {
              if (!e) {
                e = true;
                for (var r = arguments.length, n = new Array(r), i2 = 0; i2 < r; i2++)
                  n[i2] = arguments[i2];
                t.apply(this, n);
              }
            };
          }
          function sRe() {
          }
          function aRe(t) {
            return t.setHeader && typeof t.abort == "function";
          }
          function pJ(t, e, r) {
            if (typeof e == "function")
              return pJ(t, null, e);
            e || (e = {}), r = oRe(r || sRe);
            var n = e.readable || e.readable !== false && t.readable, i2 = e.writable || e.writable !== false && t.writable, o = function() {
              t.writable || a();
            }, s = t._writableState && t._writableState.finished, a = function() {
              i2 = false, s = true, n || r.call(t);
            }, u = t._readableState && t._readableState.endEmitted, l = function() {
              n = false, u = true, i2 || r.call(t);
            }, f = function(m) {
              r.call(t, m);
            }, h = function() {
              var m;
              if (n && !u)
                return (!t._readableState || !t._readableState.ended) && (m = new dJ()), r.call(t, m);
              if (i2 && !s)
                return (!t._writableState || !t._writableState.ended) && (m = new dJ()), r.call(t, m);
            }, p = function() {
              t.req.on("finish", a);
            };
            return aRe(t) ? (t.on("complete", a), t.on("abort", h), t.req ? p() : t.on("request", p)) : i2 && !t._writableState && (t.on("end", o), t.on("close", o)), t.on("end", l), t.on("finish", a), e.error !== false && t.on("error", f), t.on("close", h), function() {
              t.removeListener("complete", a), t.removeListener("abort", h), t.removeListener("request", p), t.req && t.req.removeListener("finish", a), t.removeListener("end", o), t.removeListener("close", o), t.removeListener("finish", a), t.removeListener("end", l), t.removeListener("error", f), t.removeListener("close", h);
            };
          }
          mJ.exports = pJ;
        });
        var gJ = A((gut, yJ) => {
          "use strict";
          c();
          var uE;
          function Gl(t, e, r) {
            return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
          }
          var cRe = cE(), Wl = Symbol("lastResolve"), rd = Symbol("lastReject"), yg = Symbol("error"), lE = Symbol("ended"), nd = Symbol("lastPromise"), VI = Symbol("handlePromise"), id = Symbol("stream");
          function jl(t, e) {
            return { value: t, done: e };
          }
          function uRe(t) {
            var e = t[Wl];
            if (e !== null) {
              var r = t[id].read();
              r !== null && (t[nd] = null, t[Wl] = null, t[rd] = null, e(jl(r, false)));
            }
          }
          function lRe(t) {
            process.nextTick(uRe, t);
          }
          function fRe(t, e) {
            return function(r, n) {
              t.then(function() {
                if (e[lE]) {
                  r(jl(void 0, true));
                  return;
                }
                e[VI](r, n);
              }, n);
            };
          }
          var hRe = Object.getPrototypeOf(function() {
          }), dRe = Object.setPrototypeOf((uE = { get stream() {
            return this[id];
          }, next: function() {
            var e = this, r = this[yg];
            if (r !== null)
              return Promise.reject(r);
            if (this[lE])
              return Promise.resolve(jl(void 0, true));
            if (this[id].destroyed)
              return new Promise(function(s, a) {
                process.nextTick(function() {
                  e[yg] ? a(e[yg]) : s(jl(void 0, true));
                });
              });
            var n = this[nd], i2;
            if (n)
              i2 = new Promise(fRe(n, this));
            else {
              var o = this[id].read();
              if (o !== null)
                return Promise.resolve(jl(o, false));
              i2 = new Promise(this[VI]);
            }
            return this[nd] = i2, i2;
          } }, Gl(uE, Symbol.asyncIterator, function() {
            return this;
          }), Gl(uE, "return", function() {
            var e = this;
            return new Promise(function(r, n) {
              e[id].destroy(null, function(i2) {
                if (i2) {
                  n(i2);
                  return;
                }
                r(jl(void 0, true));
              });
            });
          }), uE), hRe), pRe = function(e) {
            var r, n = Object.create(dRe, (r = {}, Gl(r, id, { value: e, writable: true }), Gl(r, Wl, { value: null, writable: true }), Gl(r, rd, { value: null, writable: true }), Gl(r, yg, { value: null, writable: true }), Gl(r, lE, { value: e._readableState.endEmitted, writable: true }), Gl(r, VI, { value: function(o, s) {
              var a = n[id].read();
              a ? (n[nd] = null, n[Wl] = null, n[rd] = null, o(jl(a, false))) : (n[Wl] = o, n[rd] = s);
            }, writable: true }), r));
            return n[nd] = null, cRe(e, function(i2) {
              if (i2 && i2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var o = n[rd];
                o !== null && (n[nd] = null, n[Wl] = null, n[rd] = null, o(i2)), n[yg] = i2;
                return;
              }
              var s = n[Wl];
              s !== null && (n[nd] = null, n[Wl] = null, n[rd] = null, s(jl(void 0, true))), n[lE] = true;
            }), e.on("readable", lRe.bind(null, n)), n;
          };
          yJ.exports = pRe;
        });
        var EJ = A((wut, wJ) => {
          c();
          wJ.exports = function() {
            throw new Error("Readable.from is not available in the browser");
          };
        });
        var MI = A((but, CJ) => {
          "use strict";
          c();
          CJ.exports = Ft;
          var u1;
          Ft.ReadableState = SJ;
          var Eut = In().EventEmitter, vJ = function(e, r) {
            return e.listeners(r).length;
          }, wg = RI(), fE = _i().Buffer, mRe = globalThis.Uint8Array || function() {
          };
          function yRe(t) {
            return fE.from(t);
          }
          function gRe(t) {
            return fE.isBuffer(t) || t instanceof mRe;
          }
          var qI = fg(), yt;
          qI && qI.debuglog ? yt = qI.debuglog("stream") : yt = function() {
          };
          var wRe = GZ(), YI = II(), ERe = CI(), bRe = ERe.getHighWaterMark, hE = ed().codes, _Re = hE.ERR_INVALID_ARG_TYPE, vRe = hE.ERR_STREAM_PUSH_AFTER_EOF, SRe = hE.ERR_METHOD_NOT_IMPLEMENTED, xRe = hE.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, l1, zI, HI;
          ni()(Ft, wg);
          var gg = YI.errorOrDestroy, $I = ["error", "close", "destroy", "pause", "resume"];
          function RRe(t, e, r) {
            if (typeof t.prependListener == "function")
              return t.prependListener(e, r);
            !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
          }
          function SJ(t, e, r) {
            u1 = u1 || td(), t = t || {}, typeof r != "boolean" && (r = e instanceof u1), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = bRe(this, t, "readableHighWaterMark", r), this.buffer = new wRe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (l1 || (l1 = mg().StringDecoder), this.decoder = new l1(t.encoding), this.encoding = t.encoding);
          }
          function Ft(t) {
            if (u1 = u1 || td(), !(this instanceof Ft))
              return new Ft(t);
            var e = this instanceof u1;
            this._readableState = new SJ(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), wg.call(this);
          }
          Object.defineProperty(Ft.prototype, "destroyed", { enumerable: false, get: function() {
            return this._readableState === void 0 ? false : this._readableState.destroyed;
          }, set: function(e) {
            !this._readableState || (this._readableState.destroyed = e);
          } });
          Ft.prototype.destroy = YI.destroy;
          Ft.prototype._undestroy = YI.undestroy;
          Ft.prototype._destroy = function(t, e) {
            e(t);
          };
          Ft.prototype.push = function(t, e) {
            var r = this._readableState, n;
            return r.objectMode ? n = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = fE.from(t, e), e = ""), n = true), xJ(this, t, e, false, n);
          };
          Ft.prototype.unshift = function(t) {
            return xJ(this, t, null, true, false);
          };
          function xJ(t, e, r, n, i2) {
            yt("readableAddChunk", e);
            var o = t._readableState;
            if (e === null)
              o.reading = false, IRe(t, o);
            else {
              var s;
              if (i2 || (s = ARe(o, e)), s)
                gg(t, s);
              else if (o.objectMode || e && e.length > 0)
                if (typeof e != "string" && !o.objectMode && Object.getPrototypeOf(e) !== fE.prototype && (e = yRe(e)), n)
                  o.endEmitted ? gg(t, new xRe()) : GI(t, o, e, true);
                else if (o.ended)
                  gg(t, new vRe());
                else {
                  if (o.destroyed)
                    return false;
                  o.reading = false, o.decoder && !r ? (e = o.decoder.write(e), o.objectMode || e.length !== 0 ? GI(t, o, e, false) : jI(t, o)) : GI(t, o, e, false);
                }
              else
                n || (o.reading = false, jI(t, o));
            }
            return !o.ended && (o.length < o.highWaterMark || o.length === 0);
          }
          function GI(t, e, r, n) {
            e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && dE(t)), jI(t, e);
          }
          function ARe(t, e) {
            var r;
            return !gRe(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new _Re("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
          }
          Ft.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Ft.prototype.setEncoding = function(t) {
            l1 || (l1 = mg().StringDecoder);
            var e = new l1(t);
            this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var r = this._readableState.buffer.head, n = ""; r !== null; )
              n += e.write(r.data), r = r.next;
            return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
          };
          var bJ = 1073741824;
          function TRe(t) {
            return t >= bJ ? t = bJ : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
          }
          function _J(t, e) {
            return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = TRe(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
          }
          Ft.prototype.read = function(t) {
            yt("read", t), t = parseInt(t, 10);
            var e = this._readableState, r = t;
            if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
              return yt("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? WI(this) : dE(this), null;
            if (t = _J(t, e), t === 0 && e.ended)
              return e.length === 0 && WI(this), null;
            var n = e.needReadable;
            yt("need readable", n), (e.length === 0 || e.length - t < e.highWaterMark) && (n = true, yt("length less than watermark", n)), e.ended || e.reading ? (n = false, yt("reading or ended", n)) : n && (yt("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = _J(r, e)));
            var i2;
            return t > 0 ? i2 = TJ(t, e) : i2 = null, i2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && WI(this)), i2 !== null && this.emit("data", i2), i2;
          };
          function IRe(t, e) {
            if (yt("onEofChunk"), !e.ended) {
              if (e.decoder) {
                var r = e.decoder.end();
                r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
              }
              e.ended = true, e.sync ? dE(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, RJ(t)));
            }
          }
          function dE(t) {
            var e = t._readableState;
            yt("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (yt("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(RJ, t));
          }
          function RJ(t) {
            var e = t._readableState;
            yt("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, QI(t);
          }
          function jI(t, e) {
            e.readingMore || (e.readingMore = true, process.nextTick(CRe, t, e));
          }
          function CRe(t, e) {
            for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
              var r = e.length;
              if (yt("maybeReadMore read 0"), t.read(0), r === e.length)
                break;
            }
            e.readingMore = false;
          }
          Ft.prototype._read = function(t) {
            gg(this, new SRe("_read()"));
          };
          Ft.prototype.pipe = function(t, e) {
            var r = this, n = this._readableState;
            switch (n.pipesCount) {
              case 0:
                n.pipes = t;
                break;
              case 1:
                n.pipes = [n.pipes, t];
                break;
              default:
                n.pipes.push(t);
                break;
            }
            n.pipesCount += 1, yt("pipe count=%d opts=%j", n.pipesCount, e);
            var i2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, o = i2 ? a : y;
            n.endEmitted ? process.nextTick(o) : r.once("end", o), t.on("unpipe", s);
            function s(g, E) {
              yt("onunpipe"), g === r && E && E.hasUnpiped === false && (E.hasUnpiped = true, f());
            }
            function a() {
              yt("onend"), t.end();
            }
            var u = PRe(r);
            t.on("drain", u);
            var l = false;
            function f() {
              yt("cleanup"), t.removeListener("close", d), t.removeListener("finish", m), t.removeListener("drain", u), t.removeListener("error", p), t.removeListener("unpipe", s), r.removeListener("end", a), r.removeListener("end", y), r.removeListener("data", h), l = true, n.awaitDrain && (!t._writableState || t._writableState.needDrain) && u();
            }
            r.on("data", h);
            function h(g) {
              yt("ondata");
              var E = t.write(g);
              yt("dest.write", E), E === false && ((n.pipesCount === 1 && n.pipes === t || n.pipesCount > 1 && IJ(n.pipes, t) !== -1) && !l && (yt("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
            }
            function p(g) {
              yt("onerror", g), y(), t.removeListener("error", p), vJ(t, "error") === 0 && gg(t, g);
            }
            RRe(t, "error", p);
            function d() {
              t.removeListener("finish", m), y();
            }
            t.once("close", d);
            function m() {
              yt("onfinish"), t.removeListener("close", d), y();
            }
            t.once("finish", m);
            function y() {
              yt("unpipe"), r.unpipe(t);
            }
            return t.emit("pipe", r), n.flowing || (yt("pipe resume"), r.resume()), t;
          };
          function PRe(t) {
            return function() {
              var r = t._readableState;
              yt("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && vJ(t, "data") && (r.flowing = true, QI(t));
            };
          }
          Ft.prototype.unpipe = function(t) {
            var e = this._readableState, r = { hasUnpiped: false };
            if (e.pipesCount === 0)
              return this;
            if (e.pipesCount === 1)
              return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
            if (!t) {
              var n = e.pipes, i2 = e.pipesCount;
              e.pipes = null, e.pipesCount = 0, e.flowing = false;
              for (var o = 0; o < i2; o++)
                n[o].emit("unpipe", this, { hasUnpiped: false });
              return this;
            }
            var s = IJ(e.pipes, t);
            return s === -1 ? this : (e.pipes.splice(s, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
          };
          Ft.prototype.on = function(t, e) {
            var r = wg.prototype.on.call(this, t, e), n = this._readableState;
            return t === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : t === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, yt("on readable", n.length, n.reading), n.length ? dE(this) : n.reading || process.nextTick(DRe, this)), r;
          };
          Ft.prototype.addListener = Ft.prototype.on;
          Ft.prototype.removeListener = function(t, e) {
            var r = wg.prototype.removeListener.call(this, t, e);
            return t === "readable" && process.nextTick(AJ, this), r;
          };
          Ft.prototype.removeAllListeners = function(t) {
            var e = wg.prototype.removeAllListeners.apply(this, arguments);
            return (t === "readable" || t === void 0) && process.nextTick(AJ, this), e;
          };
          function AJ(t) {
            var e = t._readableState;
            e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
          }
          function DRe(t) {
            yt("readable nexttick read 0"), t.read(0);
          }
          Ft.prototype.resume = function() {
            var t = this._readableState;
            return t.flowing || (yt("resume"), t.flowing = !t.readableListening, kRe(this, t)), t.paused = false, this;
          };
          function kRe(t, e) {
            e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(NRe, t, e));
          }
          function NRe(t, e) {
            yt("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), QI(t), e.flowing && !e.reading && t.read(0);
          }
          Ft.prototype.pause = function() {
            return yt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (yt("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
          };
          function QI(t) {
            var e = t._readableState;
            for (yt("flow", e.flowing); e.flowing && t.read() !== null; )
              ;
          }
          Ft.prototype.wrap = function(t) {
            var e = this, r = this._readableState, n = false;
            t.on("end", function() {
              if (yt("wrapped end"), r.decoder && !r.ended) {
                var s = r.decoder.end();
                s && s.length && e.push(s);
              }
              e.push(null);
            }), t.on("data", function(s) {
              if (yt("wrapped data"), r.decoder && (s = r.decoder.write(s)), !(r.objectMode && s == null) && !(!r.objectMode && (!s || !s.length))) {
                var a = e.push(s);
                a || (n = true, t.pause());
              }
            });
            for (var i2 in t)
              this[i2] === void 0 && typeof t[i2] == "function" && (this[i2] = function(a) {
                return function() {
                  return t[a].apply(t, arguments);
                };
              }(i2));
            for (var o = 0; o < $I.length; o++)
              t.on($I[o], this.emit.bind(this, $I[o]));
            return this._read = function(s) {
              yt("wrapped _read", s), n && (n = false, t.resume());
            }, this;
          };
          typeof Symbol == "function" && (Ft.prototype[Symbol.asyncIterator] = function() {
            return zI === void 0 && (zI = gJ()), zI(this);
          });
          Object.defineProperty(Ft.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
            return this._readableState.highWaterMark;
          } });
          Object.defineProperty(Ft.prototype, "readableBuffer", { enumerable: false, get: function() {
            return this._readableState && this._readableState.buffer;
          } });
          Object.defineProperty(Ft.prototype, "readableFlowing", { enumerable: false, get: function() {
            return this._readableState.flowing;
          }, set: function(e) {
            this._readableState && (this._readableState.flowing = e);
          } });
          Ft._fromList = TJ;
          Object.defineProperty(Ft.prototype, "readableLength", { enumerable: false, get: function() {
            return this._readableState.length;
          } });
          function TJ(t, e) {
            if (e.length === 0)
              return null;
            var r;
            return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
          }
          function WI(t) {
            var e = t._readableState;
            yt("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ORe, e, t));
          }
          function ORe(t, e) {
            if (yt("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
              var r = e._writableState;
              (!r || r.autoDestroy && r.finished) && e.destroy();
            }
          }
          typeof Symbol == "function" && (Ft.from = function(t, e) {
            return HI === void 0 && (HI = EJ()), HI(Ft, t, e);
          });
          function IJ(t, e) {
            for (var r = 0, n = t.length; r < n; r++)
              if (t[r] === e)
                return r;
            return -1;
          }
        });
        var XI = A((_ut, DJ) => {
          "use strict";
          c();
          DJ.exports = eu;
          var pE = ed().codes, LRe = pE.ERR_METHOD_NOT_IMPLEMENTED, BRe = pE.ERR_MULTIPLE_CALLBACK, MRe = pE.ERR_TRANSFORM_ALREADY_TRANSFORMING, URe = pE.ERR_TRANSFORM_WITH_LENGTH_0, mE = td();
          ni()(eu, mE);
          function FRe(t, e) {
            var r = this._transformState;
            r.transforming = false;
            var n = r.writecb;
            if (n === null)
              return this.emit("error", new BRe());
            r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
            var i2 = this._readableState;
            i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
          function eu(t) {
            if (!(this instanceof eu))
              return new eu(t);
            mE.call(this, t), this._transformState = { afterTransform: FRe.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", KRe);
          }
          function KRe() {
            var t = this;
            typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
              PJ(t, e, r);
            }) : PJ(this, null, null);
          }
          eu.prototype.push = function(t, e) {
            return this._transformState.needTransform = false, mE.prototype.push.call(this, t, e);
          };
          eu.prototype._transform = function(t, e, r) {
            r(new LRe("_transform()"));
          };
          eu.prototype._write = function(t, e, r) {
            var n = this._transformState;
            if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
              var i2 = this._readableState;
              (n.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
            }
          };
          eu.prototype._read = function(t) {
            var e = this._transformState;
            e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
          };
          eu.prototype._destroy = function(t, e) {
            mE.prototype._destroy.call(this, t, function(r) {
              e(r);
            });
          };
          function PJ(t, e, r) {
            if (e)
              return t.emit("error", e);
            if (r != null && t.push(r), t._writableState.length)
              throw new URe();
            if (t._transformState.transforming)
              throw new MRe();
            return t.push(null);
          }
        });
        var OJ = A((vut, NJ) => {
          "use strict";
          c();
          NJ.exports = Eg;
          var kJ = XI();
          ni()(Eg, kJ);
          function Eg(t) {
            if (!(this instanceof Eg))
              return new Eg(t);
            kJ.call(this, t);
          }
          Eg.prototype._transform = function(t, e, r) {
            r(null, t);
          };
        });
        var FJ = A((Sut, UJ) => {
          "use strict";
          c();
          var ZI;
          function VRe(t) {
            var e = false;
            return function() {
              e || (e = true, t.apply(void 0, arguments));
            };
          }
          var MJ = ed().codes, qRe = MJ.ERR_MISSING_ARGS, zRe = MJ.ERR_STREAM_DESTROYED;
          function LJ(t) {
            if (t)
              throw t;
          }
          function HRe(t) {
            return t.setHeader && typeof t.abort == "function";
          }
          function $Re(t, e, r, n) {
            n = VRe(n);
            var i2 = false;
            t.on("close", function() {
              i2 = true;
            }), ZI === void 0 && (ZI = cE()), ZI(t, { readable: e, writable: r }, function(s) {
              if (s)
                return n(s);
              i2 = true, n();
            });
            var o = false;
            return function(s) {
              if (!i2 && !o) {
                if (o = true, HRe(t))
                  return t.abort();
                if (typeof t.destroy == "function")
                  return t.destroy();
                n(s || new zRe("pipe"));
              }
            };
          }
          function BJ(t) {
            t();
          }
          function GRe(t, e) {
            return t.pipe(e);
          }
          function WRe(t) {
            return !t.length || typeof t[t.length - 1] != "function" ? LJ : t.pop();
          }
          function jRe() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
              e[r] = arguments[r];
            var n = WRe(e);
            if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
              throw new qRe("streams");
            var i2, o = e.map(function(s, a) {
              var u = a < e.length - 1, l = a > 0;
              return $Re(s, u, l, function(f) {
                i2 || (i2 = f), f && o.forEach(BJ), !u && (o.forEach(BJ), n(i2));
              });
            });
            return e.reduce(GRe);
          }
          UJ.exports = jRe;
        });
        var VJ = A((ss, KJ) => {
          c();
          ss = KJ.exports = MI();
          ss.Stream = ss;
          ss.Readable = ss;
          ss.Writable = OI();
          ss.Duplex = td();
          ss.Transform = XI();
          ss.PassThrough = OJ();
          ss.finished = cE();
          ss.pipeline = FJ();
        });
        var HJ = A((xut, zJ) => {
          "use strict";
          c();
          var YRe = ni(), { Readable: qJ } = VJ();
          zJ.exports = f1;
          YRe(f1, qJ);
          function f1(t, e) {
            if (!(this instanceof f1))
              return new f1(t, e);
            e = e || {}, qJ.call(this, Object.assign({}, e, { objectMode: true })), this._iterator = t, this._options = e, this.on("end", this.destroy.bind(this, null, null));
          }
          f1.prototype._read = function() {
            this.destroyed || this._iterator.next((t, e, r) => {
              if (!this.destroyed) {
                if (t)
                  return this.destroy(t);
                e === void 0 && r === void 0 ? this.push(null) : this._options.keys !== false && this._options.values === false ? this.push(e) : this._options.keys === false && this._options.values !== false ? this.push(r) : this.push({ key: e, value: r });
              }
            });
          };
          f1.prototype._destroy = function(t, e) {
            this._iterator.end(function(r) {
              e(t || r);
            });
          };
        });
        var gE = A((Rut, yE) => {
          "use strict";
          c();
          function sd(t, e) {
            let r = function(n, i2) {
              if (typeof n == "object" && n !== null && (i2 = i2 || n, n = n.message || n.name), n = n || "", i2 = i2 || void 0, typeof i2 == "object" && i2.type === t && i2.message === n)
                return i2;
              Object.defineProperty(this, "type", { value: t, enumerable: false, writable: true, configurable: true }), Object.defineProperty(this, "name", { value: t, enumerable: false, writable: true, configurable: true }), Object.defineProperty(this, "cause", { value: i2, enumerable: false, writable: true, configurable: true }), Object.defineProperty(this, "message", { value: n, enumerable: false, writable: true, configurable: true }), Error.call(this), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, r);
            };
            return r.prototype = new e(), r;
          }
          var od = sd("LevelUPError", Error);
          yE.exports = { LevelUPError: od, InitializationError: sd("InitializationError", od), OpenError: sd("OpenError", od), ReadError: sd("ReadError", od), WriteError: sd("WriteError", od), NotFoundError: sd("NotFoundError", od), EncodingError: sd("EncodingError", od) };
          yE.exports.NotFoundError.prototype.notFound = true;
          yE.exports.NotFoundError.prototype.status = 404;
        });
        var bg = A((JI) => {
          "use strict";
          c();
          JI.getCallback = function(t, e) {
            return typeof t == "function" ? t : e;
          };
          JI.getOptions = function(t) {
            return typeof t == "object" && t !== null ? t : {};
          };
        });
        var GJ = A((Tut, $J) => {
          "use strict";
          c();
          var _g = gE().WriteError, QRe = Q8(), XRe = bg().getCallback, ZRe = bg().getOptions;
          function vg(t) {
            this.db = t, this.batch = t.db.batch(), this.ops = [], this.length = 0;
          }
          vg.prototype.put = function(t, e, r) {
            try {
              this.batch.put(t, e, r);
            } catch (n) {
              throw new _g(n);
            }
            return this.ops.push({ ...r, type: "put", key: t, value: e }), this.length++, this;
          };
          vg.prototype.del = function(t, e) {
            try {
              this.batch.del(t, e);
            } catch (r) {
              throw new _g(r);
            }
            return this.ops.push({ ...e, type: "del", key: t }), this.length++, this;
          };
          vg.prototype.clear = function() {
            try {
              this.batch.clear();
            } catch (t) {
              throw new _g(t);
            }
            return this.ops = [], this.length = 0, this;
          };
          vg.prototype.write = function(t, e) {
            let r = this.db, n = this.ops;
            e = XRe(t, e), e = QRe.fromCallback(e), t = ZRe(t);
            try {
              this.batch.write(t, function(i2) {
                if (i2)
                  return e(new _g(i2));
                r.emit("batch", n), e();
              });
            } catch (i2) {
              throw new _g(i2);
            }
            return e.promise;
          };
          $J.exports = vg;
        });
        var YJ = A((Iut, jJ) => {
          "use strict";
          c();
          var WJ = X8();
          jJ.exports = function(t, ...e) {
            e.length === 0 ? WJ(t) : WJ(() => t(...e));
          };
        });
        var ZJ = A((Cut, XJ) => {
          "use strict";
          c();
          var wE = In().EventEmitter, JRe = fZ().inherits, eAe = VZ(), tAe = HJ(), rAe = GJ(), h1 = gE(), nAe = yI(), ad = Q8(), Sg = bg().getCallback, d1 = bg().getOptions, xg = YJ(), EE = h1.WriteError, QJ = h1.ReadError, iAe = h1.NotFoundError, oAe = h1.OpenError, sAe = h1.InitializationError;
          function Yt(t, e, r) {
            if (!(this instanceof Yt))
              return new Yt(t, e, r);
            let n;
            if (wE.call(this), this.setMaxListeners(1 / 0), typeof e == "function" && (r = e, e = {}), e = e || {}, !t || typeof t != "object") {
              if (n = new sAe("First argument must be an abstract-leveldown compliant store"), typeof r == "function")
                return xg(r, n);
              throw n;
            }
            if (typeof t.status != "string")
              throw new Error(".status required, old abstract-leveldown");
            this.options = d1(e), this._db = t, this.db = null, this.open(r || ((i2) => {
              i2 && this.emit("error", i2);
            })), this.supports = nAe(this.db.supports, { status: true, deferredOpen: true, openCallback: true, promises: true, streams: true });
            for (let i2 of Object.keys(this.supports.additionalMethods))
              this[i2] == null && (this[i2] = function(...o) {
                return this.db[i2](...o);
              });
          }
          Yt.prototype.emit = wE.prototype.emit;
          Yt.prototype.once = wE.prototype.once;
          JRe(Yt, wE);
          Object.defineProperty(Yt.prototype, "status", { enumerable: true, get() {
            return this.db.status;
          } });
          Yt.prototype.isOperational = function() {
            return this.db.status === "open" || this.db.status === "opening";
          };
          Yt.prototype.open = function(t, e) {
            return typeof t == "function" && (e = t, t = null), e = ad.fromCallback(e), t || (t = this.options), this.db && this.isOpen() ? (xg(e, null, this), e.promise) : this.db && this._isOpening() ? (this.once("open", () => {
              e(null, this);
            }), e.promise) : (this.db = new eAe(this._db), this.emit("opening"), this.db.open(t, (r) => {
              if (r)
                return e(new oAe(r));
              this.db = this._db, e(null, this), this.emit("open"), this.emit("ready");
            }), e.promise);
          };
          Yt.prototype.close = function(t) {
            return t = ad.fromCallback(t), this.isOpen() ? (this.db.close((e, ...r) => {
              this.emit("closed"), t(e, ...r);
            }), this.emit("closing")) : this.isClosed() ? xg(t) : this.db.status === "closing" ? this.once("closed", t) : this._isOpening() && this.once("open", () => {
              this.close(t);
            }), t.promise;
          };
          Yt.prototype.isOpen = function() {
            return this.db.status === "open";
          };
          Yt.prototype._isOpening = function() {
            return this.db.status === "opening";
          };
          Yt.prototype.isClosed = function() {
            return /^clos|new/.test(this.db.status);
          };
          Yt.prototype.get = function(t, e, r) {
            return r = Sg(e, r), r = ad.fromCallback(r), Rg(this, r) || (e = d1(e), this.db.get(t, e, function(n, i2) {
              if (n)
                return /notfound/i.test(n) || n.notFound ? n = new iAe("Key not found in database [" + t + "]", n) : n = new QJ(n), r(n);
              r(null, i2);
            })), r.promise;
          };
          Yt.prototype.getMany = function(t, e, r) {
            return this.db.getMany(t, e, r);
          };
          Yt.prototype.put = function(t, e, r, n) {
            return n = Sg(r, n), n = ad.fromCallback(n), Rg(this, n) || (r = d1(r), this.db.put(t, e, r, (i2) => {
              if (i2)
                return n(new EE(i2));
              this.emit("put", t, e), n();
            })), n.promise;
          };
          Yt.prototype.del = function(t, e, r) {
            return r = Sg(e, r), r = ad.fromCallback(r), Rg(this, r) || (e = d1(e), this.db.del(t, e, (n) => {
              if (n)
                return r(new EE(n));
              this.emit("del", t), r();
            })), r.promise;
          };
          Yt.prototype.batch = function(t, e, r) {
            return arguments.length ? (typeof t == "function" ? r = t : r = Sg(e, r), r = ad.fromCallback(r), Rg(this, r) || (e = d1(e), this.db.batch(t, e, (n) => {
              if (n)
                return r(new EE(n));
              this.emit("batch", t), r();
            })), r.promise) : new rAe(this);
          };
          Yt.prototype.iterator = function(t) {
            return this.db.iterator(t);
          };
          Yt.prototype.clear = function(t, e) {
            return e = Sg(t, e), t = d1(t), e = ad.fromCallback(e), Rg(this, e) || this.db.clear(t, (r) => {
              if (r)
                return e(new EE(r));
              this.emit("clear", t), e();
            }), e.promise;
          };
          Yt.prototype.readStream = Yt.prototype.createReadStream = function(t) {
            return t = Object.assign({ keys: true, values: true }, t), typeof t.limit != "number" && (t.limit = -1), new tAe(this.db.iterator(t), t);
          };
          Yt.prototype.keyStream = Yt.prototype.createKeyStream = function(t) {
            return this.createReadStream(Object.assign({}, t, { keys: true, values: false }));
          };
          Yt.prototype.valueStream = Yt.prototype.createValueStream = function(t) {
            return this.createReadStream(Object.assign({}, t, { keys: false, values: true }));
          };
          Yt.prototype.toString = function() {
            return "LevelUP";
          };
          Yt.prototype.type = "levelup";
          Yt.prototype._nextTick = xg;
          function Rg(t, e) {
            return t.isOperational() ? false : (xg(e, new QJ("Database is not open")), true);
          }
          Yt.errors = h1;
          XJ.exports = Yt;
        });
        var JJ = A((tu) => {
          "use strict";
          c();
          var { Buffer: eC } = _i();
          tu.utf8 = tu["utf-8"] = { encode: function(t) {
            return tC(t) ? t : String(t);
          }, decode: bE, buffer: false, type: "utf8" };
          tu.json = { encode: JSON.stringify, decode: JSON.parse, buffer: false, type: "json" };
          tu.binary = { encode: function(t) {
            return tC(t) ? t : eC.from(t);
          }, decode: bE, buffer: true, type: "binary" };
          tu.none = { encode: bE, decode: bE, buffer: false, type: "id" };
          tu.id = tu.none;
          var aAe = ["hex", "ascii", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le"];
          for (let t of aAe)
            tu[t] = { encode: function(e) {
              return tC(e) ? e : eC.from(e, t);
            }, decode: function(e) {
              return e.toString(t);
            }, buffer: true, type: t };
          function bE(t) {
            return t;
          }
          function tC(t) {
            return t == null || eC.isBuffer(t);
          }
        });
        var tee = A((Dut, eee) => {
          "use strict";
          c();
          var rC = JJ(), cAe = /* @__PURE__ */ new Set(["lt", "gt", "lte", "gte"]);
          eee.exports = Pi;
          function Pi(t) {
            if (!(this instanceof Pi))
              return new Pi(t);
            this.opts = t || {}, this.encodings = rC;
          }
          Pi.prototype._encoding = function(t) {
            return typeof t == "string" && (t = rC[t]), t || (t = rC.id), t;
          };
          Pi.prototype._keyEncoding = function(t, e) {
            return this._encoding(e && e.keyEncoding || t && t.keyEncoding || this.opts.keyEncoding);
          };
          Pi.prototype._valueEncoding = function(t, e) {
            return this._encoding(e && (e.valueEncoding || e.encoding) || t && (t.valueEncoding || t.encoding) || this.opts.valueEncoding || this.opts.encoding);
          };
          Pi.prototype.encodeKey = function(t, e, r) {
            return this._keyEncoding(e, r).encode(t);
          };
          Pi.prototype.encodeValue = function(t, e, r) {
            return this._valueEncoding(e, r).encode(t);
          };
          Pi.prototype.decodeKey = function(t, e) {
            return this._keyEncoding(e).decode(t);
          };
          Pi.prototype.decodeValue = function(t, e) {
            return this._valueEncoding(e).decode(t);
          };
          Pi.prototype.encodeBatch = function(t, e) {
            return t.map((r) => {
              let n = { type: r.type, key: this.encodeKey(r.key, e, r) };
              return this.keyAsBuffer(e, r) && (n.keyEncoding = "binary"), r.prefix && (n.prefix = r.prefix), "value" in r && (n.value = this.encodeValue(r.value, e, r), this.valueAsBuffer(e, r) && (n.valueEncoding = "binary")), n;
            });
          };
          Pi.prototype.encodeLtgt = function(t) {
            let e = {};
            for (let r of Object.keys(t)) {
              if (r === "start" || r === "end")
                throw new Error('Legacy range options ("start" and "end") have been removed');
              e[r] = cAe.has(r) ? this.encodeKey(t[r], t) : t[r];
            }
            return e;
          };
          Pi.prototype.createStreamDecoder = function(t) {
            return t.keys && t.values ? (e, r) => ({ key: this.decodeKey(e, t), value: this.decodeValue(r, t) }) : t.keys ? (e) => this.decodeKey(e, t) : t.values ? (e, r) => this.decodeValue(r, t) : function() {
            };
          };
          Pi.prototype.keyAsBuffer = function(t) {
            return this._keyEncoding(t).buffer;
          };
          Pi.prototype.valueAsBuffer = function(t) {
            return this._valueEncoding(t).buffer;
          };
        });
        var see = A((kut, oee) => {
          "use strict";
          c();
          var ree = Zc().AbstractLevelDOWN, nee = Zc().AbstractChainedBatch, iee = Zc().AbstractIterator, nC = ni(), uAe = tee(), iC = gE().EncodingError, lAe = ["approximateSize", "compactRange"];
          oee.exports = ii;
          function ii(t, e) {
            if (!(this instanceof ii))
              return new ii(t, e);
            let r = t.supports || {}, n = r.additionalMethods || {};
            ree.call(this, r), this.supports.encodings = true, this.supports.additionalMethods = {}, lAe.forEach(function(i2) {
              let o = typeof t[i2] == "function";
              (n[i2] || o) && (this.supports.additionalMethods[i2] = true, this[i2] = function(s, a, u, l) {
                return s = this.codec.encodeKey(s, u), a = this.codec.encodeKey(a, u), this.db[i2](s, a, u, l);
              });
            }, this), e = e || {}, typeof e.keyEncoding > "u" && (e.keyEncoding = "utf8"), typeof e.valueEncoding > "u" && (e.valueEncoding = "utf8"), this.db = t, this.codec = new uAe(e);
          }
          nC(ii, ree);
          ii.prototype.type = "encoding-down";
          ii.prototype._serializeKey = ii.prototype._serializeValue = function(t) {
            return t;
          };
          ii.prototype._open = function(t, e) {
            this.db.open(t, e);
          };
          ii.prototype._close = function(t) {
            this.db.close(t);
          };
          ii.prototype._put = function(t, e, r, n) {
            t = this.codec.encodeKey(t, r), e = this.codec.encodeValue(e, r), this.db.put(t, e, r, n);
          };
          ii.prototype._get = function(t, e, r) {
            t = this.codec.encodeKey(t, e), e.asBuffer = this.codec.valueAsBuffer(e), this.db.get(t, e, (n, i2) => {
              if (n)
                return r(n);
              try {
                i2 = this.codec.decodeValue(i2, e);
              } catch (o) {
                return r(new iC(o));
              }
              r(null, i2);
            });
          };
          ii.prototype._getMany = function(t, e, r) {
            t = t.map((n) => this.codec.encodeKey(n, e)), e.asBuffer = this.codec.valueAsBuffer(e), this.db.getMany(t, e, (n, i2) => {
              if (n)
                return r(n);
              let o = new Array(i2.length);
              for (let s = 0; s < i2.length; s++) {
                if (i2[s] === void 0) {
                  o[s] = void 0;
                  continue;
                }
                try {
                  o[s] = this.codec.decodeValue(i2[s], e);
                } catch (a) {
                  return r(new iC(a));
                }
              }
              r(null, o);
            });
          };
          ii.prototype._del = function(t, e, r) {
            t = this.codec.encodeKey(t, e), this.db.del(t, e, r);
          };
          ii.prototype._chainedBatch = function() {
            return new p1(this);
          };
          ii.prototype._batch = function(t, e, r) {
            t = this.codec.encodeBatch(t, e), this.db.batch(t, e, r);
          };
          ii.prototype._iterator = function(t) {
            return t.keyAsBuffer = this.codec.keyAsBuffer(t), t.valueAsBuffer = this.codec.valueAsBuffer(t), new Ag(this, t);
          };
          ii.prototype._clear = function(t, e) {
            t = this.codec.encodeLtgt(t), this.db.clear(t, e);
          };
          function Ag(t, e) {
            iee.call(this, t), this.codec = t.codec, this.keys = e.keys, this.values = e.values, this.opts = this.codec.encodeLtgt(e), this.it = t.db.iterator(this.opts);
          }
          nC(Ag, iee);
          Ag.prototype._next = function(t) {
            this.it.next((e, r, n) => {
              if (e)
                return t(e);
              try {
                this.keys && typeof r < "u" ? r = this.codec.decodeKey(r, this.opts) : r = void 0, this.values && typeof n < "u" ? n = this.codec.decodeValue(n, this.opts) : n = void 0;
              } catch (i2) {
                return t(new iC(i2));
              }
              t(null, r, n);
            });
          };
          Ag.prototype._seek = function(t) {
            t = this.codec.encodeKey(t, this.opts), this.it.seek(t);
          };
          Ag.prototype._end = function(t) {
            this.it.end(t);
          };
          function p1(t, e) {
            nee.call(this, t), this.codec = t.codec, this.batch = t.db.batch();
          }
          nC(p1, nee);
          p1.prototype._put = function(t, e, r) {
            t = this.codec.encodeKey(t, r), e = this.codec.encodeValue(e, r), this.batch.put(t, e);
          };
          p1.prototype._del = function(t, e) {
            t = this.codec.encodeKey(t, e), this.batch.del(t);
          };
          p1.prototype._clear = function() {
            this.batch.clear();
          };
          p1.prototype._write = function(t, e) {
            this.batch.write(t, e);
          };
        });
        var uee = A((Nut, cee) => {
          "use strict";
          c();
          var aee = ZJ(), fAe = see();
          function hAe(t) {
            function e(n, i2, o) {
              return typeof n == "function" ? o = n : typeof i2 == "function" && (o = i2), r(i2) || (i2 = r(n) ? n : {}), aee(fAe(t(n, i2), i2), i2, o);
            }
            function r(n) {
              return typeof n == "object" && n !== null;
            }
            for (let n of ["destroy", "repair"])
              typeof t[n] == "function" && (e[n] = function(...i2) {
                t[n](...i2);
              });
            return e.errors = aee.errors, e;
          }
          cee.exports = hAe;
        });
        var fee = A((Out, lee) => {
          c();
          lee.exports = pAe;
          var dAe = X8();
          function pAe(t, e, r) {
            if (typeof e != "number")
              throw new Error("second argument must be a Number");
            let n, i2, o, s, a, u = true, l;
            Array.isArray(t) ? (n = [], o = i2 = t.length) : (s = Object.keys(t), n = {}, o = i2 = s.length);
            function f(p) {
              function d() {
                r && r(p, n), r = null;
              }
              u ? dAe(d) : d();
            }
            function h(p, d, m) {
              if (n[p] = m, d && (a = true), --o === 0 || d)
                f(d);
              else if (!a && l < i2) {
                let y;
                s ? (y = s[l], l += 1, t[y](function(g, E) {
                  h(y, g, E);
                })) : (y = l, l += 1, t[y](function(g, E) {
                  h(y, g, E);
                }));
              }
            }
            l = e, o ? s ? s.some(function(p, d) {
              return t[p](function(m, y) {
                h(p, m, y);
              }), d === e - 1;
            }) : t.some(function(p, d) {
              return p(function(m, y) {
                h(d, m, y);
              }), d === e - 1;
            }) : f(null), u = false;
          }
        });
        var dee = A((un) => {
          c();
          un.compare = function(t, e) {
            if (Buffer.isBuffer(t)) {
              for (var r = Math.min(t.length, e.length), n = 0; n < r; n++) {
                var i2 = t[n] - e[n];
                if (i2)
                  return i2;
              }
              return t.length - e.length;
            }
            return t < e ? -1 : t > e ? 1 : 0;
          };
          function hee(t) {
            return t !== void 0 && t !== "";
          }
          function m1(t, e) {
            return Object.hasOwnProperty.call(t, e);
          }
          function Wa(t, e) {
            return Object.hasOwnProperty.call(t, e) && e;
          }
          var mAe = un.lowerBoundKey = function(t) {
            return Wa(t, "gt") || Wa(t, "gte") || Wa(t, "min") || (t.reverse ? Wa(t, "end") : Wa(t, "start")) || void 0;
          }, oC = un.lowerBound = function(t, e) {
            var r = mAe(t);
            return r ? t[r] : e;
          }, sC = un.lowerBoundInclusive = function(t) {
            return !m1(t, "gt");
          }, aC = un.upperBoundInclusive = function(t) {
            return !m1(t, "lt");
          }, yAe = un.lowerBoundExclusive = function(t) {
            return !sC(t);
          }, gAe = un.upperBoundExclusive = function(t) {
            return !aC(t);
          }, wAe = un.upperBoundKey = function(t) {
            return Wa(t, "lt") || Wa(t, "lte") || Wa(t, "max") || (t.reverse ? Wa(t, "start") : Wa(t, "end")) || void 0;
          }, cC = un.upperBound = function(t, e) {
            var r = wAe(t);
            return r ? t[r] : e;
          };
          un.start = function(t, e) {
            return t.reverse ? cC(t, e) : oC(t, e);
          };
          un.end = function(t, e) {
            return t.reverse ? oC(t, e) : cC(t, e);
          };
          un.startInclusive = function(t) {
            return t.reverse ? aC(t) : sC(t);
          };
          un.endInclusive = function(t) {
            return t.reverse ? sC(t) : aC(t);
          };
          function EAe(t) {
            return t;
          }
          un.toLtgt = function(t, e, r, n, i2) {
            e = e || {}, r = r || EAe;
            var o = arguments.length > 3, s = un.lowerBoundKey(t), a = un.upperBoundKey(t);
            return s ? s === "gt" ? e.gt = r(t.gt, false) : e.gte = r(t[s], false) : o && (e.gte = r(n, false)), a ? a === "lt" ? e.lt = r(t.lt, true) : e.lte = r(t[a], true) : o && (e.lte = r(i2, true)), t.reverse != null && (e.reverse = !!t.reverse), m1(e, "max") && delete e.max, m1(e, "min") && delete e.min, m1(e, "start") && delete e.start, m1(e, "end") && delete e.end, e;
          };
          un.contains = function(t, e, r) {
            r = r || un.compare;
            var n = oC(t);
            if (hee(n)) {
              var i2 = r(e, n);
              if (i2 < 0 || i2 === 0 && yAe(t))
                return false;
            }
            var o = cC(t);
            if (hee(o)) {
              var i2 = r(e, o);
              if (i2 > 0 || i2 === 0 && gAe(t))
                return false;
            }
            return true;
          };
          un.filter = function(t, e) {
            return function(r) {
              return un.contains(t, r, e);
            };
          };
        });
        var uC = A((But, pee) => {
          "use strict";
          c();
          var _E = dee(), Yl = Symbol("none");
          pee.exports = function(e) {
            let r = _E.lowerBound(e, Yl), n = _E.upperBound(e, Yl), i2 = _E.lowerBoundExclusive(e, Yl), o = _E.upperBoundExclusive(e, Yl);
            return r !== Yl && n !== Yl ? IDBKeyRange.bound(r, n, i2, o) : r !== Yl ? IDBKeyRange.lowerBound(r, i2) : n !== Yl ? IDBKeyRange.upperBound(n, o) : null;
          };
        });
        var lC = A((Mut, yee) => {
          "use strict";
          c();
          var vE = _i().Buffer, bAe = function() {
            if (globalThis.TextDecoder) {
              let t = new TextDecoder("utf-8");
              return t.decode.bind(t);
            } else
              return function(e) {
                return mee(e).toString();
              };
          }(), _Ae = function() {
            if (globalThis.TextDecoder) {
              let t = new TextDecoder("utf-8");
              return t.decode.bind(t);
            } else
              return function(e) {
                return vE.from(e).toString();
              };
          }();
          function mee(t) {
            let e = vE.from(t.buffer);
            return t.byteLength === t.buffer.byteLength ? e : e.slice(t.byteOffset, t.byteOffset + t.byteLength);
          }
          yee.exports = function(t, e) {
            return t instanceof Uint8Array ? e ? mee(t) : bAe(t) : t instanceof ArrayBuffer ? e ? vE.from(t) : _Ae(t) : e ? vE.from(String(t)) : String(t);
          };
        });
        var bee = A((Uut, Eee) => {
          "use strict";
          c();
          var vAe = ni(), gee = Zc().AbstractIterator, SAe = uC(), wee = lC(), xAe = function() {
          };
          Eee.exports = Zs;
          function Zs(t, e, r) {
            if (gee.call(this, t), this._limit = r.limit, this._count = 0, this._callback = null, this._cache = [], this._completed = false, this._aborted = false, this._error = null, this._transaction = null, this._keys = r.keys, this._values = r.values, this._keyAsBuffer = r.keyAsBuffer, this._valueAsBuffer = r.valueAsBuffer, this._limit === 0) {
              this._completed = true;
              return;
            }
            let n;
            try {
              n = SAe(r);
            } catch {
              this._completed = true;
              return;
            }
            this.createIterator(e, n, r.reverse);
          }
          vAe(Zs, gee);
          Zs.prototype.createIterator = function(t, e, r) {
            let n = this.db.db.transaction([t], "readonly"), o = n.objectStore(t).openCursor(e, r ? "prev" : "next");
            o.onsuccess = (s) => {
              let a = s.target.result;
              a && this.onItem(a);
            }, this._transaction = n, n.onabort = () => {
              this.onAbort(this._transaction.error || new Error("aborted by user"));
            }, n.oncomplete = () => {
              this.onComplete();
            };
          };
          Zs.prototype.onItem = function(t) {
            this._cache.push(t.key, t.value), (this._limit <= 0 || ++this._count < this._limit) && t.continue(), this.maybeNext();
          };
          Zs.prototype.onAbort = function(t) {
            this._aborted = true, this._error = t, this.maybeNext();
          };
          Zs.prototype.onComplete = function() {
            this._completed = true, this.maybeNext();
          };
          Zs.prototype.maybeNext = function() {
            this._callback && (this._next(this._callback), this._callback = null);
          };
          Zs.prototype._next = function(t) {
            if (this._aborted) {
              let e = this._error;
              this._error = null, this._nextTick(t, e);
            } else if (this._cache.length > 0) {
              let e = this._cache.shift(), r = this._cache.shift();
              this._keys && e !== void 0 ? e = this._deserializeKey(e, this._keyAsBuffer) : e = void 0, this._values && r !== void 0 ? r = this._deserializeValue(r, this._valueAsBuffer) : r = void 0, this._nextTick(t, null, e, r);
            } else
              this._completed ? this._nextTick(t) : this._callback = t;
          };
          Zs.prototype._deserializeKey = wee;
          Zs.prototype._deserializeValue = wee;
          Zs.prototype._end = function(t) {
            if (this._aborted || this._completed)
              return this._nextTick(t, this._error);
            this.onItem = xAe, this.onAbort = t, this.onComplete = t;
          };
        });
        var See = A((Fut, vee) => {
          "use strict";
          c();
          var _ee = _i().Buffer, RAe = function() {
            if (globalThis.TextEncoder) {
              let t = new TextEncoder("utf-8");
              return t.encode.bind(t);
            } else
              return _ee.from;
          }();
          vee.exports = function(t, e) {
            return e ? _ee.isBuffer(t) ? t : RAe(String(t)) : String(t);
          };
        });
        var xee = A((SE) => {
          "use strict";
          c();
          var AAe = _i().Buffer;
          SE.test = function(t) {
            return function(r) {
              try {
                return r.cmp(t, 0), true;
              } catch {
                return false;
              }
            };
          };
          SE.bufferKeys = SE.test(AAe.alloc(0));
        });
        var Aee = A((Vut, Ree) => {
          "use strict";
          c();
          Ree.exports = function(e, r, n, i2, o) {
            if (i2.limit === 0)
              return e._nextTick(o);
            let s = e.db.transaction([r], "readwrite"), a = s.objectStore(r), u = 0;
            s.oncomplete = function() {
              o();
            }, s.onabort = function() {
              o(s.error || new Error("aborted by user"));
            };
            let l = a.openKeyCursor ? "openKeyCursor" : "openCursor", f = i2.reverse ? "prev" : "next";
            a[l](n, f).onsuccess = function(h) {
              let p = h.target.result;
              p && (a.delete(p.key).onsuccess = function() {
                (i2.limit <= 0 || ++u < i2.limit) && p.continue();
              });
            };
          };
        });
        var Dee = A((qut, Pee) => {
          "use strict";
          c();
          Pee.exports = gn;
          var Tee = Zc().AbstractLevelDOWN, TAe = ni(), IAe = fee(), CAe = bee(), Iee = See(), xE = lC(), PAe = xee(), DAe = Aee(), kAe = uC(), Cee = "level-js-";
          function gn(t, e) {
            if (!(this instanceof gn))
              return new gn(t, e);
            if (Tee.call(this, { bufferKeys: PAe.bufferKeys(indexedDB), snapshots: true, permanence: true, clear: true, getMany: true }), e = e || {}, typeof t != "string")
              throw new Error("constructor requires a location string argument");
            this.location = t, this.prefix = e.prefix == null ? Cee : e.prefix, this.version = parseInt(e.version || 1, 10);
          }
          TAe(gn, Tee);
          gn.prototype.type = "level-js";
          gn.prototype._open = function(t, e) {
            let r = indexedDB.open(this.prefix + this.location, this.version);
            r.onerror = function() {
              e(r.error || new Error("unknown error"));
            }, r.onsuccess = () => {
              this.db = r.result, e();
            }, r.onupgradeneeded = (n) => {
              let i2 = n.target.result;
              i2.objectStoreNames.contains(this.location) || i2.createObjectStore(this.location);
            };
          };
          gn.prototype.store = function(t) {
            return this.db.transaction([this.location], t).objectStore(this.location);
          };
          gn.prototype.await = function(t, e) {
            let r = t.transaction;
            r.onabort = function() {
              e(r.error || new Error("aborted by user"));
            }, r.oncomplete = function() {
              e(null, t.result);
            };
          };
          gn.prototype._get = function(t, e, r) {
            let n = this.store("readonly"), i2;
            try {
              i2 = n.get(t);
            } catch (o) {
              return this._nextTick(r, o);
            }
            this.await(i2, function(o, s) {
              if (o)
                return r(o);
              if (s === void 0)
                return r(new Error("NotFound"));
              r(null, xE(s, e.asBuffer));
            });
          };
          gn.prototype._getMany = function(t, e, r) {
            let n = e.asBuffer, i2 = this.store("readonly"), o = t.map((s) => (a) => {
              let u;
              try {
                u = i2.get(s);
              } catch (l) {
                return a(l);
              }
              u.onsuccess = () => {
                let l = u.result;
                a(null, l === void 0 ? l : xE(l, n));
              }, u.onerror = (l) => {
                l.stopPropagation(), a(u.error);
              };
            });
            IAe(o, 16, r);
          };
          gn.prototype._del = function(t, e, r) {
            let n = this.store("readwrite"), i2;
            try {
              i2 = n.delete(t);
            } catch (o) {
              return this._nextTick(r, o);
            }
            this.await(i2, r);
          };
          gn.prototype._put = function(t, e, r, n) {
            let i2 = this.store("readwrite"), o;
            try {
              o = i2.put(e, t);
            } catch (s) {
              return this._nextTick(n, s);
            }
            this.await(o, n);
          };
          gn.prototype._serializeKey = function(t) {
            return Iee(t, this.supports.bufferKeys);
          };
          gn.prototype._serializeValue = function(t) {
            return Iee(t, true);
          };
          gn.prototype._iterator = function(t) {
            return new CAe(this, this.location, t);
          };
          gn.prototype._batch = function(t, e, r) {
            if (t.length === 0)
              return this._nextTick(r);
            let n = this.store("readwrite"), i2 = n.transaction, o = 0, s;
            i2.onabort = function() {
              r(s || i2.error || new Error("aborted by user"));
            }, i2.oncomplete = function() {
              r();
            };
            function a() {
              let u = t[o++], l = u.key, f;
              try {
                f = u.type === "del" ? n.delete(l) : n.put(u.value, l);
              } catch (h) {
                s = h, i2.abort();
                return;
              }
              o < t.length && (f.onsuccess = a);
            }
            a();
          };
          gn.prototype._clear = function(t, e) {
            let r, n;
            try {
              r = kAe(t);
            } catch {
              return this._nextTick(e);
            }
            if (t.limit >= 0)
              return DAe(this, this.location, r, t, e);
            try {
              let i2 = this.store("readwrite");
              n = r ? i2.delete(r) : i2.clear();
            } catch (i2) {
              return this._nextTick(e, i2);
            }
            this.await(n, e);
          };
          gn.prototype._close = function(t) {
            this.db.close(), this._nextTick(t);
          };
          gn.prototype.upgrade = function(t) {
            if (this.status !== "open")
              return this._nextTick(t, new Error("cannot upgrade() before open()"));
            let e = this.iterator(), r = {}, n = this;
            e._deserializeKey = e._deserializeValue = a, i2();
            function i2(u) {
              if (u)
                return s(u);
              e.next(o);
            }
            function o(u, l, f) {
              if (u || l === void 0)
                return s(u);
              let h = n._serializeKey(xE(l, true)), p = n._serializeValue(xE(f, true));
              n._batch([{ type: "del", key: l }, { type: "put", key: h, value: p }], r, i2);
            }
            function s(u) {
              e.end(function(l) {
                t(u || l);
              });
            }
            function a(u) {
              return u;
            }
          };
          gn.destroy = function(t, e, r) {
            typeof e == "function" && (r = e, e = Cee);
            let n = indexedDB.deleteDatabase(e + t);
            n.onsuccess = function() {
              r();
            }, n.onerror = function(i2) {
              r(i2);
            };
          };
        });
        var Nee = A((zut, kee) => {
          c();
          kee.exports = uee()(Dee());
        });
        var Mee = A((Wut, Bee) => {
          c();
          var dC = d0();
          Bee.exports = (t) => {
            t = t || {};
            let e;
            typeof t == "function" ? (e = t, t = {}) : e = t.onEnd;
            let r = new dC(), n, i2, o, s = () => {
              if (!r.isEmpty()) {
                if (t.writev) {
                  let y, g = [];
                  for (; !r.isEmpty(); ) {
                    if (y = r.shift(), y.error)
                      throw y.error;
                    g.push(y.value);
                  }
                  return { done: y.done, value: g };
                }
                let m = r.shift();
                if (m.error)
                  throw m.error;
                return m;
              }
              return o ? { done: true } : new Promise((m, y) => {
                i2 = (g) => (i2 = null, g.error ? y(g.error) : t.writev && !g.done ? m({ done: g.done, value: [g.value] }) : m(g), n);
              });
            }, a = (m) => i2 ? i2(m) : (r.push(m), n), u = (m) => (r = new dC(), i2 ? i2({ error: m }) : (r.push({ error: m }), n)), l = (m) => o ? n : a({ done: false, value: m }), f = (m) => o ? n : (o = true, m ? u(m) : a({ done: true })), h = () => (r = new dC(), f(), { done: true }), p = (m) => (f(m), { done: true });
            if (n = { [Symbol.asyncIterator]() {
              return this;
            }, next: s, return: h, throw: p, push: l, end: f }, !e)
              return n;
            let d = n;
            return n = { [Symbol.asyncIterator]() {
              return this;
            }, next() {
              return d.next();
            }, throw(m) {
              return d.throw(m), e && (e(m), e = null), { done: true };
            }, return() {
              return d.return(), e && (e(), e = null), { done: true };
            }, push: l, end(m) {
              return d.end(m), e && (e(m), e = null), n;
            } }, n;
          };
        });
        var lte = A((Uft, ute) => {
          "use strict";
          c();
          function Qr(t, r) {
            var r = r || {};
            this._head = 0, this._tail = 0, this._capacity = r.capacity, this._capacityMask = 3, this._list = new Array(4), Array.isArray(t) && this._fromArray(t);
          }
          Qr.prototype.peekAt = function(e) {
            var r = e;
            if (r === (r | 0)) {
              var n = this.size();
              if (!(r >= n || r < -n))
                return r < 0 && (r += n), r = this._head + r & this._capacityMask, this._list[r];
            }
          };
          Qr.prototype.get = function(e) {
            return this.peekAt(e);
          };
          Qr.prototype.peek = function() {
            if (this._head !== this._tail)
              return this._list[this._head];
          };
          Qr.prototype.peekFront = function() {
            return this.peek();
          };
          Qr.prototype.peekBack = function() {
            return this.peekAt(-1);
          };
          Object.defineProperty(Qr.prototype, "length", { get: function() {
            return this.size();
          } });
          Qr.prototype.size = function() {
            return this._head === this._tail ? 0 : this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
          };
          Qr.prototype.unshift = function(e) {
            if (e === void 0)
              return this.size();
            var r = this._list.length;
            return this._head = this._head - 1 + r & this._capacityMask, this._list[this._head] = e, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.pop(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
          };
          Qr.prototype.shift = function() {
            var e = this._head;
            if (e !== this._tail) {
              var r = this._list[e];
              return this._list[e] = void 0, this._head = e + 1 & this._capacityMask, e < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2 && this._shrinkArray(), r;
            }
          };
          Qr.prototype.push = function(e) {
            if (e === void 0)
              return this.size();
            var r = this._tail;
            return this._list[r] = e, this._tail = r + 1 & this._capacityMask, this._tail === this._head && this._growArray(), this._capacity && this.size() > this._capacity && this.shift(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail);
          };
          Qr.prototype.pop = function() {
            var e = this._tail;
            if (e !== this._head) {
              var r = this._list.length;
              this._tail = e - 1 + r & this._capacityMask;
              var n = this._list[this._tail];
              return this._list[this._tail] = void 0, this._head < 2 && e > 1e4 && e <= r >>> 2 && this._shrinkArray(), n;
            }
          };
          Qr.prototype.removeOne = function(e) {
            var r = e;
            if (r === (r | 0) && this._head !== this._tail) {
              var n = this.size(), i2 = this._list.length;
              if (!(r >= n || r < -n)) {
                r < 0 && (r += n), r = this._head + r & this._capacityMask;
                var o = this._list[r], s;
                if (e < n / 2) {
                  for (s = e; s > 0; s--)
                    this._list[r] = this._list[r = r - 1 + i2 & this._capacityMask];
                  this._list[r] = void 0, this._head = this._head + 1 + i2 & this._capacityMask;
                } else {
                  for (s = n - 1 - e; s > 0; s--)
                    this._list[r] = this._list[r = r + 1 + i2 & this._capacityMask];
                  this._list[r] = void 0, this._tail = this._tail - 1 + i2 & this._capacityMask;
                }
                return o;
              }
            }
          };
          Qr.prototype.remove = function(e, r) {
            var n = e, i2, o = r;
            if (n === (n | 0) && this._head !== this._tail) {
              var s = this.size(), a = this._list.length;
              if (!(n >= s || n < -s || r < 1)) {
                if (n < 0 && (n += s), r === 1 || !r)
                  return i2 = new Array(1), i2[0] = this.removeOne(n), i2;
                if (n === 0 && n + r >= s)
                  return i2 = this.toArray(), this.clear(), i2;
                n + r > s && (r = s - n);
                var u;
                for (i2 = new Array(r), u = 0; u < r; u++)
                  i2[u] = this._list[this._head + n + u & this._capacityMask];
                if (n = this._head + n & this._capacityMask, e + r === s) {
                  for (this._tail = this._tail - r + a & this._capacityMask, u = r; u > 0; u--)
                    this._list[n = n + 1 + a & this._capacityMask] = void 0;
                  return i2;
                }
                if (e === 0) {
                  for (this._head = this._head + r + a & this._capacityMask, u = r - 1; u > 0; u--)
                    this._list[n = n + 1 + a & this._capacityMask] = void 0;
                  return i2;
                }
                if (n < s / 2) {
                  for (this._head = this._head + e + r + a & this._capacityMask, u = e; u > 0; u--)
                    this.unshift(this._list[n = n - 1 + a & this._capacityMask]);
                  for (n = this._head - 1 + a & this._capacityMask; o > 0; )
                    this._list[n = n - 1 + a & this._capacityMask] = void 0, o--;
                  e < 0 && (this._tail = n);
                } else {
                  for (this._tail = n, n = n + r + a & this._capacityMask, u = s - (r + e); u > 0; u--)
                    this.push(this._list[n++]);
                  for (n = this._tail; o > 0; )
                    this._list[n = n + 1 + a & this._capacityMask] = void 0, o--;
                }
                return this._head < 2 && this._tail > 1e4 && this._tail <= a >>> 2 && this._shrinkArray(), i2;
              }
            }
          };
          Qr.prototype.splice = function(e, r) {
            var n = e;
            if (n === (n | 0)) {
              var i2 = this.size();
              if (n < 0 && (n += i2), !(n > i2))
                if (arguments.length > 2) {
                  var o, s, a, u = arguments.length, l = this._list.length, f = 2;
                  if (!i2 || n < i2 / 2) {
                    for (s = new Array(n), o = 0; o < n; o++)
                      s[o] = this._list[this._head + o & this._capacityMask];
                    for (r === 0 ? (a = [], n > 0 && (this._head = this._head + n + l & this._capacityMask)) : (a = this.remove(n, r), this._head = this._head + n + l & this._capacityMask); u > f; )
                      this.unshift(arguments[--u]);
                    for (o = n; o > 0; o--)
                      this.unshift(s[o - 1]);
                  } else {
                    s = new Array(i2 - (n + r));
                    var h = s.length;
                    for (o = 0; o < h; o++)
                      s[o] = this._list[this._head + n + r + o & this._capacityMask];
                    for (r === 0 ? (a = [], n != i2 && (this._tail = this._head + n + l & this._capacityMask)) : (a = this.remove(n, r), this._tail = this._tail - h + l & this._capacityMask); f < u; )
                      this.push(arguments[f++]);
                    for (o = 0; o < h; o++)
                      this.push(s[o]);
                  }
                  return a;
                } else
                  return this.remove(n, r);
            }
          };
          Qr.prototype.clear = function() {
            this._head = 0, this._tail = 0;
          };
          Qr.prototype.isEmpty = function() {
            return this._head === this._tail;
          };
          Qr.prototype.toArray = function() {
            return this._copyArray(false);
          };
          Qr.prototype._fromArray = function(e) {
            for (var r = 0; r < e.length; r++)
              this.push(e[r]);
          };
          Qr.prototype._copyArray = function(e) {
            var r = [], n = this._list, i2 = n.length, o;
            if (e || this._head > this._tail) {
              for (o = this._head; o < i2; o++)
                r.push(n[o]);
              for (o = 0; o < this._tail; o++)
                r.push(n[o]);
            } else
              for (o = this._head; o < this._tail; o++)
                r.push(n[o]);
            return r;
          };
          Qr.prototype._growArray = function() {
            this._head && (this._list = this._copyArray(true), this._head = 0), this._tail = this._list.length, this._list.length <<= 1, this._capacityMask = this._capacityMask << 1 | 1;
          };
          Qr.prototype._shrinkArray = function() {
            this._list.length >>>= 1, this._capacityMask >>>= 1;
          };
          ute.exports = Qr;
        });
        var AC = A((aht, pte) => {
          c();
          pte.exports = In().EventEmitter;
        });
        var wte = A((cht, gte) => {
          "use strict";
          c();
          function mte(t, e) {
            var r = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(t);
              e && (n = n.filter(function(i2) {
                return Object.getOwnPropertyDescriptor(t, i2).enumerable;
              })), r.push.apply(r, n);
            }
            return r;
          }
          function ZAe(t) {
            for (var e = 1; e < arguments.length; e++) {
              var r = arguments[e] != null ? arguments[e] : {};
              e % 2 ? mte(Object(r), true).forEach(function(n) {
                JAe(t, n, r[n]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : mte(Object(r)).forEach(function(n) {
                Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
              });
            }
            return t;
          }
          function JAe(t, e, r) {
            return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
          }
          function eTe(t, e) {
            if (!(t instanceof e))
              throw new TypeError("Cannot call a class as a function");
          }
          function yte(t, e) {
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(t, n.key, n);
            }
          }
          function tTe(t, e, r) {
            return e && yte(t.prototype, e), r && yte(t, r), t;
          }
          var rTe = _i(), LE = rTe.Buffer, nTe = fg(), TC = nTe.inspect, iTe = TC && TC.custom || "inspect";
          function oTe(t, e, r) {
            LE.prototype.copy.call(t, e, r);
          }
          gte.exports = function() {
            function t() {
              eTe(this, t), this.head = null, this.tail = null, this.length = 0;
            }
            return tTe(t, [{ key: "push", value: function(r) {
              var n = { data: r, next: null };
              this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
            } }, { key: "unshift", value: function(r) {
              var n = { data: r, next: this.head };
              this.length === 0 && (this.tail = n), this.head = n, ++this.length;
            } }, { key: "shift", value: function() {
              if (this.length !== 0) {
                var r = this.head.data;
                return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
              }
            } }, { key: "clear", value: function() {
              this.head = this.tail = null, this.length = 0;
            } }, { key: "join", value: function(r) {
              if (this.length === 0)
                return "";
              for (var n = this.head, i2 = "" + n.data; n = n.next; )
                i2 += r + n.data;
              return i2;
            } }, { key: "concat", value: function(r) {
              if (this.length === 0)
                return LE.alloc(0);
              for (var n = LE.allocUnsafe(r >>> 0), i2 = this.head, o = 0; i2; )
                oTe(i2.data, n, o), o += i2.data.length, i2 = i2.next;
              return n;
            } }, { key: "consume", value: function(r, n) {
              var i2;
              return r < this.head.data.length ? (i2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i2 = this.shift() : i2 = n ? this._getString(r) : this._getBuffer(r), i2;
            } }, { key: "first", value: function() {
              return this.head.data;
            } }, { key: "_getString", value: function(r) {
              var n = this.head, i2 = 1, o = n.data;
              for (r -= o.length; n = n.next; ) {
                var s = n.data, a = r > s.length ? s.length : r;
                if (a === s.length ? o += s : o += s.slice(0, r), r -= a, r === 0) {
                  a === s.length ? (++i2, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = s.slice(a));
                  break;
                }
                ++i2;
              }
              return this.length -= i2, o;
            } }, { key: "_getBuffer", value: function(r) {
              var n = LE.allocUnsafe(r), i2 = this.head, o = 1;
              for (i2.data.copy(n), r -= i2.data.length; i2 = i2.next; ) {
                var s = i2.data, a = r > s.length ? s.length : r;
                if (s.copy(n, n.length - r, 0, a), r -= a, r === 0) {
                  a === s.length ? (++o, i2.next ? this.head = i2.next : this.head = this.tail = null) : (this.head = i2, i2.data = s.slice(a));
                  break;
                }
                ++o;
              }
              return this.length -= o, n;
            } }, { key: iTe, value: function(r, n) {
              return TC(this, ZAe({}, n, { depth: 0, customInspect: false }));
            } }]), t;
          }();
        });
        var CC = A((uht, bte) => {
          "use strict";
          c();
          function sTe(t, e) {
            var r = this, n = this._readableState && this._readableState.destroyed, i2 = this._writableState && this._writableState.destroyed;
            return n || i2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(IC, this, t)) : process.nextTick(IC, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(o) {
              !e && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(BE, r) : (r._writableState.errorEmitted = true, process.nextTick(Ete, r, o)) : process.nextTick(Ete, r, o) : e ? (process.nextTick(BE, r), e(o)) : process.nextTick(BE, r);
            }), this);
          }
          function Ete(t, e) {
            IC(t, e), BE(t);
          }
          function BE(t) {
            t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
          }
          function aTe() {
            this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
          }
          function IC(t, e) {
            t.emit("error", e);
          }
          function cTe(t, e) {
            var r = t._readableState, n = t._writableState;
            r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e);
          }
          bte.exports = { destroy: sTe, undestroy: aTe, errorOrDestroy: cTe };
        });
        var hd = A((lht, Ste) => {
          "use strict";
          c();
          function uTe(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
          }
          var vte = {};
          function cs(t, e, r) {
            r || (r = Error);
            function n(o, s, a) {
              return typeof e == "string" ? e : e(o, s, a);
            }
            var i2 = function(o) {
              uTe(s, o);
              function s(a, u, l) {
                return o.call(this, n(a, u, l)) || this;
              }
              return s;
            }(r);
            i2.prototype.name = r.name, i2.prototype.code = t, vte[t] = i2;
          }
          function _te(t, e) {
            if (Array.isArray(t)) {
              var r = t.length;
              return t = t.map(function(n) {
                return String(n);
              }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
            } else
              return "of ".concat(e, " ").concat(String(t));
          }
          function lTe(t, e, r) {
            return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
          }
          function fTe(t, e, r) {
            return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
          }
          function hTe(t, e, r) {
            return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
          }
          cs("ERR_INVALID_OPT_VALUE", function(t, e) {
            return 'The value "' + e + '" is invalid for option "' + t + '"';
          }, TypeError);
          cs("ERR_INVALID_ARG_TYPE", function(t, e, r) {
            var n;
            typeof e == "string" && lTe(e, "not ") ? (n = "must not be", e = e.replace(/^not /, "")) : n = "must be";
            var i2;
            if (fTe(t, " argument"))
              i2 = "The ".concat(t, " ").concat(n, " ").concat(_te(e, "type"));
            else {
              var o = hTe(t, ".") ? "property" : "argument";
              i2 = 'The "'.concat(t, '" ').concat(o, " ").concat(n, " ").concat(_te(e, "type"));
            }
            return i2 += ". Received type ".concat(typeof r), i2;
          }, TypeError);
          cs("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
          cs("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
            return "The " + t + " method is not implemented";
          });
          cs("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
          cs("ERR_STREAM_DESTROYED", function(t) {
            return "Cannot call " + t + " after a stream was destroyed";
          });
          cs("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
          cs("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
          cs("ERR_STREAM_WRITE_AFTER_END", "write after end");
          cs("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
          cs("ERR_UNKNOWN_ENCODING", function(t) {
            return "Unknown encoding: " + t;
          }, TypeError);
          cs("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
          Ste.exports.codes = vte;
        });
        var PC = A((fht, xte) => {
          "use strict";
          c();
          var dTe = hd().codes.ERR_INVALID_OPT_VALUE;
          function pTe(t, e, r) {
            return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
          }
          function mTe(t, e, r, n) {
            var i2 = pTe(e, n, r);
            if (i2 != null) {
              if (!(isFinite(i2) && Math.floor(i2) === i2) || i2 < 0) {
                var o = n ? r : "highWaterMark";
                throw new dTe(o, i2);
              }
              return Math.floor(i2);
            }
            return t.objectMode ? 16 : 16 * 1024;
          }
          xte.exports = { getHighWaterMark: mTe };
        });
        var NC = A((hht, Pte) => {
          "use strict";
          c();
          Pte.exports = Xr;
          function Ate(t) {
            var e = this;
            this.next = null, this.entry = null, this.finish = function() {
              qTe(e, t);
            };
          }
          var R1;
          Xr.WritableState = Og;
          var yTe = { deprecate: DI() }, Tte = AC(), UE = _i().Buffer, gTe = globalThis.Uint8Array || function() {
          };
          function wTe(t) {
            return UE.from(t);
          }
          function ETe(t) {
            return UE.isBuffer(t) || t instanceof gTe;
          }
          var kC = CC(), bTe = PC(), _Te = bTe.getHighWaterMark, tf = hd().codes, vTe = tf.ERR_INVALID_ARG_TYPE, STe = tf.ERR_METHOD_NOT_IMPLEMENTED, xTe = tf.ERR_MULTIPLE_CALLBACK, RTe = tf.ERR_STREAM_CANNOT_PIPE, ATe = tf.ERR_STREAM_DESTROYED, TTe = tf.ERR_STREAM_NULL_VALUES, ITe = tf.ERR_STREAM_WRITE_AFTER_END, CTe = tf.ERR_UNKNOWN_ENCODING, A1 = kC.errorOrDestroy;
          ni()(Xr, Tte);
          function PTe() {
          }
          function Og(t, e, r) {
            R1 = R1 || dd(), t = t || {}, typeof r != "boolean" && (r = e instanceof R1), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = _Te(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
            var n = t.decodeStrings === false;
            this.decodeStrings = !n, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i2) {
              MTe(e, i2);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new Ate(this);
          }
          Og.prototype.getBuffer = function() {
            for (var e = this.bufferedRequest, r = []; e; )
              r.push(e), e = e.next;
            return r;
          };
          (function() {
            try {
              Object.defineProperty(Og.prototype, "buffer", { get: yTe.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch {
            }
          })();
          var ME;
          typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ME = Function.prototype[Symbol.hasInstance], Object.defineProperty(Xr, Symbol.hasInstance, { value: function(e) {
            return ME.call(this, e) ? true : this !== Xr ? false : e && e._writableState instanceof Og;
          } })) : ME = function(e) {
            return e instanceof this;
          };
          function Xr(t) {
            R1 = R1 || dd();
            var e = this instanceof R1;
            if (!e && !ME.call(Xr, this))
              return new Xr(t);
            this._writableState = new Og(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Tte.call(this);
          }
          Xr.prototype.pipe = function() {
            A1(this, new RTe());
          };
          function DTe(t, e) {
            var r = new ITe();
            A1(t, r), process.nextTick(e, r);
          }
          function kTe(t, e, r, n) {
            var i2;
            return r === null ? i2 = new TTe() : typeof r != "string" && !e.objectMode && (i2 = new vTe("chunk", ["string", "Buffer"], r)), i2 ? (A1(t, i2), process.nextTick(n, i2), false) : true;
          }
          Xr.prototype.write = function(t, e, r) {
            var n = this._writableState, i2 = false, o = !n.objectMode && ETe(t);
            return o && !UE.isBuffer(t) && (t = wTe(t)), typeof e == "function" && (r = e, e = null), o ? e = "buffer" : e || (e = n.defaultEncoding), typeof r != "function" && (r = PTe), n.ending ? DTe(this, r) : (o || kTe(this, n, t, r)) && (n.pendingcb++, i2 = OTe(this, n, o, t, e, r)), i2;
          };
          Xr.prototype.cork = function() {
            this._writableState.corked++;
          };
          Xr.prototype.uncork = function() {
            var t = this._writableState;
            t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ite(this, t));
          };
          Xr.prototype.setDefaultEncoding = function(e) {
            if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
              throw new CTe(e);
            return this._writableState.defaultEncoding = e, this;
          };
          Object.defineProperty(Xr.prototype, "writableBuffer", { enumerable: false, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } });
          function NTe(t, e, r) {
            return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = UE.from(e, r)), e;
          }
          Object.defineProperty(Xr.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
            return this._writableState.highWaterMark;
          } });
          function OTe(t, e, r, n, i2, o) {
            if (!r) {
              var s = NTe(e, n, i2);
              n !== s && (r = true, i2 = "buffer", n = s);
            }
            var a = e.objectMode ? 1 : n.length;
            e.length += a;
            var u = e.length < e.highWaterMark;
            if (u || (e.needDrain = true), e.writing || e.corked) {
              var l = e.lastBufferedRequest;
              e.lastBufferedRequest = { chunk: n, encoding: i2, isBuf: r, callback: o, next: null }, l ? l.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
            } else
              DC(t, e, false, a, n, i2, o);
            return u;
          }
          function DC(t, e, r, n, i2, o, s) {
            e.writelen = n, e.writecb = s, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ATe("write")) : r ? t._writev(i2, e.onwrite) : t._write(i2, o, e.onwrite), e.sync = false;
          }
          function LTe(t, e, r, n, i2) {
            --e.pendingcb, r ? (process.nextTick(i2, n), process.nextTick(Ng, t, e), t._writableState.errorEmitted = true, A1(t, n)) : (i2(n), t._writableState.errorEmitted = true, A1(t, n), Ng(t, e));
          }
          function BTe(t) {
            t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
          }
          function MTe(t, e) {
            var r = t._writableState, n = r.sync, i2 = r.writecb;
            if (typeof i2 != "function")
              throw new xTe();
            if (BTe(r), e)
              LTe(t, r, n, e, i2);
            else {
              var o = Cte(r) || t.destroyed;
              !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ite(t, r), n ? process.nextTick(Rte, t, r, o, i2) : Rte(t, r, o, i2);
            }
          }
          function Rte(t, e, r, n) {
            r || UTe(t, e), e.pendingcb--, n(), Ng(t, e);
          }
          function UTe(t, e) {
            e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
          }
          function Ite(t, e) {
            e.bufferProcessing = true;
            var r = e.bufferedRequest;
            if (t._writev && r && r.next) {
              var n = e.bufferedRequestCount, i2 = new Array(n), o = e.corkedRequestsFree;
              o.entry = r;
              for (var s = 0, a = true; r; )
                i2[s] = r, r.isBuf || (a = false), r = r.next, s += 1;
              i2.allBuffers = a, DC(t, e, true, e.length, i2, "", o.finish), e.pendingcb++, e.lastBufferedRequest = null, o.next ? (e.corkedRequestsFree = o.next, o.next = null) : e.corkedRequestsFree = new Ate(e), e.bufferedRequestCount = 0;
            } else {
              for (; r; ) {
                var u = r.chunk, l = r.encoding, f = r.callback, h = e.objectMode ? 1 : u.length;
                if (DC(t, e, false, h, u, l, f), r = r.next, e.bufferedRequestCount--, e.writing)
                  break;
              }
              r === null && (e.lastBufferedRequest = null);
            }
            e.bufferedRequest = r, e.bufferProcessing = false;
          }
          Xr.prototype._write = function(t, e, r) {
            r(new STe("_write()"));
          };
          Xr.prototype._writev = null;
          Xr.prototype.end = function(t, e, r) {
            var n = this._writableState;
            return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || VTe(this, n, r), this;
          };
          Object.defineProperty(Xr.prototype, "writableLength", { enumerable: false, get: function() {
            return this._writableState.length;
          } });
          function Cte(t) {
            return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
          }
          function FTe(t, e) {
            t._final(function(r) {
              e.pendingcb--, r && A1(t, r), e.prefinished = true, t.emit("prefinish"), Ng(t, e);
            });
          }
          function KTe(t, e) {
            !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(FTe, t, e)) : (e.prefinished = true, t.emit("prefinish")));
          }
          function Ng(t, e) {
            var r = Cte(e);
            if (r && (KTe(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
              var n = t._readableState;
              (!n || n.autoDestroy && n.endEmitted) && t.destroy();
            }
            return r;
          }
          function VTe(t, e, r) {
            e.ending = true, Ng(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
          }
          function qTe(t, e, r) {
            var n = t.entry;
            for (t.entry = null; n; ) {
              var i2 = n.callback;
              e.pendingcb--, i2(r), n = n.next;
            }
            e.corkedRequestsFree.next = t;
          }
          Object.defineProperty(Xr.prototype, "destroyed", { enumerable: false, get: function() {
            return this._writableState === void 0 ? false : this._writableState.destroyed;
          }, set: function(e) {
            !this._writableState || (this._writableState.destroyed = e);
          } });
          Xr.prototype.destroy = kC.destroy;
          Xr.prototype._undestroy = kC.undestroy;
          Xr.prototype._destroy = function(t, e) {
            e(t);
          };
        });
        var dd = A((dht, kte) => {
          "use strict";
          c();
          var zTe = Object.keys || function(t) {
            var e = [];
            for (var r in t)
              e.push(r);
            return e;
          };
          kte.exports = Ja;
          var Dte = BC(), LC = NC();
          ni()(Ja, Dte);
          for (OC = zTe(LC.prototype), FE = 0; FE < OC.length; FE++)
            KE = OC[FE], Ja.prototype[KE] || (Ja.prototype[KE] = LC.prototype[KE]);
          var OC, KE, FE;
          function Ja(t) {
            if (!(this instanceof Ja))
              return new Ja(t);
            Dte.call(this, t), LC.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", HTe)));
          }
          Object.defineProperty(Ja.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
            return this._writableState.highWaterMark;
          } });
          Object.defineProperty(Ja.prototype, "writableBuffer", { enumerable: false, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } });
          Object.defineProperty(Ja.prototype, "writableLength", { enumerable: false, get: function() {
            return this._writableState.length;
          } });
          function HTe() {
            this._writableState.ended || process.nextTick($Te, this);
          }
          function $Te(t) {
            t.end();
          }
          Object.defineProperty(Ja.prototype, "destroyed", { enumerable: false, get: function() {
            return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(e) {
            this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e);
          } });
        });
        var VE = A((pht, Lte) => {
          "use strict";
          c();
          var Nte = hd().codes.ERR_STREAM_PREMATURE_CLOSE;
          function GTe(t) {
            var e = false;
            return function() {
              if (!e) {
                e = true;
                for (var r = arguments.length, n = new Array(r), i2 = 0; i2 < r; i2++)
                  n[i2] = arguments[i2];
                t.apply(this, n);
              }
            };
          }
          function WTe() {
          }
          function jTe(t) {
            return t.setHeader && typeof t.abort == "function";
          }
          function Ote(t, e, r) {
            if (typeof e == "function")
              return Ote(t, null, e);
            e || (e = {}), r = GTe(r || WTe);
            var n = e.readable || e.readable !== false && t.readable, i2 = e.writable || e.writable !== false && t.writable, o = function() {
              t.writable || a();
            }, s = t._writableState && t._writableState.finished, a = function() {
              i2 = false, s = true, n || r.call(t);
            }, u = t._readableState && t._readableState.endEmitted, l = function() {
              n = false, u = true, i2 || r.call(t);
            }, f = function(m) {
              r.call(t, m);
            }, h = function() {
              var m;
              if (n && !u)
                return (!t._readableState || !t._readableState.ended) && (m = new Nte()), r.call(t, m);
              if (i2 && !s)
                return (!t._writableState || !t._writableState.ended) && (m = new Nte()), r.call(t, m);
            }, p = function() {
              t.req.on("finish", a);
            };
            return jTe(t) ? (t.on("complete", a), t.on("abort", h), t.req ? p() : t.on("request", p)) : i2 && !t._writableState && (t.on("end", o), t.on("close", o)), t.on("end", l), t.on("finish", a), e.error !== false && t.on("error", f), t.on("close", h), function() {
              t.removeListener("complete", a), t.removeListener("abort", h), t.removeListener("request", p), t.req && t.req.removeListener("finish", a), t.removeListener("end", o), t.removeListener("close", o), t.removeListener("finish", a), t.removeListener("end", l), t.removeListener("error", f), t.removeListener("close", h);
            };
          }
          Lte.exports = Ote;
        });
        var Mte = A((mht, Bte) => {
          "use strict";
          c();
          var qE;
          function rf(t, e, r) {
            return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
          }
          var YTe = VE(), nf = Symbol("lastResolve"), pd = Symbol("lastReject"), Lg = Symbol("error"), zE = Symbol("ended"), md = Symbol("lastPromise"), MC = Symbol("handlePromise"), yd = Symbol("stream");
          function of(t, e) {
            return { value: t, done: e };
          }
          function QTe(t) {
            var e = t[nf];
            if (e !== null) {
              var r = t[yd].read();
              r !== null && (t[md] = null, t[nf] = null, t[pd] = null, e(of(r, false)));
            }
          }
          function XTe(t) {
            process.nextTick(QTe, t);
          }
          function ZTe(t, e) {
            return function(r, n) {
              t.then(function() {
                if (e[zE]) {
                  r(of(void 0, true));
                  return;
                }
                e[MC](r, n);
              }, n);
            };
          }
          var JTe = Object.getPrototypeOf(function() {
          }), eIe = Object.setPrototypeOf((qE = { get stream() {
            return this[yd];
          }, next: function() {
            var e = this, r = this[Lg];
            if (r !== null)
              return Promise.reject(r);
            if (this[zE])
              return Promise.resolve(of(void 0, true));
            if (this[yd].destroyed)
              return new Promise(function(s, a) {
                process.nextTick(function() {
                  e[Lg] ? a(e[Lg]) : s(of(void 0, true));
                });
              });
            var n = this[md], i2;
            if (n)
              i2 = new Promise(ZTe(n, this));
            else {
              var o = this[yd].read();
              if (o !== null)
                return Promise.resolve(of(o, false));
              i2 = new Promise(this[MC]);
            }
            return this[md] = i2, i2;
          } }, rf(qE, Symbol.asyncIterator, function() {
            return this;
          }), rf(qE, "return", function() {
            var e = this;
            return new Promise(function(r, n) {
              e[yd].destroy(null, function(i2) {
                if (i2) {
                  n(i2);
                  return;
                }
                r(of(void 0, true));
              });
            });
          }), qE), JTe), tIe = function(e) {
            var r, n = Object.create(eIe, (r = {}, rf(r, yd, { value: e, writable: true }), rf(r, nf, { value: null, writable: true }), rf(r, pd, { value: null, writable: true }), rf(r, Lg, { value: null, writable: true }), rf(r, zE, { value: e._readableState.endEmitted, writable: true }), rf(r, MC, { value: function(o, s) {
              var a = n[yd].read();
              a ? (n[md] = null, n[nf] = null, n[pd] = null, o(of(a, false))) : (n[nf] = o, n[pd] = s);
            }, writable: true }), r));
            return n[md] = null, YTe(e, function(i2) {
              if (i2 && i2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var o = n[pd];
                o !== null && (n[md] = null, n[nf] = null, n[pd] = null, o(i2)), n[Lg] = i2;
                return;
              }
              var s = n[nf];
              s !== null && (n[md] = null, n[nf] = null, n[pd] = null, s(of(void 0, true))), n[zE] = true;
            }), e.on("readable", XTe.bind(null, n)), n;
          };
          Bte.exports = tIe;
        });
        var Fte = A((yht, Ute) => {
          c();
          Ute.exports = function() {
            throw new Error("Readable.from is not available in the browser");
          };
        });
        var BC = A((wht, Yte) => {
          "use strict";
          c();
          Yte.exports = Kt;
          var T1;
          Kt.ReadableState = zte;
          var ght = In().EventEmitter, qte = function(e, r) {
            return e.listeners(r).length;
          }, Mg = AC(), HE = _i().Buffer, rIe = globalThis.Uint8Array || function() {
          };
          function nIe(t) {
            return HE.from(t);
          }
          function iIe(t) {
            return HE.isBuffer(t) || t instanceof rIe;
          }
          var UC = fg(), gt;
          UC && UC.debuglog ? gt = UC.debuglog("stream") : gt = function() {
          };
          var oIe = wte(), $C = CC(), sIe = PC(), aIe = sIe.getHighWaterMark, $E = hd().codes, cIe = $E.ERR_INVALID_ARG_TYPE, uIe = $E.ERR_STREAM_PUSH_AFTER_EOF, lIe = $E.ERR_METHOD_NOT_IMPLEMENTED, fIe = $E.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, I1, FC, KC;
          ni()(Kt, Mg);
          var Bg = $C.errorOrDestroy, VC = ["error", "close", "destroy", "pause", "resume"];
          function hIe(t, e, r) {
            if (typeof t.prependListener == "function")
              return t.prependListener(e, r);
            !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
          }
          function zte(t, e, r) {
            T1 = T1 || dd(), t = t || {}, typeof r != "boolean" && (r = e instanceof T1), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = aIe(this, t, "readableHighWaterMark", r), this.buffer = new oIe(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (I1 || (I1 = mg().StringDecoder), this.decoder = new I1(t.encoding), this.encoding = t.encoding);
          }
          function Kt(t) {
            if (T1 = T1 || dd(), !(this instanceof Kt))
              return new Kt(t);
            var e = this instanceof T1;
            this._readableState = new zte(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Mg.call(this);
          }
          Object.defineProperty(Kt.prototype, "destroyed", { enumerable: false, get: function() {
            return this._readableState === void 0 ? false : this._readableState.destroyed;
          }, set: function(e) {
            !this._readableState || (this._readableState.destroyed = e);
          } });
          Kt.prototype.destroy = $C.destroy;
          Kt.prototype._undestroy = $C.undestroy;
          Kt.prototype._destroy = function(t, e) {
            e(t);
          };
          Kt.prototype.push = function(t, e) {
            var r = this._readableState, n;
            return r.objectMode ? n = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = HE.from(t, e), e = ""), n = true), Hte(this, t, e, false, n);
          };
          Kt.prototype.unshift = function(t) {
            return Hte(this, t, null, true, false);
          };
          function Hte(t, e, r, n, i2) {
            gt("readableAddChunk", e);
            var o = t._readableState;
            if (e === null)
              o.reading = false, mIe(t, o);
            else {
              var s;
              if (i2 || (s = dIe(o, e)), s)
                Bg(t, s);
              else if (o.objectMode || e && e.length > 0)
                if (typeof e != "string" && !o.objectMode && Object.getPrototypeOf(e) !== HE.prototype && (e = nIe(e)), n)
                  o.endEmitted ? Bg(t, new fIe()) : qC(t, o, e, true);
                else if (o.ended)
                  Bg(t, new uIe());
                else {
                  if (o.destroyed)
                    return false;
                  o.reading = false, o.decoder && !r ? (e = o.decoder.write(e), o.objectMode || e.length !== 0 ? qC(t, o, e, false) : HC(t, o)) : qC(t, o, e, false);
                }
              else
                n || (o.reading = false, HC(t, o));
            }
            return !o.ended && (o.length < o.highWaterMark || o.length === 0);
          }
          function qC(t, e, r, n) {
            e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && GE(t)), HC(t, e);
          }
          function dIe(t, e) {
            var r;
            return !iIe(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new cIe("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
          }
          Kt.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Kt.prototype.setEncoding = function(t) {
            I1 || (I1 = mg().StringDecoder);
            var e = new I1(t);
            this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var r = this._readableState.buffer.head, n = ""; r !== null; )
              n += e.write(r.data), r = r.next;
            return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
          };
          var Kte = 1073741824;
          function pIe(t) {
            return t >= Kte ? t = Kte : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
          }
          function Vte(t, e) {
            return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = pIe(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
          }
          Kt.prototype.read = function(t) {
            gt("read", t), t = parseInt(t, 10);
            var e = this._readableState, r = t;
            if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
              return gt("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? zC(this) : GE(this), null;
            if (t = Vte(t, e), t === 0 && e.ended)
              return e.length === 0 && zC(this), null;
            var n = e.needReadable;
            gt("need readable", n), (e.length === 0 || e.length - t < e.highWaterMark) && (n = true, gt("length less than watermark", n)), e.ended || e.reading ? (n = false, gt("reading or ended", n)) : n && (gt("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Vte(r, e)));
            var i2;
            return t > 0 ? i2 = Wte(t, e) : i2 = null, i2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && zC(this)), i2 !== null && this.emit("data", i2), i2;
          };
          function mIe(t, e) {
            if (gt("onEofChunk"), !e.ended) {
              if (e.decoder) {
                var r = e.decoder.end();
                r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
              }
              e.ended = true, e.sync ? GE(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, $te(t)));
            }
          }
          function GE(t) {
            var e = t._readableState;
            gt("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (gt("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick($te, t));
          }
          function $te(t) {
            var e = t._readableState;
            gt("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, GC(t);
          }
          function HC(t, e) {
            e.readingMore || (e.readingMore = true, process.nextTick(yIe, t, e));
          }
          function yIe(t, e) {
            for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
              var r = e.length;
              if (gt("maybeReadMore read 0"), t.read(0), r === e.length)
                break;
            }
            e.readingMore = false;
          }
          Kt.prototype._read = function(t) {
            Bg(this, new lIe("_read()"));
          };
          Kt.prototype.pipe = function(t, e) {
            var r = this, n = this._readableState;
            switch (n.pipesCount) {
              case 0:
                n.pipes = t;
                break;
              case 1:
                n.pipes = [n.pipes, t];
                break;
              default:
                n.pipes.push(t);
                break;
            }
            n.pipesCount += 1, gt("pipe count=%d opts=%j", n.pipesCount, e);
            var i2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, o = i2 ? a : y;
            n.endEmitted ? process.nextTick(o) : r.once("end", o), t.on("unpipe", s);
            function s(g, E) {
              gt("onunpipe"), g === r && E && E.hasUnpiped === false && (E.hasUnpiped = true, f());
            }
            function a() {
              gt("onend"), t.end();
            }
            var u = gIe(r);
            t.on("drain", u);
            var l = false;
            function f() {
              gt("cleanup"), t.removeListener("close", d), t.removeListener("finish", m), t.removeListener("drain", u), t.removeListener("error", p), t.removeListener("unpipe", s), r.removeListener("end", a), r.removeListener("end", y), r.removeListener("data", h), l = true, n.awaitDrain && (!t._writableState || t._writableState.needDrain) && u();
            }
            r.on("data", h);
            function h(g) {
              gt("ondata");
              var E = t.write(g);
              gt("dest.write", E), E === false && ((n.pipesCount === 1 && n.pipes === t || n.pipesCount > 1 && jte(n.pipes, t) !== -1) && !l && (gt("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
            }
            function p(g) {
              gt("onerror", g), y(), t.removeListener("error", p), qte(t, "error") === 0 && Bg(t, g);
            }
            hIe(t, "error", p);
            function d() {
              t.removeListener("finish", m), y();
            }
            t.once("close", d);
            function m() {
              gt("onfinish"), t.removeListener("close", d), y();
            }
            t.once("finish", m);
            function y() {
              gt("unpipe"), r.unpipe(t);
            }
            return t.emit("pipe", r), n.flowing || (gt("pipe resume"), r.resume()), t;
          };
          function gIe(t) {
            return function() {
              var r = t._readableState;
              gt("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && qte(t, "data") && (r.flowing = true, GC(t));
            };
          }
          Kt.prototype.unpipe = function(t) {
            var e = this._readableState, r = { hasUnpiped: false };
            if (e.pipesCount === 0)
              return this;
            if (e.pipesCount === 1)
              return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
            if (!t) {
              var n = e.pipes, i2 = e.pipesCount;
              e.pipes = null, e.pipesCount = 0, e.flowing = false;
              for (var o = 0; o < i2; o++)
                n[o].emit("unpipe", this, { hasUnpiped: false });
              return this;
            }
            var s = jte(e.pipes, t);
            return s === -1 ? this : (e.pipes.splice(s, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
          };
          Kt.prototype.on = function(t, e) {
            var r = Mg.prototype.on.call(this, t, e), n = this._readableState;
            return t === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : t === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, gt("on readable", n.length, n.reading), n.length ? GE(this) : n.reading || process.nextTick(wIe, this)), r;
          };
          Kt.prototype.addListener = Kt.prototype.on;
          Kt.prototype.removeListener = function(t, e) {
            var r = Mg.prototype.removeListener.call(this, t, e);
            return t === "readable" && process.nextTick(Gte, this), r;
          };
          Kt.prototype.removeAllListeners = function(t) {
            var e = Mg.prototype.removeAllListeners.apply(this, arguments);
            return (t === "readable" || t === void 0) && process.nextTick(Gte, this), e;
          };
          function Gte(t) {
            var e = t._readableState;
            e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
          }
          function wIe(t) {
            gt("readable nexttick read 0"), t.read(0);
          }
          Kt.prototype.resume = function() {
            var t = this._readableState;
            return t.flowing || (gt("resume"), t.flowing = !t.readableListening, EIe(this, t)), t.paused = false, this;
          };
          function EIe(t, e) {
            e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(bIe, t, e));
          }
          function bIe(t, e) {
            gt("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), GC(t), e.flowing && !e.reading && t.read(0);
          }
          Kt.prototype.pause = function() {
            return gt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (gt("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
          };
          function GC(t) {
            var e = t._readableState;
            for (gt("flow", e.flowing); e.flowing && t.read() !== null; )
              ;
          }
          Kt.prototype.wrap = function(t) {
            var e = this, r = this._readableState, n = false;
            t.on("end", function() {
              if (gt("wrapped end"), r.decoder && !r.ended) {
                var s = r.decoder.end();
                s && s.length && e.push(s);
              }
              e.push(null);
            }), t.on("data", function(s) {
              if (gt("wrapped data"), r.decoder && (s = r.decoder.write(s)), !(r.objectMode && s == null) && !(!r.objectMode && (!s || !s.length))) {
                var a = e.push(s);
                a || (n = true, t.pause());
              }
            });
            for (var i2 in t)
              this[i2] === void 0 && typeof t[i2] == "function" && (this[i2] = function(a) {
                return function() {
                  return t[a].apply(t, arguments);
                };
              }(i2));
            for (var o = 0; o < VC.length; o++)
              t.on(VC[o], this.emit.bind(this, VC[o]));
            return this._read = function(s) {
              gt("wrapped _read", s), n && (n = false, t.resume());
            }, this;
          };
          typeof Symbol == "function" && (Kt.prototype[Symbol.asyncIterator] = function() {
            return FC === void 0 && (FC = Mte()), FC(this);
          });
          Object.defineProperty(Kt.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
            return this._readableState.highWaterMark;
          } });
          Object.defineProperty(Kt.prototype, "readableBuffer", { enumerable: false, get: function() {
            return this._readableState && this._readableState.buffer;
          } });
          Object.defineProperty(Kt.prototype, "readableFlowing", { enumerable: false, get: function() {
            return this._readableState.flowing;
          }, set: function(e) {
            this._readableState && (this._readableState.flowing = e);
          } });
          Kt._fromList = Wte;
          Object.defineProperty(Kt.prototype, "readableLength", { enumerable: false, get: function() {
            return this._readableState.length;
          } });
          function Wte(t, e) {
            if (e.length === 0)
              return null;
            var r;
            return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
          }
          function zC(t) {
            var e = t._readableState;
            gt("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(_Ie, e, t));
          }
          function _Ie(t, e) {
            if (gt("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
              var r = e._writableState;
              (!r || r.autoDestroy && r.finished) && e.destroy();
            }
          }
          typeof Symbol == "function" && (Kt.from = function(t, e) {
            return KC === void 0 && (KC = Fte()), KC(Kt, t, e);
          });
          function jte(t, e) {
            for (var r = 0, n = t.length; r < n; r++)
              if (t[r] === e)
                return r;
            return -1;
          }
        });
        var WC = A((Eht, Xte) => {
          "use strict";
          c();
          Xte.exports = su;
          var WE = hd().codes, vIe = WE.ERR_METHOD_NOT_IMPLEMENTED, SIe = WE.ERR_MULTIPLE_CALLBACK, xIe = WE.ERR_TRANSFORM_ALREADY_TRANSFORMING, RIe = WE.ERR_TRANSFORM_WITH_LENGTH_0, jE = dd();
          ni()(su, jE);
          function AIe(t, e) {
            var r = this._transformState;
            r.transforming = false;
            var n = r.writecb;
            if (n === null)
              return this.emit("error", new SIe());
            r.writechunk = null, r.writecb = null, e != null && this.push(e), n(t);
            var i2 = this._readableState;
            i2.reading = false, (i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
          }
          function su(t) {
            if (!(this instanceof su))
              return new su(t);
            jE.call(this, t), this._transformState = { afterTransform: AIe.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", TIe);
          }
          function TIe() {
            var t = this;
            typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
              Qte(t, e, r);
            }) : Qte(this, null, null);
          }
          su.prototype.push = function(t, e) {
            return this._transformState.needTransform = false, jE.prototype.push.call(this, t, e);
          };
          su.prototype._transform = function(t, e, r) {
            r(new vIe("_transform()"));
          };
          su.prototype._write = function(t, e, r) {
            var n = this._transformState;
            if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
              var i2 = this._readableState;
              (n.needTransform || i2.needReadable || i2.length < i2.highWaterMark) && this._read(i2.highWaterMark);
            }
          };
          su.prototype._read = function(t) {
            var e = this._transformState;
            e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
          };
          su.prototype._destroy = function(t, e) {
            jE.prototype._destroy.call(this, t, function(r) {
              e(r);
            });
          };
          function Qte(t, e, r) {
            if (e)
              return t.emit("error", e);
            if (r != null && t.push(r), t._writableState.length)
              throw new RIe();
            if (t._transformState.transforming)
              throw new xIe();
            return t.push(null);
          }
        });
        var ere = A((bht, Jte) => {
          "use strict";
          c();
          Jte.exports = Ug;
          var Zte = WC();
          ni()(Ug, Zte);
          function Ug(t) {
            if (!(this instanceof Ug))
              return new Ug(t);
            Zte.call(this, t);
          }
          Ug.prototype._transform = function(t, e, r) {
            r(null, t);
          };
        });
        var ore = A((_ht, ire) => {
          "use strict";
          c();
          var jC;
          function IIe(t) {
            var e = false;
            return function() {
              e || (e = true, t.apply(void 0, arguments));
            };
          }
          var nre = hd().codes, CIe = nre.ERR_MISSING_ARGS, PIe = nre.ERR_STREAM_DESTROYED;
          function tre(t) {
            if (t)
              throw t;
          }
          function DIe(t) {
            return t.setHeader && typeof t.abort == "function";
          }
          function kIe(t, e, r, n) {
            n = IIe(n);
            var i2 = false;
            t.on("close", function() {
              i2 = true;
            }), jC === void 0 && (jC = VE()), jC(t, { readable: e, writable: r }, function(s) {
              if (s)
                return n(s);
              i2 = true, n();
            });
            var o = false;
            return function(s) {
              if (!i2 && !o) {
                if (o = true, DIe(t))
                  return t.abort();
                if (typeof t.destroy == "function")
                  return t.destroy();
                n(s || new PIe("pipe"));
              }
            };
          }
          function rre(t) {
            t();
          }
          function NIe(t, e) {
            return t.pipe(e);
          }
          function OIe(t) {
            return !t.length || typeof t[t.length - 1] != "function" ? tre : t.pop();
          }
          function LIe() {
            for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
              e[r] = arguments[r];
            var n = OIe(e);
            if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
              throw new CIe("streams");
            var i2, o = e.map(function(s, a) {
              var u = a < e.length - 1, l = a > 0;
              return kIe(s, u, l, function(f) {
                i2 || (i2 = f), f && o.forEach(rre), !u && (o.forEach(rre), n(i2));
              });
            });
            return e.reduce(NIe);
          }
          ire.exports = LIe;
        });
        var are = A((us, sre) => {
          c();
          us = sre.exports = BC();
          us.Stream = us;
          us.Readable = us;
          us.Writable = NC();
          us.Duplex = dd();
          us.Transform = WC();
          us.PassThrough = ere();
          us.finished = VE();
          us.pipeline = ore();
        });
        var YC = A((vht, ure) => {
          "use strict";
          c();
          var { Readable: BIe } = are(), cre = uh(), MIe = (t = 1 / 0) => {
            let e = 0;
            return new BIe({ read(r) {
              if (e >= t)
                return this.push(null);
              e + r >= t && (r = t - e), e += r, this.push(cre(r));
            } });
          };
          ure.exports = { randomStream: MIe, randomBytes: cre };
        });
        var $ne = A((p2t, Hne) => {
          c();
          Hne.exports = (t) => {
            if (t[Symbol.asyncIterator])
              return t;
            if (t.getReader)
              return async function* () {
                let e = t.getReader();
                try {
                  for (; ; ) {
                    let { done: r, value: n } = await e.read();
                    if (r)
                      return;
                    yield n;
                  }
                } finally {
                  e.releaseLock();
                }
              }();
            throw new Error("unknown stream");
          };
        });
        var hP = A(() => {
          c();
        });
        var dP = A((u5t, Boe) => {
          "use strict";
          c();
          var XCe = Vp(), ZCe = (t, e) => ({ path: decodeURIComponent(new URL(t).pathname.split("/").pop() || ""), content: JCe(t, e) });
          async function* JCe(t, e) {
            yield* (await new XCe().get(t, e)).iterator();
          }
          Boe.exports = ZCe;
        });
        var AP = A((kEt, RP) => {
          "use strict";
          c();
          var IPe = (t, e) => Math.floor(Math.random() * (e - t + 1) + t), fse = () => {
            let t = new Error("Delay aborted");
            return t.name = "AbortError", t;
          }, hse = ({ clearTimeout: t, setTimeout: e, willResolve: r }) => (n, { value: i2, signal: o } = {}) => {
            if (o && o.aborted)
              return Promise.reject(fse());
            let s, a, u, l = t || clearTimeout, f = () => {
              l(s), u(fse());
            }, h = () => {
              o && o.removeEventListener("abort", f);
            }, p = new Promise((d, m) => {
              a = () => {
                h(), r ? d(i2) : m(i2);
              }, u = m, s = (e || setTimeout)(a, n);
            });
            return o && o.addEventListener("abort", f, { once: true }), p.clear = () => {
              l(s), s = null, a();
            }, p;
          }, dse = (t) => {
            let e = hse({ ...t, willResolve: true });
            return e.reject = hse({ ...t, willResolve: false }), e.range = (r, n, i2) => e(IPe(r, n), i2), e;
          }, xP = dse();
          xP.createWithTimers = dse;
          RP.exports = xP;
          RP.exports.default = xP;
        });
        var OP = A((zbt, Pse) => {
          "use strict";
          c();
          var $1 = /* @__PURE__ */ new Map(), FPe = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
          async function KPe(t, e, r) {
            for (; $1.get(r); ) {
              try {
                await t();
              } catch (n) {
                setTimeout(() => {
                  throw n;
                }, 1);
                break;
              }
              if (!$1.get(r))
                break;
              await new Promise((n) => {
                let i2 = setTimeout(n, e);
                $1.set(r, i2);
              });
            }
          }
          function VPe(t, e, r) {
            r = r || e;
            let n = FPe(), i2 = setTimeout(() => {
              KPe(t, e, n);
            }, r);
            return $1.set(n, i2), n;
          }
          function qPe(t) {
            let e = $1.get(t);
            e && (clearTimeout(e), $1.delete(t));
          }
          Pse.exports = { setDelayedInterval: VPe, clearDelayedInterval: qPe };
        });
        var Vse = A((g_t, Kse) => {
          "use strict";
          c();
          var WPe = () => {
            let t = {};
            return t.promise = new Promise((e, r) => {
              t.resolve = e, t.reject = r;
            }), t;
          };
          Kse.exports = WPe;
        });
        var $se = A((E_t, Hse) => {
          c();
          var qse = d0(), zse = Vse();
          Hse.exports = class {
            constructor() {
              this._buffer = new qse(), this._waitingConsumers = new qse();
            }
            push(e) {
              let { promise: r, resolve: n } = zse();
              return this._buffer.push({ chunk: e, resolve: n }), this._consume(), r;
            }
            _consume() {
              for (; !this._waitingConsumers.isEmpty() && !this._buffer.isEmpty(); ) {
                let e = this._waitingConsumers.shift(), r = this._buffer.shift();
                e.resolve(r.chunk), r.resolve();
              }
            }
            shift() {
              let { promise: e, resolve: r } = zse();
              return this._waitingConsumers.push({ resolve: r }), this._consume(), e;
            }
            isEmpty() {
              return this._buffer.isEmpty();
            }
          };
        });
        var Yse = A((m3) => {
          c();
          (function() {
            var t, e, r, n, i2, o, s, a;
            a = function(u) {
              var l, f, h, p;
              return l = (u & 255 << 24) >>> 24, f = (u & 255 << 16) >>> 16, h = (u & 255 << 8) >>> 8, p = u & 255, [l, f, h, p].join(".");
            }, s = function(u) {
              var l, f, h, p, d, m;
              for (l = [], h = p = 0; p <= 3 && u.length !== 0; h = ++p) {
                if (h > 0) {
                  if (u[0] !== ".")
                    throw new Error("Invalid IP");
                  u = u.substring(1);
                }
                m = e(u), d = m[0], f = m[1], u = u.substring(f), l.push(d);
              }
              if (u.length !== 0)
                throw new Error("Invalid IP");
              switch (l.length) {
                case 1:
                  if (l[0] > 4294967295)
                    throw new Error("Invalid IP");
                  return l[0] >>> 0;
                case 2:
                  if (l[0] > 255 || l[1] > 16777215)
                    throw new Error("Invalid IP");
                  return (l[0] << 24 | l[1]) >>> 0;
                case 3:
                  if (l[0] > 255 || l[1] > 255 || l[2] > 65535)
                    throw new Error("Invalid IP");
                  return (l[0] << 24 | l[1] << 16 | l[2]) >>> 0;
                case 4:
                  if (l[0] > 255 || l[1] > 255 || l[2] > 255 || l[3] > 255)
                    throw new Error("Invalid IP");
                  return (l[0] << 24 | l[1] << 16 | l[2] << 8 | l[3]) >>> 0;
                default:
                  throw new Error("Invalid IP");
              }
            }, r = function(u) {
              return u.charCodeAt(0);
            }, n = r("0"), o = r("a"), i2 = r("A"), e = function(u) {
              var l, f, h, p, d;
              for (p = 0, l = 10, f = "9", h = 0, u.length > 1 && u[h] === "0" && (u[h + 1] === "x" || u[h + 1] === "X" ? (h += 2, l = 16) : "0" <= u[h + 1] && u[h + 1] <= "9" && (h++, l = 8, f = "7")), d = h; h < u.length; ) {
                if ("0" <= u[h] && u[h] <= f)
                  p = p * l + (r(u[h]) - n) >>> 0;
                else if (l === 16)
                  if ("a" <= u[h] && u[h] <= "f")
                    p = p * l + (10 + r(u[h]) - o) >>> 0;
                  else if ("A" <= u[h] && u[h] <= "F")
                    p = p * l + (10 + r(u[h]) - i2) >>> 0;
                  else
                    break;
                else
                  break;
                if (p > 4294967295)
                  throw new Error("too large");
                h++;
              }
              if (h === d)
                throw new Error("empty octet");
              return [p, h];
            }, t = function() {
              function u(l, f) {
                var h, p, d, m;
                if (typeof l != "string")
                  throw new Error("Missing `net' parameter");
                if (f || (m = l.split("/", 2), l = m[0], f = m[1]), f || (f = 32), typeof f == "string" && f.indexOf(".") > -1) {
                  try {
                    this.maskLong = s(f);
                  } catch (y) {
                    throw h = y, new Error("Invalid mask: " + f);
                  }
                  for (p = d = 32; d >= 0; p = --d)
                    if (this.maskLong === 4294967295 << 32 - p >>> 0) {
                      this.bitmask = p;
                      break;
                    }
                } else if (f || f === 0)
                  this.bitmask = parseInt(f, 10), this.maskLong = 0, this.bitmask > 0 && (this.maskLong = 4294967295 << 32 - this.bitmask >>> 0);
                else
                  throw new Error("Invalid mask: empty");
                try {
                  this.netLong = (s(l) & this.maskLong) >>> 0;
                } catch (y) {
                  throw h = y, new Error("Invalid net address: " + l);
                }
                if (!(this.bitmask <= 32))
                  throw new Error("Invalid mask for ip4: " + f);
                this.size = Math.pow(2, 32 - this.bitmask), this.base = a(this.netLong), this.mask = a(this.maskLong), this.hostmask = a(~this.maskLong), this.first = this.bitmask <= 30 ? a(this.netLong + 1) : this.base, this.last = this.bitmask <= 30 ? a(this.netLong + this.size - 2) : a(this.netLong + this.size - 1), this.broadcast = this.bitmask <= 30 ? a(this.netLong + this.size - 1) : void 0;
              }
              return u.prototype.contains = function(l) {
                return typeof l == "string" && (l.indexOf("/") > 0 || l.split(".").length !== 4) && (l = new u(l)), l instanceof u ? this.contains(l.base) && this.contains(l.broadcast || l.last) : (s(l) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
              }, u.prototype.next = function(l) {
                return l == null && (l = 1), new u(a(this.netLong + this.size * l), this.mask);
              }, u.prototype.forEach = function(l) {
                var f, h, p;
                for (p = s(this.first), h = s(this.last), f = 0; p <= h; )
                  l(a(p), p, f), f++, p++;
              }, u.prototype.toString = function() {
                return this.base + "/" + this.bitmask;
              }, u;
            }(), m3.ip2long = s, m3.long2ip = a, m3.Netmask = t;
          }).call(m3);
        });
        var VP = A((x_t, Xse) => {
          "use strict";
          c();
          var Qse = "[a-fA-F\\d:]", hf = (t) => t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${Qse})|(?<=${Qse})(?=\\s|$))` : "", ra = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", _n = "[a-fA-F\\d]{1,4}", Xb = `
(?:
(?:${_n}:){7}(?:${_n}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${_n}:){6}(?:${ra}|:${_n}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${_n}:){5}(?::${ra}|(?::${_n}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${_n}:){4}(?:(?::${_n}){0,1}:${ra}|(?::${_n}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${_n}:){3}(?:(?::${_n}){0,2}:${ra}|(?::${_n}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${_n}:){2}(?:(?::${_n}){0,3}:${ra}|(?::${_n}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${_n}:){1}(?:(?::${_n}){0,4}:${ra}|(?::${_n}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${_n}){0,5}:${ra}|(?::${_n}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), jPe = new RegExp(`(?:^${ra}$)|(?:^${Xb}$)`), YPe = new RegExp(`^${ra}$`), QPe = new RegExp(`^${Xb}$`), KP = (t) => t && t.exact ? jPe : new RegExp(`(?:${hf(t)}${ra}${hf(t)})|(?:${hf(t)}${Xb}${hf(t)})`, "g");
          KP.v4 = (t) => t && t.exact ? YPe : new RegExp(`${hf(t)}${ra}${hf(t)}`, "g");
          KP.v6 = (t) => t && t.exact ? QPe : new RegExp(`${hf(t)}${Xb}${hf(t)}`, "g");
          Xse.exports = KP;
        });
        var Jse = A((R_t, Zse) => {
          "use strict";
          c();
          var qP = VP(), G1 = (t) => qP({ exact: true }).test(t);
          G1.v4 = (t) => qP.v4({ exact: true }).test(t);
          G1.v6 = (t) => qP.v6({ exact: true }).test(t);
          G1.version = (t) => G1(t) ? G1.v4(t) ? 4 : 6 : void 0;
          Zse.exports = G1;
        });
        var tae = A((eae, Zb) => {
          c();
          (function(t) {
            "use strict";
            let e = "(0?\\d+|0x[a-f0-9]+)", r = { fourOctet: new RegExp(`^${e}\\.${e}\\.${e}\\.${e}$`, "i"), threeOctet: new RegExp(`^${e}\\.${e}\\.${e}$`, "i"), twoOctet: new RegExp(`^${e}\\.${e}$`, "i"), longValue: new RegExp(`^${e}$`, "i") }, n = new RegExp("^0[0-7]+$", "i"), i2 = new RegExp("^0x[a-f0-9]+$", "i"), o = "%[0-9a-z]{1,}", s = "(?:[0-9a-f]+::?)+", a = { zoneIndex: new RegExp(o, "i"), native: new RegExp(`^(::)?(${s})?([0-9a-f]+)?(::)?(${o})?$`, "i"), deprecatedTransitional: new RegExp(`^(?:::)(${e}\\.${e}\\.${e}\\.${e}(${o})?)$`, "i"), transitional: new RegExp(`^((?:${s})|(?:::)(?:${s})?)${e}\\.${e}\\.${e}\\.${e}(${o})?$`, "i") };
            function u(d, m) {
              if (d.indexOf("::") !== d.lastIndexOf("::"))
                return null;
              let y = 0, g = -1, E = (d.match(a.zoneIndex) || [])[0], b, v;
              for (E && (E = E.substring(1), d = d.replace(/%.+$/, "")); (g = d.indexOf(":", g + 1)) >= 0; )
                y++;
              if (d.substr(0, 2) === "::" && y--, d.substr(-2, 2) === "::" && y--, y > m)
                return null;
              for (v = m - y, b = ":"; v--; )
                b += "0:";
              return d = d.replace("::", b), d[0] === ":" && (d = d.slice(1)), d[d.length - 1] === ":" && (d = d.slice(0, -1)), m = function() {
                let S = d.split(":"), x = [];
                for (let T = 0; T < S.length; T++)
                  x.push(parseInt(S[T], 16));
                return x;
              }(), { parts: m, zoneId: E };
            }
            function l(d, m, y, g) {
              if (d.length !== m.length)
                throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
              let E = 0, b;
              for (; g > 0; ) {
                if (b = y - g, b < 0 && (b = 0), d[E] >> b !== m[E] >> b)
                  return false;
                g -= y, E += 1;
              }
              return true;
            }
            function f(d) {
              if (i2.test(d))
                return parseInt(d, 16);
              if (d[0] === "0" && !isNaN(parseInt(d[1], 10))) {
                if (n.test(d))
                  return parseInt(d, 8);
                throw new Error(`ipaddr: cannot parse ${d} as octal`);
              }
              return parseInt(d, 10);
            }
            function h(d, m) {
              for (; d.length < m; )
                d = `0${d}`;
              return d;
            }
            let p = {};
            p.IPv4 = function() {
              function d(m) {
                if (m.length !== 4)
                  throw new Error("ipaddr: ipv4 octet count should be 4");
                let y, g;
                for (y = 0; y < m.length; y++)
                  if (g = m[y], !(0 <= g && g <= 255))
                    throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
                this.octets = m;
              }
              return d.prototype.SpecialRanges = { unspecified: [[new d([0, 0, 0, 0]), 8]], broadcast: [[new d([255, 255, 255, 255]), 32]], multicast: [[new d([224, 0, 0, 0]), 4]], linkLocal: [[new d([169, 254, 0, 0]), 16]], loopback: [[new d([127, 0, 0, 0]), 8]], carrierGradeNat: [[new d([100, 64, 0, 0]), 10]], private: [[new d([10, 0, 0, 0]), 8], [new d([172, 16, 0, 0]), 12], [new d([192, 168, 0, 0]), 16]], reserved: [[new d([192, 0, 0, 0]), 24], [new d([192, 0, 2, 0]), 24], [new d([192, 88, 99, 0]), 24], [new d([198, 51, 100, 0]), 24], [new d([203, 0, 113, 0]), 24], [new d([240, 0, 0, 0]), 4]] }, d.prototype.kind = function() {
                return "ipv4";
              }, d.prototype.match = function(m, y) {
                let g;
                if (y === void 0 && (g = m, m = g[0], y = g[1]), m.kind() !== "ipv4")
                  throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
                return l(this.octets, m.octets, 8, y);
              }, d.prototype.prefixLengthFromSubnetMask = function() {
                let m = 0, y = false, g = { 0: 8, 128: 7, 192: 6, 224: 5, 240: 4, 248: 3, 252: 2, 254: 1, 255: 0 }, E, b, v;
                for (E = 3; E >= 0; E -= 1)
                  if (b = this.octets[E], b in g) {
                    if (v = g[b], y && v !== 0)
                      return null;
                    v !== 8 && (y = true), m += v;
                  } else
                    return null;
                return 32 - m;
              }, d.prototype.range = function() {
                return p.subnetMatch(this, this.SpecialRanges);
              }, d.prototype.toByteArray = function() {
                return this.octets.slice(0);
              }, d.prototype.toIPv4MappedAddress = function() {
                return p.IPv6.parse(`::ffff:${this.toString()}`);
              }, d.prototype.toNormalizedString = function() {
                return this.toString();
              }, d.prototype.toString = function() {
                return this.octets.join(".");
              }, d;
            }(), p.IPv4.broadcastAddressFromCIDR = function(d) {
              try {
                let m = this.parseCIDR(d), y = m[0].toByteArray(), g = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), E = [], b = 0;
                for (; b < 4; )
                  E.push(parseInt(y[b], 10) | parseInt(g[b], 10) ^ 255), b++;
                return new this(E);
              } catch {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
              }
            }, p.IPv4.isIPv4 = function(d) {
              return this.parser(d) !== null;
            }, p.IPv4.isValid = function(d) {
              try {
                return new this(this.parser(d)), true;
              } catch {
                return false;
              }
            }, p.IPv4.isValidFourPartDecimal = function(d) {
              return !!(p.IPv4.isValid(d) && d.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/));
            }, p.IPv4.networkAddressFromCIDR = function(d) {
              let m, y, g, E, b;
              try {
                for (m = this.parseCIDR(d), g = m[0].toByteArray(), b = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), E = [], y = 0; y < 4; )
                  E.push(parseInt(g[y], 10) & parseInt(b[y], 10)), y++;
                return new this(E);
              } catch {
                throw new Error("ipaddr: the address does not have IPv4 CIDR format");
              }
            }, p.IPv4.parse = function(d) {
              let m = this.parser(d);
              if (m === null)
                throw new Error("ipaddr: string is not formatted like an IPv4 Address");
              return new this(m);
            }, p.IPv4.parseCIDR = function(d) {
              let m;
              if (m = d.match(/^(.+)\/(\d+)$/)) {
                let y = parseInt(m[2]);
                if (y >= 0 && y <= 32) {
                  let g = [this.parse(m[1]), y];
                  return Object.defineProperty(g, "toString", { value: function() {
                    return this.join("/");
                  } }), g;
                }
              }
              throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
            }, p.IPv4.parser = function(d) {
              let m, y, g;
              if (m = d.match(r.fourOctet))
                return function() {
                  let E = m.slice(1, 6), b = [];
                  for (let v = 0; v < E.length; v++)
                    y = E[v], b.push(f(y));
                  return b;
                }();
              if (m = d.match(r.longValue)) {
                if (g = f(m[1]), g > 4294967295 || g < 0)
                  throw new Error("ipaddr: address outside defined range");
                return function() {
                  let E = [], b;
                  for (b = 0; b <= 24; b += 8)
                    E.push(g >> b & 255);
                  return E;
                }().reverse();
              } else
                return (m = d.match(r.twoOctet)) ? function() {
                  let E = m.slice(1, 4), b = [];
                  if (g = f(E[1]), g > 16777215 || g < 0)
                    throw new Error("ipaddr: address outside defined range");
                  return b.push(f(E[0])), b.push(g >> 16 & 255), b.push(g >> 8 & 255), b.push(g & 255), b;
                }() : (m = d.match(r.threeOctet)) ? function() {
                  let E = m.slice(1, 5), b = [];
                  if (g = f(E[2]), g > 65535 || g < 0)
                    throw new Error("ipaddr: address outside defined range");
                  return b.push(f(E[0])), b.push(f(E[1])), b.push(g >> 8 & 255), b.push(g & 255), b;
                }() : null;
            }, p.IPv4.subnetMaskFromPrefixLength = function(d) {
              if (d = parseInt(d), d < 0 || d > 32)
                throw new Error("ipaddr: invalid IPv4 prefix length");
              let m = [0, 0, 0, 0], y = 0, g = Math.floor(d / 8);
              for (; y < g; )
                m[y] = 255, y++;
              return g < 4 && (m[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(m);
            }, p.IPv6 = function() {
              function d(m, y) {
                let g, E;
                if (m.length === 16)
                  for (this.parts = [], g = 0; g <= 14; g += 2)
                    this.parts.push(m[g] << 8 | m[g + 1]);
                else if (m.length === 8)
                  this.parts = m;
                else
                  throw new Error("ipaddr: ipv6 part count should be 8 or 16");
                for (g = 0; g < this.parts.length; g++)
                  if (E = this.parts[g], !(0 <= E && E <= 65535))
                    throw new Error("ipaddr: ipv6 part should fit in 16 bits");
                y && (this.zoneId = y);
              }
              return d.prototype.SpecialRanges = { unspecified: [new d([0, 0, 0, 0, 0, 0, 0, 0]), 128], linkLocal: [new d([65152, 0, 0, 0, 0, 0, 0, 0]), 10], multicast: [new d([65280, 0, 0, 0, 0, 0, 0, 0]), 8], loopback: [new d([0, 0, 0, 0, 0, 0, 0, 1]), 128], uniqueLocal: [new d([64512, 0, 0, 0, 0, 0, 0, 0]), 7], ipv4Mapped: [new d([0, 0, 0, 0, 0, 65535, 0, 0]), 96], rfc6145: [new d([0, 0, 0, 0, 65535, 0, 0, 0]), 96], rfc6052: [new d([100, 65435, 0, 0, 0, 0, 0, 0]), 96], "6to4": [new d([8194, 0, 0, 0, 0, 0, 0, 0]), 16], teredo: [new d([8193, 0, 0, 0, 0, 0, 0, 0]), 32], reserved: [[new d([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]] }, d.prototype.isIPv4MappedAddress = function() {
                return this.range() === "ipv4Mapped";
              }, d.prototype.kind = function() {
                return "ipv6";
              }, d.prototype.match = function(m, y) {
                let g;
                if (y === void 0 && (g = m, m = g[0], y = g[1]), m.kind() !== "ipv6")
                  throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
                return l(this.parts, m.parts, 16, y);
              }, d.prototype.prefixLengthFromSubnetMask = function() {
                let m = 0, y = false, g = { 0: 16, 32768: 15, 49152: 14, 57344: 13, 61440: 12, 63488: 11, 64512: 10, 65024: 9, 65280: 8, 65408: 7, 65472: 6, 65504: 5, 65520: 4, 65528: 3, 65532: 2, 65534: 1, 65535: 0 }, E, b;
                for (let v = 7; v >= 0; v -= 1)
                  if (E = this.parts[v], E in g) {
                    if (b = g[E], y && b !== 0)
                      return null;
                    b !== 16 && (y = true), m += b;
                  } else
                    return null;
                return 128 - m;
              }, d.prototype.range = function() {
                return p.subnetMatch(this, this.SpecialRanges);
              }, d.prototype.toByteArray = function() {
                let m, y = [], g = this.parts;
                for (let E = 0; E < g.length; E++)
                  m = g[E], y.push(m >> 8), y.push(m & 255);
                return y;
              }, d.prototype.toFixedLengthString = function() {
                let m = function() {
                  let g = [];
                  for (let E = 0; E < this.parts.length; E++)
                    g.push(h(this.parts[E].toString(16), 4));
                  return g;
                }.call(this).join(":"), y = "";
                return this.zoneId && (y = `%${this.zoneId}`), m + y;
              }, d.prototype.toIPv4Address = function() {
                if (!this.isIPv4MappedAddress())
                  throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
                let m = this.parts.slice(-2), y = m[0], g = m[1];
                return new p.IPv4([y >> 8, y & 255, g >> 8, g & 255]);
              }, d.prototype.toNormalizedString = function() {
                let m = function() {
                  let g = [];
                  for (let E = 0; E < this.parts.length; E++)
                    g.push(this.parts[E].toString(16));
                  return g;
                }.call(this).join(":"), y = "";
                return this.zoneId && (y = `%${this.zoneId}`), m + y;
              }, d.prototype.toRFC5952String = function() {
                let m = /((^|:)(0(:|$)){2,})/g, y = this.toNormalizedString(), g = 0, E = -1, b;
                for (; b = m.exec(y); )
                  b[0].length > E && (g = b.index, E = b[0].length);
                return E < 0 ? y : `${y.substring(0, g)}::${y.substring(g + E)}`;
              }, d.prototype.toString = function() {
                return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
              }, d;
            }(), p.IPv6.broadcastAddressFromCIDR = function(d) {
              try {
                let m = this.parseCIDR(d), y = m[0].toByteArray(), g = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), E = [], b = 0;
                for (; b < 16; )
                  E.push(parseInt(y[b], 10) | parseInt(g[b], 10) ^ 255), b++;
                return new this(E);
              } catch (m) {
                throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${m})`);
              }
            }, p.IPv6.isIPv6 = function(d) {
              return this.parser(d) !== null;
            }, p.IPv6.isValid = function(d) {
              if (typeof d == "string" && d.indexOf(":") === -1)
                return false;
              try {
                let m = this.parser(d);
                return new this(m.parts, m.zoneId), true;
              } catch {
                return false;
              }
            }, p.IPv6.networkAddressFromCIDR = function(d) {
              let m, y, g, E, b;
              try {
                for (m = this.parseCIDR(d), g = m[0].toByteArray(), b = this.subnetMaskFromPrefixLength(m[1]).toByteArray(), E = [], y = 0; y < 16; )
                  E.push(parseInt(g[y], 10) & parseInt(b[y], 10)), y++;
                return new this(E);
              } catch (v) {
                throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${v})`);
              }
            }, p.IPv6.parse = function(d) {
              let m = this.parser(d);
              if (m.parts === null)
                throw new Error("ipaddr: string is not formatted like an IPv6 Address");
              return new this(m.parts, m.zoneId);
            }, p.IPv6.parseCIDR = function(d) {
              let m, y, g;
              if ((y = d.match(/^(.+)\/(\d+)$/)) && (m = parseInt(y[2]), m >= 0 && m <= 128))
                return g = [this.parse(y[1]), m], Object.defineProperty(g, "toString", { value: function() {
                  return this.join("/");
                } }), g;
              throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
            }, p.IPv6.parser = function(d) {
              let m, y, g, E, b, v;
              if (g = d.match(a.deprecatedTransitional))
                return this.parser(`::ffff:${g[1]}`);
              if (a.native.test(d))
                return u(d, 8);
              if ((g = d.match(a.transitional)) && (v = g[6] || "", m = u(g[1].slice(0, -1) + v, 6), m.parts)) {
                for (b = [parseInt(g[2]), parseInt(g[3]), parseInt(g[4]), parseInt(g[5])], y = 0; y < b.length; y++)
                  if (E = b[y], !(0 <= E && E <= 255))
                    return null;
                return m.parts.push(b[0] << 8 | b[1]), m.parts.push(b[2] << 8 | b[3]), { parts: m.parts, zoneId: m.zoneId };
              }
              return null;
            }, p.IPv6.subnetMaskFromPrefixLength = function(d) {
              if (d = parseInt(d), d < 0 || d > 128)
                throw new Error("ipaddr: invalid IPv6 prefix length");
              let m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], y = 0, g = Math.floor(d / 8);
              for (; y < g; )
                m[y] = 255, y++;
              return g < 16 && (m[g] = Math.pow(2, d % 8) - 1 << 8 - d % 8), new this(m);
            }, p.fromByteArray = function(d) {
              let m = d.length;
              if (m === 4)
                return new p.IPv4(d);
              if (m === 16)
                return new p.IPv6(d);
              throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
            }, p.isValid = function(d) {
              return p.IPv6.isValid(d) || p.IPv4.isValid(d);
            }, p.parse = function(d) {
              if (p.IPv6.isValid(d))
                return p.IPv6.parse(d);
              if (p.IPv4.isValid(d))
                return p.IPv4.parse(d);
              throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
            }, p.parseCIDR = function(d) {
              try {
                return p.IPv6.parseCIDR(d);
              } catch {
                try {
                  return p.IPv4.parseCIDR(d);
                } catch {
                  throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
                }
              }
            }, p.process = function(d) {
              let m = this.parse(d);
              return m.kind() === "ipv6" && m.isIPv4MappedAddress() ? m.toIPv4Address() : m;
            }, p.subnetMatch = function(d, m, y) {
              let g, E, b, v;
              y == null && (y = "unicast");
              for (E in m)
                if (Object.prototype.hasOwnProperty.call(m, E)) {
                  for (b = m[E], b[0] && !(b[0] instanceof Array) && (b = [b]), g = 0; g < b.length; g++)
                    if (v = b[g], d.kind() === v[0].kind() && d.match.apply(d, v))
                      return E;
                }
              return y;
            }, typeof Zb < "u" && Zb.exports ? Zb.exports = p : t.ipaddr = p;
          })(eae);
        });
        var oae = A((y3) => {
          "use strict";
          c();
          var iae = y3 && y3.__importDefault || function(t) {
            return t && t.__esModule ? t : { default: t };
          };
          Object.defineProperty(y3, "__esModule", { value: true });
          var XPe = Yse(), ZPe = iae(VP()), JPe = iae(Jse()), rae = tae(), eDe = ["0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.0.0/29", "192.0.0.8/32", "192.0.0.9/32", "192.0.0.10/32", "192.0.0.170/32", "192.0.0.171/32", "192.0.2.0/24", "192.31.196.0/24", "192.52.193.0/24", "192.88.99.0/24", "192.168.0.0/16", "192.175.48.0/24", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "240.0.0.0/4", "255.255.255.255/32"], tDe = eDe.map((t) => new XPe.Netmask(t));
          function rDe(t) {
            for (let e of tDe)
              if (e.contains(t))
                return true;
            return false;
          }
          function nae(t) {
            return /^::$/.test(t) || /^::1$/.test(t) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(t) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(t) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(t) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(t) || /^ff([0-9a-fA-F]{2,2}):/i.test(t);
          }
          y3.default = (t) => {
            if (rae.isValid(t)) {
              let e = rae.parse(t);
              if (e.kind() === "ipv4")
                return rDe(e.toNormalizedString());
              if (e.kind() === "ipv6")
                return nae(t);
            } else if (JPe.default(t) && ZPe.default.v6().test(t))
              return nae(t);
          };
        });
        var Jb = A((T_t, sae) => {
          "use strict";
          c();
          sae.exports = oae().default;
        });
        var Bae = A((E7t, Lae) => {
          "use strict";
          c();
          function mDe(t) {
            return t >= 55296 && t <= 56319;
          }
          function yDe(t) {
            return t >= 56320 && t <= 57343;
          }
          Lae.exports = function(e, r, n) {
            if (typeof r != "string")
              throw new Error("Input must be string");
            for (var i2 = r.length, o = 0, s, a, u = 0; u < i2; u += 1) {
              if (s = r.charCodeAt(u), a = r[u], mDe(s) && yDe(r.charCodeAt(u + 1)) && (u += 1, a += r[u]), o += e(a), o === n)
                return r.slice(0, u + 1);
              if (o > n)
                return r.slice(0, u - a.length + 1);
            }
            return r;
          };
        });
        var Uae = A((b7t, Mae) => {
          "use strict";
          c();
          function gDe(t) {
            return t >= 55296 && t <= 56319;
          }
          function wDe(t) {
            return t >= 56320 && t <= 57343;
          }
          Mae.exports = function(e) {
            if (typeof e != "string")
              throw new Error("Input must be string");
            for (var r = e.length, n = 0, i2 = null, o = null, s = 0; s < r; s++)
              i2 = e.charCodeAt(s), wDe(i2) ? o != null && gDe(o) ? n += 1 : n += 3 : i2 <= 127 ? n += 1 : i2 >= 128 && i2 <= 2047 ? n += 2 : i2 >= 2048 && i2 <= 65535 && (n += 3), o = i2;
            return n;
          };
        });
        var Kae = A((_7t, Fae) => {
          "use strict";
          c();
          var EDe = Bae(), bDe = Uae();
          Fae.exports = EDe.bind(null, bDe);
        });
        var zae = A((v7t, qae) => {
          "use strict";
          c();
          var _De = Kae(), vDe = /[\/\?<>\\:\*\|"]/g, SDe = /[\x00-\x1f\x80-\x9f]/g, xDe = /^\.+$/, RDe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i, ADe = /[\. ]+$/;
          function Vae(t, e) {
            if (typeof t != "string")
              throw new Error("Input must be string");
            var r = t.replace(vDe, e).replace(SDe, e).replace(xDe, e).replace(RDe, e).replace(ADe, e);
            return _De(r, 255);
          }
          qae.exports = function(t, e) {
            var r = e && e.replacement || "", n = Vae(t, r);
            return r === "" ? n : Vae(n, "");
          };
        });
        var Wae = A((S7t, Gae) => {
          c();
          var Y1 = st();
          Aa();
          gr();
          var he = Y1.asn1, Q1 = Gae.exports = Y1.pkcs7asn1 = Y1.pkcs7asn1 || {};
          Y1.pkcs7 = Y1.pkcs7 || {};
          Y1.pkcs7.asn1 = Q1;
          var Hae = { name: "ContentInfo", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "ContentInfo.ContentType", tagClass: he.Class.UNIVERSAL, type: he.Type.OID, constructed: false, capture: "contentType" }, { name: "ContentInfo.content", tagClass: he.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, captureAsn1: "content" }] };
          Q1.contentInfoValidator = Hae;
          var $ae = { name: "EncryptedContentInfo", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentType", tagClass: he.Class.UNIVERSAL, type: he.Type.OID, constructed: false, capture: "contentType" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter", tagClass: he.Class.UNIVERSAL, captureAsn1: "encParameter" }] }, { name: "EncryptedContentInfo.encryptedContent", tagClass: he.Class.CONTEXT_SPECIFIC, type: 0, capture: "encryptedContent", captureAsn1: "encryptedContentAsn1" }] };
          Q1.envelopedDataValidator = { name: "EnvelopedData", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "EnvelopedData.Version", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "version" }, { name: "EnvelopedData.RecipientInfos", tagClass: he.Class.UNIVERSAL, type: he.Type.SET, constructed: true, captureAsn1: "recipientInfos" }].concat($ae) };
          Q1.encryptedDataValidator = { name: "EncryptedData", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "EncryptedData.Version", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "version" }].concat($ae) };
          var TDe = { name: "SignerInfo", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.version", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false }, { name: "SignerInfo.issuerAndSerialNumber", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.issuerAndSerialNumber.issuer", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "SignerInfo.issuerAndSerialNumber.serialNumber", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "SignerInfo.digestAlgorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "SignerInfo.digestAlgorithm.algorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.OID, constructed: false, capture: "digestAlgorithm" }, { name: "SignerInfo.digestAlgorithm.parameter", tagClass: he.Class.UNIVERSAL, constructed: false, captureAsn1: "digestParameter", optional: true }] }, { name: "SignerInfo.authenticatedAttributes", tagClass: he.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "authenticatedAttributes" }, { name: "SignerInfo.digestEncryptionAlgorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, capture: "signatureAlgorithm" }, { name: "SignerInfo.encryptedDigest", tagClass: he.Class.UNIVERSAL, type: he.Type.OCTETSTRING, constructed: false, capture: "signature" }, { name: "SignerInfo.unauthenticatedAttributes", tagClass: he.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, capture: "unauthenticatedAttributes" }] };
          Q1.signedDataValidator = { name: "SignedData", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "SignedData.Version", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "version" }, { name: "SignedData.DigestAlgorithms", tagClass: he.Class.UNIVERSAL, type: he.Type.SET, constructed: true, captureAsn1: "digestAlgorithms" }, Hae, { name: "SignedData.Certificates", tagClass: he.Class.CONTEXT_SPECIFIC, type: 0, optional: true, captureAsn1: "certificates" }, { name: "SignedData.CertificateRevocationLists", tagClass: he.Class.CONTEXT_SPECIFIC, type: 1, optional: true, captureAsn1: "crls" }, { name: "SignedData.SignerInfos", tagClass: he.Class.UNIVERSAL, type: he.Type.SET, capture: "signerInfos", optional: true, value: [TDe] }] };
          Q1.recipientInfoValidator = { name: "RecipientInfo", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.version", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "version" }, { name: "RecipientInfo.issuerAndSerial", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.issuerAndSerial.issuer", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, captureAsn1: "issuer" }, { name: "RecipientInfo.issuerAndSerial.serialNumber", tagClass: he.Class.UNIVERSAL, type: he.Type.INTEGER, constructed: false, capture: "serial" }] }, { name: "RecipientInfo.keyEncryptionAlgorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.SEQUENCE, constructed: true, value: [{ name: "RecipientInfo.keyEncryptionAlgorithm.algorithm", tagClass: he.Class.UNIVERSAL, type: he.Type.OID, constructed: false, capture: "encAlgorithm" }, { name: "RecipientInfo.keyEncryptionAlgorithm.parameter", tagClass: he.Class.UNIVERSAL, constructed: false, captureAsn1: "encParameter", optional: true }] }, { name: "RecipientInfo.encryptedKey", tagClass: he.Class.UNIVERSAL, type: he.Type.OCTETSTRING, constructed: false, capture: "encKey" }] };
        });
        var Yae = A((x7t, jae) => {
          c();
          var Id = st();
          gr();
          Id.mgf = Id.mgf || {};
          var IDe = jae.exports = Id.mgf.mgf1 = Id.mgf1 = Id.mgf1 || {};
          IDe.create = function(t) {
            var e = { generate: function(r, n) {
              for (var i2 = new Id.util.ByteBuffer(), o = Math.ceil(n / t.digestLength), s = 0; s < o; s++) {
                var a = new Id.util.ByteBuffer();
                a.putInt32(s), t.start(), t.update(r + a.getBytes()), i2.putBuffer(t.digest());
              }
              return i2.truncate(i2.length() - n), i2.getBytes();
            } };
            return e;
          };
        });
        var Xae = A((R7t, Qae) => {
          c();
          var l_ = st();
          Yae();
          Qae.exports = l_.mgf = l_.mgf || {};
          l_.mgf.mgf1 = l_.mgf1;
        });
        var Jae = A((A7t, Zae) => {
          c();
          var Cd = st();
          nh();
          gr();
          var CDe = Zae.exports = Cd.pss = Cd.pss || {};
          CDe.create = function(t) {
            arguments.length === 3 && (t = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] });
            var e = t.md, r = t.mgf, n = e.digestLength, i2 = t.salt || null;
            typeof i2 == "string" && (i2 = Cd.util.createBuffer(i2));
            var o;
            if ("saltLength" in t)
              o = t.saltLength;
            else if (i2 !== null)
              o = i2.length();
            else
              throw new Error("Salt length not specified or specific salt not given.");
            if (i2 !== null && i2.length() !== o)
              throw new Error("Given salt length does not match length of given salt.");
            var s = t.prng || Cd.random, a = {};
            return a.encode = function(u, l) {
              var f, h = l - 1, p = Math.ceil(h / 8), d = u.digest().getBytes();
              if (p < n + o + 2)
                throw new Error("Message is too long to encrypt.");
              var m;
              i2 === null ? m = s.getBytesSync(o) : m = i2.bytes();
              var y = new Cd.util.ByteBuffer();
              y.fillWithByte(0, 8), y.putBytes(d), y.putBytes(m), e.start(), e.update(y.getBytes());
              var g = e.digest().getBytes(), E = new Cd.util.ByteBuffer();
              E.fillWithByte(0, p - o - n - 2), E.putByte(1), E.putBytes(m);
              var b = E.getBytes(), v = p - n - 1, S = r.generate(g, v), x = "";
              for (f = 0; f < v; f++)
                x += String.fromCharCode(b.charCodeAt(f) ^ S.charCodeAt(f));
              var T = 65280 >> 8 * p - h & 255;
              return x = String.fromCharCode(x.charCodeAt(0) & ~T) + x.substr(1), x + g + String.fromCharCode(188);
            }, a.verify = function(u, l, f) {
              var h, p = f - 1, d = Math.ceil(p / 8);
              if (l = l.substr(-d), d < n + o + 2)
                throw new Error("Inconsistent parameters to PSS signature verification.");
              if (l.charCodeAt(d - 1) !== 188)
                throw new Error("Encoded message does not end in 0xBC.");
              var m = d - n - 1, y = l.substr(0, m), g = l.substr(m, n), E = 65280 >> 8 * d - p & 255;
              if ((y.charCodeAt(0) & E) !== 0)
                throw new Error("Bits beyond keysize not zero as expected.");
              var b = r.generate(g, m), v = "";
              for (h = 0; h < m; h++)
                v += String.fromCharCode(y.charCodeAt(h) ^ b.charCodeAt(h));
              v = String.fromCharCode(v.charCodeAt(0) & ~E) + v.substr(1);
              var S = d - n - o - 2;
              for (h = 0; h < S; h++)
                if (v.charCodeAt(h) !== 0)
                  throw new Error("Leftmost octets not zero as expected");
              if (v.charCodeAt(S) !== 1)
                throw new Error("Inconsistent PSS signature, 0x01 marker not found");
              var x = v.substr(-o), T = new Cd.util.ByteBuffer();
              T.fillWithByte(0, 8), T.putBytes(u), T.putBytes(x), e.start(), e.update(T.getBytes());
              var R = e.digest().getBytes();
              return g === R;
            }, a;
          };
        });
        var tD = A((T7t, ice) => {
          c();
          var Le = st();
          jp();
          Aa();
          jw();
          sl();
          Xae();
          $p();
          Zw();
          Jae();
          sh();
          gr();
          var _ = Le.asn1, ne = ice.exports = Le.pki = Le.pki || {}, Lt = ne.oids, Zr = {};
          Zr.CN = Lt.commonName;
          Zr.commonName = "CN";
          Zr.C = Lt.countryName;
          Zr.countryName = "C";
          Zr.L = Lt.localityName;
          Zr.localityName = "L";
          Zr.ST = Lt.stateOrProvinceName;
          Zr.stateOrProvinceName = "ST";
          Zr.O = Lt.organizationName;
          Zr.organizationName = "O";
          Zr.OU = Lt.organizationalUnitName;
          Zr.organizationalUnitName = "OU";
          Zr.E = Lt.emailAddress;
          Zr.emailAddress = "E";
          var tce = Le.pki.rsa.publicKeyValidator, PDe = { name: "Certificate", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "tbsCertificate", value: [{ name: "Certificate.TBSCertificate.version", tagClass: _.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.version.integer", tagClass: _.Class.UNIVERSAL, type: _.Type.INTEGER, constructed: false, capture: "certVersion" }] }, { name: "Certificate.TBSCertificate.serialNumber", tagClass: _.Class.UNIVERSAL, type: _.Type.INTEGER, constructed: false, capture: "certSerialNumber" }, { name: "Certificate.TBSCertificate.signature", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.signature.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "certinfoSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: _.Class.UNIVERSAL, optional: true, captureAsn1: "certinfoSignatureParams" }] }, { name: "Certificate.TBSCertificate.issuer", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "certIssuer" }, { name: "Certificate.TBSCertificate.validity", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.TBSCertificate.validity.notBefore (utc)", tagClass: _.Class.UNIVERSAL, type: _.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity1UTCTime" }, { name: "Certificate.TBSCertificate.validity.notBefore (generalized)", tagClass: _.Class.UNIVERSAL, type: _.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity2GeneralizedTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (utc)", tagClass: _.Class.UNIVERSAL, type: _.Type.UTCTIME, constructed: false, optional: true, capture: "certValidity3UTCTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (generalized)", tagClass: _.Class.UNIVERSAL, type: _.Type.GENERALIZEDTIME, constructed: false, optional: true, capture: "certValidity4GeneralizedTime" }] }, { name: "Certificate.TBSCertificate.subject", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "certSubject" }, tce, { name: "Certificate.TBSCertificate.issuerUniqueID", tagClass: _.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.issuerUniqueID.id", tagClass: _.Class.UNIVERSAL, type: _.Type.BITSTRING, constructed: false, captureBitStringValue: "certIssuerUniqueId" }] }, { name: "Certificate.TBSCertificate.subjectUniqueID", tagClass: _.Class.CONTEXT_SPECIFIC, type: 2, constructed: true, optional: true, value: [{ name: "Certificate.TBSCertificate.subjectUniqueID.id", tagClass: _.Class.UNIVERSAL, type: _.Type.BITSTRING, constructed: false, captureBitStringValue: "certSubjectUniqueId" }] }, { name: "Certificate.TBSCertificate.extensions", tagClass: _.Class.CONTEXT_SPECIFIC, type: 3, constructed: true, captureAsn1: "certExtensions", optional: true }] }, { name: "Certificate.signatureAlgorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "Certificate.signatureAlgorithm.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "certSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: _.Class.UNIVERSAL, optional: true, captureAsn1: "certSignatureParams" }] }, { name: "Certificate.signatureValue", tagClass: _.Class.UNIVERSAL, type: _.Type.BITSTRING, constructed: false, captureBitStringValue: "certSignature" }] }, DDe = { name: "rsapss", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.hashAlgorithm", tagClass: _.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier", tagClass: _.Class.UNIVERSAL, type: _.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "hashOid" }] }] }, { name: "rsapss.maskGenAlgorithm", tagClass: _.Class.CONTEXT_SPECIFIC, type: 1, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier", tagClass: _.Class.UNIVERSAL, type: _.Class.SEQUENCE, constructed: true, optional: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "maskGenOid" }, { name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "maskGenHashOid" }] }] }] }, { name: "rsapss.saltLength", tagClass: _.Class.CONTEXT_SPECIFIC, type: 2, optional: true, value: [{ name: "rsapss.saltLength.saltLength", tagClass: _.Class.UNIVERSAL, type: _.Class.INTEGER, constructed: false, capture: "saltLength" }] }, { name: "rsapss.trailerField", tagClass: _.Class.CONTEXT_SPECIFIC, type: 3, optional: true, value: [{ name: "rsapss.trailer.trailer", tagClass: _.Class.UNIVERSAL, type: _.Class.INTEGER, constructed: false, capture: "trailer" }] }] }, kDe = { name: "CertificationRequestInfo", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfo", value: [{ name: "CertificationRequestInfo.integer", tagClass: _.Class.UNIVERSAL, type: _.Type.INTEGER, constructed: false, capture: "certificationRequestInfoVersion" }, { name: "CertificationRequestInfo.subject", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "certificationRequestInfoSubject" }, tce, { name: "CertificationRequestInfo.attributes", tagClass: _.Class.CONTEXT_SPECIFIC, type: 0, constructed: true, optional: true, capture: "certificationRequestInfoAttributes", value: [{ name: "CertificationRequestInfo.attributes", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequestInfo.attributes.type", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false }, { name: "CertificationRequestInfo.attributes.value", tagClass: _.Class.UNIVERSAL, type: _.Type.SET, constructed: true }] }] }] }, NDe = { name: "CertificationRequest", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, captureAsn1: "csr", value: [kDe, { name: "CertificationRequest.signatureAlgorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.SEQUENCE, constructed: true, value: [{ name: "CertificationRequest.signatureAlgorithm.algorithm", tagClass: _.Class.UNIVERSAL, type: _.Type.OID, constructed: false, capture: "csrSignatureOid" }, { name: "CertificationRequest.signatureAlgorithm.parameters", tagClass: _.Class.UNIVERSAL, optional: true, captureAsn1: "csrSignatureParams" }] }, { name: "CertificationRequest.signature", tagClass: _.Class.UNIVERSAL, type: _.Type.BITSTRING, constructed: false, captureBitStringValue: "csrSignature" }] };
          ne.RDNAttributesAsArray = function(t, e) {
            for (var r = [], n, i2, o, s = 0; s < t.value.length; ++s) {
              n = t.value[s];
              for (var a = 0; a < n.value.length; ++a)
                o = {}, i2 = n.value[a], o.type = _.derToOid(i2.value[0].value), o.value = i2.value[1].value, o.valueTagClass = i2.value[1].type, o.type in Lt && (o.name = Lt[o.type], o.name in Zr && (o.shortName = Zr[o.name])), e && (e.update(o.type), e.update(o.value)), r.push(o);
            }
            return r;
          };
          ne.CRIAttributesAsArray = function(t) {
            for (var e = [], r = 0; r < t.length; ++r)
              for (var n = t[r], i2 = _.derToOid(n.value[0].value), o = n.value[1].value, s = 0; s < o.length; ++s) {
                var a = {};
                if (a.type = i2, a.value = o[s].value, a.valueTagClass = o[s].type, a.type in Lt && (a.name = Lt[a.type], a.name in Zr && (a.shortName = Zr[a.name])), a.type === Lt.extensionRequest) {
                  a.extensions = [];
                  for (var u = 0; u < a.value.length; ++u)
                    a.extensions.push(ne.certificateExtensionFromAsn1(a.value[u]));
                }
                e.push(a);
              }
            return e;
          };
          function pf(t, e) {
            typeof e == "string" && (e = { shortName: e });
            for (var r = null, n, i2 = 0; r === null && i2 < t.attributes.length; ++i2)
              n = t.attributes[i2], (e.type && e.type === n.type || e.name && e.name === n.name || e.shortName && e.shortName === n.shortName) && (r = n);
            return r;
          }
          var f_ = function(t, e, r) {
            var n = {};
            if (t !== Lt["RSASSA-PSS"])
              return n;
            r && (n = { hash: { algorithmOid: Lt.sha1 }, mgf: { algorithmOid: Lt.mgf1, hash: { algorithmOid: Lt.sha1 } }, saltLength: 20 });
            var i2 = {}, o = [];
            if (!_.validate(e, DDe, i2, o)) {
              var s = new Error("Cannot read RSASSA-PSS parameter block.");
              throw s.errors = o, s;
            }
            return i2.hashOid !== void 0 && (n.hash = n.hash || {}, n.hash.algorithmOid = _.derToOid(i2.hashOid)), i2.maskGenOid !== void 0 && (n.mgf = n.mgf || {}, n.mgf.algorithmOid = _.derToOid(i2.maskGenOid), n.mgf.hash = n.mgf.hash || {}, n.mgf.hash.algorithmOid = _.derToOid(i2.maskGenHashOid)), i2.saltLength !== void 0 && (n.saltLength = i2.saltLength.charCodeAt(0)), n;
          }, h_ = function(t) {
            switch (Lt[t.signatureOid]) {
              case "sha1WithRSAEncryption":
              case "sha1WithRSASignature":
                return Le.md.sha1.create();
              case "md5WithRSAEncryption":
                return Le.md.md5.create();
              case "sha256WithRSAEncryption":
                return Le.md.sha256.create();
              case "sha384WithRSAEncryption":
                return Le.md.sha384.create();
              case "sha512WithRSAEncryption":
                return Le.md.sha512.create();
              case "RSASSA-PSS":
                return Le.md.sha256.create();
              default:
                var e = new Error("Could not compute " + t.type + " digest. Unknown signature OID.");
                throw e.signatureOid = t.signatureOid, e;
            }
          }, rce = function(t) {
            var e = t.certificate, r;
            switch (e.signatureOid) {
              case Lt.sha1WithRSAEncryption:
              case Lt.sha1WithRSASignature:
                break;
              case Lt["RSASSA-PSS"]:
                var n, i2;
                if (n = Lt[e.signatureParameters.mgf.hash.algorithmOid], n === void 0 || Le.md[n] === void 0) {
                  var o = new Error("Unsupported MGF hash function.");
                  throw o.oid = e.signatureParameters.mgf.hash.algorithmOid, o.name = n, o;
                }
                if (i2 = Lt[e.signatureParameters.mgf.algorithmOid], i2 === void 0 || Le.mgf[i2] === void 0) {
                  var o = new Error("Unsupported MGF function.");
                  throw o.oid = e.signatureParameters.mgf.algorithmOid, o.name = i2, o;
                }
                if (i2 = Le.mgf[i2].create(Le.md[n].create()), n = Lt[e.signatureParameters.hash.algorithmOid], n === void 0 || Le.md[n] === void 0) {
                  var o = new Error("Unsupported RSASSA-PSS hash function.");
                  throw o.oid = e.signatureParameters.hash.algorithmOid, o.name = n, o;
                }
                r = Le.pss.create(Le.md[n].create(), i2, e.signatureParameters.saltLength);
                break;
            }
            return e.publicKey.verify(t.md.digest().getBytes(), t.signature, r);
          };
          ne.certificateFromPem = function(t, e, r) {
            var n = Le.pem.decode(t)[0];
            if (n.type !== "CERTIFICATE" && n.type !== "X509 CERTIFICATE" && n.type !== "TRUSTED CERTIFICATE") {
              var i2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              throw i2.headerType = n.type, i2;
            }
            if (n.procType && n.procType.type === "ENCRYPTED")
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            var o = _.fromDer(n.body, r);
            return ne.certificateFromAsn1(o, e);
          };
          ne.certificateToPem = function(t, e) {
            var r = { type: "CERTIFICATE", body: _.toDer(ne.certificateToAsn1(t)).getBytes() };
            return Le.pem.encode(r, { maxline: e });
          };
          ne.publicKeyFromPem = function(t) {
            var e = Le.pem.decode(t)[0];
            if (e.type !== "PUBLIC KEY" && e.type !== "RSA PUBLIC KEY") {
              var r = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
              throw r.headerType = e.type, r;
            }
            if (e.procType && e.procType.type === "ENCRYPTED")
              throw new Error("Could not convert public key from PEM; PEM is encrypted.");
            var n = _.fromDer(e.body);
            return ne.publicKeyFromAsn1(n);
          };
          ne.publicKeyToPem = function(t, e) {
            var r = { type: "PUBLIC KEY", body: _.toDer(ne.publicKeyToAsn1(t)).getBytes() };
            return Le.pem.encode(r, { maxline: e });
          };
          ne.publicKeyToRSAPublicKeyPem = function(t, e) {
            var r = { type: "RSA PUBLIC KEY", body: _.toDer(ne.publicKeyToRSAPublicKey(t)).getBytes() };
            return Le.pem.encode(r, { maxline: e });
          };
          ne.getPublicKeyFingerprint = function(t, e) {
            e = e || {};
            var r = e.md || Le.md.sha1.create(), n = e.type || "RSAPublicKey", i2;
            switch (n) {
              case "RSAPublicKey":
                i2 = _.toDer(ne.publicKeyToRSAPublicKey(t)).getBytes();
                break;
              case "SubjectPublicKeyInfo":
                i2 = _.toDer(ne.publicKeyToAsn1(t)).getBytes();
                break;
              default:
                throw new Error('Unknown fingerprint type "' + e.type + '".');
            }
            r.start(), r.update(i2);
            var o = r.digest();
            if (e.encoding === "hex") {
              var s = o.toHex();
              return e.delimiter ? s.match(/.{2}/g).join(e.delimiter) : s;
            } else {
              if (e.encoding === "binary")
                return o.getBytes();
              if (e.encoding)
                throw new Error('Unknown encoding "' + e.encoding + '".');
            }
            return o;
          };
          ne.certificationRequestFromPem = function(t, e, r) {
            var n = Le.pem.decode(t)[0];
            if (n.type !== "CERTIFICATE REQUEST") {
              var i2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
              throw i2.headerType = n.type, i2;
            }
            if (n.procType && n.procType.type === "ENCRYPTED")
              throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
            var o = _.fromDer(n.body, r);
            return ne.certificationRequestFromAsn1(o, e);
          };
          ne.certificationRequestToPem = function(t, e) {
            var r = { type: "CERTIFICATE REQUEST", body: _.toDer(ne.certificationRequestToAsn1(t)).getBytes() };
            return Le.pem.encode(r, { maxline: e });
          };
          ne.createCertificate = function() {
            var t = {};
            return t.version = 2, t.serialNumber = "00", t.signatureOid = null, t.signature = null, t.siginfo = {}, t.siginfo.algorithmOid = null, t.validity = {}, t.validity.notBefore = new Date(), t.validity.notAfter = new Date(), t.issuer = {}, t.issuer.getField = function(e) {
              return pf(t.issuer, e);
            }, t.issuer.addField = function(e) {
              ms([e]), t.issuer.attributes.push(e);
            }, t.issuer.attributes = [], t.issuer.hash = null, t.subject = {}, t.subject.getField = function(e) {
              return pf(t.subject, e);
            }, t.subject.addField = function(e) {
              ms([e]), t.subject.attributes.push(e);
            }, t.subject.attributes = [], t.subject.hash = null, t.extensions = [], t.publicKey = null, t.md = null, t.setSubject = function(e, r) {
              ms(e), t.subject.attributes = e, delete t.subject.uniqueId, r && (t.subject.uniqueId = r), t.subject.hash = null;
            }, t.setIssuer = function(e, r) {
              ms(e), t.issuer.attributes = e, delete t.issuer.uniqueId, r && (t.issuer.uniqueId = r), t.issuer.hash = null;
            }, t.setExtensions = function(e) {
              for (var r = 0; r < e.length; ++r)
                nce(e[r], { cert: t });
              t.extensions = e;
            }, t.getExtension = function(e) {
              typeof e == "string" && (e = { name: e });
              for (var r = null, n, i2 = 0; r === null && i2 < t.extensions.length; ++i2)
                n = t.extensions[i2], (e.id && n.id === e.id || e.name && n.name === e.name) && (r = n);
              return r;
            }, t.sign = function(e, r) {
              t.md = r || Le.md.sha1.create();
              var n = Lt[t.md.algorithm + "WithRSAEncryption"];
              if (!n) {
                var i2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
                throw i2.algorithm = t.md.algorithm, i2;
              }
              t.signatureOid = t.siginfo.algorithmOid = n, t.tbsCertificate = ne.getTBSCertificate(t);
              var o = _.toDer(t.tbsCertificate);
              t.md.update(o.getBytes()), t.signature = e.sign(t.md);
            }, t.verify = function(e) {
              var r = false;
              if (!t.issued(e)) {
                var n = e.issuer, i2 = t.subject, o = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
                throw o.expectedIssuer = i2.attributes, o.actualIssuer = n.attributes, o;
              }
              var s = e.md;
              if (s === null) {
                s = h_({ signatureOid: e.signatureOid, type: "certificate" });
                var a = e.tbsCertificate || ne.getTBSCertificate(e), u = _.toDer(a);
                s.update(u.getBytes());
              }
              return s !== null && (r = rce({ certificate: t, md: s, signature: e.signature })), r;
            }, t.isIssuer = function(e) {
              var r = false, n = t.issuer, i2 = e.subject;
              if (n.hash && i2.hash)
                r = n.hash === i2.hash;
              else if (n.attributes.length === i2.attributes.length) {
                r = true;
                for (var o, s, a = 0; r && a < n.attributes.length; ++a)
                  o = n.attributes[a], s = i2.attributes[a], (o.type !== s.type || o.value !== s.value) && (r = false);
              }
              return r;
            }, t.issued = function(e) {
              return e.isIssuer(t);
            }, t.generateSubjectKeyIdentifier = function() {
              return ne.getPublicKeyFingerprint(t.publicKey, { type: "RSAPublicKey" });
            }, t.verifySubjectKeyIdentifier = function() {
              for (var e = Lt.subjectKeyIdentifier, r = 0; r < t.extensions.length; ++r) {
                var n = t.extensions[r];
                if (n.id === e) {
                  var i2 = t.generateSubjectKeyIdentifier().getBytes();
                  return Le.util.hexToBytes(n.subjectKeyIdentifier) === i2;
                }
              }
              return false;
            }, t;
          };
          ne.certificateFromAsn1 = function(t, e) {
            var r = {}, n = [];
            if (!_.validate(t, PDe, r, n)) {
              var i2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
              throw i2.errors = n, i2;
            }
            var o = _.derToOid(r.publicKeyOid);
            if (o !== ne.oids.rsaEncryption)
              throw new Error("Cannot read public key. OID is not RSA.");
            var s = ne.createCertificate();
            s.version = r.certVersion ? r.certVersion.charCodeAt(0) : 0;
            var a = Le.util.createBuffer(r.certSerialNumber);
            s.serialNumber = a.toHex(), s.signatureOid = Le.asn1.derToOid(r.certSignatureOid), s.signatureParameters = f_(s.signatureOid, r.certSignatureParams, true), s.siginfo.algorithmOid = Le.asn1.derToOid(r.certinfoSignatureOid), s.siginfo.parameters = f_(s.siginfo.algorithmOid, r.certinfoSignatureParams, false), s.signature = r.certSignature;
            var u = [];
            if (r.certValidity1UTCTime !== void 0 && u.push(_.utcTimeToDate(r.certValidity1UTCTime)), r.certValidity2GeneralizedTime !== void 0 && u.push(_.generalizedTimeToDate(r.certValidity2GeneralizedTime)), r.certValidity3UTCTime !== void 0 && u.push(_.utcTimeToDate(r.certValidity3UTCTime)), r.certValidity4GeneralizedTime !== void 0 && u.push(_.generalizedTimeToDate(r.certValidity4GeneralizedTime)), u.length > 2)
              throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
            if (u.length < 2)
              throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
            if (s.validity.notBefore = u[0], s.validity.notAfter = u[1], s.tbsCertificate = r.tbsCertificate, e) {
              s.md = h_({ signatureOid: s.signatureOid, type: "certificate" });
              var l = _.toDer(s.tbsCertificate);
              s.md.update(l.getBytes());
            }
            var f = Le.md.sha1.create(), h = _.toDer(r.certIssuer);
            f.update(h.getBytes()), s.issuer.getField = function(m) {
              return pf(s.issuer, m);
            }, s.issuer.addField = function(m) {
              ms([m]), s.issuer.attributes.push(m);
            }, s.issuer.attributes = ne.RDNAttributesAsArray(r.certIssuer), r.certIssuerUniqueId && (s.issuer.uniqueId = r.certIssuerUniqueId), s.issuer.hash = f.digest().toHex();
            var p = Le.md.sha1.create(), d = _.toDer(r.certSubject);
            return p.update(d.getBytes()), s.subject.getField = function(m) {
              return pf(s.subject, m);
            }, s.subject.addField = function(m) {
              ms([m]), s.subject.attributes.push(m);
            }, s.subject.attributes = ne.RDNAttributesAsArray(r.certSubject), r.certSubjectUniqueId && (s.subject.uniqueId = r.certSubjectUniqueId), s.subject.hash = p.digest().toHex(), r.certExtensions ? s.extensions = ne.certificateExtensionsFromAsn1(r.certExtensions) : s.extensions = [], s.publicKey = ne.publicKeyFromAsn1(r.subjectPublicKeyInfo), s;
          };
          ne.certificateExtensionsFromAsn1 = function(t) {
            for (var e = [], r = 0; r < t.value.length; ++r)
              for (var n = t.value[r], i2 = 0; i2 < n.value.length; ++i2)
                e.push(ne.certificateExtensionFromAsn1(n.value[i2]));
            return e;
          };
          ne.certificateExtensionFromAsn1 = function(t) {
            var e = {};
            if (e.id = _.derToOid(t.value[0].value), e.critical = false, t.value[1].type === _.Type.BOOLEAN ? (e.critical = t.value[1].value.charCodeAt(0) !== 0, e.value = t.value[2].value) : e.value = t.value[1].value, e.id in Lt) {
              if (e.name = Lt[e.id], e.name === "keyUsage") {
                var r = _.fromDer(e.value), n = 0, i2 = 0;
                r.value.length > 1 && (n = r.value.charCodeAt(1), i2 = r.value.length > 2 ? r.value.charCodeAt(2) : 0), e.digitalSignature = (n & 128) === 128, e.nonRepudiation = (n & 64) === 64, e.keyEncipherment = (n & 32) === 32, e.dataEncipherment = (n & 16) === 16, e.keyAgreement = (n & 8) === 8, e.keyCertSign = (n & 4) === 4, e.cRLSign = (n & 2) === 2, e.encipherOnly = (n & 1) === 1, e.decipherOnly = (i2 & 128) === 128;
              } else if (e.name === "basicConstraints") {
                var r = _.fromDer(e.value);
                r.value.length > 0 && r.value[0].type === _.Type.BOOLEAN ? e.cA = r.value[0].value.charCodeAt(0) !== 0 : e.cA = false;
                var o = null;
                r.value.length > 0 && r.value[0].type === _.Type.INTEGER ? o = r.value[0].value : r.value.length > 1 && (o = r.value[1].value), o !== null && (e.pathLenConstraint = _.derToInteger(o));
              } else if (e.name === "extKeyUsage")
                for (var r = _.fromDer(e.value), s = 0; s < r.value.length; ++s) {
                  var a = _.derToOid(r.value[s].value);
                  a in Lt ? e[Lt[a]] = true : e[a] = true;
                }
              else if (e.name === "nsCertType") {
                var r = _.fromDer(e.value), n = 0;
                r.value.length > 1 && (n = r.value.charCodeAt(1)), e.client = (n & 128) === 128, e.server = (n & 64) === 64, e.email = (n & 32) === 32, e.objsign = (n & 16) === 16, e.reserved = (n & 8) === 8, e.sslCA = (n & 4) === 4, e.emailCA = (n & 2) === 2, e.objCA = (n & 1) === 1;
              } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
                e.altNames = [];
                for (var u, r = _.fromDer(e.value), l = 0; l < r.value.length; ++l) {
                  u = r.value[l];
                  var f = { type: u.type, value: u.value };
                  switch (e.altNames.push(f), u.type) {
                    case 1:
                    case 2:
                    case 6:
                      break;
                    case 7:
                      f.ip = Le.util.bytesToIP(u.value);
                      break;
                    case 8:
                      f.oid = _.derToOid(u.value);
                      break;
                    default:
                  }
                }
              } else if (e.name === "subjectKeyIdentifier") {
                var r = _.fromDer(e.value);
                e.subjectKeyIdentifier = Le.util.bytesToHex(r.value);
              }
            }
            return e;
          };
          ne.certificationRequestFromAsn1 = function(t, e) {
            var r = {}, n = [];
            if (!_.validate(t, NDe, r, n)) {
              var i2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
              throw i2.errors = n, i2;
            }
            var o = _.derToOid(r.publicKeyOid);
            if (o !== ne.oids.rsaEncryption)
              throw new Error("Cannot read public key. OID is not RSA.");
            var s = ne.createCertificationRequest();
            if (s.version = r.csrVersion ? r.csrVersion.charCodeAt(0) : 0, s.signatureOid = Le.asn1.derToOid(r.csrSignatureOid), s.signatureParameters = f_(s.signatureOid, r.csrSignatureParams, true), s.siginfo.algorithmOid = Le.asn1.derToOid(r.csrSignatureOid), s.siginfo.parameters = f_(s.siginfo.algorithmOid, r.csrSignatureParams, false), s.signature = r.csrSignature, s.certificationRequestInfo = r.certificationRequestInfo, e) {
              s.md = h_({ signatureOid: s.signatureOid, type: "certification request" });
              var a = _.toDer(s.certificationRequestInfo);
              s.md.update(a.getBytes());
            }
            var u = Le.md.sha1.create();
            return s.subject.getField = function(l) {
              return pf(s.subject, l);
            }, s.subject.addField = function(l) {
              ms([l]), s.subject.attributes.push(l);
            }, s.subject.attributes = ne.RDNAttributesAsArray(r.certificationRequestInfoSubject, u), s.subject.hash = u.digest().toHex(), s.publicKey = ne.publicKeyFromAsn1(r.subjectPublicKeyInfo), s.getAttribute = function(l) {
              return pf(s, l);
            }, s.addAttribute = function(l) {
              ms([l]), s.attributes.push(l);
            }, s.attributes = ne.CRIAttributesAsArray(r.certificationRequestInfoAttributes || []), s;
          };
          ne.createCertificationRequest = function() {
            var t = {};
            return t.version = 0, t.signatureOid = null, t.signature = null, t.siginfo = {}, t.siginfo.algorithmOid = null, t.subject = {}, t.subject.getField = function(e) {
              return pf(t.subject, e);
            }, t.subject.addField = function(e) {
              ms([e]), t.subject.attributes.push(e);
            }, t.subject.attributes = [], t.subject.hash = null, t.publicKey = null, t.attributes = [], t.getAttribute = function(e) {
              return pf(t, e);
            }, t.addAttribute = function(e) {
              ms([e]), t.attributes.push(e);
            }, t.md = null, t.setSubject = function(e) {
              ms(e), t.subject.attributes = e, t.subject.hash = null;
            }, t.setAttributes = function(e) {
              ms(e), t.attributes = e;
            }, t.sign = function(e, r) {
              t.md = r || Le.md.sha1.create();
              var n = Lt[t.md.algorithm + "WithRSAEncryption"];
              if (!n) {
                var i2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
                throw i2.algorithm = t.md.algorithm, i2;
              }
              t.signatureOid = t.siginfo.algorithmOid = n, t.certificationRequestInfo = ne.getCertificationRequestInfo(t);
              var o = _.toDer(t.certificationRequestInfo);
              t.md.update(o.getBytes()), t.signature = e.sign(t.md);
            }, t.verify = function() {
              var e = false, r = t.md;
              if (r === null) {
                r = h_({ signatureOid: t.signatureOid, type: "certification request" });
                var n = t.certificationRequestInfo || ne.getCertificationRequestInfo(t), i2 = _.toDer(n);
                r.update(i2.getBytes());
              }
              return r !== null && (e = rce({ certificate: t, md: r, signature: t.signature })), e;
            }, t;
          };
          function X1(t) {
            for (var e = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []), r, n, i2 = t.attributes, o = 0; o < i2.length; ++o) {
              r = i2[o];
              var s = r.value, a = _.Type.PRINTABLESTRING;
              "valueTagClass" in r && (a = r.valueTagClass, a === _.Type.UTF8 && (s = Le.util.encodeUtf8(s))), n = _.create(_.Class.UNIVERSAL, _.Type.SET, true, [_.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(r.type).getBytes()), _.create(_.Class.UNIVERSAL, a, false, s)])]), e.value.push(n);
            }
            return e;
          }
          function ms(t) {
            for (var e, r = 0; r < t.length; ++r) {
              if (e = t[r], typeof e.name > "u" && (e.type && e.type in ne.oids ? e.name = ne.oids[e.type] : e.shortName && e.shortName in Zr && (e.name = ne.oids[Zr[e.shortName]])), typeof e.type > "u")
                if (e.name && e.name in ne.oids)
                  e.type = ne.oids[e.name];
                else {
                  var n = new Error("Attribute type not specified.");
                  throw n.attribute = e, n;
                }
              if (typeof e.shortName > "u" && e.name && e.name in Zr && (e.shortName = Zr[e.name]), e.type === Lt.extensionRequest && (e.valueConstructed = true, e.valueTagClass = _.Type.SEQUENCE, !e.value && e.extensions)) {
                e.value = [];
                for (var i2 = 0; i2 < e.extensions.length; ++i2)
                  e.value.push(ne.certificateExtensionToAsn1(nce(e.extensions[i2])));
              }
              if (typeof e.value > "u") {
                var n = new Error("Attribute value not specified.");
                throw n.attribute = e, n;
              }
            }
          }
          function nce(t, e) {
            if (e = e || {}, typeof t.name > "u" && t.id && t.id in ne.oids && (t.name = ne.oids[t.id]), typeof t.id > "u")
              if (t.name && t.name in ne.oids)
                t.id = ne.oids[t.name];
              else {
                var r = new Error("Extension ID not specified.");
                throw r.extension = t, r;
              }
            if (typeof t.value < "u")
              return t;
            if (t.name === "keyUsage") {
              var n = 0, i2 = 0, o = 0;
              t.digitalSignature && (i2 |= 128, n = 7), t.nonRepudiation && (i2 |= 64, n = 6), t.keyEncipherment && (i2 |= 32, n = 5), t.dataEncipherment && (i2 |= 16, n = 4), t.keyAgreement && (i2 |= 8, n = 3), t.keyCertSign && (i2 |= 4, n = 2), t.cRLSign && (i2 |= 2, n = 1), t.encipherOnly && (i2 |= 1, n = 0), t.decipherOnly && (o |= 128, n = 7);
              var s = String.fromCharCode(n);
              o !== 0 ? s += String.fromCharCode(i2) + String.fromCharCode(o) : i2 !== 0 && (s += String.fromCharCode(i2)), t.value = _.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, s);
            } else if (t.name === "basicConstraints")
              t.value = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []), t.cA && t.value.value.push(_.create(_.Class.UNIVERSAL, _.Type.BOOLEAN, false, String.fromCharCode(255))), "pathLenConstraint" in t && t.value.value.push(_.create(_.Class.UNIVERSAL, _.Type.INTEGER, false, _.integerToDer(t.pathLenConstraint).getBytes()));
            else if (t.name === "extKeyUsage") {
              t.value = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
              var a = t.value.value;
              for (var u in t)
                t[u] === true && (u in Lt ? a.push(_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(Lt[u]).getBytes())) : u.indexOf(".") !== -1 && a.push(_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(u).getBytes())));
            } else if (t.name === "nsCertType") {
              var n = 0, i2 = 0;
              t.client && (i2 |= 128, n = 7), t.server && (i2 |= 64, n = 6), t.email && (i2 |= 32, n = 5), t.objsign && (i2 |= 16, n = 4), t.reserved && (i2 |= 8, n = 3), t.sslCA && (i2 |= 4, n = 2), t.emailCA && (i2 |= 2, n = 1), t.objCA && (i2 |= 1, n = 0);
              var s = String.fromCharCode(n);
              i2 !== 0 && (s += String.fromCharCode(i2)), t.value = _.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, s);
            } else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
              t.value = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
              for (var l, f = 0; f < t.altNames.length; ++f) {
                l = t.altNames[f];
                var s = l.value;
                if (l.type === 7 && l.ip) {
                  if (s = Le.util.bytesFromIP(l.ip), s === null) {
                    var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                    throw r.extension = t, r;
                  }
                } else
                  l.type === 8 && (l.oid ? s = _.oidToDer(_.oidToDer(l.oid)) : s = _.oidToDer(s));
                t.value.value.push(_.create(_.Class.CONTEXT_SPECIFIC, l.type, false, s));
              }
            } else if (t.name === "nsComment" && e.cert) {
              if (!/^[\x00-\x7F]*$/.test(t.comment) || t.comment.length < 1 || t.comment.length > 128)
                throw new Error('Invalid "nsComment" content.');
              t.value = _.create(_.Class.UNIVERSAL, _.Type.IA5STRING, false, t.comment);
            } else if (t.name === "subjectKeyIdentifier" && e.cert) {
              var h = e.cert.generateSubjectKeyIdentifier();
              t.subjectKeyIdentifier = h.toHex(), t.value = _.create(_.Class.UNIVERSAL, _.Type.OCTETSTRING, false, h.getBytes());
            } else if (t.name === "authorityKeyIdentifier" && e.cert) {
              t.value = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
              var a = t.value.value;
              if (t.keyIdentifier) {
                var p = t.keyIdentifier === true ? e.cert.generateSubjectKeyIdentifier().getBytes() : t.keyIdentifier;
                a.push(_.create(_.Class.CONTEXT_SPECIFIC, 0, false, p));
              }
              if (t.authorityCertIssuer) {
                var d = [_.create(_.Class.CONTEXT_SPECIFIC, 4, true, [X1(t.authorityCertIssuer === true ? e.cert.issuer : t.authorityCertIssuer)])];
                a.push(_.create(_.Class.CONTEXT_SPECIFIC, 1, true, d));
              }
              if (t.serialNumber) {
                var m = Le.util.hexToBytes(t.serialNumber === true ? e.cert.serialNumber : t.serialNumber);
                a.push(_.create(_.Class.CONTEXT_SPECIFIC, 2, false, m));
              }
            } else if (t.name === "cRLDistributionPoints") {
              t.value = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
              for (var a = t.value.value, y = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []), g = _.create(_.Class.CONTEXT_SPECIFIC, 0, true, []), l, f = 0; f < t.altNames.length; ++f) {
                l = t.altNames[f];
                var s = l.value;
                if (l.type === 7 && l.ip) {
                  if (s = Le.util.bytesFromIP(l.ip), s === null) {
                    var r = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                    throw r.extension = t, r;
                  }
                } else
                  l.type === 8 && (l.oid ? s = _.oidToDer(_.oidToDer(l.oid)) : s = _.oidToDer(s));
                g.value.push(_.create(_.Class.CONTEXT_SPECIFIC, l.type, false, s));
              }
              y.value.push(_.create(_.Class.CONTEXT_SPECIFIC, 0, true, [g])), a.push(y);
            }
            if (typeof t.value > "u") {
              var r = new Error("Extension value not specified.");
              throw r.extension = t, r;
            }
            return t;
          }
          function eD(t, e) {
            switch (t) {
              case Lt["RSASSA-PSS"]:
                var r = [];
                return e.hash.algorithmOid !== void 0 && r.push(_.create(_.Class.CONTEXT_SPECIFIC, 0, true, [_.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(e.hash.algorithmOid).getBytes()), _.create(_.Class.UNIVERSAL, _.Type.NULL, false, "")])])), e.mgf.algorithmOid !== void 0 && r.push(_.create(_.Class.CONTEXT_SPECIFIC, 1, true, [_.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(e.mgf.algorithmOid).getBytes()), _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(e.mgf.hash.algorithmOid).getBytes()), _.create(_.Class.UNIVERSAL, _.Type.NULL, false, "")])])])), e.saltLength !== void 0 && r.push(_.create(_.Class.CONTEXT_SPECIFIC, 2, true, [_.create(_.Class.UNIVERSAL, _.Type.INTEGER, false, _.integerToDer(e.saltLength).getBytes())])), _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, r);
              default:
                return _.create(_.Class.UNIVERSAL, _.Type.NULL, false, "");
            }
          }
          function ODe(t) {
            var e = _.create(_.Class.CONTEXT_SPECIFIC, 0, true, []);
            if (t.attributes.length === 0)
              return e;
            for (var r = t.attributes, n = 0; n < r.length; ++n) {
              var i2 = r[n], o = i2.value, s = _.Type.UTF8;
              "valueTagClass" in i2 && (s = i2.valueTagClass), s === _.Type.UTF8 && (o = Le.util.encodeUtf8(o));
              var a = false;
              "valueConstructed" in i2 && (a = i2.valueConstructed);
              var u = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(i2.type).getBytes()), _.create(_.Class.UNIVERSAL, _.Type.SET, true, [_.create(_.Class.UNIVERSAL, s, a, o)])]);
              e.value.push(u);
            }
            return e;
          }
          var LDe = new Date("1950-01-01T00:00:00Z"), BDe = new Date("2050-01-01T00:00:00Z");
          function ece(t) {
            return t >= LDe && t < BDe ? _.create(_.Class.UNIVERSAL, _.Type.UTCTIME, false, _.dateToUtcTime(t)) : _.create(_.Class.UNIVERSAL, _.Type.GENERALIZEDTIME, false, _.dateToGeneralizedTime(t));
          }
          ne.getTBSCertificate = function(t) {
            var e = ece(t.validity.notBefore), r = ece(t.validity.notAfter), n = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.CONTEXT_SPECIFIC, 0, true, [_.create(_.Class.UNIVERSAL, _.Type.INTEGER, false, _.integerToDer(t.version).getBytes())]), _.create(_.Class.UNIVERSAL, _.Type.INTEGER, false, Le.util.hexToBytes(t.serialNumber)), _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(t.siginfo.algorithmOid).getBytes()), eD(t.siginfo.algorithmOid, t.siginfo.parameters)]), X1(t.issuer), _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [e, r]), X1(t.subject), ne.publicKeyToAsn1(t.publicKey)]);
            return t.issuer.uniqueId && n.value.push(_.create(_.Class.CONTEXT_SPECIFIC, 1, true, [_.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, String.fromCharCode(0) + t.issuer.uniqueId)])), t.subject.uniqueId && n.value.push(_.create(_.Class.CONTEXT_SPECIFIC, 2, true, [_.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, String.fromCharCode(0) + t.subject.uniqueId)])), t.extensions.length > 0 && n.value.push(ne.certificateExtensionsToAsn1(t.extensions)), n;
          };
          ne.getCertificationRequestInfo = function(t) {
            var e = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.INTEGER, false, _.integerToDer(t.version).getBytes()), X1(t.subject), ne.publicKeyToAsn1(t.publicKey), ODe(t)]);
            return e;
          };
          ne.distinguishedNameToAsn1 = function(t) {
            return X1(t);
          };
          ne.certificateToAsn1 = function(t) {
            var e = t.tbsCertificate || ne.getTBSCertificate(t);
            return _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [e, _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(t.signatureOid).getBytes()), eD(t.signatureOid, t.signatureParameters)]), _.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, String.fromCharCode(0) + t.signature)]);
          };
          ne.certificateExtensionsToAsn1 = function(t) {
            var e = _.create(_.Class.CONTEXT_SPECIFIC, 3, true, []), r = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
            e.value.push(r);
            for (var n = 0; n < t.length; ++n)
              r.value.push(ne.certificateExtensionToAsn1(t[n]));
            return e;
          };
          ne.certificateExtensionToAsn1 = function(t) {
            var e = _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, []);
            e.value.push(_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(t.id).getBytes())), t.critical && e.value.push(_.create(_.Class.UNIVERSAL, _.Type.BOOLEAN, false, String.fromCharCode(255)));
            var r = t.value;
            return typeof t.value != "string" && (r = _.toDer(r).getBytes()), e.value.push(_.create(_.Class.UNIVERSAL, _.Type.OCTETSTRING, false, r)), e;
          };
          ne.certificationRequestToAsn1 = function(t) {
            var e = t.certificationRequestInfo || ne.getCertificationRequestInfo(t);
            return _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [e, _.create(_.Class.UNIVERSAL, _.Type.SEQUENCE, true, [_.create(_.Class.UNIVERSAL, _.Type.OID, false, _.oidToDer(t.signatureOid).getBytes()), eD(t.signatureOid, t.signatureParameters)]), _.create(_.Class.UNIVERSAL, _.Type.BITSTRING, false, String.fromCharCode(0) + t.signature)]);
          };
          ne.createCaStore = function(t) {
            var e = { certs: {} };
            e.getIssuer = function(s) {
              var a = r(s.issuer);
              return a;
            }, e.addCertificate = function(s) {
              if (typeof s == "string" && (s = Le.pki.certificateFromPem(s)), n(s.subject), !e.hasCertificate(s))
                if (s.subject.hash in e.certs) {
                  var a = e.certs[s.subject.hash];
                  Le.util.isArray(a) || (a = [a]), a.push(s), e.certs[s.subject.hash] = a;
                } else
                  e.certs[s.subject.hash] = s;
            }, e.hasCertificate = function(s) {
              typeof s == "string" && (s = Le.pki.certificateFromPem(s));
              var a = r(s.subject);
              if (!a)
                return false;
              Le.util.isArray(a) || (a = [a]);
              for (var u = _.toDer(ne.certificateToAsn1(s)).getBytes(), l = 0; l < a.length; ++l) {
                var f = _.toDer(ne.certificateToAsn1(a[l])).getBytes();
                if (u === f)
                  return true;
              }
              return false;
            }, e.listAllCertificates = function() {
              var s = [];
              for (var a in e.certs)
                if (e.certs.hasOwnProperty(a)) {
                  var u = e.certs[a];
                  if (!Le.util.isArray(u))
                    s.push(u);
                  else
                    for (var l = 0; l < u.length; ++l)
                      s.push(u[l]);
                }
              return s;
            }, e.removeCertificate = function(s) {
              var a;
              if (typeof s == "string" && (s = Le.pki.certificateFromPem(s)), n(s.subject), !e.hasCertificate(s))
                return null;
              var u = r(s.subject);
              if (!Le.util.isArray(u))
                return a = e.certs[s.subject.hash], delete e.certs[s.subject.hash], a;
              for (var l = _.toDer(ne.certificateToAsn1(s)).getBytes(), f = 0; f < u.length; ++f) {
                var h = _.toDer(ne.certificateToAsn1(u[f])).getBytes();
                l === h && (a = u[f], u.splice(f, 1));
              }
              return u.length === 0 && delete e.certs[s.subject.hash], a;
            };
            function r(s) {
              return n(s), e.certs[s.hash] || null;
            }
            function n(s) {
              if (!s.hash) {
                var a = Le.md.sha1.create();
                s.attributes = ne.RDNAttributesAsArray(X1(s), a), s.hash = a.digest().toHex();
              }
            }
            if (t)
              for (var i2 = 0; i2 < t.length; ++i2) {
                var o = t[i2];
                e.addCertificate(o);
              }
            return e;
          };
          ne.certificateError = { bad_certificate: "forge.pki.BadCertificate", unsupported_certificate: "forge.pki.UnsupportedCertificate", certificate_revoked: "forge.pki.CertificateRevoked", certificate_expired: "forge.pki.CertificateExpired", certificate_unknown: "forge.pki.CertificateUnknown", unknown_ca: "forge.pki.UnknownCertificateAuthority" };
          ne.verifyCertificateChain = function(t, e, r) {
            typeof r == "function" && (r = { verify: r }), r = r || {}, e = e.slice(0);
            var n = e.slice(0), i2 = r.validityCheckDate;
            typeof i2 > "u" && (i2 = new Date());
            var o = true, s = null, a = 0;
            do {
              var u = e.shift(), l = null, f = false;
              if (i2 && (i2 < u.validity.notBefore || i2 > u.validity.notAfter) && (s = { message: "Certificate is not valid yet or has expired.", error: ne.certificateError.certificate_expired, notBefore: u.validity.notBefore, notAfter: u.validity.notAfter, now: i2 }), s === null) {
                if (l = e[0] || t.getIssuer(u), l === null && u.isIssuer(u) && (f = true, l = u), l) {
                  var h = l;
                  Le.util.isArray(h) || (h = [h]);
                  for (var p = false; !p && h.length > 0; ) {
                    l = h.shift();
                    try {
                      p = l.verify(u);
                    } catch {
                    }
                  }
                  p || (s = { message: "Certificate signature is invalid.", error: ne.certificateError.bad_certificate });
                }
                s === null && (!l || f) && !t.hasCertificate(u) && (s = { message: "Certificate is not trusted.", error: ne.certificateError.unknown_ca });
              }
              if (s === null && l && !u.isIssuer(l) && (s = { message: "Certificate issuer is invalid.", error: ne.certificateError.bad_certificate }), s === null)
                for (var d = { keyUsage: true, basicConstraints: true }, m = 0; s === null && m < u.extensions.length; ++m) {
                  var y = u.extensions[m];
                  y.critical && !(y.name in d) && (s = { message: "Certificate has an unsupported critical extension.", error: ne.certificateError.unsupported_certificate });
                }
              if (s === null && (!o || e.length === 0 && (!l || f))) {
                var g = u.getExtension("basicConstraints"), E = u.getExtension("keyUsage");
                if (E !== null && (!E.keyCertSign || g === null) && (s = { message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.", error: ne.certificateError.bad_certificate }), s === null && g !== null && !g.cA && (s = { message: "Certificate basicConstraints indicates the certificate is not a CA.", error: ne.certificateError.bad_certificate }), s === null && E !== null && "pathLenConstraint" in g) {
                  var b = a - 1;
                  b > g.pathLenConstraint && (s = { message: "Certificate basicConstraints pathLenConstraint violated.", error: ne.certificateError.bad_certificate });
                }
              }
              var v = s === null ? true : s.error, S = r.verify ? r.verify(v, a, n) : v;
              if (S === true)
                s = null;
              else
                throw v === true && (s = { message: "The application rejected the certificate.", error: ne.certificateError.bad_certificate }), (S || S === 0) && (typeof S == "object" && !Le.util.isArray(S) ? (S.message && (s.message = S.message), S.error && (s.error = S.error)) : typeof S == "string" && (s.error = S)), s;
              o = false, ++a;
            } while (e.length > 0);
            return true;
          };
        });
        var ace = A((I7t, sce) => {
          c();
          var oe = st();
          jp();
          Aa();
          jw();
          $p();
          Zw();
          Wae();
          nh();
          gr();
          tD();
          var D = oe.asn1, Ni = sce.exports = oe.pkcs7 = oe.pkcs7 || {};
          Ni.messageFromPem = function(t) {
            var e = oe.pem.decode(t)[0];
            if (e.type !== "PKCS7") {
              var r = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
              throw r.headerType = e.type, r;
            }
            if (e.procType && e.procType.type === "ENCRYPTED")
              throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
            var n = D.fromDer(e.body);
            return Ni.messageFromAsn1(n);
          };
          Ni.messageToPem = function(t, e) {
            var r = { type: "PKCS7", body: D.toDer(t.toAsn1()).getBytes() };
            return oe.pem.encode(r, { maxline: e });
          };
          Ni.messageFromAsn1 = function(t) {
            var e = {}, r = [];
            if (!D.validate(t, Ni.asn1.contentInfoValidator, e, r)) {
              var n = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
              throw n.errors = r, n;
            }
            var i2 = D.derToOid(e.contentType), o;
            switch (i2) {
              case oe.pki.oids.envelopedData:
                o = Ni.createEnvelopedData();
                break;
              case oe.pki.oids.encryptedData:
                o = Ni.createEncryptedData();
                break;
              case oe.pki.oids.signedData:
                o = Ni.createSignedData();
                break;
              default:
                throw new Error("Cannot read PKCS#7 message. ContentType with OID " + i2 + " is not (yet) supported.");
            }
            return o.fromAsn1(e.content.value[0]), o;
          };
          Ni.createSignedData = function() {
            var t = null;
            return t = { type: oe.pki.oids.signedData, version: 1, certificates: [], crls: [], signers: [], digestAlgorithmIdentifiers: [], contentInfo: null, signerInfos: [], fromAsn1: function(n) {
              if (nD(t, n, Ni.asn1.signedDataValidator), t.certificates = [], t.crls = [], t.digestAlgorithmIdentifiers = [], t.contentInfo = null, t.signerInfos = [], t.rawCapture.certificates)
                for (var i2 = t.rawCapture.certificates.value, o = 0; o < i2.length; ++o)
                  t.certificates.push(oe.pki.certificateFromAsn1(i2[o]));
            }, toAsn1: function() {
              t.contentInfo || t.sign();
              for (var n = [], i2 = 0; i2 < t.certificates.length; ++i2)
                n.push(oe.pki.certificateToAsn1(t.certificates[i2]));
              var o = [], s = D.create(D.Class.CONTEXT_SPECIFIC, 0, true, [D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, D.integerToDer(t.version).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SET, true, t.digestAlgorithmIdentifiers), t.contentInfo])]);
              return n.length > 0 && s.value[0].value.push(D.create(D.Class.CONTEXT_SPECIFIC, 0, true, n)), o.length > 0 && s.value[0].value.push(D.create(D.Class.CONTEXT_SPECIFIC, 1, true, o)), s.value[0].value.push(D.create(D.Class.UNIVERSAL, D.Type.SET, true, t.signerInfos)), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.type).getBytes()), s]);
            }, addSigner: function(n) {
              var i2 = n.issuer, o = n.serialNumber;
              if (n.certificate) {
                var s = n.certificate;
                typeof s == "string" && (s = oe.pki.certificateFromPem(s)), i2 = s.issuer.attributes, o = s.serialNumber;
              }
              var a = n.key;
              if (!a)
                throw new Error("Could not add PKCS#7 signer; no private key specified.");
              typeof a == "string" && (a = oe.pki.privateKeyFromPem(a));
              var u = n.digestAlgorithm || oe.pki.oids.sha1;
              switch (u) {
                case oe.pki.oids.sha1:
                case oe.pki.oids.sha256:
                case oe.pki.oids.sha384:
                case oe.pki.oids.sha512:
                case oe.pki.oids.md5:
                  break;
                default:
                  throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + u);
              }
              var l = n.authenticatedAttributes || [];
              if (l.length > 0) {
                for (var f = false, h = false, p = 0; p < l.length; ++p) {
                  var d = l[p];
                  if (!f && d.type === oe.pki.oids.contentType) {
                    if (f = true, h)
                      break;
                    continue;
                  }
                  if (!h && d.type === oe.pki.oids.messageDigest) {
                    if (h = true, f)
                      break;
                    continue;
                  }
                }
                if (!f || !h)
                  throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
              }
              t.signers.push({ key: a, version: 1, issuer: i2, serialNumber: o, digestAlgorithm: u, signatureAlgorithm: oe.pki.oids.rsaEncryption, signature: null, authenticatedAttributes: l, unauthenticatedAttributes: [] });
            }, sign: function(n) {
              if (n = n || {}, (typeof t.content != "object" || t.contentInfo === null) && (t.contentInfo = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(oe.pki.oids.data).getBytes())]), "content" in t)) {
                var i2;
                t.content instanceof oe.util.ByteBuffer ? i2 = t.content.bytes() : typeof t.content == "string" && (i2 = oe.util.encodeUtf8(t.content)), n.detached ? t.detachedContent = D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, i2) : t.contentInfo.value.push(D.create(D.Class.CONTEXT_SPECIFIC, 0, true, [D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, i2)]));
              }
              if (t.signers.length !== 0) {
                var o = e();
                r(o);
              }
            }, verify: function() {
              throw new Error("PKCS#7 signature verification not yet implemented.");
            }, addCertificate: function(n) {
              typeof n == "string" && (n = oe.pki.certificateFromPem(n)), t.certificates.push(n);
            }, addCertificateRevokationList: function(n) {
              throw new Error("PKCS#7 CRL support not yet implemented.");
            } }, t;
            function e() {
              for (var n = {}, i2 = 0; i2 < t.signers.length; ++i2) {
                var o = t.signers[i2], s = o.digestAlgorithm;
                s in n || (n[s] = oe.md[oe.pki.oids[s]].create()), o.authenticatedAttributes.length === 0 ? o.md = n[s] : o.md = oe.md[oe.pki.oids[s]].create();
              }
              t.digestAlgorithmIdentifiers = [];
              for (var s in n)
                t.digestAlgorithmIdentifiers.push(D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(s).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.NULL, false, "")]));
              return n;
            }
            function r(n) {
              var i2;
              if (t.detachedContent ? i2 = t.detachedContent : (i2 = t.contentInfo.value[1], i2 = i2.value[0]), !i2)
                throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
              var o = D.derToOid(t.contentInfo.value[0].value), s = D.toDer(i2);
              s.getByte(), D.getBerValueLength(s), s = s.getBytes();
              for (var a in n)
                n[a].start().update(s);
              for (var u = new Date(), l = 0; l < t.signers.length; ++l) {
                var f = t.signers[l];
                if (f.authenticatedAttributes.length === 0) {
                  if (o !== oe.pki.oids.data)
                    throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
                } else {
                  f.authenticatedAttributesAsn1 = D.create(D.Class.CONTEXT_SPECIFIC, 0, true, []);
                  for (var h = D.create(D.Class.UNIVERSAL, D.Type.SET, true, []), p = 0; p < f.authenticatedAttributes.length; ++p) {
                    var d = f.authenticatedAttributes[p];
                    d.type === oe.pki.oids.messageDigest ? d.value = n[f.digestAlgorithm].digest() : d.type === oe.pki.oids.signingTime && (d.value || (d.value = u)), h.value.push(rD(d)), f.authenticatedAttributesAsn1.value.push(rD(d));
                  }
                  s = D.toDer(h).getBytes(), f.md.start().update(s);
                }
                f.signature = f.key.sign(f.md, "RSASSA-PKCS1-V1_5");
              }
              t.signerInfos = qDe(t.signers);
            }
          };
          Ni.createEncryptedData = function() {
            var t = null;
            return t = { type: oe.pki.oids.encryptedData, version: 0, encryptedContent: { algorithm: oe.pki.oids["aes256-CBC"] }, fromAsn1: function(e) {
              nD(t, e, Ni.asn1.encryptedDataValidator);
            }, decrypt: function(e) {
              e !== void 0 && (t.encryptedContent.key = e), oce(t);
            } }, t;
          };
          Ni.createEnvelopedData = function() {
            var t = null;
            return t = { type: oe.pki.oids.envelopedData, version: 0, recipients: [], encryptedContent: { algorithm: oe.pki.oids["aes256-CBC"] }, fromAsn1: function(e) {
              var r = nD(t, e, Ni.asn1.envelopedDataValidator);
              t.recipients = FDe(r.recipientInfos.value);
            }, toAsn1: function() {
              return D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.type).getBytes()), D.create(D.Class.CONTEXT_SPECIFIC, 0, true, [D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, D.integerToDer(t.version).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SET, true, KDe(t.recipients)), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, zDe(t.encryptedContent))])])]);
            }, findRecipient: function(e) {
              for (var r = e.issuer.attributes, n = 0; n < t.recipients.length; ++n) {
                var i2 = t.recipients[n], o = i2.issuer;
                if (i2.serialNumber === e.serialNumber && o.length === r.length) {
                  for (var s = true, a = 0; a < r.length; ++a)
                    if (o[a].type !== r[a].type || o[a].value !== r[a].value) {
                      s = false;
                      break;
                    }
                  if (s)
                    return i2;
                }
              }
              return null;
            }, decrypt: function(e, r) {
              if (t.encryptedContent.key === void 0 && e !== void 0 && r !== void 0)
                switch (e.encryptedContent.algorithm) {
                  case oe.pki.oids.rsaEncryption:
                  case oe.pki.oids.desCBC:
                    var n = r.decrypt(e.encryptedContent.content);
                    t.encryptedContent.key = oe.util.createBuffer(n);
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + e.encryptedContent.algorithm);
                }
              oce(t);
            }, addRecipient: function(e) {
              t.recipients.push({ version: 0, issuer: e.issuer.attributes, serialNumber: e.serialNumber, encryptedContent: { algorithm: oe.pki.oids.rsaEncryption, key: e.publicKey } });
            }, encrypt: function(e, r) {
              if (t.encryptedContent.content === void 0) {
                r = r || t.encryptedContent.algorithm, e = e || t.encryptedContent.key;
                var n, i2, o;
                switch (r) {
                  case oe.pki.oids["aes128-CBC"]:
                    n = 16, i2 = 16, o = oe.aes.createEncryptionCipher;
                    break;
                  case oe.pki.oids["aes192-CBC"]:
                    n = 24, i2 = 16, o = oe.aes.createEncryptionCipher;
                    break;
                  case oe.pki.oids["aes256-CBC"]:
                    n = 32, i2 = 16, o = oe.aes.createEncryptionCipher;
                    break;
                  case oe.pki.oids["des-EDE3-CBC"]:
                    n = 24, i2 = 8, o = oe.des.createEncryptionCipher;
                    break;
                  default:
                    throw new Error("Unsupported symmetric cipher, OID " + r);
                }
                if (e === void 0)
                  e = oe.util.createBuffer(oe.random.getBytes(n));
                else if (e.length() != n)
                  throw new Error("Symmetric key has wrong length; got " + e.length() + " bytes, expected " + n + ".");
                t.encryptedContent.algorithm = r, t.encryptedContent.key = e, t.encryptedContent.parameter = oe.util.createBuffer(oe.random.getBytes(i2));
                var s = o(e);
                if (s.start(t.encryptedContent.parameter.copy()), s.update(t.content), !s.finish())
                  throw new Error("Symmetric encryption failed.");
                t.encryptedContent.content = s.output;
              }
              for (var a = 0; a < t.recipients.length; ++a) {
                var u = t.recipients[a];
                if (u.encryptedContent.content === void 0)
                  switch (u.encryptedContent.algorithm) {
                    case oe.pki.oids.rsaEncryption:
                      u.encryptedContent.content = u.encryptedContent.key.encrypt(t.encryptedContent.key.data);
                      break;
                    default:
                      throw new Error("Unsupported asymmetric cipher, OID " + u.encryptedContent.algorithm);
                  }
              }
            } }, t;
          };
          function MDe(t) {
            var e = {}, r = [];
            if (!D.validate(t, Ni.asn1.recipientInfoValidator, e, r)) {
              var n = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
              throw n.errors = r, n;
            }
            return { version: e.version.charCodeAt(0), issuer: oe.pki.RDNAttributesAsArray(e.issuer), serialNumber: oe.util.createBuffer(e.serial).toHex(), encryptedContent: { algorithm: D.derToOid(e.encAlgorithm), parameter: e.encParameter ? e.encParameter.value : void 0, content: e.encKey } };
          }
          function UDe(t) {
            return D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, D.integerToDer(t.version).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [oe.pki.distinguishedNameToAsn1({ attributes: t.issuer }), D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, oe.util.hexToBytes(t.serialNumber))]), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.encryptedContent.algorithm).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.NULL, false, "")]), D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, t.encryptedContent.content)]);
          }
          function FDe(t) {
            for (var e = [], r = 0; r < t.length; ++r)
              e.push(MDe(t[r]));
            return e;
          }
          function KDe(t) {
            for (var e = [], r = 0; r < t.length; ++r)
              e.push(UDe(t[r]));
            return e;
          }
          function VDe(t) {
            var e = D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, D.integerToDer(t.version).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [oe.pki.distinguishedNameToAsn1({ attributes: t.issuer }), D.create(D.Class.UNIVERSAL, D.Type.INTEGER, false, oe.util.hexToBytes(t.serialNumber))]), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.digestAlgorithm).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.NULL, false, "")])]);
            if (t.authenticatedAttributesAsn1 && e.value.push(t.authenticatedAttributesAsn1), e.value.push(D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.signatureAlgorithm).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.NULL, false, "")])), e.value.push(D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, t.signature)), t.unauthenticatedAttributes.length > 0) {
              for (var r = D.create(D.Class.CONTEXT_SPECIFIC, 1, true, []), n = 0; n < t.unauthenticatedAttributes.length; ++n) {
                var i2 = t.unauthenticatedAttributes[n];
                r.values.push(rD(i2));
              }
              e.value.push(r);
            }
            return e;
          }
          function qDe(t) {
            for (var e = [], r = 0; r < t.length; ++r)
              e.push(VDe(t[r]));
            return e;
          }
          function rD(t) {
            var e;
            if (t.type === oe.pki.oids.contentType)
              e = D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.value).getBytes());
            else if (t.type === oe.pki.oids.messageDigest)
              e = D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, t.value.bytes());
            else if (t.type === oe.pki.oids.signingTime) {
              var r = new Date("1950-01-01T00:00:00Z"), n = new Date("2050-01-01T00:00:00Z"), i2 = t.value;
              if (typeof i2 == "string") {
                var o = Date.parse(i2);
                isNaN(o) ? i2.length === 13 ? i2 = D.utcTimeToDate(i2) : i2 = D.generalizedTimeToDate(i2) : i2 = new Date(o);
              }
              i2 >= r && i2 < n ? e = D.create(D.Class.UNIVERSAL, D.Type.UTCTIME, false, D.dateToUtcTime(i2)) : e = D.create(D.Class.UNIVERSAL, D.Type.GENERALIZEDTIME, false, D.dateToGeneralizedTime(i2));
            }
            return D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.type).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SET, true, [e])]);
          }
          function zDe(t) {
            return [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(oe.pki.oids.data).getBytes()), D.create(D.Class.UNIVERSAL, D.Type.SEQUENCE, true, [D.create(D.Class.UNIVERSAL, D.Type.OID, false, D.oidToDer(t.algorithm).getBytes()), t.parameter ? D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, t.parameter.getBytes()) : void 0]), D.create(D.Class.CONTEXT_SPECIFIC, 0, true, [D.create(D.Class.UNIVERSAL, D.Type.OCTETSTRING, false, t.content.getBytes())])];
          }
          function nD(t, e, r) {
            var n = {}, i2 = [];
            if (!D.validate(e, r, n, i2)) {
              var o = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
              throw o.errors = o, o;
            }
            var s = D.derToOid(n.contentType);
            if (s !== oe.pki.oids.data)
              throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
            if (n.encryptedContent) {
              var a = "";
              if (oe.util.isArray(n.encryptedContent))
                for (var u = 0; u < n.encryptedContent.length; ++u) {
                  if (n.encryptedContent[u].type !== D.Type.OCTETSTRING)
                    throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                  a += n.encryptedContent[u].value;
                }
              else
                a = n.encryptedContent;
              t.encryptedContent = { algorithm: D.derToOid(n.encAlgorithm), parameter: oe.util.createBuffer(n.encParameter.value), content: oe.util.createBuffer(a) };
            }
            if (n.content) {
              var a = "";
              if (oe.util.isArray(n.content))
                for (var u = 0; u < n.content.length; ++u) {
                  if (n.content[u].type !== D.Type.OCTETSTRING)
                    throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                  a += n.content[u].value;
                }
              else
                a = n.content;
              t.content = oe.util.createBuffer(a);
            }
            return t.version = n.version.charCodeAt(0), t.rawCapture = n, n;
          }
          function oce(t) {
            if (t.encryptedContent.key === void 0)
              throw new Error("Symmetric key not available.");
            if (t.content === void 0) {
              var e;
              switch (t.encryptedContent.algorithm) {
                case oe.pki.oids["aes128-CBC"]:
                case oe.pki.oids["aes192-CBC"]:
                case oe.pki.oids["aes256-CBC"]:
                  e = oe.aes.createDecryptionCipher(t.encryptedContent.key);
                  break;
                case oe.pki.oids.desCBC:
                case oe.pki.oids["des-EDE3-CBC"]:
                  e = oe.des.createDecryptionCipher(t.encryptedContent.key);
                  break;
                default:
                  throw new Error("Unsupported symmetric cipher, OID " + t.encryptedContent.algorithm);
              }
              if (e.start(t.encryptedContent.parameter), e.update(t.encryptedContent.content), !e.finish())
                throw new Error("Symmetric decryption failed.");
              t.content = e.output;
            }
          }
        });
        var sD = A((a9t, wce) => {
          "use strict";
          c();
          var QDe = async function* (t, e) {
            for await (let r of t)
              await e(r), yield r;
          };
          wce.exports = QDe;
        });
        var Ice = A((nSt, Tce) => {
          "use strict";
          c();
          function tke(t) {
            if (Array.isArray(t)) {
              for (var e = 0, r = Array(t.length); e < t.length; e++)
                r[e] = t[e];
              return r;
            } else
              return Array.from(t);
          }
          Tce.exports = function(e) {
            var r = void 0, n = void 0;
            function i2(a) {
              if (!(a instanceof Object))
                throw new Error('Target "' + a + '" is not an object');
              n = a;
            }
            function o(a) {
              Object.keys(a).forEach(function(u) {
                var l = a[u];
                if (typeof l != "function")
                  throw new Error('Trap "' + u + ": " + l + '" is not a function');
                if (!Reflect[u])
                  throw new Error('Trap "' + u + ": " + l + '" is not a valid trap');
              }), r = a;
            }
            i2(function() {
            }), e && i2(e), o(Reflect);
            var s = new Proxy({}, { get: function(u, l) {
              return function() {
                for (var f = arguments.length, h = Array(f), p = 0; p < f; p++)
                  h[p] = arguments[p];
                return r[l].apply(null, [n].concat(tke(h.slice(1))));
              };
            } });
            return { setTarget: i2, setHandler: o, getTarget: function() {
              return n;
            }, getHandler: function() {
              return r;
            }, proxy: new Proxy(n, s) };
          };
        });
        var xD = A((ixt, Yce) => {
          "use strict";
          c();
          var oke = H7(), A_ = typeof window == "object" && typeof document == "object" && document.nodeType === 9, T3 = oke(), ske = A_ && !T3, ake = T3 && !A_, cke = T3 && A_, uke = typeof jd == "function" && typeof globalThis.process < "u" && typeof globalThis.process.release < "u" && globalThis.process.release.name === "node" && !T3, lke = typeof importScripts == "function" && typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, fke = typeof globalThis.process < "u" && typeof globalThis.process.env < "u" && globalThis.process.env["NODE" + (() => "_")() + "ENV"] === "test", hke = typeof navigator < "u" && navigator.product === "ReactNative";
          Yce.exports = { isTest: fke, isElectron: T3, isElectronMain: ake, isElectronRenderer: cke, isNode: uke, isBrowser: ske, isWebWorker: lke, isEnvWithDom: A_, isReactNative: hke };
        });
        var xue = A((NRt, Sue) => {
          "use strict";
          c();
          Sue.exports = vue;
          var bke = G7(), _f = vue.prototype, _ke = new Date() % 1e9;
          function vke() {
            return (Math.random() * 1e9 >>> 0) + _ke++;
          }
          function vue(t) {
            t = t || {}, this.id = t.id || vke(), this.max = t.max || 1 / 0, this.items = t.items || [], this._lookup = {}, this.size = this.items.length, this.lastModified = new Date(t.lastModified || new Date());
            for (var e, r, n = this.items.length; n--; )
              e = this.items[n], r = new Date(e.expires) - new Date(), this._lookup[e.key] = e, r > 0 ? this.expire(e.key, r) : r <= 0 && this.delete(e.key);
          }
          _f.has = function(t) {
            return t in this._lookup;
          };
          _f.get = function(t) {
            if (!this.has(t))
              return null;
            var e = this._lookup[t];
            return e.refresh && this.expire(t, e.refresh), this.items.splice(this.items.indexOf(e), 1), this.items.push(e), e.value;
          };
          _f.meta = function(t) {
            if (!this.has(t))
              return null;
            var e = this._lookup[t];
            return "meta" in e ? e.meta : null;
          };
          _f.set = function(t, e, r) {
            var n = this._lookup[t], i2 = this._lookup[t] = { key: t, value: e };
            return this.lastModified = new Date(), n ? (clearTimeout(n.timeout), this.items.splice(this.items.indexOf(n), 1, i2)) : (this.size >= this.max && this.delete(this.items[0].key), this.items.push(i2), this.size++), r && ("ttl" in r && this.expire(t, r.ttl), "meta" in r && (i2.meta = r.meta), r.refresh && (i2.refresh = r.ttl)), this;
          };
          _f.delete = function(t) {
            var e = this._lookup[t];
            return e ? (this.lastModified = new Date(), this.items.splice(this.items.indexOf(e), 1), clearTimeout(e.timeout), delete this._lookup[t], this.size--, this) : false;
          };
          _f.expire = function(t, e) {
            var r = e || 0, n = this._lookup[t];
            if (!n)
              return this;
            if (typeof r == "string" && (r = bke(e)), typeof r != "number")
              throw new TypeError("Expiration time must be a string or number.");
            return clearTimeout(n.timeout), n.timeout = setTimeout(this.delete.bind(this, n.key), r), n.expires = Number(new Date()) + r, this;
          };
          _f.clear = function() {
            for (var t = this.items.length; t--; )
              this.delete(this.items[t].key);
            return this;
          };
          _f.toJSON = function() {
            for (var t = new Array(this.items.length), e, r = t.length; r--; )
              e = this.items[r], t[r] = { key: e.key, meta: e.meta, value: e.value, expires: e.expires, refresh: e.refresh };
            return { id: this.id, max: isFinite(this.max) ? this.max : void 0, lastModified: this.lastModified, items: t };
          };
        });
        var gle = A((hk, yle) => {
          c();
          var iv = _i(), cc = iv.Buffer;
          function mle(t, e) {
            for (var r in t)
              e[r] = t[r];
          }
          cc.from && cc.alloc && cc.allocUnsafe && cc.allocUnsafeSlow ? yle.exports = iv : (mle(iv, hk), hk.Buffer = qd);
          function qd(t, e, r) {
            return cc(t, e, r);
          }
          qd.prototype = Object.create(cc.prototype);
          mle(cc, qd);
          qd.from = function(t, e, r) {
            if (typeof t == "number")
              throw new TypeError("Argument must not be a number");
            return cc(t, e, r);
          };
          qd.alloc = function(t, e, r) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            var n = cc(t);
            return e !== void 0 ? typeof r == "string" ? n.fill(e, r) : n.fill(e) : n.fill(0), n;
          };
          qd.allocUnsafe = function(t) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            return cc(t);
          };
          qd.allocUnsafeSlow = function(t) {
            if (typeof t != "number")
              throw new TypeError("Argument must be a number");
            return iv.SlowBuffer(t);
          };
        });
        var wle = A((PIt, pk) => {
          "use strict";
          c();
          var dk = 65536, Jke = 4294967295;
          function eNe() {
            throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
          }
          var tNe = gle().Buffer, ov = globalThis.crypto || globalThis.msCrypto;
          ov && ov.getRandomValues ? pk.exports = rNe : pk.exports = eNe;
          function rNe(t, e) {
            if (t > Jke)
              throw new RangeError("requested too many random bytes");
            var r = tNe.allocUnsafe(t);
            if (t > 0)
              if (t > dk)
                for (var n = 0; n < t; n += dk)
                  ov.getRandomValues(r.slice(n, n + dk));
              else
                ov.getRandomValues(r);
            return typeof e == "function" ? process.nextTick(function() {
              e(null, r);
            }) : r;
          }
        });
        var _le = A((DIt, ble) => {
          "use strict";
          c();
          var nNe = wle(), { EventEmitter: iNe } = In();
          function Ele(t, e) {
            if (t === e)
              return true;
            if (t.length !== e.length)
              return false;
            for (let r = 0, n = t.length; r < n; ++r)
              if (t[r] !== e[r])
                return false;
            return true;
          }
          function mk() {
            return { contacts: [], dontSplit: false, left: null, right: null };
          }
          function z3(t, e) {
            if (!(e instanceof Uint8Array))
              throw new TypeError(t + " is not a Uint8Array");
          }
          var mm = class extends iNe {
            constructor(e = {}) {
              super(), this.localNodeId = e.localNodeId || nNe(20), this.numberOfNodesPerKBucket = e.numberOfNodesPerKBucket || 20, this.numberOfNodesToPing = e.numberOfNodesToPing || 3, this.distance = e.distance || mm.distance, this.arbiter = e.arbiter || mm.arbiter, this.metadata = Object.assign({}, e.metadata), z3("option.localNodeId as parameter 1", this.localNodeId), this.root = mk();
            }
            static arbiter(e, r) {
              return e.vectorClock > r.vectorClock ? e : r;
            }
            static distance(e, r) {
              let n = 0, i2 = 0, o = Math.min(e.length, r.length), s = Math.max(e.length, r.length);
              for (; i2 < o; ++i2)
                n = n * 256 + (e[i2] ^ r[i2]);
              for (; i2 < s; ++i2)
                n = n * 256 + 255;
              return n;
            }
            add(e) {
              z3("contact.id", (e || {}).id);
              let r = 0, n = this.root;
              for (; n.contacts === null; )
                n = this._determineNode(n, e.id, r++);
              let i2 = this._indexOf(n, e.id);
              return i2 >= 0 ? (this._update(n, i2, e), this) : n.contacts.length < this.numberOfNodesPerKBucket ? (n.contacts.push(e), this.emit("added", e), this) : n.dontSplit ? (this.emit("ping", n.contacts.slice(0, this.numberOfNodesToPing), e), this) : (this._split(n, r), this.add(e));
            }
            closest(e, r = 1 / 0) {
              if (z3("id", e), !Number.isInteger(r) && r !== 1 / 0 || r <= 0)
                throw new TypeError("n is not positive number");
              let n = [];
              for (let i2 = [this.root], o = 0; i2.length > 0 && n.length < r; ) {
                let s = i2.pop();
                if (s.contacts === null) {
                  let a = this._determineNode(s, e, o++);
                  i2.push(s.left === a ? s.right : s.left), i2.push(a);
                } else
                  n = n.concat(s.contacts);
              }
              return n.map((i2) => [this.distance(i2.id, e), i2]).sort((i2, o) => i2[0] - o[0]).slice(0, r).map((i2) => i2[1]);
            }
            count() {
              let e = 0;
              for (let r = [this.root]; r.length > 0; ) {
                let n = r.pop();
                n.contacts === null ? r.push(n.right, n.left) : e += n.contacts.length;
              }
              return e;
            }
            _determineNode(e, r, n) {
              let i2 = n >> 3, o = n % 8;
              return r.length <= i2 && o !== 0 ? e.left : r[i2] & 1 << 7 - o ? e.right : e.left;
            }
            get(e) {
              z3("id", e);
              let r = 0, n = this.root;
              for (; n.contacts === null; )
                n = this._determineNode(n, e, r++);
              let i2 = this._indexOf(n, e);
              return i2 >= 0 ? n.contacts[i2] : null;
            }
            _indexOf(e, r) {
              for (let n = 0; n < e.contacts.length; ++n)
                if (Ele(e.contacts[n].id, r))
                  return n;
              return -1;
            }
            remove(e) {
              z3("the id as parameter 1", e);
              let r = 0, n = this.root;
              for (; n.contacts === null; )
                n = this._determineNode(n, e, r++);
              let i2 = this._indexOf(n, e);
              if (i2 >= 0) {
                let o = n.contacts.splice(i2, 1)[0];
                this.emit("removed", o);
              }
              return this;
            }
            _split(e, r) {
              e.left = mk(), e.right = mk();
              for (let o of e.contacts)
                this._determineNode(e, o.id, r).contacts.push(o);
              e.contacts = null;
              let n = this._determineNode(e, this.localNodeId, r), i2 = e.left === n ? e.right : e.left;
              i2.dontSplit = true;
            }
            toArray() {
              let e = [];
              for (let r = [this.root]; r.length > 0; ) {
                let n = r.pop();
                n.contacts === null ? r.push(n.right, n.left) : e = e.concat(n.contacts);
              }
              return e;
            }
            *toIterable() {
              for (let e = [this.root]; e.length > 0; ) {
                let r = e.pop();
                r.contacts === null ? e.push(r.right, r.left) : yield* r.contacts;
              }
            }
            _update(e, r, n) {
              if (!Ele(e.contacts[r].id, n.id))
                throw new Error("wrong index for _update");
              let i2 = e.contacts[r], o = this.arbiter(i2, n);
              o === i2 && i2 !== n || (e.contacts.splice(r, 1), e.contacts.push(o), this.emit("updated", i2, o));
            }
          };
          ble.exports = mm;
        });
        var Afe = A((Fv) => {
          "use strict";
          c();
          Object.defineProperty(Fv, "__esModule", { value: true });
          var kk = class {
            constructor() {
              this.pullQueue = [], this.pushQueue = [], this.eventHandlers = {}, this.isPaused = false, this.isStopped = false;
            }
            push(e) {
              if (this.isStopped)
                return;
              let r = { value: e, done: false };
              if (this.pullQueue.length) {
                let n = this.pullQueue.shift();
                n && n.resolve(r);
              } else
                this.pushQueue.push(Promise.resolve(r)), this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused && (this.isPaused = true, this.eventHandlers.highWater ? this.eventHandlers.highWater() : console && console.warn(`EventIterator queue reached ${this.pushQueue.length} items`));
            }
            stop() {
              if (!this.isStopped) {
                this.isStopped = true, this.remove();
                for (let e of this.pullQueue)
                  e.resolve({ value: void 0, done: true });
                this.pullQueue.length = 0;
              }
            }
            fail(e) {
              if (!this.isStopped)
                if (this.isStopped = true, this.remove(), this.pullQueue.length) {
                  for (let r of this.pullQueue)
                    r.reject(e);
                  this.pullQueue.length = 0;
                } else {
                  let r = Promise.reject(e);
                  r.catch(() => {
                  }), this.pushQueue.push(r);
                }
            }
            remove() {
              Promise.resolve().then(() => {
                this.removeCallback && this.removeCallback();
              });
            }
            [Symbol.asyncIterator]() {
              return { next: (e) => {
                let r = this.pushQueue.shift();
                return r ? (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused && (this.isPaused = false, this.eventHandlers.lowWater && this.eventHandlers.lowWater()), r) : this.isStopped ? Promise.resolve({ value: void 0, done: true }) : new Promise((n, i2) => {
                  this.pullQueue.push({ resolve: n, reject: i2 });
                });
              }, return: () => (this.isStopped = true, this.pushQueue.length = 0, this.remove(), Promise.resolve({ value: void 0, done: true })) };
            }
          }, Uv = class {
            constructor(e, { highWaterMark: r = 100, lowWaterMark: n = 1 } = {}) {
              let i2 = new kk();
              i2.highWaterMark = r, i2.lowWaterMark = n, i2.removeCallback = e({ push: (o) => i2.push(o), stop: () => i2.stop(), fail: (o) => i2.fail(o), on: (o, s) => {
                i2.eventHandlers[o] = s;
              } }) || (() => {
              }), this[Symbol.asyncIterator] = () => i2[Symbol.asyncIterator](), Object.freeze(this);
            }
          };
          Fv.EventIterator = Uv;
          Fv.default = Uv;
        });
        var Tfe = A((i4) => {
          "use strict";
          c();
          Object.defineProperty(i4, "__esModule", { value: true });
          var Nk = Afe();
          i4.EventIterator = Nk.EventIterator;
          function vNe(t, e, r) {
            return new Nk.EventIterator(({ push: n }) => (this.addEventListener(t, n, e), () => this.removeEventListener(t, n, e)), r);
          }
          i4.subscribe = vNe;
          i4.default = Nk.EventIterator;
        });
        var she = A((Hk) => {
          "use strict";
          c();
          Object.defineProperty(Hk, "__esModule", { value: true });
          function ONe(t) {
            return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
          }
          Hk.isSerializableHash = ONe;
        });
        var Gv = A((Tm) => {
          "use strict";
          c();
          Object.defineProperty(Tm, "__esModule", { value: true });
          function LNe(t, e, r) {
            return ~(t - 1) & e | t - 1 & r;
          }
          Tm.select = LNe;
          function BNe(t, e) {
            return (t | 0) - (e | 0) - 1 >>> 31 & 1;
          }
          Tm.lessOrEqual = BNe;
          function ahe(t, e) {
            if (t.length !== e.length)
              return 0;
            for (var r = 0, n = 0; n < t.length; n++)
              r |= t[n] ^ e[n];
            return 1 & r - 1 >>> 8;
          }
          Tm.compare = ahe;
          function MNe(t, e) {
            return t.length === 0 || e.length === 0 ? false : ahe(t, e) !== 0;
          }
          Tm.equal = MNe;
        });
        var lc = A(($k) => {
          "use strict";
          c();
          Object.defineProperty($k, "__esModule", { value: true });
          function UNe(t) {
            for (var e = 0; e < t.length; e++)
              t[e] = 0;
            return t;
          }
          $k.wipe = UNe;
        });
        var uhe = A((o4) => {
          "use strict";
          c();
          Object.defineProperty(o4, "__esModule", { value: true });
          var fc = she(), FNe = Gv(), KNe = lc(), che = function() {
            function t(e, r) {
              this._finished = false, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
              var n = new Uint8Array(this.blockSize);
              r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
              for (var i2 = 0; i2 < n.length; i2++)
                n[i2] ^= 54;
              this._inner.update(n);
              for (var i2 = 0; i2 < n.length; i2++)
                n[i2] ^= 106;
              this._outer.update(n), fc.isSerializableHash(this._inner) && fc.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), KNe.wipe(n);
            }
            return t.prototype.reset = function() {
              if (!fc.isSerializableHash(this._inner) || !fc.isSerializableHash(this._outer))
                throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
              return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = false, this;
            }, t.prototype.clean = function() {
              fc.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), fc.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
            }, t.prototype.update = function(e) {
              return this._inner.update(e), this;
            }, t.prototype.finish = function(e) {
              return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = true, this);
            }, t.prototype.digest = function() {
              var e = new Uint8Array(this.digestLength);
              return this.finish(e), e;
            }, t.prototype.saveState = function() {
              if (!fc.isSerializableHash(this._inner))
                throw new Error("hmac: can't saveState() because hash doesn't implement it");
              return this._inner.saveState();
            }, t.prototype.restoreState = function(e) {
              if (!fc.isSerializableHash(this._inner) || !fc.isSerializableHash(this._outer))
                throw new Error("hmac: can't restoreState() because hash doesn't implement it");
              return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = false, this;
            }, t.prototype.cleanSavedState = function(e) {
              if (!fc.isSerializableHash(this._inner))
                throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
              this._inner.cleanSavedState(e);
            }, t;
          }();
          o4.HMAC = che;
          function VNe(t, e, r) {
            var n = new che(t, e);
            n.update(r);
            var i2 = n.digest();
            return n.clean(), i2;
          }
          o4.hmac = VNe;
          o4.equal = FNe.equal;
        });
        var hhe = A((Gk) => {
          "use strict";
          c();
          Object.defineProperty(Gk, "__esModule", { value: true });
          var lhe = uhe(), fhe = lc(), qNe = function() {
            function t(e, r, n, i2) {
              n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i2;
              var o = lhe.hmac(this._hash, n, r);
              this._hmac = new lhe.HMAC(e, o), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
            }
            return t.prototype._fillBuffer = function() {
              this._counter[0]++;
              var e = this._counter[0];
              if (e === 0)
                throw new Error("hkdf: cannot expand more");
              this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
            }, t.prototype.expand = function(e) {
              for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
                this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
              return r;
            }, t.prototype.clean = function() {
              this._hmac.clean(), fhe.wipe(this._buffer), fhe.wipe(this._counter), this._bufpos = 0;
            }, t;
          }();
          Gk.HKDF = qNe;
        });
        var phe = A((Wk) => {
          "use strict";
          c();
          Object.defineProperty(Wk, "__esModule", { value: true });
          var dhe = 65536, zNe = function() {
            function t() {
              this.isAvailable = false, this.isInstantiated = false;
              var e = typeof self < "u" ? self.crypto || self.msCrypto : null;
              e && e.getRandomValues && (this._crypto = e, this.isAvailable = true, this.isInstantiated = true);
            }
            return t.prototype.randomBytes = function(e) {
              if (!this.isAvailable || !this._crypto)
                throw new Error("Browser random byte generator is not available.");
              for (var r = new Uint8Array(e), n = 0; n < r.length; n += dhe)
                this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, dhe)));
              return r;
            }, t;
          }();
          Wk.BrowserRandomSource = zNe;
        });
        var mhe = A((jk) => {
          "use strict";
          c();
          Object.defineProperty(jk, "__esModule", { value: true });
          var HNe = lc(), $Ne = function() {
            function t() {
              if (this.isAvailable = false, this.isInstantiated = false, typeof jd < "u") {
                var e = rh();
                e && e.randomBytes && (this._crypto = e, this.isAvailable = true, this.isInstantiated = true);
              }
            }
            return t.prototype.randomBytes = function(e) {
              if (!this.isAvailable || !this._crypto)
                throw new Error("Node.js random byte generator is not available.");
              var r = this._crypto.randomBytes(e);
              if (r.length !== e)
                throw new Error("NodeRandomSource: got fewer bytes than requested");
              for (var n = new Uint8Array(e), i2 = 0; i2 < n.length; i2++)
                n[i2] = r[i2];
              return HNe.wipe(r), n;
            }, t;
          }();
          jk.NodeRandomSource = $Ne;
        });
        var yhe = A((Yk) => {
          "use strict";
          c();
          Object.defineProperty(Yk, "__esModule", { value: true });
          var GNe = phe(), WNe = mhe(), jNe = function() {
            function t() {
              if (this.isAvailable = false, this.name = "", this._source = new GNe.BrowserRandomSource(), this._source.isAvailable) {
                this.isAvailable = true, this.name = "Browser";
                return;
              }
              if (this._source = new WNe.NodeRandomSource(), this._source.isAvailable) {
                this.isAvailable = true, this.name = "Node";
                return;
              }
            }
            return t.prototype.randomBytes = function(e) {
              if (!this.isAvailable)
                throw new Error("System random byte generator is not available.");
              return this._source.randomBytes(e);
            }, t;
          }();
          Yk.SystemRandomSource = jNe;
        });
        var ghe = A((Lo) => {
          "use strict";
          c();
          Object.defineProperty(Lo, "__esModule", { value: true });
          function YNe(t, e) {
            var r = t >>> 16 & 65535, n = t & 65535, i2 = e >>> 16 & 65535, o = e & 65535;
            return n * o + (r * o + n * i2 << 16 >>> 0) | 0;
          }
          Lo.mul = Math.imul || YNe;
          function QNe(t, e) {
            return t + e | 0;
          }
          Lo.add = QNe;
          function XNe(t, e) {
            return t - e | 0;
          }
          Lo.sub = XNe;
          function ZNe(t, e) {
            return t << e | t >>> 32 - e;
          }
          Lo.rotl = ZNe;
          function JNe(t, e) {
            return t << 32 - e | t >>> e;
          }
          Lo.rotr = JNe;
          function eOe(t) {
            return typeof t == "number" && isFinite(t) && Math.floor(t) === t;
          }
          Lo.isInteger = Number.isInteger || eOe;
          Lo.MAX_SAFE_INTEGER = 9007199254740991;
          Lo.isSafeInteger = function(t) {
            return Lo.isInteger(t) && t >= -Lo.MAX_SAFE_INTEGER && t <= Lo.MAX_SAFE_INTEGER;
          };
        });
        var s4 = A((Et) => {
          "use strict";
          c();
          Object.defineProperty(Et, "__esModule", { value: true });
          var whe = ghe();
          function tOe(t, e) {
            return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
          }
          Et.readInt16BE = tOe;
          function rOe(t, e) {
            return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
          }
          Et.readUint16BE = rOe;
          function nOe(t, e) {
            return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
          }
          Et.readInt16LE = nOe;
          function iOe(t, e) {
            return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
          }
          Et.readUint16LE = iOe;
          function Ehe(t, e, r) {
            return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
          }
          Et.writeUint16BE = Ehe;
          Et.writeInt16BE = Ehe;
          function bhe(t, e, r) {
            return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
          }
          Et.writeUint16LE = bhe;
          Et.writeInt16LE = bhe;
          function Qk(t, e) {
            return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
          }
          Et.readInt32BE = Qk;
          function Xk(t, e) {
            return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
          }
          Et.readUint32BE = Xk;
          function Zk(t, e) {
            return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
          }
          Et.readInt32LE = Zk;
          function Jk(t, e) {
            return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
          }
          Et.readUint32LE = Jk;
          function Wv(t, e, r) {
            return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
          }
          Et.writeUint32BE = Wv;
          Et.writeInt32BE = Wv;
          function jv(t, e, r) {
            return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
          }
          Et.writeUint32LE = jv;
          Et.writeInt32LE = jv;
          function oOe(t, e) {
            e === void 0 && (e = 0);
            var r = Qk(t, e), n = Qk(t, e + 4);
            return r * 4294967296 + n - (n >> 31) * 4294967296;
          }
          Et.readInt64BE = oOe;
          function sOe(t, e) {
            e === void 0 && (e = 0);
            var r = Xk(t, e), n = Xk(t, e + 4);
            return r * 4294967296 + n;
          }
          Et.readUint64BE = sOe;
          function aOe(t, e) {
            e === void 0 && (e = 0);
            var r = Zk(t, e), n = Zk(t, e + 4);
            return n * 4294967296 + r - (r >> 31) * 4294967296;
          }
          Et.readInt64LE = aOe;
          function cOe(t, e) {
            e === void 0 && (e = 0);
            var r = Jk(t, e), n = Jk(t, e + 4);
            return n * 4294967296 + r;
          }
          Et.readUint64LE = cOe;
          function _he(t, e, r) {
            return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Wv(t / 4294967296 >>> 0, e, r), Wv(t >>> 0, e, r + 4), e;
          }
          Et.writeUint64BE = _he;
          Et.writeInt64BE = _he;
          function vhe(t, e, r) {
            return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), jv(t >>> 0, e, r), jv(t / 4294967296 >>> 0, e, r + 4), e;
          }
          Et.writeUint64LE = vhe;
          Et.writeInt64LE = vhe;
          function uOe(t, e, r) {
            if (r === void 0 && (r = 0), t % 8 !== 0)
              throw new Error("readUintBE supports only bitLengths divisible by 8");
            if (t / 8 > e.length - r)
              throw new Error("readUintBE: array is too short for the given bitLength");
            for (var n = 0, i2 = 1, o = t / 8 + r - 1; o >= r; o--)
              n += e[o] * i2, i2 *= 256;
            return n;
          }
          Et.readUintBE = uOe;
          function lOe(t, e, r) {
            if (r === void 0 && (r = 0), t % 8 !== 0)
              throw new Error("readUintLE supports only bitLengths divisible by 8");
            if (t / 8 > e.length - r)
              throw new Error("readUintLE: array is too short for the given bitLength");
            for (var n = 0, i2 = 1, o = r; o < r + t / 8; o++)
              n += e[o] * i2, i2 *= 256;
            return n;
          }
          Et.readUintLE = lOe;
          function fOe(t, e, r, n) {
            if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
              throw new Error("writeUintBE supports only bitLengths divisible by 8");
            if (!whe.isSafeInteger(e))
              throw new Error("writeUintBE value must be an integer");
            for (var i2 = 1, o = t / 8 + n - 1; o >= n; o--)
              r[o] = e / i2 & 255, i2 *= 256;
            return r;
          }
          Et.writeUintBE = fOe;
          function hOe(t, e, r, n) {
            if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
              throw new Error("writeUintLE supports only bitLengths divisible by 8");
            if (!whe.isSafeInteger(e))
              throw new Error("writeUintLE value must be an integer");
            for (var i2 = 1, o = n; o < n + t / 8; o++)
              r[o] = e / i2 & 255, i2 *= 256;
            return r;
          }
          Et.writeUintLE = hOe;
          function dOe(t, e) {
            e === void 0 && (e = 0);
            var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
            return r.getFloat32(e);
          }
          Et.readFloat32BE = dOe;
          function pOe(t, e) {
            e === void 0 && (e = 0);
            var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
            return r.getFloat32(e, true);
          }
          Et.readFloat32LE = pOe;
          function mOe(t, e) {
            e === void 0 && (e = 0);
            var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
            return r.getFloat64(e);
          }
          Et.readFloat64BE = mOe;
          function yOe(t, e) {
            e === void 0 && (e = 0);
            var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
            return r.getFloat64(e, true);
          }
          Et.readFloat64LE = yOe;
          function gOe(t, e, r) {
            e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
            var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
            return n.setFloat32(r, t), e;
          }
          Et.writeFloat32BE = gOe;
          function wOe(t, e, r) {
            e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
            var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
            return n.setFloat32(r, t, true), e;
          }
          Et.writeFloat32LE = wOe;
          function EOe(t, e, r) {
            e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
            var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
            return n.setFloat64(r, t), e;
          }
          Et.writeFloat64BE = EOe;
          function bOe(t, e, r) {
            e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
            var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
            return n.setFloat64(r, t, true), e;
          }
          Et.writeFloat64LE = bOe;
        });
        var Ahe = A((ca) => {
          "use strict";
          c();
          Object.defineProperty(ca, "__esModule", { value: true });
          var _Oe = yhe(), vOe = s4(), She = lc();
          ca.defaultRandomSource = new _Oe.SystemRandomSource();
          function eN(t, e) {
            return e === void 0 && (e = ca.defaultRandomSource), e.randomBytes(t);
          }
          ca.randomBytes = eN;
          function SOe(t) {
            t === void 0 && (t = ca.defaultRandomSource);
            var e = eN(4, t), r = vOe.readUint32LE(e);
            return She.wipe(e), r;
          }
          ca.randomUint32 = SOe;
          var xhe = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          function Rhe(t, e, r) {
            if (e === void 0 && (e = xhe), r === void 0 && (r = ca.defaultRandomSource), e.length < 2)
              throw new Error("randomString charset is too short");
            if (e.length > 256)
              throw new Error("randomString charset is too long");
            for (var n = "", i2 = e.length, o = 256 - 256 % i2; t > 0; ) {
              for (var s = eN(Math.ceil(t * 256 / o), r), a = 0; a < s.length && t > 0; a++) {
                var u = s[a];
                u < o && (n += e.charAt(u % i2), t--);
              }
              She.wipe(s);
            }
            return n;
          }
          ca.randomString = Rhe;
          function xOe(t, e, r) {
            e === void 0 && (e = xhe), r === void 0 && (r = ca.defaultRandomSource);
            var n = Math.ceil(t / (Math.log(e.length) / Math.LN2));
            return Rhe(n, e, r);
          }
          ca.randomStringForEntropy = xOe;
        });
        var Phe = A((Ji) => {
          "use strict";
          c();
          Object.defineProperty(Ji, "__esModule", { value: true });
          var ROe = Ahe(), AOe = lc();
          Ji.PUBLIC_KEY_LENGTH = 32;
          Ji.SECRET_KEY_LENGTH = 32;
          Ji.SHARED_KEY_LENGTH = 32;
          function hc(t) {
            var e = new Float64Array(16);
            if (t)
              for (var r = 0; r < t.length; r++)
                e[r] = t[r];
            return e;
          }
          var The = new Uint8Array(32);
          The[0] = 9;
          var TOe = hc([56129, 1]);
          function tN(t) {
            for (var e = 1, r = 0; r < 16; r++) {
              var n = t[r] + e + 65535;
              e = Math.floor(n / 65536), t[r] = n - e * 65536;
            }
            t[0] += e - 1 + 37 * (e - 1);
          }
          function a4(t, e, r) {
            for (var n = ~(r - 1), i2 = 0; i2 < 16; i2++) {
              var o = n & (t[i2] ^ e[i2]);
              t[i2] ^= o, e[i2] ^= o;
            }
          }
          function IOe(t, e) {
            for (var r = hc(), n = hc(), i2 = 0; i2 < 16; i2++)
              n[i2] = e[i2];
            tN(n), tN(n), tN(n);
            for (var o = 0; o < 2; o++) {
              r[0] = n[0] - 65517;
              for (var i2 = 1; i2 < 15; i2++)
                r[i2] = n[i2] - 65535 - (r[i2 - 1] >> 16 & 1), r[i2 - 1] &= 65535;
              r[15] = n[15] - 32767 - (r[14] >> 16 & 1);
              var s = r[15] >> 16 & 1;
              r[14] &= 65535, a4(n, r, 1 - s);
            }
            for (var i2 = 0; i2 < 16; i2++)
              t[2 * i2] = n[i2] & 255, t[2 * i2 + 1] = n[i2] >> 8;
          }
          function COe(t, e) {
            for (var r = 0; r < 16; r++)
              t[r] = e[2 * r] + (e[2 * r + 1] << 8);
            t[15] &= 32767;
          }
          function Yv(t, e, r) {
            for (var n = 0; n < 16; n++)
              t[n] = e[n] + r[n];
          }
          function Qv(t, e, r) {
            for (var n = 0; n < 16; n++)
              t[n] = e[n] - r[n];
          }
          function Cu(t, e, r) {
            var n, i2, o = 0, s = 0, a = 0, u = 0, l = 0, f = 0, h = 0, p = 0, d = 0, m = 0, y = 0, g = 0, E = 0, b = 0, v = 0, S = 0, x = 0, T = 0, R = 0, O = 0, F = 0, z = 0, W = 0, se = 0, re2 = 0, Ge = 0, ge = 0, ke = 0, H = 0, $e = 0, or3 = 0, nt = r[0], it = r[1], J = r[2], fe = r[3], ce = r[4], Pe = r[5], Me = r[6], Be = r[7], $t = r[8], sr = r[9], et = r[10], ft = r[11], ar = r[12], Ur = r[13], Jr = r[14], en = r[15];
            n = e[0], o += n * nt, s += n * it, a += n * J, u += n * fe, l += n * ce, f += n * Pe, h += n * Me, p += n * Be, d += n * $t, m += n * sr, y += n * et, g += n * ft, E += n * ar, b += n * Ur, v += n * Jr, S += n * en, n = e[1], s += n * nt, a += n * it, u += n * J, l += n * fe, f += n * ce, h += n * Pe, p += n * Me, d += n * Be, m += n * $t, y += n * sr, g += n * et, E += n * ft, b += n * ar, v += n * Ur, S += n * Jr, x += n * en, n = e[2], a += n * nt, u += n * it, l += n * J, f += n * fe, h += n * ce, p += n * Pe, d += n * Me, m += n * Be, y += n * $t, g += n * sr, E += n * et, b += n * ft, v += n * ar, S += n * Ur, x += n * Jr, T += n * en, n = e[3], u += n * nt, l += n * it, f += n * J, h += n * fe, p += n * ce, d += n * Pe, m += n * Me, y += n * Be, g += n * $t, E += n * sr, b += n * et, v += n * ft, S += n * ar, x += n * Ur, T += n * Jr, R += n * en, n = e[4], l += n * nt, f += n * it, h += n * J, p += n * fe, d += n * ce, m += n * Pe, y += n * Me, g += n * Be, E += n * $t, b += n * sr, v += n * et, S += n * ft, x += n * ar, T += n * Ur, R += n * Jr, O += n * en, n = e[5], f += n * nt, h += n * it, p += n * J, d += n * fe, m += n * ce, y += n * Pe, g += n * Me, E += n * Be, b += n * $t, v += n * sr, S += n * et, x += n * ft, T += n * ar, R += n * Ur, O += n * Jr, F += n * en, n = e[6], h += n * nt, p += n * it, d += n * J, m += n * fe, y += n * ce, g += n * Pe, E += n * Me, b += n * Be, v += n * $t, S += n * sr, x += n * et, T += n * ft, R += n * ar, O += n * Ur, F += n * Jr, z += n * en, n = e[7], p += n * nt, d += n * it, m += n * J, y += n * fe, g += n * ce, E += n * Pe, b += n * Me, v += n * Be, S += n * $t, x += n * sr, T += n * et, R += n * ft, O += n * ar, F += n * Ur, z += n * Jr, W += n * en, n = e[8], d += n * nt, m += n * it, y += n * J, g += n * fe, E += n * ce, b += n * Pe, v += n * Me, S += n * Be, x += n * $t, T += n * sr, R += n * et, O += n * ft, F += n * ar, z += n * Ur, W += n * Jr, se += n * en, n = e[9], m += n * nt, y += n * it, g += n * J, E += n * fe, b += n * ce, v += n * Pe, S += n * Me, x += n * Be, T += n * $t, R += n * sr, O += n * et, F += n * ft, z += n * ar, W += n * Ur, se += n * Jr, re2 += n * en, n = e[10], y += n * nt, g += n * it, E += n * J, b += n * fe, v += n * ce, S += n * Pe, x += n * Me, T += n * Be, R += n * $t, O += n * sr, F += n * et, z += n * ft, W += n * ar, se += n * Ur, re2 += n * Jr, Ge += n * en, n = e[11], g += n * nt, E += n * it, b += n * J, v += n * fe, S += n * ce, x += n * Pe, T += n * Me, R += n * Be, O += n * $t, F += n * sr, z += n * et, W += n * ft, se += n * ar, re2 += n * Ur, Ge += n * Jr, ge += n * en, n = e[12], E += n * nt, b += n * it, v += n * J, S += n * fe, x += n * ce, T += n * Pe, R += n * Me, O += n * Be, F += n * $t, z += n * sr, W += n * et, se += n * ft, re2 += n * ar, Ge += n * Ur, ge += n * Jr, ke += n * en, n = e[13], b += n * nt, v += n * it, S += n * J, x += n * fe, T += n * ce, R += n * Pe, O += n * Me, F += n * Be, z += n * $t, W += n * sr, se += n * et, re2 += n * ft, Ge += n * ar, ge += n * Ur, ke += n * Jr, H += n * en, n = e[14], v += n * nt, S += n * it, x += n * J, T += n * fe, R += n * ce, O += n * Pe, F += n * Me, z += n * Be, W += n * $t, se += n * sr, re2 += n * et, Ge += n * ft, ge += n * ar, ke += n * Ur, H += n * Jr, $e += n * en, n = e[15], S += n * nt, x += n * it, T += n * J, R += n * fe, O += n * ce, F += n * Pe, z += n * Me, W += n * Be, se += n * $t, re2 += n * sr, Ge += n * et, ge += n * ft, ke += n * ar, H += n * Ur, $e += n * Jr, or3 += n * en, o += 38 * x, s += 38 * T, a += 38 * R, u += 38 * O, l += 38 * F, f += 38 * z, h += 38 * W, p += 38 * se, d += 38 * re2, m += 38 * Ge, y += 38 * ge, g += 38 * ke, E += 38 * H, b += 38 * $e, v += 38 * or3, i2 = 1, n = o + i2 + 65535, i2 = Math.floor(n / 65536), o = n - i2 * 65536, n = s + i2 + 65535, i2 = Math.floor(n / 65536), s = n - i2 * 65536, n = a + i2 + 65535, i2 = Math.floor(n / 65536), a = n - i2 * 65536, n = u + i2 + 65535, i2 = Math.floor(n / 65536), u = n - i2 * 65536, n = l + i2 + 65535, i2 = Math.floor(n / 65536), l = n - i2 * 65536, n = f + i2 + 65535, i2 = Math.floor(n / 65536), f = n - i2 * 65536, n = h + i2 + 65535, i2 = Math.floor(n / 65536), h = n - i2 * 65536, n = p + i2 + 65535, i2 = Math.floor(n / 65536), p = n - i2 * 65536, n = d + i2 + 65535, i2 = Math.floor(n / 65536), d = n - i2 * 65536, n = m + i2 + 65535, i2 = Math.floor(n / 65536), m = n - i2 * 65536, n = y + i2 + 65535, i2 = Math.floor(n / 65536), y = n - i2 * 65536, n = g + i2 + 65535, i2 = Math.floor(n / 65536), g = n - i2 * 65536, n = E + i2 + 65535, i2 = Math.floor(n / 65536), E = n - i2 * 65536, n = b + i2 + 65535, i2 = Math.floor(n / 65536), b = n - i2 * 65536, n = v + i2 + 65535, i2 = Math.floor(n / 65536), v = n - i2 * 65536, n = S + i2 + 65535, i2 = Math.floor(n / 65536), S = n - i2 * 65536, o += i2 - 1 + 37 * (i2 - 1), i2 = 1, n = o + i2 + 65535, i2 = Math.floor(n / 65536), o = n - i2 * 65536, n = s + i2 + 65535, i2 = Math.floor(n / 65536), s = n - i2 * 65536, n = a + i2 + 65535, i2 = Math.floor(n / 65536), a = n - i2 * 65536, n = u + i2 + 65535, i2 = Math.floor(n / 65536), u = n - i2 * 65536, n = l + i2 + 65535, i2 = Math.floor(n / 65536), l = n - i2 * 65536, n = f + i2 + 65535, i2 = Math.floor(n / 65536), f = n - i2 * 65536, n = h + i2 + 65535, i2 = Math.floor(n / 65536), h = n - i2 * 65536, n = p + i2 + 65535, i2 = Math.floor(n / 65536), p = n - i2 * 65536, n = d + i2 + 65535, i2 = Math.floor(n / 65536), d = n - i2 * 65536, n = m + i2 + 65535, i2 = Math.floor(n / 65536), m = n - i2 * 65536, n = y + i2 + 65535, i2 = Math.floor(n / 65536), y = n - i2 * 65536, n = g + i2 + 65535, i2 = Math.floor(n / 65536), g = n - i2 * 65536, n = E + i2 + 65535, i2 = Math.floor(n / 65536), E = n - i2 * 65536, n = b + i2 + 65535, i2 = Math.floor(n / 65536), b = n - i2 * 65536, n = v + i2 + 65535, i2 = Math.floor(n / 65536), v = n - i2 * 65536, n = S + i2 + 65535, i2 = Math.floor(n / 65536), S = n - i2 * 65536, o += i2 - 1 + 37 * (i2 - 1), t[0] = o, t[1] = s, t[2] = a, t[3] = u, t[4] = l, t[5] = f, t[6] = h, t[7] = p, t[8] = d, t[9] = m, t[10] = y, t[11] = g, t[12] = E, t[13] = b, t[14] = v, t[15] = S;
          }
          function c4(t, e) {
            Cu(t, e, e);
          }
          function POe(t, e) {
            for (var r = hc(), n = 0; n < 16; n++)
              r[n] = e[n];
            for (var n = 253; n >= 0; n--)
              c4(r, r), n !== 2 && n !== 4 && Cu(r, r, e);
            for (var n = 0; n < 16; n++)
              t[n] = r[n];
          }
          function rN(t, e) {
            for (var r = new Uint8Array(32), n = new Float64Array(80), i2 = hc(), o = hc(), s = hc(), a = hc(), u = hc(), l = hc(), f = 0; f < 31; f++)
              r[f] = t[f];
            r[31] = t[31] & 127 | 64, r[0] &= 248, COe(n, e);
            for (var f = 0; f < 16; f++)
              o[f] = n[f];
            i2[0] = a[0] = 1;
            for (var f = 254; f >= 0; --f) {
              var h = r[f >>> 3] >>> (f & 7) & 1;
              a4(i2, o, h), a4(s, a, h), Yv(u, i2, s), Qv(i2, i2, s), Yv(s, o, a), Qv(o, o, a), c4(a, u), c4(l, i2), Cu(i2, s, i2), Cu(s, o, u), Yv(u, i2, s), Qv(i2, i2, s), c4(o, i2), Qv(s, a, l), Cu(i2, s, TOe), Yv(i2, i2, a), Cu(s, s, i2), Cu(i2, a, l), Cu(a, o, n), c4(o, u), a4(i2, o, h), a4(s, a, h);
            }
            for (var f = 0; f < 16; f++)
              n[f + 16] = i2[f], n[f + 32] = s[f], n[f + 48] = o[f], n[f + 64] = a[f];
            var p = n.subarray(32), d = n.subarray(16);
            POe(p, p), Cu(d, d, p);
            var m = new Uint8Array(32);
            return IOe(m, d), m;
          }
          Ji.scalarMult = rN;
          function Ihe(t) {
            return rN(t, The);
          }
          Ji.scalarMultBase = Ihe;
          function Che(t) {
            if (t.length !== Ji.SECRET_KEY_LENGTH)
              throw new Error("x25519: seed must be " + Ji.SECRET_KEY_LENGTH + " bytes");
            var e = new Uint8Array(t), r = Ihe(e);
            return { publicKey: r, secretKey: e };
          }
          Ji.generateKeyPairFromSeed = Che;
          function DOe(t) {
            var e = ROe.randomBytes(32, t), r = Che(e);
            return AOe.wipe(e), r;
          }
          Ji.generateKeyPair = DOe;
          function kOe(t, e, r) {
            if (r === void 0 && (r = false), t.length !== Ji.PUBLIC_KEY_LENGTH)
              throw new Error("X25519: incorrect secret key length");
            if (e.length !== Ji.PUBLIC_KEY_LENGTH)
              throw new Error("X25519: incorrect public key length");
            var n = rN(t, e);
            if (r) {
              for (var i2 = 0, o = 0; o < n.length; o++)
                i2 |= n[o];
              if (i2 === 0)
                throw new Error("X25519: invalid shared key");
            }
            return n;
          }
          Ji.sharedKey = kOe;
        });
        var khe = A((Af) => {
          "use strict";
          c();
          Object.defineProperty(Af, "__esModule", { value: true });
          var Zv = s4(), Xv = lc();
          Af.DIGEST_LENGTH = 32;
          Af.BLOCK_SIZE = 64;
          var Dhe = function() {
            function t() {
              this.digestLength = Af.DIGEST_LENGTH, this.blockSize = Af.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = false, this.reset();
            }
            return t.prototype._initState = function() {
              this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
            }, t.prototype.reset = function() {
              return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = false, this;
            }, t.prototype.clean = function() {
              Xv.wipe(this._buffer), Xv.wipe(this._temp), this.reset();
            }, t.prototype.update = function(e, r) {
              if (r === void 0 && (r = e.length), this._finished)
                throw new Error("SHA256: can't update because hash was finished.");
              var n = 0;
              if (this._bytesHashed += r, this._bufferLength > 0) {
                for (; this._bufferLength < this.blockSize && r > 0; )
                  this._buffer[this._bufferLength++] = e[n++], r--;
                this._bufferLength === this.blockSize && (nN(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
              }
              for (r >= this.blockSize && (n = nN(this._temp, this._state, e, n, r), r %= this.blockSize); r > 0; )
                this._buffer[this._bufferLength++] = e[n++], r--;
              return this;
            }, t.prototype.finish = function(e) {
              if (!this._finished) {
                var r = this._bytesHashed, n = this._bufferLength, i2 = r / 536870912 | 0, o = r << 3, s = r % 64 < 56 ? 64 : 128;
                this._buffer[n] = 128;
                for (var a = n + 1; a < s - 8; a++)
                  this._buffer[a] = 0;
                Zv.writeUint32BE(i2, this._buffer, s - 8), Zv.writeUint32BE(o, this._buffer, s - 4), nN(this._temp, this._state, this._buffer, 0, s), this._finished = true;
              }
              for (var a = 0; a < this.digestLength / 4; a++)
                Zv.writeUint32BE(this._state[a], e, a * 4);
              return this;
            }, t.prototype.digest = function() {
              var e = new Uint8Array(this.digestLength);
              return this.finish(e), e;
            }, t.prototype.saveState = function() {
              if (this._finished)
                throw new Error("SHA256: cannot save finished state");
              return { state: new Int32Array(this._state), buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0, bufferLength: this._bufferLength, bytesHashed: this._bytesHashed };
            }, t.prototype.restoreState = function(e) {
              return this._state.set(e.state), this._bufferLength = e.bufferLength, e.buffer && this._buffer.set(e.buffer), this._bytesHashed = e.bytesHashed, this._finished = false, this;
            }, t.prototype.cleanSavedState = function(e) {
              Xv.wipe(e.state), e.buffer && Xv.wipe(e.buffer), e.bufferLength = 0, e.bytesHashed = 0;
            }, t;
          }();
          Af.SHA256 = Dhe;
          var NOe = new Int32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
          function nN(t, e, r, n, i2) {
            for (; i2 >= 64; ) {
              for (var o = e[0], s = e[1], a = e[2], u = e[3], l = e[4], f = e[5], h = e[6], p = e[7], d = 0; d < 16; d++) {
                var m = n + d * 4;
                t[d] = Zv.readUint32BE(r, m);
              }
              for (var d = 16; d < 64; d++) {
                var y = t[d - 2], g = (y >>> 17 | y << 32 - 17) ^ (y >>> 19 | y << 32 - 19) ^ y >>> 10;
                y = t[d - 15];
                var E = (y >>> 7 | y << 32 - 7) ^ (y >>> 18 | y << 32 - 18) ^ y >>> 3;
                t[d] = (g + t[d - 7] | 0) + (E + t[d - 16] | 0);
              }
              for (var d = 0; d < 64; d++) {
                var g = (((l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7)) + (l & f ^ ~l & h) | 0) + (p + (NOe[d] + t[d] | 0) | 0) | 0, E = ((o >>> 2 | o << 32 - 2) ^ (o >>> 13 | o << 32 - 13) ^ (o >>> 22 | o << 32 - 22)) + (o & s ^ o & a ^ s & a) | 0;
                p = h, h = f, f = l, l = u + g | 0, u = a, a = s, s = o, o = g + E | 0;
              }
              e[0] += o, e[1] += s, e[2] += a, e[3] += u, e[4] += l, e[5] += f, e[6] += h, e[7] += p, n += 64, i2 -= 64;
            }
            return n;
          }
          function OOe(t) {
            var e = new Dhe();
            e.update(t);
            var r = e.digest();
            return e.clean(), r;
          }
          Af.hash = OOe;
        });
        var Ohe = A((Jv) => {
          "use strict";
          c();
          Object.defineProperty(Jv, "__esModule", { value: true });
          var bi = s4(), iN = lc(), LOe = 20;
          function BOe(t, e, r) {
            for (var n = 1634760805, i2 = 857760878, o = 2036477234, s = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], u = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], l = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], f = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], h = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], p = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], d = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], m = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], y = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], g = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], E = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], b = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], v = n, S = i2, x = o, T = s, R = a, O = u, F = l, z = f, W = h, se = p, re2 = d, Ge = m, ge = y, ke = g, H = E, $e = b, or3 = 0; or3 < LOe; or3 += 2)
              v = v + R | 0, ge ^= v, ge = ge >>> 32 - 16 | ge << 16, W = W + ge | 0, R ^= W, R = R >>> 32 - 12 | R << 12, S = S + O | 0, ke ^= S, ke = ke >>> 32 - 16 | ke << 16, se = se + ke | 0, O ^= se, O = O >>> 32 - 12 | O << 12, x = x + F | 0, H ^= x, H = H >>> 32 - 16 | H << 16, re2 = re2 + H | 0, F ^= re2, F = F >>> 32 - 12 | F << 12, T = T + z | 0, $e ^= T, $e = $e >>> 32 - 16 | $e << 16, Ge = Ge + $e | 0, z ^= Ge, z = z >>> 32 - 12 | z << 12, x = x + F | 0, H ^= x, H = H >>> 32 - 8 | H << 8, re2 = re2 + H | 0, F ^= re2, F = F >>> 32 - 7 | F << 7, T = T + z | 0, $e ^= T, $e = $e >>> 32 - 8 | $e << 8, Ge = Ge + $e | 0, z ^= Ge, z = z >>> 32 - 7 | z << 7, S = S + O | 0, ke ^= S, ke = ke >>> 32 - 8 | ke << 8, se = se + ke | 0, O ^= se, O = O >>> 32 - 7 | O << 7, v = v + R | 0, ge ^= v, ge = ge >>> 32 - 8 | ge << 8, W = W + ge | 0, R ^= W, R = R >>> 32 - 7 | R << 7, v = v + O | 0, $e ^= v, $e = $e >>> 32 - 16 | $e << 16, re2 = re2 + $e | 0, O ^= re2, O = O >>> 32 - 12 | O << 12, S = S + F | 0, ge ^= S, ge = ge >>> 32 - 16 | ge << 16, Ge = Ge + ge | 0, F ^= Ge, F = F >>> 32 - 12 | F << 12, x = x + z | 0, ke ^= x, ke = ke >>> 32 - 16 | ke << 16, W = W + ke | 0, z ^= W, z = z >>> 32 - 12 | z << 12, T = T + R | 0, H ^= T, H = H >>> 32 - 16 | H << 16, se = se + H | 0, R ^= se, R = R >>> 32 - 12 | R << 12, x = x + z | 0, ke ^= x, ke = ke >>> 32 - 8 | ke << 8, W = W + ke | 0, z ^= W, z = z >>> 32 - 7 | z << 7, T = T + R | 0, H ^= T, H = H >>> 32 - 8 | H << 8, se = se + H | 0, R ^= se, R = R >>> 32 - 7 | R << 7, S = S + F | 0, ge ^= S, ge = ge >>> 32 - 8 | ge << 8, Ge = Ge + ge | 0, F ^= Ge, F = F >>> 32 - 7 | F << 7, v = v + O | 0, $e ^= v, $e = $e >>> 32 - 8 | $e << 8, re2 = re2 + $e | 0, O ^= re2, O = O >>> 32 - 7 | O << 7;
            bi.writeUint32LE(v + n | 0, t, 0), bi.writeUint32LE(S + i2 | 0, t, 4), bi.writeUint32LE(x + o | 0, t, 8), bi.writeUint32LE(T + s | 0, t, 12), bi.writeUint32LE(R + a | 0, t, 16), bi.writeUint32LE(O + u | 0, t, 20), bi.writeUint32LE(F + l | 0, t, 24), bi.writeUint32LE(z + f | 0, t, 28), bi.writeUint32LE(W + h | 0, t, 32), bi.writeUint32LE(se + p | 0, t, 36), bi.writeUint32LE(re2 + d | 0, t, 40), bi.writeUint32LE(Ge + m | 0, t, 44), bi.writeUint32LE(ge + y | 0, t, 48), bi.writeUint32LE(ke + g | 0, t, 52), bi.writeUint32LE(H + E | 0, t, 56), bi.writeUint32LE($e + b | 0, t, 60);
          }
          function Nhe(t, e, r, n, i2) {
            if (i2 === void 0 && (i2 = 0), t.length !== 32)
              throw new Error("ChaCha: key size must be 32 bytes");
            if (n.length < r.length)
              throw new Error("ChaCha: destination is shorter than source");
            var o, s;
            if (i2 === 0) {
              if (e.length !== 8 && e.length !== 12)
                throw new Error("ChaCha nonce must be 8 or 12 bytes");
              o = new Uint8Array(16), s = o.length - e.length, o.set(e, s);
            } else {
              if (e.length !== 16)
                throw new Error("ChaCha nonce with counter must be 16 bytes");
              o = e, s = i2;
            }
            for (var a = new Uint8Array(64), u = 0; u < r.length; u += 64) {
              BOe(a, o, t);
              for (var l = u; l < u + 64 && l < r.length; l++)
                n[l] = r[l] ^ a[l - u];
              UOe(o, 0, s);
            }
            return iN.wipe(a), i2 === 0 && iN.wipe(o), n;
          }
          Jv.streamXOR = Nhe;
          function MOe(t, e, r, n) {
            return n === void 0 && (n = 0), iN.wipe(r), Nhe(t, e, r, r, n);
          }
          Jv.stream = MOe;
          function UOe(t, e, r) {
            for (var n = 1; r--; )
              n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
            if (n > 0)
              throw new Error("ChaCha: counter overflow");
          }
        });
        var Bhe = A((Pu) => {
          "use strict";
          c();
          Object.defineProperty(Pu, "__esModule", { value: true });
          var FOe = Gv(), e7 = lc();
          Pu.DIGEST_LENGTH = 16;
          var Lhe = function() {
            function t(e) {
              this.digestLength = Pu.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = false;
              var r = e[0] | e[1] << 8;
              this._r[0] = r & 8191;
              var n = e[2] | e[3] << 8;
              this._r[1] = (r >>> 13 | n << 3) & 8191;
              var i2 = e[4] | e[5] << 8;
              this._r[2] = (n >>> 10 | i2 << 6) & 7939;
              var o = e[6] | e[7] << 8;
              this._r[3] = (i2 >>> 7 | o << 9) & 8191;
              var s = e[8] | e[9] << 8;
              this._r[4] = (o >>> 4 | s << 12) & 255, this._r[5] = s >>> 1 & 8190;
              var a = e[10] | e[11] << 8;
              this._r[6] = (s >>> 14 | a << 2) & 8191;
              var u = e[12] | e[13] << 8;
              this._r[7] = (a >>> 11 | u << 5) & 8065;
              var l = e[14] | e[15] << 8;
              this._r[8] = (u >>> 8 | l << 8) & 8191, this._r[9] = l >>> 5 & 127, this._pad[0] = e[16] | e[17] << 8, this._pad[1] = e[18] | e[19] << 8, this._pad[2] = e[20] | e[21] << 8, this._pad[3] = e[22] | e[23] << 8, this._pad[4] = e[24] | e[25] << 8, this._pad[5] = e[26] | e[27] << 8, this._pad[6] = e[28] | e[29] << 8, this._pad[7] = e[30] | e[31] << 8;
            }
            return t.prototype._blocks = function(e, r, n) {
              for (var i2 = this._fin ? 0 : 2048, o = this._h[0], s = this._h[1], a = this._h[2], u = this._h[3], l = this._h[4], f = this._h[5], h = this._h[6], p = this._h[7], d = this._h[8], m = this._h[9], y = this._r[0], g = this._r[1], E = this._r[2], b = this._r[3], v = this._r[4], S = this._r[5], x = this._r[6], T = this._r[7], R = this._r[8], O = this._r[9]; n >= 16; ) {
                var F = e[r + 0] | e[r + 1] << 8;
                o += F & 8191;
                var z = e[r + 2] | e[r + 3] << 8;
                s += (F >>> 13 | z << 3) & 8191;
                var W = e[r + 4] | e[r + 5] << 8;
                a += (z >>> 10 | W << 6) & 8191;
                var se = e[r + 6] | e[r + 7] << 8;
                u += (W >>> 7 | se << 9) & 8191;
                var re2 = e[r + 8] | e[r + 9] << 8;
                l += (se >>> 4 | re2 << 12) & 8191, f += re2 >>> 1 & 8191;
                var Ge = e[r + 10] | e[r + 11] << 8;
                h += (re2 >>> 14 | Ge << 2) & 8191;
                var ge = e[r + 12] | e[r + 13] << 8;
                p += (Ge >>> 11 | ge << 5) & 8191;
                var ke = e[r + 14] | e[r + 15] << 8;
                d += (ge >>> 8 | ke << 8) & 8191, m += ke >>> 5 | i2;
                var H = 0, $e = H;
                $e += o * y, $e += s * (5 * O), $e += a * (5 * R), $e += u * (5 * T), $e += l * (5 * x), H = $e >>> 13, $e &= 8191, $e += f * (5 * S), $e += h * (5 * v), $e += p * (5 * b), $e += d * (5 * E), $e += m * (5 * g), H += $e >>> 13, $e &= 8191;
                var or3 = H;
                or3 += o * g, or3 += s * y, or3 += a * (5 * O), or3 += u * (5 * R), or3 += l * (5 * T), H = or3 >>> 13, or3 &= 8191, or3 += f * (5 * x), or3 += h * (5 * S), or3 += p * (5 * v), or3 += d * (5 * b), or3 += m * (5 * E), H += or3 >>> 13, or3 &= 8191;
                var nt = H;
                nt += o * E, nt += s * g, nt += a * y, nt += u * (5 * O), nt += l * (5 * R), H = nt >>> 13, nt &= 8191, nt += f * (5 * T), nt += h * (5 * x), nt += p * (5 * S), nt += d * (5 * v), nt += m * (5 * b), H += nt >>> 13, nt &= 8191;
                var it = H;
                it += o * b, it += s * E, it += a * g, it += u * y, it += l * (5 * O), H = it >>> 13, it &= 8191, it += f * (5 * R), it += h * (5 * T), it += p * (5 * x), it += d * (5 * S), it += m * (5 * v), H += it >>> 13, it &= 8191;
                var J = H;
                J += o * v, J += s * b, J += a * E, J += u * g, J += l * y, H = J >>> 13, J &= 8191, J += f * (5 * O), J += h * (5 * R), J += p * (5 * T), J += d * (5 * x), J += m * (5 * S), H += J >>> 13, J &= 8191;
                var fe = H;
                fe += o * S, fe += s * v, fe += a * b, fe += u * E, fe += l * g, H = fe >>> 13, fe &= 8191, fe += f * y, fe += h * (5 * O), fe += p * (5 * R), fe += d * (5 * T), fe += m * (5 * x), H += fe >>> 13, fe &= 8191;
                var ce = H;
                ce += o * x, ce += s * S, ce += a * v, ce += u * b, ce += l * E, H = ce >>> 13, ce &= 8191, ce += f * g, ce += h * y, ce += p * (5 * O), ce += d * (5 * R), ce += m * (5 * T), H += ce >>> 13, ce &= 8191;
                var Pe = H;
                Pe += o * T, Pe += s * x, Pe += a * S, Pe += u * v, Pe += l * b, H = Pe >>> 13, Pe &= 8191, Pe += f * E, Pe += h * g, Pe += p * y, Pe += d * (5 * O), Pe += m * (5 * R), H += Pe >>> 13, Pe &= 8191;
                var Me = H;
                Me += o * R, Me += s * T, Me += a * x, Me += u * S, Me += l * v, H = Me >>> 13, Me &= 8191, Me += f * b, Me += h * E, Me += p * g, Me += d * y, Me += m * (5 * O), H += Me >>> 13, Me &= 8191;
                var Be = H;
                Be += o * O, Be += s * R, Be += a * T, Be += u * x, Be += l * S, H = Be >>> 13, Be &= 8191, Be += f * v, Be += h * b, Be += p * E, Be += d * g, Be += m * y, H += Be >>> 13, Be &= 8191, H = (H << 2) + H | 0, H = H + $e | 0, $e = H & 8191, H = H >>> 13, or3 += H, o = $e, s = or3, a = nt, u = it, l = J, f = fe, h = ce, p = Pe, d = Me, m = Be, r += 16, n -= 16;
              }
              this._h[0] = o, this._h[1] = s, this._h[2] = a, this._h[3] = u, this._h[4] = l, this._h[5] = f, this._h[6] = h, this._h[7] = p, this._h[8] = d, this._h[9] = m;
            }, t.prototype.finish = function(e, r) {
              r === void 0 && (r = 0);
              var n = new Uint16Array(10), i2, o, s, a;
              if (this._leftover) {
                for (a = this._leftover, this._buffer[a++] = 1; a < 16; a++)
                  this._buffer[a] = 0;
                this._fin = 1, this._blocks(this._buffer, 0, 16);
              }
              for (i2 = this._h[1] >>> 13, this._h[1] &= 8191, a = 2; a < 10; a++)
                this._h[a] += i2, i2 = this._h[a] >>> 13, this._h[a] &= 8191;
              for (this._h[0] += i2 * 5, i2 = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += i2, i2 = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += i2, n[0] = this._h[0] + 5, i2 = n[0] >>> 13, n[0] &= 8191, a = 1; a < 10; a++)
                n[a] = this._h[a] + i2, i2 = n[a] >>> 13, n[a] &= 8191;
              for (n[9] -= 1 << 13, o = (i2 ^ 1) - 1, a = 0; a < 10; a++)
                n[a] &= o;
              for (o = ~o, a = 0; a < 10; a++)
                this._h[a] = this._h[a] & o | n[a];
              for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, s = this._h[0] + this._pad[0], this._h[0] = s & 65535, a = 1; a < 8; a++)
                s = (this._h[a] + this._pad[a] | 0) + (s >>> 16) | 0, this._h[a] = s & 65535;
              return e[r + 0] = this._h[0] >>> 0, e[r + 1] = this._h[0] >>> 8, e[r + 2] = this._h[1] >>> 0, e[r + 3] = this._h[1] >>> 8, e[r + 4] = this._h[2] >>> 0, e[r + 5] = this._h[2] >>> 8, e[r + 6] = this._h[3] >>> 0, e[r + 7] = this._h[3] >>> 8, e[r + 8] = this._h[4] >>> 0, e[r + 9] = this._h[4] >>> 8, e[r + 10] = this._h[5] >>> 0, e[r + 11] = this._h[5] >>> 8, e[r + 12] = this._h[6] >>> 0, e[r + 13] = this._h[6] >>> 8, e[r + 14] = this._h[7] >>> 0, e[r + 15] = this._h[7] >>> 8, this._finished = true, this;
            }, t.prototype.update = function(e) {
              var r = 0, n = e.length, i2;
              if (this._leftover) {
                i2 = 16 - this._leftover, i2 > n && (i2 = n);
                for (var o = 0; o < i2; o++)
                  this._buffer[this._leftover + o] = e[r + o];
                if (n -= i2, r += i2, this._leftover += i2, this._leftover < 16)
                  return this;
                this._blocks(this._buffer, 0, 16), this._leftover = 0;
              }
              if (n >= 16 && (i2 = n - n % 16, this._blocks(e, r, i2), r += i2, n -= i2), n) {
                for (var o = 0; o < n; o++)
                  this._buffer[this._leftover + o] = e[r + o];
                this._leftover += n;
              }
              return this;
            }, t.prototype.digest = function() {
              if (this._finished)
                throw new Error("Poly1305 was finished");
              var e = new Uint8Array(16);
              return this.finish(e), e;
            }, t.prototype.clean = function() {
              return e7.wipe(this._buffer), e7.wipe(this._r), e7.wipe(this._h), e7.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = true, this;
            }, t;
          }();
          Pu.Poly1305 = Lhe;
          function KOe(t, e) {
            var r = new Lhe(t);
            r.update(e);
            var n = r.digest();
            return r.clean(), n;
          }
          Pu.oneTimeAuth = KOe;
          function VOe(t, e) {
            return t.length !== Pu.DIGEST_LENGTH || e.length !== Pu.DIGEST_LENGTH ? false : FOe.equal(t, e);
          }
          Pu.equal = VOe;
        });
        var Fhe = A((Du) => {
          "use strict";
          c();
          Object.defineProperty(Du, "__esModule", { value: true });
          var t7 = Ohe(), qOe = Bhe(), u4 = lc(), Mhe = s4(), zOe = Gv();
          Du.KEY_LENGTH = 32;
          Du.NONCE_LENGTH = 12;
          Du.TAG_LENGTH = 16;
          var Uhe = new Uint8Array(16), HOe = function() {
            function t(e) {
              if (this.nonceLength = Du.NONCE_LENGTH, this.tagLength = Du.TAG_LENGTH, e.length !== Du.KEY_LENGTH)
                throw new Error("ChaCha20Poly1305 needs 32-byte key");
              this._key = new Uint8Array(e);
            }
            return t.prototype.seal = function(e, r, n, i2) {
              if (e.length > 16)
                throw new Error("ChaCha20Poly1305: incorrect nonce length");
              var o = new Uint8Array(16);
              o.set(e, o.length - e.length);
              var s = new Uint8Array(32);
              t7.stream(this._key, o, s, 4);
              var a = r.length + this.tagLength, u;
              if (i2) {
                if (i2.length !== a)
                  throw new Error("ChaCha20Poly1305: incorrect destination length");
                u = i2;
              } else
                u = new Uint8Array(a);
              return t7.streamXOR(this._key, o, r, u, 4), this._authenticate(u.subarray(u.length - this.tagLength, u.length), s, u.subarray(0, u.length - this.tagLength), n), u4.wipe(o), u;
            }, t.prototype.open = function(e, r, n, i2) {
              if (e.length > 16)
                throw new Error("ChaCha20Poly1305: incorrect nonce length");
              if (r.length < this.tagLength)
                return null;
              var o = new Uint8Array(16);
              o.set(e, o.length - e.length);
              var s = new Uint8Array(32);
              t7.stream(this._key, o, s, 4);
              var a = new Uint8Array(this.tagLength);
              if (this._authenticate(a, s, r.subarray(0, r.length - this.tagLength), n), !zOe.equal(a, r.subarray(r.length - this.tagLength, r.length)))
                return null;
              var u = r.length - this.tagLength, l;
              if (i2) {
                if (i2.length !== u)
                  throw new Error("ChaCha20Poly1305: incorrect destination length");
                l = i2;
              } else
                l = new Uint8Array(u);
              return t7.streamXOR(this._key, o, r.subarray(0, r.length - this.tagLength), l, 4), u4.wipe(o), l;
            }, t.prototype.clean = function() {
              return u4.wipe(this._key), this;
            }, t.prototype._authenticate = function(e, r, n, i2) {
              var o = new qOe.Poly1305(r);
              i2 && (o.update(i2), i2.length % 16 > 0 && o.update(Uhe.subarray(i2.length % 16))), o.update(n), n.length % 16 > 0 && o.update(Uhe.subarray(n.length % 16));
              var s = new Uint8Array(8);
              i2 && Mhe.writeUint64LE(i2.length, s), o.update(s), Mhe.writeUint64LE(n.length, s), o.update(s);
              for (var a = o.digest(), u = 0; u < a.length; u++)
                e[u] = a[u];
              o.clean(), u4.wipe(a), u4.wipe(s);
            }, t;
          }();
          Du.ChaCha20Poly1305 = HOe;
        });
        var sde = A((ULt, ode) => {
          c();
          ode.exports = ide;
          var nde = 128, iLe = 127, oLe = ~iLe, sLe = Math.pow(2, 31);
          function ide(t, e, r) {
            e = e || [], r = r || 0;
            for (var n = r; t >= sLe; )
              e[r++] = t & 255 | nde, t /= 128;
            for (; t & oLe; )
              e[r++] = t & 255 | nde, t >>>= 7;
            return e[r] = t | 0, ide.bytes = r - n + 1, e;
          }
        });
        var ude = A((FLt, cde) => {
          c();
          cde.exports = cN;
          var aLe = 128, ade = 127;
          function cN(t, n) {
            var r = 0, n = n || 0, i2 = 0, o = n, s, a = t.length;
            do {
              if (o >= a)
                throw cN.bytes = 0, new RangeError("Could not decode varint");
              s = t[o++], r += i2 < 28 ? (s & ade) << i2 : (s & ade) * Math.pow(2, i2), i2 += 7;
            } while (s >= aLe);
            return cN.bytes = o - n, r;
          }
        });
        var fde = A((KLt, lde) => {
          c();
          var cLe = Math.pow(2, 7), uLe = Math.pow(2, 14), lLe = Math.pow(2, 21), fLe = Math.pow(2, 28), hLe = Math.pow(2, 35), dLe = Math.pow(2, 42), pLe = Math.pow(2, 49), mLe = Math.pow(2, 56), yLe = Math.pow(2, 63);
          lde.exports = function(t) {
            return t < cLe ? 1 : t < uLe ? 2 : t < lLe ? 3 : t < fLe ? 4 : t < hLe ? 5 : t < dLe ? 6 : t < pLe ? 7 : t < mLe ? 8 : t < yLe ? 9 : 10;
          };
        });
        var dde = A((VLt, hde) => {
          c();
          hde.exports = { encode: sde(), decode: ude(), encodingLength: fde() };
        });
        var yde = A((qLt, mde) => {
          "use strict";
          c();
          var pde = dde();
          mde.exports = (t) => {
            if (!(t instanceof Uint8Array))
              throw new Error("arg needs to be a Uint8Array");
            let e = [];
            for (; t.length > 0; ) {
              let r = pde.decode(t);
              e.push(r), t = t.slice(pde.decode.bytes);
            }
            return e;
          };
        });
        var kde = A((Pde, Dde) => {
          "use strict";
          c();
          var ALe = Math.exp;
          Pde = Dde.exports = function(e) {
            if (typeof e != "number")
              throw new Error("must provide a timespan to the moving average constructor");
            if (e <= 0)
              throw new Error("must provide a timespan > 0 to the moving average constructor");
            let r, n = 0, i2 = 0, o = 0, s, a = {};
            function u(l, f) {
              return 1 - ALe(-(l - f) / e);
            }
            return a.push = function(f, h) {
              if (s) {
                let p = u(f, s), d = h - r, m = p * d;
                r = p * h + (1 - p) * r, n = (1 - p) * (n + d * m), i2 = Math.sqrt(n), o = r + p * d;
              } else
                r = h;
              s = f;
            }, a.movingAverage = function() {
              return r;
            }, a.variance = function() {
              return n;
            }, a.deviation = function() {
              return i2;
            }, a.forecast = function() {
              return o;
            }, a;
          };
        });
        var FLe = {};
        ct(FLe, { create: () => BLe, globSource: () => MLe, urlSource: () => ULe });
        c();
        c();
        c();
        var tO = w(z7(), 1), Ze = tO.default;
        var Jde = w($7(), 1);
        c();
        var ya = w(Mi(), 1);
        Hr();
        si();
        ma();
        ya.default.formatters.b = (t) => t == null ? "undefined" : Ne.baseEncode(t);
        ya.default.formatters.t = (t) => t == null ? "undefined" : xt.baseEncode(t);
        ya.default.formatters.m = (t) => t == null ? "undefined" : to.baseEncode(t);
        ya.default.formatters.p = (t) => t == null ? "undefined" : t.toString();
        ya.default.formatters.c = (t) => t == null ? "undefined" : t.toString();
        ya.default.formatters.k = (t) => t == null ? "undefined" : t.toString();
        function C(t) {
          return Object.assign((0, ya.default)(t), { error: (0, ya.default)(`${t}:error`), trace: (0, ya.default)(`${t}:trace`) });
        }
        var I7 = w(K(), 1);
        c();
        var U4 = w(K(), 1);
        c();
        var gc = w(Ea(), 1), up = gc.default.Reader, m9 = gc.default.Writer, Ke = gc.default.util, Xn = gc.default.roots["ipfs-unixfs"] || (gc.default.roots["ipfs-unixfs"] = {}), uL = Xn.Data = (() => {
          function t(e) {
            if (this.blocksizes = [], e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.Type = 0, t.prototype.Data = Ke.newBuffer([]), t.prototype.filesize = Ke.Long ? Ke.Long.fromBits(0, 0, true) : 0, t.prototype.blocksizes = Ke.emptyArray, t.prototype.hashType = Ke.Long ? Ke.Long.fromBits(0, 0, true) : 0, t.prototype.fanout = Ke.Long ? Ke.Long.fromBits(0, 0, true) : 0, t.prototype.mode = 0, t.prototype.mtime = null, t.encode = function(r, n) {
            if (n || (n = m9.create()), n.uint32(8).int32(r.Type), r.Data != null && Object.hasOwnProperty.call(r, "Data") && n.uint32(18).bytes(r.Data), r.filesize != null && Object.hasOwnProperty.call(r, "filesize") && n.uint32(24).uint64(r.filesize), r.blocksizes != null && r.blocksizes.length)
              for (var i2 = 0; i2 < r.blocksizes.length; ++i2)
                n.uint32(32).uint64(r.blocksizes[i2]);
            return r.hashType != null && Object.hasOwnProperty.call(r, "hashType") && n.uint32(40).uint64(r.hashType), r.fanout != null && Object.hasOwnProperty.call(r, "fanout") && n.uint32(48).uint64(r.fanout), r.mode != null && Object.hasOwnProperty.call(r, "mode") && n.uint32(56).uint32(r.mode), r.mtime != null && Object.hasOwnProperty.call(r, "mtime") && Xn.UnixTime.encode(r.mtime, n.uint32(66).fork()).ldelim(), n;
          }, t.decode = function(r, n) {
            r instanceof up || (r = up.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new Xn.Data(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.Type = r.int32();
                  break;
                case 2:
                  o.Data = r.bytes();
                  break;
                case 3:
                  o.filesize = r.uint64();
                  break;
                case 4:
                  if (o.blocksizes && o.blocksizes.length || (o.blocksizes = []), (s & 7) === 2)
                    for (var a = r.uint32() + r.pos; r.pos < a; )
                      o.blocksizes.push(r.uint64());
                  else
                    o.blocksizes.push(r.uint64());
                  break;
                case 5:
                  o.hashType = r.uint64();
                  break;
                case 6:
                  o.fanout = r.uint64();
                  break;
                case 7:
                  o.mode = r.uint32();
                  break;
                case 8:
                  o.mtime = Xn.UnixTime.decode(r, r.uint32());
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            if (!o.hasOwnProperty("Type"))
              throw Ke.ProtocolError("missing required 'Type'", { instance: o });
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof Xn.Data)
              return r;
            var n = new Xn.Data();
            switch (r.Type) {
              case "Raw":
              case 0:
                n.Type = 0;
                break;
              case "Directory":
              case 1:
                n.Type = 1;
                break;
              case "File":
              case 2:
                n.Type = 2;
                break;
              case "Metadata":
              case 3:
                n.Type = 3;
                break;
              case "Symlink":
              case 4:
                n.Type = 4;
                break;
              case "HAMTShard":
              case 5:
                n.Type = 5;
                break;
            }
            if (r.Data != null && (typeof r.Data == "string" ? Ke.base64.decode(r.Data, n.Data = Ke.newBuffer(Ke.base64.length(r.Data)), 0) : r.Data.length && (n.Data = r.Data)), r.filesize != null && (Ke.Long ? (n.filesize = Ke.Long.fromValue(r.filesize)).unsigned = true : typeof r.filesize == "string" ? n.filesize = parseInt(r.filesize, 10) : typeof r.filesize == "number" ? n.filesize = r.filesize : typeof r.filesize == "object" && (n.filesize = new Ke.LongBits(r.filesize.low >>> 0, r.filesize.high >>> 0).toNumber(true))), r.blocksizes) {
              if (!Array.isArray(r.blocksizes))
                throw TypeError(".Data.blocksizes: array expected");
              n.blocksizes = [];
              for (var i2 = 0; i2 < r.blocksizes.length; ++i2)
                Ke.Long ? (n.blocksizes[i2] = Ke.Long.fromValue(r.blocksizes[i2])).unsigned = true : typeof r.blocksizes[i2] == "string" ? n.blocksizes[i2] = parseInt(r.blocksizes[i2], 10) : typeof r.blocksizes[i2] == "number" ? n.blocksizes[i2] = r.blocksizes[i2] : typeof r.blocksizes[i2] == "object" && (n.blocksizes[i2] = new Ke.LongBits(r.blocksizes[i2].low >>> 0, r.blocksizes[i2].high >>> 0).toNumber(true));
            }
            if (r.hashType != null && (Ke.Long ? (n.hashType = Ke.Long.fromValue(r.hashType)).unsigned = true : typeof r.hashType == "string" ? n.hashType = parseInt(r.hashType, 10) : typeof r.hashType == "number" ? n.hashType = r.hashType : typeof r.hashType == "object" && (n.hashType = new Ke.LongBits(r.hashType.low >>> 0, r.hashType.high >>> 0).toNumber(true))), r.fanout != null && (Ke.Long ? (n.fanout = Ke.Long.fromValue(r.fanout)).unsigned = true : typeof r.fanout == "string" ? n.fanout = parseInt(r.fanout, 10) : typeof r.fanout == "number" ? n.fanout = r.fanout : typeof r.fanout == "object" && (n.fanout = new Ke.LongBits(r.fanout.low >>> 0, r.fanout.high >>> 0).toNumber(true))), r.mode != null && (n.mode = r.mode >>> 0), r.mtime != null) {
              if (typeof r.mtime != "object")
                throw TypeError(".Data.mtime: object expected");
              n.mtime = Xn.UnixTime.fromObject(r.mtime);
            }
            return n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if ((n.arrays || n.defaults) && (i2.blocksizes = []), n.defaults) {
              if (i2.Type = n.enums === String ? "Raw" : 0, n.bytes === String ? i2.Data = "" : (i2.Data = [], n.bytes !== Array && (i2.Data = Ke.newBuffer(i2.Data))), Ke.Long) {
                var o = new Ke.Long(0, 0, true);
                i2.filesize = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o;
              } else
                i2.filesize = n.longs === String ? "0" : 0;
              if (Ke.Long) {
                var o = new Ke.Long(0, 0, true);
                i2.hashType = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o;
              } else
                i2.hashType = n.longs === String ? "0" : 0;
              if (Ke.Long) {
                var o = new Ke.Long(0, 0, true);
                i2.fanout = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o;
              } else
                i2.fanout = n.longs === String ? "0" : 0;
              i2.mode = 0, i2.mtime = null;
            }
            if (r.Type != null && r.hasOwnProperty("Type") && (i2.Type = n.enums === String ? Xn.Data.DataType[r.Type] : r.Type), r.Data != null && r.hasOwnProperty("Data") && (i2.Data = n.bytes === String ? Ke.base64.encode(r.Data, 0, r.Data.length) : n.bytes === Array ? Array.prototype.slice.call(r.Data) : r.Data), r.filesize != null && r.hasOwnProperty("filesize") && (typeof r.filesize == "number" ? i2.filesize = n.longs === String ? String(r.filesize) : r.filesize : i2.filesize = n.longs === String ? Ke.Long.prototype.toString.call(r.filesize) : n.longs === Number ? new Ke.LongBits(r.filesize.low >>> 0, r.filesize.high >>> 0).toNumber(true) : r.filesize), r.blocksizes && r.blocksizes.length) {
              i2.blocksizes = [];
              for (var s = 0; s < r.blocksizes.length; ++s)
                typeof r.blocksizes[s] == "number" ? i2.blocksizes[s] = n.longs === String ? String(r.blocksizes[s]) : r.blocksizes[s] : i2.blocksizes[s] = n.longs === String ? Ke.Long.prototype.toString.call(r.blocksizes[s]) : n.longs === Number ? new Ke.LongBits(r.blocksizes[s].low >>> 0, r.blocksizes[s].high >>> 0).toNumber(true) : r.blocksizes[s];
            }
            return r.hashType != null && r.hasOwnProperty("hashType") && (typeof r.hashType == "number" ? i2.hashType = n.longs === String ? String(r.hashType) : r.hashType : i2.hashType = n.longs === String ? Ke.Long.prototype.toString.call(r.hashType) : n.longs === Number ? new Ke.LongBits(r.hashType.low >>> 0, r.hashType.high >>> 0).toNumber(true) : r.hashType), r.fanout != null && r.hasOwnProperty("fanout") && (typeof r.fanout == "number" ? i2.fanout = n.longs === String ? String(r.fanout) : r.fanout : i2.fanout = n.longs === String ? Ke.Long.prototype.toString.call(r.fanout) : n.longs === Number ? new Ke.LongBits(r.fanout.low >>> 0, r.fanout.high >>> 0).toNumber(true) : r.fanout), r.mode != null && r.hasOwnProperty("mode") && (i2.mode = r.mode), r.mtime != null && r.hasOwnProperty("mtime") && (i2.mtime = Xn.UnixTime.toObject(r.mtime, n)), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, gc.default.util.toJSONOptions);
          }, t.DataType = function() {
            let e = {}, r = Object.create(e);
            return r[e[0] = "Raw"] = 0, r[e[1] = "Directory"] = 1, r[e[2] = "File"] = 2, r[e[3] = "Metadata"] = 3, r[e[4] = "Symlink"] = 4, r[e[5] = "HAMTShard"] = 5, r;
          }(), t;
        })(), IBe = Xn.UnixTime = (() => {
          function t(e) {
            if (e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.Seconds = Ke.Long ? Ke.Long.fromBits(0, 0, false) : 0, t.prototype.FractionalNanoseconds = 0, t.encode = function(r, n) {
            return n || (n = m9.create()), n.uint32(8).int64(r.Seconds), r.FractionalNanoseconds != null && Object.hasOwnProperty.call(r, "FractionalNanoseconds") && n.uint32(21).fixed32(r.FractionalNanoseconds), n;
          }, t.decode = function(r, n) {
            r instanceof up || (r = up.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new Xn.UnixTime(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.Seconds = r.int64();
                  break;
                case 2:
                  o.FractionalNanoseconds = r.fixed32();
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            if (!o.hasOwnProperty("Seconds"))
              throw Ke.ProtocolError("missing required 'Seconds'", { instance: o });
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof Xn.UnixTime)
              return r;
            var n = new Xn.UnixTime();
            return r.Seconds != null && (Ke.Long ? (n.Seconds = Ke.Long.fromValue(r.Seconds)).unsigned = false : typeof r.Seconds == "string" ? n.Seconds = parseInt(r.Seconds, 10) : typeof r.Seconds == "number" ? n.Seconds = r.Seconds : typeof r.Seconds == "object" && (n.Seconds = new Ke.LongBits(r.Seconds.low >>> 0, r.Seconds.high >>> 0).toNumber())), r.FractionalNanoseconds != null && (n.FractionalNanoseconds = r.FractionalNanoseconds >>> 0), n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if (n.defaults) {
              if (Ke.Long) {
                var o = new Ke.Long(0, 0, false);
                i2.Seconds = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o;
              } else
                i2.Seconds = n.longs === String ? "0" : 0;
              i2.FractionalNanoseconds = 0;
            }
            return r.Seconds != null && r.hasOwnProperty("Seconds") && (typeof r.Seconds == "number" ? i2.Seconds = n.longs === String ? String(r.Seconds) : r.Seconds : i2.Seconds = n.longs === String ? Ke.Long.prototype.toString.call(r.Seconds) : n.longs === Number ? new Ke.LongBits(r.Seconds.low >>> 0, r.Seconds.high >>> 0).toNumber() : r.Seconds), r.FractionalNanoseconds != null && r.hasOwnProperty("FractionalNanoseconds") && (i2.FractionalNanoseconds = r.FractionalNanoseconds), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, gc.default.util.toJSONOptions);
          }, t;
        })(), CBe = Xn.Metadata = (() => {
          function t(e) {
            if (e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.MimeType = "", t.encode = function(r, n) {
            return n || (n = m9.create()), r.MimeType != null && Object.hasOwnProperty.call(r, "MimeType") && n.uint32(10).string(r.MimeType), n;
          }, t.decode = function(r, n) {
            r instanceof up || (r = up.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new Xn.Metadata(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.MimeType = r.string();
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof Xn.Metadata)
              return r;
            var n = new Xn.Metadata();
            return r.MimeType != null && (n.MimeType = String(r.MimeType)), n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            return n.defaults && (i2.MimeType = ""), r.MimeType != null && r.hasOwnProperty("MimeType") && (i2.MimeType = r.MimeType), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, gc.default.util.toJSONOptions);
          }, t;
        })();
        var wc = uL, lL = ["raw", "directory", "file", "metadata", "symlink", "hamt-sharded-directory"], q0e = ["directory", "hamt-sharded-directory"], fL = parseInt("0644", 8), hL = parseInt("0755", 8);
        function Ec(t) {
          if (t != null)
            return typeof t == "number" ? t & 4095 : (t = t.toString(), t.substring(0, 1) === "0" ? parseInt(t, 8) & 4095 : parseInt(t, 10) & 4095);
        }
        function qu(t) {
          if (t == null)
            return;
          let e;
          if (t.secs != null && (e = { secs: t.secs, nsecs: t.nsecs }), t.Seconds != null && (e = { secs: t.Seconds, nsecs: t.FractionalNanoseconds }), Array.isArray(t) && (e = { secs: t[0], nsecs: t[1] }), t instanceof Date) {
            let r = t.getTime(), n = Math.floor(r / 1e3);
            e = { secs: n, nsecs: (r - n * 1e3) * 1e3 };
          }
          if (!!Object.prototype.hasOwnProperty.call(e, "secs")) {
            if (e != null && e.nsecs != null && (e.nsecs < 0 || e.nsecs > 999999999))
              throw (0, U4.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
            return e;
          }
        }
        var Je = class {
          static unmarshal(e) {
            let r = wc.decode(e), n = wc.toObject(r, { defaults: false, arrays: true, longs: Number, objects: false }), i2 = new Je({ type: lL[n.Type], data: n.Data, blockSizes: n.blocksizes, mode: n.mode, mtime: n.mtime ? { secs: n.mtime.Seconds, nsecs: n.mtime.FractionalNanoseconds } : void 0 });
            return i2._originalMode = n.mode || 0, i2;
          }
          constructor(e = { type: "file" }) {
            let { type: r, data: n, blockSizes: i2, hashType: o, fanout: s, mtime: a, mode: u } = e;
            if (r && !lL.includes(r))
              throw (0, U4.default)(new Error("Type: " + r + " is not valid"), "ERR_INVALID_TYPE");
            this.type = r || "file", this.data = n, this.hashType = o, this.fanout = s, this.blockSizes = i2 || [], this._originalMode = 0, this.mode = Ec(u), a && (this.mtime = qu(a), this.mtime && !this.mtime.nsecs && (this.mtime.nsecs = 0));
          }
          set mode(e) {
            this._mode = this.isDirectory() ? hL : fL;
            let r = Ec(e);
            r !== void 0 && (this._mode = r);
          }
          get mode() {
            return this._mode;
          }
          isDirectory() {
            return Boolean(this.type && q0e.includes(this.type));
          }
          addBlockSize(e) {
            this.blockSizes.push(e);
          }
          removeBlockSize(e) {
            this.blockSizes.splice(e, 1);
          }
          fileSize() {
            if (this.isDirectory())
              return 0;
            let e = 0;
            return this.blockSizes.forEach((r) => {
              e += r;
            }), this.data && (e += this.data.length), e;
          }
          marshal() {
            let e;
            switch (this.type) {
              case "raw":
                e = wc.DataType.Raw;
                break;
              case "directory":
                e = wc.DataType.Directory;
                break;
              case "file":
                e = wc.DataType.File;
                break;
              case "metadata":
                e = wc.DataType.Metadata;
                break;
              case "symlink":
                e = wc.DataType.Symlink;
                break;
              case "hamt-sharded-directory":
                e = wc.DataType.HAMTShard;
                break;
              default:
                throw (0, U4.default)(new Error("Type: " + e + " is not valid"), "ERR_INVALID_TYPE");
            }
            let r = this.data;
            (!this.data || !this.data.length) && (r = void 0);
            let n;
            this.mode != null && (n = this._originalMode & 4294963200 | (Ec(this.mode) || 0), n === fL && !this.isDirectory() && (n = void 0), n === hL && this.isDirectory() && (n = void 0));
            let i2;
            if (this.mtime != null) {
              let s = qu(this.mtime);
              s && (i2 = { Seconds: s.secs, FractionalNanoseconds: s.nsecs }, i2.FractionalNanoseconds === 0 && delete i2.FractionalNanoseconds);
            }
            let o = { Type: e, Data: r, filesize: this.isDirectory() ? void 0 : this.fileSize(), blocksizes: this.blockSizes, hashType: this.hashType, fanout: this.fanout, mode: n, mtime: i2 };
            return wc.encode(o).finish();
          }
        };
        var At = {};
        ct(At, { code: () => pt, createLink: () => IL, createNode: () => TL, decode: () => Rt, encode: () => je, name: () => x1e, prepare: () => Ln, validate: () => b9 });
        c();
        te();
        c();
        var p1e = new TextDecoder();
        function w9(t, e) {
          let r = 0;
          for (let n = 0; ; n += 7) {
            if (n >= 64)
              throw new Error("protobuf: varint overflow");
            if (e >= t.length)
              throw new Error("protobuf: unexpected end of data");
            let i2 = t[e++];
            if (r += n < 28 ? (i2 & 127) << n : (i2 & 127) * 2 ** n, i2 < 128)
              break;
          }
          return [r, e];
        }
        function z4(t, e) {
          let r;
          [r, e] = w9(t, e);
          let n = e + r;
          if (r < 0 || n < 0)
            throw new Error("protobuf: invalid length");
          if (n > t.length)
            throw new Error("protobuf: unexpected end of data");
          return [t.subarray(e, n), n];
        }
        function EL(t, e) {
          let r;
          return [r, e] = w9(t, e), [r & 7, r >> 3, e];
        }
        function m1e(t) {
          let e = {}, r = t.length, n = 0;
          for (; n < r; ) {
            let i2, o;
            if ([i2, o, n] = EL(t, n), o === 1) {
              if (e.Hash)
                throw new Error("protobuf: (PBLink) duplicate Hash section");
              if (i2 !== 2)
                throw new Error(`protobuf: (PBLink) wrong wireType (${i2}) for Hash`);
              if (e.Name !== void 0)
                throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
              if (e.Tsize !== void 0)
                throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
              [e.Hash, n] = z4(t, n);
            } else if (o === 2) {
              if (e.Name !== void 0)
                throw new Error("protobuf: (PBLink) duplicate Name section");
              if (i2 !== 2)
                throw new Error(`protobuf: (PBLink) wrong wireType (${i2}) for Name`);
              if (e.Tsize !== void 0)
                throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
              let s;
              [s, n] = z4(t, n), e.Name = p1e.decode(s);
            } else if (o === 3) {
              if (e.Tsize !== void 0)
                throw new Error("protobuf: (PBLink) duplicate Tsize section");
              if (i2 !== 0)
                throw new Error(`protobuf: (PBLink) wrong wireType (${i2}) for Tsize`);
              [e.Tsize, n] = w9(t, n);
            } else
              throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${o}`);
          }
          if (n > r)
            throw new Error("protobuf: (PBLink) unexpected end of data");
          return e;
        }
        function bL(t) {
          let e = t.length, r = 0, n, i2 = false, o;
          for (; r < e; ) {
            let a, u;
            if ([a, u, r] = EL(t, r), a !== 2)
              throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${a}`);
            if (u === 1) {
              if (o)
                throw new Error("protobuf: (PBNode) duplicate Data section");
              [o, r] = z4(t, r), n && (i2 = true);
            } else if (u === 2) {
              if (i2)
                throw new Error("protobuf: (PBNode) duplicate Links section");
              n || (n = []);
              let l;
              [l, r] = z4(t, r), n.push(m1e(l));
            } else
              throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${u}`);
          }
          if (r > e)
            throw new Error("protobuf: (PBNode) unexpected end of data");
          let s = {};
          return o && (s.Data = o), s.Links = n || [], s;
        }
        c();
        var vL = new TextEncoder(), _L = 2 ** 32, y1e = 2 ** 31;
        function g1e(t, e) {
          let r = e.length;
          if (typeof t.Tsize == "number") {
            if (t.Tsize < 0)
              throw new Error("Tsize cannot be negative");
            if (!Number.isSafeInteger(t.Tsize))
              throw new Error("Tsize too large for encoding");
            r = Qm(e, r, t.Tsize) - 1, e[r] = 24;
          }
          if (typeof t.Name == "string") {
            let n = vL.encode(t.Name);
            r -= n.length, e.set(n, r), r = Qm(e, r, n.length) - 1, e[r] = 18;
          }
          return t.Hash && (r -= t.Hash.length, e.set(t.Hash, r), r = Qm(e, r, t.Hash.length) - 1, e[r] = 10), e.length - r;
        }
        function SL(t) {
          let e = E1e(t), r = new Uint8Array(e), n = e;
          if (t.Data && (n -= t.Data.length, r.set(t.Data, n), n = Qm(r, n, t.Data.length) - 1, r[n] = 10), t.Links)
            for (let i2 = t.Links.length - 1; i2 >= 0; i2--) {
              let o = g1e(t.Links[i2], r.subarray(0, n));
              n -= o, n = Qm(r, n, o) - 1, r[n] = 18;
            }
          return r;
        }
        function w1e(t) {
          let e = 0;
          if (t.Hash) {
            let r = t.Hash.length;
            e += 1 + r + hp(r);
          }
          if (typeof t.Name == "string") {
            let r = vL.encode(t.Name).length;
            e += 1 + r + hp(r);
          }
          return typeof t.Tsize == "number" && (e += 1 + hp(t.Tsize)), e;
        }
        function E1e(t) {
          let e = 0;
          if (t.Data) {
            let r = t.Data.length;
            e += 1 + r + hp(r);
          }
          if (t.Links)
            for (let r of t.Links) {
              let n = w1e(r);
              e += 1 + n + hp(n);
            }
          return e;
        }
        function Qm(t, e, r) {
          e -= hp(r);
          let n = e;
          for (; r >= y1e; )
            t[e++] = r & 127 | 128, r /= 128;
          for (; r >= 128; )
            t[e++] = r & 127 | 128, r >>>= 7;
          return t[e] = r, n;
        }
        function hp(t) {
          return t % 2 === 0 && t++, Math.floor((b1e(t) + 6) / 7);
        }
        function b1e(t) {
          let e = 0;
          return t >= _L && (t = Math.floor(t / _L), e = 32), t >= 1 << 16 && (t >>>= 16, e += 16), t >= 1 << 8 && (t >>>= 8, e += 8), e + _1e[t];
        }
        var _1e = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8];
        c();
        te();
        var v1e = ["Data", "Links"], S1e = ["Hash", "Name", "Tsize"], E9 = new TextEncoder();
        function RL(t, e) {
          if (t === e)
            return 0;
          let r = t.Name ? E9.encode(t.Name) : [], n = e.Name ? E9.encode(e.Name) : [], i2 = r.length, o = n.length;
          for (let s = 0, a = Math.min(i2, o); s < a; ++s)
            if (r[s] !== n[s]) {
              i2 = r[s], o = n[s];
              break;
            }
          return i2 < o ? -1 : o < i2 ? 1 : 0;
        }
        function xL(t, e) {
          return !Object.keys(t).some((r) => !e.includes(r));
        }
        function AL(t) {
          if (typeof t.asCID == "object") {
            let r = I.asCID(t);
            if (!r)
              throw new TypeError("Invalid DAG-PB form");
            return { Hash: r };
          }
          if (typeof t != "object" || Array.isArray(t))
            throw new TypeError("Invalid DAG-PB form");
          let e = {};
          if (t.Hash) {
            let r = I.asCID(t.Hash);
            try {
              r || (typeof t.Hash == "string" ? r = I.parse(t.Hash) : t.Hash instanceof Uint8Array && (r = I.decode(t.Hash)));
            } catch (n) {
              throw new TypeError(`Invalid DAG-PB form: ${n.message}`);
            }
            r && (e.Hash = r);
          }
          if (!e.Hash)
            throw new TypeError("Invalid DAG-PB form");
          return typeof t.Name == "string" && (e.Name = t.Name), typeof t.Tsize == "number" && (e.Tsize = t.Tsize), e;
        }
        function Ln(t) {
          if ((t instanceof Uint8Array || typeof t == "string") && (t = { Data: t }), typeof t != "object" || Array.isArray(t))
            throw new TypeError("Invalid DAG-PB form");
          let e = {};
          if (t.Data !== void 0)
            if (typeof t.Data == "string")
              e.Data = E9.encode(t.Data);
            else if (t.Data instanceof Uint8Array)
              e.Data = t.Data;
            else
              throw new TypeError("Invalid DAG-PB form");
          if (t.Links !== void 0)
            if (Array.isArray(t.Links))
              e.Links = t.Links.map(AL), e.Links.sort(RL);
            else
              throw new TypeError("Invalid DAG-PB form");
          else
            e.Links = [];
          return e;
        }
        function b9(t) {
          if (!t || typeof t != "object" || Array.isArray(t))
            throw new TypeError("Invalid DAG-PB form");
          if (!xL(t, v1e))
            throw new TypeError("Invalid DAG-PB form (extraneous properties)");
          if (t.Data !== void 0 && !(t.Data instanceof Uint8Array))
            throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
          if (!Array.isArray(t.Links))
            throw new TypeError("Invalid DAG-PB form (Links must be an array)");
          for (let e = 0; e < t.Links.length; e++) {
            let r = t.Links[e];
            if (!r || typeof r != "object" || Array.isArray(r))
              throw new TypeError("Invalid DAG-PB form (bad link object)");
            if (!xL(r, S1e))
              throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
            if (!r.Hash)
              throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
            if (r.Hash.asCID !== r.Hash)
              throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
            if (r.Name !== void 0 && typeof r.Name != "string")
              throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
            if (r.Tsize !== void 0 && (typeof r.Tsize != "number" || r.Tsize % 1 !== 0))
              throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
            if (e > 0 && RL(r, t.Links[e - 1]) === -1)
              throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
          }
        }
        function TL(t, e = []) {
          return Ln({ Data: t, Links: e });
        }
        function IL(t, e, r) {
          return AL({ Hash: r, Name: t, Tsize: e });
        }
        var x1e = "dag-pb", pt = 112;
        function je(t) {
          b9(t);
          let e = {};
          return t.Links && (e.Links = t.Links.map((r) => {
            let n = {};
            return r.Hash && (n.Hash = r.Hash.bytes), r.Name !== void 0 && (n.Name = r.Name), r.Tsize !== void 0 && (n.Tsize = r.Tsize), n;
          })), t.Data && (e.Data = t.Data), SL(e);
        }
        function Rt(t) {
          let e = bL(t), r = {};
          return e.Data && (r.Data = e.Data), e.Links && (r.Links = e.Links.map((n) => {
            let i2 = {};
            try {
              i2.Hash = I.decode(n.Hash);
            } catch {
            }
            if (!i2.Hash)
              throw new Error("Invalid Hash field found in link, expected CID");
            return n.Name !== void 0 && (i2.Name = n.Name), n.Tsize !== void 0 && (i2.Tsize = n.Tsize), i2;
          })), r;
        }
        var vc = {};
        ct(vc, { code: () => qf, decode: () => zf, encode: () => U9, name: () => nme });
        c();
        Vf();
        te();
        var OB = 42;
        function Z1e(t) {
          if (t.asCID !== t)
            return null;
          let e = I.asCID(t);
          if (!e)
            return null;
          let r = new Uint8Array(e.bytes.byteLength + 1);
          return r.set(e.bytes, 1), [new Q(L.tag, OB), new Q(L.bytes, r)];
        }
        function J1e() {
          throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
        }
        function eme(t) {
          if (Number.isNaN(t))
            throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
          if (t === 1 / 0 || t === -1 / 0)
            throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
          return null;
        }
        var tme = { float64: true, typeEncoders: { Object: Z1e, undefined: J1e, number: eme } };
        function rme(t) {
          if (t[0] !== 0)
            throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
          return I.decode(t.subarray(1));
        }
        var LB = { allowIndefinite: false, coerceUndefinedToNull: true, allowNaN: false, allowInfinity: false, allowBigInt: true, strict: true, useMaps: false, tags: [] };
        LB.tags[OB] = rme;
        var nme = "dag-cbor", qf = 113, U9 = (t) => ao(t, tme), zf = (t) => Mn(t, LB);
        var vp = {};
        ct(vp, { code: () => $9, decode: () => dme, encode: () => hme, name: () => fme });
        c();
        bp();
        ma();
        Vf();
        c();
        c();
        vi();
        L9();
        ro();
        zu();
        var K9 = class extends Array {
          constructor() {
            super(), this.inRecursive = [];
          }
          prefix(e) {
            let r = this.inRecursive[this.inRecursive.length - 1];
            r && (r.type === L.array && (r.elements++, r.elements !== 1 && e.push([44])), r.type === L.map && (r.elements++, r.elements !== 1 && (r.elements % 2 === 1 ? e.push([44]) : e.push([58]))));
          }
          [L.uint.major](e, r) {
            this.prefix(e);
            let n = String(r.value), i2 = [];
            for (let o = 0; o < n.length; o++)
              i2[o] = n.charCodeAt(o);
            e.push(i2);
          }
          [L.negint.major](e, r) {
            this[L.uint.major](e, r);
          }
          [L.bytes.major](e, r) {
            throw new Error(`${bc} unsupported type: Uint8Array`);
          }
          [L.string.major](e, r) {
            this.prefix(e);
            let n = $4(JSON.stringify(r.value));
            e.push(n.length > 32 ? Xm(n) : n);
          }
          [L.array.major](e, r) {
            this.prefix(e), this.inRecursive.push({ type: L.array, elements: 0 }), e.push([91]);
          }
          [L.map.major](e, r) {
            this.prefix(e), this.inRecursive.push({ type: L.map, elements: 0 }), e.push([123]);
          }
          [L.tag.major](e, r) {
          }
          [L.float.major](e, r) {
            if (r.type.name === "break") {
              let s = this.inRecursive.pop();
              if (s) {
                if (s.type === L.array)
                  e.push([93]);
                else if (s.type === L.map)
                  e.push([125]);
                else
                  throw new Error("Unexpected recursive type; this should not happen!");
                return;
              }
              throw new Error("Unexpected break; this should not happen!");
            }
            if (r.value === void 0)
              throw new Error(`${bc} unsupported type: undefined`);
            if (this.prefix(e), r.type.name === "true") {
              e.push([116, 114, 117, 101]);
              return;
            } else if (r.type.name === "false") {
              e.push([102, 97, 108, 115, 101]);
              return;
            } else if (r.type.name === "null") {
              e.push([110, 117, 108, 108]);
              return;
            }
            let n = String(r.value), i2 = [], o = false;
            for (let s = 0; s < n.length; s++)
              i2[s] = n.charCodeAt(s), !o && (i2[s] === 46 || i2[s] === 101 || i2[s] === 69) && (o = true);
            o || (i2.push(46), i2.push(48)), e.push(i2);
          }
        };
        function ime(t, e) {
          if (Array.isArray(t[0]) || Array.isArray(e[0]))
            throw new Error(`${bc} complex map keys are not supported`);
          let r = t[0], n = e[0];
          if (r.type !== L.string || n.type !== L.string)
            throw new Error(`${bc} non-string map keys are not supported`);
          if (r < n)
            return -1;
          if (r > n)
            return 1;
          throw new Error(`${bc} unexpected duplicate map keys, this is not supported`);
        }
        var ome = { addBreakTokens: true, mapSorter: ime };
        function V9(t, e) {
          return e = Object.assign({}, ome, e), O9(t, new K9(), e);
        }
        c();
        M9();
        vi();
        zu();
        ro();
        var _p = class {
          constructor(e, r = {}) {
            this.pos = 0, this.data = e, this.options = r, this.modeStack = ["value"], this.lastToken = "";
          }
          done() {
            return this.pos >= this.data.length;
          }
          ch() {
            return this.data[this.pos];
          }
          currentMode() {
            return this.modeStack[this.modeStack.length - 1];
          }
          skipWhitespace() {
            let e = this.ch();
            for (; e === 32 || e === 9 || e === 13 || e === 10; )
              e = this.data[++this.pos];
          }
          expect(e) {
            if (this.data.length - this.pos < e.length)
              throw new Error(`${Ie} unexpected end of input at position ${this.pos}`);
            for (let r = 0; r < e.length; r++)
              if (this.data[this.pos++] !== e[r])
                throw new Error(`${Ie} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...e)}'`);
          }
          parseNumber() {
            let e = this.pos, r = false, n = false, i2 = (a) => {
              for (; !this.done(); ) {
                let u = this.ch();
                if (a.includes(u))
                  this.pos++;
                else
                  break;
              }
            };
            if (this.ch() === 45 && (r = true, this.pos++), this.ch() === 48)
              if (this.pos++, this.ch() === 46)
                this.pos++, n = true;
              else
                return new Q(L.uint, 0, this.pos - e);
            if (i2([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]), r && this.pos === e + 1)
              throw new Error(`${Ie} unexpected token at position ${this.pos}`);
            if (!this.done() && this.ch() === 46) {
              if (n)
                throw new Error(`${Ie} unexpected token at position ${this.pos}`);
              n = true, this.pos++, i2([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]);
            }
            !this.done() && (this.ch() === 101 || this.ch() === 69) && (n = true, this.pos++, !this.done() && (this.ch() === 43 || this.ch() === 45) && this.pos++, i2([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]));
            let o = String.fromCharCode.apply(null, this.data.subarray(e, this.pos)), s = parseFloat(o);
            return n ? new Q(L.float, s, this.pos - e) : this.options.allowBigInt !== true || Number.isSafeInteger(s) ? new Q(s >= 0 ? L.uint : L.negint, s, this.pos - e) : new Q(s >= 0 ? L.uint : L.negint, BigInt(o), this.pos - e);
          }
          parseString() {
            if (this.ch() !== 34)
              throw new Error(`${Ie} unexpected character at position ${this.pos}; this shouldn't happen`);
            this.pos++;
            for (let o = this.pos, s = 0; o < this.data.length && s < 65536; o++, s++) {
              let a = this.data[o];
              if (a === 92 || a < 32 || a >= 128)
                break;
              if (a === 34) {
                let u = String.fromCharCode.apply(null, this.data.subarray(this.pos, o));
                return this.pos = o + 1, new Q(L.string, u, s);
              }
            }
            let e = this.pos, r = [], n = () => {
              if (this.pos + 4 >= this.data.length)
                throw new Error(`${Ie} unexpected end of unicode escape sequence at position ${this.pos}`);
              let o = 0;
              for (let s = 0; s < 4; s++) {
                let a = this.ch();
                if (a >= 48 && a <= 57)
                  a -= 48;
                else if (a >= 97 && a <= 102)
                  a = a - 97 + 10;
                else if (a >= 65 && a <= 70)
                  a = a - 65 + 10;
                else
                  throw new Error(`${Ie} unexpected unicode escape character at position ${this.pos}`);
                o = o * 16 + a, this.pos++;
              }
              return o;
            }, i2 = () => {
              let o = this.ch(), s = null, a = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
              if (this.pos + a > this.data.length)
                throw new Error(`${Ie} unexpected unicode sequence at position ${this.pos}`);
              let u, l, f, h;
              switch (a) {
                case 1:
                  o < 128 && (s = o);
                  break;
                case 2:
                  u = this.data[this.pos + 1], (u & 192) === 128 && (h = (o & 31) << 6 | u & 63, h > 127 && (s = h));
                  break;
                case 3:
                  u = this.data[this.pos + 1], l = this.data[this.pos + 2], (u & 192) === 128 && (l & 192) === 128 && (h = (o & 15) << 12 | (u & 63) << 6 | l & 63, h > 2047 && (h < 55296 || h > 57343) && (s = h));
                  break;
                case 4:
                  u = this.data[this.pos + 1], l = this.data[this.pos + 2], f = this.data[this.pos + 3], (u & 192) === 128 && (l & 192) === 128 && (f & 192) === 128 && (h = (o & 15) << 18 | (u & 63) << 12 | (l & 63) << 6 | f & 63, h > 65535 && h < 1114112 && (s = h));
              }
              s === null ? (s = 65533, a = 1) : s > 65535 && (s -= 65536, r.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), r.push(s), this.pos += a;
            };
            for (; !this.done(); ) {
              let o = this.ch(), s;
              switch (o) {
                case 92:
                  if (this.pos++, this.done())
                    throw new Error(`${Ie} unexpected string termination at position ${this.pos}`);
                  switch (s = this.ch(), this.pos++, s) {
                    case 34:
                    case 39:
                    case 92:
                    case 47:
                      r.push(s);
                      break;
                    case 98:
                      r.push(8);
                      break;
                    case 116:
                      r.push(9);
                      break;
                    case 110:
                      r.push(10);
                      break;
                    case 102:
                      r.push(12);
                      break;
                    case 114:
                      r.push(13);
                      break;
                    case 117:
                      r.push(n());
                      break;
                    default:
                      throw new Error(`${Ie} unexpected string escape character at position ${this.pos}`);
                  }
                  break;
                case 34:
                  return this.pos++, new Q(L.string, _9(r), this.pos - e);
                default:
                  if (o < 32)
                    throw new Error(`${Ie} invalid control character at position ${this.pos}`);
                  o < 128 ? (r.push(o), this.pos++) : i2();
              }
            }
            throw new Error(`${Ie} unexpected end of string at position ${this.pos}`);
          }
          parseValue() {
            switch (this.ch()) {
              case 123:
                return this.modeStack.push("obj-start"), this.pos++, new Q(L.map, 1 / 0, 1);
              case 91:
                return this.modeStack.push("array-start"), this.pos++, new Q(L.array, 1 / 0, 1);
              case 34:
                return this.parseString();
              case 110:
                return this.expect([110, 117, 108, 108]), new Q(L.null, null, 4);
              case 102:
                return this.expect([102, 97, 108, 115, 101]), new Q(L.false, false, 5);
              case 116:
                return this.expect([116, 114, 117, 101]), new Q(L.true, true, 4);
              case 45:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return this.parseNumber();
              default:
                throw new Error(`${Ie} unexpected character at position ${this.pos}`);
            }
          }
          next() {
            switch (this.skipWhitespace(), this.currentMode()) {
              case "value":
                return this.modeStack.pop(), this.parseValue();
              case "array-value": {
                if (this.modeStack.pop(), this.ch() === 93)
                  return this.pos++, this.skipWhitespace(), new Q(L.break, void 0, 1);
                if (this.ch() !== 44)
                  throw new Error(`${Ie} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
                return this.pos++, this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue();
              }
              case "array-start":
                return this.modeStack.pop(), this.ch() === 93 ? (this.pos++, this.skipWhitespace(), new Q(L.break, void 0, 1)) : (this.modeStack.push("array-value"), this.skipWhitespace(), this.parseValue());
              case "obj-key":
                if (this.ch() === 125)
                  return this.modeStack.pop(), this.pos++, this.skipWhitespace(), new Q(L.break, void 0, 1);
                if (this.ch() !== 44)
                  throw new Error(`${Ie} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
                this.pos++, this.skipWhitespace();
              case "obj-start": {
                if (this.modeStack.pop(), this.ch() === 125)
                  return this.pos++, this.skipWhitespace(), new Q(L.break, void 0, 1);
                let e = this.parseString();
                if (this.skipWhitespace(), this.ch() !== 58)
                  throw new Error(`${Ie} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
                return this.pos++, this.modeStack.push("obj-value"), e;
              }
              case "obj-value":
                return this.modeStack.pop(), this.modeStack.push("obj-key"), this.skipWhitespace(), this.parseValue();
              default:
                throw new Error(`${Ie} unexpected parse state at position ${this.pos}; this shouldn't happen`);
            }
          }
        };
        function q9(t, e) {
          return e = Object.assign({ tokenizer: new _p(t, e) }, e), Mn(t, e);
        }
        function ame(t) {
          if (t.asCID !== t)
            return null;
          let e = I.asCID(t);
          if (!e)
            return null;
          let r = e.toString();
          return [new Q(L.map, 1 / 0, 1), new Q(L.string, "/", 1), new Q(L.string, r, r.length), new Q(L.break, void 0, 1)];
        }
        function MB(t) {
          let e = to.encode(t).slice(1);
          return [new Q(L.map, 1 / 0, 1), new Q(L.string, "/", 1), new Q(L.map, 1 / 0, 1), new Q(L.string, "bytes", 5), new Q(L.string, e, e.length), new Q(L.break, void 0, 1), new Q(L.break, void 0, 1)];
        }
        function cme() {
          throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
        }
        function ume(t) {
          if (Number.isNaN(t))
            throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
          if (t === 1 / 0 || t === -1 / 0)
            throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
          return null;
        }
        var lme = { typeEncoders: { Object: ame, Uint8Array: MB, Buffer: MB, undefined: cme, number: ume } }, z9 = class extends _p {
          constructor(e, r) {
            super(e, r), this.tokenBuffer = [];
          }
          done() {
            return this.tokenBuffer.length === 0 && super.done();
          }
          _next() {
            return this.tokenBuffer.length > 0 ? this.tokenBuffer.pop() : super.next();
          }
          next() {
            let e = this._next();
            if (e.type === L.map) {
              let r = this._next();
              if (r.type === L.string && r.value === "/") {
                let n = this._next();
                if (n.type === L.string) {
                  if (this._next().type !== L.break)
                    throw new Error("Invalid encoded CID form");
                  return this.tokenBuffer.push(n), new Q(L.tag, 42, 0);
                }
                if (n.type === L.map) {
                  let i2 = this._next();
                  if (i2.type === L.string && i2.value === "bytes") {
                    let o = this._next();
                    if (o.type === L.string) {
                      for (let a = 0; a < 2; a++)
                        if (this._next().type !== L.break)
                          throw new Error("Invalid encoded Bytes form");
                      let s = to.decode(`m${o.value}`);
                      return new Q(L.bytes, s, o.value.length);
                    }
                    this.tokenBuffer.push(o);
                  }
                  this.tokenBuffer.push(i2);
                }
                this.tokenBuffer.push(n);
              }
              this.tokenBuffer.push(r);
            }
            return e;
          }
        }, H9 = { allowIndefinite: false, allowUndefined: false, allowNaN: false, allowInfinity: false, allowBigInt: true, strict: true, useMaps: false, tags: [] };
        H9.tags[42] = I.parse;
        var fme = "dag-json", $9 = 297, hme = (t) => V9(t, lme), dme = (t) => {
          let e = Object.assign(H9, { tokenizer: new z9(t, H9) });
          return q9(t, e);
        };
        var kLe = w(Z9(), 1);
        va();
        o2();
        c();
        c();
        var Sc = class extends Error {
          constructor(e = "not initialized") {
            super(e), this.name = "NotInitializedError", this.code = Sc.code;
          }
        };
        Sc.code = "ERR_NOT_INITIALIZED";
        var lS = class extends Error {
          constructor(e = "cannot initialize an initializing node") {
            super(e), this.name = "AlreadyInitializingError", this.code = Ts.code;
          }
        };
        lS.code = "ERR_ALREADY_INITIALIZING";
        var Ts = class extends Error {
          constructor(e = "cannot re-initialize an initialized node") {
            super(e), this.name = "AlreadyInitializedError", this.code = Ts.code;
          }
        };
        Ts.code = "ERR_ALREADY_INITIALIZED";
        var xc = class extends Error {
          constructor(e = "not started") {
            super(e), this.name = "NotStartedError", this.code = xc.code;
          }
        };
        xc.code = "ERR_NOT_STARTED";
        var $f = class extends Error {
          constructor(e = "cannot start, already startin") {
            super(e), this.name = "AlreadyStartingError", this.code = $f.code;
          }
        };
        $f.code = "ERR_ALREADY_STARTING";
        var Gf = class extends Error {
          constructor(e = "cannot start, already started") {
            super(e), this.name = "AlreadyStartedError", this.code = Gf.code;
          }
        };
        Gf.code = "ERR_ALREADY_STARTED";
        var Is = class extends Error {
          constructor(e = "not enabled") {
            super(e), this.name = "NotEnabledError", this.code = Is.code;
          }
        };
        Is.code = "ERR_NOT_ENABLED";
        Re();
        c();
        c();
        c();
        var HU = w(m2(), 1);
        te();
        c();
        Lp();
        me();
        Re();
        var Rc = "/", NU = new TextEncoder().encode(Rc), bw = NU[0], ae = class {
          constructor(e, r) {
            if (typeof e == "string")
              this._buf = U(e);
            else if (e instanceof Uint8Array)
              this._buf = e;
            else
              throw new Error("Invalid key, should be String of Uint8Array");
            if (r == null && (r = true), r && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== bw)
              throw new Error("Invalid key");
          }
          toString(e = "utf8") {
            return M(this._buf, e);
          }
          uint8Array() {
            return this._buf;
          }
          get [Symbol.toStringTag]() {
            return `Key(${this.toString()})`;
          }
          static withNamespaces(e) {
            return new ae(e.join(Rc));
          }
          static random() {
            return new ae(jf().replace(/-/g, ""));
          }
          static asKey(e) {
            return e instanceof Uint8Array || typeof e == "string" ? new ae(e) : e.uint8Array ? new ae(e.uint8Array()) : null;
          }
          clean() {
            if ((!this._buf || this._buf.byteLength === 0) && (this._buf = NU), this._buf[0] !== bw) {
              let e = new Uint8Array(this._buf.byteLength + 1);
              e.fill(bw, 0, 1), e.set(this._buf, 1), this._buf = e;
            }
            for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === bw; )
              this._buf = this._buf.subarray(0, -1);
          }
          less(e) {
            let r = this.list(), n = e.list();
            for (let i2 = 0; i2 < r.length; i2++) {
              if (n.length < i2 + 1)
                return false;
              let o = r[i2], s = n[i2];
              if (o < s)
                return true;
              if (o > s)
                return false;
            }
            return r.length < n.length;
          }
          reverse() {
            return ae.withNamespaces(this.list().slice().reverse());
          }
          namespaces() {
            return this.list();
          }
          baseNamespace() {
            let e = this.namespaces();
            return e[e.length - 1];
          }
          list() {
            return this.toString().split(Rc).slice(1);
          }
          type() {
            return wye(this.baseNamespace());
          }
          name() {
            return Eye(this.baseNamespace());
          }
          instance(e) {
            return new ae(this.toString() + ":" + e);
          }
          path() {
            let e = this.parent().toString();
            return e.endsWith(Rc) || (e += Rc), e += this.type(), new ae(e);
          }
          parent() {
            let e = this.list();
            return e.length === 1 ? new ae(Rc) : new ae(e.slice(0, -1).join(Rc));
          }
          child(e) {
            return this.toString() === Rc ? e : e.toString() === Rc ? this : new ae(this.toString() + e.toString(), false);
          }
          isAncestorOf(e) {
            return e.toString() === this.toString() ? false : e.toString().startsWith(this.toString());
          }
          isDecendantOf(e) {
            return e.toString() === this.toString() ? false : this.toString().startsWith(e.toString());
          }
          isTopLevel() {
            return this.list().length === 1;
          }
          concat(...e) {
            return ae.withNamespaces([...this.namespaces(), ...bye(e.map((r) => r.namespaces()))]);
          }
        };
        function wye(t) {
          let e = t.split(":");
          return e.length < 2 ? "" : e.slice(0, -1).join(":");
        }
        function Eye(t) {
          let e = t.split(":");
          return e[e.length - 1];
        }
        function bye(t) {
          return [].concat(...t);
        }
        var vw = w(K(), 1);
        c();
        var VU = w($o(), 1), qU = w(Vi(), 1);
        c();
        var Sye = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
        mt.nanosecond = mt.ns = 1 / 1e6;
        mt.\u00B5s = mt.\u03BCs = mt.us = mt.microsecond = 1 / 1e3;
        mt.millisecond = mt.ms = mt[""] = 1;
        mt.second = mt.sec = mt.s = mt.ms * 1e3;
        mt.minute = mt.min = mt.m = mt.s * 60;
        mt.hour = mt.hr = mt.h = mt.m * 60;
        mt.day = mt.d = mt.h * 24;
        mt.week = mt.wk = mt.w = mt.d * 7;
        mt.month = mt.b = mt.d * (365.25 / 12);
        mt.year = mt.yr = mt.y = mt.d * 365.25;
        function mt(t = "", e = "ms") {
          var r = null;
          return t = (t + "").replace(/(\d)[,_](\d)/g, "$1$2"), t.replace(Sye, function(n, i2, o) {
            o = KU(o), o && (r = (r || 0) + parseFloat(i2, 10) * o);
          }), r && r / (KU(e) || 1);
        }
        function KU(t) {
          return mt[t] || mt[t.toLowerCase().replace(/s$/, "")];
        }
        var ju = mt;
        c();
        var Ac = class extends Error {
          constructor(e = "request timed out") {
            super(e), this.name = "TimeoutError", this.code = Ac.code;
          }
        };
        Ac.code = "ERR_TIMEOUT";
        function B(t, e) {
          return (...r) => {
            let n = r[e ?? r.length - 1];
            if (!n || !n.timeout)
              return t(...r);
            let i2 = typeof n.timeout == "string" ? ju(n.timeout) : n.timeout, o = new VU.TimeoutController(i2);
            n.signal = (0, qU.anySignal)([n.signal, o.signal]);
            let s = t(...r), a = new Promise((f, h) => {
              o.signal.addEventListener("abort", () => {
                h(new Ac());
              });
            }), u = Date.now(), l = () => {
              if (o.signal.aborted)
                throw new Ac();
              if (Date.now() - u > i2)
                throw o.abort(), new Ac();
            };
            return s[Symbol.asyncIterator] ? async function* () {
              let f = s[Symbol.asyncIterator]();
              try {
                for (; ; ) {
                  let { value: h, done: p } = await Promise.race([f.next(), a]);
                  if (p)
                    break;
                  l(), yield h;
                }
              } catch (h) {
                throw l(), h;
              } finally {
                o.clear(), f.return && f.return();
              }
            }() : (async () => {
              try {
                let f = await Promise.race([s, a]);
                return l(), f;
              } catch (f) {
                throw l(), f;
              } finally {
                o.clear();
              }
            })();
          };
        }
        c();
        te();
        var KS = w(K(), 1), zU = "/ipfs/";
        function Tc(t) {
          if (t instanceof Uint8Array)
            try {
              t = I.decode(t);
            } catch (i2) {
              throw (0, KS.default)(i2, "ERR_INVALID_CID");
            }
          let e = I.asCID(t);
          if (e)
            return { cid: e, path: void 0 };
          t = t.toString(), t.startsWith(zU) && (t = t.substring(zU.length));
          let r = t.split("/"), n;
          try {
            e = I.parse(r.shift() || "");
          } catch (i2) {
            throw (0, KS.default)(i2, "ERR_INVALID_CID");
          }
          return r.length && (n = `/${r.join("/")}`), { cid: e, path: n };
        }
        var xye = "ERR_BAD_PATH", Sw = "This command must be run in online mode. Try running 'ipfs daemon' first.", w2 = new ae("/local/filesroot"), E2 = 262144;
        var $U = (t) => {
          if (I.asCID(t))
            return `/ipfs/${t}`;
          let r = t.toString();
          try {
            return `/ipfs/${I.parse(r)}`;
          } catch {
          }
          if (HU.default.path(r))
            return r;
          throw (0, vw.default)(new Error(`invalid path: ${t}`), xye);
        }, Bp = (t) => t instanceof Uint8Array ? I.decode(t).toString() : (t = t.toString(), t.indexOf("/ipfs/") === 0 && (t = t.substring(6)), t.charAt(t.length - 1) === "/" && (t = t.substring(0, t.length - 1)), t), Yu = async function(t, e, r, n = {}) {
          let { cid: i2, path: o } = Tc(r);
          o && (n.path = o);
          let s = i2, a = n.path || "";
          if (a.startsWith("/") && (a = a.substring(1)), n.path)
            try {
              for await (let { value: u, remainderPath: l } of Qu(i2, n.path, e, t, { signal: n.signal })) {
                if (!I.asCID(u))
                  break;
                a = l, s = u;
              }
            } catch (u) {
              throw u.message.startsWith("Object has no property") && (u.message = `no link named "${a.split("/")[0]}" under ${s}`, u.code = "ERR_NO_LINK"), u;
            }
          return { cid: s, remainderPath: a || "" };
        }, VS = (t) => {
          if (t.type !== "file" && t.type !== "directory" && t.type !== "raw")
            throw new Error(`Unknown node type '${t.type}'`);
          let e = { cid: t.cid, path: t.path, name: t.name, size: t.size, type: "file" };
          return t.type === "directory" && (e.type = "dir"), t.type === "file" && (e.size = t.unixfs.fileSize()), (t.type === "file" || t.type === "directory") && (e.mode = t.unixfs.mode, t.unixfs.mtime !== void 0 && (e.mtime = t.unixfs.mtime)), e;
        }, GU = B(async (t, e) => await t), Qu = async function* (t, e, r, n, i2) {
          let o = async (l) => {
            let f = await r.getCodec(l.code), h = await n.blocks.get(l, i2);
            return f.decode(h);
          }, s = e.split("/").filter(Boolean), a = await o(t), u = t;
          for (; s.length; ) {
            let l = s.shift();
            if (!l)
              throw (0, vw.default)(new Error(`Could not resolve path "${e}"`), "ERR_INVALID_PATH");
            if (t.code === pt && Array.isArray(a.Links)) {
              let f = a.Links.find((h) => h.Name === l);
              if (f) {
                yield { value: f.Hash, remainderPath: s.join("/") }, a = await o(f.Hash), u = f.Hash;
                continue;
              }
            }
            if (Object.prototype.hasOwnProperty.call(a, l))
              a = a[l], yield { value: a, remainderPath: s.join("/") };
            else
              throw (0, vw.default)(new Error(`no link named "${l}" under ${u}`), "ERR_NO_LINK");
            I.asCID(a) && (u = a, a = await o(a));
          }
          yield { value: a, remainderPath: "" };
        };
        var li = class {
          static create({ start: e, stop: r }) {
            return new li(e, r);
          }
          static async start(e, r) {
            let { state: n, activate: i2 } = e;
            switch (n.status) {
              case "stopped":
                try {
                  let o = i2(r);
                  e.state = { status: "starting", ready: o };
                  let s = await o;
                  return e.state = { status: "started", value: s }, s;
                } catch (o) {
                  throw e.state = { status: "stopped" }, o;
                }
              case "starting":
                throw new $f();
              case "started":
                throw new Gf();
              case "stopping":
                return await n.ready, await li.start(e, r);
              default:
                return li.panic(e);
            }
          }
          static async stop(e) {
            let { state: r, deactivate: n } = e;
            switch (r.status) {
              case "stopped":
                break;
              case "starting": {
                try {
                  await r.ready;
                } catch {
                }
                return await li.stop(e);
              }
              case "stopping":
                return await r.ready;
              case "started": {
                n && await n(r.value), e.state = { status: "stopped" };
                break;
              }
              default:
                li.panic(r);
            }
          }
          static try({ state: e }) {
            switch (e.status) {
              case "started":
                return e.value;
              default:
                return null;
            }
          }
          static async use({ state: e }, r) {
            switch (e.status) {
              case "started":
                return e.value;
              case "starting":
                return await GU(e.ready, r);
              default:
                throw new xc();
            }
          }
          static panic({ state: e }) {
            let r = JSON.stringify({ status: e.status });
            throw RangeError(`Service in invalid state ${r}, should never happen if you see this please report a bug`);
          }
          constructor(e, r) {
            this.activate = e, this.deactivate = r, this.state = { status: "stopped" };
          }
          async use(e) {
            return await li.use(this, e);
          }
          try() {
            return li.try(this);
          }
        };
        function WU({ network: t, preload: e, peerId: r, keychain: n, repo: i2, ipns: o, mfsPreload: s, print: a, hashers: u, options: l }) {
          return async () => {
            let { libp2p: h } = await li.start(t, { peerId: r, repo: i2, print: a, hashers: u, options: l });
            await Promise.all([o.startOnline({ keychain: n, libp2p: h, peerId: r, repo: i2 }), e.start(), s.start()]);
          };
        }
        c();
        function jU({ network: t, preload: e, ipns: r, repo: n, mfsPreload: i2 }) {
          return async () => {
            await Promise.all([e.stop(), r.stop(), i2.stop()]), await li.stop(t), await n.close();
          };
        }
        c();
        c();
        c();
        var QU = w(Mp(), 1), xw = class {
          constructor(e) {
            this.lru = (0, QU.default)(e);
          }
          get(e) {
            let r = this.lru.get(e);
            if (r) {
              if (r.expire && r.expire < Date.now()) {
                this.lru.remove(e);
                return;
              }
              return r.value;
            }
          }
          set(e, r, n) {
            this.lru.set(e, { value: r, expire: Date.now() + n });
          }
          has(e) {
            return !!this.get(e);
          }
          remove(e) {
            this.lru.remove(e);
          }
          clear() {
            this.lru.clear();
          }
        };
        c();
        var sF = w(Xu(), 1);
        c();
        var hi = class extends Error {
          constructor(e) {
            super(e), this.name = "TimeoutError";
          }
        }, zS = class extends Error {
          constructor(e) {
            super(), this.name = "AbortError", this.message = e;
          }
        }, ZU = (t) => globalThis.DOMException === void 0 ? new zS(t) : new DOMException(t), JU = (t) => {
          let e = t.reason === void 0 ? ZU("This operation was aborted.") : t.reason;
          return e instanceof Error ? e : ZU(e);
        };
        function nn(t, e, r, n) {
          let i2, o = new Promise((s, a) => {
            if (typeof e != "number" || Math.sign(e) !== 1)
              throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${e}\``);
            if (e === Number.POSITIVE_INFINITY) {
              s(t);
              return;
            }
            if (n = { customTimers: { setTimeout, clearTimeout }, ...n }, n.signal) {
              let { signal: u } = n;
              u.aborted && a(JU(u)), u.addEventListener("abort", () => {
                a(JU(u));
              });
            }
            i2 = n.customTimers.setTimeout.call(void 0, () => {
              if (typeof r == "function") {
                try {
                  s(r());
                } catch (f) {
                  a(f);
                }
                return;
              }
              let u = typeof r == "string" ? r : `Promise timed out after ${e} milliseconds`, l = r instanceof Error ? r : new hi(u);
              typeof t.cancel == "function" && t.cancel(), a(l);
            }, e), (async () => {
              try {
                s(await t);
              } catch (u) {
                a(u);
              } finally {
                n.customTimers.clearTimeout.call(void 0, i2);
              }
            })();
          });
          return o.clear = () => {
            clearTimeout(i2), i2 = void 0;
          }, o;
        }
        c();
        c();
        function HS(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var Yf = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Ic, _2 = class {
          constructor() {
            Ic.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && Yf(this, Ic, "f")[this.size - 1].priority >= r.priority) {
              Yf(this, Ic, "f").push(n);
              return;
            }
            let i2 = HS(Yf(this, Ic, "f"), n, (o, s) => s.priority - o.priority);
            Yf(this, Ic, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = Yf(this, Ic, "f").shift();
            return e?.run;
          }
          filter(e) {
            return Yf(this, Ic, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return Yf(this, Ic, "f").length;
          }
        };
        Ic = /* @__PURE__ */ new WeakMap();
        var Zt = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, we = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Fn, S2, x2, Ju, Pw, R2, Aw, Ds, v2, co, Tw, uo, A2, Zu, Up, Fp, Qf, Iw, eF, tF, oF, rF, nF, iF, Cw, $S, GS, Dw, kw = () => {
        }, Tye = new hi(), WS = class extends Error {
        }, ks = class extends sF.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), Fn.add(this), S2.set(this, void 0), x2.set(this, void 0), Ju.set(this, 0), Pw.set(this, void 0), R2.set(this, void 0), Aw.set(this, 0), Ds.set(this, void 0), v2.set(this, void 0), co.set(this, void 0), Tw.set(this, void 0), uo.set(this, 0), A2.set(this, void 0), Zu.set(this, void 0), Up.set(this, kw), Fp.set(this, kw), Qf.set(this, void 0), Iw.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: _2, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            Zt(this, S2, e.carryoverConcurrencyCount, "f"), Zt(this, x2, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), Zt(this, Pw, e.intervalCap, "f"), Zt(this, R2, e.interval, "f"), Zt(this, co, new e.queueClass(), "f"), Zt(this, Tw, e.queueClass, "f"), this.concurrency = e.concurrency, Zt(this, Qf, e.timeout, "f"), Zt(this, Iw, e.throwOnTimeout === true, "f"), Zt(this, Zu, e.autoStart === false, "f");
          }
          get concurrency() {
            return we(this, A2, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            Zt(this, A2, e, "f"), we(this, Fn, "m", Dw).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                Zt(this, uo, (a = we(this, uo, "f"), a++, a), "f"), Zt(this, Ju, (u = we(this, Ju, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new WS("The task was aborted."));
                    return;
                  }
                  let f = await (we(this, Qf, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? we(this, Qf, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? we(this, Iw, "f") : r.throwOnTimeout) && i2(Tye);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                we(this, Fn, "m", oF).call(this);
              };
              we(this, co, "f").enqueue(o, r), we(this, Fn, "m", Cw).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return we(this, Zu, "f") ? (Zt(this, Zu, false, "f"), we(this, Fn, "m", Dw).call(this), this) : this;
          }
          pause() {
            Zt(this, Zu, true, "f");
          }
          clear() {
            Zt(this, co, new (we(this, Tw, "f"))(), "f");
          }
          async onEmpty() {
            if (we(this, co, "f").size !== 0)
              return new Promise((e) => {
                let r = we(this, Up, "f");
                Zt(this, Up, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(we(this, co, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  we(this, co, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(we(this, uo, "f") === 0 && we(this, co, "f").size === 0))
              return new Promise((e) => {
                let r = we(this, Fp, "f");
                Zt(this, Fp, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return we(this, co, "f").size;
          }
          sizeBy(e) {
            return we(this, co, "f").filter(e).length;
          }
          get pending() {
            return we(this, uo, "f");
          }
          get isPaused() {
            return we(this, Zu, "f");
          }
          get timeout() {
            return we(this, Qf, "f");
          }
          set timeout(e) {
            Zt(this, Qf, e, "f");
          }
        };
        S2 = /* @__PURE__ */ new WeakMap(), x2 = /* @__PURE__ */ new WeakMap(), Ju = /* @__PURE__ */ new WeakMap(), Pw = /* @__PURE__ */ new WeakMap(), R2 = /* @__PURE__ */ new WeakMap(), Aw = /* @__PURE__ */ new WeakMap(), Ds = /* @__PURE__ */ new WeakMap(), v2 = /* @__PURE__ */ new WeakMap(), co = /* @__PURE__ */ new WeakMap(), Tw = /* @__PURE__ */ new WeakMap(), uo = /* @__PURE__ */ new WeakMap(), A2 = /* @__PURE__ */ new WeakMap(), Zu = /* @__PURE__ */ new WeakMap(), Up = /* @__PURE__ */ new WeakMap(), Fp = /* @__PURE__ */ new WeakMap(), Qf = /* @__PURE__ */ new WeakMap(), Iw = /* @__PURE__ */ new WeakMap(), Fn = /* @__PURE__ */ new WeakSet(), eF = function() {
          return we(this, x2, "f") || we(this, Ju, "f") < we(this, Pw, "f");
        }, tF = function() {
          return we(this, uo, "f") < we(this, A2, "f");
        }, oF = function() {
          var e;
          Zt(this, uo, (e = we(this, uo, "f"), e--, e), "f"), we(this, Fn, "m", Cw).call(this), this.emit("next");
        }, rF = function() {
          we(this, Up, "f").call(this), Zt(this, Up, kw, "f"), we(this, uo, "f") === 0 && (we(this, Fp, "f").call(this), Zt(this, Fp, kw, "f"), this.emit("idle"));
        }, nF = function() {
          we(this, Fn, "m", GS).call(this), we(this, Fn, "m", $S).call(this), Zt(this, v2, void 0, "f");
        }, iF = function() {
          let e = Date.now();
          if (we(this, Ds, "f") === void 0) {
            let r = we(this, Aw, "f") - e;
            if (r < 0)
              Zt(this, Ju, we(this, S2, "f") ? we(this, uo, "f") : 0, "f");
            else
              return we(this, v2, "f") === void 0 && Zt(this, v2, setTimeout(() => {
                we(this, Fn, "m", nF).call(this);
              }, r), "f"), true;
          }
          return false;
        }, Cw = function() {
          if (we(this, co, "f").size === 0)
            return we(this, Ds, "f") && clearInterval(we(this, Ds, "f")), Zt(this, Ds, void 0, "f"), we(this, Fn, "m", rF).call(this), false;
          if (!we(this, Zu, "f")) {
            let e = !we(this, Fn, "m", iF).call(this);
            if (we(this, Fn, "a", eF) && we(this, Fn, "a", tF)) {
              let r = we(this, co, "f").dequeue();
              return r ? (this.emit("active"), r(), e && we(this, Fn, "m", $S).call(this), true) : false;
            }
          }
          return false;
        }, $S = function() {
          we(this, x2, "f") || we(this, Ds, "f") !== void 0 || (Zt(this, Ds, setInterval(() => {
            we(this, Fn, "m", GS).call(this);
          }, we(this, R2, "f")), "f"), Zt(this, Aw, Date.now() + we(this, R2, "f"), "f"));
        }, GS = function() {
          we(this, Ju, "f") === 0 && we(this, uo, "f") === 0 && we(this, Ds, "f") && (clearInterval(we(this, Ds, "f")), Zt(this, Ds, void 0, "f")), Zt(this, Ju, we(this, S2, "f") ? we(this, uo, "f") : 0, "f"), we(this, Fn, "m", Dw).call(this);
        }, Dw = function() {
          for (; we(this, Fn, "m", Cw).call(this); )
            ;
        };
        var _F = w(Vp(), 1), rx = new xw(1e3), Wye = 60 * 1e3, jye = ks.default ? ks.default : ks, Yye = new jye({ concurrency: 4 }), bF = (t) => {
          if (t.Path)
            return t.Path;
          throw new Error(t.Message);
        };
        async function vF(t, e) {
          return (async (n, i2 = {}) => {
            let o = new URLSearchParams(i2);
            o.set("arg", n);
            let s = o.toString();
            if (!i2.nocache && rx.has(s)) {
              let u = rx.get(s);
              return bF(u);
            }
            let a = await Yye.add(async () => {
              let u = await _F.default.get("https://ipfs.io/api/v0/dns", { searchParams: o }), l = new URL(u.url).search.slice(1), f = await u.json();
              return rx.set(l, f, Wye), f;
            });
            return bF(a);
          })(t, e);
        }
        function Qye(t) {
          return t.endsWith(".eth") && (t = t.replace(/.eth$/, ".eth.link")), t;
        }
        function SF() {
          return B(async (e, r = { recursive: true }) => {
            if (typeof e != "string")
              throw new Error("Invalid arguments, domain must be a string");
            return e = Qye(e), vF(e, r);
          });
        }
        c();
        function xF({ network: t }) {
          return () => {
            let e = t.try();
            return e != null && Boolean(e.libp2p.isStarted());
          };
        }
        c();
        var ox = w(m2(), 1);
        te();
        c();
        te();
        o2();
        Hr();
        On();
        va();
        yr();
        vr();
        var TF = w(K(), 1);
        c();
        var RF = Symbol.for("@libp2p/peer-id");
        var AF = Object.values(Sa).map((t) => t.decoder).reduce((t, e) => t.or(e), Sa.identity.decoder), IF = 114, nx = 36, ix = 37, I2 = class {
          constructor(e) {
            this.type = e.type, this.multihash = e.multihash, this.privateKey = e.privateKey, Object.defineProperty(this, "string", { enumerable: false, writable: true });
          }
          get [Symbol.toStringTag]() {
            return `PeerId(${this.toString()})`;
          }
          get [RF]() {
            return true;
          }
          toString() {
            return this.string == null && (this.string = Ne.encode(this.multihash.bytes).slice(1)), this.string;
          }
          toCID() {
            return I.createV1(IF, this.multihash);
          }
          toBytes() {
            return this.multihash.bytes;
          }
          toJSON() {
            return this.toString();
          }
          equals(e) {
            if (e instanceof Uint8Array)
              return Ce(this.multihash.bytes, e);
            if (typeof e == "string")
              return ue(e).equals(this);
            if (e?.multihash?.bytes != null)
              return Ce(this.multihash.bytes, e.multihash.bytes);
            throw new Error("not valid Id");
          }
        }, Xf = class extends I2 {
          constructor(e) {
            super({ ...e, type: "RSA" }), this.type = "RSA", this.publicKey = e.publicKey;
          }
        }, Zf = class extends I2 {
          constructor(e) {
            super({ ...e, type: "Ed25519" }), this.type = "Ed25519", this.publicKey = e.multihash.digest;
          }
        }, Jf = class extends I2 {
          constructor(e) {
            super({ ...e, type: "secp256k1" }), this.type = "secp256k1", this.publicKey = e.multihash.digest;
          }
        };
        function on(t) {
          let e = (0, TF.default)(new Error("Not a PeerId"), "ERR_INVALID_PARAMETERS");
          if (t.type === "RSA")
            return new Xf(t);
          if (t.type === "Ed25519")
            return new Zf(t);
          if (t.type === "secp256k1")
            return new Jf(t);
          throw e;
        }
        function ue(t, e) {
          if (e = e ?? AF, t.charAt(0) === "1" || t.charAt(0) === "Q") {
            let r = _r(Ne.decode(`z${t}`));
            return t.startsWith("12D") ? new Zf({ multihash: r }) : t.startsWith("16U") ? new Jf({ multihash: r }) : new Xf({ multihash: r });
          }
          return Ir(AF.decode(t));
        }
        function Ir(t) {
          try {
            let e = _r(t);
            if (e.code === $r.code) {
              if (e.digest.length === nx)
                return new Zf({ multihash: e });
              if (e.digest.length === ix)
                return new Jf({ multihash: e });
            }
            if (e.code === xe.code)
              return new Xf({ multihash: e });
          } catch {
            return Xye(I.decode(t));
          }
          throw new Error("Supplied PeerID CID is invalid");
        }
        function Xye(t) {
          if (t == null || t.multihash == null || t.version == null || t.version === 1 && t.code !== IF)
            throw new Error("Supplied PeerID CID is invalid");
          let e = t.multihash;
          if (e.code === xe.code)
            return new Xf({ multihash: t.multihash });
          if (e.code === $r.code) {
            if (e.digest.length === nx)
              return new Zf({ multihash: t.multihash });
            if (e.digest.length === ix)
              return new Jf({ multihash: t.multihash });
          }
          throw new Error("Supplied PeerID CID is invalid");
        }
        async function sn(t, e) {
          return t.length === nx ? new Zf({ multihash: xs($r.code, t), privateKey: e }) : t.length === ix ? new Jf({ multihash: xs($r.code, t), privateKey: e }) : new Xf({ multihash: await xe.digest(t), publicKey: t, privateKey: e });
        }
        function CF({ repo: t, codecs: e, bases: r, name: n }) {
          async function i2(o, s = {}) {
            if (!ox.default.path(o))
              throw new Error("invalid argument " + o);
            if (ox.default.ipnsPath(o))
              for await (let g of n.resolve(o, s))
                o = g;
            let [, a, u, ...l] = o.split("/"), f = s.cidBase ? await r.getBase(s.cidBase) : void 0, h = Zye(u);
            if (l.length === 0) {
              let g = f ? f.encoder.encode(h) : u;
              return `/${a}/${g}`;
            }
            let p = I.decode(h);
            o = l.join("/");
            let d = Qu(p, o, e, t, s), m = p, y = o;
            for await (let g of d)
              I.asCID(g.value) && (m = g.value, y = g.remainderPath);
            return `/ipfs/${m.toString(f && f.encoder)}${y ? "/" + y : ""}`;
          }
          return B(i2);
        }
        function Zye(t) {
          try {
            return ue(t).toBytes();
          } catch {
            return I.parse(t).bytes;
          }
        }
        c();
        c();
        var DF = w(qi(), 1);
        te();
        function kF({ addAll: t }) {
          return (e, r = {}) => {
            let n, i2 = I.asCID(e);
            return i2 ? n = t([{ cid: i2, ...r }], r) : n = t([{ path: e.toString(), ...r }], r), (0, DF.default)(n);
          };
        }
        c();
        c();
        var qp = w(K(), 1);
        te();
        async function* xa(t) {
          if (t == null)
            throw (0, qp.default)(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT");
          let e = I.asCID(t);
          if (e) {
            yield Ns({ cid: e });
            return;
          }
          if (t instanceof String || typeof t == "string") {
            yield Ns({ path: t });
            return;
          }
          if (t.cid != null || t.path != null)
            return yield Ns(t);
          if (Symbol.iterator in t) {
            let r = t[Symbol.iterator](), n = r.next();
            if (n.done)
              return r;
            if (I.asCID(n.value) || n.value instanceof String || typeof n.value == "string") {
              yield Ns({ cid: n.value });
              for (let i2 of r)
                yield Ns({ cid: i2 });
              return;
            }
            if (n.value.cid != null || n.value.path != null) {
              yield Ns(n.value);
              for (let i2 of r)
                yield Ns(i2);
              return;
            }
            throw (0, qp.default)(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT");
          }
          if (Symbol.asyncIterator in t) {
            let r = t[Symbol.asyncIterator](), n = await r.next();
            if (n.done)
              return r;
            if (I.asCID(n.value) || n.value instanceof String || typeof n.value == "string") {
              yield Ns({ cid: n.value });
              for await (let i2 of r)
                yield Ns({ cid: i2 });
              return;
            }
            if (n.value.cid != null || n.value.path != null) {
              yield Ns(n.value);
              for await (let i2 of r)
                yield Ns(i2);
              return;
            }
            throw (0, qp.default)(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT");
          }
          throw (0, qp.default)(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT");
        }
        function Ns(t) {
          let e = t.cid || `${t.path}`;
          if (!e)
            throw (0, qp.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
          let r = { path: e, recursive: t.recursive !== false };
          return t.metadata != null && (r.metadata = t.metadata), r;
        }
        c();
        var vt = { direct: "direct", recursive: "recursive", indirect: "indirect", all: "all" };
        function NF({ repo: t, codecs: e }) {
          async function* r(n, i2 = {}) {
            let o = async function* () {
              for await (let { path: u, recursive: l, metadata: f } of xa(n)) {
                let { cid: h } = await Yu(t, e, u), { reason: p } = await t.pins.isPinnedWithType(h, [vt.recursive, vt.direct]);
                if (p === "recursive" && !l)
                  throw new Error(`${h} already pinned recursively`);
                l ? await t.pins.pinRecursively(h, { metadata: f }) : await t.pins.pinDirectly(h, { metadata: f }), yield h;
              }
            };
            if (!Boolean(i2.lock)) {
              yield* o();
              return;
            }
            let a = await t.gcLock.readLock();
            try {
              yield* o();
            } finally {
              a();
            }
          }
          return B(r);
        }
        c();
        var sx = w(K(), 1);
        function C2(t, e, r) {
          let n = { type: t, cid: e };
          return r && (n.metadata = r), n;
        }
        function OF({ repo: t, codecs: e }) {
          async function* r(n = {}) {
            let i2 = vt.all;
            if (n.type && (i2 = n.type, !Object.keys(vt).includes(i2)))
              throw (0, sx.default)(new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
            if (n.paths) {
              let o = false;
              for await (let { path: s } of xa(n.paths)) {
                let { cid: a } = await Yu(t, e, s), { reason: u, pinned: l, parent: f, metadata: h } = await t.pins.isPinnedWithType(a, i2);
                if (!l)
                  throw (0, sx.default)(new Error(`path '${s}' is not pinned`), "ERR_NOT_PINNED");
                switch (u) {
                  case vt.direct:
                  case vt.recursive:
                    o = true, yield C2(u, a, h);
                    break;
                  default:
                    o = true, yield C2(`${vt.indirect} through ${f}`, a, h);
                }
              }
              if (!o)
                throw new Error("No match found");
              return;
            }
            if (i2 === vt.recursive || i2 === vt.all)
              for await (let { cid: o, metadata: s } of t.pins.recursiveKeys())
                yield C2(vt.recursive, o, s);
            if (i2 === vt.indirect || i2 === vt.all)
              for await (let o of t.pins.indirectKeys(n))
                yield C2(vt.indirect, o);
            if (i2 === vt.direct || i2 === vt.all)
              for await (let { cid: o, metadata: s } of t.pins.directKeys())
                yield C2(vt.direct, o, s);
          }
          return B(r);
        }
        c();
        var LF = w(qi(), 1);
        function BF({ rmAll: t }) {
          async function e(r, n = {}) {
            let i2 = await (0, LF.default)(t([{ path: r, ...n }], n));
            if (!i2)
              throw new Error("CID expected");
            return i2;
          }
          return e;
        }
        c();
        function MF({ repo: t, codecs: e }) {
          async function* r(n, i2 = {}) {
            let o = await t.gcLock.readLock();
            try {
              for await (let { path: s, recursive: a } of xa(n)) {
                let { cid: u } = await Yu(t, e, s), { pinned: l, reason: f } = await t.pins.isPinnedWithType(u, vt.all);
                if (!l)
                  throw new Error(`${u} is not pinned`);
                switch (f) {
                  case vt.recursive:
                    if (!a)
                      throw new Error(`${u} is pinned recursively`);
                    await t.pins.unpin(u), yield u;
                    break;
                  case vt.direct:
                    await t.pins.unpin(u), yield u;
                    break;
                  default:
                    throw new Error(`${u} is pinned indirectly under ${f}`);
                }
              }
            } finally {
              o();
            }
          }
          return B(r);
        }
        var Ow = class {
          constructor({ codecs: e, repo: r }) {
            let n = NF({ codecs: e, repo: r });
            this.addAll = n, this.add = kF({ addAll: n });
            let i2 = MF({ codecs: e, repo: r });
            this.rmAll = i2, this.rm = BF({ rmAll: i2 }), this.ls = OF({ codecs: e, repo: r }), this.remote = { add: (o, s = {}) => Promise.reject(new Error("Not implemented")), ls: async function* (o, s = {}) {
              return Promise.reject(new Error("Not implemented"));
            }, rm: (o, s = {}) => Promise.reject(new Error("Not implemented")), rmAll: (o, s = {}) => Promise.reject(new Error("Not implemented")), service: { add: (o, s) => Promise.reject(new Error("Not implemented")), rm: (o, s = {}) => Promise.reject(new Error("Not implemented")), ls: (o = {}) => Promise.reject(new Error("Not implemented")) } };
          }
        };
        c();
        c();
        var zq = w(K(), 1);
        c();
        c();
        var ege = Symbol.for("@libp2p/peer-id");
        function Go(t) {
          return t != null && Boolean(t[ege]);
        }
        var el = {};
        ct(el, { abortedError: () => tge, dbDeleteFailedError: () => Bw, dbOpenFailedError: () => Lw, dbWriteFailedError: () => Mw, notFoundError: () => Rn });
        c();
        var zp = w(K(), 1);
        function Lw(t) {
          return t = t || new Error("Cannot open database"), (0, zp.default)(t, "ERR_DB_OPEN_FAILED");
        }
        function Bw(t) {
          return t = t || new Error("Delete failed"), (0, zp.default)(t, "ERR_DB_DELETE_FAILED");
        }
        function Mw(t) {
          return t = t || new Error("Write failed"), (0, zp.default)(t, "ERR_DB_WRITE_FAILED");
        }
        function Rn(t) {
          return t = t || new Error("Not Found"), (0, zp.default)(t, "ERR_NOT_FOUND");
        }
        function tge(t) {
          return t = t || new Error("Aborted"), (0, zp.default)(t, "ERR_ABORTED");
        }
        var Zo = w(K(), 1);
        me();
        yr();
        c();
        var Nq = w(UF(), 1);
        var v6 = {};
        ct(v6, { generateEphemeralKeyPair: () => SV, generateKeyPair: () => sR, generateKeyPairFromSeed: () => _6e, importKey: () => Mc, keyStretcher: () => gV, keysPBM: () => Hp, marshalPrivateKey: () => S6e, marshalPublicKey: () => v6e, supportedKeys: () => La, unmarshalPrivateKey: () => Jn, unmarshalPublicKey: () => ho });
        c();
        var Hp = {};
        ct(Hp, { KeyType: () => Fr, PrivateKey: () => Ls, PublicKey: () => Os });
        c();
        c();
        c();
        c();
        c();
        c();
        function eh(t, e) {
          for (let r = 0; r < t.byteLength; r++) {
            if (t[r] < e[r])
              return -1;
            if (t[r] > e[r])
              return 1;
          }
          return t.byteLength > e.byteLength ? 1 : t.byteLength < e.byteLength ? -1 : 0;
        }
        ur();
        yr();
        Re();
        me();
        c();
        function Pc(t, e) {
          if (t.length !== e.length)
            throw new Error("Inputs should have the same length");
          let r = new Uint8Array(t.length);
          for (let n = 0; n < t.length; n++)
            r[n] = t[n] ^ e[n];
          return r;
        }
        var KF = Symbol.for("@achingbrain/uint8arraylist");
        function FF(t, e, r) {
          if (e == null || e < 0 || e >= r)
            throw new RangeError("index is out of bounds");
          let n = 0;
          for (let i2 of t) {
            let o = n + i2.byteLength;
            if (e < o)
              return { buf: i2, index: e - n };
            n = o;
          }
          throw new RangeError("index is out of bounds");
        }
        function tl(t) {
          return Boolean(t?.[KF]);
        }
        var qe = class {
          constructor(...e) {
            Object.defineProperty(this, KF, { value: true }), this.bufs = [], this.length = 0, this.appendAll(e);
          }
          *[Symbol.iterator]() {
            yield* this.bufs;
          }
          get byteLength() {
            return this.length;
          }
          append(...e) {
            this.appendAll(e);
          }
          appendAll(e) {
            let r = 0;
            for (let n of e)
              if (n instanceof Uint8Array)
                r += n.byteLength, this.bufs.push(n);
              else if (tl(n))
                r += n.length, this.bufs = this.bufs.concat(n.bufs);
              else
                throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");
            this.length += r;
          }
          get(e) {
            let r = FF(this.bufs, e, this.length);
            return r.buf[r.index];
          }
          set(e, r) {
            let n = FF(this.bufs, e, this.length);
            n.buf[n.index] = r;
          }
          write(e, r = 0) {
            if (e instanceof Uint8Array)
              for (let n = 0; n < e.length; n++)
                this.set(r + n, e[n]);
            else if (tl(e))
              for (let n = 0; n < e.length; n++)
                this.set(r + n, e.get(n));
            else
              throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList");
          }
          consume(e) {
            if (e = Math.trunc(e), !(Number.isNaN(e) || e <= 0))
              for (; this.bufs.length > 0; )
                if (e >= this.bufs[0].byteLength)
                  e -= this.bufs[0].byteLength, this.length -= this.bufs[0].byteLength, this.bufs.shift();
                else {
                  this.bufs[0] = this.bufs[0].subarray(e), this.length -= e;
                  break;
                }
          }
          slice(e, r) {
            let { bufs: n, length: i2 } = this._subList(e, r);
            return Ae(n, i2);
          }
          subarray(e, r) {
            let { bufs: n } = this._subList(e, r), i2 = new qe();
            return i2.appendAll(n), i2;
          }
          _subList(e, r) {
            if (e == null && r == null)
              return { bufs: this.bufs, length: this.length };
            if (e = e ?? 0, r = r ?? (this.length > 0 ? this.length : 0), e < 0 || r > this.length)
              throw new RangeError("index out of bounds");
            if (e === r)
              return { bufs: [], length: 0 };
            let n = [], i2 = 0;
            for (let o of this.bufs) {
              let s = i2, a = s + o.byteLength, u = e >= s && e < a, l = r > s && r <= a, f = e < s && r >= a;
              i2 = a;
              let h, p;
              if (u && (h = e - s, p = o.byteLength), l && (p = r - s, h == null && (h = 0)), f && (h = 0, p = o.byteLength), h != null && p != null && n.push(o.subarray(h, p)), l)
                break;
            }
            return { bufs: n, length: r - e };
          }
          getInt8(e) {
            let r = this.slice(e, e + 1);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getInt8(0);
          }
          setInt8(e, r) {
            let n = new Uint8Array(1);
            new DataView(n.buffer, n.byteOffset, n.byteLength).setInt8(0, r), this.write(n, e);
          }
          getInt16(e, r) {
            let n = this.slice(e, e + 2);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getInt16(0, r);
          }
          setInt16(e, r, n) {
            let i2 = new Uint8Array(2);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setInt16(0, r, n), this.write(i2, e);
          }
          getInt32(e, r) {
            let n = this.slice(e, e + 4);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getInt32(0, r);
          }
          setInt32(e, r, n) {
            let i2 = new Uint8Array(4);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setInt32(0, r, n), this.write(i2, e);
          }
          getBigInt64(e, r) {
            let n = this.slice(e, e + 8);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getBigInt64(0, r);
          }
          setBigInt64(e, r, n) {
            let i2 = new Uint8Array(8);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setBigInt64(0, r, n), this.write(i2, e);
          }
          getUint8(e) {
            let r = this.slice(e, e + 1);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).getUint8(0);
          }
          setUint8(e, r) {
            let n = new Uint8Array(1);
            new DataView(n.buffer, n.byteOffset, n.byteLength).setUint8(0, r), this.write(n, e);
          }
          getUint16(e, r) {
            let n = this.slice(e, e + 2);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getUint16(0, r);
          }
          setUint16(e, r, n) {
            let i2 = new Uint8Array(2);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setUint16(0, r, n), this.write(i2, e);
          }
          getUint32(e, r) {
            let n = this.slice(e, e + 4);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getUint32(0, r);
          }
          setUint32(e, r, n) {
            let i2 = new Uint8Array(4);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setUint32(0, r, n), this.write(i2, e);
          }
          getBigUint64(e, r) {
            let n = this.slice(e, e + 8);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getBigUint64(0, r);
          }
          setBigUint64(e, r, n) {
            let i2 = new Uint8Array(8);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setBigUint64(0, r, n), this.write(i2, e);
          }
          getFloat32(e, r) {
            let n = this.slice(e, e + 4);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat32(0, r);
          }
          setFloat32(e, r, n) {
            let i2 = new Uint8Array(4);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setFloat32(0, r, n), this.write(i2, e);
          }
          getFloat64(e, r) {
            let n = this.slice(e, e + 8);
            return new DataView(n.buffer, n.byteOffset, n.byteLength).getFloat64(0, r);
          }
          setFloat64(e, r, n) {
            let i2 = new Uint8Array(8);
            new DataView(i2.buffer, i2.byteOffset, i2.byteLength).setFloat64(0, r, n), this.write(i2, e);
          }
        };
        c();
        c();
        function Ra(t) {
          return t instanceof Uint8Array ? { get(e) {
            return t[e];
          }, set(e, r) {
            t[e] = r;
          } } : { get(e) {
            return t.get(e);
          }, set(e, r) {
            t.set(e, r);
          } };
        }
        c();
        var VF = 4294967296, Kn = class {
          constructor(e = 0, r = 0) {
            this.hi = e, this.lo = r;
          }
          toBigInt(e) {
            if (e)
              return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
            if (this.hi >>> 31 !== 0) {
              let r = ~this.lo + 1 >>> 0, n = ~this.hi >>> 0;
              return r === 0 && (n = n + 1 >>> 0), -(BigInt(r) + (BigInt(n) << 32n));
            }
            return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n);
          }
          zzDecode() {
            let e = -(this.lo & 1), r = ((this.lo >>> 1 | this.hi << 31) ^ e) >>> 0, n = (this.hi >>> 1 ^ e) >>> 0;
            return new Kn(n, r);
          }
          zzEncode() {
            let e = this.hi >> 31, r = ((this.hi << 1 | this.lo >>> 31) ^ e) >>> 0, n = (this.lo << 1 ^ e) >>> 0;
            return new Kn(r, n);
          }
          toBytes(e, r = 0) {
            let n = Ra(e);
            for (; this.hi > 0; )
              n.set(r++, this.lo & 127 | 128), this.lo = (this.lo >>> 7 | this.hi << 25) >>> 0, this.hi >>>= 7;
            for (; this.lo > 127; )
              n.set(r++, this.lo & 127 | 128), this.lo = this.lo >>> 7;
            n.set(r++, this.lo);
          }
          static fromBigInt(e) {
            if (e === 0n)
              return new Kn();
            let r = e < 0;
            r && (e = -e);
            let n = Number(e >> 32n) | 0, i2 = Number(e - (BigInt(n) << 32n)) | 0;
            return r && (n = ~n >>> 0, i2 = ~i2 >>> 0, ++i2 > VF && (i2 = 0, ++n > VF && (n = 0))), new Kn(n, i2);
          }
          static fromNumber(e) {
            if (e === 0)
              return new Kn();
            let r = e < 0;
            r && (e = -e);
            let n = e >>> 0, i2 = (e - n) / 4294967296 >>> 0;
            return r && (i2 = ~i2 >>> 0, n = ~n >>> 0, ++n > 4294967295 && (n = 0, ++i2 > 4294967295 && (i2 = 0))), new Kn(i2, n);
          }
          static fromBytes(e, r) {
            let n = Ra(e), i2 = new Kn(), o = 0;
            if (e.length - r > 4) {
              for (; o < 4; ++o)
                if (i2.lo = (i2.lo | (n.get(r) & 127) << o * 7) >>> 0, n.get(r++) < 128)
                  return i2;
              if (i2.lo = (i2.lo | (n.get(r) & 127) << 28) >>> 0, i2.hi = (i2.hi | (n.get(r) & 127) >> 4) >>> 0, n.get(r++) < 128)
                return i2;
              o = 0;
            } else {
              for (; o < 3; ++o) {
                if (r >= e.length)
                  throw RangeError(`index out of range: ${r} > ${e.length}`);
                if (i2.lo = (i2.lo | (n.get(r) & 127) << o * 7) >>> 0, n.get(r++) < 128)
                  return i2;
              }
              return i2.lo = (i2.lo | (n.get(r++) & 127) << o * 7) >>> 0, i2;
            }
            if (e.length - r > 4) {
              for (; o < 5; ++o)
                if (i2.hi = (i2.hi | (n.get(r) & 127) << o * 7 + 3) >>> 0, n.get(r++) < 128)
                  return i2;
            } else
              for (; o < 5; ++o) {
                if (r >= e.length)
                  throw RangeError(`index out of range: ${r} > ${e.length}`);
                if (i2.hi = (i2.hi | (n.get(r) & 127) << o * 7 + 3) >>> 0, n.get(r++) < 128)
                  return i2;
              }
            throw Error("invalid varint encoding");
          }
        };
        var qF = 128, rge = 127, nge = ~rge, ige = Math.pow(2, 31), oge = Math.pow(2, 7), sge = Math.pow(2, 14), age = Math.pow(2, 21), cge = Math.pow(2, 28), uge = Math.pow(2, 35), lge = Math.pow(2, 42), fge = Math.pow(2, 49), hge = Math.pow(2, 56), dge = Math.pow(2, 63), We = { encodingLength(t) {
          return t < oge ? 1 : t < sge ? 2 : t < age ? 3 : t < cge ? 4 : t < uge ? 5 : t < lge ? 6 : t < fge ? 7 : t < hge ? 8 : t < dge ? 9 : 10;
        }, encode(t, e) {
          let r = 0, n = Ra(e);
          for (; t >= ige; )
            n.set(r++, t & 255 | qF), t /= 128;
          for (; (t & nge) > 0; )
            n.set(r++, t & 255 | qF), t >>>= 7;
          n.set(r, t | 0);
        }, decode(t, e = 0) {
          let r = Ra(t), n = 4294967295;
          if (n = (r.get(e) & 127) >>> 0, r.get(e++) < 128 || (n = (n | (r.get(e) & 127) << 7) >>> 0, r.get(e++) < 128) || (n = (n | (r.get(e) & 127) << 14) >>> 0, r.get(e++) < 128) || (n = (n | (r.get(e) & 127) << 21) >>> 0, r.get(e++) < 128) || (n = (n | (r.get(e) & 15) << 28) >>> 0, r.get(e++) < 128))
            return n;
          if ((e += 5) > t.length)
            throw RangeError(`index out of range: ${e} > ${t.length}`);
          return n;
        } }, Uw = { encodingLength(t) {
          return t < 0 ? 10 : We.encodingLength(t);
        }, encode(t, e) {
          if (t < 0) {
            let r = 0, n = Ra(e), i2 = Kn.fromNumber(t);
            for (; i2.hi > 0; )
              n.set(r++, i2.lo & 127 | 128), i2.lo = (i2.lo >>> 7 | i2.hi << 25) >>> 0, i2.hi >>>= 7;
            for (; i2.lo > 127; )
              n.set(r++, i2.lo & 127 | 128), i2.lo = i2.lo >>> 7;
            n.set(r++, i2.lo);
            return;
          }
          We.encode(t, e);
        }, decode(t, e = 0) {
          return We.decode(t, e) | 0;
        } }, Fw = { encodingLength(t) {
          return t = (t << 1 ^ t >> 31) >>> 0, We.encodingLength(t);
        }, encode(t, e, r = 0) {
          return t = (t << 1 ^ t >> 31) >>> 0, We.encode(t, e);
        }, decode(t, e = 0) {
          let r = We.decode(t, e);
          return r >>> 1 ^ -(r & 1) | 0;
        } };
        function Ye(t, e) {
          let r = new Uint8Array(We.encodingLength(t.length));
          return We.encode(t.length, r), e.decode(new qe(r, t), 0);
        }
        c();
        function Qe(t, e) {
          let r = e.encode(t), n = We.encodingLength(We.decode(r));
          return r.slice(n);
        }
        c();
        c();
        var ot;
        (function(t) {
          t[t.VARINT = 0] = "VARINT", t[t.BIT64 = 1] = "BIT64", t[t.LENGTH_DELIMITED = 2] = "LENGTH_DELIMITED", t[t.START_GROUP = 3] = "START_GROUP", t[t.END_GROUP = 4] = "END_GROUP", t[t.BIT32 = 5] = "BIT32";
        })(ot || (ot = {}));
        function Pt(t, e, r, n, i2) {
          return { name: t, type: e, encode: r, decode: n, encodingLength: i2 };
        }
        var pge = function() {
          return 1;
        }, mge = function(e) {
          return Uint8Array.from([e ? 1 : 0]);
        }, yge = function(e, r) {
          return e.get(r) > 0;
        }, P2 = Pt("bool", ot.VARINT, mge, yge, pge);
        c();
        var gge = function(e) {
          let r = e.byteLength;
          return We.encodingLength(r) + r;
        }, wge = function(e) {
          let r = new Uint8Array(We.encodingLength(e.byteLength));
          return We.encode(e.byteLength, r), new qe(r, e);
        }, Ege = function(e, r) {
          let n = We.decode(e, r);
          return r += We.encodingLength(n), e.slice(r, r + n);
        }, ye = Pt("bytes", ot.LENGTH_DELIMITED, wge, Ege, gge);
        c();
        var zF = function() {
          return 8;
        }, bge = function(e) {
          let r = new qe(new Uint8Array(zF(e)));
          return r.setFloat64(0, e, true), r;
        }, _ge = function(e, r) {
          return e.getFloat64(r, true);
        }, vge = Pt("double", ot.BIT64, bge, _ge, zF);
        c();
        function xi(t) {
          function e(o) {
            if (t[o.toString()] == null)
              throw new Error("Invalid enum value");
            return typeof o == "number" ? o : t[o];
          }
          let r = function(s) {
            return We.encodingLength(e(s));
          }, n = function(s) {
            let a = e(s), u = new Uint8Array(We.encodingLength(a));
            return We.encode(a, u), u;
          }, i2 = function(s, a) {
            let l = We.decode(s, a).toString();
            if (t[l] == null)
              throw new Error("Invalid enum value");
            return t[l];
          };
          return Pt("enum", ot.VARINT, n, i2, r);
        }
        c();
        var HF = function() {
          return 4;
        }, Sge = function(e) {
          let r = new qe(new Uint8Array(HF(e)));
          return r.setInt32(0, e, true), r;
        }, xge = function(e, r) {
          return e.getInt32(r, true);
        }, Rge = Pt("fixed32", ot.BIT32, Sge, xge, HF);
        c();
        var $F = function(e) {
          return 8;
        }, Age = function(e) {
          let r = new qe(new Uint8Array($F(e)));
          return r.setBigInt64(0, e, true), r;
        }, Tge = function(e, r) {
          return e.getBigInt64(r, true);
        }, Ige = Pt("fixed64", ot.BIT64, Age, Tge, $F);
        c();
        var GF = function() {
          return 4;
        }, Cge = function(e) {
          let r = new qe(new Uint8Array(GF(1)));
          return r.setFloat32(0, e, true), r;
        }, Pge = function(e, r) {
          return e.getFloat32(r, true);
        }, Dge = Pt("float", ot.BIT32, Cge, Pge, GF);
        c();
        var WF = function(e) {
          return Uw.encodingLength(e);
        }, kge = function(e) {
          let r = new Uint8Array(WF(e));
          return Uw.encode(e, r), r;
        }, Nge = function(e, r) {
          return Uw.decode(e, r);
        }, cx = Pt("int32", ot.VARINT, kge, Nge, WF);
        c();
        c();
        var jF = 0x7fn, rl = { encodingLength(t) {
          let e = 0;
          for (; t >= 0x80n; e++)
            t >>= 7n;
          return e + 1;
        }, encode(t, e) {
          let r = Ra(e), n = 0;
          for (; jF < t; )
            r.set(n++, Number(t & jF) | 128), t >>= 7n;
          r.set(n, Number(t));
        }, decode(t, e = 0) {
          return Kn.fromBytes(t, e).toBigInt(true);
        } }, Kw = { encodingLength(t) {
          return t < 0n ? 10 : rl.encodingLength(t);
        }, encode(t, e, r = 0) {
          if (t < 0n) {
            Kn.fromBigInt(t).toBytes(e, r);
            return;
          }
          return rl.encode(t, e);
        }, decode(t, e = 0) {
          return Kn.fromBytes(t, e).toBigInt(false);
        } }, Vw = { encodingLength(t) {
          return rl.encodingLength(t >= 0 ? t * 2n : t * -2n - 1n);
        }, encode(t, e, r = 0) {
          Kn.fromBigInt(t).zzEncode().toBytes(e, r);
        }, decode(t, e = 0) {
          return Kn.fromBytes(t, e).zzDecode().toBigInt(false);
        } };
        var YF = function(e) {
          return Kw.encodingLength(e);
        }, Oge = function(e) {
          let r = new Uint8Array(YF(e));
          return Kw.encode(e, r), r;
        }, Lge = function(e, r) {
          return Kw.decode(e, r) | 0n;
        }, Bge = Pt("int64", ot.VARINT, Oge, Lge, YF);
        c();
        function Xe(t) {
          let e = function(o) {
            let s = 0;
            for (let a of Object.values(t))
              s += a.codec.encodingLength(o[a.name]);
            return We.encodingLength(s) + s;
          }, r = function(o) {
            let s = new qe();
            function a(l, f, h) {
              if (l == null) {
                if (h.optional === true)
                  return;
                throw new Error(`Non optional field "${h.name}" was ${l === null ? "null" : "undefined"}`);
              }
              let p = f << 3 | h.codec.type, d = new Uint8Array(We.encodingLength(p));
              We.encode(p, d);
              let m = h.codec.encode(l);
              s.append(d), s.append(m);
            }
            for (let [l, f] of Object.entries(t)) {
              let h = parseInt(l);
              if (f.repeats === true) {
                if (!Array.isArray(o[f.name]))
                  throw new Error(`Repeating field "${f.name}" was not an array`);
                for (let p of o[f.name])
                  a(p, h, f);
              } else
                a(o[f.name], h, f);
            }
            let u = new Uint8Array(We.encodingLength(s.length));
            return We.encode(s.length, u), new qe(u, s);
          }, n = function(o, s) {
            let a = We.decode(o, s);
            s += We.encodingLength(a);
            let u = s + a, l = {};
            for (; s < u; ) {
              let f = We.decode(o, s);
              s += We.encodingLength(f);
              let h = f & 7, p = f >> 3, d = t[p], m = 0;
              if (h === ot.VARINT)
                if (d != null) {
                  let y = d.codec.decode(o, s);
                  m = d.codec.encodingLength(y);
                } else {
                  let y = We.decode(o, s);
                  m = We.encodingLength(y);
                }
              else if (h === ot.BIT64)
                m = 8;
              else if (h === ot.LENGTH_DELIMITED) {
                let y = We.decode(o, s);
                m = y + We.encodingLength(y);
              } else if (h === ot.BIT32)
                m = 4;
              else {
                if (h === ot.START_GROUP)
                  throw new Error("Unsupported wire type START_GROUP");
                if (h === ot.END_GROUP)
                  throw new Error("Unsupported wire type END_GROUP");
              }
              if (d != null) {
                let y = d.codec.decode(o, s);
                d.repeats === true ? (l[d.name] == null && (l[d.name] = []), l[d.name].push(y)) : l[d.name] = y;
              }
              s += m;
            }
            for (let f of Object.values(t))
              f.repeats === true && l[f.name] == null && (l[f.name] = []);
            return l;
          };
          return Pt("message", ot.LENGTH_DELIMITED, r, n, e);
        }
        c();
        var QF = function() {
          return 4;
        }, Mge = function(e) {
          let r = new qe(new Uint8Array(QF(e)));
          return r.setInt32(0, e, true), r;
        }, Uge = function(e, r) {
          return e.getInt32(r, true);
        }, Fge = Pt("sfixed32", ot.BIT32, Mge, Uge, QF);
        c();
        var XF = function() {
          return 8;
        }, Kge = function(e) {
          let r = new qe(new Uint8Array(XF(e)));
          return r.setBigInt64(0, e, true), r;
        }, Vge = function(e, r) {
          return e.getBigInt64(r, true);
        }, qge = Pt("sfixed64", ot.BIT64, Kge, Vge, XF);
        c();
        var ZF = function(e) {
          return Fw.encodingLength(e);
        }, zge = function(e) {
          let r = new Uint8Array(ZF(e));
          return Fw.encode(e, r), r;
        }, Hge = function(e, r) {
          return Fw.decode(e, r);
        }, $ge = Pt("sint32", ot.VARINT, zge, Hge, ZF);
        c();
        var JF = function(e) {
          return Vw.encodingLength(e);
        }, Gge = function(e) {
          let r = new Uint8Array(JF(e));
          return Vw.encode(e, r), r;
        }, Wge = function(e, r) {
          return Vw.decode(e, r);
        }, jge = Pt("sint64", ot.VARINT, Gge, Wge, JF);
        c();
        Re();
        me();
        var Yge = function(e) {
          let r = U(e).byteLength;
          return We.encodingLength(r) + r;
        }, Qge = function(e) {
          let r = U(e), n = new Uint8Array(We.encodingLength(r.byteLength));
          return We.encode(r.length, n), new qe(n, r);
        }, Xge = function(e, r) {
          let n = We.decode(e, r);
          return r += We.encodingLength(n), M(e.slice(r, r + n));
        }, pn = Pt("string", ot.LENGTH_DELIMITED, Qge, Xge, Yge);
        c();
        var eK = function(e) {
          return We.encodingLength(e);
        }, Zge = function(e) {
          let r = new Uint8Array(eK(e));
          return We.encode(e, r), r;
        }, Jge = function(e, r) {
          return We.decode(e, r);
        }, e3e = Pt("uint32", ot.VARINT, Zge, Jge, eK);
        c();
        var t3e = function(e) {
          return rl.encodingLength(e);
        }, r3e = function(e) {
          let r = new Uint8Array(rl.encodingLength(e));
          return rl.encode(e, r), r;
        }, n3e = function(e, r) {
          return rl.decode(e, r);
        }, nl = Pt("uint64", ot.VARINT, r3e, n3e, t3e);
        var Fr;
        (function(t) {
          t.RSA = "RSA", t.Ed25519 = "Ed25519", t.Secp256k1 = "Secp256k1";
        })(Fr || (Fr = {}));
        var ux;
        (function(t) {
          t[t.RSA = 0] = "RSA", t[t.Ed25519 = 1] = "Ed25519", t[t.Secp256k1 = 2] = "Secp256k1";
        })(ux || (ux = {}));
        (function(t) {
          t.codec = () => xi(ux);
        })(Fr || (Fr = {}));
        var Os;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "Type", codec: Fr.codec() }, 2: { name: "Data", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(Os || (Os = {}));
        var Ls;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "Type", codec: Fr.codec() }, 2: { name: "Data", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(Ls || (Ls = {}));
        var oHe = w(Aa(), 1), sHe = w(i6(), 1), b6 = w(st(), 1), _6 = w(K(), 1);
        Re();
        c();
        var kx = w(K(), 1);
        ur();
        Re();
        c();
        c();
        var an = { get(t = globalThis) {
          let e = t.crypto;
          if (e == null || e.subtle == null)
            throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
          return e;
        } };
        c();
        var dV = { SHA1: 20, SHA256: 32, SHA512: 64 };
        var Iwe = { SHA1: "SHA-1", SHA256: "SHA-256", SHA512: "SHA-512" }, Cwe = async (t, e) => {
          let r = await an.get().subtle.sign({ name: "HMAC" }, t, e);
          return new Uint8Array(r, 0, r.byteLength);
        };
        async function pV(t, e) {
          let r = Iwe[t], n = await an.get().subtle.importKey("raw", e, { name: "HMAC", hash: { name: r } }, false, ["sign"]);
          return { async digest(i2) {
            return await Cwe(n, i2);
          }, length: dV[t] };
        }
        var yV = { "AES-128": { ivSize: 16, keySize: 16 }, "AES-256": { ivSize: 16, keySize: 32 }, Blowfish: { ivSize: 8, keySize: 32 } };
        async function gV(t, e, r) {
          let n = yV[t];
          if (n == null) {
            let b = Object.keys(yV).join(" / ");
            throw (0, kx.default)(new Error(`unknown cipher type '${t}'. Must be ${b}`), "ERR_INVALID_CIPHER_TYPE");
          }
          if (e == null)
            throw (0, kx.default)(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
          let i2 = n.keySize, o = n.ivSize, s = 20, a = U("key expansion"), u = 2 * (o + i2 + s), l = await pV(e, r), f = await l.digest(a), h = [], p = 0;
          for (; p < u; ) {
            let b = await l.digest(Ae([f, a])), v = b.length;
            p + v > u && (v = u - p), h.push(b), p += v, f = await l.digest(f);
          }
          let d = u / 2, m = Ae(h), y = m.slice(0, d), g = m.slice(d, u), E = (b) => ({ iv: b.slice(0, o), cipherKey: b.slice(o, o + i2), macKey: b.slice(o + i2) });
          return { k1: E(y), k2: E(g) };
        }
        c();
        c();
        var Xp = w(K(), 1);
        c();
        var sze = w(gr(), 1), aze = w(L2(), 1), wV = w(st(), 1);
        Re();
        me();
        ur();
        function Us(t, e) {
          let r = Uint8Array.from(t.abs().toByteArray());
          if (r = r[0] === 0 ? r.slice(1) : r, e != null) {
            if (r.length > e)
              throw new Error("byte array longer than desired length");
            r = Ae([new Uint8Array(e - r.length), r]);
          }
          return M(r, "base64url");
        }
        function lo(t) {
          let e = o6(t);
          return new wV.default.jsbn.BigInteger(M(e, "base16"), 16);
        }
        function o6(t, e) {
          let r = U(t, "base64urlpad");
          if (e != null) {
            if (r.length > e)
              throw new Error("byte array longer than desired length");
            r = Ae([new Uint8Array(e - r.length), r]);
          }
          return r;
        }
        me();
        ur();
        yr();
        var EV = { "P-256": 256, "P-384": 384, "P-521": 521 }, Pwe = Object.keys(EV), Nx = Pwe.join(" / ");
        async function bV(t) {
          if (t !== "P-256" && t !== "P-384" && t !== "P-521")
            throw (0, Xp.default)(new Error(`Unknown curve: ${t}. Must be ${Nx}`), "ERR_INVALID_CURVE");
          let e = await an.get().subtle.generateKey({ name: "ECDH", namedCurve: t }, true, ["deriveBits"]), r = async (o, s) => {
            let a;
            s != null ? a = await an.get().subtle.importKey("jwk", kwe(t, s), { name: "ECDH", namedCurve: t }, false, ["deriveBits"]) : a = e.privateKey;
            let u = await an.get().subtle.importKey("jwk", vV(t, o), { name: "ECDH", namedCurve: t }, false, []), l = await an.get().subtle.deriveBits({ name: "ECDH", namedCurve: t, public: u }, a, EV[t]);
            return new Uint8Array(l, 0, l.byteLength);
          }, n = await an.get().subtle.exportKey("jwk", e.publicKey);
          return { key: Dwe(n), genSharedKey: r };
        }
        var _V = { "P-256": 32, "P-384": 48, "P-521": 66 };
        function Dwe(t) {
          if (t.crv == null || t.x == null || t.y == null)
            throw (0, Xp.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
          if (t.crv !== "P-256" && t.crv !== "P-384" && t.crv !== "P-521")
            throw (0, Xp.default)(new Error(`Unknown curve: ${t.crv}. Must be ${Nx}`), "ERR_INVALID_CURVE");
          let e = _V[t.crv];
          return Ae([Uint8Array.from([4]), o6(t.x, e), o6(t.y, e)], 1 + e * 2);
        }
        function vV(t, e) {
          if (t !== "P-256" && t !== "P-384" && t !== "P-521")
            throw (0, Xp.default)(new Error(`Unknown curve: ${t}. Must be ${Nx}`), "ERR_INVALID_CURVE");
          let r = _V[t];
          if (!Ce(e.slice(0, 1), Uint8Array.from([4])))
            throw (0, Xp.default)(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
          return { kty: "EC", crv: t, x: M(e.slice(1, r + 1), "base64url"), y: M(e.slice(1 + r), "base64url"), ext: true };
        }
        var kwe = (t, e) => ({ ...vV(t, e.public), d: M(e.private, "base64url") });
        var SV = bV;
        c();
        ma();
        c();
        ur();
        Re();
        function s6(t) {
          let e = t?.algorithm ?? "AES-GCM", r = t?.keyLength ?? 16, n = t?.nonceLength ?? 12, i2 = t?.digest ?? "SHA-256", o = t?.saltLength ?? 16, s = t?.iterations ?? 32767, a = an.get();
          r *= 8;
          async function u(h, p) {
            let d = a.getRandomValues(new Uint8Array(o)), m = a.getRandomValues(new Uint8Array(n)), y = { name: e, iv: m };
            typeof p == "string" && (p = U(p));
            let g = { name: "PBKDF2", salt: d, iterations: s, hash: { name: i2 } }, E = await a.subtle.importKey("raw", p, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]), b = await a.subtle.deriveKey(g, E, { name: e, length: r }, true, ["encrypt"]), v = await a.subtle.encrypt(y, b, h);
            return Ae([d, y.iv, new Uint8Array(v)]);
          }
          async function l(h, p) {
            let d = h.slice(0, o), m = h.slice(o, o + n), y = h.slice(o + n), g = { name: e, iv: m };
            typeof p == "string" && (p = U(p));
            let E = { name: "PBKDF2", salt: d, iterations: s, hash: { name: i2 } }, b = await a.subtle.importKey("raw", p, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]), v = await a.subtle.deriveKey(E, b, { name: e, length: r }, true, ["decrypt"]), S = await a.subtle.decrypt(g, v, y);
            return new Uint8Array(S);
          }
          return { encrypt: u, decrypt: l };
        }
        async function RV(t, e) {
          let r = to.decode(t);
          return await s6().decrypt(r, e);
        }
        var Vx = {};
        ct(Vx, { RsaPrivateKey: () => Jp, RsaPublicKey: () => U2, fromJwk: () => zwe, generateKeyPair: () => Hwe, unmarshalRsaPrivateKey: () => Vwe, unmarshalRsaPublicKey: () => qwe });
        c();
        vr();
        var Kx = w(K(), 1);
        yr();
        me();
        var Gze = w(Bx(), 1), M2 = w(st(), 1);
        c();
        c();
        var DV = w(uh(), 1), kV = w(K(), 1);
        function Fs(t) {
          if (isNaN(t) || t <= 0)
            throw (0, kV.default)(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
          return (0, DV.default)(t);
        }
        me();
        Re();
        var lh = {};
        ct(lh, { jwkToPkcs1: () => Bwe, jwkToPkix: () => Uwe, pkcs1ToJwk: () => Lwe, pkixToJwk: () => Mwe });
        c();
        var Ize = w(Aa(), 1), Cze = w(sh(), 1), Oc = w(st(), 1);
        Re();
        me();
        var Mx = w(K(), 1);
        function Lwe(t) {
          let e = Oc.default.asn1.fromDer(M(t, "ascii")), r = Oc.default.pki.privateKeyFromAsn1(e);
          return { kty: "RSA", n: Us(r.n), e: Us(r.e), d: Us(r.d), p: Us(r.p), q: Us(r.q), dp: Us(r.dP), dq: Us(r.dQ), qi: Us(r.qInv), alg: "RS256" };
        }
        function Bwe(t) {
          if (t.n == null || t.e == null || t.d == null || t.p == null || t.q == null || t.dp == null || t.dq == null || t.qi == null)
            throw (0, Mx.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
          let e = Oc.default.pki.privateKeyToAsn1({ n: lo(t.n), e: lo(t.e), d: lo(t.d), p: lo(t.p), q: lo(t.q), dP: lo(t.dp), dQ: lo(t.dq), qInv: lo(t.qi) });
          return U(Oc.default.asn1.toDer(e).getBytes(), "ascii");
        }
        function Mwe(t) {
          let e = Oc.default.asn1.fromDer(M(t, "ascii")), r = Oc.default.pki.publicKeyFromAsn1(e);
          return { kty: "RSA", n: Us(r.n), e: Us(r.e) };
        }
        function Uwe(t) {
          if (t.n == null || t.e == null)
            throw (0, Mx.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
          let e = Oc.default.pki.publicKeyToAsn1({ n: lo(t.n), e: lo(t.e) });
          return U(Oc.default.asn1.toDer(e).getBytes(), "ascii");
        }
        c();
        var Nze = w(sh(), 1), Ux = w(st(), 1);
        function NV(t, e) {
          return e.map((r) => lo(t[r]));
        }
        function OV(t) {
          return Ux.default.pki.setRsaPrivateKey(...NV(t, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
        }
        function LV(t) {
          return Ux.default.pki.setRsaPublicKey(...NV(t, ["n", "e"]));
        }
        var BV = w(K(), 1);
        async function MV(t) {
          let e = await an.get().subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign", "verify"]), r = await KV(e);
          return { privateKey: r[0], publicKey: r[1] };
        }
        async function Fx(t) {
          let r = [await an.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["sign"]), await Fwe(t)], n = await KV({ privateKey: r[0], publicKey: r[1] });
          return { privateKey: n[0], publicKey: n[1] };
        }
        async function UV(t, e) {
          let r = await an.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["sign"]), n = await an.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, r, Uint8Array.from(e));
          return new Uint8Array(n, 0, n.byteLength);
        }
        async function FV(t, e, r) {
          let n = await an.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["verify"]);
          return await an.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, n, e, r);
        }
        async function KV(t) {
          if (t.privateKey == null || t.publicKey == null)
            throw (0, BV.default)(new Error("Private and public key are required"), "ERR_INVALID_PARAMETERS");
          return await Promise.all([an.get().subtle.exportKey("jwk", t.privateKey), an.get().subtle.exportKey("jwk", t.publicKey)]);
        }
        async function Fwe(t) {
          return await an.get().subtle.importKey("jwk", { kty: t.kty, n: t.n, e: t.e }, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["verify"]);
        }
        function VV(t, e, r, n) {
          let i2 = e ? LV(t) : OV(t), o = M(Uint8Array.from(r), "ascii"), s = n(o, i2);
          return U(s, "ascii");
        }
        function qV(t, e) {
          return VV(t, true, e, (r, n) => n.encrypt(r));
        }
        function zV(t, e) {
          return VV(t, false, e, (r, n) => n.decrypt(r));
        }
        c();
        ma();
        async function Zp(t, e) {
          let n = await s6().encrypt(t, e);
          return to.encode(n);
        }
        var U2 = class {
          constructor(e) {
            this._key = e;
          }
          async verify(e, r) {
            return await FV(this._key, r, e);
          }
          marshal() {
            return lh.jwkToPkix(this._key);
          }
          get bytes() {
            return Os.encode({ Type: Fr.RSA, Data: this.marshal() });
          }
          encrypt(e) {
            return qV(this._key, e);
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, Jp = class {
          constructor(e, r) {
            this._key = e, this._publicKey = r;
          }
          genSecret() {
            return Fs(16);
          }
          async sign(e) {
            return await UV(this._key, e);
          }
          get public() {
            if (this._publicKey == null)
              throw (0, Kx.default)(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
            return new U2(this._publicKey);
          }
          decrypt(e) {
            return zV(this._key, e);
          }
          marshal() {
            return lh.jwkToPkcs1(this._key);
          }
          get bytes() {
            return Ls.encode({ Type: Fr.RSA, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await this.public.hash();
            return M(e, "base58btc");
          }
          async export(e, r = "pkcs-8") {
            if (r === "pkcs-8") {
              let n = new M2.default.util.ByteBuffer(this.marshal()), i2 = M2.default.asn1.fromDer(n), o = M2.default.pki.privateKeyFromAsn1(i2), s = { algorithm: "aes256", count: 1e4, saltSize: 128 / 8, prfAlgorithm: "sha512" };
              return M2.default.pki.encryptRsaPrivateKey(o, e, s);
            } else {
              if (r === "libp2p-key")
                return await Zp(this.bytes, e);
              throw (0, Kx.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
            }
          }
        };
        async function Vwe(t) {
          let e = lh.pkcs1ToJwk(t), r = await Fx(e);
          return new Jp(r.privateKey, r.publicKey);
        }
        function qwe(t) {
          let e = lh.pkixToJwk(t);
          return new U2(e);
        }
        async function zwe(t) {
          let e = await Fx(t);
          return new Jp(e.privateKey, e.publicKey);
        }
        async function Hwe(t) {
          let e = await MV(t);
          return new Jp(e.privateKey, e.publicKey);
        }
        var Qx = {};
        ct(Qx, { Ed25519PrivateKey: () => dh, Ed25519PublicKey: () => q2, generateKeyPair: () => i6e, generateKeyPairFromSeed: () => Yx, unmarshalEd25519PrivateKey: () => r6e, unmarshalEd25519PublicKey: () => n6e });
        c();
        var jx = w(K(), 1);
        yr();
        vr();
        Hr();
        va();
        c();
        c();
        var WV = w(rh(), 1);
        var An = BigInt(0), Nt = BigInt(1), Ti = BigInt(2), jV = BigInt(255), HV = Ti ** BigInt(252) + BigInt("27742317777372353535851937790883648493"), Dr = { a: BigInt(-1), d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"), P: Ti ** jV - BigInt(19), l: HV, n: HV, h: BigInt(8), Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"), Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") };
        var YV = Ti ** BigInt(256), F2 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"), jze = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"), $we = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"), Gwe = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"), Wwe = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"), jwe = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"), kt = class {
          constructor(e, r, n, i2) {
            this.x = e, this.y = r, this.z = n, this.t = i2;
          }
          static fromAffine(e) {
            if (!(e instanceof Kr))
              throw new TypeError("ExtendedPoint#fromAffine: expected Point");
            return e.equals(Kr.ZERO) ? kt.ZERO : new kt(e.x, e.y, Nt, X(e.x * e.y));
          }
          static toAffineBatch(e) {
            let r = Xwe(e.map((n) => n.z));
            return e.map((n, i2) => n.toAffine(r[i2]));
          }
          static normalizeZ(e) {
            return this.toAffineBatch(e).map(this.fromAffine);
          }
          equals(e) {
            $V(e);
            let { x: r, y: n, z: i2 } = this, { x: o, y: s, z: a } = e, u = X(r * a), l = X(o * i2), f = X(n * a), h = X(s * i2);
            return u === l && f === h;
          }
          negate() {
            return new kt(X(-this.x), this.y, this.z, X(-this.t));
          }
          double() {
            let { x: e, y: r, z: n } = this, { a: i2 } = Dr, o = X(e ** Ti), s = X(r ** Ti), a = X(Ti * X(n ** Ti)), u = X(i2 * o), l = X(X((e + r) ** Ti) - o - s), f = u + s, h = f - a, p = u - s, d = X(l * h), m = X(f * p), y = X(l * p), g = X(h * f);
            return new kt(d, m, g, y);
          }
          add(e) {
            $V(e);
            let { x: r, y: n, z: i2, t: o } = this, { x: s, y: a, z: u, t: l } = e, f = X((n - r) * (a + s)), h = X((n + r) * (a - s)), p = X(h - f);
            if (p === An)
              return this.double();
            let d = X(i2 * Ti * l), m = X(o * Ti * u), y = m + d, g = h + f, E = m - d, b = X(y * p), v = X(g * E), S = X(y * E), x = X(p * g);
            return new kt(b, v, x, S);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          precomputeWindow(e) {
            let r = 1 + 256 / e, n = [], i2 = this, o = i2;
            for (let s = 0; s < r; s++) {
              o = i2, n.push(o);
              for (let a = 1; a < 2 ** (e - 1); a++)
                o = o.add(i2), n.push(o);
              i2 = o.double();
            }
            return n;
          }
          wNAF(e, r) {
            !r && this.equals(kt.BASE) && (r = Kr.BASE);
            let n = r && r._WINDOW_SIZE || 1;
            if (256 % n)
              throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let i2 = r && $x.get(r);
            i2 || (i2 = this.precomputeWindow(n), r && n !== 1 && (i2 = kt.normalizeZ(i2), $x.set(r, i2)));
            let o = kt.ZERO, s = kt.ZERO, a = 1 + 256 / n, u = 2 ** (n - 1), l = BigInt(2 ** n - 1), f = 2 ** n, h = BigInt(n);
            for (let p = 0; p < a; p++) {
              let d = p * u, m = Number(e & l);
              if (e >>= h, m > u && (m -= f, e += Nt), m === 0) {
                let y = i2[d];
                p % 2 && (y = y.negate()), s = s.add(y);
              } else {
                let y = i2[d + Math.abs(m) - 1];
                m < 0 && (y = y.negate()), o = o.add(y);
              }
            }
            return kt.normalizeZ([o, s])[0];
          }
          multiply(e, r) {
            return this.wNAF(a6(e, Dr.l), r);
          }
          multiplyUnsafe(e) {
            let r = a6(e, Dr.l, false), n = kt.BASE, i2 = kt.ZERO;
            if (r === An)
              return i2;
            if (this.equals(i2) || r === Nt)
              return this;
            if (this.equals(n))
              return this.wNAF(r);
            let o = i2, s = this;
            for (; r > An; )
              r & Nt && (o = o.add(s)), s = s.double(), r >>= Nt;
            return o;
          }
          isSmallOrder() {
            return this.multiplyUnsafe(Dr.h).equals(kt.ZERO);
          }
          isTorsionFree() {
            return this.multiplyUnsafe(Dr.l).equals(kt.ZERO);
          }
          toAffine(e = c6(this.z)) {
            let { x: r, y: n, z: i2 } = this, o = X(r * e), s = X(n * e);
            if (X(i2 * e) !== Nt)
              throw new Error("invZ was invalid");
            return new Kr(o, s);
          }
          fromRistrettoBytes() {
            zx();
          }
          toRistrettoBytes() {
            zx();
          }
          fromRistrettoHash() {
            zx();
          }
        };
        kt.BASE = new kt(Dr.Gx, Dr.Gy, Nt, X(Dr.Gx * Dr.Gy));
        kt.ZERO = new kt(An, Nt, Nt, An);
        function $V(t) {
          if (!(t instanceof kt))
            throw new TypeError("ExtendedPoint expected");
        }
        function qx(t) {
          if (!(t instanceof Hi))
            throw new TypeError("RistrettoPoint expected");
        }
        function zx() {
          throw new Error("Legacy method: switch to RistrettoPoint");
        }
        var Hi = class {
          constructor(e) {
            this.ep = e;
          }
          static calcElligatorRistrettoMap(e) {
            let { d: r } = Dr, n = X(F2 * e * e), i2 = X((n + Nt) * Wwe), o = BigInt(-1), s = X((o - r * n) * X(n + r)), { isValid: a, value: u } = Wx(i2, s), l = X(u * e);
            ll(l) || (l = X(-l)), a || (u = l), a || (o = n);
            let f = X(o * (n - Nt) * jwe - s), h = u * u, p = X((u + u) * s), d = X(f * $we), m = X(Nt - h), y = X(Nt + h);
            return new kt(X(p * y), X(m * d), X(d * y), X(p * m));
          }
          static hashToCurve(e) {
            e = fl(e, 64);
            let r = Hx(e.slice(0, 32)), n = this.calcElligatorRistrettoMap(r), i2 = Hx(e.slice(32, 64)), o = this.calcElligatorRistrettoMap(i2);
            return new Hi(n.add(o));
          }
          static fromHex(e) {
            e = fl(e, 32);
            let { a: r, d: n } = Dr, i2 = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", o = Hx(e);
            if (!Jwe(K2(o), e) || ll(o))
              throw new Error(i2);
            let s = X(o * o), a = X(Nt + r * s), u = X(Nt - r * s), l = X(a * a), f = X(u * u), h = X(r * n * l - f), { isValid: p, value: d } = GV(X(h * f)), m = X(d * u), y = X(d * m * h), g = X((o + o) * m);
            ll(g) && (g = X(-g));
            let E = X(a * y), b = X(g * E);
            if (!p || ll(b) || E === An)
              throw new Error(i2);
            return new Hi(new kt(g, E, Nt, b));
          }
          toRawBytes() {
            let { x: e, y: r, z: n, t: i2 } = this.ep, o = X(X(n + r) * X(n - r)), s = X(e * r), { value: a } = GV(X(o * s ** Ti)), u = X(a * o), l = X(a * s), f = X(u * l * i2), h;
            if (ll(i2 * f)) {
              let d = X(r * F2), m = X(e * F2);
              e = d, r = m, h = X(u * Gwe);
            } else
              h = l;
            ll(e * f) && (r = X(-r));
            let p = X((n - r) * h);
            return ll(p) && (p = X(-p)), K2(p);
          }
          toHex() {
            return V2(this.toRawBytes());
          }
          toString() {
            return this.toHex();
          }
          equals(e) {
            qx(e);
            let r = this.ep, n = e.ep, i2 = X(r.x * n.y) === X(r.y * n.x), o = X(r.y * n.y) === X(r.x * n.x);
            return i2 || o;
          }
          add(e) {
            return qx(e), new Hi(this.ep.add(e.ep));
          }
          subtract(e) {
            return qx(e), new Hi(this.ep.subtract(e.ep));
          }
          multiply(e) {
            return new Hi(this.ep.multiply(e));
          }
          multiplyUnsafe(e) {
            return new Hi(this.ep.multiplyUnsafe(e));
          }
        };
        Hi.BASE = new Hi(kt.BASE);
        Hi.ZERO = new Hi(kt.ZERO);
        var $x = /* @__PURE__ */ new WeakMap(), Kr = class {
          constructor(e, r) {
            this.x = e, this.y = r;
          }
          _setWindowSize(e) {
            this._WINDOW_SIZE = e, $x.delete(this);
          }
          static fromHex(e, r = true) {
            let { d: n, P: i2 } = Dr;
            e = fl(e, 32);
            let o = e.slice();
            o[31] = e[31] & -129;
            let s = e0(o);
            if (r && s >= i2)
              throw new Error("Expected 0 < hex < P");
            if (!r && s >= YV)
              throw new Error("Expected 0 < hex < 2**256");
            let a = X(s * s), u = X(a - Nt), l = X(n * a + Nt), { isValid: f, value: h } = Wx(u, l);
            if (!f)
              throw new Error("Point.fromHex: invalid y coordinate");
            let p = (h & Nt) === Nt;
            return (e[31] & 128) !== 0 !== p && (h = X(-h)), new Kr(h, s);
          }
          static async fromPrivateKey(e) {
            return (await u6(e)).point;
          }
          toRawBytes() {
            let e = K2(this.y);
            return e[31] |= this.x & Nt ? 128 : 0, e;
          }
          toHex() {
            return V2(this.toRawBytes());
          }
          toX25519() {
            let { y: e } = this, r = X((Nt + e) * c6(Nt - e));
            return K2(r);
          }
          isTorsionFree() {
            return kt.fromAffine(this).isTorsionFree();
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new Kr(X(-this.x), this.y);
          }
          add(e) {
            return kt.fromAffine(this).add(kt.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return kt.fromAffine(this).multiply(e, this).toAffine();
          }
        };
        Kr.BASE = new Kr(Dr.Gx, Dr.Gy);
        Kr.ZERO = new Kr(An, Nt);
        var fh = class {
          constructor(e, r) {
            this.r = e, this.s = r, this.assertValidity();
          }
          static fromHex(e) {
            let r = fl(e, 64), n = Kr.fromHex(r.slice(0, 32), false), i2 = e0(r.slice(32, 64));
            return new fh(n, i2);
          }
          assertValidity() {
            let { r: e, s: r } = this;
            if (!(e instanceof Kr))
              throw new Error("Expected Point instance");
            return a6(r, Dr.l, false), this;
          }
          toRawBytes() {
            let e = new Uint8Array(64);
            return e.set(this.r.toRawBytes()), e.set(K2(this.s), 32), e;
          }
          toHex() {
            return V2(this.toRawBytes());
          }
        };
        function Ywe(...t) {
          if (!t.every((n) => n instanceof Uint8Array))
            throw new Error("Expected Uint8Array list");
          if (t.length === 1)
            return t[0];
          let e = t.reduce((n, i2) => n + i2.length, 0), r = new Uint8Array(e);
          for (let n = 0, i2 = 0; n < t.length; n++) {
            let o = t[n];
            r.set(o, i2), i2 += o.length;
          }
          return r;
        }
        var Qwe = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        function V2(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Uint8Array expected");
          let e = "";
          for (let r = 0; r < t.length; r++)
            e += Qwe[t[r]];
          return e;
        }
        function QV(t) {
          if (typeof t != "string")
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex");
          let e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            let n = r * 2, i2 = t.slice(n, n + 2), o = Number.parseInt(i2, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            e[r] = o;
          }
          return e;
        }
        function XV(t) {
          let r = t.toString(16).padStart(64, "0");
          return QV(r);
        }
        function K2(t) {
          return XV(t).reverse();
        }
        function ll(t) {
          return (X(t) & Nt) === Nt;
        }
        function e0(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          return BigInt("0x" + V2(Uint8Array.from(t).reverse()));
        }
        function Hx(t) {
          return X(e0(t) & Ti ** jV - Nt);
        }
        function X(t, e = Dr.P) {
          let r = t % e;
          return r >= An ? r : e + r;
        }
        function c6(t, e = Dr.P) {
          if (t === An || e <= An)
            throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
          let r = X(t, e), n = e, i2 = An, o = Nt, s = Nt, a = An;
          for (; r !== An; ) {
            let l = n / r, f = n % r, h = i2 - s * l, p = o - a * l;
            n = r, r = f, i2 = s, o = a, s = h, a = p;
          }
          if (n !== Nt)
            throw new Error("invert: does not exist");
          return X(i2, e);
        }
        function Xwe(t, e = Dr.P) {
          let r = new Array(t.length), n = t.reduce((o, s, a) => s === An ? o : (r[a] = o, X(o * s, e)), Nt), i2 = c6(n, e);
          return t.reduceRight((o, s, a) => s === An ? o : (r[a] = X(o * r[a], e), X(o * s, e)), i2), r;
        }
        function Na(t, e) {
          let { P: r } = Dr, n = t;
          for (; e-- > An; )
            n *= n, n %= r;
          return n;
        }
        function Zwe(t) {
          let { P: e } = Dr, r = BigInt(5), n = BigInt(10), i2 = BigInt(20), o = BigInt(40), s = BigInt(80), u = t * t % e * t % e, l = Na(u, Ti) * u % e, f = Na(l, Nt) * t % e, h = Na(f, r) * f % e, p = Na(h, n) * h % e, d = Na(p, i2) * p % e, m = Na(d, o) * d % e, y = Na(m, s) * m % e, g = Na(y, s) * m % e, E = Na(g, n) * h % e;
          return { pow_p_5_8: Na(E, Ti) * t % e, b2: u };
        }
        function Wx(t, e) {
          let r = X(e * e * e), n = X(r * r * e), i2 = Zwe(t * n).pow_p_5_8, o = X(t * r * i2), s = X(e * o * o), a = o, u = X(o * F2), l = s === t, f = s === X(-t), h = s === X(-t * F2);
          return l && (o = a), (f || h) && (o = u), ll(o) && (o = X(-o)), { isValid: l || f, value: o };
        }
        function GV(t) {
          return Wx(Nt, t);
        }
        async function Gx(...t) {
          let e = await hh.sha512(Ywe(...t)), r = e0(e);
          return X(r, Dr.l);
        }
        function Jwe(t, e) {
          if (t.length !== e.length)
            return false;
          for (let r = 0; r < t.length; r++)
            if (t[r] !== e[r])
              return false;
          return true;
        }
        function fl(t, e) {
          let r = t instanceof Uint8Array ? Uint8Array.from(t) : QV(t);
          if (typeof e == "number" && r.length !== e)
            throw new Error(`Expected ${e} bytes`);
          return r;
        }
        function a6(t, e, r = true) {
          if (!e)
            throw new TypeError("Specify max value");
          if (typeof t == "number" && Number.isSafeInteger(t) && (t = BigInt(t)), typeof t == "bigint" && t < e) {
            if (r) {
              if (An < t)
                return t;
            } else if (An <= t)
              return t;
          }
          throw new TypeError("Expected valid scalar: 0 < scalar < max");
        }
        function e6e(t) {
          return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
        }
        async function u6(t) {
          if (t = typeof t == "bigint" || typeof t == "number" ? XV(a6(t, YV)) : fl(t), t.length !== 32)
            throw new Error("Expected 32 bytes");
          let e = await hh.sha512(t), r = e6e(e.slice(0, 32)), n = e.slice(32, 64), i2 = X(e0(r), Dr.l), o = Kr.BASE.multiply(i2), s = o.toRawBytes();
          return { head: r, prefix: n, scalar: i2, point: o, pointBytes: s };
        }
        async function t0(t) {
          return (await u6(t)).pointBytes;
        }
        async function l6(t, e) {
          t = fl(t);
          let { prefix: r, scalar: n, pointBytes: i2 } = await u6(e), o = await Gx(r, t), s = Kr.BASE.multiply(o), a = await Gx(s.toRawBytes(), i2, t), u = X(o + a * n, Dr.l);
          return new fh(s, u).toRawBytes();
        }
        async function f6(t, e, r) {
          e = fl(e), r instanceof Kr || (r = Kr.fromHex(r, false));
          let { r: n, s: i2 } = t instanceof fh ? t.assertValidity() : fh.fromHex(t), o = kt.BASE.multiplyUnsafe(i2), s = await Gx(n.toRawBytes(), r.toRawBytes(), e), a = kt.fromAffine(r).multiplyUnsafe(s);
          return kt.fromAffine(n).add(a).subtract(o).multiplyUnsafe(Dr.h).equals(kt.ZERO);
        }
        Kr.BASE._setWindowSize(8);
        var ul = { node: WV.default, web: typeof self == "object" && "crypto" in self ? self.crypto : void 0 }, hh = { TORSION_SUBGROUP: ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"], bytesToHex: V2, getExtendedPublicKey: u6, mod: X, invert: c6, hashToPrivateScalar: (t) => {
          if (t = fl(t), t.length < 40 || t.length > 1024)
            throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
          let e = X(e0(t), Dr.l);
          if (e === An || e === Nt)
            throw new Error("Invalid private key");
          return e;
        }, randomBytes: (t = 32) => {
          if (ul.web)
            return ul.web.getRandomValues(new Uint8Array(t));
          if (ul.node) {
            let { randomBytes: e } = ul.node;
            return new Uint8Array(e(t).buffer);
          } else
            throw new Error("The environment doesn't have randomBytes function");
        }, randomPrivateKey: () => hh.randomBytes(32), sha512: async (t) => {
          if (ul.web) {
            let e = await ul.web.subtle.digest("SHA-512", t.buffer);
            return new Uint8Array(e);
          } else {
            if (ul.node)
              return Uint8Array.from(ul.node.createHash("sha512").update(t).digest());
            throw new Error("The environment doesn't have sha512 function");
          }
        }, precompute(t = 8, e = Kr.BASE) {
          let r = e.equals(Kr.BASE) ? e : new Kr(e.x, e.y);
          return r._setWindowSize(t), r.multiply(Ti), r;
        } };
        var r0 = 32, Lc = 64, h6 = 32;
        async function JV() {
          let t = hh.randomPrivateKey(), e = await t0(t);
          return { privateKey: nq(t, e), publicKey: e };
        }
        async function eq(t) {
          if (t.length !== h6)
            throw new TypeError('"seed" must be 32 bytes in length.');
          if (!(t instanceof Uint8Array))
            throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
          let e = t, r = await t0(e);
          return { privateKey: nq(e, r), publicKey: r };
        }
        async function tq(t, e) {
          let r = t.slice(0, h6);
          return await l6(e, r);
        }
        async function rq(t, e, r) {
          return await f6(e, r, t);
        }
        function nq(t, e) {
          let r = new Uint8Array(Lc);
          for (let n = 0; n < h6; n++)
            r[n] = t[n], r[h6 + n] = e[n];
          return r;
        }
        var q2 = class {
          constructor(e) {
            this._key = n0(e, r0);
          }
          async verify(e, r) {
            return await rq(this._key, r, e);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return Os.encode({ Type: Fr.Ed25519, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, dh = class {
          constructor(e, r) {
            this._key = n0(e, Lc), this._publicKey = n0(r, r0);
          }
          async sign(e) {
            return await tq(this._key, e);
          }
          get public() {
            return new q2(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return Ls.encode({ Type: Fr.Ed25519, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await $r.digest(this.public.bytes);
            return Ne.encode(e.bytes).substring(1);
          }
          async export(e, r = "libp2p-key") {
            if (r === "libp2p-key")
              return await Zp(this.bytes, e);
            throw (0, jx.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        };
        function r6e(t) {
          if (t.length > Lc) {
            t = n0(t, Lc + r0);
            let n = t.slice(0, Lc), i2 = t.slice(Lc, t.length);
            return new dh(n, i2);
          }
          t = n0(t, Lc);
          let e = t.slice(0, Lc), r = t.slice(r0);
          return new dh(e, r);
        }
        function n6e(t) {
          return t = n0(t, r0), new q2(t);
        }
        async function i6e() {
          let { privateKey: t, publicKey: e } = await JV();
          return new dh(t, e);
        }
        async function Yx(t) {
          let { privateKey: e, publicKey: r } = await eq(t);
          return new dh(e, r);
        }
        function n0(t, e) {
          if (t = Uint8Array.from(t ?? []), t.length !== e)
            throw (0, jx.default)(new Error(`Key must be a Uint8Array of length ${e}, got ${t.length}`), "ERR_INVALID_KEY_TYPE");
          return t;
        }
        var nR = {};
        ct(nR, { Secp256k1PrivateKey: () => j2, Secp256k1PublicKey: () => W2, generateKeyPair: () => b6e, unmarshalSecp256k1PrivateKey: () => w6e, unmarshalSecp256k1PublicKey: () => E6e });
        c();
        vr();
        var _q = w(K(), 1);
        yr();
        me();
        c();
        var c0 = w(K(), 1);
        c();
        var o6e = w(rh(), 1);
        var Ot = BigInt(0), wr = BigInt(1), cn = BigInt(2), H2 = BigInt(3), s6e = BigInt(8), Jx = cn ** BigInt(256), xr = { a: Ot, b: BigInt(7), P: Jx - cn ** BigInt(32) - BigInt(977), n: Jx - BigInt("432420386565659656852420866394968145599"), h: wr, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee") };
        function iq(t) {
          let { a: e, b: r } = xr, n = pe(t * t), i2 = pe(n * t);
          return pe(i2 + e * t + r);
        }
        var d6 = xr.a === Ot, qt = class {
          constructor(e, r, n) {
            this.x = e, this.y = r, this.z = n;
          }
          static fromAffine(e) {
            if (!(e instanceof Tt))
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            return new qt(e.x, e.y, wr);
          }
          static toAffineBatch(e) {
            let r = l6e(e.map((n) => n.z));
            return e.map((n, i2) => n.toAffine(r[i2]));
          }
          static normalizeZ(e) {
            return qt.toAffineBatch(e).map(qt.fromAffine);
          }
          equals(e) {
            if (!(e instanceof qt))
              throw new TypeError("JacobianPoint expected");
            let { x: r, y: n, z: i2 } = this, { x: o, y: s, z: a } = e, u = pe(i2 ** cn), l = pe(a ** cn), f = pe(r * l), h = pe(o * u), p = pe(pe(n * a) * l), d = pe(pe(s * i2) * u);
            return f === h && p === d;
          }
          negate() {
            return new qt(this.x, pe(-this.y), this.z);
          }
          double() {
            let { x: e, y: r, z: n } = this, i2 = pe(e ** cn), o = pe(r ** cn), s = pe(o ** cn), a = pe(cn * (pe((e + o) ** cn) - i2 - s)), u = pe(H2 * i2), l = pe(u ** cn), f = pe(l - cn * a), h = pe(u * (a - f) - s6e * s), p = pe(cn * r * n);
            return new qt(f, h, p);
          }
          add(e) {
            if (!(e instanceof qt))
              throw new TypeError("JacobianPoint expected");
            let { x: r, y: n, z: i2 } = this, { x: o, y: s, z: a } = e;
            if (o === Ot || s === Ot)
              return this;
            if (r === Ot || n === Ot)
              return e;
            let u = pe(i2 ** cn), l = pe(a ** cn), f = pe(r * l), h = pe(o * u), p = pe(pe(n * a) * l), d = pe(pe(s * i2) * u), m = pe(h - f), y = pe(d - p);
            if (m === Ot)
              return y === Ot ? this.double() : qt.ZERO;
            let g = pe(m ** cn), E = pe(m * g), b = pe(f * g), v = pe(y ** cn - E - cn * b), S = pe(y * (b - v) - p * E), x = pe(i2 * a * m);
            return new qt(v, S, x);
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiplyUnsafe(e) {
            let r = aq(e), n = qt.BASE, i2 = qt.ZERO;
            if (r === Ot)
              return i2;
            if (r === wr)
              return this;
            if (!d6) {
              let p = i2, d = this;
              for (; r > Ot; )
                r & wr && (p = p.add(d)), d = d.double(), r >>= wr;
              return p;
            }
            let { k1neg: o, k1: s, k2neg: a, k2: u } = uq(r), l = i2, f = i2, h = this;
            for (; s > Ot || u > Ot; )
              s & wr && (l = l.add(h)), u & wr && (f = f.add(h)), h = h.double(), s >>= wr, u >>= wr;
            return o && (l = l.negate()), a && (f = f.negate()), f = new qt(pe(f.x * xr.beta), f.y, f.z), l.add(f);
          }
          precomputeWindow(e) {
            let r = d6 ? 128 / e + 1 : 256 / e + 1, n = [], i2 = this, o = i2;
            for (let s = 0; s < r; s++) {
              o = i2, n.push(o);
              for (let a = 1; a < 2 ** (e - 1); a++)
                o = o.add(i2), n.push(o);
              i2 = o.double();
            }
            return n;
          }
          wNAF(e, r) {
            !r && this.equals(qt.BASE) && (r = Tt.BASE);
            let n = r && r._WINDOW_SIZE || 1;
            if (256 % n)
              throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
            let i2 = r && eR.get(r);
            i2 || (i2 = this.precomputeWindow(n), r && n !== 1 && (i2 = qt.normalizeZ(i2), eR.set(r, i2)));
            let o = qt.ZERO, s = qt.ZERO, a = 1 + (d6 ? 128 / n : 256 / n), u = 2 ** (n - 1), l = BigInt(2 ** n - 1), f = 2 ** n, h = BigInt(n);
            for (let p = 0; p < a; p++) {
              let d = p * u, m = Number(e & l);
              if (e >>= h, m > u && (m -= f, e += wr), m === 0) {
                let y = i2[d];
                p % 2 && (y = y.negate()), s = s.add(y);
              } else {
                let y = i2[d + Math.abs(m) - 1];
                m < 0 && (y = y.negate()), o = o.add(y);
              }
            }
            return { p: o, f: s };
          }
          multiply(e, r) {
            let n = aq(e), i2, o;
            if (d6) {
              let { k1neg: s, k1: a, k2neg: u, k2: l } = uq(n), { p: f, f: h } = this.wNAF(a, r), { p, f: d } = this.wNAF(l, r);
              s && (f = f.negate()), u && (p = p.negate()), p = new qt(pe(p.x * xr.beta), p.y, p.z), i2 = f.add(p), o = h.add(d);
            } else {
              let { p: s, f: a } = this.wNAF(n, r);
              i2 = s, o = a;
            }
            return qt.normalizeZ([i2, o])[0];
          }
          toAffine(e = s0(this.z)) {
            let { x: r, y: n, z: i2 } = this, o = e, s = pe(o * o), a = pe(s * o), u = pe(r * s), l = pe(n * a);
            if (pe(i2 * o) !== wr)
              throw new Error("invZ was invalid");
            return new Tt(u, l);
          }
        };
        qt.BASE = new qt(xr.Gx, xr.Gy, wr);
        qt.ZERO = new qt(Ot, wr, Ot);
        var eR = /* @__PURE__ */ new WeakMap(), Tt = class {
          constructor(e, r) {
            this.x = e, this.y = r;
          }
          _setWindowSize(e) {
            this._WINDOW_SIZE = e, eR.delete(this);
          }
          static fromCompressedHex(e) {
            let r = e.length === 32, n = Qo(r ? e : e.subarray(1));
            if (!Zx(n))
              throw new Error("Point is not on curve");
            let i2 = iq(n), o = u6e(i2), s = (o & wr) === wr;
            r ? s && (o = pe(-o)) : (e[0] & 1) === 1 !== s && (o = pe(-o));
            let a = new Tt(n, o);
            return a.assertValidity(), a;
          }
          static fromUncompressedHex(e) {
            let r = Qo(e.subarray(1, 33)), n = Qo(e.subarray(33, 65)), i2 = new Tt(r, n);
            return i2.assertValidity(), i2;
          }
          static fromHex(e) {
            let r = Bc(e), n = r.length, i2 = r[0];
            if (n === 32 || n === 33 && (i2 === 2 || i2 === 3))
              return this.fromCompressedHex(r);
            if (n === 65 && i2 === 4)
              return this.fromUncompressedHex(r);
            throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`);
          }
          static fromPrivateKey(e) {
            return Tt.BASE.multiply($2(e));
          }
          static fromSignature(e, r, n) {
            e = Bc(e);
            let i2 = lq(e), { r: o, s } = fq(r);
            if (n !== 0 && n !== 1)
              throw new Error("Cannot recover signature: invalid recovery bit");
            if (i2 === Ot)
              throw new Error("Cannot recover signature: msgHash cannot be 0");
            let a = n & 1 ? "03" : "02", u = Tt.fromHex(a + ph(o)), { n: l } = xr, f = s0(o, l), h = pe(-i2 * f, l), p = pe(s * f, l), d = Tt.BASE.multiplyAndAddUnsafe(u, h, p);
            if (!d)
              throw new Error("Cannot recover signature: point at infinify");
            return d.assertValidity(), d;
          }
          toRawBytes(e = false) {
            return hl(this.toHex(e));
          }
          toHex(e = false) {
            let r = ph(this.x);
            return e ? `${this.y & wr ? "03" : "02"}${r}` : `04${r}${ph(this.y)}`;
          }
          toHexX() {
            return this.toHex(true).slice(2);
          }
          toRawX() {
            return this.toRawBytes(true).slice(1);
          }
          assertValidity() {
            let e = "Point is not on elliptic curve", { x: r, y: n } = this;
            if (!Zx(r) || !Zx(n))
              throw new Error(e);
            let i2 = pe(n * n), o = iq(r);
            if (pe(i2 - o) !== Ot)
              throw new Error(e);
          }
          equals(e) {
            return this.x === e.x && this.y === e.y;
          }
          negate() {
            return new Tt(this.x, pe(-this.y));
          }
          double() {
            return qt.fromAffine(this).double().toAffine();
          }
          add(e) {
            return qt.fromAffine(this).add(qt.fromAffine(e)).toAffine();
          }
          subtract(e) {
            return this.add(e.negate());
          }
          multiply(e) {
            return qt.fromAffine(this).multiply(e, this).toAffine();
          }
          multiplyAndAddUnsafe(e, r, n) {
            let i2 = qt.fromAffine(this), o = r === Ot || r === wr || this !== Tt.BASE ? i2.multiplyUnsafe(r) : i2.multiply(r), s = qt.fromAffine(e).multiplyUnsafe(n), a = o.add(s);
            return a.equals(qt.ZERO) ? void 0 : a.toAffine();
          }
        };
        Tt.BASE = new Tt(xr.Gx, xr.Gy);
        Tt.ZERO = new Tt(Ot, Ot);
        function oq(t) {
          return Number.parseInt(t[0], 16) >= 8 ? "00" + t : t;
        }
        function sq(t) {
          if (t.length < 2 || t[0] !== 2)
            throw new Error(`Invalid signature integer tag: ${o0(t)}`);
          let e = t[1], r = t.subarray(2, e + 2);
          if (!e || r.length !== e)
            throw new Error("Invalid signature integer: wrong length");
          if (r[0] === 0 && r[1] <= 127)
            throw new Error("Invalid signature integer: trailing length");
          return { data: Qo(r), left: t.subarray(e + 2) };
        }
        function a6e(t) {
          if (t.length < 2 || t[0] != 48)
            throw new Error(`Invalid signature tag: ${o0(t)}`);
          if (t[1] !== t.length - 2)
            throw new Error("Invalid signature: incorrect length");
          let { data: e, left: r } = sq(t.subarray(2)), { data: n, left: i2 } = sq(r);
          if (i2.length)
            throw new Error(`Invalid signature: left bytes after parsing: ${o0(i2)}`);
          return { r: e, s: n };
        }
        var Oa = class {
          constructor(e, r) {
            this.r = e, this.s = r, this.assertValidity();
          }
          static fromCompact(e) {
            let r = y6(e), n = "Signature.fromCompact";
            if (typeof e != "string" && !r)
              throw new TypeError(`${n}: Expected string or Uint8Array`);
            let i2 = r ? o0(e) : e;
            if (i2.length !== 128)
              throw new Error(`${n}: Expected 64-byte hex`);
            return new Oa(g6(i2.slice(0, 64)), g6(i2.slice(64, 128)));
          }
          static fromDER(e) {
            let r = y6(e);
            if (typeof e != "string" && !r)
              throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
            let { r: n, s: i2 } = a6e(r ? e : hl(e));
            return new Oa(n, i2);
          }
          static fromHex(e) {
            return this.fromDER(e);
          }
          assertValidity() {
            let { r: e, s: r } = this;
            if (!G2(e))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!G2(r))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            let e = xr.n >> wr;
            return this.s > e;
          }
          normalizeS() {
            return this.hasHighS() ? new Oa(this.r, xr.n - this.s) : this;
          }
          toDERRawBytes(e = false) {
            return hl(this.toDERHex(e));
          }
          toDERHex(e = false) {
            let r = oq(z2(this.s));
            if (e)
              return r;
            let n = oq(z2(this.r)), i2 = z2(n.length / 2), o = z2(r.length / 2);
            return `30${z2(n.length / 2 + r.length / 2 + 4)}02${i2}${n}02${o}${r}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return hl(this.toCompactHex());
          }
          toCompactHex() {
            return ph(this.r) + ph(this.s);
          }
        };
        function i0(...t) {
          if (!t.every(y6))
            throw new Error("Uint8Array list expected");
          if (t.length === 1)
            return t[0];
          let e = t.reduce((n, i2) => n + i2.length, 0), r = new Uint8Array(e);
          for (let n = 0, i2 = 0; n < t.length; n++) {
            let o = t[n];
            r.set(o, i2), i2 += o.length;
          }
          return r;
        }
        function y6(t) {
          return t instanceof Uint8Array;
        }
        var c6e = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
        function o0(t) {
          if (!(t instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let e = "";
          for (let r = 0; r < t.length; r++)
            e += c6e[t[r]];
          return e;
        }
        function ph(t) {
          if (t > Jx)
            throw new Error("Expected number < 2^256");
          return t.toString(16).padStart(64, "0");
        }
        function Xx(t) {
          return hl(ph(t));
        }
        function z2(t) {
          let e = t.toString(16);
          return e.length & 1 ? `0${e}` : e;
        }
        function g6(t) {
          if (typeof t != "string")
            throw new TypeError("hexToNumber: expected string, got " + typeof t);
          return BigInt(`0x${t}`);
        }
        function hl(t) {
          if (typeof t != "string")
            throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2)
            throw new Error("hexToBytes: received invalid unpadded hex" + t.length);
          let e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            let n = r * 2, i2 = t.slice(n, n + 2), o = Number.parseInt(i2, 16);
            if (Number.isNaN(o) || o < 0)
              throw new Error("Invalid byte sequence");
            e[r] = o;
          }
          return e;
        }
        function Qo(t) {
          return g6(o0(t));
        }
        function Bc(t) {
          return t instanceof Uint8Array ? Uint8Array.from(t) : hl(t);
        }
        function aq(t) {
          if (typeof t == "number" && Number.isSafeInteger(t) && t > 0)
            return BigInt(t);
          if (typeof t == "bigint" && G2(t))
            return t;
          throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
        }
        function pe(t, e = xr.P) {
          let r = t % e;
          return r >= Ot ? r : e + r;
        }
        function Yo(t, e) {
          let { P: r } = xr, n = t;
          for (; e-- > Ot; )
            n *= n, n %= r;
          return n;
        }
        function u6e(t) {
          let { P: e } = xr, r = BigInt(6), n = BigInt(11), i2 = BigInt(22), o = BigInt(23), s = BigInt(44), a = BigInt(88), u = t * t * t % e, l = u * u * t % e, f = Yo(l, H2) * l % e, h = Yo(f, H2) * l % e, p = Yo(h, cn) * u % e, d = Yo(p, n) * p % e, m = Yo(d, i2) * d % e, y = Yo(m, s) * m % e, g = Yo(y, a) * y % e, E = Yo(g, s) * m % e, b = Yo(E, H2) * l % e, v = Yo(b, o) * d % e, S = Yo(v, r) * u % e;
          return Yo(S, cn);
        }
        function s0(t, e = xr.P) {
          if (t === Ot || e <= Ot)
            throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);
          let r = pe(t, e), n = e, i2 = Ot, o = wr, s = wr, a = Ot;
          for (; r !== Ot; ) {
            let l = n / r, f = n % r, h = i2 - s * l, p = o - a * l;
            n = r, r = f, i2 = s, o = a, s = h, a = p;
          }
          if (n !== wr)
            throw new Error("invert: does not exist");
          return pe(i2, e);
        }
        function l6e(t, e = xr.P) {
          let r = new Array(t.length), n = t.reduce((o, s, a) => s === Ot ? o : (r[a] = o, pe(o * s, e)), wr), i2 = s0(n, e);
          return t.reduceRight((o, s, a) => s === Ot ? o : (r[a] = pe(o * r[a], e), pe(o * s, e)), i2), r;
        }
        var cq = (t, e) => (t + e / cn) / e, p6 = cn ** BigInt(128);
        function uq(t) {
          let { n: e } = xr, r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), n = -wr * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = r, s = cq(o * t, e), a = cq(-n * t, e), u = pe(t - s * r - a * i2, e), l = pe(-s * n - a * o, e), f = u > p6, h = l > p6;
          if (f && (u = e - u), h && (l = e - l), u > p6 || l > p6)
            throw new Error("splitScalarEndo: Endomorphism failed, k=" + t);
          return { k1neg: f, k1: u, k2neg: h, k2: l };
        }
        function lq(t) {
          let { n: e } = xr, n = t.length * 8 - 256, i2 = Qo(t);
          return n > 0 && (i2 = i2 >> BigInt(n)), i2 >= e && (i2 -= e), i2;
        }
        var tR = class {
          constructor() {
            this.v = new Uint8Array(32).fill(1), this.k = new Uint8Array(32).fill(0), this.counter = 0;
          }
          hmac(...e) {
            return Ii.hmacSha256(this.k, ...e);
          }
          hmacSync(...e) {
            if (typeof Ii.hmacSha256Sync != "function")
              throw new Error("utils.hmacSha256Sync is undefined, you need to set it");
            let r = Ii.hmacSha256Sync(this.k, ...e);
            if (r instanceof Promise)
              throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");
            return r;
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error("Tried 1,000 k values for sign(), all were invalid");
            this.counter += 1;
          }
          async reseed(e = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([0]), e), this.v = await this.hmac(this.v), e.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e), this.v = await this.hmac(this.v));
          }
          reseedSync(e = new Uint8Array()) {
            this.k = this.hmacSync(this.v, Uint8Array.from([0]), e), this.v = this.hmacSync(this.v), e.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e), this.v = this.hmacSync(this.v));
          }
          async generate() {
            return this.incr(), this.v = await this.hmac(this.v), this.v;
          }
          generateSync() {
            return this.incr(), this.v = this.hmacSync(this.v), this.v;
          }
        };
        function G2(t) {
          return Ot < t && t < xr.n;
        }
        function Zx(t) {
          return Ot < t && t < xr.P;
        }
        function f6e(t, e, r) {
          let n = Qo(t);
          if (!G2(n))
            return;
          let { n: i2 } = xr, o = Tt.BASE.multiply(n), s = pe(o.x, i2);
          if (s === Ot)
            return;
          let a = pe(s0(n, i2) * pe(e + r * s, i2), i2);
          if (a === Ot)
            return;
          let u = new Oa(s, a), l = (o.x === u.r ? 0 : 2) | Number(o.y & wr);
          return { sig: u, recovery: l };
        }
        function $2(t) {
          let e;
          if (typeof t == "bigint")
            e = t;
          else if (typeof t == "number" && Number.isSafeInteger(t) && t > 0)
            e = BigInt(t);
          else if (typeof t == "string") {
            if (t.length !== 64)
              throw new Error("Expected 32 bytes of private key");
            e = g6(t);
          } else if (y6(t)) {
            if (t.length !== 32)
              throw new Error("Expected 32 bytes of private key");
            e = Qo(t);
          } else
            throw new TypeError("Expected valid private key");
          if (!G2(e))
            throw new Error("Expected private key: 0 < key < n");
          return e;
        }
        function h6e(t) {
          return t instanceof Tt ? (t.assertValidity(), t) : Tt.fromHex(t);
        }
        function fq(t) {
          if (t instanceof Oa)
            return t.assertValidity(), t;
          try {
            return Oa.fromDER(t);
          } catch {
            return Oa.fromCompact(t);
          }
        }
        function a0(t, e = false) {
          return Tt.fromPrivateKey(t).toRawBytes(e);
        }
        function hq(t) {
          let e = t.length > 32 ? t.slice(0, 32) : t;
          return Qo(e);
        }
        function d6e(t) {
          let e = hq(t), r = pe(e, xr.n);
          return dq(r < Ot ? e : r);
        }
        function dq(t) {
          if (typeof t != "bigint")
            throw new Error("Expected bigint");
          let e = ph(t);
          return hl(e);
        }
        function p6e(t, e, r) {
          if (t == null)
            throw new Error(`sign: expected valid message hash, not "${t}"`);
          let n = Bc(t), i2 = $2(e), o = [dq(i2), d6e(n)];
          if (r != null) {
            r === true && (r = Ii.randomBytes(32));
            let u = Bc(r);
            if (u.length !== 32)
              throw new Error("sign: Expected 32 bytes of extra data");
            o.push(u);
          }
          let s = i0(...o), a = hq(n);
          return { seed: s, m: a, d: i2 };
        }
        function m6e(t, e) {
          let { sig: r, recovery: n } = t, { canonical: i2, der: o, recovered: s } = Object.assign({ canonical: true, der: true }, e);
          i2 && r.hasHighS() && (r = r.normalizeS(), n ^= 1);
          let a = o ? r.toDERRawBytes() : r.toCompactRawBytes();
          return s ? [a, n] : a;
        }
        async function w6(t, e, r = {}) {
          let { seed: n, m: i2, d: o } = p6e(t, e, r.extraEntropy), s, a = new tR();
          for (await a.reseed(n); !(s = f6e(await a.generate(), i2, o)); )
            await a.reseed();
          return m6e(s, r);
        }
        var y6e = { strict: true };
        function E6(t, e, r, n = y6e) {
          let i2;
          try {
            i2 = fq(t), e = Bc(e);
          } catch {
            return false;
          }
          let { r: o, s } = i2;
          if (n.strict && i2.hasHighS())
            return false;
          let a = lq(e);
          if (a === Ot)
            return false;
          let u;
          try {
            u = h6e(r);
          } catch {
            return false;
          }
          let { n: l } = xr, f = s0(s, l), h = pe(a * f, l), p = pe(o * f, l), d = Tt.BASE.multiplyAndAddUnsafe(u, h, p);
          return d ? pe(d.x, l) === o : false;
        }
        Tt.BASE._setWindowSize(8);
        var fo = { node: o6e, web: typeof self == "object" && "crypto" in self ? self.crypto : void 0 };
        var m6 = {}, Ii = { isValidPrivateKey(t) {
          try {
            return $2(t), true;
          } catch {
            return false;
          }
        }, privateAdd: (t, e) => {
          let r = $2(t), n = Qo(Bc(e));
          return Xx(pe(r + n, xr.n));
        }, privateNegate: (t) => {
          let e = $2(t);
          return Xx(xr.n - e);
        }, pointAddScalar: (t, e, r) => {
          let n = Tt.fromHex(t), i2 = Qo(Bc(e)), o = Tt.BASE.multiplyAndAddUnsafe(n, i2, wr);
          if (!o)
            throw new Error("Tweaked point at infinity");
          return o.toRawBytes(r);
        }, pointMultiply: (t, e, r) => {
          let n = Tt.fromHex(t), i2 = Qo(Bc(e));
          return n.multiply(i2).toRawBytes(r);
        }, hashToPrivateKey: (t) => {
          if (t = Bc(t), t.length < 40 || t.length > 1024)
            throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
          let e = pe(Qo(t), xr.n - wr) + wr;
          return Xx(e);
        }, randomBytes: (t = 32) => {
          if (fo.web)
            return fo.web.getRandomValues(new Uint8Array(t));
          if (fo.node) {
            let { randomBytes: e } = fo.node;
            return Uint8Array.from(e(t));
          } else
            throw new Error("The environment doesn't have randomBytes function");
        }, randomPrivateKey: () => Ii.hashToPrivateKey(Ii.randomBytes(40)), bytesToHex: o0, hexToBytes: hl, concatBytes: i0, mod: pe, invert: s0, sha256: async (...t) => {
          if (fo.web) {
            let e = await fo.web.subtle.digest("SHA-256", i0(...t));
            return new Uint8Array(e);
          } else if (fo.node) {
            let { createHash: e } = fo.node, r = e("sha256");
            return t.forEach((n) => r.update(n)), Uint8Array.from(r.digest());
          } else
            throw new Error("The environment doesn't have sha256 function");
        }, hmacSha256: async (t, ...e) => {
          if (fo.web) {
            let r = await fo.web.subtle.importKey("raw", t, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), n = i0(...e), i2 = await fo.web.subtle.sign("HMAC", r, n);
            return new Uint8Array(i2);
          } else if (fo.node) {
            let { createHmac: r } = fo.node, n = r("sha256", t);
            return e.forEach((i2) => n.update(i2)), Uint8Array.from(n.digest());
          } else
            throw new Error("The environment doesn't have hmac-sha256 function");
        }, sha256Sync: void 0, hmacSha256Sync: void 0, taggedHash: async (t, ...e) => {
          let r = m6[t];
          if (r === void 0) {
            let n = await Ii.sha256(Uint8Array.from(t, (i2) => i2.charCodeAt(0)));
            r = i0(n, n), m6[t] = r;
          }
          return Ii.sha256(r, ...e);
        }, taggedHashSync: (t, ...e) => {
          if (typeof Ii.sha256Sync != "function")
            throw new Error("utils.sha256Sync is undefined, you need to set it");
          let r = m6[t];
          if (r === void 0) {
            let n = Ii.sha256Sync(Uint8Array.from(t, (i2) => i2.charCodeAt(0)));
            r = i0(n, n), m6[t] = r;
          }
          return Ii.sha256Sync(r, ...e);
        }, precompute(t = 8, e = Tt.BASE) {
          let r = e === Tt.BASE ? e : new Tt(e.x, e.y);
          return r._setWindowSize(t), r.multiply(H2), r;
        } };
        vr();
        function mq() {
          return Ii.randomPrivateKey();
        }
        async function yq(t, e) {
          let { digest: r } = await xe.digest(e);
          try {
            return await w6(r, t);
          } catch (n) {
            throw (0, c0.default)(n, "ERR_INVALID_INPUT");
          }
        }
        async function gq(t, e, r) {
          try {
            let { digest: n } = await xe.digest(r);
            return E6(e, n, t);
          } catch (n) {
            throw (0, c0.default)(n, "ERR_INVALID_INPUT");
          }
        }
        function wq(t) {
          return Tt.fromHex(t).toRawBytes(true);
        }
        function Eq(t) {
          try {
            a0(t, true);
          } catch (e) {
            throw (0, c0.default)(e, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        function rR(t) {
          try {
            Tt.fromHex(t);
          } catch (e) {
            throw (0, c0.default)(e, "ERR_INVALID_PUBLIC_KEY");
          }
        }
        function bq(t) {
          try {
            return a0(t, true);
          } catch (e) {
            throw (0, c0.default)(e, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        var W2 = class {
          constructor(e) {
            rR(e), this._key = e;
          }
          async verify(e, r) {
            return await gq(this._key, r, e);
          }
          marshal() {
            return wq(this._key);
          }
          get bytes() {
            return Os.encode({ Type: Fr.Secp256k1, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, j2 = class {
          constructor(e, r) {
            this._key = e, this._publicKey = r ?? bq(e), Eq(this._key), rR(this._publicKey);
          }
          async sign(e) {
            return await yq(this._key, e);
          }
          get public() {
            return new W2(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return Ls.encode({ Type: Fr.Secp256k1, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await this.public.hash();
            return M(e, "base58btc");
          }
          async export(e, r = "libp2p-key") {
            if (r === "libp2p-key")
              return await Zp(this.bytes, e);
            throw (0, _q.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        };
        function w6e(t) {
          return new j2(t);
        }
        function E6e(t) {
          return new W2(t);
        }
        async function b6e() {
          let t = await mq();
          return new j2(t);
        }
        var La = { rsa: Vx, ed25519: Qx, secp256k1: nR };
        function iR(t) {
          let e = Object.keys(La).join(" / ");
          return (0, _6.default)(new Error(`invalid or unsupported key type ${t}. Must be ${e}`), "ERR_UNSUPPORTED_KEY_TYPE");
        }
        function oR(t) {
          if (t = t.toLowerCase(), t === "rsa" || t === "ed25519" || t === "secp256k1")
            return La[t];
          throw iR(t);
        }
        async function sR(t, e) {
          return await oR(t).generateKeyPair(e ?? 2048);
        }
        async function _6e(t, e, r) {
          if (t.toLowerCase() !== "ed25519")
            throw (0, _6.default)(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
          return await Yx(e);
        }
        function ho(t) {
          let e = Os.decode(t), r = e.Data;
          switch (e.Type) {
            case Fr.RSA:
              return La.rsa.unmarshalRsaPublicKey(r);
            case Fr.Ed25519:
              return La.ed25519.unmarshalEd25519PublicKey(r);
            case Fr.Secp256k1:
              return La.secp256k1.unmarshalSecp256k1PublicKey(r);
            default:
              throw iR(e.Type);
          }
        }
        function v6e(t, e) {
          return e = (e ?? "rsa").toLowerCase(), oR(e), t.bytes;
        }
        async function Jn(t) {
          let e = Ls.decode(t), r = e.Data;
          switch (e.Type) {
            case Fr.RSA:
              return await La.rsa.unmarshalRsaPrivateKey(r);
            case Fr.Ed25519:
              return La.ed25519.unmarshalEd25519PrivateKey(r);
            case Fr.Secp256k1:
              return La.secp256k1.unmarshalSecp256k1PrivateKey(r);
            default:
              throw iR(e.Type);
          }
        }
        function S6e(t, e) {
          return e = (e ?? "rsa").toLowerCase(), oR(e), t.bytes;
        }
        async function Mc(t, e) {
          try {
            let i2 = await RV(t, e);
            return await Jn(i2);
          } catch {
          }
          let r = b6.default.pki.decryptRsaPrivateKey(t, e);
          if (r === null)
            throw (0, _6.default)(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
          let n = b6.default.asn1.toDer(b6.default.pki.privateKeyToAsn1(r));
          return n = U(n.getBytes(), "ascii"), await La.rsa.unmarshalRsaPrivateKey(n);
        }
        var fR = w(K(), 1);
        si();
        Re();
        c();
        var u0 = w(K(), 1);
        c();
        var vq = "ERR_IPNS_EXPIRED_RECORD", Y2 = "ERR_UNRECOGNIZED_VALIDITY", Sq = "ERR_SIGNATURE_CREATION", mh = "ERR_SIGNATURE_VERIFICATION", xq = "ERR_UNRECOGNIZED_FORMAT";
        var aR = "ERR_UNDEFINED_PARAMETER", Rq = "ERR_INVALID_RECORD_DATA", Aq = "ERR_INVALID_EMBEDDED_KEY", Tq = "ERR_MISSING_PRIVATE_KEY";
        c();
        var $i;
        (function(t) {
          let e;
          (function(n) {
            n.EOL = "EOL";
          })(e = t.ValidityType || (t.ValidityType = {}));
          let r;
          (function(n) {
            n[n.EOL = 0] = "EOL";
          })(r || (r = {})), function(n) {
            n.codec = () => xi(r);
          }(e = t.ValidityType || (t.ValidityType = {})), t.codec = () => Xe({ 1: { name: "value", codec: ye, optional: true }, 2: { name: "signature", codec: ye, optional: true }, 3: { name: "validityType", codec: t.ValidityType.codec(), optional: true }, 4: { name: "validity", codec: ye, optional: true }, 5: { name: "sequence", codec: nl, optional: true }, 6: { name: "ttl", codec: nl, optional: true }, 7: { name: "pubKey", codec: ye, optional: true }, 8: { name: "signatureV2", codec: ye, optional: true }, 9: { name: "data", codec: ye, optional: true } }), t.encode = (n) => Qe(n, t.codec()), t.decode = (n) => Ye(n, t.codec());
        })($i || ($i = {}));
        Re();
        ur();
        Vf();
        var Iq = C("ipns:utils"), Cq = U("/ipns/");
        function Q2(t) {
          let e = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"), r = String(t).trim().match(e);
          if (r == null)
            throw new Error("Invalid format");
          let n = parseInt(r[1], 10), i2 = parseInt(r[2], 10) - 1, o = parseInt(r[3], 10), s = parseInt(r[4], 10), a = parseInt(r[5], 10), u = parseInt(r[6], 10), l = parseInt(r[7].slice(0, -6), 10);
          return new Date(Date.UTC(n, i2, o, s, a, u, l));
        }
        var Pq = async (t, e) => {
          if (e == null || t == null) {
            let n = new Error("one or more of the provided parameters are not defined");
            throw Iq.error(n), (0, u0.default)(n, aR);
          }
          let r;
          if (e.pubKey != null) {
            try {
              r = ho(e.pubKey);
            } catch (i2) {
              throw Iq.error(i2), i2;
            }
            if (!(await sn(e.pubKey)).equals(t))
              throw (0, u0.default)(new Error("Embedded public key did not match PeerID"), Aq);
          } else
            t.publicKey != null && (r = ho(t.publicKey));
          if (r != null)
            return r;
          throw (0, u0.default)(new Error("no public key is available"), aR);
        }, S6 = (t, e, r) => {
          let n = U(e);
          return Ae([t, r, n]);
        }, x6 = (t) => {
          let e = U("ipns-signature:");
          return Ae([e, t]);
        }, uR = (t) => $i.encode(t), Uc = (t) => {
          let e = $i.decode(t);
          return { value: e.value ?? new Uint8Array(0), signature: e.signature ?? new Uint8Array(0), validityType: e.validityType ?? $i.ValidityType.EOL, validity: e.validity ?? new Uint8Array(0), sequence: e.sequence ?? 0n, pubKey: e.pubKey, ttl: e.ttl ?? void 0, signatureV2: e.signatureV2, data: e.data };
        }, dl = (t) => Ae([Cq, t.toBytes()]), lR = (t) => Ir(t.slice(Cq.length)), Dq = (t, e, r, n, i2) => {
          let o;
          if (r === $i.ValidityType.EOL)
            o = 0;
          else
            throw (0, u0.default)(new Error("Unknown validity type"), Y2);
          return ao({ Value: t, Validity: e, ValidityType: o, Sequence: n, TTL: i2 });
        }, kq = (t) => {
          let e = Mn(t);
          if (e.ValidityType === 0)
            e.ValidityType = $i.ValidityType.EOL;
          else
            throw (0, u0.default)(new Error("Unknown validity type"), Y2);
          return Number.isInteger(e.Sequence) && (e.Sequence = BigInt(e.Sequence)), Number.isInteger(e.TTL) && (e.TTL = BigInt(e.TTL)), e;
        };
        yr();
        On();
        va();
        var Oq = C("ipns"), x6e = $r.code, X2 = "/ipns/", R6 = X2.length, Lq = async (t, e, r, n) => {
          let i2 = new Nq.default(Date.now() + Number(n)), o = $i.ValidityType.EOL, [s, a] = n.toString().split("."), u = BigInt(s) * BigInt(1e5) + BigInt(a ?? "0");
          return await R6e(t, e, r, o, i2, u);
        };
        var R6e = async (t, e, r, n, i2, o) => {
          r = BigInt(r);
          let s = U(i2.toString());
          if (t.privateKey == null)
            throw (0, fR.default)(new Error("Missing private key"), Tq);
          let a = await Jn(t.privateKey), u = await T6e(a, e, n, s), l = Dq(e, s, n, r, o), f = x6(l), h = await a.sign(f), p = { value: e, signature: u, validityType: n, validity: s, sequence: r, ttl: o, signatureV2: h, data: l };
          if (t.publicKey != null) {
            let d = _r(t.toBytes());
            (d.code !== x6e || !Ce(t.publicKey, d.digest)) && (p.pubKey = t.publicKey);
          }
          return Oq("ipns entry for %b created", e), p;
        }, A6e = (t) => e9.encode(t).slice(1), Z2 = (t) => new ae(`/ipns/${A6e(t)}`), T6e = async (t, e, r, n) => {
          try {
            let i2 = S6(e, r, n);
            return await t.sign(i2);
          } catch (i2) {
            throw Oq.error("record signature creation failed", i2), (0, fR.default)(new Error("record signature creation failed"), Sq);
          }
        };
        var Xo = C("ipfs:ipns:publisher"), Bq = Rn().code, Mq = 60 * 60 * 1e3, yh = class {
          constructor(e, r) {
            this._routing = e, this._datastore = r;
          }
          async publishWithEOL(e, r, n) {
            let i2 = await this._updateOrCreateRecord(e, r, n);
            return this._putRecordToRouting(i2, e);
          }
          publish(e, r) {
            return this.publishWithEOL(e, r, Mq);
          }
          async _putRecordToRouting(e, r) {
            if (!Go(r)) {
              let i2 = "peerId received is not valid";
              throw Xo.error(i2), (0, Zo.default)(new Error(i2), "ERR_INVALID_PEER_ID");
            }
            if (r.publicKey == null)
              throw (0, Zo.default)(new Error("Public key was missing"), "ERR_MISSING_PUBLIC_KEY");
            let n = dl(r);
            return await this._publishEntry(n, e), e;
          }
          async _publishEntry(e, r) {
            try {
              let n = await this._routing.put(e, r);
              return Xo(`ipns record for ${M(e, "base32")} was stored in the routing`), n;
            } catch (n) {
              let i2 = `ipns record for ${M(e, "base32")} could not be stored in the routing - ${n.stack}`;
              throw Xo.error(i2), Xo.error(n), (0, Zo.default)(new Error(i2), "ERR_PUTTING_TO_ROUTING");
            }
          }
          async _getPublished(e, r = {}) {
            if (!Go(e)) {
              let i2 = "peerId received is not valid";
              throw Xo.error(i2), (0, Zo.default)(new Error(i2), "ERR_INVALID_PEER_ID");
            }
            let n = r.checkRouting !== false;
            try {
              let i2 = await this._datastore.get(Z2(e.toBytes()));
              return this._unmarshalData(i2);
            } catch (i2) {
              if (i2.code !== Bq) {
                let o = `unexpected error getting the ipns record ${e.toString()} from datastore`;
                throw Xo.error(o), (0, Zo.default)(new Error(o), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
              }
              if (!n)
                throw (0, Zo.default)(i2, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
              try {
                let o = dl(e), s = await this._routing.get(o);
                return this._unmarshalData(s);
              } catch (o) {
                throw Xo.error(o), o;
              }
            }
          }
          _unmarshalData(e) {
            try {
              return Uc(e);
            } catch (r) {
              throw (0, Zo.default)(r, "ERR_INVALID_RECORD_DATA");
            }
          }
          async _updateOrCreateRecord(e, r, n) {
            if (!Go(e)) {
              let u = "peerId received is not valid";
              throw Xo.error(u), (0, Zo.default)(new Error(u), "ERR_INVALID_PEER_ID");
            }
            let i2 = { checkRouting: true }, o;
            try {
              o = await this._getPublished(e, i2);
            } catch (u) {
              if (u.code !== Bq) {
                let l = `unexpected error when determining the last published IPNS record for ${e.toString()} ${u.stack}`;
                throw Xo.error(l), (0, Zo.default)(new Error(l), "ERR_DETERMINING_PUBLISHED_RECORD");
              }
            }
            let s = 0n;
            o && o.sequence !== void 0 && (s = Ce(o.value, r) ? o.sequence : o.sequence + BigInt(1));
            let a;
            try {
              a = await Lq(e, r, s, n);
            } catch (u) {
              let l = `ipns record for ${r} could not be created`;
              throw Xo.error(u), (0, Zo.default)(new Error(l), "ERR_CREATING_IPNS_RECORD");
            }
            try {
              let u = uR(a);
              return await this._datastore.put(Z2(e.toBytes()), u), Xo(`ipns record for ${M(r, "base32")} was stored in the datastore`), u;
            } catch {
              let l = `ipns record for ${r} could not be stored in the datastore`;
              throw Xo.error(l), (0, Zo.default)(new Error(l), "ERR_STORING_IN_DATASTORE");
            }
          }
        };
        yh.defaultRecordLifetime = Mq;
        c();
        var gh = w(K(), 1);
        var A6 = C("ipfs:ipns:republisher"), Uq = 60 * 1e3, Fq = 60 * Uq, I6e = 4 * Fq, C6e = 24 * Fq, T6 = class {
          constructor(e, r, n, i2, o = { pass: "" }) {
            this._publisher = e, this._datastore = r, this._peerId = n, this._keychain = i2, this._options = o, this._republishHandle = null;
          }
          async start() {
            if (this._republishHandle)
              throw (0, gh.default)(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
            let e = { _task: null, _inflightTask: null, _timeoutId: null, runPeriodically: (i2) => {
              e._timeoutId = setTimeout(async () => {
                e._timeoutId = null;
                try {
                  e._inflightTask = e._task(), await e._inflightTask, e._task && e.runPeriodically(i2);
                } catch (o) {
                  A6.error(o);
                }
              }, i2());
            }, cancel: async () => {
              e._timeoutId != null && clearTimeout(e._timeoutId), e._task = null, await e._inflightTask;
            } }, { pass: r } = this._options, n = true;
            e._task = () => this._republishEntries(this._peerId, r), e.runPeriodically(() => n ? (n = false, this._options.initialBroadcastInterval || Uq) : this._options.broadcastInterval || I6e), this._republishHandle = e;
          }
          async stop() {
            let e = this._republishHandle;
            if (!e)
              throw (0, gh.default)(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
            this._republishHandle = null, await e.cancel();
          }
          async _republishEntries(e, r) {
            try {
              await this._republishEntry(e);
            } catch {
              let i2 = "cannot republish entry for the node's private key";
              A6.error(i2);
              return;
            }
            if (r)
              try {
                let n = await this._keychain.listKeys();
                for (let i2 of n) {
                  if (i2.name === "self")
                    continue;
                  let o = await this._keychain.exportKey(i2.name, r), s = await Mc(o, r), a = await sn(s.public.bytes, s.bytes);
                  await this._republishEntry(a);
                }
              } catch (n) {
                A6.error(n);
              }
          }
          async _republishEntry(e) {
            try {
              let r = await this._getPreviousValue(e);
              await this._publisher.publishWithEOL(e, r, C6e);
            } catch (r) {
              if (r.code === "ERR_NO_ENTRY_FOUND")
                return;
              throw r;
            }
          }
          async _getPreviousValue(e) {
            if (!Go(e))
              throw (0, gh.default)(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
            try {
              let r = await this._datastore.get(Z2(e.toBytes()));
              if (!(r instanceof Uint8Array))
                throw (0, gh.default)(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
              try {
                return Uc(r).value;
              } catch (n) {
                throw A6.error(n), (0, gh.default)(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
              }
            } catch (r) {
              throw r && r.notFound ? (0, gh.default)(new Error(`no previous entry for record with id: ${e.toString()}`), "ERR_NO_ENTRY_FOUND") : r;
            }
          }
        };
        c();
        var f0 = w(K(), 1);
        me();
        Re();
        ur();
        c();
        var Ks = w(K(), 1);
        me();
        yr();
        var J2 = C("ipns:validator"), P6e = async (t, e) => {
          let { value: r, validityType: n, validity: i2 } = e, o, s;
          e.signatureV2 != null && e.data != null ? (s = e.signatureV2, o = x6(e.data), D6e(e)) : (s = e.signature ?? new Uint8Array(0), o = S6(r, n, i2));
          let a;
          try {
            a = await t.verify(o, s);
          } catch {
            a = false;
          }
          if (!a)
            throw J2.error("record signature verification failed"), (0, Ks.default)(new Error("record signature verification failed"), mh);
          if (i2 != null && n === $i.ValidityType.EOL) {
            let u;
            try {
              u = Q2(M(i2));
            } catch {
              throw J2.error("unrecognized validity format (not an rfc3339 format)"), (0, Ks.default)(new Error("unrecognized validity format (not an rfc3339 format)"), xq);
            }
            if (u.getTime() < Date.now())
              throw J2.error("record has expired"), (0, Ks.default)(new Error("record has expired"), vq);
          } else if (n != null)
            throw J2.error("unrecognized validity type"), (0, Ks.default)(new Error("unrecognized validity type"), Y2);
          J2("ipns entry for %b is valid", r);
        }, D6e = (t) => {
          if (t.data == null)
            throw (0, Ks.default)(new Error("Record data is missing"), Rq);
          let e = kq(t.data);
          if (!Ce(e.Value, t.value))
            throw (0, Ks.default)(new Error('Field "value" did not match between protobuf and CBOR'), mh);
          if (!Ce(e.Validity, t.validity))
            throw (0, Ks.default)(new Error('Field "validity" did not match between protobuf and CBOR'), mh);
          if (e.ValidityType !== t.validityType)
            throw (0, Ks.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), mh);
          if (e.Sequence !== t.sequence)
            throw (0, Ks.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), mh);
          if (e.TTL !== t.ttl)
            throw (0, Ks.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), mh);
        }, l0 = async (t, e) => {
          let r = lR(t), n = Uc(e), i2 = await Pq(r, n);
          await P6e(i2, n);
        };
        var dR = C("ipfs:ipns:resolver"), k6e = Rn().code, Kq = 32, I6 = class {
          constructor(e) {
            this._routing = e;
          }
          async resolve(e, r = {}) {
            if (typeof e != "string")
              throw (0, f0.default)(new Error("invalid name"), "ERR_INVALID_NAME");
            let n = r.recursive && r.recursive.toString() === "true", i2 = e.split("/");
            if (i2.length !== 3 || i2[0] !== "")
              throw (0, f0.default)(new Error("invalid name"), "ERR_INVALID_NAME");
            let o = i2[2], s = 1 / 0;
            n && (s = Kq);
            let a = await this.resolver(o, s);
            return dR(`${e} was locally resolved correctly`), a;
          }
          async resolver(e, r) {
            if (r === 0) {
              let o = `could not resolve name (recursion limit of ${Kq} exceeded)`;
              throw dR.error(o), (0, f0.default)(new Error(o), "ERR_RESOLVE_RECURSION_LIMIT");
            }
            let n = await this._resolveName(e), i2 = n.split("/");
            return i2[1] === "ipfs" || !r ? n : this.resolver(i2[2], r - 1);
          }
          async _resolveName(e) {
            let r = ue(e), n = dl(r), i2;
            try {
              i2 = await this._routing.get(n);
            } catch (o) {
              throw dR.error("could not get record from routing", o), o.code === k6e ? (0, f0.default)(new Error(`record requested for ${e} was not found in the network`), "ERR_NO_RECORD_FOUND") : (0, f0.default)(new Error(`unexpected error getting the ipns record ${r.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
            }
            return this._validateRecord(r, i2);
          }
          async _validateRecord(e, r) {
            await l0(Ae([U("/ipns/"), e.toBytes()]), r);
            let n = Uc(r);
            return M(n.value);
          }
        };
        c();
        var Vq = w(Mp(), 1), C6 = class {
          constructor(e) {
            this.lru = (0, Vq.default)(e);
          }
          get(e) {
            let r = this.lru.get(e);
            if (r) {
              if (r.expire && r.expire < Date.now()) {
                this.lru.remove(e);
                return;
              }
              return r.value;
            }
          }
          set(e, r, n) {
            this.lru.set(e, { value: r, expire: Date.now() + n });
          }
          has(e) {
            return !!this.get(e);
          }
          remove(e) {
            this.lru.remove(e);
          }
          clear() {
            this.lru.clear();
          }
        };
        me();
        var ey = C("ipfs:ipns"), qq = 60 * 1e3, ty = class {
          constructor(e, r, n, i2, o) {
            this.publisher = new yh(e, r), this.republisher = new T6(this.publisher, r, n, i2, o), this.resolver = new I6(e), this.cache = new C6(1e3), this.routing = e;
          }
          async publish(e, r, n = yh.defaultRecordLifetime) {
            try {
              await this.publisher.publishWithEOL(e, r, n), ey(`IPNS value ${M(r, "base32")} was published correctly`);
              let i2 = e.toString(), o = parseFloat(n), s = o < qq ? o : qq;
              return this.cache.set(i2, r, s), ey(`IPNS value ${M(r, "base32")} was cached correctly`), { name: i2, value: r };
            } catch (i2) {
              throw ey.error(i2), i2;
            }
          }
          async resolve(e, r = {}) {
            if (typeof e != "string")
              throw (0, zq.default)(new Error("name received is not valid"), "ERR_INVALID_NAME");
            if (!r.nocache && !r.recursive) {
              let n = e.split("/")[2], i2 = this.cache.get(n);
              if (i2)
                return i2;
            }
            try {
              let n = await this.resolver.resolve(e, r);
              return ey(`IPNS record from ${e} was resolved correctly`), n;
            } catch (n) {
              throw ey.error(n), n;
            }
          }
          async initializeKeyspace(e, r) {
            return this.publish(e, r, yh.defaultRecordLifetime);
          }
        };
        c();
        c();
        c();
        c();
        var $q = w(Vs(), 1), P6 = (t, e) => async function* () {
          yield* (await (0, $q.default)(t)).sort(e);
        }();
        var pR = w(Ci(), 1), wh = w(Gi(), 1), mR = w(h0(), 1), Wi = class {
          open() {
            return Promise.reject(new Error(".open is not implemented"));
          }
          close() {
            return Promise.reject(new Error(".close is not implemented"));
          }
          put(e, r, n) {
            return Promise.reject(new Error(".put is not implemented"));
          }
          get(e, r) {
            return Promise.reject(new Error(".get is not implemented"));
          }
          has(e, r) {
            return Promise.reject(new Error(".has is not implemented"));
          }
          delete(e, r) {
            return Promise.reject(new Error(".delete is not implemented"));
          }
          async *putMany(e, r = {}) {
            for await (let { key: n, value: i2 } of e)
              await this.put(n, i2, r), yield { key: n, value: i2 };
          }
          async *getMany(e, r = {}) {
            for await (let n of e)
              yield this.get(n, r);
          }
          async *deleteMany(e, r = {}) {
            for await (let n of e)
              await this.delete(n, r), yield n;
          }
          batch() {
            let e = [], r = [];
            return { put(n, i2) {
              e.push({ key: n, value: i2 });
            }, delete(n) {
              r.push(n);
            }, commit: async (n) => {
              await (0, pR.default)(this.putMany(e, n)), e = [], await (0, pR.default)(this.deleteMany(r, n)), r = [];
            } };
          }
          async *_all(e, r) {
            throw new Error("._all is not implemented");
          }
          async *_allKeys(e, r) {
            throw new Error("._allKeys is not implemented");
          }
          query(e, r) {
            let n = this._all(e, r);
            if (e.prefix != null && (n = (0, wh.default)(n, (i2) => i2.key.toString().startsWith(e.prefix))), Array.isArray(e.filters) && (n = e.filters.reduce((i2, o) => (0, wh.default)(i2, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i2, o) => P6(i2, o), n)), e.offset != null) {
              let i2 = 0;
              n = (0, wh.default)(n, () => i2++ >= e.offset);
            }
            return e.limit != null && (n = (0, mR.default)(n, e.limit)), n;
          }
          queryKeys(e, r) {
            let n = this._allKeys(e, r);
            if (e.prefix != null && (n = (0, wh.default)(n, (i2) => i2.toString().startsWith(e.prefix))), Array.isArray(e.filters) && (n = e.filters.reduce((i2, o) => (0, wh.default)(i2, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i2, o) => P6(i2, o), n)), e.offset != null) {
              let i2 = 0;
              n = (0, wh.default)(n, () => i2++ >= e.offset);
            }
            return e.limit != null && (n = (0, mR.default)(n, e.limit)), n;
          }
        };
        var tz = w(Mi(), 1), gR = w(ez(), 1), wR = w(Ci(), 1), M6e = (0, tz.default)("datastore:core:tiered"), ry = class extends Wi {
          constructor(e) {
            super(), this.stores = e.slice();
          }
          async open() {
            try {
              await Promise.all(this.stores.map((e) => e.open()));
            } catch {
              throw Lw();
            }
          }
          async put(e, r) {
            try {
              await Promise.all(this.stores.map((n) => n.put(e, r)));
            } catch {
              throw Mw();
            }
          }
          async get(e, r) {
            for (let n of this.stores)
              try {
                let i2 = await n.get(e, r);
                if (i2)
                  return i2;
              } catch (i2) {
                M6e(i2);
              }
            throw Rn();
          }
          async has(e, r) {
            for (let n of this.stores)
              if (await n.has(e, r))
                return true;
            return false;
          }
          async delete(e, r) {
            try {
              await Promise.all(this.stores.map((n) => n.delete(e, r)));
            } catch {
              throw Bw();
            }
          }
          async *putMany(e, r = {}) {
            let n, i2 = this.stores.map((o) => {
              let s = (0, gR.default)();
              return (0, wR.default)(o.putMany(s, r)).catch((a) => {
                n = a;
              }), s;
            });
            try {
              for await (let o of e) {
                if (n)
                  throw n;
                i2.forEach((s) => s.push(o)), yield o;
              }
            } finally {
              i2.forEach((o) => o.end());
            }
          }
          async *deleteMany(e, r = {}) {
            let n, i2 = this.stores.map((o) => {
              let s = (0, gR.default)();
              return (0, wR.default)(o.deleteMany(s, r)).catch((a) => {
                n = a;
              }), s;
            });
            try {
              for await (let o of e) {
                if (n)
                  throw n;
                i2.forEach((s) => s.push(o)), yield o;
              }
            } finally {
              i2.forEach((o) => o.end());
            }
          }
          async close() {
            await Promise.all(this.stores.map((e) => e.close()));
          }
          batch() {
            let e = this.stores.map((r) => r.batch());
            return { put: (r, n) => {
              e.forEach((i2) => i2.put(r, n));
            }, delete: (r) => {
              e.forEach((n) => n.delete(r));
            }, commit: async (r) => {
              for (let n of e)
                await n.commit(r);
            } };
          }
          query(e, r) {
            return this.stores[this.stores.length - 1].query(e, r);
          }
          queryKeys(e, r) {
            return this.stores[this.stores.length - 1].queryKeys(e, r);
          }
        };
        var sy = w(D6(), 1);
        c();
        c();
        me();
        var k6 = (t, e) => {
          let r = e.map((n, i2) => ({ entry: $i.decode(n), index: i2 }));
          return r.sort((n, i2) => {
            if (n.entry.signatureV2 != null && i2.entry.signatureV2 == null)
              return -1;
            if (n.entry.signatureV2 == null && i2.entry.signatureV2 != null)
              return 1;
            let o = n.entry.sequence ?? 0n, s = i2.entry.sequence ?? 0n;
            if (o > s)
              return -1;
            if (o < s)
              return 1;
            let a = n.entry.validity ?? new Uint8Array(0), u = i2.entry.validity ?? new Uint8Array(0), l = Q2(M(a)), f = Q2(M(u));
            return l.getTime() > f.getTime() ? -1 : l.getTime() < f.getTime() ? 1 : 0;
          }), r[0].index;
        };
        Hr();
        c();
        c();
        c();
        c();
        c();
        var rz = "SHARDING", nz = "_README";
        c();
        var ny = class extends Wi {
          constructor() {
            super(), this.data = {};
          }
          open() {
            return Promise.resolve();
          }
          close() {
            return Promise.resolve();
          }
          async put(e, r) {
            this.data[e.toString()] = r;
          }
          async get(e) {
            if (!await this.has(e))
              throw Rn();
            return this.data[e.toString()];
          }
          async has(e) {
            return this.data[e.toString()] !== void 0;
          }
          async delete(e) {
            delete this.data[e.toString()];
          }
          async *_all() {
            yield* Object.entries(this.data).map(([e, r]) => ({ key: new ae(e), value: r }));
          }
          async *_allKeys() {
            yield* Object.entries(this.data).map(([e]) => new ae(e));
          }
        };
        c();
        var q6e = w(ei(), 1), z6e = w(az(), 1);
        c();
        var j$e = new ae(rz), Y$e = new ae(nz);
        c();
        var G6e = w(Gi(), 1), W6e = w(h0(), 1), j6e = w(Fc(), 1);
        c();
        var m0 = el;
        c();
        var hz = w(K(), 1);
        me();
        Re();
        var O6 = "/record/";
        function SR(t) {
          return M(t, "base32");
        }
        function iy(t) {
          (typeof t == "string" || t instanceof String) && (t = U(t.toString()));
          let e = M(t, "base64url");
          return `${O6}${e}`;
        }
        function dz(t) {
          if (t.substring(0, O6.length) !== O6)
            throw (0, hz.default)(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
          let e = t.substring(O6.length);
          return U(e, "base64url");
        }
        yr();
        var po = w(K(), 1);
        var pi = C("datastore-pubsub:publisher"), L6 = class extends Wi {
          constructor(e, r, n, i2, o, s) {
            if (super(), !i2)
              throw (0, po.default)(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
            if (typeof i2 != "function")
              throw (0, po.default)(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
            if (typeof o != "function")
              throw (0, po.default)(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
            if (s && typeof s != "function")
              throw (0, po.default)(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
            this._pubsub = e, this._datastore = r, this._peerId = n, this._validator = i2, this._selector = o, this._handleSubscriptionKeyFn = s, this._onMessage = this._onMessage.bind(this), this._pubsub.addEventListener("message", this._onMessage);
          }
          async put(e, r) {
            if (!(e instanceof Uint8Array)) {
              let i2 = "datastore key does not have a valid format";
              throw pi.error(i2), (0, po.default)(new Error(i2), "ERR_INVALID_DATASTORE_KEY");
            }
            if (!(r instanceof Uint8Array)) {
              let i2 = "received value is not a Uint8Array";
              throw pi.error(i2), (0, po.default)(new Error(i2), "ERR_INVALID_VALUE_RECEIVED");
            }
            let n = iy(e);
            pi(`publish value for topic ${n}`), await this._pubsub.publish(n, r);
          }
          async get(e) {
            if (!(e instanceof Uint8Array)) {
              let i2 = "datastore key does not have a valid format";
              throw pi.error(i2), (0, po.default)(new Error(i2), "ERR_INVALID_DATASTORE_KEY");
            }
            let r = iy(e), n = await this._pubsub.getTopics();
            if (n && Array.isArray(n) && n.indexOf(r) > -1)
              return this._getLocal(e);
            try {
              await this._pubsub.subscribe(r);
            } catch {
              let o = `cannot subscribe topic ${r}`;
              throw pi.error(o), (0, po.default)(new Error(o), "ERR_SUBSCRIBING_TOPIC");
            }
            return pi(`subscribed values for key ${r}`), this._getLocal(e);
          }
          unsubscribe(e) {
            let r = iy(e);
            return this._pubsub.unsubscribe(r);
          }
          async _getLocal(e) {
            let r = new ae("/" + SR(e), false), n;
            try {
              n = await this._datastore.get(r);
            } catch (i2) {
              if (i2.code !== "ERR_NOT_FOUND") {
                let s = `unexpected error getting the ipns record for ${r.toString()}`;
                throw pi.error(s), (0, po.default)(new Error(s), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
              }
              let o = `local record requested was not found for ${r.toString()}`;
              throw pi.error(o), (0, po.default)(new Error(o), "ERR_NOT_FOUND");
            }
            if (!(n instanceof Uint8Array)) {
              let i2 = "found record that we couldn't convert to a value";
              throw pi.error(i2), (0, po.default)(new Error(i2), "ERR_INVALID_RECORD_RECEIVED");
            }
            return n;
          }
          async _onMessage(e) {
            let r = e.detail, { data: n, from: i2, topic: o } = r, s;
            try {
              s = dz(o);
            } catch (a) {
              pi.error(a);
              return;
            }
            if (pi(`message received for topic ${o}`), this._peerId.equals(i2)) {
              pi("message discarded as it is from the same peer");
              return;
            }
            if (this._handleSubscriptionKeyFn) {
              let a;
              try {
                a = await this._handleSubscriptionKeyFn(s);
              } catch {
                pi.error("message discarded by the subscriptionKeyFn");
                return;
              }
              s = a;
            }
            try {
              await this._storeIfSubscriptionIsBetter(s, n);
            } catch (a) {
              pi.error(a);
            }
          }
          async _storeIfSubscriptionIsBetter(e, r) {
            let n = false;
            try {
              n = await this._isBetter(e, r);
            } catch (i2) {
              if (i2.code !== "ERR_NOT_VALID_RECORD")
                throw i2;
            }
            n && await this._storeRecord(e, r);
          }
          async _validateRecord(e, r) {
            return this._validator(e, r);
          }
          async _selectRecord(e, r) {
            return await this._selector(e, r) === 0;
          }
          async _isBetter(e, r) {
            try {
              await this._validateRecord(e, r);
            } catch {
              let s = "record received through pubsub is not valid";
              throw pi.error(s), (0, po.default)(new Error(s), "ERR_NOT_VALID_RECORD");
            }
            let n = new ae(e), i2;
            try {
              i2 = await this._getLocal(n.uint8Array());
            } catch {
              return true;
            }
            return Ce(i2, r) ? false : this._selectRecord(e, [i2, r]);
          }
          async _storeRecord(e, r) {
            let n = new ae("/" + SR(e), false);
            await this._datastore.put(n, r), pi(`record for ${iy(e)} was stored in the datastore`);
          }
        };
        Re();
        me();
        var xR = w(K(), 1);
        var B6 = C("ipfs:ipns:pubsub"), Eh = class {
          constructor(e, r, n) {
            this._subscriptions = {}, this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this), this._pubsubDs = new L6(e, r, n, l0, k6, this._handleSubscriptionKey);
          }
          async put(e, r) {
            try {
              await this._pubsubDs.put(e, r);
            } catch (n) {
              throw B6.error(n), n;
            }
          }
          async get(e) {
            let r, n;
            try {
              r = await this._pubsubDs.get(e);
            } catch (o) {
              n = o;
            }
            let i2 = e.slice(0, R6);
            if (M(i2) === X2) {
              let o = Ne.encode(e).substring(1), s = Ne.encode(e.slice(R6)).substring(1);
              this._subscriptions[o] = s, B6(`subscribed to pubsub topic ${o}, id ${s}`);
            }
            if (n)
              throw n;
            return r;
          }
          _handleSubscriptionKey(e) {
            e instanceof Uint8Array && (e = M(e, "base58btc"));
            let r = this._subscriptions[e];
            if (!r)
              throw (0, xR.default)(new Error(`key ${e} does not correspond to a subscription`), "ERR_INVALID_KEY");
            try {
              return dl(ue(r));
            } catch (n) {
              throw B6.error(n), n;
            }
          }
          getSubscriptions() {
            return Object.values(this._subscriptions).filter(Boolean).map((r) => `${X2}${r}`);
          }
          async cancel(e) {
            if (typeof e != "string")
              throw (0, xR.default)(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
            e.startsWith(X2) && (e = e.substring(R6));
            let r = Object.keys(this._subscriptions).find((i2) => this._subscriptions[i2] === e);
            if (!r)
              return { canceled: false };
            let n = U(r);
            return this._pubsubDs.unsubscribe(n), delete this._subscriptions[r], B6(`unsubscribed pubsub ${r}: ${e}`), { canceled: true };
          }
        };
        c();
        c();
        c();
        var oy;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "key", codec: ye }, 2: { name: "value", codec: ye }, 5: { name: "timeReceived", codec: pn } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(oy || (oy = {}));
        c();
        function pz(t) {
          let e = t.getUTCFullYear(), r = String(t.getUTCMonth() + 1).padStart(2, "0"), n = String(t.getUTCDate()).padStart(2, "0"), i2 = String(t.getUTCHours()).padStart(2, "0"), o = String(t.getUTCMinutes()).padStart(2, "0"), s = String(t.getUTCSeconds()).padStart(2, "0"), a = t.getUTCMilliseconds(), u = String(a * 1e3 * 1e3).padStart(9, "0");
          return `${e}-${r}-${n}T${i2}:${o}:${s}.${u}Z`;
        }
        function mz(t) {
          let e = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"), r = String(t).trim().match(e);
          if (r == null)
            throw new Error("Invalid format");
          let n = parseInt(r[1], 10), i2 = parseInt(r[2], 10) - 1, o = parseInt(r[3], 10), s = parseInt(r[4], 10), a = parseInt(r[5], 10), u = parseInt(r[6], 10), l = parseInt(r[7].slice(0, -6), 10);
          return new Date(Date.UTC(n, i2, o, s, a, u, l));
        }
        var Vr = class {
          constructor(e, r, n) {
            if (!(e instanceof Uint8Array))
              throw new Error("key must be a Uint8Array");
            if (!(r instanceof Uint8Array))
              throw new Error("value must be a Uint8Array");
            this.key = e, this.value = r, this.timeReceived = n;
          }
          serialize() {
            return oy.encode(this.prepareSerialize());
          }
          prepareSerialize() {
            return { key: this.key, value: this.value, timeReceived: pz(this.timeReceived) };
          }
          static deserialize(e) {
            let r = oy.decode(e);
            return new Vr(r.key, r.value, new Date(r.timeReceived));
          }
          static fromDeserialized(e) {
            let r = mz(e.timeReceived);
            if (e.key == null)
              throw new Error("key missing from deserialized object");
            if (e.value == null)
              throw new Error("value missing from deserialized object");
            return new Vr(e.key, e.value, r);
          }
        };
        var y0 = w(K(), 1);
        me();
        var RR = C("ipfs:ipns:offline-datastore"), g0 = class {
          constructor(e) {
            this._datastore = e, this.stores = [];
          }
          async put(e, r) {
            if (!(e instanceof Uint8Array))
              throw (0, y0.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
            if (!(r instanceof Uint8Array))
              throw (0, y0.default)(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
            let n;
            try {
              n = this._routingKey(e);
            } catch (o) {
              throw RR.error(o), (0, y0.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
            }
            let i2 = new Vr(e, r, new Date());
            await this._datastore.put(n, i2.serialize());
          }
          async get(e) {
            if (!(e instanceof Uint8Array))
              throw (0, y0.default)(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
            let r;
            try {
              r = this._routingKey(e);
            } catch (o) {
              throw RR.error(o), (0, y0.default)(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
            }
            let n = await this._datastore.get(r), i2;
            try {
              i2 = Vr.deserialize(n);
            } catch (o) {
              throw RR.error(o), o;
            }
            return i2.value;
          }
          _routingKey(e) {
            return new ae("/dht/record/" + M(e, "base32"), false);
          }
        };
        c();
        var yz = w(Ci(), 1);
        var Q6e = C("ipfs:ipns:dht-datastore"), M6 = class {
          constructor(e) {
            this._dht = e;
          }
          async put(e, r) {
            try {
              await (0, yz.default)(this._dht.put(e, r));
            } catch (n) {
              throw Q6e.error(n), n;
            }
          }
          async get(e) {
            for await (let r of this._dht.get(e))
              if (r.name === "VALUE")
                return r.value;
            throw Rn();
          }
        };
        function gz({ libp2p: t, repo: e, peerId: r, options: n }) {
          let i2 = [], o;
          if ((0, sy.default)(n, "EXPERIMENTAL.ipnsPubsub", false) && (o = new Eh(t.pubsub, e.datastore, r), i2.push(o)), (0, sy.default)(n, "offline", false) !== true && ["dht", "dhtclient", "dhtserver"].includes((0, sy.default)(n, "config.Routing.Type", "none")) && i2.push(new M6(t.dht)), (0, sy.default)(n, "offline", false) || i2.length === 0) {
            let s = new g0(e.datastore);
            i2.push(s);
          }
          return new ry(i2);
        }
        var X6e = C("ipfs:components:ipns"), U6 = class {
          constructor(e = { pass: "" }) {
            this.options = e, this.offline = null, this.online = null;
          }
          getIPNS() {
            let e = this.online || this.offline;
            if (e)
              return e;
            throw new Sc();
          }
          get routing() {
            return this.getIPNS().routing;
          }
          startOffline({ repo: e, peerId: r, keychain: n }) {
            if (this.offline != null)
              throw new Ts();
            X6e("initializing IPNS keyspace (offline)");
            let i2 = new g0(e.datastore), o = new ty(i2, e.datastore, r, n, this.options);
            this.offline = o;
          }
          async startOnline({ libp2p: e, repo: r, peerId: n, keychain: i2 }) {
            if (this.online != null)
              throw new Ts();
            let o = gz({ libp2p: e, repo: r, peerId: n, options: this.options }), s = new ty(o, r.datastore, n, i2, this.options);
            await s.republisher.start(), this.online = s;
          }
          async stop() {
            let e = this.online;
            e && (await e.republisher.stop(), this.online = null);
          }
          publish(e, r, n) {
            return this.getIPNS().publish(e, r, n);
          }
          resolve(e, r) {
            return this.getIPNS().resolve(e, r);
          }
          initializeKeyspace(e, r) {
            return this.getIPNS().initializeKeyspace(e, r);
          }
        };
        c();
        c();
        var TR = w(K(), 1);
        Re();
        me();
        c();
        var wz = w(m2(), 1);
        var Ez = w(Ci(), 1);
        async function bz({ ipns: t, repo: e, codecs: r }, n, i2) {
          if (wz.default.ipnsPath(n))
            return t.resolve(n);
          let { cid: o, path: s } = Tc(n);
          await (0, Ez.default)(Qu(o, s || "", r, e, i2));
        }
        var AR = C("ipfs:name:publish");
        function _z({ ipns: t, repo: e, codecs: r, peerId: n, isOnline: i2, keychain: o }) {
          let s = async (u) => {
            let l;
            if (u === "self" && n.privateKey != null)
              l = await Jn(n.privateKey);
            else
              try {
                let f = await o.exportKey(u, "temp");
                l = await Mc(f, "temp");
              } catch (f) {
                throw AR.error(f), (0, TR.default)(f, "ERR_CANNOT_GET_KEY");
              }
            return sn(l.public.bytes, l.bytes);
          };
          async function a(u, l = {}) {
            let f = l.resolve !== false, h = l.lifetime || "24h", p = l.key || "self";
            if (!i2())
              throw (0, TR.default)(new Error(Sw), "OFFLINE_ERROR");
            try {
              u = $U(u);
            } catch (E) {
              throw AR.error(E), E;
            }
            let d = 0;
            try {
              d = ju(h) || 0, d = parseFloat(d.toFixed(6));
            } catch (E) {
              throw AR.error(E), E;
            }
            let m = await Promise.all([s(p), f ? bz({ ipns: t, repo: e, codecs: r }, u) : Promise.resolve()]), y = U(u), g = await t.publish(m[0], y, d);
            return { name: g.name, value: M(g.value) };
          }
          return B(a);
        }
        c();
        var F6 = w(K(), 1);
        te();
        On();
        nw();
        var Rz = w(Sz(), 1);
        me();
        var J6e = Ze.bind({ ignoreUndefined: true }), e5e = C("ipfs:name:resolve"), xz = (t, e) => e.length > 0 ? t + "/" + e.join("/") : t;
        function Az({ dns: t, ipns: e, isOnline: r, options: { offline: n } }) {
          async function* i2(o, s = {}) {
            if (s = J6e({ nocache: false, recursive: true }, s), n && s && s.nocache)
              throw (0, F6.default)(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
            if (!r() && !n)
              throw (0, F6.default)(new Error(Sw), "OFFLINE_ERROR");
            let a = o.toString();
            a.startsWith("/ipns/") || (a = `/ipns/${a}`);
            let [u, l, ...f] = a.slice(1).split("/");
            try {
              if (l.substring(0, 1) === "1") {
                let p = ue(l), d = _r(p.toBytes());
                l = I.createV1(114, d).toString(xp);
              } else {
                let p = I.parse(l);
                p.version === 1 && (l = p.toString(xp));
              }
            } catch (p) {
              if ((0, Rz.default)(l)) {
                yield xz(await t(l, s), f);
                return;
              }
              throw e5e.error(p), (0, F6.default)(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
            }
            let h = await e.resolve(`/${u}/${l}`, s);
            yield xz(h instanceof Uint8Array ? M(h) : h, f);
          }
          return B(i2);
        }
        c();
        c();
        c();
        var IR = w(K(), 1);
        function w0(t, e) {
          if (!t || !(e && e.ipnsPubsub))
            throw (0, IR.default)(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
          if (t.routing instanceof Eh)
            return t.routing;
          let r = (t.routing.stores || []).find((n) => n instanceof Eh);
          if (!r)
            throw (0, IR.default)(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
          return r;
        }
        function Tz({ ipns: t, options: e }) {
          let r = e.EXPERIMENTAL;
          async function n(i2, o = {}) {
            return w0(t, r).cancel(i2, o);
          }
          return B(n);
        }
        c();
        function Iz({ ipns: t, options: e }) {
          let r = e.EXPERIMENTAL;
          async function n(i2 = {}) {
            try {
              return { enabled: Boolean(w0(t, r)) };
            } catch {
              return { enabled: false };
            }
          }
          return B(n);
        }
        c();
        function Cz({ ipns: t, options: e }) {
          let r = e.EXPERIMENTAL;
          async function n(i2 = {}) {
            return w0(t, r).getSubscriptions(i2);
          }
          return B(n);
        }
        var K6 = class {
          constructor({ ipns: e, options: r }) {
            this.cancel = Tz({ ipns: e, options: r }), this.state = Iz({ ipns: e, options: r }), this.subs = Cz({ ipns: e, options: r });
          }
        };
        var V6 = class {
          constructor({ dns: e, ipns: r, repo: n, codecs: i2, peerId: o, isOnline: s, keychain: a, options: u }) {
            this.publish = _z({ ipns: r, repo: n, codecs: i2, peerId: o, isOnline: s, keychain: a }), this.resolve = Az({ dns: e, ipns: r, isOnline: s, options: u }), this.pubsub = new K6({ ipns: r, options: u });
          }
        };
        c();
        te();
        var Pz = w($o(), 1), Dz = w(Vi(), 1), t5e = Rn().code, CR = { default: "<dst>", edges: "<src> -> <dst>" };
        function kz({ repo: t, codecs: e, resolve: r, preload: n }) {
          async function* i2(o, s = {}) {
            if (s.maxDepth === 0)
              return;
            if (s.edges && s.format && s.format !== CR.default)
              throw new Error("Cannot set edges to true and also specify format");
            if (s.format = s.edges ? CR.edges : s.format, typeof s.maxDepth != "number" && (s.maxDepth = s.recursive ? 1 / 0 : 1), s.timeout) {
              let f = [new Pz.TimeoutController(s.timeout).signal];
              s.signal && f.push(s.signal), s.signal = (0, Dz.anySignal)(f);
            }
            let u = (Array.isArray(o) ? o : [o]).map((l) => r5e(n, l, s));
            for (let l of u)
              try {
                yield* n5e(r, t, e, l, s);
              } catch (f) {
                yield { ref: "", err: f.message };
              }
          }
          return i2;
        }
        function r5e(t, e, r) {
          let { cid: n, path: i2 } = Tc(e);
          return r.preload !== false && t(n), `/ipfs/${n}${i2 || ""}`;
        }
        async function* n5e(t, e, r, n, i2) {
          let o = await t(n, i2), { cid: s } = Tc(o), a = i2.maxDepth != null ? i2.maxDepth : 1 / 0, u = i2.unique || false;
          for await (let l of o5e(e, r, s, a, u, i2))
            !l.parent || l.isDuplicate || (yield { ref: i5e(l.parent.cid, l.node.cid, l.node.name, i2.format) });
        }
        function i5e(t, e, r = "", n = CR.default) {
          let i2 = n.replace(/<src>/g, t.toString());
          return i2 = i2.replace(/<dst>/g, e.toString()), i2 = i2.replace(/<linkname>/g, r), i2;
        }
        async function* o5e(t, e, r, n, i2, o) {
          let s = /* @__PURE__ */ new Set();
          async function* a(u, l) {
            let f = l + 1;
            if (!(f > n))
              try {
                for await (let h of s5e(t, e, u.cid, o))
                  yield { parent: u, node: h, isDuplicate: i2 && s.has(h.cid.toString()) }, i2 && s.add(h.cid.toString()), yield* a(h, f);
              } catch (h) {
                throw h.code === t5e && (h.message = `Could not find object with CID: ${u.cid}`), h;
              }
          }
          yield* a({ cid: r }, 0);
        }
        async function* s5e(t, e, r, n) {
          let i2 = await t.blocks.get(r, n), s = (await e.getCodec(r.code)).decode(i2), a = r.code === pt, u = [];
          for (let [l, f] of PR(s, u)) {
            if (a) {
              let h = l.match(/^Links\/(\d+)\/Hash$/);
              if (h) {
                let p = Number(h[1]);
                if (p < s.Links.length) {
                  yield { name: s.Links[p].Name, cid: f };
                  continue;
                }
              }
            }
            yield { name: l, cid: f };
          }
        }
        var PR = function* (t, e) {
          if (t != null && !(t instanceof Uint8Array)) {
            for (let [r, n] of Object.entries(t)) {
              let i2 = [...e, r];
              if (n != null && typeof n == "object")
                if (Array.isArray(n))
                  for (let [o, s] of n.entries()) {
                    let a = [...i2, o], u = I.asCID(s);
                    u ? yield [a.join("/"), u] : typeof s == "object" && (yield* PR(s, a));
                  }
                else {
                  let o = I.asCID(n);
                  o ? yield [i2.join("/"), o] : yield* PR(n, i2);
                }
            }
            return [];
          }
        };
        c();
        function Nz({ repo: t }) {
          async function* e(r = {}) {
            for await (let n of t.blocks.queryKeys({}, { signal: r.signal }))
              yield { ref: n.toString() };
          }
          return B(e);
        }
        c();
        c();
        function Oz({ network: t }) {
          async function e(r = {}) {
            let { bitswap: n } = await t.use(r), i2 = n.getWantlist();
            return Array.from(i2).map((o) => o[1].cid);
          }
          return B(e);
        }
        c();
        function Lz({ network: t }) {
          async function e(r, n = {}) {
            let { bitswap: i2 } = await t.use(n), o = i2.wantlistForPeer(r);
            return Array.from(o).map((s) => s[1].cid);
          }
          return B(e);
        }
        c();
        function Bz({ network: t }) {
          async function e(r, n = {}) {
            let { bitswap: i2 } = await t.use(n);
            return Array.isArray(r) || (r = [r]), i2.unwant(r);
          }
          return B(e);
        }
        c();
        function q6({ network: t }) {
          async function e(r = {}) {
            let n = (await t.use(r)).bitswap, i2 = n.stat().snapshot;
            return { provideBufLen: parseInt(i2.providesBufferLength.toString()), blocksReceived: BigInt(i2.blocksReceived.toString()), wantlist: Array.from(n.getWantlist()).map((o) => o[1].cid), peers: n.peers(), dupBlksReceived: BigInt(i2.dupBlksReceived.toString()), dupDataReceived: BigInt(i2.dupDataReceived.toString()), dataReceived: BigInt(i2.dataReceived.toString()), blocksSent: BigInt(i2.blocksSent.toString()), dataSent: BigInt(i2.dataSent.toString()) };
          }
          return B(e);
        }
        var z6 = class {
          constructor({ network: e }) {
            this.wantlist = Oz({ network: e }), this.wantlistForPeer = Lz({ network: e }), this.unwant = Bz({ network: e }), this.stat = q6({ network: e });
          }
        };
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        var Mz = "[a-fA-F\\d:]", pl = (t) => t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${Mz})|(?<=${Mz})(?=\\s|$))` : "", qs = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", mn = "[a-fA-F\\d]{1,4}", H6 = `
(?:
(?:${mn}:){7}(?:${mn}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${mn}:){6}(?:${qs}|:${mn}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${mn}:){5}(?::${qs}|(?::${mn}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${mn}:){4}(?:(?::${mn}){0,1}:${qs}|(?::${mn}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${mn}:){3}(?:(?::${mn}){0,2}:${qs}|(?::${mn}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${mn}:){2}(?:(?::${mn}){0,3}:${qs}|(?::${mn}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${mn}:){1}(?:(?::${mn}){0,4}:${qs}|(?::${mn}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${mn}){0,5}:${qs}|(?::${mn}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a5e = new RegExp(`(?:^${qs}$)|(?:^${H6}$)`), c5e = new RegExp(`^${qs}$`), u5e = new RegExp(`^${H6}$`), DR = (t) => t && t.exact ? a5e : new RegExp(`(?:${pl(t)}${qs}${pl(t)})|(?:${pl(t)}${H6}${pl(t)})`, "g");
        DR.v4 = (t) => t && t.exact ? c5e : new RegExp(`${pl(t)}${qs}${pl(t)}`, "g");
        DR.v6 = (t) => t && t.exact ? u5e : new RegExp(`${pl(t)}${H6}${pl(t)}`, "g");
        var $6 = DR;
        function G6(t) {
          return $6({ exact: true }).test(t);
        }
        function Uz(t) {
          return $6.v6({ exact: true }).test(t);
        }
        function Fz(t) {
          return $6.v4({ exact: true }).test(t);
        }
        me();
        var Kz = Fz, l5e = Uz, kR = function(t) {
          let e = 0, r;
          if (Kz(t))
            r = new Uint8Array(e + 4), t.split(/\./g).forEach((n) => {
              r[e++] = parseInt(n, 10) & 255;
            });
          else if (l5e(t)) {
            let n = t.split(":", 8), i2;
            for (i2 = 0; i2 < n.length; i2++) {
              let o = Kz(n[i2]), s;
              o && (s = kR(n[i2]), n[i2] = M(s.slice(0, 2), "base16")), s != null && ++i2 < 8 && n.splice(i2, 0, M(s.slice(2, 4), "base16"));
            }
            if (n[0] === "")
              for (; n.length < 8; )
                n.unshift("0");
            else if (n[n.length - 1] === "")
              for (; n.length < 8; )
                n.push("0");
            else if (n.length < 8) {
              for (i2 = 0; i2 < n.length && n[i2] !== ""; i2++)
                ;
              let o = [i2, 1];
              for (i2 = 9 - n.length; i2 > 0; i2--)
                o.push("0");
              n.splice.apply(n, o);
            }
            for (r = new Uint8Array(e + 16), i2 = 0; i2 < n.length; i2++) {
              let o = parseInt(n[i2], 16);
              r[e++] = o >> 8 & 255, r[e++] = o & 255;
            }
          }
          if (r == null)
            throw Error("Invalid ip address: " + t);
          return r;
        }, Vz = function(t, e, r) {
          e = ~~e, r = r ?? t.length - e;
          let n = [], i2 = "", o = new DataView(t.buffer);
          if (r === 4) {
            for (let s = 0; s < r; s++)
              n.push(t[e + s]);
            i2 = n.join(".");
          } else if (r === 16) {
            for (let s = 0; s < r; s += 2)
              n.push(o.getUint16(e + s).toString(16));
            i2 = n.join(":"), i2 = i2.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), i2 = i2.replace(/:{3,4}/, "::");
          }
          return i2;
        };
        c();
        var ay = {}, NR = {}, h5e = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, -1, "ip6zone"], [53, -1, "dns", true], [54, -1, "dns4", true], [55, -1, "dns6", true], [56, -1, "dnsaddr", true], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, -1, "unix", false, true], [421, -1, "ipfs"], [421, -1, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, -1, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, -1, "memory"]];
        h5e.forEach((t) => {
          let e = d5e(...t);
          NR[e.code] = e, ay[e.name] = e;
        });
        function d5e(t, e, r, n, i2) {
          return { code: t, size: e, name: r, resolvable: Boolean(n), path: Boolean(i2) };
        }
        function Tn(t) {
          if (typeof t == "number") {
            if (NR[t] != null)
              return NR[t];
            throw new Error(`no protocol with code: ${t}`);
          } else if (typeof t == "string") {
            if (ay[t] != null)
              return ay[t];
            throw new Error(`no protocol with name: ${t}`);
          }
          throw new Error(`invalid protocol id type: ${typeof t}`);
        }
        te();
        si();
        Hr();
        On();
        var bh = w(ai(), 1);
        me();
        Re();
        ur();
        function Hz(t, e) {
          switch (Tn(t).code) {
            case 4:
            case 41:
              return p5e(e);
            case 6:
            case 273:
            case 33:
            case 132:
              return Gz(e).toString();
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return y5e(e);
            case 421:
              return w5e(e);
            case 444:
              return zz(e);
            case 445:
              return zz(e);
            default:
              return M(e, "base16");
          }
        }
        function $z(t, e) {
          switch (Tn(t).code) {
            case 4:
              return qz(e);
            case 41:
              return qz(e);
            case 6:
            case 273:
            case 33:
            case 132:
              return OR(parseInt(e, 10));
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return m5e(e);
            case 421:
              return g5e(e);
            case 444:
              return E5e(e);
            case 445:
              return b5e(e);
            default:
              return U(e, "base16");
          }
        }
        function qz(t) {
          if (!G6(t))
            throw new Error("invalid ip address");
          return kR(t);
        }
        function p5e(t) {
          let e = Vz(t, 0, t.length);
          if (e == null || !G6(e))
            throw new Error("invalid ip address");
          return e;
        }
        function OR(t) {
          let e = new ArrayBuffer(2);
          return new DataView(e).setUint16(0, t), new Uint8Array(e);
        }
        function Gz(t) {
          return new DataView(t.buffer).getUint16(t.byteOffset);
        }
        function m5e(t) {
          let e = U(t), r = Uint8Array.from(bh.default.encode(e.length));
          return Ae([r, e], r.length + e.length);
        }
        function y5e(t) {
          let e = bh.default.decode(t);
          if (t = t.slice(bh.default.decode.bytes), t.length !== e)
            throw new Error("inconsistent lengths");
          return M(t);
        }
        function g5e(t) {
          let e;
          t[0] === "Q" || t[0] === "1" ? e = _r(Ne.decode(`z${t}`)).bytes : e = I.parse(t).multihash.bytes;
          let r = Uint8Array.from(bh.default.encode(e.length));
          return Ae([r, e], r.length + e.length);
        }
        function w5e(t) {
          let e = bh.default.decode(t), r = t.slice(bh.default.decode.bytes);
          if (r.length !== e)
            throw new Error("inconsistent lengths");
          return M(r, "base58btc");
        }
        function E5e(t) {
          let e = t.split(":");
          if (e.length !== 2)
            throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
          if (e[0].length !== 16)
            throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);
          let r = xt.decode("b" + e[0]), n = parseInt(e[1], 10);
          if (n < 1 || n > 65536)
            throw new Error("Port number is not in range(1, 65536)");
          let i2 = OR(n);
          return Ae([r, i2], r.length + i2.length);
        }
        function b5e(t) {
          let e = t.split(":");
          if (e.length !== 2)
            throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);
          if (e[0].length !== 56)
            throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);
          let r = xt.decode(`b${e[0]}`), n = parseInt(e[1], 10);
          if (n < 1 || n > 65536)
            throw new Error("Port number is not in range(1, 65536)");
          let i2 = OR(n);
          return Ae([r, i2], r.length + i2.length);
        }
        function zz(t) {
          let e = t.slice(0, t.length - 2), r = t.slice(t.length - 2), n = M(e, "base32"), i2 = Gz(r);
          return `${n}:${i2}`;
        }
        var E0 = w(ai(), 1);
        ur();
        me();
        function _5e(t) {
          let e = [], r = t.split("/").slice(1);
          if (r.length === 1 && r[0] === "")
            return [];
          for (let n = 0; n < r.length; n++) {
            let i2 = r[n], o = Tn(i2);
            if (o.size === 0) {
              e.push([i2]);
              continue;
            }
            if (n++, n >= r.length)
              throw jz("invalid address: " + t);
            if (o.path === true) {
              e.push([i2, UR(r.slice(n).join("/"))]);
              break;
            }
            e.push([i2, r[n]]);
          }
          return e;
        }
        function v5e(t) {
          let e = [];
          return t.map((r) => {
            let n = Y6(r);
            return e.push(n.name), r.length > 1 && r[1] != null && e.push(r[1]), null;
          }), UR(e.join("/"));
        }
        function S5e(t) {
          return t.map((e) => {
            Array.isArray(e) || (e = [e]);
            let r = Y6(e);
            return e.length > 1 ? [r.code, $z(r.code, e[1])] : [r.code];
          });
        }
        function LR(t) {
          return t.map((e) => {
            let r = Y6(e);
            return e[1] != null ? [r.code, Hz(r.code, e[1])] : [r.code];
          });
        }
        function BR(t) {
          return j6(Ae(t.map((e) => {
            let r = Y6(e), n = Uint8Array.from(E0.default.encode(r.code));
            return e.length > 1 && e[1] != null && (n = Ae([n, e[1]])), n;
          })));
        }
        function MR(t, e) {
          return t.size > 0 ? t.size / 8 : t.size === 0 ? 0 : E0.default.decode(e) + E0.default.decode.bytes;
        }
        function cy(t) {
          let e = [], r = 0;
          for (; r < t.length; ) {
            let n = E0.default.decode(t, r), i2 = E0.default.decode.bytes, o = Tn(n), s = MR(o, t.slice(r + i2));
            if (s === 0) {
              e.push([n]), r += i2;
              continue;
            }
            let a = t.slice(r + i2, r + i2 + s);
            if (r += s + i2, r > t.length)
              throw jz("Invalid address Uint8Array: " + M(t, "base16"));
            e.push([n, a]);
          }
          return e;
        }
        function W6(t) {
          let e = cy(t), r = LR(e);
          return v5e(r);
        }
        function x5e(t) {
          t = UR(t);
          let e = _5e(t), r = S5e(e);
          return BR(r);
        }
        function Wz(t) {
          return x5e(t);
        }
        function j6(t) {
          let e = R5e(t);
          if (e != null)
            throw e;
          return Uint8Array.from(t);
        }
        function R5e(t) {
          try {
            cy(t);
          } catch (e) {
            return e;
          }
        }
        function UR(t) {
          return "/" + t.trim().split("/").filter((e) => e).join("/");
        }
        function jz(t) {
          return new Error("Error parsing address: " + t);
        }
        function Y6(t) {
          return Tn(t[0]);
        }
        var FR = w(ai(), 1);
        te();
        Hr();
        var Qz = w(K(), 1);
        me();
        yr();
        var T5e = Symbol.for("nodejs.util.inspect.custom"), Xz = /* @__PURE__ */ new Map(), Yz = Symbol.for("@multiformats/js-multiaddr/multiaddr"), j = class {
          constructor(e) {
            if (e == null && (e = ""), Object.defineProperty(this, Yz, { value: true }), e instanceof Uint8Array)
              this.bytes = j6(e);
            else if (typeof e == "string") {
              if (e.length > 0 && e.charAt(0) !== "/")
                throw new Error(`multiaddr "${e}" must start with a "/"`);
              this.bytes = Wz(e);
            } else if (j.isMultiaddr(e))
              this.bytes = j6(e.bytes);
            else
              throw new Error("addr must be a string, Buffer, or another Multiaddr");
          }
          toString() {
            return W6(this.bytes);
          }
          toJSON() {
            return this.toString();
          }
          toOptions() {
            let e = this.toString().split("/");
            return { family: e[1] === "ip4" ? 4 : 6, host: e[2], transport: e[3], port: parseInt(e[4]) };
          }
          protos() {
            return this.protoCodes().map((e) => Object.assign({}, Tn(e)));
          }
          protoCodes() {
            let e = [], r = this.bytes, n = 0;
            for (; n < r.length; ) {
              let i2 = FR.default.decode(r, n), o = FR.default.decode.bytes, s = Tn(i2);
              n += MR(s, r.slice(n + o)) + o, e.push(i2);
            }
            return e;
          }
          protoNames() {
            return this.protos().map((e) => e.name);
          }
          tuples() {
            return cy(this.bytes);
          }
          stringTuples() {
            let e = cy(this.bytes);
            return LR(e);
          }
          encapsulate(e) {
            return e = new j(e), new j(this.toString() + e.toString());
          }
          decapsulate(e) {
            let r = e.toString(), n = this.toString(), i2 = n.lastIndexOf(r);
            if (i2 < 0)
              throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);
            return new j(n.slice(0, i2));
          }
          decapsulateCode(e) {
            let r = this.tuples();
            for (let n = r.length - 1; n >= 0; n--)
              if (r[n][0] === e)
                return new j(BR(r.slice(0, n)));
            return this;
          }
          getPeerId() {
            try {
              let r = this.stringTuples().filter((n) => n[0] === ay.ipfs.code).pop();
              if (r?.[1] != null) {
                let n = r[1];
                return n[0] === "Q" || n[0] === "1" ? M(Ne.decode(`z${n}`), "base58btc") : M(I.parse(n).multihash.bytes, "base58btc");
              }
              return null;
            } catch {
              return null;
            }
          }
          getPath() {
            let e = null;
            try {
              e = this.stringTuples().filter((r) => Tn(r[0]).path === true)[0][1], e == null && (e = null);
            } catch {
              e = null;
            }
            return e;
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async resolve() {
            let e = this.protos().find((i2) => i2.resolvable);
            if (e == null)
              return [this];
            let r = Xz.get(e.name);
            if (r == null)
              throw (0, Qz.default)(new Error(`no available resolver for ${e.name}`), "ERR_NO_AVAILABLE_RESOLVER");
            return (await r(this)).map((i2) => new j(i2));
          }
          nodeAddress() {
            let e = this.protoCodes(), r = this.protoNames(), n = this.toString().split("/").slice(1);
            if (n.length < 4)
              throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
            if (e[0] !== 4 && e[0] !== 41 && e[0] !== 54 && e[0] !== 55)
              throw new Error(`no protocol with name: "'${r[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
            if (n[2] !== "tcp" && n[2] !== "udp")
              throw new Error(`no protocol with name: "'${r[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
            return { family: e[0] === 41 || e[0] === 55 ? 6 : 4, address: n[1], port: parseInt(n[3]) };
          }
          isThinWaistAddress(e) {
            let r = (e ?? this).protos();
            return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273);
          }
          static fromNodeAddress(e, r) {
            if (e == null)
              throw new Error("requires node address object");
            if (r == null)
              throw new Error("requires transport protocol");
            let n;
            switch (e.family) {
              case 4:
                n = "ip4";
                break;
              case 6:
                n = "ip6";
                break;
              default:
                throw Error("Invalid addr family, should be 4 or 6.");
            }
            return new j("/" + [n, e.address, r, e.port].join("/"));
          }
          static isName(e) {
            return j.isMultiaddr(e) ? e.protos().some((r) => r.resolvable) : false;
          }
          static isMultiaddr(e) {
            return Boolean(e?.[Yz]);
          }
          [T5e]() {
            return "<Multiaddr " + M(this.bytes, "base16") + " - " + W6(this.bytes) + ">";
          }
          inspect() {
            return "<Multiaddr " + M(this.bytes, "base16") + " - " + W6(this.bytes) + ">";
          }
        };
        j.resolvers = Xz;
        var I5e = ze("dns4"), C5e = ze("dns6"), P5e = ze("dnsaddr"), gl = mi(ze("dns"), P5e, I5e, C5e), Q6 = mi(ze("ip4"), ze("ip6")), ly = mi(dt(Q6, ze("tcp")), dt(gl, ze("tcp"))), Jz = dt(Q6, ze("udp")), D5e = dt(Jz, ze("utp")), k5e = dt(Jz, ze("quic")), vh = mi(dt(ly, ze("ws")), dt(gl, ze("ws"))), yl = mi(dt(ly, ze("wss")), dt(gl, ze("wss"))), KR = mi(dt(ly, ze("http")), dt(Q6, ze("http")), dt(gl, ze("http"))), VR = mi(dt(ly, ze("https")), dt(Q6, ze("https")), dt(gl, ze("https"))), X6 = mi(dt(vh, ze("p2p-webrtc-star"), ze("p2p")), dt(yl, ze("p2p-webrtc-star"), ze("p2p")), dt(vh, ze("p2p-webrtc-star")), dt(yl, ze("p2p-webrtc-star"))), Mje = mi(dt(vh, ze("p2p-websocket-star"), ze("p2p")), dt(yl, ze("p2p-websocket-star"), ze("p2p")), dt(vh, ze("p2p-websocket-star")), dt(yl, ze("p2p-websocket-star"))), eH = mi(dt(KR, ze("p2p-webrtc-direct"), ze("p2p")), dt(VR, ze("p2p-webrtc-direct"), ze("p2p")), dt(KR, ze("p2p-webrtc-direct")), dt(VR, ze("p2p-webrtc-direct"))), uy = mi(vh, yl, KR, VR, X6, eH, ly, D5e, k5e, gl), Uje = mi(dt(uy, ze("p2p-stardust"), ze("p2p")), dt(uy, ze("p2p-stardust"))), ml = mi(dt(uy, ze("p2p")), X6, eH, ze("p2p")), Zz = mi(dt(ml, ze("p2p-circuit"), ml), dt(ml, ze("p2p-circuit")), dt(ze("p2p-circuit"), ml), dt(uy, ze("p2p-circuit")), dt(ze("p2p-circuit"), uy), ze("p2p-circuit")), tH = () => mi(dt(Zz, tH), Zz), _h = tH(), qR = mi(dt(_h, ml, _h), dt(ml, _h), dt(_h, ml), _h, ml), rH = qR;
        function nH(t) {
          function e(r) {
            let n;
            try {
              n = new j(r);
            } catch {
              return false;
            }
            let i2 = t(n.protoNames());
            return i2 === null ? false : i2 === true || i2 === false ? i2 : i2.length === 0;
          }
          return e;
        }
        function dt(...t) {
          function e(r) {
            if (r.length < t.length)
              return null;
            let n = r;
            return t.some((i2) => (n = typeof i2 == "function" ? i2().partialMatch(r) : i2.partialMatch(r), Array.isArray(n) && (r = n), n === null)), n;
          }
          return { toString: function() {
            return "{ " + t.join(" ") + " }";
          }, input: t, matches: nH(e), partialMatch: e };
        }
        function mi(...t) {
          function e(n) {
            let i2 = null;
            return t.some((o) => {
              let s = typeof o == "function" ? o().partialMatch(n) : o.partialMatch(n);
              return s != null ? (i2 = s, true) : false;
            }), i2;
          }
          return { toString: function() {
            return "{ " + t.join(" ") + " }";
          }, input: t, matches: nH(e), partialMatch: e };
        }
        function ze(t) {
          let e = t;
          function r(i2) {
            let o;
            try {
              o = new j(i2);
            } catch {
              return false;
            }
            let s = o.protoNames();
            return s.length === 1 && s[0] === e;
          }
          function n(i2) {
            return i2.length === 0 ? null : i2[0] === e ? i2.slice(1) : null;
          }
          return { toString: function() {
            return e;
          }, matches: r, partialMatch: n };
        }
        function Z6(t) {
          try {
            return rH.matches(t);
          } catch {
            return false;
          }
        }
        function iH({ repo: t }) {
          async function e(r, n = {}) {
            if (!Z6(r))
              throw new Error(`${r} is not a valid Multiaddr`);
            let i2 = await t.config.getAll(n), o = i2.Bootstrap || [];
            return o.push(r.toString()), i2.Bootstrap = Array.from(new Set(o)).sort((s, a) => s.localeCompare(a)), await t.config.replace(i2), { Peers: [r] };
          }
          return B(e);
        }
        c();
        function oH({ repo: t }) {
          async function e(r = {}) {
            let n = await t.config.getAll(r), i2 = n.Bootstrap || [];
            return n.Bootstrap = [], await t.config.replace(n), { Peers: i2.map((o) => new j(o)) };
          }
          return B(e);
        }
        c();
        function sH({ repo: t }) {
          async function e(r = {}) {
            return { Peers: (await t.config.get("Bootstrap", r) || []).map((i2) => new j(i2)) };
          }
          return B(e);
        }
        c();
        c();
        var Kc = () => ({ Addresses: { Swarm: [], Announce: [], NoAnnounce: [], API: "", Gateway: "", RPC: "", Delegates: ["/dns4/node0.delegate.ipfs.io/tcp/443/https", "/dns4/node1.delegate.ipfs.io/tcp/443/https", "/dns4/node2.delegate.ipfs.io/tcp/443/https", "/dns4/node3.delegate.ipfs.io/tcp/443/https"] }, Discovery: { MDNS: { Enabled: false, Interval: 10 }, webRTCStar: { Enabled: true } }, Bootstrap: ["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN", "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb", "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp", "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa", "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt", "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic", "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6", "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS", "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"], Pubsub: { Enabled: true }, Swarm: { ConnMgr: { LowWater: 5, HighWater: 20 }, DisableNatPortMap: true }, Routing: { Type: "dhtclient" } });
        function aH({ repo: t }) {
          async function e(r = {}) {
            let n = await t.config.getAll(r);
            return n.Bootstrap = Kc().Bootstrap, await t.config.replace(n), { Peers: Kc().Bootstrap.map((i2) => new j(i2)) };
          }
          return B(e);
        }
        c();
        function cH({ repo: t }) {
          async function e(r, n = {}) {
            if (!Z6(r))
              throw new Error(`${r} is not a valid Multiaddr`);
            let i2 = await t.config.getAll(n);
            return i2.Bootstrap = (i2.Bootstrap || []).filter((o) => o.toString() !== r.toString()), await t.config.replace(i2), { Peers: [r] };
          }
          return B(e);
        }
        var J6 = class {
          constructor({ repo: e }) {
            this.add = iH({ repo: e }), this.list = sH({ repo: e }), this.rm = cH({ repo: e }), this.clear = oH({ repo: e }), this.reset = aH({ repo: e });
          }
        };
        c();
        c();
        function uH({ preload: t, repo: e }) {
          async function r(n, i2 = {}) {
            return i2.preload !== false && t(n), e.blocks.get(n, i2);
          }
          return B(r);
        }
        c();
        te();
        function lH({ codecs: t, hashers: e, repo: r, preload: n }) {
          async function i2(o, s = {}) {
            let a = s.pin ? await r.gcLock.readLock() : null;
            try {
              let u = s.version != null ? s.version : 0, l = s.format || (u === 0 ? "dag-pb" : "raw"), h = await (await e.getHasher(s.mhtype || "sha2-256")).digest(o), p = await t.getCodec(l), d = I.create(u, p.code, h);
              return await r.blocks.put(d, o, { signal: s.signal }), s.preload !== false && n(d), s.pin === true && await r.pins.pinRecursively(d, { signal: s.signal }), d;
            } finally {
              a && a();
            }
          }
          return B(i2);
        }
        c();
        var AH = w(K(), 1), TH = w(n5(), 1), IH = w(ei(), 1), CH = w(Gi(), 1);
        c();
        c();
        c();
        var i5 = class {
          constructor(e) {
            if (!(e > 0) || (e - 1 & e) !== 0)
              throw new Error("Max size for a FixedFIFO should be a power of two");
            this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
          }
          push(e) {
            return this.buffer[this.top] !== void 0 ? false : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, true);
          }
          shift() {
            let e = this.buffer[this.btm];
            if (e !== void 0)
              return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
          }
          isEmpty() {
            return this.buffer[this.btm] === void 0;
          }
        }, _0 = class {
          constructor(e) {
            this.hwm = e ?? 16, this.head = new i5(this.hwm), this.tail = this.head;
          }
          push(e) {
            if (!this.head.push(e)) {
              let r = this.head;
              this.head = r.next = new i5(2 * this.head.buffer.length), this.head.push(e);
            }
          }
          shift() {
            let e = this.tail.shift();
            if (e === void 0 && this.tail.next != null) {
              let r = this.tail.next;
              return this.tail.next = null, this.tail = r, this.tail.shift();
            }
            return e;
          }
          isEmpty() {
            return this.head.isEmpty();
          }
        };
        function zs(t) {
          return q5e((r) => {
            let n = r.shift();
            if (n == null)
              return { done: true };
            if (n.error != null)
              throw n.error;
            return { done: n.done === true, value: n.value };
          }, t);
        }
        function q5e(t, e) {
          e = e ?? {};
          let r = e.onEnd, n = new _0(), i2, o, s, a = async () => n.isEmpty() ? s ? { done: true } : await new Promise((y, g) => {
            o = (E) => {
              o = null, n.push(E);
              try {
                y(t(n));
              } catch (b) {
                g(b);
              }
              return i2;
            };
          }) : t(n), u = (y) => o != null ? o(y) : (n.push(y), i2), l = (y) => (n = new _0(), o != null ? o({ error: y }) : (n.push({ error: y }), i2)), f = (y) => s ? i2 : u({ done: false, value: y }), h = (y) => s ? i2 : (s = true, y != null ? l(y) : u({ done: true })), p = () => (n = new _0(), h(), { done: true }), d = (y) => (h(y), { done: true });
          if (i2 = { [Symbol.asyncIterator]() {
            return this;
          }, next: a, return: p, throw: d, push: f, end: h }, r == null)
            return i2;
          let m = i2;
          return i2 = { [Symbol.asyncIterator]() {
            return this;
          }, next() {
            return m.next();
          }, throw(y) {
            return m.throw(y), r != null && (r(y), r = void 0), { done: true };
          }, return() {
            return m.return(), r != null && (r(), r = void 0), { done: true };
          }, push: f, end(y) {
            return m.end(y), r != null && (r(y), r = void 0), i2;
          } }, i2;
        }
        var xH = w(Fc(), 1), z5e = (...t) => {
          let e;
          for (; t.length > 0; )
            e = t.shift()(e);
          return e;
        }, RH = (t) => t != null && (typeof t[Symbol.asyncIterator] == "function" || typeof t[Symbol.iterator] == "function" || typeof t.next == "function"), $R = (t) => t != null && typeof t.sink == "function" && RH(t.source), H5e = (t) => (e) => {
          let r = t.sink(e);
          if (r.then != null) {
            let n = zs();
            return r.then(() => {
              n.end();
            }, (o) => {
              n.end(o);
            }), (0, xH.default)(n, async function* () {
              yield* t.source, n.end();
            }());
          }
          return t.source;
        };
        function Te(t, ...e) {
          if ($R(t)) {
            let n = t;
            t = () => n.source;
          } else if (RH(t)) {
            let n = t;
            t = () => n;
          }
          let r = [t, ...e];
          if (r.length > 1 && $R(r[r.length - 1]) && (r[r.length - 1] = r[r.length - 1].sink), r.length > 2)
            for (let n = 1; n < r.length - 1; n++)
              $R(r[n]) && (r[n] = H5e(r[n]));
          return z5e(...r);
        }
        c();
        te();
        function o5(t) {
          return t instanceof Uint8Array ? I.decode(t) : I.parse(t.toString());
        }
        var $5e = 8;
        function PH({ repo: t }) {
          async function* e(r, n = {}) {
            Array.isArray(r) || (r = [r]);
            let i2 = await t.gcLock.writeLock();
            try {
              yield* Te(r, (o) => (0, IH.default)(o, (s) => async () => {
                s = o5(s);
                let a = { cid: s };
                try {
                  if (!await t.blocks.has(s))
                    throw (0, AH.default)(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
                  await t.blocks.delete(s);
                } catch (u) {
                  n.force || (u.message = `cannot remove ${s}: ${u.message}`, a.error = u);
                }
                return a;
              }), (o) => (0, TH.default)(o, { concurrency: $5e }), (o) => (0, CH.default)(o, () => !n.quiet));
            } finally {
              i2();
            }
          }
          return B(e);
        }
        c();
        function DH({ repo: t, preload: e }) {
          async function r(n, i2 = {}) {
            n = o5(n), i2.preload !== false && e(n);
            let o = await t.blocks.get(n);
            return { cid: n, size: o.length };
          }
          return B(r);
        }
        var s5 = class {
          constructor({ codecs: e, hashers: r, preload: n, repo: i2 }) {
            this.get = uH({ preload: n, repo: i2 }), this.put = lH({ codecs: e, hashers: r, preload: n, repo: i2 }), this.rm = PH({ repo: i2 }), this.stat = DH({ preload: n, repo: i2 });
          }
        };
        c();
        c();
        var GH = w(qi(), 1);
        c();
        c();
        var MH = w(K(), 1);
        Re();
        var UH = w(v0(), 1), FH = w(LH(), 1), KH = w(S0(), 1), VH = w(Vs(), 1), qH = w(ei(), 1);
        c();
        function Jo(t) {
          return ArrayBuffer.isView(t) || t instanceof ArrayBuffer;
        }
        function Vc(t) {
          return t.constructor && (t.constructor.name === "Blob" || t.constructor.name === "File") && typeof t.stream == "function";
        }
        function fy(t) {
          return typeof t == "object" && (t.path || t.content);
        }
        var qc = (t) => t && typeof t.getReader == "function";
        async function* a5(t) {
          yield t;
        }
        async function c5(t) {
          if (Jo(t))
            return a5(GR(t));
          if (typeof t == "string" || t instanceof String)
            return a5(GR(t.toString()));
          if (Vc(t))
            return (0, FH.default)(t);
          if (qc(t) && (t = (0, UH.default)(t)), Symbol.iterator in t || Symbol.asyncIterator in t) {
            let e = (0, KH.default)(t), { value: r, done: n } = await e.peek();
            if (n)
              return a5(new Uint8Array(0));
            if (e.push(r), Number.isInteger(r))
              return a5(Uint8Array.from(await (0, VH.default)(e)));
            if (Jo(r) || typeof r == "string" || r instanceof String)
              return (0, qH.default)(e, GR);
          }
          throw (0, MH.default)(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT");
        }
        function GR(t) {
          return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer ? new Uint8Array(t) : Array.isArray(t) ? Uint8Array.from(t) : U(t.toString());
        }
        c();
        var l5 = w(K(), 1), zH = w(v0(), 1), HH = w(S0(), 1);
        async function* $H(t, e) {
          if (t == null)
            throw (0, l5.default)(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT");
          if (typeof t == "string" || t instanceof String) {
            yield u5(t.toString(), e);
            return;
          }
          if (Jo(t) || Vc(t)) {
            yield u5(t, e);
            return;
          }
          if (qc(t) && (t = (0, zH.default)(t)), Symbol.iterator in t || Symbol.asyncIterator in t) {
            let r = (0, HH.default)(t), { value: n, done: i2 } = await r.peek();
            if (i2) {
              yield { content: [] };
              return;
            }
            if (r.push(n), Number.isInteger(n) || Jo(n) || typeof n == "string" || n instanceof String) {
              yield u5(r, e);
              return;
            }
            throw (0, l5.default)(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"), "ERR_UNEXPECTED_INPUT");
          }
          if (fy(t)) {
            yield u5(t, e);
            return;
          }
          throw (0, l5.default)(new Error('Unexpected input: cannot convert "' + typeof t + '" into ImportCandidate'), "ERR_UNEXPECTED_INPUT");
        }
        async function u5(t, e) {
          let { path: r, mode: n, mtime: i2, content: o } = t, s = { path: r || "", mode: Ec(n), mtime: qu(i2) };
          return o ? s.content = await e(o) : r || (s.content = await e(t)), s;
        }
        function f5(t) {
          return $H(t, c5);
        }
        function WH({ addAll: t }) {
          async function e(r, n = {}) {
            let i2 = await (0, GH.default)(t(f5(r), n));
            if (i2 == null)
              throw Error("Failed to add a file, if you see this please report a bug");
            return i2;
          }
          return e;
        }
        c();
        c();
        var X$ = w(d5(), 1);
        c();
        vr();
        c();
        rw();
        bp();
        var WR = w(ZH(), 1);
        function Z5e(t) {
          let e = new Array(4);
          for (let r = 0; r < 4; r++)
            e[r] = t & 255, t = t >> 8;
          return new Uint8Array(e);
        }
        var nQe = Ep({ name: "murmur3-32", code: 35, encode: (t) => Z5e(WR.default.x86.hash32(t)) }), Sh = Ep({ name: "murmur3-128", code: 34, encode: (t) => op.fromHex(WR.default.x64.hash128(t)) });
        async function J5e(t) {
          return (await Sh.encode(t)).slice(0, 8).reverse();
        }
        var e8e = { chunker: "fixed", strategy: "balanced", rawLeaves: false, onlyHash: false, reduceSingleLeafToSelf: true, hasher: xe, leafType: "file", cidVersion: 0, progress: () => () => {
        }, shardSplitThreshold: 1e3, fileImportConcurrency: 50, blockWriteConcurrency: 10, minChunkSize: 262144, maxChunkSize: 262144, avgChunkSize: 262144, window: 16, polynomial: 17437180132763652, maxChildrenPerNode: 174, layerRepeat: 4, wrapWithDirectory: false, recursive: false, hidden: false, timeout: void 0, hamtHashFn: J5e, hamtHashCode: 34, hamtBucketBits: 8 }, JH = (t = {}) => Ze.bind({ ignoreUndefined: true })(e8e, t);
        c();
        c();
        c();
        te();
        vr();
        var t8e = async (t, e, r) => {
          r.codec || (r.codec = At), r.hasher || (r.hasher = xe), r.cidVersion === void 0 && (r.cidVersion = 1), r.codec === At && r.hasher !== xe && (r.cidVersion = 1);
          let n = await r.hasher.digest(t), i2 = I.create(r.cidVersion, r.codec.code, n);
          return r.onlyHash || await e.put(i2, t, { signal: r.signal }), i2;
        }, Hs = t8e;
        var r8e = async (t, e, r) => {
          let n = new Je({ type: "directory", mtime: t.mtime, mode: t.mode }), i2 = je(Ln({ Data: n.marshal() })), o = await Hs(i2, e, r), s = t.path;
          return { cid: o, path: s, unixfs: n, size: i2.length };
        }, e$ = r8e;
        c();
        var u$ = w(K(), 1);
        var l$ = w(d5(), 1);
        zo();
        c();
        var t$ = w(Vs(), 1);
        async function n8e(t, e) {
          return e(await (0, t$.default)(t));
        }
        var r$ = n8e;
        c();
        var n$ = w(h5(), 1);
        function i8e(t, e, r) {
          return i$(t, e, r);
        }
        async function i$(t, e, r) {
          let n = [];
          for await (let i2 of (0, n$.default)(t, r.maxChildrenPerNode))
            n.push(await e(i2));
          return n.length > 1 ? i$(n, e, r) : n[0];
        }
        var o$ = i8e;
        c();
        var s$ = w(h5(), 1);
        async function o8e(t, e, r) {
          let n = new jR(r.layerRepeat), i2 = 0, o = 1, s = n;
          for await (let a of (0, s$.default)(t, r.maxChildrenPerNode))
            s.isFull() && (s !== n && n.addChild(await s.reduce(e)), i2 && i2 % r.layerRepeat === 0 && o++, s = new m5(o, r.layerRepeat, i2), i2++), s.append(a);
          return s && s !== n && n.addChild(await s.reduce(e)), n.reduce(e);
        }
        var a$ = o8e, m5 = class {
          constructor(e, r, n = 0) {
            this.maxDepth = e, this.layerRepeat = r, this.currentDepth = 1, this.iteration = n, this.root = this.node = this.parent = { children: [], depth: this.currentDepth, maxDepth: e, maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat };
          }
          isFull() {
            if (!this.root.data)
              return false;
            if (this.currentDepth < this.maxDepth && this.node.maxChildren)
              return this._addNextNodeToParent(this.node), false;
            let e = this._findParent(this.node, this.currentDepth);
            return e ? (this._addNextNodeToParent(e), false) : true;
          }
          _addNextNodeToParent(e) {
            this.parent = e;
            let r = { children: [], depth: e.depth + 1, parent: e, maxDepth: this.maxDepth, maxChildren: Math.floor(e.children.length / this.layerRepeat) * this.layerRepeat };
            e.children.push(r), this.currentDepth = r.depth, this.node = r;
          }
          append(e) {
            this.node.data = e;
          }
          reduce(e) {
            return this._reduce(this.root, e);
          }
          async _reduce(e, r) {
            let n = [];
            return e.children.length && (n = await Promise.all(e.children.filter((i2) => i2.data).map((i2) => this._reduce(i2, r)))), r((e.data || []).concat(n));
          }
          _findParent(e, r) {
            let n = e.parent;
            if (!(!n || n.depth === 0))
              return n.children.length === n.maxChildren || !n.maxChildren ? this._findParent(n, r) : n;
          }
        }, jR = class extends m5 {
          constructor(e) {
            super(0, e), this.root.depth = 0, this.currentDepth = 1;
          }
          addChild(e) {
            this.root.children.push(e);
          }
          reduce(e) {
            return e((this.root.data || []).concat(this.root.children));
          }
        };
        c();
        zo();
        async function* s8e(t, e, r) {
          for await (let n of t.content)
            yield async () => {
              r.progress(n.length, t.path);
              let i2, o = { codec: At, cidVersion: r.cidVersion, hasher: r.hasher, onlyHash: r.onlyHash };
              return r.rawLeaves ? (o.codec = Fi, o.cidVersion = 1) : (i2 = new Je({ type: r.leafType, data: n }), n = je({ Data: i2.marshal(), Links: [] })), { cid: await Hs(n, e, o), unixfs: i2, size: n.length };
            };
        }
        var c$ = s8e;
        var a8e = { flat: r$, balanced: o$, trickle: a$ };
        async function* c8e(t, e, r) {
          let n = -1, i2, o;
          typeof r.bufferImporter == "function" ? o = r.bufferImporter : o = c$;
          for await (let s of (0, l$.default)(o(t, e, r), r.blockWriteConcurrency)) {
            if (n++, n === 0) {
              i2 = s;
              continue;
            } else
              n === 1 && i2 && (yield i2, i2 = null);
            yield s;
          }
          i2 && (i2.single = true, yield i2);
        }
        var u8e = (t, e, r) => {
          async function n(i2) {
            if (i2.length === 1 && i2[0].single && r.reduceSingleLeafToSelf) {
              let f = i2[0];
              if (t.mtime !== void 0 || t.mode !== void 0) {
                let h = await e.get(f.cid);
                f.unixfs = new Je({ type: "file", mtime: t.mtime, mode: t.mode, data: h }), h = je(Ln({ Data: f.unixfs.marshal() })), f.cid = await Hs(h, e, { ...r, codec: At, hasher: r.hasher, cidVersion: r.cidVersion }), f.size = h.length;
              }
              return { cid: f.cid, path: t.path, unixfs: f.unixfs, size: f.size };
            }
            let o = new Je({ type: "file", mtime: t.mtime, mode: t.mode }), s = i2.filter((f) => f.cid.code === Un && f.size || f.unixfs && !f.unixfs.data && f.unixfs.fileSize() ? true : Boolean(f.unixfs && f.unixfs.data && f.unixfs.data.length)).map((f) => f.cid.code === Un ? (o.addBlockSize(f.size), { Name: "", Tsize: f.size, Hash: f.cid }) : (!f.unixfs || !f.unixfs.data ? o.addBlockSize(f.unixfs && f.unixfs.fileSize() || 0) : o.addBlockSize(f.unixfs.data.length), { Name: "", Tsize: f.size, Hash: f.cid })), a = { Data: o.marshal(), Links: s }, u = je(Ln(a));
            return { cid: await Hs(u, e, r), path: t.path, unixfs: o, size: u.length + a.Links.reduce((f, h) => f + h.Tsize, 0) };
          }
          return n;
        };
        function l8e(t, e, r) {
          let n = a8e[r.strategy];
          if (!n)
            throw (0, u$.default)(new Error(`Unknown importer build strategy name: ${r.strategy}`), "ERR_BAD_STRATEGY");
          return n(c8e(t, e, r), u8e(t, e, r), r);
        }
        var f$ = l8e;
        var rA = w(K(), 1);
        c();
        var T$ = w(YR(), 1), I$ = w(A$(), 1), eA = w(K(), 1);
        async function* y8e(t, e) {
          let r, n, i2;
          if (e.minChunkSize && e.maxChunkSize && e.avgChunkSize)
            i2 = e.avgChunkSize, r = e.minChunkSize, n = e.maxChunkSize;
          else if (e.avgChunkSize)
            i2 = e.avgChunkSize, r = i2 / 3, n = i2 + i2 / 2;
          else
            throw (0, eA.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
          if (r < 16)
            throw (0, eA.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
          n < r && (n = r), i2 < r && (i2 = r);
          let o = Math.floor(Math.log2(i2));
          for await (let s of g8e(t, { min: r, max: n, bits: o, window: e.window, polynomial: e.polynomial }))
            yield s;
        }
        var C$ = y8e;
        async function* g8e(t, e) {
          let r = await (0, I$.create)(e.bits, e.min, e.max, e.window), n = new T$.default();
          for await (let i2 of t) {
            n.append(i2);
            let o = r.fingerprint(i2);
            for (let s = 0; s < o.length; s++) {
              let a = o[s], u = n.slice(0, a);
              n.consume(a), yield u;
            }
          }
          n.length && (yield n.slice(0));
        }
        c();
        var y5 = w(YR(), 1);
        async function* w8e(t, e) {
          let r = new y5.default(), n = 0, i2 = false, o = e.maxChunkSize;
          for await (let s of t)
            for (r.append(s), n += s.length; n >= o; )
              if (yield r.slice(0, o), i2 = true, o === r.length)
                r = new y5.default(), n = 0;
              else {
                let a = new y5.default();
                a.append(r.shallowSlice(o)), r = a, n -= o;
              }
          (!i2 || n) && (yield r.slice(0, n));
        }
        var P$ = w8e;
        c();
        var tA = w(K(), 1);
        Re();
        async function* E8e(t) {
          for await (let e of t) {
            if (e.length === void 0)
              throw (0, tA.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
            if (typeof e == "string" || e instanceof String)
              yield U(e.toString());
            else if (Array.isArray(e))
              yield Uint8Array.from(e);
            else if (e instanceof Uint8Array)
              yield e;
            else
              throw (0, tA.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
          }
        }
        var D$ = E8e;
        function b8e(t) {
          return Symbol.iterator in t;
        }
        function _8e(t) {
          return Symbol.asyncIterator in t;
        }
        function v8e(t) {
          try {
            if (t instanceof Uint8Array)
              return async function* () {
                yield t;
              }();
            if (b8e(t))
              return async function* () {
                yield* t;
              }();
            if (_8e(t))
              return t;
          } catch {
            throw (0, rA.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
          }
          throw (0, rA.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
        }
        async function* S8e(t, e, r) {
          for await (let n of t)
            if (n.path && (n.path.substring(0, 2) === "./" && (r.wrapWithDirectory = true), n.path = n.path.split("/").filter((i2) => i2 && i2 !== ".").join("/")), n.content) {
              let i2;
              typeof r.chunker == "function" ? i2 = r.chunker : r.chunker === "rabin" ? i2 = C$ : i2 = P$;
              let o;
              typeof r.chunkValidator == "function" ? o = r.chunkValidator : o = D$;
              let s = { path: n.path, mtime: n.mtime, mode: n.mode, content: i2(o(v8e(n.content), r), r) };
              yield () => f$(s, e, r);
            } else if (n.path) {
              let i2 = { path: n.path, mtime: n.mtime, mode: n.mode };
              yield () => e$(i2, e, r);
            } else
              throw new Error("Import candidate must have content or path or both");
        }
        var k$ = S8e;
        c();
        c();
        c();
        var nA = class {
          constructor(e, r) {
            this.options = r || {}, this.root = e.root, this.dir = e.dir, this.path = e.path, this.dirty = e.dirty, this.flat = e.flat, this.parent = e.parent, this.parentKey = e.parentKey, this.unixfs = e.unixfs, this.mode = e.mode, this.mtime = e.mtime, this.cid = void 0, this.size = void 0;
          }
          async put(e, r) {
          }
          get(e) {
            return Promise.resolve(this);
          }
          async *eachChildSeries() {
          }
          async *flush(e) {
          }
        }, wl = nA;
        var iA = class extends wl {
          constructor(e, r) {
            super(e, r), this._children = {};
          }
          async put(e, r) {
            this.cid = void 0, this.size = void 0, this._children[e] = r;
          }
          get(e) {
            return Promise.resolve(this._children[e]);
          }
          childCount() {
            return Object.keys(this._children).length;
          }
          directChildrenCount() {
            return this.childCount();
          }
          onlyChild() {
            return this._children[Object.keys(this._children)[0]];
          }
          async *eachChildSeries() {
            let e = Object.keys(this._children);
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              yield { key: n, child: this._children[n] };
            }
          }
          async *flush(e) {
            let r = Object.keys(this._children), n = [];
            for (let l = 0; l < r.length; l++) {
              let f = this._children[r[l]];
              if (f instanceof wl)
                for await (let h of f.flush(e))
                  f = h, yield f;
              f.size != null && f.cid && n.push({ Name: r[l], Tsize: f.size, Hash: f.cid });
            }
            let i2 = new Je({ type: "directory", mtime: this.mtime, mode: this.mode }), o = { Data: i2.marshal(), Links: n }, s = je(Ln(o)), a = await Hs(s, e, this.options), u = s.length + o.Links.reduce((l, f) => l + (f.Tsize == null ? 0 : f.Tsize), 0);
            this.cid = a, this.size = u, yield { cid: a, unixfs: i2, path: this.path, size: u };
          }
        }, yy = iA;
        c();
        c();
        var g5 = w(wy(), 1), sA = class extends wl {
          constructor(e, r) {
            super(e, r), this._bucket = (0, g5.createHAMT)({ hashFn: r.hamtHashFn, bits: r.hamtBucketBits });
          }
          async put(e, r) {
            await this._bucket.put(e, r);
          }
          get(e) {
            return this._bucket.get(e);
          }
          childCount() {
            return this._bucket.leafCount();
          }
          directChildrenCount() {
            return this._bucket.childrenCount();
          }
          onlyChild() {
            return this._bucket.onlyChild();
          }
          async *eachChildSeries() {
            for await (let { key: e, value: r } of this._bucket.eachLeafSeries())
              yield { key: e, child: r };
          }
          async *flush(e) {
            for await (let r of $$(this._bucket, e, this, this.options))
              yield { ...r, path: this.path };
          }
        }, H$ = sA;
        async function* $$(t, e, r, n) {
          let i2 = t._children, o = [], s = 0;
          for (let d = 0; d < i2.length; d++) {
            let m = i2.get(d);
            if (!m)
              continue;
            let y = d.toString(16).toUpperCase().padStart(2, "0");
            if (m instanceof g5.Bucket) {
              let g;
              for await (let E of await $$(m, e, null, n))
                g = E;
              if (!g)
                throw new Error("Could not flush sharded directory, no subshard found");
              o.push({ Name: y, Tsize: g.size, Hash: g.cid }), s += g.size;
            } else if (typeof m.value.flush == "function") {
              let g = m.value, E;
              for await (let v of g.flush(e))
                E = v, yield E;
              let b = y + m.key;
              o.push({ Name: b, Tsize: E.size, Hash: E.cid }), s += E.size;
            } else {
              let g = m.value;
              if (!g.cid)
                continue;
              let E = y + m.key, b = g.size;
              o.push({ Name: E, Tsize: b, Hash: g.cid }), s += b;
            }
          }
          let a = Uint8Array.from(i2.bitField().reverse()), u = new Je({ type: "hamt-sharded-directory", data: a, fanout: t.tableSize(), hashType: n.hamtHashCode, mtime: r && r.mtime, mode: r && r.mode }), l = { Data: u.marshal(), Links: o }, f = je(Ln(l)), h = await Hs(f, e, n), p = f.length + s;
          yield { cid: h, unixfs: u, size: p };
        }
        async function G$(t, e, r, n) {
          let i2 = e;
          e instanceof yy && e.directChildrenCount() >= r && (i2 = await V8e(e, n));
          let o = i2.parent;
          if (o) {
            if (i2 !== e) {
              if (t && (t.parent = i2), !i2.parentKey)
                throw new Error("No parent key found");
              await o.put(i2.parentKey, i2);
            }
            return G$(i2, o, r, n);
          }
          return i2;
        }
        async function V8e(t, e) {
          let r = new H$({ root: t.root, dir: true, parent: t.parent, parentKey: t.parentKey, path: t.path, dirty: t.dirty, flat: false, mtime: t.mtime, mode: t.mode }, e);
          for await (let { key: n, child: i2 } of t.eachChildSeries())
            await r.put(n, i2);
          return r;
        }
        var W$ = G$;
        c();
        var q8e = (t = "") => (t.trim().match(/([^\\/]|\\\/)+/g) || []).filter(Boolean), j$ = q8e;
        async function z8e(t, e, r) {
          let n = j$(t.path || ""), i2 = n.length - 1, o = e, s = "";
          for (let a = 0; a < n.length; a++) {
            let u = n[a];
            s += `${s ? "/" : ""}${u}`;
            let l = a === i2;
            if (o.dirty = true, o.cid = void 0, o.size = void 0, l)
              await o.put(u, t), e = await W$(null, o, r.shardSplitThreshold, r);
            else {
              let f = await o.get(u);
              (!f || !(f instanceof wl)) && (f = new yy({ root: false, dir: true, parent: o, parentKey: u, path: s, dirty: true, flat: true, mtime: f && f.unixfs && f.unixfs.mtime, mode: f && f.unixfs && f.unixfs.mode }, r)), await o.put(u, f), o = f;
            }
          }
          return e;
        }
        async function* Y$(t, e) {
          if (!(t instanceof wl)) {
            t && t.unixfs && t.unixfs.isDirectory() && (yield t);
            return;
          }
          yield* t.flush(e);
        }
        async function* H8e(t, e, r) {
          let n = new yy({ root: true, dir: true, path: "", dirty: true, flat: true }, r);
          for await (let i2 of t)
            !i2 || (n = await z8e(i2, n, r), (!i2.unixfs || !i2.unixfs.isDirectory()) && (yield i2));
          if (r.wrapWithDirectory)
            yield* Y$(n, e);
          else
            for await (let i2 of n.eachChildSeries())
              !i2 || (yield* Y$(i2.child, e));
        }
        var Q$ = H8e;
        async function* x0(t, e, r = {}) {
          let n = JH(r), i2;
          typeof r.dagBuilder == "function" ? i2 = r.dagBuilder : i2 = k$;
          let o;
          typeof r.treeBuilder == "function" ? o = r.treeBuilder : o = Q$;
          let s;
          Symbol.asyncIterator in t || Symbol.iterator in t ? s = t : s = [t];
          for await (let a of o((0, X$.default)(i2(s, e, n), n.fileImportConcurrency), e, n))
            yield { cid: a.cid, path: a.path, unixfs: a.unixfs, size: a.size };
        }
        c();
        c();
        var Ey = w(K(), 1), Z$ = w(v0(), 1), J$ = w(S0(), 1), cA = w(ei(), 1);
        async function* w5(t, e) {
          if (typeof t == "string" || t instanceof String || Jo(t) || Vc(t) || t._readableState)
            throw (0, Ey.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
          if (qc(t) && (t = (0, Z$.default)(t)), Symbol.iterator in t || Symbol.asyncIterator in t) {
            let r = (0, J$.default)(t), { value: n, done: i2 } = await r.peek();
            if (i2) {
              yield* [];
              return;
            }
            if (r.push(n), Number.isInteger(n))
              throw (0, Ey.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT");
            if (n._readableState) {
              yield* (0, cA.default)(r, (o) => aA({ content: o }, e));
              return;
            }
            if (Jo(n)) {
              yield aA({ content: r }, e);
              return;
            }
            if (fy(n) || n[Symbol.iterator] || n[Symbol.asyncIterator] || qc(n) || Vc(n)) {
              yield* (0, cA.default)(r, (o) => aA(o, e));
              return;
            }
          }
          throw fy(t) ? (0, Ey.default)(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"), "ERR_UNEXPECTED_INPUT") : (0, Ey.default)(new Error("Unexpected input: " + typeof t), "ERR_UNEXPECTED_INPUT");
        }
        async function aA(t, e) {
          let { path: r, mode: n, mtime: i2, content: o } = t, s = { path: r || "", mode: Ec(n), mtime: qu(i2) };
          return o ? s.content = await e(o) : r || (s.content = await e(t)), s;
        }
        function eG(t) {
          return w5(t, c5);
        }
        c();
        var tG = (t) => {
          if (t)
            if (t.startsWith("size-")) {
              let e = t.split("-")[1], r = parseInt(e);
              if (isNaN(r))
                throw new Error("Chunker parameter size must be an integer");
              return { chunker: "fixed", maxChunkSize: r };
            } else {
              if (t.startsWith("rabin"))
                return { chunker: "rabin", ...$8e(t) };
              throw new Error(`Unrecognized chunker option: ${t}`);
            }
          else
            return { chunker: "fixed" };
        }, $8e = (t) => {
          let e = {}, r = t.split("-");
          switch (r.length) {
            case 1:
              e.avgChunkSize = 262144;
              break;
            case 2:
              e.avgChunkSize = E5(r[1], "avg");
              break;
            case 4:
              e.minChunkSize = E5(r[1], "min"), e.avgChunkSize = E5(r[2], "avg"), e.maxChunkSize = E5(r[3], "max");
              break;
            default:
              throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
          }
          return e;
        }, E5 = (t, e) => {
          let r = parseInt(t);
          if (isNaN(r))
            throw new Error(`Chunker parameter ${e} must be an integer`);
          return r;
        };
        var G8e = Ze.bind({ ignoreUndefined: true });
        function rG({ repo: t, preload: e, hashers: r, options: n }) {
          let i2 = n && n.sharding;
          async function* o(s, a = {}) {
            let u = G8e({ shardSplitThreshold: i2 ? 1e3 : 1 / 0, strategy: "balanced" }, a, { ...tG(a.chunker) });
            u.hashAlg && u.hashAlg !== "sha2-256" && u.cidVersion !== 1 && (u.cidVersion = 1), u.trickle && (u.strategy = "trickle"), u.strategy === "trickle" && (u.leafType = "raw", u.reduceSingleLeafToSelf = false), u.cidVersion > 0 && u.rawLeaves === void 0 && (u.rawLeaves = true), u.hashAlg !== void 0 && u.rawLeaves === void 0 && (u.rawLeaves = true), delete u.trickle;
            let l = {};
            if (u.progress) {
              let d = u.progress;
              u.progress = (m, y) => {
                l[y] || (l[y] = 0), l[y] += m, d(l[y], y);
              };
            }
            let f;
            u.hashAlg != null && (f = await r.getHasher(u.hashAlg));
            let h = Te(eG(s), (d) => x0(d, t.blocks, { ...u, hasher: f, pin: false }), W8e(u), j8e(e, u), Y8e(t, u)), p = await t.gcLock.readLock();
            try {
              for await (let d of h) {
                let m = d.path ?? d.cid.toString();
                delete l[m], yield { ...d, path: m };
              }
            } finally {
              p();
            }
          }
          return B(o);
        }
        function W8e(t) {
          async function* e(r) {
            for await (let n of r) {
              let i2 = n.cid;
              t.cidVersion === 1 && (i2 = i2.toV1());
              let o = n.path ? n.path : i2.toString();
              t.wrapWithDirectory && !n.path && (o = ""), yield { path: o, cid: i2, size: n.size, mode: n.unixfs && n.unixfs.mode, mtime: n.unixfs && n.unixfs.mtime };
            }
          }
          return e;
        }
        function j8e(t, e) {
          async function* r(n) {
            for await (let i2 of n)
              (!i2.path || e.wrapWithDirectory ? i2.path === "" : !i2.path.includes("/")) && !e.onlyHash && e.preload !== false && t(i2.cid), yield i2;
          }
          return r;
        }
        function Y8e(t, e) {
          async function* r(n) {
            for await (let i2 of n) {
              let o = !(i2.path && i2.path.includes("/"));
              (e.pin == null ? true : e.pin) && o && !e.onlyHash && await t.pins.pinRecursively(i2.cid), yield i2;
            }
          }
          return r;
        }
        c();
        c();
        var S5 = w(K(), 1);
        te();
        c();
        var gG = w(K(), 1);
        zo();
        va();
        c();
        var v5 = w(K(), 1);
        c();
        var b5 = w(wy(), 1);
        var Q8e = async function(t) {
          return (await Sh.encode(t)).slice(0, 8).reverse();
        }, X8e = (t, e, r) => Promise.all(t.map((n) => {
          if (n.Name == null)
            throw new Error("Unexpected Link without a Name");
          if (n.Name.length === 2) {
            let i2 = parseInt(n.Name, 16);
            return e._putObjectAt(i2, new b5.Bucket({ hash: r._options.hash, bits: r._options.bits }, e, i2));
          }
          return r.put(n.Name.substring(2), true);
        })), nG = (t) => t.toString(16).toUpperCase().padStart(2, "0").substring(0, 2), Z8e = (t) => {
          let e = t.bucket, r = [];
          for (; e._parent; )
            r.push(e), e = e._parent;
          return r.push(e), r.reverse();
        }, iG = async (t, e, r, n, i2) => {
          if (!n) {
            let f = (0, b5.createHAMT)({ hashFn: Q8e });
            n = { rootBucket: f, hamtDepth: 1, lastBucket: f };
          }
          await X8e(t.Links, n.lastBucket, n.rootBucket);
          let o = await n.rootBucket._findNewBucketAndPos(e), s = nG(o.pos), a = Z8e(o);
          a.length > n.hamtDepth && (n.lastBucket = a[n.hamtDepth], s = nG(n.lastBucket._posAtParent));
          let u = t.Links.find((f) => {
            if (f.Name == null)
              return false;
            let h = f.Name.substring(0, 2), p = f.Name.substring(2);
            return !(h !== s || p && p !== e);
          });
          if (!u)
            return null;
          if (u.Name != null && u.Name.substring(2) === e)
            return u.Hash;
          n.hamtDepth++;
          let l = await r.get(u.Hash, i2);
          return t = Rt(l), iG(t, e, r, n, i2);
        }, oG = iG;
        c();
        c();
        function J8e(t, e, r, n) {
          let i2 = t.length, o = e + i2;
          return r >= o || n < e ? new Uint8Array(0) : (n >= e && n < o && (t = t.slice(0, n - e)), r >= e && r < o && (t = t.slice(r - e)), t);
        }
        var xh = J8e;
        c();
        var _5 = w(K(), 1), eEe = (t, e, r) => {
          if (e || (e = 0), e < 0)
            throw (0, _5.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
          if (e > t)
            throw (0, _5.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
          if (!r && r !== 0 && (r = t - e), r < 0)
            throw (0, _5.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
          return e + r > t && (r = t - e), { offset: e, length: r };
        }, R0 = eEe;
        var uA = w(K(), 1);
        zo();
        async function* sG(t, e, r, n, i2 = 0, o) {
          if (e instanceof Uint8Array) {
            let u = xh(e, i2, r, n);
            return u.length && (yield u), i2 += u.length, i2;
          }
          if (e.Data == null)
            throw (0, uA.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
          let s;
          try {
            s = Je.unmarshal(e.Data);
          } catch (u) {
            throw (0, uA.default)(u, "ERR_NOT_UNIXFS");
          }
          if (s.data && s.data.length) {
            let u = xh(s.data, i2, r, n);
            u.length && (yield u), i2 += s.data.length;
          }
          let a = i2;
          for (let u = 0; u < e.Links.length; u++) {
            let l = e.Links[u], f = i2 + s.blockSizes[u];
            if (r >= a && r < f || n > a && n <= f || r < a && n > f) {
              let h = await t.get(l.Hash, { signal: o.signal }), p;
              switch (l.Hash.code) {
                case pt:
                  p = await Rt(h);
                  break;
                case Un:
                  p = h;
                  break;
                case qf:
                  p = await zf(h);
                  break;
                default:
                  throw Error(`Unsupported codec: ${l.Hash.code}`);
              }
              for await (let d of sG(t, p, r, n, i2, o))
                i2 += d.length, yield d;
            }
            i2 = f, a = f + 1;
          }
        }
        var tEe = (t, e, r, n, i2, o, s) => {
          function a(u = {}) {
            let l = r.fileSize();
            if (l === void 0)
              throw new Error("File was a directory");
            let { offset: f, length: h } = R0(l, u.offset, u.length), p = f, d = f + h;
            return sG(s, e, p, d, 0, u);
          }
          return a;
        }, lA = tEe;
        c();
        var rEe = (t, e, r, n, i2, o, s) => {
          async function* a(u = {}) {
            let l = u.offset || 0, f = u.length || e.Links.length, h = e.Links.slice(l, f);
            for (let p of h) {
              let d = await i2(p.Hash, p.Name || "", `${n}/${p.Name || ""}`, [], o + 1, s, u);
              d.entry && (yield d.entry);
            }
          }
          return a;
        }, aG = rEe;
        c();
        var nEe = (t, e, r, n, i2, o, s) => {
          function a(u = {}) {
            return cG(e, n, i2, o, s, u);
          }
          return a;
        };
        async function* cG(t, e, r, n, i2, o) {
          let s = t.Links;
          for (let a of s) {
            let u = a.Name != null ? a.Name.substring(2) : null;
            if (u)
              yield (await r(a.Hash, u, `${e}/${u}`, [], n + 1, i2, o)).entry;
            else {
              let l = await i2.get(a.Hash);
              t = Rt(l);
              for await (let f of cG(t, e, r, n, i2, o))
                yield f;
            }
          }
        }
        var uG = nEe;
        var iEe = (t, e) => {
          let r = t.Links.find((n) => n.Name === e);
          return r && r.Hash;
        }, oEe = { raw: lA, file: lA, directory: aG, "hamt-sharded-directory": uG, metadata: (t, e, r, n, i2, o, s) => () => [], symlink: (t, e, r, n, i2, o, s) => () => [] }, sEe = async (t, e, r, n, i2, o, s, a) => {
          let u = await s.get(t, a), l = Rt(u), f, h;
          if (e || (e = t.toString()), l.Data == null)
            throw (0, v5.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
          try {
            f = Je.unmarshal(l.Data);
          } catch (p) {
            throw (0, v5.default)(p, "ERR_NOT_UNIXFS");
          }
          if (r || (r = e), n.length) {
            let p;
            if (f && f.type === "hamt-sharded-directory" ? p = await oG(l, n[0], s) : p = iEe(l, n[0]), !p)
              throw (0, v5.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
            let d = n.shift(), m = `${r}/${d}`;
            h = { cid: p, toResolve: n, name: d || "", path: m };
          }
          return { entry: { type: f.isDirectory() ? "directory" : "file", name: e, path: r, cid: t, content: oEe[f.type](t, l, f, r, i2, o, s), unixfs: f, depth: o, node: l, size: f.fileSize() }, next: h };
        }, lG = sEe;
        c();
        var fG = w(K(), 1);
        var aEe = (t) => {
          async function* e(r = {}) {
            let { offset: n, length: i2 } = R0(t.length, r.offset, r.length);
            yield xh(t, 0, n, n + i2);
          }
          return e;
        }, cEe = async (t, e, r, n, i2, o, s, a) => {
          if (n.length)
            throw (0, fG.default)(new Error(`No link named ${r} found in raw node ${t}`), "ERR_NOT_FOUND");
          let u = await s.get(t, a);
          return { entry: { type: "raw", name: e, path: r, cid: t, content: aEe(u), depth: o, size: u.length, node: u } };
        }, hG = cEe;
        c();
        te();
        var dG = w(K(), 1);
        var uEe = async (t, e, r, n, i2, o, s, a) => {
          let u = await s.get(t), l = zf(u), f = l, h = r;
          for (; n.length; ) {
            let p = n[0];
            if (p in f) {
              n.shift(), h = `${h}/${p}`;
              let d = I.asCID(f[p]);
              if (d)
                return { entry: { type: "object", name: e, path: r, cid: t, node: u, depth: o, size: u.length, content: async function* () {
                  yield l;
                } }, next: { cid: d, name: p, path: h, toResolve: n } };
              f = f[p];
            } else
              throw (0, dG.default)(new Error(`No property named ${p} found in cbor node ${t}`), "ERR_NO_PROP");
          }
          return { entry: { type: "object", name: e, path: r, cid: t, node: u, depth: o, size: u.length, content: async function* () {
            yield l;
          } } };
        }, pG = uEe;
        c();
        var mG = w(K(), 1);
        On();
        var lEe = (t) => {
          async function* e(r = {}) {
            let { offset: n, length: i2 } = R0(t.length, r.offset, r.length);
            yield xh(t, 0, n, n + i2);
          }
          return e;
        }, fEe = async (t, e, r, n, i2, o, s, a) => {
          if (n.length)
            throw (0, mG.default)(new Error(`No link named ${r} found in raw node ${t}`), "ERR_NOT_FOUND");
          let u = await _r(t.multihash.bytes);
          return { entry: { type: "identity", name: e, path: r, cid: t, content: lEe(u.digest), depth: o, size: u.digest.length, node: u.digest } };
        }, yG = fEe;
        var hEe = { [pt]: lG, [Un]: hG, [qf]: pG, [$r.code]: yG };
        function wG(t, e, r, n, i2, o, s) {
          let a = hEe[t.code];
          if (!a)
            throw (0, gG.default)(new Error(`No resolver for code ${t.code}`), "ERR_NO_RESOLVER");
          return a(t, e, r, n, wG, i2, o, s);
        }
        var EG = wG;
        var bG = w(qi(), 1), dEe = (t = "") => (t.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean), pEe = (t) => {
          if (t instanceof Uint8Array)
            return { cid: I.decode(t), toResolve: [] };
          let e = I.asCID(t);
          if (e)
            return { cid: e, toResolve: [] };
          if (typeof t == "string") {
            t.indexOf("/ipfs/") === 0 && (t = t.substring(6));
            let r = dEe(t);
            return { cid: I.parse(r[0]), toResolve: r.slice(1) };
          }
          throw (0, S5.default)(new Error(`Unknown path type ${t}`), "ERR_BAD_PATH");
        };
        async function* fA(t, e, r = {}) {
          let { cid: n, toResolve: i2 } = pEe(t), o = n.toString(), s = o, a = i2.length;
          for (; ; ) {
            let u = await EG(n, o, s, i2, a, e, r);
            if (!u.entry && !u.next)
              throw (0, S5.default)(new Error(`Could not resolve ${t}`), "ERR_NOT_FOUND");
            if (u.entry && (yield u.entry), !u.next)
              return;
            i2 = u.next.toResolve, n = u.next.cid, o = u.next.name, s = u.next.path;
          }
        }
        async function ti(t, e, r = {}) {
          let n = await (0, bG.default)(fA(t, e, r));
          if (!n)
            throw (0, S5.default)(new Error(`Could not resolve ${t}`), "ERR_NOT_FOUND");
          return n;
        }
        async function* x5(t, e, r = {}) {
          let n = await ti(t, e, r);
          if (!n)
            return;
          if (yield n, n.type === "directory")
            for await (let o of i2(n, r))
              yield o;
          async function* i2(o, s) {
            for await (let a of o.content(s))
              yield a, !(a instanceof Uint8Array) && a.type === "directory" && (yield* i2(a, s));
          }
        }
        te();
        function _G({ repo: t, preload: e }) {
          async function* r(n, i2 = {}) {
            if (n = Bp(n), i2.preload !== false) {
              let s = n.split("/");
              e(I.parse(s[0]));
            }
            let o = await ti(n, t.blocks, i2);
            if (o.type === "directory")
              throw new Error("this dag node is a directory");
            if (!o.content)
              throw new Error("this dag node has no content");
            yield* o.content(i2);
          }
          return B(r);
        }
        c();
        var D0 = w(K(), 1);
        te();
        c();
        c();
        c();
        function Ar() {
          let t = {};
          return t.promise = new Promise((e, r) => {
            t.resolve = e, t.reject = r;
          }), t;
        }
        c();
        me();
        Re();
        var IZe = "0".charCodeAt(0), CZe = U("ustar\0", "binary"), PZe = U("ustar ", "binary"), DZe = U(" \0", "binary");
        c();
        c();
        function by(t) {
          let e = async function* () {
            let r = yield, n = new qe();
            for await (let i2 of t) {
              if (r == null) {
                n.append(i2), r = yield n, n = new qe();
                continue;
              }
              for (n.append(i2); n.length >= r; ) {
                let o = n.subarray(0, r);
                if (n.consume(r), r = yield o, r == null) {
                  n.length > 0 && (r = yield n, n = new qe());
                  break;
                }
              }
            }
            if (r != null)
              throw Object.assign(new Error(`stream ended before ${r} bytes became available`), { code: "ERR_UNDER_READ", buffer: n });
          }();
          return e.next(), e;
        }
        c();
        var AG = w(SG(), 1), TG = w(hA(), 1);
        c();
        Re();
        var wEe = "0000000000000000000", EEe = "7777777777777777777", bEe = "0".charCodeAt(0), _Ee = U("ustar\0", "binary"), vEe = U("00", "binary"), SEe = parseInt("7777", 8), xEe = 257, REe = 263, AEe = function(t) {
          switch (t) {
            case "file":
              return 0;
            case "link":
              return 1;
            case "symlink":
              return 2;
            case "character-device":
              return 3;
            case "block-device":
              return 4;
            case "directory":
              return 5;
            case "fifo":
              return 6;
            case "contiguous-file":
              return 7;
            case "pax-header":
              return 72;
            default:
              return 0;
          }
        }, TEe = function(t) {
          let e = 256;
          for (let r = 0; r < 148; r++)
            e += t[r];
          for (let r = 156; r < 512; r++)
            e += t[r];
          return e;
        }, El = function(t, e) {
          let r = t.toString(8);
          return r.length > e ? U(EEe.slice(0, e) + " ") : U(wEe.slice(0, e - r.length) + r + " ");
        }, dA = function(t) {
          let e = U(t).byteLength, r = Math.floor(Math.log(e) / Math.log(10)) + 1;
          return e + r >= Math.pow(10, r) && r++, `${e + r}${t}`;
        };
        function RG(t) {
          let e = "";
          t.name != null && (e += dA(" path=" + t.name + `
`)), t.linkname != null && (e += dA(" linkpath=" + t.linkname + `
`));
          let r = t.pax;
          if (r != null)
            for (let n in r)
              Object.prototype.hasOwnProperty.call(r, n) && (e += dA(" " + n + "=" + r[n] + `
`));
          return U(e);
        }
        function R5(t) {
          let e = new Uint8Array(512), r = t.name, n = "";
          if (t.typeflag === 5 && r[r.length - 1] !== "/" && (r += "/"), U(r).byteLength !== r.length)
            return null;
          for (; U(r).byteLength > 100; ) {
            let i2 = r.indexOf("/");
            if (i2 === -1)
              return null;
            n += n !== "" ? "/" + r.slice(0, i2) : r.slice(0, i2), r = r.slice(i2 + 1);
          }
          return U(r).byteLength > 100 || U(n).byteLength > 155 || t.linkname != null && U(t.linkname).byteLength > 100 ? null : (e.set(U(r), 0), e.set(El(t.mode & SEe, 6), 100), e.set(El(t.uid, 6), 108), e.set(El(t.gid, 6), 116), e.set(El(t.size, 11), 124), e.set(El(t.mtime.getTime() / 1e3 | 0, 11), 136), e[156] = bEe + AEe(t.type), t.linkname != null && e.set(U(t.linkname), 157), e.set(_Ee, xEe), e.set(vEe, REe), t.uname != null && e.set(U(t.uname), 265), t.gname != null && e.set(U(t.gname), 297), e.set(El(t.devmajor ?? 0, 6), 329), e.set(El(t.devminor ?? 0, 6), 337), n != null && e.set(U(n), 345), e.set(El(TEe(e), 6), 148), e);
        }
        Re();
        me();
        var { S_IFMT: CEe, S_IFBLK: PEe, S_IFCHR: DEe, S_IFDIR: kEe, S_IFIFO: NEe, S_IFLNK: OEe } = AG.default, LEe = parseInt("755", 8), BEe = parseInt("644", 8), IG = new Uint8Array(1024);
        function MEe(t = 0) {
          switch (t & CEe) {
            case PEe:
              return "block-device";
            case DEe:
              return "character-device";
            case kEe:
              return "directory";
            case NEe:
              return "fifo";
            case OEe:
              return "symlink";
            default:
              return "file";
          }
        }
        function mA(t) {
          return t &= 511, t !== 0 ? IG.slice(0, 512 - t) : new Uint8Array(0);
        }
        function pA(t) {
          if (t.pax == null) {
            let e = R5(t);
            if (e != null)
              return e;
          }
          return UEe(t);
        }
        function UEe(t) {
          let e = RG(t), r = { name: "PaxHeader", mode: t.mode, uid: t.uid, gid: t.gid, size: e.length, mtime: t.mtime, type: "pax-header", linkname: t.linkname, uname: t.uname, gname: t.gname, devmajor: t.devmajor, devminor: t.devminor };
          return new qe(R5(r) ?? new Uint8Array(0), e, mA(e.length), R5({ ...r, size: t.size, type: t.type }) ?? new Uint8Array(0)).slice();
        }
        function A5() {
          return async function* (t) {
            for await (let { header: e, body: r } of t) {
              let n = { ...e, size: e.type === "symlink" ? 0 : e.size ?? 0, type: e.type ?? MEe(e.mode), mode: e.mode ?? (e.type === "directory" ? LEe : BEe), uid: e.uid ?? 0, gid: e.gid ?? 0, mtime: e.mtime ?? new Date() };
              if (typeof r == "string" && (r = U(r)), r instanceof Uint8Array || tl(r)) {
                n.size = r.length, yield pA(n), yield tl(r) ? r.slice() : r, yield mA(n.size);
                continue;
              }
              if (n.type === "symlink" && n.linkname == null) {
                if (r == null)
                  throw new Error("type was symlink but no linkname or body specified");
                n.linkname = M(await (0, TG.default)(r)), yield pA(n);
                continue;
              }
              if (yield pA(n), n.type !== "file" && n.type !== "contiguous-file")
                continue;
              let i2 = 0;
              for await (let o of r ?? [])
                i2 += o.length, yield tl(o) ? o.slice() : o;
              if (i2 !== n.size)
                throw new Error(`size mismatch, wrote ${i2} of ${n.size} bytes`);
              yield mA(n.size);
            }
            yield IG;
          };
        }
        c();
        function C0(t) {
          let e = t.length;
          for (; --e >= 0; )
            t[e] = 0;
        }
        var FEe = 0, dW = 1, KEe = 2, VEe = 3, qEe = 258, OA = 29, Ly = 256, Ty = Ly + 1 + OA, I0 = 30, LA = 19, pW = 2 * Ty + 1, Rh = 15, yA = 16, zEe = 7, BA = 256, mW = 16, yW = 17, gW = 18, PA = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), k5 = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), HEe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), wW = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), $Ee = 512, Hc = new Array((Ty + 2) * 2);
        C0(Hc);
        var xy = new Array(I0 * 2);
        C0(xy);
        var Iy = new Array($Ee);
        C0(Iy);
        var Cy = new Array(qEe - VEe + 1);
        C0(Cy);
        var MA = new Array(OA);
        C0(MA);
        var B5 = new Array(I0);
        C0(B5);
        function gA(t, e, r, n, i2) {
          this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i2, this.has_stree = t && t.length;
        }
        var EW, bW, _W;
        function wA(t, e) {
          this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
        }
        var vW = (t) => t < 256 ? Iy[t] : Iy[256 + (t >>> 7)], Py = (t, e) => {
          t.pending_buf[t.pending++] = e & 255, t.pending_buf[t.pending++] = e >>> 8 & 255;
        }, ji = (t, e, r) => {
          t.bi_valid > yA - r ? (t.bi_buf |= e << t.bi_valid & 65535, Py(t, t.bi_buf), t.bi_buf = e >> yA - t.bi_valid, t.bi_valid += r - yA) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r);
        }, Ma = (t, e, r) => {
          ji(t, r[e * 2], r[e * 2 + 1]);
        }, SW = (t, e) => {
          let r = 0;
          do
            r |= t & 1, t >>>= 1, r <<= 1;
          while (--e > 0);
          return r >>> 1;
        }, GEe = (t) => {
          t.bi_valid === 16 ? (Py(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = t.bi_buf & 255, t.bi_buf >>= 8, t.bi_valid -= 8);
        }, WEe = (t, e) => {
          let r = e.dyn_tree, n = e.max_code, i2 = e.stat_desc.static_tree, o = e.stat_desc.has_stree, s = e.stat_desc.extra_bits, a = e.stat_desc.extra_base, u = e.stat_desc.max_length, l, f, h, p, d, m, y = 0;
          for (p = 0; p <= Rh; p++)
            t.bl_count[p] = 0;
          for (r[t.heap[t.heap_max] * 2 + 1] = 0, l = t.heap_max + 1; l < pW; l++)
            f = t.heap[l], p = r[r[f * 2 + 1] * 2 + 1] + 1, p > u && (p = u, y++), r[f * 2 + 1] = p, !(f > n) && (t.bl_count[p]++, d = 0, f >= a && (d = s[f - a]), m = r[f * 2], t.opt_len += m * (p + d), o && (t.static_len += m * (i2[f * 2 + 1] + d)));
          if (y !== 0) {
            do {
              for (p = u - 1; t.bl_count[p] === 0; )
                p--;
              t.bl_count[p]--, t.bl_count[p + 1] += 2, t.bl_count[u]--, y -= 2;
            } while (y > 0);
            for (p = u; p !== 0; p--)
              for (f = t.bl_count[p]; f !== 0; )
                h = t.heap[--l], !(h > n) && (r[h * 2 + 1] !== p && (t.opt_len += (p - r[h * 2 + 1]) * r[h * 2], r[h * 2 + 1] = p), f--);
          }
        }, xW = (t, e, r) => {
          let n = new Array(Rh + 1), i2 = 0, o, s;
          for (o = 1; o <= Rh; o++)
            n[o] = i2 = i2 + r[o - 1] << 1;
          for (s = 0; s <= e; s++) {
            let a = t[s * 2 + 1];
            a !== 0 && (t[s * 2] = SW(n[a]++, a));
          }
        }, jEe = () => {
          let t, e, r, n, i2, o = new Array(Rh + 1);
          for (r = 0, n = 0; n < OA - 1; n++)
            for (MA[n] = r, t = 0; t < 1 << PA[n]; t++)
              Cy[r++] = n;
          for (Cy[r - 1] = n, i2 = 0, n = 0; n < 16; n++)
            for (B5[n] = i2, t = 0; t < 1 << k5[n]; t++)
              Iy[i2++] = n;
          for (i2 >>= 7; n < I0; n++)
            for (B5[n] = i2 << 7, t = 0; t < 1 << k5[n] - 7; t++)
              Iy[256 + i2++] = n;
          for (e = 0; e <= Rh; e++)
            o[e] = 0;
          for (t = 0; t <= 143; )
            Hc[t * 2 + 1] = 8, t++, o[8]++;
          for (; t <= 255; )
            Hc[t * 2 + 1] = 9, t++, o[9]++;
          for (; t <= 279; )
            Hc[t * 2 + 1] = 7, t++, o[7]++;
          for (; t <= 287; )
            Hc[t * 2 + 1] = 8, t++, o[8]++;
          for (xW(Hc, Ty + 1, o), t = 0; t < I0; t++)
            xy[t * 2 + 1] = 5, xy[t * 2] = SW(t, 5);
          EW = new gA(Hc, PA, Ly + 1, Ty, Rh), bW = new gA(xy, k5, 0, I0, Rh), _W = new gA(new Array(0), HEe, 0, LA, zEe);
        }, RW = (t) => {
          let e;
          for (e = 0; e < Ty; e++)
            t.dyn_ltree[e * 2] = 0;
          for (e = 0; e < I0; e++)
            t.dyn_dtree[e * 2] = 0;
          for (e = 0; e < LA; e++)
            t.bl_tree[e * 2] = 0;
          t.dyn_ltree[BA * 2] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0;
        }, AW = (t) => {
          t.bi_valid > 8 ? Py(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
        }, YEe = (t, e, r, n) => {
          AW(t), n && (Py(t, r), Py(t, ~r)), t.pending_buf.set(t.window.subarray(e, e + r), t.pending), t.pending += r;
        }, CG = (t, e, r, n) => {
          let i2 = e * 2, o = r * 2;
          return t[i2] < t[o] || t[i2] === t[o] && n[e] <= n[r];
        }, EA = (t, e, r) => {
          let n = t.heap[r], i2 = r << 1;
          for (; i2 <= t.heap_len && (i2 < t.heap_len && CG(e, t.heap[i2 + 1], t.heap[i2], t.depth) && i2++, !CG(e, n, t.heap[i2], t.depth)); )
            t.heap[r] = t.heap[i2], r = i2, i2 <<= 1;
          t.heap[r] = n;
        }, PG = (t, e, r) => {
          let n, i2, o = 0, s, a;
          if (t.last_lit !== 0)
            do
              n = t.pending_buf[t.d_buf + o * 2] << 8 | t.pending_buf[t.d_buf + o * 2 + 1], i2 = t.pending_buf[t.l_buf + o], o++, n === 0 ? Ma(t, i2, e) : (s = Cy[i2], Ma(t, s + Ly + 1, e), a = PA[s], a !== 0 && (i2 -= MA[s], ji(t, i2, a)), n--, s = vW(n), Ma(t, s, r), a = k5[s], a !== 0 && (n -= B5[s], ji(t, n, a)));
            while (o < t.last_lit);
          Ma(t, BA, e);
        }, DA = (t, e) => {
          let r = e.dyn_tree, n = e.stat_desc.static_tree, i2 = e.stat_desc.has_stree, o = e.stat_desc.elems, s, a, u = -1, l;
          for (t.heap_len = 0, t.heap_max = pW, s = 0; s < o; s++)
            r[s * 2] !== 0 ? (t.heap[++t.heap_len] = u = s, t.depth[s] = 0) : r[s * 2 + 1] = 0;
          for (; t.heap_len < 2; )
            l = t.heap[++t.heap_len] = u < 2 ? ++u : 0, r[l * 2] = 1, t.depth[l] = 0, t.opt_len--, i2 && (t.static_len -= n[l * 2 + 1]);
          for (e.max_code = u, s = t.heap_len >> 1; s >= 1; s--)
            EA(t, r, s);
          l = o;
          do
            s = t.heap[1], t.heap[1] = t.heap[t.heap_len--], EA(t, r, 1), a = t.heap[1], t.heap[--t.heap_max] = s, t.heap[--t.heap_max] = a, r[l * 2] = r[s * 2] + r[a * 2], t.depth[l] = (t.depth[s] >= t.depth[a] ? t.depth[s] : t.depth[a]) + 1, r[s * 2 + 1] = r[a * 2 + 1] = l, t.heap[1] = l++, EA(t, r, 1);
          while (t.heap_len >= 2);
          t.heap[--t.heap_max] = t.heap[1], WEe(t, e), xW(r, u, t.bl_count);
        }, DG = (t, e, r) => {
          let n, i2 = -1, o, s = e[0 * 2 + 1], a = 0, u = 7, l = 4;
          for (s === 0 && (u = 138, l = 3), e[(r + 1) * 2 + 1] = 65535, n = 0; n <= r; n++)
            o = s, s = e[(n + 1) * 2 + 1], !(++a < u && o === s) && (a < l ? t.bl_tree[o * 2] += a : o !== 0 ? (o !== i2 && t.bl_tree[o * 2]++, t.bl_tree[mW * 2]++) : a <= 10 ? t.bl_tree[yW * 2]++ : t.bl_tree[gW * 2]++, a = 0, i2 = o, s === 0 ? (u = 138, l = 3) : o === s ? (u = 6, l = 3) : (u = 7, l = 4));
        }, kG = (t, e, r) => {
          let n, i2 = -1, o, s = e[0 * 2 + 1], a = 0, u = 7, l = 4;
          for (s === 0 && (u = 138, l = 3), n = 0; n <= r; n++)
            if (o = s, s = e[(n + 1) * 2 + 1], !(++a < u && o === s)) {
              if (a < l)
                do
                  Ma(t, o, t.bl_tree);
                while (--a !== 0);
              else
                o !== 0 ? (o !== i2 && (Ma(t, o, t.bl_tree), a--), Ma(t, mW, t.bl_tree), ji(t, a - 3, 2)) : a <= 10 ? (Ma(t, yW, t.bl_tree), ji(t, a - 3, 3)) : (Ma(t, gW, t.bl_tree), ji(t, a - 11, 7));
              a = 0, i2 = o, s === 0 ? (u = 138, l = 3) : o === s ? (u = 6, l = 3) : (u = 7, l = 4);
            }
        }, QEe = (t) => {
          let e;
          for (DG(t, t.dyn_ltree, t.l_desc.max_code), DG(t, t.dyn_dtree, t.d_desc.max_code), DA(t, t.bl_desc), e = LA - 1; e >= 3 && t.bl_tree[wW[e] * 2 + 1] === 0; e--)
            ;
          return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
        }, XEe = (t, e, r, n) => {
          let i2;
          for (ji(t, e - 257, 5), ji(t, r - 1, 5), ji(t, n - 4, 4), i2 = 0; i2 < n; i2++)
            ji(t, t.bl_tree[wW[i2] * 2 + 1], 3);
          kG(t, t.dyn_ltree, e - 1), kG(t, t.dyn_dtree, r - 1);
        }, ZEe = (t) => {
          let e = 4093624447, r;
          for (r = 0; r <= 31; r++, e >>>= 1)
            if (e & 1 && t.dyn_ltree[r * 2] !== 0)
              return 0;
          if (t.dyn_ltree[9 * 2] !== 0 || t.dyn_ltree[10 * 2] !== 0 || t.dyn_ltree[13 * 2] !== 0)
            return 1;
          for (r = 32; r < Ly; r++)
            if (t.dyn_ltree[r * 2] !== 0)
              return 1;
          return 0;
        }, NG = false, JEe = (t) => {
          NG || (jEe(), NG = true), t.l_desc = new wA(t.dyn_ltree, EW), t.d_desc = new wA(t.dyn_dtree, bW), t.bl_desc = new wA(t.bl_tree, _W), t.bi_buf = 0, t.bi_valid = 0, RW(t);
        }, TW = (t, e, r, n) => {
          ji(t, (FEe << 1) + (n ? 1 : 0), 3), YEe(t, e, r, true);
        }, ebe = (t) => {
          ji(t, dW << 1, 3), Ma(t, BA, Hc), GEe(t);
        }, tbe = (t, e, r, n) => {
          let i2, o, s = 0;
          t.level > 0 ? (t.strm.data_type === 2 && (t.strm.data_type = ZEe(t)), DA(t, t.l_desc), DA(t, t.d_desc), s = QEe(t), i2 = t.opt_len + 3 + 7 >>> 3, o = t.static_len + 3 + 7 >>> 3, o <= i2 && (i2 = o)) : i2 = o = r + 5, r + 4 <= i2 && e !== -1 ? TW(t, e, r, n) : t.strategy === 4 || o === i2 ? (ji(t, (dW << 1) + (n ? 1 : 0), 3), PG(t, Hc, xy)) : (ji(t, (KEe << 1) + (n ? 1 : 0), 3), XEe(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), PG(t, t.dyn_ltree, t.dyn_dtree)), RW(t), n && AW(t);
        }, rbe = (t, e, r) => (t.pending_buf[t.d_buf + t.last_lit * 2] = e >>> 8 & 255, t.pending_buf[t.d_buf + t.last_lit * 2 + 1] = e & 255, t.pending_buf[t.l_buf + t.last_lit] = r & 255, t.last_lit++, e === 0 ? t.dyn_ltree[r * 2]++ : (t.matches++, e--, t.dyn_ltree[(Cy[r] + Ly + 1) * 2]++, t.dyn_dtree[vW(e) * 2]++), t.last_lit === t.lit_bufsize - 1), nbe = JEe, ibe = TW, obe = tbe, sbe = rbe, abe = ebe, cbe = { _tr_init: nbe, _tr_stored_block: ibe, _tr_flush_block: obe, _tr_tally: sbe, _tr_align: abe }, ube = (t, e, r, n) => {
          let i2 = t & 65535 | 0, o = t >>> 16 & 65535 | 0, s = 0;
          for (; r !== 0; ) {
            s = r > 2e3 ? 2e3 : r, r -= s;
            do
              i2 = i2 + e[n++] | 0, o = o + i2 | 0;
            while (--s);
            i2 %= 65521, o %= 65521;
          }
          return i2 | o << 16 | 0;
        }, Dy = ube, lbe = () => {
          let t, e = [];
          for (var r = 0; r < 256; r++) {
            t = r;
            for (var n = 0; n < 8; n++)
              t = t & 1 ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[r] = t;
          }
          return e;
        }, fbe = new Uint32Array(lbe()), hbe = (t, e, r, n) => {
          let i2 = fbe, o = n + r;
          t ^= -1;
          for (let s = n; s < o; s++)
            t = t >>> 8 ^ i2[(t ^ e[s]) & 255];
          return t ^ -1;
        }, Hn = hbe, Th = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, Dh = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }, { _tr_init: dbe, _tr_stored_block: pbe, _tr_flush_block: mbe, _tr_tally: xl, _tr_align: ybe } = cbe, { Z_NO_FLUSH: kh, Z_PARTIAL_FLUSH: gbe, Z_FULL_FLUSH: wbe, Z_FINISH: Rl, Z_BLOCK: OG, Z_OK: Ua, Z_STREAM_END: LG, Z_STREAM_ERROR: ts, Z_DATA_ERROR: Ebe, Z_BUF_ERROR: bA, Z_DEFAULT_COMPRESSION: bbe, Z_FILTERED: _be, Z_HUFFMAN_ONLY: T5, Z_RLE: vbe, Z_FIXED: Sbe, Z_DEFAULT_STRATEGY: xbe, Z_UNKNOWN: Rbe, Z_DEFLATED: F5 } = Dh, Abe = 9, Tbe = 15, Ibe = 8, Cbe = 29, Pbe = 256, kA = Pbe + 1 + Cbe, Dbe = 30, kbe = 19, Nbe = 2 * kA + 1, Obe = 15, It = 3, vl = 258, Gs = vl + It + 1, Lbe = 32, K5 = 42, NA = 69, N5 = 73, O5 = 91, L5 = 103, Ah = 113, vy = 666, Cn = 1, By = 2, Ih = 3, P0 = 4, Bbe = 3, Sl = (t, e) => (t.msg = Th[e], e), BG = (t) => (t << 1) - (t > 4 ? 9 : 0), _l = (t) => {
          let e = t.length;
          for (; --e >= 0; )
            t[e] = 0;
        }, Mbe = (t, e, r) => (e << t.hash_shift ^ r) & t.hash_mask, Al = Mbe, bl = (t) => {
          let e = t.state, r = e.pending;
          r > t.avail_out && (r = t.avail_out), r !== 0 && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + r), t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, e.pending === 0 && (e.pending_out = 0));
        }, ri = (t, e) => {
          mbe(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, bl(t.strm);
        }, zt = (t, e) => {
          t.pending_buf[t.pending++] = e;
        }, _y = (t, e) => {
          t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = e & 255;
        }, Ube = (t, e, r, n) => {
          let i2 = t.avail_in;
          return i2 > n && (i2 = n), i2 === 0 ? 0 : (t.avail_in -= i2, e.set(t.input.subarray(t.next_in, t.next_in + i2), r), t.state.wrap === 1 ? t.adler = Dy(t.adler, e, i2, r) : t.state.wrap === 2 && (t.adler = Hn(t.adler, e, i2, r)), t.next_in += i2, t.total_in += i2, i2);
        }, IW = (t, e) => {
          let r = t.max_chain_length, n = t.strstart, i2, o, s = t.prev_length, a = t.nice_match, u = t.strstart > t.w_size - Gs ? t.strstart - (t.w_size - Gs) : 0, l = t.window, f = t.w_mask, h = t.prev, p = t.strstart + vl, d = l[n + s - 1], m = l[n + s];
          t.prev_length >= t.good_match && (r >>= 2), a > t.lookahead && (a = t.lookahead);
          do
            if (i2 = e, !(l[i2 + s] !== m || l[i2 + s - 1] !== d || l[i2] !== l[n] || l[++i2] !== l[n + 1])) {
              n += 2, i2++;
              do
                ;
              while (l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && l[++n] === l[++i2] && n < p);
              if (o = vl - (p - n), n = p - vl, o > s) {
                if (t.match_start = e, s = o, o >= a)
                  break;
                d = l[n + s - 1], m = l[n + s];
              }
            }
          while ((e = h[e & f]) > u && --r !== 0);
          return s <= t.lookahead ? s : t.lookahead;
        }, Ch = (t) => {
          let e = t.w_size, r, n, i2, o, s;
          do {
            if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - Gs)) {
              t.window.set(t.window.subarray(e, e + e), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, n = t.hash_size, r = n;
              do
                i2 = t.head[--r], t.head[r] = i2 >= e ? i2 - e : 0;
              while (--n);
              n = e, r = n;
              do
                i2 = t.prev[--r], t.prev[r] = i2 >= e ? i2 - e : 0;
              while (--n);
              o += e;
            }
            if (t.strm.avail_in === 0)
              break;
            if (n = Ube(t.strm, t.window, t.strstart + t.lookahead, o), t.lookahead += n, t.lookahead + t.insert >= It)
              for (s = t.strstart - t.insert, t.ins_h = t.window[s], t.ins_h = Al(t, t.ins_h, t.window[s + 1]); t.insert && (t.ins_h = Al(t, t.ins_h, t.window[s + It - 1]), t.prev[s & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = s, s++, t.insert--, !(t.lookahead + t.insert < It)); )
                ;
          } while (t.lookahead < Gs && t.strm.avail_in !== 0);
        }, Fbe = (t, e) => {
          let r = 65535;
          for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5); ; ) {
            if (t.lookahead <= 1) {
              if (Ch(t), t.lookahead === 0 && e === kh)
                return Cn;
              if (t.lookahead === 0)
                break;
            }
            t.strstart += t.lookahead, t.lookahead = 0;
            let n = t.block_start + r;
            if ((t.strstart === 0 || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, ri(t, false), t.strm.avail_out === 0) || t.strstart - t.block_start >= t.w_size - Gs && (ri(t, false), t.strm.avail_out === 0))
              return Cn;
          }
          return t.insert = 0, e === Rl ? (ri(t, true), t.strm.avail_out === 0 ? Ih : P0) : (t.strstart > t.block_start && (ri(t, false), t.strm.avail_out === 0), Cn);
        }, _A = (t, e) => {
          let r, n;
          for (; ; ) {
            if (t.lookahead < Gs) {
              if (Ch(t), t.lookahead < Gs && e === kh)
                return Cn;
              if (t.lookahead === 0)
                break;
            }
            if (r = 0, t.lookahead >= It && (t.ins_h = Al(t, t.ins_h, t.window[t.strstart + It - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), r !== 0 && t.strstart - r <= t.w_size - Gs && (t.match_length = IW(t, r)), t.match_length >= It)
              if (n = xl(t, t.strstart - t.match_start, t.match_length - It), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= It) {
                t.match_length--;
                do
                  t.strstart++, t.ins_h = Al(t, t.ins_h, t.window[t.strstart + It - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
                while (--t.match_length !== 0);
                t.strstart++;
              } else
                t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = Al(t, t.ins_h, t.window[t.strstart + 1]);
            else
              n = xl(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            if (n && (ri(t, false), t.strm.avail_out === 0))
              return Cn;
          }
          return t.insert = t.strstart < It - 1 ? t.strstart : It - 1, e === Rl ? (ri(t, true), t.strm.avail_out === 0 ? Ih : P0) : t.last_lit && (ri(t, false), t.strm.avail_out === 0) ? Cn : By;
        }, A0 = (t, e) => {
          let r, n, i2;
          for (; ; ) {
            if (t.lookahead < Gs) {
              if (Ch(t), t.lookahead < Gs && e === kh)
                return Cn;
              if (t.lookahead === 0)
                break;
            }
            if (r = 0, t.lookahead >= It && (t.ins_h = Al(t, t.ins_h, t.window[t.strstart + It - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = It - 1, r !== 0 && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - Gs && (t.match_length = IW(t, r), t.match_length <= 5 && (t.strategy === _be || t.match_length === It && t.strstart - t.match_start > 4096) && (t.match_length = It - 1)), t.prev_length >= It && t.match_length <= t.prev_length) {
              i2 = t.strstart + t.lookahead - It, n = xl(t, t.strstart - 1 - t.prev_match, t.prev_length - It), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
              do
                ++t.strstart <= i2 && (t.ins_h = Al(t, t.ins_h, t.window[t.strstart + It - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
              while (--t.prev_length !== 0);
              if (t.match_available = 0, t.match_length = It - 1, t.strstart++, n && (ri(t, false), t.strm.avail_out === 0))
                return Cn;
            } else if (t.match_available) {
              if (n = xl(t, 0, t.window[t.strstart - 1]), n && ri(t, false), t.strstart++, t.lookahead--, t.strm.avail_out === 0)
                return Cn;
            } else
              t.match_available = 1, t.strstart++, t.lookahead--;
          }
          return t.match_available && (n = xl(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < It - 1 ? t.strstart : It - 1, e === Rl ? (ri(t, true), t.strm.avail_out === 0 ? Ih : P0) : t.last_lit && (ri(t, false), t.strm.avail_out === 0) ? Cn : By;
        }, Kbe = (t, e) => {
          let r, n, i2, o, s = t.window;
          for (; ; ) {
            if (t.lookahead <= vl) {
              if (Ch(t), t.lookahead <= vl && e === kh)
                return Cn;
              if (t.lookahead === 0)
                break;
            }
            if (t.match_length = 0, t.lookahead >= It && t.strstart > 0 && (i2 = t.strstart - 1, n = s[i2], n === s[++i2] && n === s[++i2] && n === s[++i2])) {
              o = t.strstart + vl;
              do
                ;
              while (n === s[++i2] && n === s[++i2] && n === s[++i2] && n === s[++i2] && n === s[++i2] && n === s[++i2] && n === s[++i2] && n === s[++i2] && i2 < o);
              t.match_length = vl - (o - i2), t.match_length > t.lookahead && (t.match_length = t.lookahead);
            }
            if (t.match_length >= It ? (r = xl(t, 1, t.match_length - It), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = xl(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (ri(t, false), t.strm.avail_out === 0))
              return Cn;
          }
          return t.insert = 0, e === Rl ? (ri(t, true), t.strm.avail_out === 0 ? Ih : P0) : t.last_lit && (ri(t, false), t.strm.avail_out === 0) ? Cn : By;
        }, Vbe = (t, e) => {
          let r;
          for (; ; ) {
            if (t.lookahead === 0 && (Ch(t), t.lookahead === 0)) {
              if (e === kh)
                return Cn;
              break;
            }
            if (t.match_length = 0, r = xl(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (ri(t, false), t.strm.avail_out === 0))
              return Cn;
          }
          return t.insert = 0, e === Rl ? (ri(t, true), t.strm.avail_out === 0 ? Ih : P0) : t.last_lit && (ri(t, false), t.strm.avail_out === 0) ? Cn : By;
        };
        function Ba(t, e, r, n, i2) {
          this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i2;
        }
        var Sy = [new Ba(0, 0, 0, 0, Fbe), new Ba(4, 4, 8, 4, _A), new Ba(4, 5, 16, 8, _A), new Ba(4, 6, 32, 32, _A), new Ba(4, 4, 16, 16, A0), new Ba(8, 16, 32, 32, A0), new Ba(8, 16, 128, 128, A0), new Ba(8, 32, 128, 256, A0), new Ba(32, 128, 258, 1024, A0), new Ba(32, 258, 258, 4096, A0)], qbe = (t) => {
          t.window_size = 2 * t.w_size, _l(t.head), t.max_lazy_match = Sy[t.level].max_lazy, t.good_match = Sy[t.level].good_length, t.nice_match = Sy[t.level].nice_length, t.max_chain_length = Sy[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = It - 1, t.match_available = 0, t.ins_h = 0;
        };
        function zbe() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = F5, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(Nbe * 2), this.dyn_dtree = new Uint16Array((2 * Dbe + 1) * 2), this.bl_tree = new Uint16Array((2 * kbe + 1) * 2), _l(this.dyn_ltree), _l(this.dyn_dtree), _l(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(Obe + 1), this.heap = new Uint16Array(2 * kA + 1), _l(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(2 * kA + 1), _l(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        var CW = (t) => {
          if (!t || !t.state)
            return Sl(t, ts);
          t.total_in = t.total_out = 0, t.data_type = Rbe;
          let e = t.state;
          return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? K5 : Ah, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = kh, dbe(e), Ua;
        }, PW = (t) => {
          let e = CW(t);
          return e === Ua && qbe(t.state), e;
        }, Hbe = (t, e) => !t || !t.state || t.state.wrap !== 2 ? ts : (t.state.gzhead = e, Ua), DW = (t, e, r, n, i2, o) => {
          if (!t)
            return ts;
          let s = 1;
          if (e === bbe && (e = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), i2 < 1 || i2 > Abe || r !== F5 || n < 8 || n > 15 || e < 0 || e > 9 || o < 0 || o > Sbe)
            return Sl(t, ts);
          n === 8 && (n = 9);
          let a = new zbe();
          return t.state = a, a.strm = t, a.wrap = s, a.gzhead = null, a.w_bits = n, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = i2 + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + It - 1) / It), a.window = new Uint8Array(a.w_size * 2), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << i2 + 6, a.pending_buf_size = a.lit_bufsize * 4, a.pending_buf = new Uint8Array(a.pending_buf_size), a.d_buf = 1 * a.lit_bufsize, a.l_buf = (1 + 2) * a.lit_bufsize, a.level = e, a.strategy = o, a.method = r, PW(t);
        }, $be = (t, e) => DW(t, e, F5, Tbe, Ibe, xbe), Gbe = (t, e) => {
          let r, n;
          if (!t || !t.state || e > OG || e < 0)
            return t ? Sl(t, ts) : ts;
          let i2 = t.state;
          if (!t.output || !t.input && t.avail_in !== 0 || i2.status === vy && e !== Rl)
            return Sl(t, t.avail_out === 0 ? bA : ts);
          i2.strm = t;
          let o = i2.last_flush;
          if (i2.last_flush = e, i2.status === K5)
            if (i2.wrap === 2)
              t.adler = 0, zt(i2, 31), zt(i2, 139), zt(i2, 8), i2.gzhead ? (zt(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), zt(i2, i2.gzhead.time & 255), zt(i2, i2.gzhead.time >> 8 & 255), zt(i2, i2.gzhead.time >> 16 & 255), zt(i2, i2.gzhead.time >> 24 & 255), zt(i2, i2.level === 9 ? 2 : i2.strategy >= T5 || i2.level < 2 ? 4 : 0), zt(i2, i2.gzhead.os & 255), i2.gzhead.extra && i2.gzhead.extra.length && (zt(i2, i2.gzhead.extra.length & 255), zt(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = NA) : (zt(i2, 0), zt(i2, 0), zt(i2, 0), zt(i2, 0), zt(i2, 0), zt(i2, i2.level === 9 ? 2 : i2.strategy >= T5 || i2.level < 2 ? 4 : 0), zt(i2, Bbe), i2.status = Ah);
            else {
              let s = F5 + (i2.w_bits - 8 << 4) << 8, a = -1;
              i2.strategy >= T5 || i2.level < 2 ? a = 0 : i2.level < 6 ? a = 1 : i2.level === 6 ? a = 2 : a = 3, s |= a << 6, i2.strstart !== 0 && (s |= Lbe), s += 31 - s % 31, i2.status = Ah, _y(i2, s), i2.strstart !== 0 && (_y(i2, t.adler >>> 16), _y(i2, t.adler & 65535)), t.adler = 1;
            }
          if (i2.status === NA)
            if (i2.gzhead.extra) {
              for (r = i2.pending; i2.gzindex < (i2.gzhead.extra.length & 65535) && !(i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), bl(t), r = i2.pending, i2.pending === i2.pending_buf_size)); )
                zt(i2, i2.gzhead.extra[i2.gzindex] & 255), i2.gzindex++;
              i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = N5);
            } else
              i2.status = N5;
          if (i2.status === N5)
            if (i2.gzhead.name) {
              r = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), bl(t), r = i2.pending, i2.pending === i2.pending_buf_size)) {
                  n = 1;
                  break;
                }
                i2.gzindex < i2.gzhead.name.length ? n = i2.gzhead.name.charCodeAt(i2.gzindex++) & 255 : n = 0, zt(i2, n);
              } while (n !== 0);
              i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), n === 0 && (i2.gzindex = 0, i2.status = O5);
            } else
              i2.status = O5;
          if (i2.status === O5)
            if (i2.gzhead.comment) {
              r = i2.pending;
              do {
                if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), bl(t), r = i2.pending, i2.pending === i2.pending_buf_size)) {
                  n = 1;
                  break;
                }
                i2.gzindex < i2.gzhead.comment.length ? n = i2.gzhead.comment.charCodeAt(i2.gzindex++) & 255 : n = 0, zt(i2, n);
              } while (n !== 0);
              i2.gzhead.hcrc && i2.pending > r && (t.adler = Hn(t.adler, i2.pending_buf, i2.pending - r, r)), n === 0 && (i2.status = L5);
            } else
              i2.status = L5;
          if (i2.status === L5 && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && bl(t), i2.pending + 2 <= i2.pending_buf_size && (zt(i2, t.adler & 255), zt(i2, t.adler >> 8 & 255), t.adler = 0, i2.status = Ah)) : i2.status = Ah), i2.pending !== 0) {
            if (bl(t), t.avail_out === 0)
              return i2.last_flush = -1, Ua;
          } else if (t.avail_in === 0 && BG(e) <= BG(o) && e !== Rl)
            return Sl(t, bA);
          if (i2.status === vy && t.avail_in !== 0)
            return Sl(t, bA);
          if (t.avail_in !== 0 || i2.lookahead !== 0 || e !== kh && i2.status !== vy) {
            let s = i2.strategy === T5 ? Vbe(i2, e) : i2.strategy === vbe ? Kbe(i2, e) : Sy[i2.level].func(i2, e);
            if ((s === Ih || s === P0) && (i2.status = vy), s === Cn || s === Ih)
              return t.avail_out === 0 && (i2.last_flush = -1), Ua;
            if (s === By && (e === gbe ? ybe(i2) : e !== OG && (pbe(i2, 0, 0, false), e === wbe && (_l(i2.head), i2.lookahead === 0 && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), bl(t), t.avail_out === 0))
              return i2.last_flush = -1, Ua;
          }
          return e !== Rl ? Ua : i2.wrap <= 0 ? LG : (i2.wrap === 2 ? (zt(i2, t.adler & 255), zt(i2, t.adler >> 8 & 255), zt(i2, t.adler >> 16 & 255), zt(i2, t.adler >> 24 & 255), zt(i2, t.total_in & 255), zt(i2, t.total_in >> 8 & 255), zt(i2, t.total_in >> 16 & 255), zt(i2, t.total_in >> 24 & 255)) : (_y(i2, t.adler >>> 16), _y(i2, t.adler & 65535)), bl(t), i2.wrap > 0 && (i2.wrap = -i2.wrap), i2.pending !== 0 ? Ua : LG);
        }, Wbe = (t) => {
          if (!t || !t.state)
            return ts;
          let e = t.state.status;
          return e !== K5 && e !== NA && e !== N5 && e !== O5 && e !== L5 && e !== Ah && e !== vy ? Sl(t, ts) : (t.state = null, e === Ah ? Sl(t, Ebe) : Ua);
        }, jbe = (t, e) => {
          let r = e.length;
          if (!t || !t.state)
            return ts;
          let n = t.state, i2 = n.wrap;
          if (i2 === 2 || i2 === 1 && n.status !== K5 || n.lookahead)
            return ts;
          if (i2 === 1 && (t.adler = Dy(t.adler, e, r, 0)), n.wrap = 0, r >= n.w_size) {
            i2 === 0 && (_l(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0);
            let u = new Uint8Array(n.w_size);
            u.set(e.subarray(r - n.w_size, r), 0), e = u, r = n.w_size;
          }
          let o = t.avail_in, s = t.next_in, a = t.input;
          for (t.avail_in = r, t.next_in = 0, t.input = e, Ch(n); n.lookahead >= It; ) {
            let u = n.strstart, l = n.lookahead - (It - 1);
            do
              n.ins_h = Al(n, n.ins_h, n.window[u + It - 1]), n.prev[u & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = u, u++;
            while (--l);
            n.strstart = u, n.lookahead = It - 1, Ch(n);
          }
          return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = It - 1, n.match_available = 0, t.next_in = s, t.input = a, t.avail_in = o, n.wrap = i2, Ua;
        }, Ybe = $be, Qbe = DW, Xbe = PW, Zbe = CW, Jbe = Hbe, e_e = Gbe, t_e = Wbe, r_e = jbe, n_e = "pako deflate (from Nodeca project)", Ry = { deflateInit: Ybe, deflateInit2: Qbe, deflateReset: Xbe, deflateResetKeep: Zbe, deflateSetHeader: Jbe, deflate: e_e, deflateEnd: t_e, deflateSetDictionary: r_e, deflateInfo: n_e }, i_e = (t, e) => Object.prototype.hasOwnProperty.call(t, e), o_e = function(t) {
          let e = Array.prototype.slice.call(arguments, 1);
          for (; e.length; ) {
            let r = e.shift();
            if (!!r) {
              if (typeof r != "object")
                throw new TypeError(r + "must be non-object");
              for (let n in r)
                i_e(r, n) && (t[n] = r[n]);
            }
          }
          return t;
        }, s_e = (t) => {
          let e = 0;
          for (let n = 0, i2 = t.length; n < i2; n++)
            e += t[n].length;
          let r = new Uint8Array(e);
          for (let n = 0, i2 = 0, o = t.length; n < o; n++) {
            let s = t[n];
            r.set(s, i2), i2 += s.length;
          }
          return r;
        }, V5 = { assign: o_e, flattenChunks: s_e }, kW = true;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          kW = false;
        }
        var ky = new Uint8Array(256);
        for (let t = 0; t < 256; t++)
          ky[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
        ky[254] = ky[254] = 1;
        var a_e = (t) => {
          if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
            return new TextEncoder().encode(t);
          let e, r, n, i2, o, s = t.length, a = 0;
          for (i2 = 0; i2 < s; i2++)
            r = t.charCodeAt(i2), (r & 64512) === 55296 && i2 + 1 < s && (n = t.charCodeAt(i2 + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i2++)), a += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4;
          for (e = new Uint8Array(a), o = 0, i2 = 0; o < a; i2++)
            r = t.charCodeAt(i2), (r & 64512) === 55296 && i2 + 1 < s && (n = t.charCodeAt(i2 + 1), (n & 64512) === 56320 && (r = 65536 + (r - 55296 << 10) + (n - 56320), i2++)), r < 128 ? e[o++] = r : r < 2048 ? (e[o++] = 192 | r >>> 6, e[o++] = 128 | r & 63) : r < 65536 ? (e[o++] = 224 | r >>> 12, e[o++] = 128 | r >>> 6 & 63, e[o++] = 128 | r & 63) : (e[o++] = 240 | r >>> 18, e[o++] = 128 | r >>> 12 & 63, e[o++] = 128 | r >>> 6 & 63, e[o++] = 128 | r & 63);
          return e;
        }, c_e = (t, e) => {
          if (e < 65534 && t.subarray && kW)
            return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
          let r = "";
          for (let n = 0; n < e; n++)
            r += String.fromCharCode(t[n]);
          return r;
        }, u_e = (t, e) => {
          let r = e || t.length;
          if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
            return new TextDecoder().decode(t.subarray(0, e));
          let n, i2, o = new Array(r * 2);
          for (i2 = 0, n = 0; n < r; ) {
            let s = t[n++];
            if (s < 128) {
              o[i2++] = s;
              continue;
            }
            let a = ky[s];
            if (a > 4) {
              o[i2++] = 65533, n += a - 1;
              continue;
            }
            for (s &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && n < r; )
              s = s << 6 | t[n++] & 63, a--;
            if (a > 1) {
              o[i2++] = 65533;
              continue;
            }
            s < 65536 ? o[i2++] = s : (s -= 65536, o[i2++] = 55296 | s >> 10 & 1023, o[i2++] = 56320 | s & 1023);
          }
          return c_e(o, i2);
        }, l_e = (t, e) => {
          e = e || t.length, e > t.length && (e = t.length);
          let r = e - 1;
          for (; r >= 0 && (t[r] & 192) === 128; )
            r--;
          return r < 0 || r === 0 ? e : r + ky[t[r]] > e ? r : e;
        }, Ny = { string2buf: a_e, buf2string: u_e, utf8border: l_e };
        function f_e() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        var NW = f_e, OW = Object.prototype.toString, { Z_NO_FLUSH: h_e, Z_SYNC_FLUSH: d_e, Z_FULL_FLUSH: p_e, Z_FINISH: m_e, Z_OK: M5, Z_STREAM_END: y_e, Z_DEFAULT_COMPRESSION: g_e, Z_DEFAULT_STRATEGY: w_e, Z_DEFLATED: E_e } = Dh;
        function My(t) {
          this.options = V5.assign({ level: g_e, method: E_e, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: w_e }, t || {});
          let e = this.options;
          e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new NW(), this.strm.avail_out = 0;
          let r = Ry.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
          if (r !== M5)
            throw new Error(Th[r]);
          if (e.header && Ry.deflateSetHeader(this.strm, e.header), e.dictionary) {
            let n;
            if (typeof e.dictionary == "string" ? n = Ny.string2buf(e.dictionary) : OW.call(e.dictionary) === "[object ArrayBuffer]" ? n = new Uint8Array(e.dictionary) : n = e.dictionary, r = Ry.deflateSetDictionary(this.strm, n), r !== M5)
              throw new Error(Th[r]);
            this._dict_set = true;
          }
        }
        My.prototype.push = function(t, e) {
          let r = this.strm, n = this.options.chunkSize, i2, o;
          if (this.ended)
            return false;
          for (e === ~~e ? o = e : o = e === true ? m_e : h_e, typeof t == "string" ? r.input = Ny.string2buf(t) : OW.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length; ; ) {
            if (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), (o === d_e || o === p_e) && r.avail_out <= 6) {
              this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
              continue;
            }
            if (i2 = Ry.deflate(r, o), i2 === y_e)
              return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), i2 = Ry.deflateEnd(this.strm), this.onEnd(i2), this.ended = true, i2 === M5;
            if (r.avail_out === 0) {
              this.onData(r.output);
              continue;
            }
            if (o > 0 && r.next_out > 0) {
              this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0;
              continue;
            }
            if (r.avail_in === 0)
              break;
          }
          return true;
        };
        My.prototype.onData = function(t) {
          this.chunks.push(t);
        };
        My.prototype.onEnd = function(t) {
          t === M5 && (this.result = V5.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
        };
        function UA(t, e) {
          let r = new My(e);
          if (r.push(t, true), r.err)
            throw r.msg || Th[r.err];
          return r.result;
        }
        function b_e(t, e) {
          return e = e || {}, e.raw = true, UA(t, e);
        }
        function __e(t, e) {
          return e = e || {}, e.gzip = true, UA(t, e);
        }
        var v_e = My, S_e = UA, x_e = b_e, R_e = __e, A_e = Dh, T_e = { Deflate: v_e, deflate: S_e, deflateRaw: x_e, gzip: R_e, constants: A_e }, I5 = 30, I_e = 12, C_e = function(e, r) {
          let n, i2, o, s, a, u, l, f, h, p, d, m, y, g, E, b, v, S, x, T, R, O, F, z, W = e.state;
          n = e.next_in, F = e.input, i2 = n + (e.avail_in - 5), o = e.next_out, z = e.output, s = o - (r - e.avail_out), a = o + (e.avail_out - 257), u = W.dmax, l = W.wsize, f = W.whave, h = W.wnext, p = W.window, d = W.hold, m = W.bits, y = W.lencode, g = W.distcode, E = (1 << W.lenbits) - 1, b = (1 << W.distbits) - 1;
          e:
            do {
              m < 15 && (d += F[n++] << m, m += 8, d += F[n++] << m, m += 8), v = y[d & E];
              t:
                for (; ; ) {
                  if (S = v >>> 24, d >>>= S, m -= S, S = v >>> 16 & 255, S === 0)
                    z[o++] = v & 65535;
                  else if (S & 16) {
                    x = v & 65535, S &= 15, S && (m < S && (d += F[n++] << m, m += 8), x += d & (1 << S) - 1, d >>>= S, m -= S), m < 15 && (d += F[n++] << m, m += 8, d += F[n++] << m, m += 8), v = g[d & b];
                    r:
                      for (; ; ) {
                        if (S = v >>> 24, d >>>= S, m -= S, S = v >>> 16 & 255, S & 16) {
                          if (T = v & 65535, S &= 15, m < S && (d += F[n++] << m, m += 8, m < S && (d += F[n++] << m, m += 8)), T += d & (1 << S) - 1, T > u) {
                            e.msg = "invalid distance too far back", W.mode = I5;
                            break e;
                          }
                          if (d >>>= S, m -= S, S = o - s, T > S) {
                            if (S = T - S, S > f && W.sane) {
                              e.msg = "invalid distance too far back", W.mode = I5;
                              break e;
                            }
                            if (R = 0, O = p, h === 0) {
                              if (R += l - S, S < x) {
                                x -= S;
                                do
                                  z[o++] = p[R++];
                                while (--S);
                                R = o - T, O = z;
                              }
                            } else if (h < S) {
                              if (R += l + h - S, S -= h, S < x) {
                                x -= S;
                                do
                                  z[o++] = p[R++];
                                while (--S);
                                if (R = 0, h < x) {
                                  S = h, x -= S;
                                  do
                                    z[o++] = p[R++];
                                  while (--S);
                                  R = o - T, O = z;
                                }
                              }
                            } else if (R += h - S, S < x) {
                              x -= S;
                              do
                                z[o++] = p[R++];
                              while (--S);
                              R = o - T, O = z;
                            }
                            for (; x > 2; )
                              z[o++] = O[R++], z[o++] = O[R++], z[o++] = O[R++], x -= 3;
                            x && (z[o++] = O[R++], x > 1 && (z[o++] = O[R++]));
                          } else {
                            R = o - T;
                            do
                              z[o++] = z[R++], z[o++] = z[R++], z[o++] = z[R++], x -= 3;
                            while (x > 2);
                            x && (z[o++] = z[R++], x > 1 && (z[o++] = z[R++]));
                          }
                        } else if ((S & 64) === 0) {
                          v = g[(v & 65535) + (d & (1 << S) - 1)];
                          continue r;
                        } else {
                          e.msg = "invalid distance code", W.mode = I5;
                          break e;
                        }
                        break;
                      }
                  } else if ((S & 64) === 0) {
                    v = y[(v & 65535) + (d & (1 << S) - 1)];
                    continue t;
                  } else if (S & 32) {
                    W.mode = I_e;
                    break e;
                  } else {
                    e.msg = "invalid literal/length code", W.mode = I5;
                    break e;
                  }
                  break;
                }
            } while (n < i2 && o < a);
          x = m >> 3, n -= x, m -= x << 3, d &= (1 << m) - 1, e.next_in = n, e.next_out = o, e.avail_in = n < i2 ? 5 + (i2 - n) : 5 - (n - i2), e.avail_out = o < a ? 257 + (a - o) : 257 - (o - a), W.hold = d, W.bits = m;
        }, T0 = 15, MG = 852, UG = 592, FG = 0, vA = 1, KG = 2, P_e = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), D_e = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), k_e = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), N_e = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]), O_e = (t, e, r, n, i2, o, s, a) => {
          let u = a.bits, l = 0, f = 0, h = 0, p = 0, d = 0, m = 0, y = 0, g = 0, E = 0, b = 0, v, S, x, T, R, O = null, F = 0, z, W = new Uint16Array(T0 + 1), se = new Uint16Array(T0 + 1), re2 = null, Ge = 0, ge, ke, H;
          for (l = 0; l <= T0; l++)
            W[l] = 0;
          for (f = 0; f < n; f++)
            W[e[r + f]]++;
          for (d = u, p = T0; p >= 1 && W[p] === 0; p--)
            ;
          if (d > p && (d = p), p === 0)
            return i2[o++] = 1 << 24 | 64 << 16 | 0, i2[o++] = 1 << 24 | 64 << 16 | 0, a.bits = 1, 0;
          for (h = 1; h < p && W[h] === 0; h++)
            ;
          for (d < h && (d = h), g = 1, l = 1; l <= T0; l++)
            if (g <<= 1, g -= W[l], g < 0)
              return -1;
          if (g > 0 && (t === FG || p !== 1))
            return -1;
          for (se[1] = 0, l = 1; l < T0; l++)
            se[l + 1] = se[l] + W[l];
          for (f = 0; f < n; f++)
            e[r + f] !== 0 && (s[se[e[r + f]]++] = f);
          if (t === FG ? (O = re2 = s, z = 19) : t === vA ? (O = P_e, F -= 257, re2 = D_e, Ge -= 257, z = 256) : (O = k_e, re2 = N_e, z = -1), b = 0, f = 0, l = h, R = o, m = d, y = 0, x = -1, E = 1 << d, T = E - 1, t === vA && E > MG || t === KG && E > UG)
            return 1;
          for (; ; ) {
            ge = l - y, s[f] < z ? (ke = 0, H = s[f]) : s[f] > z ? (ke = re2[Ge + s[f]], H = O[F + s[f]]) : (ke = 32 + 64, H = 0), v = 1 << l - y, S = 1 << m, h = S;
            do
              S -= v, i2[R + (b >> y) + S] = ge << 24 | ke << 16 | H | 0;
            while (S !== 0);
            for (v = 1 << l - 1; b & v; )
              v >>= 1;
            if (v !== 0 ? (b &= v - 1, b += v) : b = 0, f++, --W[l] === 0) {
              if (l === p)
                break;
              l = e[r + s[f]];
            }
            if (l > d && (b & T) !== x) {
              for (y === 0 && (y = d), R += h, m = l - y, g = 1 << m; m + y < p && (g -= W[m + y], !(g <= 0)); )
                m++, g <<= 1;
              if (E += 1 << m, t === vA && E > MG || t === KG && E > UG)
                return 1;
              x = b & T, i2[x] = d << 24 | m << 16 | R - o | 0;
            }
          }
          return b !== 0 && (i2[R + b] = l - y << 24 | 64 << 16 | 0), a.bits = d, 0;
        }, Ay = O_e, L_e = 0, LW = 1, BW = 2, { Z_FINISH: VG, Z_BLOCK: B_e, Z_TREES: C5, Z_OK: Ph, Z_STREAM_END: M_e, Z_NEED_DICT: U_e, Z_STREAM_ERROR: rs, Z_DATA_ERROR: MW, Z_MEM_ERROR: UW, Z_BUF_ERROR: F_e, Z_DEFLATED: qG } = Dh, FW = 1, zG = 2, HG = 3, $G = 4, GG = 5, WG = 6, jG = 7, YG = 8, QG = 9, XG = 10, U5 = 11, zc = 12, SA = 13, ZG = 14, xA = 15, JG = 16, eW = 17, tW = 18, rW = 19, P5 = 20, D5 = 21, nW = 22, iW = 23, oW = 24, sW = 25, aW = 26, RA = 27, cW = 28, uW = 29, Or = 30, KW = 31, K_e = 32, V_e = 852, q_e = 592, z_e = 15, H_e = z_e, lW = (t) => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((t & 65280) << 8) + ((t & 255) << 24);
        function $_e() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        var VW = (t) => {
          if (!t || !t.state)
            return rs;
          let e = t.state;
          return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = e.wrap & 1), e.mode = FW, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(V_e), e.distcode = e.distdyn = new Int32Array(q_e), e.sane = 1, e.back = -1, Ph;
        }, qW = (t) => {
          if (!t || !t.state)
            return rs;
          let e = t.state;
          return e.wsize = 0, e.whave = 0, e.wnext = 0, VW(t);
        }, zW = (t, e) => {
          let r;
          if (!t || !t.state)
            return rs;
          let n = t.state;
          return e < 0 ? (r = 0, e = -e) : (r = (e >> 4) + 1, e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? rs : (n.window !== null && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, qW(t));
        }, HW = (t, e) => {
          if (!t)
            return rs;
          let r = new $_e();
          t.state = r, r.window = null;
          let n = zW(t, e);
          return n !== Ph && (t.state = null), n;
        }, G_e = (t) => HW(t, H_e), fW = true, AA, TA, W_e = (t) => {
          if (fW) {
            AA = new Int32Array(512), TA = new Int32Array(32);
            let e = 0;
            for (; e < 144; )
              t.lens[e++] = 8;
            for (; e < 256; )
              t.lens[e++] = 9;
            for (; e < 280; )
              t.lens[e++] = 7;
            for (; e < 288; )
              t.lens[e++] = 8;
            for (Ay(LW, t.lens, 0, 288, AA, 0, t.work, { bits: 9 }), e = 0; e < 32; )
              t.lens[e++] = 5;
            Ay(BW, t.lens, 0, 32, TA, 0, t.work, { bits: 5 }), fW = false;
          }
          t.lencode = AA, t.lenbits = 9, t.distcode = TA, t.distbits = 5;
        }, $W = (t, e, r, n) => {
          let i2, o = t.state;
          return o.window === null && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), n >= o.wsize ? (o.window.set(e.subarray(r - o.wsize, r), 0), o.wnext = 0, o.whave = o.wsize) : (i2 = o.wsize - o.wnext, i2 > n && (i2 = n), o.window.set(e.subarray(r - n, r - n + i2), o.wnext), n -= i2, n ? (o.window.set(e.subarray(r - n, r), 0), o.wnext = n, o.whave = o.wsize) : (o.wnext += i2, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += i2))), 0;
        }, j_e = (t, e) => {
          let r, n, i2, o, s, a, u, l, f, h, p, d, m, y, g = 0, E, b, v, S, x, T, R, O, F = new Uint8Array(4), z, W, se = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
          if (!t || !t.state || !t.output || !t.input && t.avail_in !== 0)
            return rs;
          r = t.state, r.mode === zc && (r.mode = SA), s = t.next_out, i2 = t.output, u = t.avail_out, o = t.next_in, n = t.input, a = t.avail_in, l = r.hold, f = r.bits, h = a, p = u, O = Ph;
          e:
            for (; ; )
              switch (r.mode) {
                case FW:
                  if (r.wrap === 0) {
                    r.mode = SA;
                    break;
                  }
                  for (; f < 16; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if (r.wrap & 2 && l === 35615) {
                    r.check = 0, F[0] = l & 255, F[1] = l >>> 8 & 255, r.check = Hn(r.check, F, 2, 0), l = 0, f = 0, r.mode = zG;
                    break;
                  }
                  if (r.flags = 0, r.head && (r.head.done = false), !(r.wrap & 1) || (((l & 255) << 8) + (l >> 8)) % 31) {
                    t.msg = "incorrect header check", r.mode = Or;
                    break;
                  }
                  if ((l & 15) !== qG) {
                    t.msg = "unknown compression method", r.mode = Or;
                    break;
                  }
                  if (l >>>= 4, f -= 4, R = (l & 15) + 8, r.wbits === 0)
                    r.wbits = R;
                  else if (R > r.wbits) {
                    t.msg = "invalid window size", r.mode = Or;
                    break;
                  }
                  r.dmax = 1 << r.wbits, t.adler = r.check = 1, r.mode = l & 512 ? XG : zc, l = 0, f = 0;
                  break;
                case zG:
                  for (; f < 16; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if (r.flags = l, (r.flags & 255) !== qG) {
                    t.msg = "unknown compression method", r.mode = Or;
                    break;
                  }
                  if (r.flags & 57344) {
                    t.msg = "unknown header flags set", r.mode = Or;
                    break;
                  }
                  r.head && (r.head.text = l >> 8 & 1), r.flags & 512 && (F[0] = l & 255, F[1] = l >>> 8 & 255, r.check = Hn(r.check, F, 2, 0)), l = 0, f = 0, r.mode = HG;
                case HG:
                  for (; f < 32; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  r.head && (r.head.time = l), r.flags & 512 && (F[0] = l & 255, F[1] = l >>> 8 & 255, F[2] = l >>> 16 & 255, F[3] = l >>> 24 & 255, r.check = Hn(r.check, F, 4, 0)), l = 0, f = 0, r.mode = $G;
                case $G:
                  for (; f < 16; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  r.head && (r.head.xflags = l & 255, r.head.os = l >> 8), r.flags & 512 && (F[0] = l & 255, F[1] = l >>> 8 & 255, r.check = Hn(r.check, F, 2, 0)), l = 0, f = 0, r.mode = GG;
                case GG:
                  if (r.flags & 1024) {
                    for (; f < 16; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    r.length = l, r.head && (r.head.extra_len = l), r.flags & 512 && (F[0] = l & 255, F[1] = l >>> 8 & 255, r.check = Hn(r.check, F, 2, 0)), l = 0, f = 0;
                  } else
                    r.head && (r.head.extra = null);
                  r.mode = WG;
                case WG:
                  if (r.flags & 1024 && (d = r.length, d > a && (d = a), d && (r.head && (R = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(n.subarray(o, o + d), R)), r.flags & 512 && (r.check = Hn(r.check, n, d, o)), a -= d, o += d, r.length -= d), r.length))
                    break e;
                  r.length = 0, r.mode = jG;
                case jG:
                  if (r.flags & 2048) {
                    if (a === 0)
                      break e;
                    d = 0;
                    do
                      R = n[o + d++], r.head && R && r.length < 65536 && (r.head.name += String.fromCharCode(R));
                    while (R && d < a);
                    if (r.flags & 512 && (r.check = Hn(r.check, n, d, o)), a -= d, o += d, R)
                      break e;
                  } else
                    r.head && (r.head.name = null);
                  r.length = 0, r.mode = YG;
                case YG:
                  if (r.flags & 4096) {
                    if (a === 0)
                      break e;
                    d = 0;
                    do
                      R = n[o + d++], r.head && R && r.length < 65536 && (r.head.comment += String.fromCharCode(R));
                    while (R && d < a);
                    if (r.flags & 512 && (r.check = Hn(r.check, n, d, o)), a -= d, o += d, R)
                      break e;
                  } else
                    r.head && (r.head.comment = null);
                  r.mode = QG;
                case QG:
                  if (r.flags & 512) {
                    for (; f < 16; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    if (l !== (r.check & 65535)) {
                      t.msg = "header crc mismatch", r.mode = Or;
                      break;
                    }
                    l = 0, f = 0;
                  }
                  r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = true), t.adler = r.check = 0, r.mode = zc;
                  break;
                case XG:
                  for (; f < 32; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  t.adler = r.check = lW(l), l = 0, f = 0, r.mode = U5;
                case U5:
                  if (r.havedict === 0)
                    return t.next_out = s, t.avail_out = u, t.next_in = o, t.avail_in = a, r.hold = l, r.bits = f, U_e;
                  t.adler = r.check = 1, r.mode = zc;
                case zc:
                  if (e === B_e || e === C5)
                    break e;
                case SA:
                  if (r.last) {
                    l >>>= f & 7, f -= f & 7, r.mode = RA;
                    break;
                  }
                  for (; f < 3; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  switch (r.last = l & 1, l >>>= 1, f -= 1, l & 3) {
                    case 0:
                      r.mode = ZG;
                      break;
                    case 1:
                      if (W_e(r), r.mode = P5, e === C5) {
                        l >>>= 2, f -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      r.mode = eW;
                      break;
                    case 3:
                      t.msg = "invalid block type", r.mode = Or;
                  }
                  l >>>= 2, f -= 2;
                  break;
                case ZG:
                  for (l >>>= f & 7, f -= f & 7; f < 32; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if ((l & 65535) !== (l >>> 16 ^ 65535)) {
                    t.msg = "invalid stored block lengths", r.mode = Or;
                    break;
                  }
                  if (r.length = l & 65535, l = 0, f = 0, r.mode = xA, e === C5)
                    break e;
                case xA:
                  r.mode = JG;
                case JG:
                  if (d = r.length, d) {
                    if (d > a && (d = a), d > u && (d = u), d === 0)
                      break e;
                    i2.set(n.subarray(o, o + d), s), a -= d, o += d, u -= d, s += d, r.length -= d;
                    break;
                  }
                  r.mode = zc;
                  break;
                case eW:
                  for (; f < 14; ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if (r.nlen = (l & 31) + 257, l >>>= 5, f -= 5, r.ndist = (l & 31) + 1, l >>>= 5, f -= 5, r.ncode = (l & 15) + 4, l >>>= 4, f -= 4, r.nlen > 286 || r.ndist > 30) {
                    t.msg = "too many length or distance symbols", r.mode = Or;
                    break;
                  }
                  r.have = 0, r.mode = tW;
                case tW:
                  for (; r.have < r.ncode; ) {
                    for (; f < 3; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    r.lens[se[r.have++]] = l & 7, l >>>= 3, f -= 3;
                  }
                  for (; r.have < 19; )
                    r.lens[se[r.have++]] = 0;
                  if (r.lencode = r.lendyn, r.lenbits = 7, z = { bits: r.lenbits }, O = Ay(L_e, r.lens, 0, 19, r.lencode, 0, r.work, z), r.lenbits = z.bits, O) {
                    t.msg = "invalid code lengths set", r.mode = Or;
                    break;
                  }
                  r.have = 0, r.mode = rW;
                case rW:
                  for (; r.have < r.nlen + r.ndist; ) {
                    for (; g = r.lencode[l & (1 << r.lenbits) - 1], E = g >>> 24, b = g >>> 16 & 255, v = g & 65535, !(E <= f); ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    if (v < 16)
                      l >>>= E, f -= E, r.lens[r.have++] = v;
                    else {
                      if (v === 16) {
                        for (W = E + 2; f < W; ) {
                          if (a === 0)
                            break e;
                          a--, l += n[o++] << f, f += 8;
                        }
                        if (l >>>= E, f -= E, r.have === 0) {
                          t.msg = "invalid bit length repeat", r.mode = Or;
                          break;
                        }
                        R = r.lens[r.have - 1], d = 3 + (l & 3), l >>>= 2, f -= 2;
                      } else if (v === 17) {
                        for (W = E + 3; f < W; ) {
                          if (a === 0)
                            break e;
                          a--, l += n[o++] << f, f += 8;
                        }
                        l >>>= E, f -= E, R = 0, d = 3 + (l & 7), l >>>= 3, f -= 3;
                      } else {
                        for (W = E + 7; f < W; ) {
                          if (a === 0)
                            break e;
                          a--, l += n[o++] << f, f += 8;
                        }
                        l >>>= E, f -= E, R = 0, d = 11 + (l & 127), l >>>= 7, f -= 7;
                      }
                      if (r.have + d > r.nlen + r.ndist) {
                        t.msg = "invalid bit length repeat", r.mode = Or;
                        break;
                      }
                      for (; d--; )
                        r.lens[r.have++] = R;
                    }
                  }
                  if (r.mode === Or)
                    break;
                  if (r.lens[256] === 0) {
                    t.msg = "invalid code -- missing end-of-block", r.mode = Or;
                    break;
                  }
                  if (r.lenbits = 9, z = { bits: r.lenbits }, O = Ay(LW, r.lens, 0, r.nlen, r.lencode, 0, r.work, z), r.lenbits = z.bits, O) {
                    t.msg = "invalid literal/lengths set", r.mode = Or;
                    break;
                  }
                  if (r.distbits = 6, r.distcode = r.distdyn, z = { bits: r.distbits }, O = Ay(BW, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, z), r.distbits = z.bits, O) {
                    t.msg = "invalid distances set", r.mode = Or;
                    break;
                  }
                  if (r.mode = P5, e === C5)
                    break e;
                case P5:
                  r.mode = D5;
                case D5:
                  if (a >= 6 && u >= 258) {
                    t.next_out = s, t.avail_out = u, t.next_in = o, t.avail_in = a, r.hold = l, r.bits = f, C_e(t, p), s = t.next_out, i2 = t.output, u = t.avail_out, o = t.next_in, n = t.input, a = t.avail_in, l = r.hold, f = r.bits, r.mode === zc && (r.back = -1);
                    break;
                  }
                  for (r.back = 0; g = r.lencode[l & (1 << r.lenbits) - 1], E = g >>> 24, b = g >>> 16 & 255, v = g & 65535, !(E <= f); ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if (b && (b & 240) === 0) {
                    for (S = E, x = b, T = v; g = r.lencode[T + ((l & (1 << S + x) - 1) >> S)], E = g >>> 24, b = g >>> 16 & 255, v = g & 65535, !(S + E <= f); ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    l >>>= S, f -= S, r.back += S;
                  }
                  if (l >>>= E, f -= E, r.back += E, r.length = v, b === 0) {
                    r.mode = aW;
                    break;
                  }
                  if (b & 32) {
                    r.back = -1, r.mode = zc;
                    break;
                  }
                  if (b & 64) {
                    t.msg = "invalid literal/length code", r.mode = Or;
                    break;
                  }
                  r.extra = b & 15, r.mode = nW;
                case nW:
                  if (r.extra) {
                    for (W = r.extra; f < W; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    r.length += l & (1 << r.extra) - 1, l >>>= r.extra, f -= r.extra, r.back += r.extra;
                  }
                  r.was = r.length, r.mode = iW;
                case iW:
                  for (; g = r.distcode[l & (1 << r.distbits) - 1], E = g >>> 24, b = g >>> 16 & 255, v = g & 65535, !(E <= f); ) {
                    if (a === 0)
                      break e;
                    a--, l += n[o++] << f, f += 8;
                  }
                  if ((b & 240) === 0) {
                    for (S = E, x = b, T = v; g = r.distcode[T + ((l & (1 << S + x) - 1) >> S)], E = g >>> 24, b = g >>> 16 & 255, v = g & 65535, !(S + E <= f); ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    l >>>= S, f -= S, r.back += S;
                  }
                  if (l >>>= E, f -= E, r.back += E, b & 64) {
                    t.msg = "invalid distance code", r.mode = Or;
                    break;
                  }
                  r.offset = v, r.extra = b & 15, r.mode = oW;
                case oW:
                  if (r.extra) {
                    for (W = r.extra; f < W; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, f -= r.extra, r.back += r.extra;
                  }
                  if (r.offset > r.dmax) {
                    t.msg = "invalid distance too far back", r.mode = Or;
                    break;
                  }
                  r.mode = sW;
                case sW:
                  if (u === 0)
                    break e;
                  if (d = p - u, r.offset > d) {
                    if (d = r.offset - d, d > r.whave && r.sane) {
                      t.msg = "invalid distance too far back", r.mode = Or;
                      break;
                    }
                    d > r.wnext ? (d -= r.wnext, m = r.wsize - d) : m = r.wnext - d, d > r.length && (d = r.length), y = r.window;
                  } else
                    y = i2, m = s - r.offset, d = r.length;
                  d > u && (d = u), u -= d, r.length -= d;
                  do
                    i2[s++] = y[m++];
                  while (--d);
                  r.length === 0 && (r.mode = D5);
                  break;
                case aW:
                  if (u === 0)
                    break e;
                  i2[s++] = r.length, u--, r.mode = D5;
                  break;
                case RA:
                  if (r.wrap) {
                    for (; f < 32; ) {
                      if (a === 0)
                        break e;
                      a--, l |= n[o++] << f, f += 8;
                    }
                    if (p -= u, t.total_out += p, r.total += p, p && (t.adler = r.check = r.flags ? Hn(r.check, i2, p, s - p) : Dy(r.check, i2, p, s - p)), p = u, (r.flags ? l : lW(l)) !== r.check) {
                      t.msg = "incorrect data check", r.mode = Or;
                      break;
                    }
                    l = 0, f = 0;
                  }
                  r.mode = cW;
                case cW:
                  if (r.wrap && r.flags) {
                    for (; f < 32; ) {
                      if (a === 0)
                        break e;
                      a--, l += n[o++] << f, f += 8;
                    }
                    if (l !== (r.total & 4294967295)) {
                      t.msg = "incorrect length check", r.mode = Or;
                      break;
                    }
                    l = 0, f = 0;
                  }
                  r.mode = uW;
                case uW:
                  O = M_e;
                  break e;
                case Or:
                  O = MW;
                  break e;
                case KW:
                  return UW;
                case K_e:
                default:
                  return rs;
              }
          return t.next_out = s, t.avail_out = u, t.next_in = o, t.avail_in = a, r.hold = l, r.bits = f, (r.wsize || p !== t.avail_out && r.mode < Or && (r.mode < RA || e !== VG)) && $W(t, t.output, t.next_out, p - t.avail_out), h -= t.avail_in, p -= t.avail_out, t.total_in += h, t.total_out += p, r.total += p, r.wrap && p && (t.adler = r.check = r.flags ? Hn(r.check, i2, p, t.next_out - p) : Dy(r.check, i2, p, t.next_out - p)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === zc ? 128 : 0) + (r.mode === P5 || r.mode === xA ? 256 : 0), (h === 0 && p === 0 || e === VG) && O === Ph && (O = F_e), O;
        }, Y_e = (t) => {
          if (!t || !t.state)
            return rs;
          let e = t.state;
          return e.window && (e.window = null), t.state = null, Ph;
        }, Q_e = (t, e) => {
          if (!t || !t.state)
            return rs;
          let r = t.state;
          return (r.wrap & 2) === 0 ? rs : (r.head = e, e.done = false, Ph);
        }, X_e = (t, e) => {
          let r = e.length, n, i2, o;
          return !t || !t.state || (n = t.state, n.wrap !== 0 && n.mode !== U5) ? rs : n.mode === U5 && (i2 = 1, i2 = Dy(i2, e, r, 0), i2 !== n.check) ? MW : (o = $W(t, e, r, r), o ? (n.mode = KW, UW) : (n.havedict = 1, Ph));
        }, Z_e = qW, J_e = zW, eve = VW, tve = G_e, rve = HW, nve = j_e, ive = Y_e, ove = Q_e, sve = X_e, ave = "pako inflate (from Nodeca project)", $c = { inflateReset: Z_e, inflateReset2: J_e, inflateResetKeep: eve, inflateInit: tve, inflateInit2: rve, inflate: nve, inflateEnd: ive, inflateGetHeader: ove, inflateSetDictionary: sve, inflateInfo: ave };
        function cve() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        }
        var uve = cve, GW = Object.prototype.toString, { Z_NO_FLUSH: lve, Z_FINISH: fve, Z_OK: Oy, Z_STREAM_END: IA, Z_NEED_DICT: CA, Z_STREAM_ERROR: hve, Z_DATA_ERROR: hW, Z_MEM_ERROR: dve } = Dh;
        function Uy(t) {
          this.options = V5.assign({ chunkSize: 1024 * 64, windowBits: 15, to: "" }, t || {});
          let e = this.options;
          e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, e.windowBits === 0 && (e.windowBits = -15)), e.windowBits >= 0 && e.windowBits < 16 && !(t && t.windowBits) && (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (e.windowBits & 15) === 0 && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new NW(), this.strm.avail_out = 0;
          let r = $c.inflateInit2(this.strm, e.windowBits);
          if (r !== Oy)
            throw new Error(Th[r]);
          if (this.header = new uve(), $c.inflateGetHeader(this.strm, this.header), e.dictionary && (typeof e.dictionary == "string" ? e.dictionary = Ny.string2buf(e.dictionary) : GW.call(e.dictionary) === "[object ArrayBuffer]" && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = $c.inflateSetDictionary(this.strm, e.dictionary), r !== Oy)))
            throw new Error(Th[r]);
        }
        Uy.prototype.push = function(t, e) {
          let r = this.strm, n = this.options.chunkSize, i2 = this.options.dictionary, o, s, a;
          if (this.ended)
            return false;
          for (e === ~~e ? s = e : s = e === true ? fve : lve, GW.call(t) === "[object ArrayBuffer]" ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length; ; ) {
            for (r.avail_out === 0 && (r.output = new Uint8Array(n), r.next_out = 0, r.avail_out = n), o = $c.inflate(r, s), o === CA && i2 && (o = $c.inflateSetDictionary(r, i2), o === Oy ? o = $c.inflate(r, s) : o === hW && (o = CA)); r.avail_in > 0 && o === IA && r.state.wrap > 0 && t[r.next_in] !== 0; )
              $c.inflateReset(r), o = $c.inflate(r, s);
            switch (o) {
              case hve:
              case hW:
              case CA:
              case dve:
                return this.onEnd(o), this.ended = true, false;
            }
            if (a = r.avail_out, r.next_out && (r.avail_out === 0 || o === IA))
              if (this.options.to === "string") {
                let u = Ny.utf8border(r.output, r.next_out), l = r.next_out - u, f = Ny.buf2string(r.output, u);
                r.next_out = l, r.avail_out = n - l, l && r.output.set(r.output.subarray(u, u + l), 0), this.onData(f);
              } else
                this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out));
            if (!(o === Oy && a === 0)) {
              if (o === IA)
                return o = $c.inflateEnd(this.strm), this.onEnd(o), this.ended = true, true;
              if (r.avail_in === 0)
                break;
            }
          }
          return true;
        };
        Uy.prototype.onData = function(t) {
          this.chunks.push(t);
        };
        Uy.prototype.onEnd = function(t) {
          t === Oy && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = V5.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
        };
        function FA(t, e) {
          let r = new Uy(e);
          if (r.push(t), r.err)
            throw r.msg || Th[r.err];
          return r.result;
        }
        function pve(t, e) {
          return e = e || {}, e.raw = true, FA(t, e);
        }
        var mve = Uy, yve = FA, gve = pve, wve = FA, Eve = Dh, bve = { Inflate: mve, inflate: yve, inflateRaw: gve, ungzip: wve, constants: Eve }, { Deflate: _ve, deflate: vve, deflateRaw: Sve, gzip: xve } = T_e, { Inflate: Rve, inflate: Ave, inflateRaw: Tve, ungzip: Ive } = bve, Cve = _ve, Pve = vve, Dve = Sve, kve = xve, Nve = Rve, Ove = Ave, Lve = Tve, Bve = Ive, Mve = Dh, KA = { Deflate: Cve, deflate: Pve, deflateRaw: Dve, gzip: kve, Inflate: Nve, inflate: Ove, inflateRaw: Lve, ungzip: Bve, constants: Mve };
        var VA = w(ei(), 1), qA = w(hA(), 1), WW = 6;
        function jW({ repo: t, preload: e }) {
          async function* r(n, i2 = {}) {
            if (i2.compressionLevel != null && (i2.compressionLevel < -1 || i2.compressionLevel > 9))
              throw (0, D0.default)(new Error("Compression level must be between -1 and 9"), "ERR_INVALID_PARAMS");
            if (i2.preload !== false) {
              let a;
              try {
                a = Bp(n).split("/");
              } catch (u) {
                throw (0, D0.default)(u, "ERR_INVALID_PATH");
              }
              e(I.parse(a[0]));
            }
            let o = I.asCID(n) || n, s = await ti(o, t.blocks, i2);
            if (s.type === "file" || s.type === "raw") {
              let a = [];
              !i2.compress || i2.archive === true ? a.push([{ header: { name: s.path, mode: s.type === "file" && s.unixfs.mode, mtime: s.type === "file" && s.unixfs.mtime ? new Date(s.unixfs.mtime.secs * 1e3) : void 0, size: s.size, type: "file" }, body: s.content() }], A5(), (u) => (0, VA.default)(u, (l) => l.slice())) : a.push(s.content), i2.compress && a.push(async function* (u) {
                let l = await (0, qA.default)(u);
                yield KA.gzip(l, { level: i2.compressionLevel || WW });
              }), yield* Te(...a);
              return;
            }
            if (s.type === "directory") {
              let a = [x5(o, t.blocks, i2), async function* (u) {
                for await (let l of u) {
                  let f = { header: { name: l.path, size: l.size } };
                  if (l.type === "file")
                    f.header.type = "file", f.header.mode = l.unixfs.mode != null ? l.unixfs.mode : void 0, f.header.mtime = l.unixfs.mtime ? new Date(l.unixfs.mtime.secs * 1e3) : void 0, f.body = l.content();
                  else if (l.type === "raw")
                    f.header.type = "file", f.body = l.content();
                  else if (l.type === "directory")
                    f.header.type = "directory", f.header.mode = l.unixfs.mode != null ? l.unixfs.mode : void 0, f.header.mtime = l.unixfs.mtime ? new Date(l.unixfs.mtime.secs * 1e3) : void 0;
                  else
                    throw (0, D0.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
                  yield f;
                }
              }, A5(), (u) => (0, VA.default)(u, (l) => l.slice())];
              if (i2.compress) {
                if (!i2.archive)
                  throw (0, D0.default)(new Error("file is not regular"), "ERR_INVALID_PATH");
                i2.compress && a.push(async function* (u) {
                  let l = await (0, qA.default)(u);
                  yield KA.gzip(l, { level: i2.compressionLevel || WW });
                });
              }
              yield* Te(...a);
              return;
            }
            throw (0, D0.default)(new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
          }
          return B(r);
        }
        c();
        var YW = w(K(), 1);
        te();
        function QW({ repo: t, preload: e }) {
          async function* r(n, i2 = {}) {
            let o = Bp(n), s = o.split("/");
            i2.preload !== false && e(I.parse(s[0]));
            let a = I.asCID(o) || o, u = await ti(a, t.blocks, i2);
            if (u.type === "file") {
              yield VS(u);
              return;
            }
            if (u.type === "directory") {
              for await (let l of u.content())
                yield VS(l);
              return;
            }
            throw (0, YW.default)(new Error(`Unknown UnixFS type ${u.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
          }
          return B(r);
        }
        var q5 = class {
          constructor({ preload: e, repo: r, hashers: n, options: i2 }) {
            let o = rG({ preload: e, repo: r, options: i2, hashers: n });
            this.addAll = o, this.add = WH({ addAll: o }), this.cat = _G({ repo: r, preload: e }), this.get = jW({ repo: r, preload: e }), this.ls = QW({ repo: r, preload: e });
          }
        };
        c();
        c();
        var Nh = "", XW = "", ZW = "";
        function JW({ repo: t }) {
          async function e(r = {}) {
            let n = await t.version.get();
            return { version: Nh, commit: XW, repo: `${n}`, "ipfs-core": Nh, "interface-ipfs-core": ZW };
          }
          return B(e);
        }
        c();
        me();
        var z5 = w(K(), 1);
        var Uve = C("ipfs:components:id");
        function ej({ peerId: t, network: e }) {
          async function r(n = {}) {
            let i2 = e.try();
            if (!i2) {
              if (n.peerId)
                throw new xc();
              if (t.publicKey == null)
                throw (0, z5.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
              return { id: t, publicKey: M(t.publicKey, "base64pad"), addresses: [], agentVersion: `js-ipfs/${Nh}`, protocolVersion: "9000", protocols: [] };
            }
            let { libp2p: o } = i2, s = n.peerId ? n.peerId : t, a = await Fve(s, o, n), u = M(a.metadata.get("AgentVersion") || new Uint8Array()), l = M(a.metadata.get("ProtocolVersion") || new Uint8Array()), f = a.id.toString(), h = a.publicKey ? M(a.publicKey, "base64pad") : "";
            return { id: s, publicKey: h, addresses: (a.addresses || []).map((p) => {
              let d = p.toString();
              return d.endsWith(`/p2p/${f}`) ? d : `${d}/p2p/${f}`;
            }).sort().map((p) => new j(p)), agentVersion: u, protocolVersion: l, protocols: (a.protocols || []).sort() };
          }
          return B(r);
        }
        async function Fve(t, e, r) {
          let n = await e.peerStore.get(t);
          n || (n = await Kve(t, e, r));
          let i2 = t.publicKey ? t.publicKey : await e.peerStore.keyBook.get(t);
          if (i2 == null)
            try {
              i2 = await e.getPublicKey(t, r);
            } catch (o) {
              Uve.error("Could not load public key for", t.toString(), o);
            }
          return { ...n, publicKey: i2, metadata: n.metadata || /* @__PURE__ */ new Map(), addresses: n.addresses.map((o) => o.multiaddr) };
        }
        async function Kve(t, e, r) {
          if (e.dht == null)
            throw (0, z5.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
          for await (let i2 of e.dht.findPeer(t, r))
            if (i2.name === "FINAL_PEER")
              break;
          let n = await e.peerStore.get(t);
          if (!n)
            throw (0, z5.default)(new Error("Could not find peer"), "ERR_NOT_FOUND");
          return n;
        }
        c();
        c();
        c();
        var Gr = Vve;
        function Vve(t, e, r) {
          var n, i2;
          if (Array.isArray(e) && (n = e.slice(0)), typeof e == "string" && (n = e.split(".")), typeof e == "symbol" && (n = [e]), !Array.isArray(n))
            throw new Error("props arg must be an array, a string or a symbol");
          if (i2 = n.pop(), !i2)
            return false;
          tj(i2);
          for (var o; o = n.shift(); )
            if (tj(o), typeof t[o] > "u" && (t[o] = {}), t = t[o], !t || typeof t != "object")
              return false;
          return t[i2] = r, true;
        }
        function tj(t) {
          if (t == "__proto__" || t == "constructor" || t == "prototype")
            throw new Error("setting of prototype values not supported");
        }
        var k0 = { server: { description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.", transform: (t) => (Gr(t, "Discovery.MDNS.Enabled", false), Gr(t, "Discovery.webRTCStar.Enabled", false), t.Swarm = { ...t.Swarm || {}, DisableNatPortMap: true }, t) }, "local-discovery": { description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.", transform: (t) => (Gr(t, "Discovery.MDNS.Enabled", true), Gr(t, "Discovery.webRTCStar.Enabled", true), Gr(t, "Swarm", { ...t.Swarm || {}, DisableNatPortMap: false }), t) }, test: { description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.", transform: (t) => {
          let e = Kc();
          return Gr(t, "Addresses.API", e.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : ""), Gr(t, "Addresses.Gateway", e.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : ""), Gr(t, "Addresses.Swarm", e.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []), Gr(t, "Addresses.Delegates", []), Gr(t, "Bootstrap", []), Gr(t, "Discovery.MDNS.Enabled", false), Gr(t, "Discovery.webRTCStar.Enabled", false), Gr(t, "Swarm", { ...t.Swarm || {}, DisableNatPortMap: true }), t;
        } }, "default-networking": { description: "Restores default network settings. Inverse profile of the `test` profile.", transform: (t) => {
          let e = Kc();
          return Gr(t, "Addresses.API", e.Addresses.API), Gr(t, "Addresses.Gateway", e.Addresses.Gateway), Gr(t, "Addresses.Swarm", e.Addresses.Swarm), Gr(t, "Addresses.Delegates", e.Addresses.Delegates), Gr(t, "Bootstrap", e.Bootstrap), Gr(t, "Discovery.MDNS.Enabled", e.Discovery.MDNS.Enabled), Gr(t, "Discovery.webRTCStar.Enabled", e.Discovery.webRTCStar.Enabled), Gr(t, "Swarm", { ...t.Swarm || {}, DisableNatPortMap: false }), t;
        } }, lowpower: { description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.", transform: (t) => {
          let e = t.Swarm || {}, r = e.ConnMgr || {};
          return r.LowWater = 20, r.HighWater = 40, e.ConnMgr = r, t.Swarm = e, t;
        } }, "default-power": { description: 'Inverse of "lowpower" profile.', transform: (t) => {
          let e = Kc();
          return t.Swarm = e.Swarm, t;
        } } };
        var qve = C("ipfs:core:config");
        function rj({ repo: t }) {
          return { getAll: B(e), get: B(r), set: B(n), replace: B(i2), profiles: { apply: B(o), list: B(zve) } };
          async function e(s = {}) {
            return t.config.getAll(s);
          }
          async function r(s, a) {
            return s ? t.config.get(s, a) : Promise.reject(new Error("key argument is required"));
          }
          async function n(s, a, u) {
            return t.config.set(s, a, u);
          }
          async function i2(s, a) {
            return t.config.replace(s, a);
          }
          async function o(s, a = { dryRun: false }) {
            let { dryRun: u } = a, l = k0[s];
            if (!l)
              throw new Error(`No profile with name '${s}' exists`);
            try {
              let f = await t.config.getAll(a), h = JSON.parse(JSON.stringify(f));
              return h = l.transform(h), u || await t.config.replace(h, a), delete f.Identity.PrivKey, delete h.Identity.PrivKey, { original: f, updated: h };
            } catch (f) {
              throw qve(f), new Error(`Could not apply profile '${s}' to config: ${f.message}`);
            }
          }
        }
        async function zve(t) {
          return Object.keys(k0).map((e) => ({ name: e, description: k0[e].description }));
        }
        c();
        c();
        te();
        c();
        bp();
        var H5 = ({ enumerable: t = true, configurable: e = false } = {}) => ({ enumerable: t, configurable: e, writable: false }), zA = function* (t, e) {
          if (t != null && !(t instanceof Uint8Array))
            for (let [r, n] of Object.entries(t)) {
              let i2 = [...e, r];
              if (n != null && typeof n == "object")
                if (Array.isArray(n))
                  for (let [o, s] of n.entries()) {
                    let a = [...i2, o], u = I.asCID(s);
                    u ? yield [a.join("/"), u] : typeof s == "object" && (yield* zA(s, a));
                  }
                else {
                  let o = I.asCID(n);
                  o ? yield [i2.join("/"), o] : yield* zA(n, i2);
                }
            }
        }, HA = function* (t, e) {
          if (t != null)
            for (let [r, n] of Object.entries(t)) {
              let i2 = [...e, r];
              if (yield i2.join("/"), n != null && !(n instanceof Uint8Array) && typeof n == "object" && !I.asCID(n))
                if (Array.isArray(n))
                  for (let [o, s] of n.entries()) {
                    let a = [...i2, o];
                    yield a.join("/"), typeof s == "object" && !I.asCID(s) && (yield* HA(s, a));
                  }
                else
                  yield* HA(n, i2);
            }
        }, Hve = (t, e) => {
          let r = t;
          for (let [n, i2] of e.entries()) {
            if (r = r[i2], r == null)
              throw new Error(`Object has no property at ${e.slice(0, n + 1).map((s) => `[${JSON.stringify(s)}]`).join("")}`);
            let o = I.asCID(r);
            if (o)
              return { value: o, remaining: e.slice(n + 1).join("/") };
          }
          return { value: r };
        }, $A = class {
          constructor({ cid: e, bytes: r, value: n }) {
            if (!e || !r || typeof n > "u")
              throw new Error("Missing required argument");
            this.cid = e, this.bytes = r, this.value = n, this.asBlock = this, Object.defineProperties(this, { cid: H5(), bytes: H5(), value: H5(), asBlock: H5() });
          }
          links() {
            return zA(this.value, []);
          }
          tree() {
            return HA(this.value, []);
          }
          get(e = "/") {
            return Hve(this.value, e.split("/").filter(Boolean));
          }
        };
        var N0 = ({ bytes: t, cid: e, value: r, codec: n }) => {
          let i2 = r !== void 0 ? r : n && n.decode(t);
          if (i2 === void 0)
            throw new Error('Missing required argument, must either provide "value" or "codec"');
          return new $A({ cid: e, bytes: t, value: i2 });
        };
        c();
        te();
        c();
        var GA = w(ai(), 1);
        function WA(t) {
          let e = U9({ version: 1, roots: t }), r = GA.default.encode(e.length), n = new Uint8Array(r.length + e.length);
          return n.set(r, 0), n.set(e, r.length), n;
        }
        function nj(t) {
          return { async setRoots(e) {
            let r = WA(e);
            await t.write(r);
          }, async writeBlock(e) {
            let { cid: r, bytes: n } = e;
            await t.write(new Uint8Array(GA.default.encode(r.bytes.length + n.length))), await t.write(r.bytes), n.length && await t.write(n);
          }, async close() {
            await t.end();
          } };
        }
        c();
        function $5() {
        }
        function ij() {
          let t = [], e = null, r = $5, n = false, i2 = null, o = $5, s = () => (e || (e = new Promise((l) => {
            r = () => {
              e = null, r = $5, l();
            };
          })), e), a = { write(l) {
            t.push(l);
            let f = s();
            return o(), f;
          }, async end() {
            n = true;
            let l = s();
            o(), await l;
          } }, u = { async next() {
            let l = t.shift();
            return l ? (t.length === 0 && r(), { done: false, value: l }) : n ? (r(), { done: true, value: void 0 }) : (i2 || (i2 = new Promise((f) => {
              o = () => (i2 = null, o = $5, f(u.next()));
            })), i2);
          } };
          return { writer: a, iterator: u };
        }
        c();
        var Il = w(ai(), 1);
        te();
        On();
        c();
        var Tl = { Null: (t) => t === null, Int: (t) => Number.isInteger(t), Float: (t) => typeof t == "number" && Number.isFinite(t), String: (t) => typeof t == "string", Bool: (t) => typeof t == "boolean", Bytes: (t) => t instanceof Uint8Array, Link: (t) => !Tl.Null(t) && typeof t == "object" && t.asCID === t, List: (t) => Array.isArray(t), Map: (t) => !Tl.Null(t) && typeof t == "object" && t.asCID !== t && !Tl.List(t) && !Tl.Bytes(t) }, O0 = { Int: Tl.Int, "CarHeader > version": (t) => O0.Int(t), "CarHeader > roots (anon) > valueType (anon)": Tl.Link, "CarHeader > roots (anon)": (t) => Tl.List(t) && Array.prototype.every.call(t, O0["CarHeader > roots (anon) > valueType (anon)"]), "CarHeader > roots": (t) => O0["CarHeader > roots (anon)"](t), CarHeader: (t) => {
          let e = t && Object.keys(t);
          return Tl.Map(t) && ["version"].every((r) => e.includes(r)) && Object.entries(t).every(([r, n]) => O0["CarHeader > " + r] && O0["CarHeader > " + r](n));
        } }, oj = O0.CarHeader;
        var jA = { SHA2_256: 18, LENGTH: 32, DAG_PB: 112 }, sj = 16 + 8 + 8 + 8;
        async function G5(t) {
          let e = await t.upTo(8);
          if (!e.length)
            throw new Error("Unexpected end of data");
          let r = Il.default.decode(e);
          return t.seek(Il.default.decode.bytes), r;
        }
        async function $ve(t) {
          let e = await t.exactly(sj), r = new DataView(e.buffer, e.byteOffset, e.byteLength), n = 0, i2 = { version: 2, characteristics: [r.getBigUint64(n, true), r.getBigUint64(n += 8, true)], dataOffset: Number(r.getBigUint64(n += 8, true)), dataSize: Number(r.getBigUint64(n += 8, true)), indexOffset: Number(r.getBigUint64(n += 8, true)) };
          return t.seek(sj), i2;
        }
        async function W5(t, e) {
          let r = await G5(t);
          if (r === 0)
            throw new Error("Invalid CAR header (zero length)");
          let n = await t.exactly(r);
          t.seek(r);
          let i2 = zf(n);
          if (!oj(i2))
            throw new Error("Invalid CAR header format");
          if (i2.version !== 1 && i2.version !== 2 || e !== void 0 && i2.version !== e)
            throw new Error(`Invalid CAR version: ${i2.version}${e !== void 0 ? ` (expected ${e})` : ""}`);
          let o = Array.isArray(i2.roots);
          if (i2.version === 1 && !o || i2.version === 2 && o)
            throw new Error("Invalid CAR header format");
          if (i2.version === 1)
            return i2;
          let s = await $ve(t);
          t.seek(s.dataOffset - t.pos);
          let a = await W5(t, 1);
          return Object.assign(a, s);
        }
        async function Gve(t) {
          let e = await t.upTo(8);
          Il.default.decode(e);
          let r = Il.default.decode.bytes, n = Il.default.decode(e.subarray(Il.default.decode.bytes)), i2 = Il.default.decode.bytes, o = r + i2 + n, s = await t.exactly(o);
          return t.seek(o), s;
        }
        async function Wve(t) {
          let e = await t.exactly(2);
          if (e[0] === jA.SHA2_256 && e[1] === jA.LENGTH) {
            let s = await t.exactly(34);
            t.seek(34);
            let a = _r(s);
            return I.create(0, jA.DAG_PB, a);
          }
          let r = await G5(t);
          if (r !== 1)
            throw new Error(`Unexpected CID version (${r})`);
          let n = await G5(t), i2 = await Gve(t), o = _r(i2);
          return I.create(r, n, o);
        }
        async function aj(t) {
          let e = t.pos, r = await G5(t);
          if (r === 0)
            throw new Error("Invalid CAR section (zero length)");
          r += t.pos - e;
          let n = await Wve(t), i2 = r - Number(t.pos - e);
          return { cid: n, length: r, blockLength: i2 };
        }
        async function jve(t) {
          let { cid: e, blockLength: r } = await aj(t), n = await t.exactly(r);
          return t.seek(r), { bytes: n, cid: e };
        }
        async function Yve(t) {
          let e = t.pos, { cid: r, length: n, blockLength: i2 } = await aj(t), o = { cid: r, length: n, blockLength: i2, offset: e, blockOffset: t.pos };
          return t.seek(o.blockLength), o;
        }
        function cj(t) {
          let e = (async () => {
            let r = await W5(t);
            if (r.version === 2) {
              let n = t.pos - r.dataOffset;
              t = Xve(t, r.dataSize - n);
            }
            return r;
          })();
          return { header: () => e, async *blocks() {
            for (await e; (await t.upTo(8)).length > 0; )
              yield await jve(t);
          }, async *blocksIndex() {
            for (await e; (await t.upTo(8)).length > 0; )
              yield await Yve(t);
          } };
        }
        function j5(t) {
          let e = 0;
          return { async upTo(r) {
            return t.subarray(e, e + Math.min(r, t.length - e));
          }, async exactly(r) {
            if (r > t.length - e)
              throw new Error("Unexpected end of data");
            return t.subarray(e, e + r);
          }, seek(r) {
            e += r;
          }, get pos() {
            return e;
          } };
        }
        function Qve(t) {
          let e = 0, r = 0, n = 0, i2 = new Uint8Array(0), o = async (s) => {
            r = i2.length - n;
            let a = [i2.subarray(n)];
            for (; r < s; ) {
              let l = await t();
              if (l == null)
                break;
              r < 0 ? l.length > r && a.push(l.subarray(-r)) : a.push(l), r += l.length;
            }
            i2 = new Uint8Array(a.reduce((l, f) => l + f.length, 0));
            let u = 0;
            for (let l of a)
              i2.set(l, u), u += l.length;
            n = 0;
          };
          return { async upTo(s) {
            return i2.length - n < s && await o(s), i2.subarray(n, n + Math.min(i2.length - n, s));
          }, async exactly(s) {
            if (i2.length - n < s && await o(s), i2.length - n < s)
              throw new Error("Unexpected end of data");
            return i2.subarray(n, n + s);
          }, seek(s) {
            e += s, n += s;
          }, get pos() {
            return e;
          } };
        }
        function uj(t) {
          let e = t[Symbol.asyncIterator]();
          async function r() {
            let n = await e.next();
            return n.done ? null : n.value;
          }
          return Qve(r);
        }
        function Xve(t, e) {
          let r = 0;
          return { async upTo(n) {
            let i2 = await t.upTo(n);
            return i2.length + r > e && (i2 = i2.subarray(0, e - r)), i2;
          }, async exactly(n) {
            let i2 = await t.exactly(n);
            if (i2.length + r > e)
              throw new Error("Unexpected end of data");
            return i2;
          }, seek(n) {
            r += n, t.seek(n);
          }, get pos() {
            return t.pos;
          } };
        }
        var Oh = class {
          constructor(e, r) {
            this._encoder = r, this._mutex = r.setRoots(e), this._ended = false;
          }
          async put(e) {
            if (!(e.bytes instanceof Uint8Array) || !e.cid)
              throw new TypeError("Can only write {cid, bytes} objects");
            if (this._ended)
              throw new Error("Already closed");
            let r = I.asCID(e.cid);
            if (!r)
              throw new TypeError("Can only write {cid, bytes} objects");
            return this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid: r, bytes: e.bytes })), this._mutex;
          }
          async close() {
            if (this._ended)
              throw new Error("Already closed");
            return await this._mutex, this._ended = true, this._encoder.close();
          }
          static create(e) {
            e = Zve(e);
            let { encoder: r, iterator: n } = lj(), i2 = new Oh(e, r), o = new Y5(n);
            return { writer: i2, out: o };
          }
          static createAppender() {
            let { encoder: e, iterator: r } = lj();
            e.setRoots = () => Promise.resolve();
            let n = new Oh([], e), i2 = new Y5(r);
            return { writer: n, out: i2 };
          }
          static async updateRootsInBytes(e, r) {
            let n = j5(e);
            await W5(n);
            let i2 = WA(r);
            if (Number(n.pos) !== i2.length)
              throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${n.pos} bytes, new header is ${i2.length} bytes)`);
            return e.set(i2, 0), e;
          }
        }, Y5 = class {
          constructor(e) {
            this._iterator = e;
          }
          [Symbol.asyncIterator]() {
            if (this._iterating)
              throw new Error("Multiple iterator not supported");
            return this._iterating = true, this._iterator;
          }
        };
        function lj() {
          let t = ij(), { writer: e, iterator: r } = t;
          return { encoder: nj(e), iterator: r };
        }
        function Zve(t) {
          if (t === void 0)
            return [];
          if (!Array.isArray(t)) {
            let r = I.asCID(t);
            if (!r)
              throw new TypeError("roots must be a single CID or an array of CIDs");
            return [r];
          }
          let e = [];
          for (let r of t) {
            let n = I.asCID(r);
            if (!n)
              throw new TypeError("roots must be a single CID or an array of CIDs");
            e.push(n);
          }
          return e;
        }
        zo();
        uS();
        c();
        Hr();
        var YA = async ({ cid: t, load: e, seen: r }) => {
          r = r || /* @__PURE__ */ new Set();
          let n = t.toString(Ne);
          if (r.has(n))
            return;
          let i2 = await e(t);
          if (r.add(n), i2 !== null)
            for (let [, o] of i2.links())
              await YA({ cid: o, load: e, seen: r });
        };
        var fj = C("ipfs:components:dag:import"), Jve = [Un, cS];
        function hj({ repo: t, preload: e, codecs: r }) {
          async function* n(i2, o = {}) {
            o.preload !== false && e(i2);
            let s = I.asCID(i2);
            if (!s)
              throw new Error(`Unexpected error converting CID type: ${i2}`);
            fj(`Exporting ${s} as car`);
            let { writer: a, out: u } = await Oh.create([s]), l = null;
            (async () => {
              try {
                let f = e7e(t, a, { signal: o.signal, timeout: o.timeout }, r);
                await YA({ cid: s, load: f });
              } catch (f) {
                l = f;
              } finally {
                a.close();
              }
            })();
            for await (let f of u) {
              if (l)
                break;
              yield f;
            }
            if (l)
              throw l;
          }
          return B(n);
        }
        function e7e(t, e, r, n) {
          return async (i2) => {
            let o = await n.getCodec(i2.code);
            if (!o)
              throw new Error(`Can't decode links in block with codec 0x${i2.code.toString(16)} to form complete DAG`);
            let s = await t.blocks.get(i2, r);
            return fj(`Adding block ${i2} to car`), await e.put({ cid: i2, bytes: s }), Jve.includes(i2.code) ? null : N0({ bytes: s, cid: i2, codec: o });
          };
        }
        c();
        var pj = w(Gc(), 1), mj = w(qi(), 1);
        var yj = w(K(), 1);
        function gj({ codecs: t, repo: e, preload: r }) {
          return B(async function(o, s = {}) {
            if (s.preload !== false && r(o), s.path) {
              let h = s.localResolve ? await (0, pj.default)(Qu(o, s.path, t, e, s)) : await (0, mj.default)(Qu(o, s.path, t, e, s));
              if (!h)
                throw (0, yj.default)(new Error("Not found"), "ERR_NOT_FOUND");
              return h;
            }
            let a = await t.getCodec(o.code), u = await e.blocks.get(o, s);
            return { value: a.decode(u), remainderPath: "" };
          });
        }
        c();
        c();
        var Q5 = class {
          constructor(e, r, n) {
            this._version = e, this._roots = r, this._iterable = n, this._decoded = false;
          }
          get version() {
            return this._version;
          }
          async getRoots() {
            return this._roots;
          }
        }, Lh = class extends Q5 {
          [Symbol.asyncIterator]() {
            if (this._decoded)
              throw new Error("Cannot decode more than once");
            if (!this._iterable)
              throw new Error("Block iterable not found");
            return this._decoded = true, this._iterable[Symbol.asyncIterator]();
          }
          static async fromBytes(e) {
            let { version: r, roots: n, iterator: i2 } = await wj(e);
            return new Lh(r, n, i2);
          }
          static async fromIterable(e) {
            let { version: r, roots: n, iterator: i2 } = await Ej(e);
            return new Lh(r, n, i2);
          }
        }, Fy = class extends Q5 {
          [Symbol.asyncIterator]() {
            if (this._decoded)
              throw new Error("Cannot decode more than once");
            if (!this._iterable)
              throw new Error("Block iterable not found");
            this._decoded = true;
            let e = this._iterable[Symbol.asyncIterator]();
            return { async next() {
              let r = await e.next();
              return r.done ? r : { done: false, value: r.value.cid };
            } };
          }
          static async fromBytes(e) {
            let { version: r, roots: n, iterator: i2 } = await wj(e);
            return new Fy(r, n, i2);
          }
          static async fromIterable(e) {
            let { version: r, roots: n, iterator: i2 } = await Ej(e);
            return new Fy(r, n, i2);
          }
        };
        async function wj(t) {
          if (!(t instanceof Uint8Array))
            throw new TypeError("fromBytes() requires a Uint8Array");
          return bj(j5(t));
        }
        async function Ej(t) {
          if (!t || typeof t[Symbol.asyncIterator] != "function")
            throw new TypeError("fromIterable() requires an async iterable");
          return bj(uj(t));
        }
        async function bj(t) {
          let e = cj(t), { version: r, roots: n } = await e.header();
          return { version: r, roots: n, iterator: e.blocks() };
        }
        var _j = w(S0(), 1), vj = w(Ci(), 1), Sj = w(ei(), 1);
        var xj = C("ipfs:components:dag:import");
        function Rj({ repo: t }) {
          async function* e(r, n = {}) {
            let i2 = await t.gcLock.readLock();
            try {
              let o = { signal: n.signal, timeout: n.timeout }, s = (0, _j.default)(r), { value: a, done: u } = await s.peek();
              if (u)
                return;
              a && s.push(a);
              let l;
              a instanceof Uint8Array ? l = [s] : l = s;
              for await (let f of l) {
                let h = await r7e(t, o, f);
                if (n.pinRoots !== false)
                  for (let p of h) {
                    let d = "";
                    try {
                      await t.blocks.has(p) ? (xj(`Pinning root ${p}`), await t.pins.pinRecursively(p)) : d = "blockstore: block not found";
                    } catch (m) {
                      d = m.message;
                    }
                    yield { root: { cid: p, pinErrorMsg: d } };
                  }
              }
            } finally {
              i2();
            }
          }
          return B(e);
        }
        async function r7e(t, e, r) {
          let n = await Lh.fromIterable(r), i2 = await n.getRoots();
          return await (0, vj.default)(t.blocks.putMany((0, Sj.default)(n, ({ cid: o, bytes: s }) => (xj(`Import block ${o}`), { key: o, value: s })), { signal: e.signal })), i2;
        }
        c();
        te();
        function Aj({ repo: t, codecs: e, hashers: r, preload: n }) {
          async function i2(o, s = {}) {
            let a = s.pin ? await t.gcLock.readLock() : null;
            try {
              let u = await e.getCodec(s.storeCodec || "dag-cbor");
              if (!u)
                throw new Error(`Unknown storeCodec ${s.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
              if (s.inputCodec) {
                if (!(o instanceof Uint8Array))
                  throw new Error("Can only inputCodec on raw bytes that can be decoded");
                let m = await e.getCodec(s.inputCodec);
                if (!m)
                  throw new Error(`Unknown inputCodec ${s.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
                o = m.decode(o);
              }
              let l = s.version != null ? s.version : 1, f = await r.getHasher(s.hashAlg || "sha2-256");
              if (!f)
                throw new Error(`Unknown hash algorithm ${s.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
              let h = u.encode(o), p = await f.digest(h), d = I.create(l, u.code, p);
              return await t.blocks.put(d, h, { signal: s.signal }), s.pin && await t.pins.pinRecursively(d), s.preload !== false && n(d), d;
            } finally {
              a && a();
            }
          }
          return B(i2);
        }
        c();
        function Tj({ repo: t, codecs: e, preload: r }) {
          async function n(i2, o = {}) {
            let { cid: s } = Tc(i2);
            return o.preload !== false && r(s), Yu(t, e, i2, o);
          }
          return B(n);
        }
        var X5 = class {
          constructor({ repo: e, codecs: r, hashers: n, preload: i2 }) {
            this.export = hj({ repo: e, preload: i2, codecs: r }), this.get = gj({ codecs: r, repo: e, preload: i2 }), this.import = Rj({ repo: e }), this.resolve = Tj({ repo: e, codecs: r, preload: i2 }), this.put = Aj({ repo: e, codecs: r, hashers: n, preload: i2 });
          }
        };
        c();
        c();
        var Z5 = (t, e) => e, n7e = (t, e, r, n) => {
          if (n != null && n.assumeHttp === false)
            return `tcp://${t}:${e}`;
          let i2 = "tcp", o = `:${e}`;
          return r[r.length - 1].protocol === "tcp" && (i2 = e === "443" ? "https" : "http", o = e === "443" || e === "80" ? "" : o), `${i2}://${t}${o}`;
        }, i7e = { ip4: Z5, ip6: (t, e, r, n) => n.length === 1 && n[0].protocol === "ip6" ? e : `[${e}]`, tcp: (t, e, r, n, i2) => n.some((o) => ["http", "https", "ws", "wss"].includes(o.protocol)) ? `${t}:${e}` : n7e(t, e, n, i2), udp: (t, e) => `udp://${t}:${e}`, dnsaddr: Z5, dns4: Z5, dns6: Z5, ipfs: (t, e) => `${t}/ipfs/${e}`, p2p: (t, e) => `${t}/p2p/${e}`, http: (t) => `http://${t}`, https: (t) => `https://${t}`, ws: (t) => `ws://${t}`, wss: (t) => `wss://${t}`, "p2p-websocket-star": (t) => `${t}/p2p-websocket-star`, "p2p-webrtc-star": (t) => `${t}/p2p-webrtc-star`, "p2p-webrtc-direct": (t) => `${t}/p2p-webrtc-direct` };
        function L0(t, e) {
          let r = new j(t), n = t.toString().split("/").slice(1);
          return r.tuples().map((i2) => ({ protocol: n.shift() ?? "", content: i2[1] != null ? n.shift() ?? "" : "" })).reduce((i2, o, s, a) => {
            let u = i7e[o.protocol];
            if (u == null)
              throw new Error(`Unsupported protocol ${o.protocol}`);
            return u(i2, o.content, s, a, e);
          }, "");
        }
        c();
        function QA(t) {
          if (!Array.isArray(t))
            throw new TypeError(`Expected an array, got ${typeof t}`);
          t = [...t];
          for (let e = t.length - 1; e > 0; e--) {
            let r = Math.floor(Math.random() * (e + 1));
            [t[e], t[r]] = [t[r], t[e]];
          }
          return t;
        }
        c();
        var Ij = w(Vp(), 1);
        var o7e = C("ipfs:preload"), s7e = ks.default ? ks.default : ks, a7e = new s7e({ concurrency: 4 });
        function Cj(t, e = {}) {
          return o7e(t), a7e.add(async () => {
            let n = (await Ij.default.post(t, { signal: e.signal })).body.getReader();
            try {
              for (; ; ) {
                let { done: i2 } = await n.read();
                if (i2)
                  return;
              }
            } finally {
              n.releaseLock();
            }
          });
        }
        var Pj = w(Mp(), 1), Ky = C("ipfs:preload");
        function Dj(t = {}) {
          if (t.enabled = Boolean(t.enabled), t.addresses = t.addresses || [], t.cache = t.cache || 1e3, !t.enabled || !t.addresses.length)
            return Ky("preload disabled"), Object.assign(() => {
            }, { start: () => {
            }, stop: () => {
            } });
          let e = true, r = [], n = t.addresses.map((s) => L0(s)), i2 = (0, Pj.default)(t.cache), o = async (s) => {
            try {
              if (e)
                throw new Error(`preload ${s} but preloader is not started`);
              let a = s.toString();
              if (i2.has(a))
                return;
              i2.set(a, true);
              let u = QA(n), l = false, f = Date.now();
              for (let h of u) {
                if (e)
                  throw new Error(`preload aborted for ${a}`);
                let p;
                try {
                  p = new AbortController(), r = r.concat(p), await Cj(`${h}/api/v0/refs?r=true&arg=${encodeURIComponent(a)}`, { signal: p.signal }), l = true;
                } catch (d) {
                  d.type !== "aborted" && Ky.error(d);
                } finally {
                  r = r.filter((d) => d !== p);
                }
                if (l)
                  break;
              }
              Ky(`${l ? "" : "un"}successfully preloaded ${a} in ${Date.now() - f}ms`);
            } catch (a) {
              Ky.error(a);
            }
          };
          return o.start = () => {
            e = false;
          }, o.stop = () => {
            e = true, Ky(`aborting ${r.length} pending preload request(s)`), r.forEach((s) => s.abort()), r = [];
          }, o;
        }
        c();
        var J5 = C("ipfs:mfs-preload");
        function kj({ preload: t, files: e, options: r = {} }) {
          if (r.interval = r.interval || 30 * 1e3, !r.enabled) {
            J5("MFS preload disabled");
            let s = async () => {
            };
            return { start: s, stop: s };
          }
          let n = "", i2, o = async () => {
            try {
              let s = await e.stat("/"), a = s.cid.toString();
              n !== a && (J5(`preloading updated MFS root ${n} -> ${s.cid}`), await t(s.cid), n = a);
            } catch (s) {
              J5.error("failed to preload MFS root", s);
            } finally {
              i2 = setTimeout(o, r.interval);
            }
          };
          return { async start() {
            let s = await e.stat("/");
            n = s.cid.toString(), J5(`monitoring MFS root ${s.cid}`), i2 = setTimeout(o, r.interval);
          }, stop() {
            clearTimeout(i2);
          } };
        }
        c();
        c();
        c();
        c();
        var Fj = w(Xu(), 1);
        c();
        c();
        function XA(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var Bh = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Wc, Vy = class {
          constructor() {
            Wc.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && Bh(this, Wc, "f")[this.size - 1].priority >= r.priority) {
              Bh(this, Wc, "f").push(n);
              return;
            }
            let i2 = XA(Bh(this, Wc, "f"), n, (o, s) => s.priority - o.priority);
            Bh(this, Wc, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = Bh(this, Wc, "f").shift();
            return e?.run;
          }
          filter(e) {
            return Bh(this, Wc, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return Bh(this, Wc, "f").length;
          }
        };
        Wc = /* @__PURE__ */ new WeakMap();
        var Jt = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, Ee = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, $n, zy, Hy, Pl, i8, $y, e8, Ws, qy, mo, t8, yo, Gy, Cl, B0, M0, Mh, r8, Nj, Oj, Uj, Lj, Bj, Mj, n8, ZA, JA, o8, s8 = () => {
        }, c7e = new hi(), eT = class extends Error {
        }, U0 = class extends Fj.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), $n.add(this), zy.set(this, void 0), Hy.set(this, void 0), Pl.set(this, 0), i8.set(this, void 0), $y.set(this, void 0), e8.set(this, 0), Ws.set(this, void 0), qy.set(this, void 0), mo.set(this, void 0), t8.set(this, void 0), yo.set(this, 0), Gy.set(this, void 0), Cl.set(this, void 0), B0.set(this, s8), M0.set(this, s8), Mh.set(this, void 0), r8.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: Vy, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            Jt(this, zy, e.carryoverConcurrencyCount, "f"), Jt(this, Hy, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), Jt(this, i8, e.intervalCap, "f"), Jt(this, $y, e.interval, "f"), Jt(this, mo, new e.queueClass(), "f"), Jt(this, t8, e.queueClass, "f"), this.concurrency = e.concurrency, Jt(this, Mh, e.timeout, "f"), Jt(this, r8, e.throwOnTimeout === true, "f"), Jt(this, Cl, e.autoStart === false, "f");
          }
          get concurrency() {
            return Ee(this, Gy, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            Jt(this, Gy, e, "f"), Ee(this, $n, "m", o8).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                Jt(this, yo, (a = Ee(this, yo, "f"), a++, a), "f"), Jt(this, Pl, (u = Ee(this, Pl, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new eT("The task was aborted."));
                    return;
                  }
                  let f = await (Ee(this, Mh, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? Ee(this, Mh, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? Ee(this, r8, "f") : r.throwOnTimeout) && i2(c7e);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                Ee(this, $n, "m", Uj).call(this);
              };
              Ee(this, mo, "f").enqueue(o, r), Ee(this, $n, "m", n8).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return Ee(this, Cl, "f") ? (Jt(this, Cl, false, "f"), Ee(this, $n, "m", o8).call(this), this) : this;
          }
          pause() {
            Jt(this, Cl, true, "f");
          }
          clear() {
            Jt(this, mo, new (Ee(this, t8, "f"))(), "f");
          }
          async onEmpty() {
            if (Ee(this, mo, "f").size !== 0)
              return new Promise((e) => {
                let r = Ee(this, B0, "f");
                Jt(this, B0, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(Ee(this, mo, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  Ee(this, mo, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(Ee(this, yo, "f") === 0 && Ee(this, mo, "f").size === 0))
              return new Promise((e) => {
                let r = Ee(this, M0, "f");
                Jt(this, M0, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return Ee(this, mo, "f").size;
          }
          sizeBy(e) {
            return Ee(this, mo, "f").filter(e).length;
          }
          get pending() {
            return Ee(this, yo, "f");
          }
          get isPaused() {
            return Ee(this, Cl, "f");
          }
          get timeout() {
            return Ee(this, Mh, "f");
          }
          set timeout(e) {
            Jt(this, Mh, e, "f");
          }
        };
        zy = /* @__PURE__ */ new WeakMap(), Hy = /* @__PURE__ */ new WeakMap(), Pl = /* @__PURE__ */ new WeakMap(), i8 = /* @__PURE__ */ new WeakMap(), $y = /* @__PURE__ */ new WeakMap(), e8 = /* @__PURE__ */ new WeakMap(), Ws = /* @__PURE__ */ new WeakMap(), qy = /* @__PURE__ */ new WeakMap(), mo = /* @__PURE__ */ new WeakMap(), t8 = /* @__PURE__ */ new WeakMap(), yo = /* @__PURE__ */ new WeakMap(), Gy = /* @__PURE__ */ new WeakMap(), Cl = /* @__PURE__ */ new WeakMap(), B0 = /* @__PURE__ */ new WeakMap(), M0 = /* @__PURE__ */ new WeakMap(), Mh = /* @__PURE__ */ new WeakMap(), r8 = /* @__PURE__ */ new WeakMap(), $n = /* @__PURE__ */ new WeakSet(), Nj = function() {
          return Ee(this, Hy, "f") || Ee(this, Pl, "f") < Ee(this, i8, "f");
        }, Oj = function() {
          return Ee(this, yo, "f") < Ee(this, Gy, "f");
        }, Uj = function() {
          var e;
          Jt(this, yo, (e = Ee(this, yo, "f"), e--, e), "f"), Ee(this, $n, "m", n8).call(this), this.emit("next");
        }, Lj = function() {
          Ee(this, B0, "f").call(this), Jt(this, B0, s8, "f"), Ee(this, yo, "f") === 0 && (Ee(this, M0, "f").call(this), Jt(this, M0, s8, "f"), this.emit("idle"));
        }, Bj = function() {
          Ee(this, $n, "m", JA).call(this), Ee(this, $n, "m", ZA).call(this), Jt(this, qy, void 0, "f");
        }, Mj = function() {
          let e = Date.now();
          if (Ee(this, Ws, "f") === void 0) {
            let r = Ee(this, e8, "f") - e;
            if (r < 0)
              Jt(this, Pl, Ee(this, zy, "f") ? Ee(this, yo, "f") : 0, "f");
            else
              return Ee(this, qy, "f") === void 0 && Jt(this, qy, setTimeout(() => {
                Ee(this, $n, "m", Bj).call(this);
              }, r), "f"), true;
          }
          return false;
        }, n8 = function() {
          if (Ee(this, mo, "f").size === 0)
            return Ee(this, Ws, "f") && clearInterval(Ee(this, Ws, "f")), Jt(this, Ws, void 0, "f"), Ee(this, $n, "m", Lj).call(this), false;
          if (!Ee(this, Cl, "f")) {
            let e = !Ee(this, $n, "m", Mj).call(this);
            if (Ee(this, $n, "a", Nj) && Ee(this, $n, "a", Oj)) {
              let r = Ee(this, mo, "f").dequeue();
              return r ? (this.emit("active"), r(), e && Ee(this, $n, "m", ZA).call(this), true) : false;
            }
          }
          return false;
        }, ZA = function() {
          Ee(this, Hy, "f") || Ee(this, Ws, "f") !== void 0 || (Jt(this, Ws, setInterval(() => {
            Ee(this, $n, "m", JA).call(this);
          }, Ee(this, $y, "f")), "f"), Jt(this, e8, Date.now() + Ee(this, $y, "f"), "f"));
        }, JA = function() {
          Ee(this, Pl, "f") === 0 && Ee(this, yo, "f") === 0 && Ee(this, Ws, "f") && (clearInterval(Ee(this, Ws, "f")), Jt(this, Ws, void 0, "f")), Jt(this, Pl, Ee(this, zy, "f") ? Ee(this, yo, "f") : 0, "f"), Ee(this, $n, "m", o8).call(this);
        }, o8 = function() {
          for (; Ee(this, $n, "m", n8).call(this); )
            ;
        };
        c();
        Lp();
        c();
        var tT = "lock:worker:request-read", rT = "lock:worker:release-read", nT = "lock:master:grant-read", iT = "lock:worker:request-write", oT = "lock:worker:release-write", sT = "lock:master:grant-write";
        c();
        var Dl = {}, F0 = (t) => {
          t.addEventListener("message", (e) => {
            F0.dispatchEvent("message", t, e);
          }), t.port != null && t.port.addEventListener("message", (e) => {
            F0.dispatchEvent("message", t, e);
          });
        };
        F0.addEventListener = (t, e) => {
          Dl[t] == null && (Dl[t] = []), Dl[t].push(e);
        };
        F0.removeEventListener = (t, e) => {
          Dl[t] != null && (Dl[t] = Dl[t].filter((r) => r === e));
        };
        F0.dispatchEvent = function(t, e, r) {
          Dl[t] != null && Dl[t].forEach((n) => n(e, r));
        };
        var aT = F0;
        var Kj = (t, e, r, n, i2) => (o, s) => {
          if (s.data.type !== r)
            return;
          let a = { type: s.data.type, name: s.data.name, identifier: s.data.identifier };
          t.dispatchEvent(new MessageEvent(e, { data: { name: a.name, handler: async () => (o.postMessage({ type: i2, name: a.name, identifier: a.identifier }), await new Promise((u) => {
            let l = (f) => {
              if (f == null || f.data == null)
                return;
              let h = { type: f.data.type, name: f.data.name, identifier: f.data.identifier };
              h.type === n && h.identifier === a.identifier && (o.removeEventListener("message", l), u());
            };
            o.addEventListener("message", l);
          })) } }));
        }, Vj = (t, e, r, n) => async () => {
          let i2 = jf();
          return globalThis.postMessage({ type: e, identifier: i2, name: t }), await new Promise((o) => {
            let s = (a) => {
              if (a == null || a.data == null)
                return;
              let u = { type: a.data.type, identifier: a.data.identifier };
              u.type === r && u.identifier === i2 && (globalThis.removeEventListener("message", s), o(() => {
                globalThis.postMessage({ type: n, identifier: i2, name: t });
              }));
            };
            globalThis.addEventListener("message", s);
          });
        }, u7e = { singleProcess: false }, qj = (t) => {
          if (t = Object.assign({}, u7e, t), Boolean(globalThis.document) || t.singleProcess) {
            let r = new EventTarget();
            return aT.addEventListener("message", Kj(r, "requestReadLock", tT, rT, nT)), aT.addEventListener("message", Kj(r, "requestWriteLock", iT, oT, sT)), r;
          }
          return { isWorker: true, readLock: (r) => Vj(r, tT, nT, rT), writeLock: (r) => Vj(r, iT, sT, oT) };
        };
        var Uh = {}, kl;
        async function cT(t, e) {
          let r, n = new Promise((i2) => {
            r = i2;
          });
          return t.add(async () => await nn((async () => await new Promise((i2) => {
            r(() => {
              i2();
            });
          }))(), e.timeout)), await n;
        }
        var l7e = (t, e) => {
          if (kl.isWorker === true)
            return { readLock: kl.readLock(t, e), writeLock: kl.writeLock(t, e) };
          let r = new U0({ concurrency: 1 }), n;
          return { async readLock() {
            if (n != null)
              return await cT(n, e);
            n = new U0({ concurrency: e.concurrency, autoStart: false });
            let i2 = n, o = cT(n, e);
            return r.add(async () => (i2.start(), await i2.onIdle().then(() => {
              n === i2 && (n = null);
            }))), await o;
          }, async writeLock() {
            return n = null, await cT(r, e);
          } };
        }, f7e = { name: "lock", concurrency: 1 / 0, timeout: 846e5, global: globalThis, singleProcess: false };
        function uT(t) {
          let e = Object.assign({}, f7e, t);
          return kl == null && (kl = qj(e), kl.isWorker !== true && (kl.addEventListener("requestReadLock", (r) => {
            Uh[r.data.name] != null && Uh[r.data.name].readLock().then(async (n) => await r.data.handler().finally(() => n()));
          }), kl.addEventListener("requestWriteLock", async (r) => {
            Uh[r.data.name] != null && Uh[r.data.name].writeLock().then(async (n) => await r.data.handler().finally(() => n()));
          }))), Uh[e.name] == null && (Uh[e.name] = l7e(e.name, e)), Uh[e.name];
        }
        var a8;
        function Wy(t = false) {
          if (a8)
            return a8;
          let e = uT({ singleProcess: t });
          return a8 = { readLock: (r) => async (...n) => {
            let i2 = await e.readLock();
            try {
              return await r.apply(null, n);
            } finally {
              i2();
            }
          }, writeLock: (r) => async (...n) => {
            let i2 = await e.writeLock();
            try {
              return await r.apply(null, n);
            } finally {
              i2();
            }
          } }, a8;
        }
        var ET = w(m2(), 1);
        c();
        c();
        c();
        te();
        vr();
        var lT = w(K(), 1);
        var zj = C("ipfs:mfs:utils:with-mfs-root");
        async function K0(t, e) {
          if (e && e.signal && e.signal.aborted)
            throw (0, lT.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
          await t.repo.datastore.open();
          let r;
          try {
            let n = await t.repo.datastore.get(w2);
            r = I.decode(n);
          } catch (n) {
            if (n.code !== "ERR_NOT_FOUND")
              throw n;
            zj("Creating new MFS root");
            let i2 = je({ Data: new Je({ type: "directory" }).marshal(), Links: [] }), o = await xe.digest(i2);
            if (r = I.createV0(o), await t.repo.blocks.put(r, i2), e && e.signal && e.signal.aborted)
              throw (0, lT.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
            await t.repo.datastore.put(w2, r.bytes);
          }
          return zj(`Loaded MFS root /ipfs/${r}`), r;
        }
        c();
        function V0(t = "") {
          return (t.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
        }
        var hT = w(K(), 1);
        te();
        var fT = "ipfs", Wr = async (t, e, r) => {
          let n = await K0(t, r), i2 = { entryType: "file" }, o = "";
          if (I.asCID(e) ? o = `/ipfs/${e}` : o = e.toString(), o = o.trim(), o = o.replace(/(\/\/+)/g, "/"), o.endsWith("/") && o.length > 1 && (o = o.substring(0, o.length - 1)), !o)
            throw (0, hT.default)(new Error("paths must not be empty"), "ERR_NO_PATH");
          if (o.substring(0, 1) !== "/")
            throw (0, hT.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
          o.substring(o.length - 1) === "/" && (o = o.substring(0, o.length - 1));
          let s = V0(o);
          if (s[0] === fT) {
            let u;
            s.length === 2 ? u = `/${s.join("/")}` : u = `/${s.slice(0, s.length - 1).join("/")}`, i2 = { type: "ipfs", depth: s.length - 2, entryType: "file", mfsPath: `/${s.join("/")}`, mfsDirectory: u, parts: s, path: `/${s.join("/")}`, name: s[s.length - 1] };
          } else {
            let u = `/${fT}/${n}${s.length ? "/" + s.join("/") : ""}`, l = `/${fT}/${n}/${s.slice(0, s.length - 1).join("/")}`;
            i2 = { type: "mfs", depth: s.length, entryType: "file", mfsDirectory: l, mfsPath: u, parts: s, path: `/${s.join("/")}`, name: s[s.length - 1] };
          }
          let a = i2.type === "mfs" ? i2.mfsPath : i2.path;
          try {
            let u = await ti(a, t.repo.blocks, r);
            i2.cid = u.cid, i2.mfsPath = `/ipfs/${u.path}`, i2.entryType = u.type, i2.content = u.content, (i2.entryType === "file" || i2.entryType === "directory") && (u.type === "file" || u.type === "directory") && (i2.unixfs = u.unixfs);
          } catch (u) {
            if (u.code !== "ERR_NOT_FOUND")
              throw u;
          }
          return i2.exists = Boolean(i2.cid), i2;
        };
        var $j = w(K(), 1);
        var h7e = Ze.bind({ ignoreUndefined: true }), d7e = C("ipfs:mfs:stat"), p7e = { withLocal: false };
        function Nl(t) {
          async function e(r, n = {}) {
            n = h7e(p7e, n), d7e(`Fetching stats for ${r}`);
            let { type: i2, cid: o, mfsPath: s } = await Wr(t, r, n), a = i2 === "ipfs" && o ? o : s, u;
            try {
              u = await ti(a, t.repo.blocks);
            } catch (l) {
              throw l.code === "ERR_NOT_FOUND" ? (0, $j.default)(new Error(`${r} does not exist`), "ERR_NOT_FOUND") : l;
            }
            if (!Hj[u.type])
              throw new Error(`Cannot stat codec ${u.cid.code}`);
            return Hj[u.type](u);
          }
          return B(e);
        }
        var Hj = { raw: (t) => ({ cid: t.cid, size: t.node.length, cumulativeSize: t.node.length, blocks: 0, type: "file", local: void 0, sizeLocal: void 0, withLocality: false }), file: (t) => {
          let e = { cid: t.cid, type: "file", size: t.unixfs.fileSize(), cumulativeSize: je(t.node).length + (t.node.Links || []).reduce((r, n) => r + (n.Tsize || 0), 0), blocks: t.unixfs.blockSizes.length, local: void 0, sizeLocal: void 0, withLocality: false, mode: t.unixfs.mode };
          return t.unixfs.mtime && (e.mtime = t.unixfs.mtime), e;
        }, directory: (t) => {
          let e = { cid: t.cid, type: "directory", size: 0, cumulativeSize: je(t.node).length + (t.node.Links || []).reduce((r, n) => r + (n.Tsize || 0), 0), blocks: t.node.Links.length, local: void 0, sizeLocal: void 0, withLocality: false, mode: t.unixfs.mode };
          return t.unixfs.mtime && (e.mtime = t.unixfs.mtime), e;
        }, object: (t) => ({ cid: t.cid, size: t.node.length, cumulativeSize: t.node.length, type: "file", blocks: 0, local: void 0, sizeLocal: void 0, withLocality: false }), identity: (t) => ({ cid: t.cid, size: t.node.length, cumulativeSize: t.node.length, blocks: 0, type: "file", local: void 0, sizeLocal: void 0, withLocality: false }) };
        c();
        var W0 = w(K(), 1);
        c();
        var m7e = C("ipfs:mfs:utils:to-trail");
        async function Fa(t, e) {
          m7e(`Creating trail for path ${e}`);
          let r = [];
          for await (let n of fA(e, t.repo.blocks))
            r.push({ name: n.name, cid: n.cid, size: n.size, type: n.type });
          return r;
        }
        c();
        te();
        c();
        c();
        te();
        vr();
        var c8 = async (t, e, r) => {
          r.codec || (r.codec = At), r.hasher || (r.hasher = xe), r.cidVersion === void 0 && (r.cidVersion = 1), r.codec === At && r.hasher !== xe && (r.cidVersion = 1);
          let n = await r.hasher.digest(t), i2 = I.create(r.cidVersion, r.codec.code, n);
          return r.onlyHash || await e.put(i2, t, { signal: r.signal }), i2;
        };
        var h8 = w(wy(), 1);
        c();
        var u8 = Sh.code, l8 = 8;
        async function f8(t) {
          return (await Sh.encode(t)).slice(0, 8).reverse();
        }
        var dT = class {
          constructor(e, r) {
            this.options = r || {}, this.root = e.root, this.dir = e.dir, this.path = e.path, this.dirty = e.dirty, this.flat = e.flat, this.parent = e.parent, this.parentKey = e.parentKey, this.unixfs = e.unixfs, this.mode = e.mode, this.mtime = e.mtime, this.cid = void 0, this.size = void 0;
          }
          async put(e, r) {
          }
          get(e) {
            return Promise.resolve(this);
          }
          async *eachChildSeries() {
          }
          async *flush(e) {
          }
        }, q0 = class extends dT {
          constructor(e, r) {
            super(e, r), this._bucket = (0, h8.createHAMT)({ hashFn: f8, bits: l8 });
          }
          async put(e, r) {
            await this._bucket.put(e, r);
          }
          get(e) {
            return this._bucket.get(e);
          }
          childCount() {
            return this._bucket.leafCount();
          }
          directChildrenCount() {
            return this._bucket.childrenCount();
          }
          onlyChild() {
            return this._bucket.onlyChild();
          }
          async *eachChildSeries() {
            for await (let { key: e, value: r } of this._bucket.eachLeafSeries())
              yield { key: e, child: r };
          }
          async *flush(e) {
            yield* Gj(this._bucket, e, this, this.options);
          }
        };
        async function* Gj(t, e, r, n) {
          let i2 = t._children, o = [], s = 0;
          for (let d = 0; d < i2.length; d++) {
            let m = i2.get(d);
            if (!m)
              continue;
            let y = d.toString(16).toUpperCase().padStart(2, "0");
            if (m instanceof h8.Bucket) {
              let g;
              for await (let E of await Gj(m, e, null, n))
                g = E;
              if (!g)
                throw new Error("Could not flush sharded directory, no subshard found");
              o.push({ Name: y, Tsize: g.size, Hash: g.cid }), s += g.size;
            } else if (typeof m.value.flush == "function") {
              let g = m.value, E;
              for await (let v of g.flush(e))
                E = v, yield E;
              let b = y + m.key;
              o.push({ Name: b, Tsize: E.size, Hash: E.cid }), s += E.size;
            } else {
              let g = m.value;
              if (!g.cid)
                continue;
              let E = y + m.key, b = g.size;
              o.push({ Name: E, Tsize: b, Hash: g.cid }), s += b;
            }
          }
          let a = Uint8Array.from(i2.bitField().reverse()), l = { Data: new Je({ type: "hamt-sharded-directory", data: a, fanout: t.tableSize(), hashType: u8, mtime: r && r.mtime, mode: r && r.mode }).marshal(), Links: o }, f = je(Ln(l)), h = await c8(f, e, n), p = f.length + s;
          yield { cid: h, node: l, size: p };
        }
        c();
        var z0 = w(wy(), 1);
        var Wj = w(qi(), 1);
        te();
        var jy = C("ipfs:mfs:core:utils:hamt-utils"), H0 = async (t, e, r, n) => {
          if (!n.parent.Data)
            throw new Error("Could not update HAMT directory because parent had no data");
          let i2 = Uint8Array.from(r._children.bitField().reverse()), o = Je.unmarshal(n.parent.Data), s = new Je({ type: "hamt-sharded-directory", data: i2, fanout: r.tableSize(), hashType: u8, mode: o.mode, mtime: o.mtime }), a = await t.hashers.getHasher(n.hashAlg), u = { Data: s.marshal(), Links: e.sort((p, d) => (p.Name || "").localeCompare(d.Name || "")) }, l = je(u), f = await a.digest(l), h = I.create(n.cidVersion, pt, f);
          return n.flush && await t.repo.blocks.put(h, l), { node: u, cid: h, size: e.reduce((p, d) => p + (d.Tsize || 0), l.length) };
        }, pT = async (t, e, r, n, i2) => {
          let o = new z0.Bucket({ hash: r._options.hash, bits: r._options.bits }, n, i2);
          return n._putObjectAt(i2, o), await Yy(t, e, o, r), o;
        }, mT = async (t) => {
          let e = (0, z0.createHAMT)({ hashFn: f8, bits: l8 });
          return await Promise.all(t.map(async (r) => {
            let n = r.Name || "";
            if (n.length === 2) {
              let i2 = parseInt(n, 16), o = new z0.Bucket({ hash: e._options.hash, bits: e._options.bits }, e, i2);
              return e._putObjectAt(i2, o), Promise.resolve();
            }
            return e.put(n.substring(2), { size: r.Tsize, cid: r.Hash });
          })), e;
        }, Yy = async (t, e, r, n) => {
          await Promise.all(e.map(async (i2) => {
            let o = i2.Name || "";
            if (o.length === 2) {
              jy("Populating sub bucket", o);
              let s = parseInt(o, 16), a = await t.repo.blocks.get(i2.Hash), u = Rt(a), l = new z0.Bucket({ hash: n._options.hash, bits: n._options.bits }, r, s);
              return r._putObjectAt(s, l), await Yy(t, u.Links, l, n), Promise.resolve();
            }
            return n.put(o.substring(2), { size: i2.Tsize, cid: i2.Hash });
          }));
        }, Fh = (t) => t.toString(16).toUpperCase().padStart(2, "0").substring(0, 2), jj = async (t, e, r) => {
          let n = await mT(r.Links), i2 = await n._findNewBucketAndPos(e), o = [{ bucket: i2.bucket, prefix: Fh(i2.pos) }], s = i2.bucket;
          for (; s !== n; )
            o.push({ bucket: s, prefix: Fh(s._posAtParent) }), s = s._parent;
          o.reverse(), o[0].node = r;
          for (let a = 0; a < o.length; a++) {
            let u = o[a];
            if (!u.node)
              throw new Error("Could not generate HAMT path");
            let l = u.node.Links.filter((d) => (d.Name || "").substring(0, 2) === u.prefix).pop();
            if (!l) {
              jy(`Link ${u.prefix}${e} will be added`);
              continue;
            }
            if (l.Name === `${u.prefix}${e}`) {
              jy(`Link ${u.prefix}${e} will be replaced`);
              continue;
            }
            jy(`Found subshard ${u.prefix}`);
            let f = await t.repo.blocks.get(l.Hash), h = Rt(f);
            if (!o[a + 1]) {
              jy(`Loaded new subshard ${u.prefix}`), await pT(t, h.Links, n, u.bucket, parseInt(u.prefix, 16));
              let d = await n._findNewBucketAndPos(e);
              o.push({ bucket: d.bucket, prefix: Fh(d.pos), node: h });
              continue;
            }
            let p = o[a + 1];
            await Yy(t, h.Links, p.bucket, n), p.node = h;
          }
          return await n.put(e, true), o.reverse(), { rootBucket: n, path: o };
        }, Yj = async (t, e, r = {}) => {
          let n = new q0({ root: true, dir: true, parent: void 0, parentKey: void 0, path: "", dirty: true, flat: false, mtime: r.mtime, mode: r.mode }, r);
          for (let o = 0; o < e.length; o++)
            await n._bucket.put(e[o].name, { size: e[o].size, cid: e[o].cid });
          let i2 = await (0, Wj.default)(n.flush(t.repo.blocks));
          if (!i2)
            throw new Error("Flushing shard yielded no result");
          return i2;
        };
        var Ka = w(K(), 1), Qj = w(qi(), 1), Va = C("ipfs:mfs:core:utils:add-link");
        async function ns(t, e) {
          let r = e.parent;
          if (e.parentCid) {
            let i2 = I.asCID(e.parentCid);
            if (i2 === null)
              throw (0, Ka.default)(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
            if (i2.code !== pt)
              throw (0, Ka.default)(new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
            Va(`Loading parent node ${i2}`);
            let o = await t.repo.blocks.get(i2);
            r = Rt(o);
          }
          if (!r)
            throw (0, Ka.default)(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
          if (!e.cid)
            throw (0, Ka.default)(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
          if (!e.name)
            throw (0, Ka.default)(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
          if (!e.size && e.size !== 0)
            throw (0, Ka.default)(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
          if (!r.Data)
            throw (0, Ka.default)(new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
          let n = Je.unmarshal(r.Data);
          return n.type === "hamt-sharded-directory" ? (Va("Adding link to sharded directory"), w7e(t, { ...e, parent: r })) : r.Links.length >= e.shardSplitThreshold ? (Va("Converting directory to sharded directory"), y7e(t, { ...e, parent: r, mtime: n.mtime, mode: n.mode })) : (Va(`Adding ${e.name} (${e.cid}) to regular directory`), g7e(t, { ...e, parent: r }));
        }
        var y7e = async (t, e) => {
          let r = await Yj(t, e.parent.Links.map((n) => ({ name: n.Name || "", size: n.Tsize || 0, cid: n.Hash })).concat({ name: e.name, size: e.size, cid: e.cid }), e);
          return Va(`Converted directory to sharded directory ${r.cid}`), r;
        }, g7e = async (t, e) => {
          let r = e.parent.Links.filter((l) => l.Name !== e.name);
          if (r.push({ Name: e.name, Tsize: e.size, Hash: e.cid }), !e.parent.Data)
            throw (0, Ka.default)(new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
          let n = Je.unmarshal(e.parent.Data), i2;
          if (n.mtime) {
            let l = Date.now(), f = Math.floor(l / 1e3);
            n.mtime = { secs: f, nsecs: (l - f * 1e3) * 1e3 }, i2 = n.marshal();
          } else
            i2 = e.parent.Data;
          e.parent = Ln({ Data: i2, Links: r });
          let o = await t.hashers.getHasher(e.hashAlg), s = je(e.parent), a = await o.digest(s), u = I.create(e.cidVersion, pt, a);
          return e.flush && await t.repo.blocks.put(u, s), { node: e.parent, cid: u, size: s.length };
        }, w7e = async (t, e) => {
          let { shard: r, path: n } = await E7e(t, e), i2 = await (0, Qj.default)(r.flush(t.repo.blocks));
          if (!i2)
            throw new Error("No result from flushing shard");
          let o = await t.repo.blocks.get(i2.cid), s = Rt(o), a = e.parent.Links.filter((l) => (l.Name || "").substring(0, 2) !== n[0].prefix), u = s.Links.find((l) => (l.Name || "").substring(0, 2) === n[0].prefix);
          if (!u)
            throw new Error(`No link found with prefix ${n[0].prefix}`);
          return a.push(u), H0(t, a, n[0].bucket, e);
        }, E7e = async (t, e) => {
          let r = { name: e.name, cid: e.cid, size: e.size };
          if (!e.parent.Data)
            throw (0, Ka.default)(new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
          let n = await mT(e.parent.Links), i2 = Je.unmarshal(e.parent.Data), o = new q0({ root: true, dir: true, parent: void 0, parentKey: void 0, path: "", dirty: true, flat: false, mode: i2.mode }, e);
          o._bucket = n, i2.mtime && (o.mtime = { secs: Math.round(Date.now() / 1e3) });
          let s = await n._findNewBucketAndPos(r.name), a = b7e(s);
          a[0].node = e.parent;
          let u = 0;
          for (; u < a.length; ) {
            let l = a[u];
            u++;
            let f = l.node;
            if (!f)
              throw new Error("Segment had no node");
            let h = f.Links.find((y) => (y.Name || "").substring(0, 2) === l.prefix);
            if (!h) {
              Va(`Link ${l.prefix}${r.name} will be added`), u = a.length;
              break;
            }
            if (h.Name === `${l.prefix}${r.name}`) {
              Va(`Link ${l.prefix}${r.name} will be replaced`), u = a.length;
              break;
            }
            if ((h.Name || "").length > 2) {
              Va(`Link ${h.Name} ${h.Hash} will be replaced with a subshard`), u = a.length;
              break;
            }
            Va(`Found subshard ${l.prefix}`);
            let p = await t.repo.blocks.get(h.Hash), d = Rt(p);
            if (!a[u]) {
              Va(`Loaded new subshard ${l.prefix}`), await pT(t, d.Links, n, l.bucket, parseInt(l.prefix, 16));
              let y = await n._findNewBucketAndPos(r.name);
              a.push({ bucket: y.bucket, prefix: Fh(y.pos), node: d });
              break;
            }
            let m = a[u];
            await Yy(t, d.Links, m.bucket, n), m.node = d;
          }
          return await o._bucket.put(r.name, { size: r.size, cid: r.cid }), { shard: o, path: a };
        }, b7e = (t) => {
          let e = [{ bucket: t.bucket, prefix: Fh(t.pos) }], r = t.bucket._parent, n = t.bucket._posAtParent;
          for (; r; )
            e.push({ bucket: r, prefix: Fh(n) }), n = r._posAtParent, r = r._parent;
          return e.reverse(), e;
        };
        c();
        var Xj = C("ipfs:mfs:utils:update-tree"), _7e = { shardSplitThreshold: 1e3 };
        async function go(t, e, r) {
          r = Object.assign({}, _7e, r), Xj("Trail", e), e = e.slice().reverse();
          let n = 0, i2;
          for await (let s of t.repo.blocks.getMany(e.map((a) => a.cid))) {
            let a = Rt(s), u = e[n].cid, l = e[n].name;
            if (n++, !i2) {
              i2 = { cid: u, name: l, size: s.length };
              continue;
            }
            let f = await ns(t, { parent: a, name: i2.name, cid: i2.cid, size: i2.size, flush: r.flush, shardSplitThreshold: r.shardSplitThreshold, hashAlg: r.hashAlg, cidVersion: r.cidVersion });
            i2 = { cid: f.cid, name: l, size: f.size };
          }
          let { cid: o } = i2;
          return Xj(`Final CID ${o}`), o;
        }
        c();
        var Zj = w(K(), 1), v7e = C("ipfs:mfs:utils:update-mfs-root");
        async function wo(t, e, r) {
          if (r && r.signal && r.signal.aborted)
            throw (0, Zj.default)(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
          return v7e(`New MFS root will be ${e}`), await t.repo.datastore.put(w2, e.bytes), e;
        }
        te();
        var aY = w(qi(), 1);
        c();
        c();
        var Kh = w(K(), 1);
        c();
        te();
        async function Jj(t, e, r) {
          let n = new Je({ type: e, mode: r.mode, mtime: r.mtime }), i2 = await t.hashers.getHasher(r.hashAlg), o = { Data: n.marshal(), Links: [] }, s = je(o), a = await i2.digest(s), u = I.create(r.cidVersion, pt, a);
          return r.flush && await t.repo.blocks.put(u, s), { cid: u, node: o };
        }
        var S7e = Ze.bind({ ignoreUndefined: true }), eY = C("ipfs:mfs:mkdir"), x7e = { parents: false, hashAlg: "sha2-256", cidVersion: 0, shardSplitThreshold: 1e3, flush: true };
        function Vh(t) {
          async function e(r, n = {}) {
            let i2 = S7e(x7e, n);
            if (!r)
              throw new Error("no path given to Mkdir");
            if (r = r.trim(), r === "/") {
              if (i2.parents)
                return;
              throw (0, Kh.default)(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
            }
            if (r.substring(0, 1) !== "/")
              throw (0, Kh.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
            eY(`Creating ${r}`);
            let o = V0(r);
            if (o[0] === "ipfs")
              throw (0, Kh.default)(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
            let s = await K0(t, i2), a, u = [], l = await Jj(t, "directory", i2);
            for (let h = 0; h <= o.length; h++) {
              let p = o.slice(0, h), d = `/ipfs/${s}/${p.join("/")}`;
              try {
                if (a = await ti(d, t.repo.blocks), a.type !== "file" && a.type !== "directory")
                  throw (0, Kh.default)(new Error(`${r} was not a UnixFS node`), "ERR_NOT_UNIXFS");
                if (h === o.length) {
                  if (i2.parents)
                    return;
                  throw (0, Kh.default)(new Error("file already exists"), "ERR_ALREADY_EXISTS");
                }
                u.push({ name: a.name, cid: a.cid });
              } catch (m) {
                if (m.code === "ERR_NOT_FOUND") {
                  if (h < o.length && !i2.parents)
                    throw (0, Kh.default)(new Error(`Intermediate directory path ${d} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
                  await R7e(t, p[p.length - 1], l, u[u.length - 1], u, i2);
                } else
                  throw m;
              }
            }
            let f = await go(t, u, i2);
            await wo(t, f, i2);
          }
          return B(e);
        }
        var R7e = async (t, e, r, n, i2, o) => {
          eY(`Adding empty dir called ${e} to ${n.cid}`);
          let s = await ns(t, { parent: n.node, parentCid: n.cid, size: 0, cid: r.cid, name: e, hashAlg: o.hashAlg, cidVersion: o.cidVersion, flush: o.flush, shardSplitThreshold: o.shardSplitThreshold });
          i2[i2.length - 1].cid = s.cid, i2.push({ name: e, cid: r.cid });
        };
        var Ol = w(K(), 1);
        var A7e = Ze.bind({ ignoreUndefined: true }), d8 = C("ipfs:mfs:cp"), T7e = { parents: false, flush: true, hashAlg: "sha2-256", cidVersion: 0, shardSplitThreshold: 1e3 };
        function $0(t) {
          async function e(r, n, i2 = {}) {
            let o = A7e(T7e, i2);
            Array.isArray(r) || (r = [r]);
            let s = await Promise.all(r.map((p) => Wr(t, p, o))), a = await Wr(t, n, o);
            if (!s.length || !a)
              throw (0, Ol.default)(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
            let u = s.find((p) => !p.exists);
            if (u)
              throw (0, Ol.default)(new Error(`${u.path} does not exist`), "ERR_INVALID_PARAMS");
            let l = tY(a);
            if (a.exists) {
              if (d8("Destination exists"), s.length === 1 && !l)
                throw (0, Ol.default)(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
            } else if (d8("Destination does not exist"), s.length > 1) {
              if (!o.parents)
                throw (0, Ol.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
              await Vh(t)(a.path, o), a = await Wr(t, a.path, o);
            } else if (a.parts.length > 1) {
              let p = `/${a.parts.slice(0, -1).join("/")}`;
              try {
                await Nl(t)(p, o);
              } catch (d) {
                if (d.code !== "ERR_NOT_FOUND")
                  throw d;
                if (!o.parents)
                  throw (0, Ol.default)(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
                await Vh(t)(p, o), a = await Wr(t, a.path, o);
              }
            }
            let f = tY(a) ? a.mfsPath : a.mfsDirectory, h = await Fa(t, f);
            if (s.length === 1) {
              let p = s.pop();
              if (!p)
                throw (0, Ol.default)(new Error("could not find source"), "ERR_INVALID_PARAMS");
              let d = l ? p.name : a.name;
              return d8(`Only one source, copying to destination ${l ? "directory" : "file"} ${d}`), I7e(t, p, d, h, o);
            }
            return d8("Multiple sources, wrapping in a directory"), C7e(t, s, a, h, o);
          }
          return B(e);
        }
        var tY = (t) => t.unixfs && t.unixfs.type && t.unixfs.type.includes("directory"), I7e = async (t, e, r, n, i2) => {
          let o = n.pop();
          if (!o)
            throw (0, Ol.default)(new Error("destination had no parent"), "ERR_INVALID_PARAMS");
          o = await rY(t, e, r, o, i2), n.push(o);
          let s = await go(t, n, i2);
          await wo(t, s, i2);
        }, C7e = async (t, e, r, n, i2) => {
          for (let s = 0; s < e.length; s++) {
            let a = e[s];
            r = await rY(t, a, a.name, r, i2);
          }
          n[n.length - 1] = r;
          let o = await go(t, n, i2);
          await wo(t, o, i2);
        }, rY = async (t, e, r, n, i2) => {
          let o = await t.repo.blocks.get(e.cid), { node: s, cid: a, size: u } = await ns(t, { parentCid: n.cid, size: o.length, cid: e.cid, name: r, hashAlg: i2.hashAlg, cidVersion: i2.cidVersion, flush: i2.flush, shardSplitThreshold: i2.shardSplitThreshold });
          return n.node = s, n.cid = a, n.size = u, n;
        };
        c();
        var Qy = w(K(), 1);
        c();
        te();
        var Ll = w(K(), 1), Bl = C("ipfs:mfs:core:utils:remove-link");
        async function nY(t, e) {
          let r = e.parent;
          if (e.parentCid) {
            let i2 = I.asCID(e.parentCid);
            if (i2 === null)
              throw (0, Ll.default)(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
            Bl(`Loading parent node ${i2}`);
            let o = await t.repo.blocks.get(i2);
            r = Rt(o);
          }
          if (!r)
            throw (0, Ll.default)(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
          if (!e.name)
            throw (0, Ll.default)(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
          if (!r.Data)
            throw (0, Ll.default)(new Error("Parent node had no data"), "ERR_INVALID_NODE");
          return Je.unmarshal(r.Data).type === "hamt-sharded-directory" ? (Bl(`Removing ${e.name} from sharded directory`), D7e(t, { ...e, parent: r })) : (Bl(`Removing link ${e.name} regular directory`), P7e(t, { ...e, parent: r }));
        }
        var P7e = async (t, e) => {
          e.parent.Links = e.parent.Links.filter((s) => s.Name !== e.name);
          let r = await je(e.parent), i2 = await (await t.hashers.getHasher(e.hashAlg)).digest(r), o = I.create(e.cidVersion, pt, i2);
          return await t.repo.blocks.put(o, r), Bl(`Updated regular directory ${o}`), { node: e.parent, cid: o };
        }, D7e = async (t, e) => {
          let { rootBucket: r, path: n } = await jj(t, e.name, e.parent);
          await r.del(e.name);
          let { node: i2 } = await iY(t, n, e.name, e);
          return H0(t, i2.Links, r, e);
        }, iY = async (t, e, r, n) => {
          let i2 = e.pop();
          if (!i2)
            throw (0, Ll.default)(new Error("Could not find parent"), "EINVALIDPARENT");
          let { bucket: o, prefix: s, node: a } = i2;
          if (!a)
            throw (0, Ll.default)(new Error("Could not find parent"), "EINVALIDPARENT");
          let u = a.Links.find((d) => (d.Name || "").substring(0, 2) === s);
          if (!u)
            throw (0, Ll.default)(new Error(`No link found with prefix ${s} for file ${r}`), "ERR_NOT_FOUND");
          if (u.Name === `${s}${r}`) {
            Bl(`Removing existing link ${u.Name}`);
            let d = a.Links.filter((m) => m.Name !== u.Name);
            return await o.del(r), H0(t, d, o, n);
          }
          Bl(`Descending into sub-shard ${u.Name} for ${s}${r}`);
          let l = await iY(t, e, r, n), f = l.cid, h = l.size, p = s;
          if (l.node.Links.length === 1) {
            Bl(`Removing subshard for ${s}`);
            let d = l.node.Links[0];
            p = `${s}${(d.Name || "").substring(2)}`, f = d.Hash, h = d.Tsize || 0;
          }
          return Bl(`Updating shard ${s} with name ${p}`), k7e(t, o, a, s, p, h, f, n);
        }, k7e = (t, e, r, n, i2, o, s, a) => {
          let u = r.Links.filter((l) => l.Name !== n);
          return u.push({ Name: i2, Tsize: o, Hash: s }), H0(t, u, e, a);
        };
        var N7e = Ze.bind({ ignoreUndefined: true }), O7e = { recursive: false, cidVersion: 0, hashAlg: "sha2-256", flush: true, shardSplitThreshold: 1e3 };
        function G0(t) {
          async function e(r, n = {}) {
            let i2 = N7e(O7e, n);
            Array.isArray(r) || (r = [r]);
            let o = await Promise.all(r.map((s) => Wr(t, s, i2)));
            if (!o.length)
              throw (0, Qy.default)(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
            o.forEach((s) => {
              if (s.path === "/")
                throw (0, Qy.default)(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
            });
            for (let s of o)
              await L7e(t, s.path, i2);
          }
          return B(e);
        }
        var L7e = async (t, e, r) => {
          let n = await Wr(t, e, r), i2 = await Fa(t, n.mfsPath), o = i2[i2.length - 1];
          i2.pop();
          let s = i2[i2.length - 1];
          if (!s)
            throw (0, Qy.default)(new Error(`${e} does not exist`), "ERR_NOT_FOUND");
          if (o.type === "directory" && !r.recursive)
            throw (0, Qy.default)(new Error(`${e} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
          let { cid: a } = await nY(t, { parentCid: s.cid, name: o.name, hashAlg: r.hashAlg, cidVersion: r.cidVersion, flush: r.flush, shardSplitThreshold: r.shardSplitThreshold });
          s.cid = a;
          let u = await go(t, i2, r);
          await wo(t, u, r);
        };
        var B7e = Ze.bind({ ignoreUndefined: true }), M7e = C("ipfs:mfs:touch"), oY = { flush: true, shardSplitThreshold: 1e3, hashAlg: "sha2-256", cidVersion: 0, recursive: false };
        function U7e(t, e, r) {
          let n = 0;
          return (t.includes("x") || t.includes("X") && (r || e & 1 || e & 8 || e & 64)) && (n += 1), t.includes("w") && (n += 2), t.includes("r") && (n += 4), n;
        }
        function F7e(t, e) {
          let r = 0;
          return t.includes("u") && (r += e << 6), t.includes("g") && (r += e << 3), t.includes("o") && (r += e), r;
        }
        function K7e(t, e, r) {
          return e.includes("t") && (r += parseInt("1000", 8)), e.includes("s") && (t.includes("u") && (r += parseInt("4000", 8)), t.includes("g") && (r += parseInt("2000", 8))), r;
        }
        function V7e(t, e, r) {
          e || (e = 0);
          let n = t.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
          if (!n)
            throw new Error(`Invalid file mode: ${t}`);
          let [, i2, o, s] = n;
          (i2 === "a" || !i2) && (i2 = "ugo");
          let a = U7e(s, e, r);
          return a = F7e(i2, a), a = K7e(i2, s, a), o === "=" ? (i2.includes("u") && (e = e & parseInt("7077", 8), e = e | a), i2.includes("g") && (e = e & parseInt("7707", 8), e = e | a), i2.includes("o") && (e = e & parseInt("7770", 8), e = e | a), e) : o === "+" ? a | e : o === "-" ? a ^ e : e;
        }
        function sY(t, e) {
          if (t instanceof String || typeof t == "string") {
            let r = `${t}`;
            r.match(/^\d+$/g) ? t = parseInt(r, 8) : t = 0 + r.split(",").reduce((n, i2) => V7e(i2, n, e.isDirectory()), e.mode || 0);
          }
          return t;
        }
        function cY(t) {
          async function e(r, n, i2 = {}) {
            let o = B7e(oY, i2);
            M7e(`Fetching stats for ${r}`);
            let { cid: s, mfsDirectory: a, name: u } = await Wr(t, r, o);
            if (s.code !== pt)
              throw (0, W0.default)(new Error(`${r} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            if (o.recursive) {
              let O = await Te(async function* () {
                for await (let F of x5(s, t.repo.blocks)) {
                  if (F.type !== "file" && F.type !== "directory")
                    throw (0, W0.default)(new Error(`${r} was not a UnixFS node`), "ERR_NOT_UNIXFS");
                  F.unixfs.mode = sY(n, F.unixfs);
                  let z = Ln({ Data: F.unixfs.marshal(), Links: F.node.Links });
                  yield { path: F.path, content: z };
                }
              }, (F) => x0(F, t.repo.blocks, { ...o, pin: false, dagBuilder: async function* (z, W, se) {
                for await (let re2 of z)
                  yield async function() {
                    let Ge = re2.content, ge = je(Ge), ke = await c8(ge, W, se);
                    if (!Ge.Data)
                      throw (0, W0.default)(new Error(`${ke} had no data`), "ERR_INVALID_NODE");
                    let H = Je.unmarshal(Ge.Data);
                    return { cid: ke, size: ge.length, path: re2.path, unixfs: H };
                  };
              } }), (F) => (0, aY.default)(F));
              if (!O)
                throw (0, W0.default)(new Error(`Could not chmod ${r}`), "ERR_COULD_NOT_CHMOD");
              await G0(t)(r, o), await $0(t)(`/ipfs/${O.cid}`, r, o);
              return;
            }
            let l = await t.repo.blocks.get(s), f = Rt(l);
            if (!f.Data)
              throw (0, W0.default)(new Error(`${s} had no data`), "ERR_INVALID_NODE");
            let h = Je.unmarshal(f.Data);
            h.mode = sY(n, h);
            let p = je({ Data: h.marshal(), Links: f.Links }), d = o.hashAlg || oY.hashAlg, y = await (await t.hashers.getHasher(d)).digest(p), g = I.create(o.cidVersion, pt, y);
            o.flush && await t.repo.blocks.put(g, p);
            let E = await Fa(t, a), b = E[E.length - 1], v = I.decode(b.cid.bytes), S = await t.repo.blocks.get(v), x = Rt(S), T = await ns(t, { parent: x, name: u, cid: g, size: p.length, flush: o.flush, hashAlg: d, cidVersion: s.version, shardSplitThreshold: 1 / 0 });
            b.cid = T.cid;
            let R = await go(t, E, o);
            await wo(t, R, o);
          }
          return B(e);
        }
        c();
        var q7e = Ze.bind({ ignoreUndefined: true }), z7e = {};
        function uY(t) {
          async function e(r, n = {}) {
            n = q7e(z7e, n);
            let { cid: i2 } = await Nl(t)(r, n);
            return i2;
          }
          return B(e);
        }
        c();
        var H7e = Ze.bind({ ignoreUndefined: true }), $7e = { parents: false, flush: true, cidVersion: 0, hashAlg: "sha2-256", shardSplitThreshold: 1e3 };
        function lY(t) {
          async function e(r, n, i2 = {}) {
            let o = H7e($7e, i2);
            await $0(t)(r, n, o), await G0(t)(r, { ...o, recursive: true });
          }
          return B(e);
        }
        c();
        var yT = w(K(), 1);
        te();
        var G7e = Ze.bind({ ignoreUndefined: true }), W7e = C("ipfs:mfs:touch"), fY = { flush: true, shardSplitThreshold: 1e3, cidVersion: 0, hashAlg: "sha2-256" };
        function hY(t) {
          async function e(r, n = {}) {
            let i2 = G7e(fY, n);
            i2.mtime = i2.mtime || new Date(), W7e(`Touching ${r} mtime: ${i2.mtime}`);
            let { cid: o, mfsDirectory: s, name: a, exists: u } = await Wr(t, r, i2), l = n.hashAlg || fY.hashAlg, f = await t.hashers.getHasher(l), h, p, d = i2.cidVersion;
            if (u) {
              if (o.code !== pt)
                throw (0, yT.default)(new Error(`${r} was not a UnixFS node`), "ERR_NOT_UNIXFS");
              d = o.version;
              let x = await t.repo.blocks.get(o), T = Rt(x);
              if (!T.Data)
                throw (0, yT.default)(new Error(`${r} had no data`), "ERR_INVALID_NODE");
              let R = Je.unmarshal(T.Data);
              R.mtime = i2.mtime, h = je({ Data: R.marshal(), Links: T.Links });
              let O = await f.digest(h);
              p = I.create(i2.cidVersion, pt, O), i2.flush && await t.repo.blocks.put(p, h);
            } else {
              let x = new Je({ type: "file", mtime: i2.mtime });
              h = je({ Data: x.marshal(), Links: [] });
              let T = await f.digest(h);
              p = I.create(i2.cidVersion, pt, T), i2.flush && await t.repo.blocks.put(p, h);
            }
            let m = await Fa(t, s), y = m[m.length - 1], g = y.cid, E = await t.repo.blocks.get(g), b = Rt(E), v = await ns(t, { parent: b, name: a, cid: p, size: h.length, flush: i2.flush, shardSplitThreshold: i2.shardSplitThreshold, hashAlg: i2.hashAlg, cidVersion: d });
            y.cid = v.cid;
            let S = await go(t, m, i2);
            await wo(t, S, i2);
          }
          return B(e);
        }
        c();
        var gT = w(K(), 1);
        var j7e = Ze.bind({ ignoreUndefined: true }), Y7e = { offset: 0, length: 1 / 0 };
        function dY(t) {
          function e(r, n = {}) {
            return n = j7e(Y7e, n), { [Symbol.asyncIterator]: async function* () {
              let o = await Wr(t, r, n), s = await ti(o.mfsPath, t.repo.blocks);
              if (s.type !== "file")
                throw (0, gT.default)(new Error(`${r} was not a file`), "ERR_NOT_FILE");
              if (!s.content)
                throw (0, gT.default)(new Error(`Could not load content stream from ${r}`), "ERR_NO_CONTENT");
              for await (let a of s.content({ offset: n.offset, length: n.length }))
                yield a;
            } };
          }
          return B(e);
        }
        c();
        c();
        var wT = w(K(), 1);
        Re();
        var Xy = C("ipfs:mfs:utils:to-async-iterator");
        function pY(t) {
          if (!t)
            throw (0, wT.default)(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
          if ((typeof t == "string" || t instanceof String) && (Xy("Content was a string"), t = U(t.toString())), t.length)
            return Xy("Content was array-like"), { [Symbol.asyncIterator]: function* () {
              yield t;
            } };
          if (t[Symbol.asyncIterator])
            return Xy("Content was an async iterator"), t;
          if (t[Symbol.iterator])
            return Xy("Content was an iterator"), t;
          if (globalThis.Blob && t instanceof globalThis.Blob) {
            Xy("Content was an HTML5 Blob");
            let e = 0, r = { next: () => e > t.size ? { done: true } : new Promise((n, i2) => {
              let o = t.slice(e, E2);
              e += E2;
              let s = new globalThis.FileReader(), a = (u) => {
                if (s.removeEventListener("loadend", a, false), u.error)
                  return i2(u.error);
                n({ done: false, value: new Uint8Array(s.result) });
              };
              s.addEventListener("loadend", a), s.readAsArrayBuffer(o);
            }) };
            return { [Symbol.asyncIterator]: () => r };
          }
          throw (0, wT.default)(new Error(`Don't know how to convert ${t} into an async iterator`), "ERR_INVALID_PARAMS");
        }
        var za = w(K(), 1);
        var yY = w(qi(), 1);
        var Q7e = Ze.bind({ ignoreUndefined: true }), qa = C("ipfs:mfs:write"), X7e = { offset: 0, length: 1 / 0, create: false, truncate: false, rawLeaves: false, reduceSingleLeafToSelf: false, cidVersion: 0, hashAlg: "sha2-256", parents: false, progress: (t, e) => {
        }, strategy: "trickle", flush: true, leafType: "raw", shardSplitThreshold: 1e3 };
        function gY(t) {
          async function e(r, n, i2 = {}) {
            let o = Q7e(X7e, i2), s, a, u;
            if (qa("Reading source, destination and parent"), await Wy().readLock(async () => {
              s = await pY(n), a = await Wr(t, r, o), u = await Wr(t, a.mfsDirectory, o);
            })(), qa("Read source, destination and parent"), !o.parents && !u.exists)
              throw (0, za.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
            if (s == null)
              throw (0, za.default)(new Error("could not create source"), "ERR_NO_SOURCE");
            if (a == null)
              throw (0, za.default)(new Error("could not create destination"), "ERR_NO_DESTINATION");
            if (!o.create && !a.exists)
              throw (0, za.default)(new Error("file does not exist"), "ERR_NO_EXIST");
            if (a.entryType !== "file")
              throw (0, za.default)(new Error("not a file"), "ERR_NOT_A_FILE");
            return Z7e(t, r, s, a, o);
          }
          return B(e);
        }
        var Z7e = async (t, e, r, n, i2) => {
          let o = await J7e(t, r, n, i2);
          await Wy().writeLock(async () => {
            let s = V0(e), a = s.pop();
            if (a == null)
              throw (0, za.default)(new Error("source does not exist"), "ERR_NO_EXIST");
            let u = false;
            try {
              await Nl(t)(`/${s.join("/")}`, i2), u = true;
            } catch (g) {
              if (g.code !== "ERR_NOT_FOUND")
                throw g;
            }
            u || await Vh(t)(`/${s.join("/")}`, i2);
            let l = await Wr(t, e, i2), f = await Fa(t, l.mfsDirectory), h = f[f.length - 1];
            if (!h)
              throw (0, za.default)(new Error("directory does not exist"), "ERR_NO_EXIST");
            if (!h.type || !h.type.includes("directory"))
              throw (0, za.default)(new Error(`cannot write to ${h.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
            let p = await t.repo.blocks.get(h.cid), d = Rt(p), m = await ns(t, { parent: d, name: a, cid: o.cid, size: o.size, flush: i2.flush, shardSplitThreshold: i2.shardSplitThreshold, hashAlg: i2.hashAlg, cidVersion: i2.cidVersion });
            h.cid = m.cid;
            let y = await go(t, f, i2);
            await wo(t, y, i2);
          })();
        }, J7e = async (t, e, r, n) => {
          r.exists ? qa(`Overwriting file ${r.cid} offset ${n.offset} length ${n.length}`) : qa(`Writing file offset ${n.offset} length ${n.length}`);
          let i2 = [];
          if (n.offset > 0)
            if (r.unixfs) {
              if (qa(`Writing first ${n.offset} bytes of original file`), i2.push(() => r.content({ offset: 0, length: n.offset })), r.unixfs.fileSize() < n.offset) {
                let f = n.offset - r.unixfs.fileSize();
                qa(`Writing zeros for extra ${f} bytes`), i2.push(mY(f));
              }
            } else
              qa(`Writing zeros for first ${n.offset} bytes`), i2.push(mY(n.offset));
          i2.push(wY(e, n.length));
          let o = t9e(e9e(i2), (f) => {
            if (r.unixfs && !n.truncate) {
              let h = r.unixfs.fileSize();
              if (h > f)
                return qa(`Writing last ${h - f} of ${h} bytes from original file starting at offset ${f}`), r.content({ offset: f });
              qa("Not writing last bytes from original file");
            }
            return { [Symbol.asyncIterator]: async function* () {
            } };
          }), s;
          n.mode !== void 0 && n.mode !== null ? s = Ec(n.mode) : r && r.unixfs && (s = r.unixfs.mode);
          let a;
          n.mtime != null ? a = qu(n.mtime) : r && r.unixfs && (a = r.unixfs.mtime);
          let u = await t.hashers.getHasher(n.hashAlg), l = await (0, yY.default)(x0([{ content: o, mode: s, mtime: a }], t.repo.blocks, { progress: n.progress, hasher: u, cidVersion: n.cidVersion, strategy: n.strategy, rawLeaves: n.rawLeaves, reduceSingleLeafToSelf: n.reduceSingleLeafToSelf, leafType: n.leafType }));
          if (!l)
            throw (0, za.default)(new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
          return qa(`Wrote ${l.cid}`), { cid: l.cid, size: l.size };
        }, wY = (t, e) => async function* () {
          let n = 0;
          for await (let i2 of t) {
            if (n += i2.length, n > e) {
              yield i2.slice(0, e - n);
              return;
            }
            yield i2;
          }
        }, mY = (t, e = E2) => {
          let r = new Uint8Array(e);
          async function* n() {
            for (; ; )
              yield r.slice();
          }
          return wY(n(), t);
        }, e9e = async function* (t) {
          for (let e = 0; e < t.length; e++)
            yield* t[e]();
        }, t9e = async function* (t, e) {
          let r = 0;
          for await (let n of t)
            r += n.length, yield n;
          for await (let n of e(r))
            r += n.length, yield n;
        };
        c();
        var bY = w(ei(), 1), EY = (t) => {
          let e = { cid: t.cid, name: t.name, type: t.type === "directory" ? "directory" : "file", size: t.size };
          return (t.type === "file" || t.type === "directory") && (e.mode = t.unixfs.mode, e.mtime = t.unixfs.mtime), e;
        };
        function _Y(t) {
          async function* e(r, n = {}) {
            let i2 = await Wr(t, r, n), o = await ti(i2.mfsPath, t.repo.blocks);
            if (o.type === "directory") {
              yield* (0, bY.default)(o.content(n), EY);
              return;
            }
            yield EY(o);
          }
          return B(e);
        }
        var r9e = { stat: Nl }, n9e = { chmod: cY, cp: $0, flush: uY, mkdir: Vh, mv: lY, rm: G0, touch: hY }, vY = { write: gY, read: dY, ls: _Y }, SY = ({ options: t, mfs: e, operations: r, lock: n }) => {
          Object.keys(r).forEach((i2) => {
            e[i2] = n(r[i2](t));
          });
        }, i9e = { repoOwner: true, repo: null };
        function o9e(t) {
          let { repoOwner: e } = Object.assign({}, i9e || {}, t), r = Wy(e), n = (s) => r.readLock(s), i2 = (s) => r.writeLock(s), o = {};
          return SY({ options: t, mfs: o, operations: r9e, lock: n }), SY({ options: t, mfs: o, operations: n9e, lock: i2 }), Object.keys(vY).forEach((s) => {
            o[s] = vY[s](t);
          }), o;
        }
        function xY({ repo: t, preload: e, hashers: r, options: n }) {
          let i2 = o9e({ repo: t, repoOwner: n.repoOwner !== false, hashers: r }), o = (s) => (...u) => {
            let l = u.filter((f) => ET.default.ipfsPath(f) || ET.default.cid(f));
            if (l.length) {
              let f = u[u.length - 1];
              f && f.preload !== false && l.forEach((h) => e(h));
            }
            return s(...u);
          };
          return { ...i2, chmod: i2.chmod, cp: o(i2.cp), mkdir: i2.mkdir, stat: o(i2.stat), rm: i2.rm, read: o(i2.read), touch: i2.touch, write: i2.write, mv: o(i2.mv), flush: i2.flush, ls: o(async function* (...s) {
            for await (let a of i2.ls(...s))
              yield { ...a, size: a.size || 0 };
          }) };
        }
        c();
        c();
        function RY({ keychain: t }) {
          return B((r, n) => t.exportKey(r, n));
        }
        c();
        var AY = "Ed25519", TY = 2048;
        function IY({ keychain: t }) {
          return B((r, n = { type: AY, size: TY }) => t.createKey(r, n.type || AY, n.size || TY));
        }
        c();
        function CY({ keychain: t }) {
          return B((r, n, i2) => t.importKey(r, n, i2));
        }
        c();
        function PY({ keychain: t }) {
          return B((r) => t.findKeyByName(r));
        }
        c();
        function DY({ keychain: t }) {
          return B(() => t.listKeys());
        }
        c();
        function kY({ keychain: t }) {
          return B(async (r, n) => {
            let i2 = await t.renameKey(r, n);
            return { was: r, now: i2.name, id: i2.id, overwrite: false };
          });
        }
        c();
        function NY({ keychain: t }) {
          return B((r) => t.removeKey(r));
        }
        var p8 = class {
          constructor({ keychain: e }) {
            this.gen = IY({ keychain: e }), this.list = DY({ keychain: e }), this.rm = NY({ keychain: e }), this.rename = kY({ keychain: e }), this.export = RY({ keychain: e }), this.import = CY({ keychain: e }), this.info = PY({ keychain: e });
          }
        };
        c();
        c();
        c();
        function Yi({ repo: t, preload: e }) {
          async function r(n, i2 = {}) {
            i2.preload !== false && e(n);
            let o = await t.blocks.get(n, i2);
            return Rt(o);
          }
          return B(r);
        }
        function OY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e });
          async function n(i2, o = {}) {
            return (await r(i2, o)).Data || new Uint8Array(0);
          }
          return B(n);
        }
        c();
        zo();
        te();
        function bT(t, e = []) {
          for (let r in t) {
            let n = t[r];
            if (r === "/" && Object.keys(t).length === 1)
              try {
                e.push({ Name: "", Tsize: 0, Hash: I.parse(n) });
                continue;
              } catch {
              }
            let i2 = I.asCID(n);
            if (i2) {
              e.push({ Name: "", Tsize: 0, Hash: i2 });
              continue;
            }
            Array.isArray(n) && bT(n, e), n && typeof n == "object" && bT(n, e);
          }
          return e;
        }
        function LY({ repo: t, codecs: e }) {
          async function r(n, i2 = {}) {
            let o = await e.getCodec(n.code), s = await t.blocks.get(n, i2), a = o.decode(s);
            switch (n.code) {
              case Un:
                return [];
              case pt:
                return a.Links;
              case qf:
              case $9:
                return bT(a);
              default:
                throw new Error(`Cannot resolve links from codec ${n.code}`);
            }
          }
          return B(r);
        }
        c();
        vr();
        te();
        function BY({ repo: t, preload: e }) {
          async function r(n = {}) {
            let i2;
            if (n.template)
              if (n.template === "unixfs-dir")
                i2 = new Je({ type: "directory" }).marshal();
              else
                throw new Error("unknown template");
            let o = je({ Data: i2, Links: [] }), s = await xe.digest(o), a = I.createV0(s);
            return await t.blocks.put(a, o, { signal: n.signal }), n.preload !== false && e(a), a;
          }
          return B(r);
        }
        c();
        te();
        vr();
        function Ha({ repo: t, preload: e }) {
          async function r(n, i2 = {}) {
            let o = await t.gcLock.readLock();
            try {
              let s = je(n), a = await xe.digest(s), u = I.createV1(pt, a);
              return await t.blocks.put(u, s, { signal: i2.signal }), i2.preload !== false && e(u), i2.pin && await t.pins.pinRecursively(u, { signal: i2.signal }), u;
            } finally {
              o();
            }
          }
          return B(r);
        }
        c();
        function MY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e });
          async function n(i2, o = {}) {
            let s = await r(i2, o), u = je(s).length, l = s.Links.reduce((f, h) => f + (h.Tsize || 0), 0);
            return { Hash: i2, NumLinks: s.Links.length, BlockSize: u, LinksSize: u - (s.Data || []).length, DataSize: (s.Data || []).length, CumulativeSize: u + l };
          }
          return B(n);
        }
        c();
        c();
        function UY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e }), n = Ha({ repo: t, preload: e });
          async function i2(o, s, a = {}) {
            let u = await r(o, a);
            return n({ ...u, Links: u.Links.concat([s]) }, a);
          }
          return B(i2);
        }
        c();
        ur();
        function FY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e }), n = Ha({ repo: t, preload: e });
          async function i2(o, s, a = {}) {
            let u = await r(o, a), l = Ae([u.Data || [], s]);
            return n({ ...u, Data: l }, a);
          }
          return B(i2);
        }
        c();
        function KY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e }), n = Ha({ repo: t, preload: e });
          async function i2(o, s, a = {}) {
            let u = await r(o, a), l = (typeof s == "string" ? s : s.Name) || "";
            return u.Links = u.Links.filter((f) => f.Name !== l), n(u, a);
          }
          return B(i2);
        }
        c();
        function VY({ repo: t, preload: e }) {
          let r = Yi({ repo: t, preload: e }), n = Ha({ repo: t, preload: e });
          async function i2(o, s, a = {}) {
            let u = await r(o, a);
            return n({ ...u, Data: s }, a);
          }
          return B(i2);
        }
        var m8 = class {
          constructor({ repo: e, preload: r }) {
            this.addLink = UY({ repo: e, preload: r }), this.appendData = FY({ repo: e, preload: r }), this.rmLink = KY({ repo: e, preload: r }), this.setData = VY({ repo: e, preload: r });
          }
        };
        var y8 = class {
          constructor({ repo: e, codecs: r, preload: n }) {
            this.data = OY({ repo: e, preload: n }), this.get = Yi({ repo: e, preload: n }), this.links = LY({ repo: e, codecs: r }), this.new = BY({ repo: e, preload: n }), this.put = Ha({ repo: e, preload: n }), this.stat = MY({ repo: e, preload: n }), this.patch = new m8({ repo: e, preload: n });
          }
        };
        c();
        c();
        var s9e = C("ipfs:repo:gc");
        function qY({ repo: t, hashers: e }) {
          async function* r(n = {}) {
            let i2 = Date.now(), o;
            try {
              o = await K0({ repo: t, hashers: e }, n), await t.pins.pinRecursively(o), yield* t.gc();
            } finally {
              o && await t.pins.unpin(o);
            }
            s9e(`Complete (${Date.now() - i2}ms)`);
          }
          return B(r);
        }
        c();
        function g8({ repo: t }) {
          async function e(r = {}) {
            let n = await t.stat();
            return { numObjects: BigInt(n.numObjects.toString()), repoSize: BigInt(n.repoSize.toString()), repoPath: n.repoPath, version: `${n.version}`, storageMax: BigInt(n.storageMax.toString()) };
          }
          return B(e);
        }
        c();
        c();
        function zY({ repo: t }) {
          async function e(r = {}) {
            try {
              await t._checkInitialized(r);
            } catch (n) {
              if ([/Key not found in database \[\/version\]/, /ENOENT/, /repo is not initialized yet/].some((o) => o.test(n.message)))
                return 12;
              throw n;
            }
            return t.version.get();
          }
          return B(e);
        }
        var w8 = class {
          constructor({ repo: e, hashers: r }) {
            this.gc = qY({ repo: e, hashers: r }), this.stat = g8({ repo: e }), this.version = zY({ repo: e }), this.setApiAddr = (n) => e.apiAddr.set(n);
          }
        };
        c();
        c();
        var $Y = w(K(), 1);
        function HY(t, e) {
          let r;
          if (t.metrics ? e.peer ? r = t.metrics.forPeer(e.peer) : e.proto ? r = t.metrics.forProtocol(e.proto) : r = t.metrics.getGlobal() : r = void 0, !r)
            return { totalIn: BigInt(0), totalOut: BigInt(0), rateIn: 0, rateOut: 0 };
          let n = r.getMovingAverages(), i2 = r.getSnapshot();
          return { totalIn: i2.dataReceived, totalOut: i2.dataSent, rateIn: n.dataReceived[6e4].movingAverage / 60, rateOut: n.dataSent[6e4].movingAverage / 60 };
        }
        function GY({ network: t }) {
          return B(async function* (r = {}) {
            let { libp2p: n } = await t.use(r);
            if (!r.poll) {
              yield HY(n, r);
              return;
            }
            let i2 = r.interval || 1e3, o = -1;
            try {
              if (o = typeof i2 == "string" ? ju(i2) || -1 : i2, !o || o < 0)
                throw new Error("invalid duration");
            } catch (a) {
              throw (0, $Y.default)(a, "ERR_INVALID_POLL_INTERVAL");
            }
            let s;
            try {
              for (; ; )
                yield HY(n, r), await new Promise((a) => {
                  s = setTimeout(a, o);
                });
            } finally {
              clearTimeout(s);
            }
          });
        }
        var E8 = class {
          constructor({ repo: e, network: r }) {
            this.repo = g8({ repo: e }), this.bw = GY({ network: r }), this.bitswap = q6({ network: r });
          }
        };
        c();
        c();
        c();
        var aI = w(_T(), 1), eZ = w(Mi(), 1), Xh = w(K(), 1);
        c();
        c();
        c();
        te();
        var QY = w(Mi(), 1), XY = w(Jy(), 1);
        si();
        zo();
        On();
        var l9e = (0, QY.default)("ipfs:repo:migrator:migration-8");
        function ZY(t) {
          return t.child ? ZY(t.child) : t;
        }
        function f9e(t) {
          try {
            let e = xt.decode(`b${t.toString().toLowerCase().slice(1)}`), r = I.decode(e).multihash.bytes, n = xt.encode(r).slice(1).toUpperCase();
            return new ae(`/${n}`, false);
          } catch {
            return t;
          }
        }
        function h9e(t) {
          try {
            let e = xt.decode(`b${t.toString().toLowerCase().slice(1)}`), r = _r(e), n = xt.encode(I.createV1(Un, r).bytes).slice(1);
            return new ae(`/${n.toUpperCase()}`, false);
          } catch {
            return t;
          }
        }
        async function YY(t, e, r) {
          let n = t.blocks;
          await n.open();
          let i2 = ZY(n), o = await (0, XY.default)(i2.queryKeys({ filters: [(s) => r(s).toString() !== s.toString()] }));
          try {
            let s = 0;
            for await (let a of i2.query({})) {
              let u = r(a.key);
              u.toString() !== a.key.toString() && (s += 1, l9e(`Migrating Block from ${a.key} to ${u}`, await i2.has(a.key)), await i2.delete(a.key), await i2.put(u, a.value), e(s / o * 100, `Migrated Block from ${a.key} to ${u}`));
            }
          } finally {
            await n.close();
          }
        }
        var JY = { version: 8, description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32", migrate: (t, e = () => {
        }) => YY(t, e, f9e), revert: (t, e = () => {
        }) => YY(t, e, h9e) };
        c();
        te();
        Vf();
        c();
        te();
        c();
        var qh = w(Ea(), 1), eQ = qh.default.Reader, d9e = qh.default.Writer, ust = qh.default.util, b8 = qh.default.roots.default || (qh.default.roots.default = {}), tQ = b8.ipfs = (() => {
          let t = {};
          return t.pin = function() {
            let e = {};
            return e.Set = function() {
              function r(n) {
                if (n)
                  for (var i2 = Object.keys(n), o = 0; o < i2.length; ++o)
                    n[i2[o]] != null && (this[i2[o]] = n[i2[o]]);
              }
              return r.prototype.version = 0, r.prototype.fanout = 0, r.prototype.seed = 0, r.encode = function(i2, o) {
                return o || (o = d9e.create()), i2.version != null && Object.hasOwnProperty.call(i2, "version") && o.uint32(8).uint32(i2.version), i2.fanout != null && Object.hasOwnProperty.call(i2, "fanout") && o.uint32(16).uint32(i2.fanout), i2.seed != null && Object.hasOwnProperty.call(i2, "seed") && o.uint32(29).fixed32(i2.seed), o;
              }, r.decode = function(i2, o) {
                i2 instanceof eQ || (i2 = eQ.create(i2));
                for (var s = o === void 0 ? i2.len : i2.pos + o, a = new b8.ipfs.pin.Set(); i2.pos < s; ) {
                  var u = i2.uint32();
                  switch (u >>> 3) {
                    case 1:
                      a.version = i2.uint32();
                      break;
                    case 2:
                      a.fanout = i2.uint32();
                      break;
                    case 3:
                      a.seed = i2.fixed32();
                      break;
                    default:
                      i2.skipType(u & 7);
                      break;
                  }
                }
                return a;
              }, r.fromObject = function(i2) {
                if (i2 instanceof b8.ipfs.pin.Set)
                  return i2;
                var o = new b8.ipfs.pin.Set();
                return i2.version != null && (o.version = i2.version >>> 0), i2.fanout != null && (o.fanout = i2.fanout >>> 0), i2.seed != null && (o.seed = i2.seed >>> 0), o;
              }, r.toObject = function(i2, o) {
                o || (o = {});
                var s = {};
                return o.defaults && (s.version = 0, s.fanout = 0, s.seed = 0), i2.version != null && i2.hasOwnProperty("version") && (s.version = i2.version), i2.fanout != null && i2.hasOwnProperty("fanout") && (s.fanout = i2.fanout), i2.seed != null && i2.hasOwnProperty("seed") && (s.seed = i2.seed), s;
              }, r.prototype.toJSON = function() {
                return this.constructor.toObject(this, qh.default.util.toJSONOptions);
              }, r;
            }(), e;
          }(), t;
        })();
        var oQ = w(nQ(), 1), S8 = w(ai(), 1);
        c();
        si();
        te();
        var eg = new ae("/local/pins"), v8 = 256, iQ = 8192, ST = I.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"), zh = { direct: "direct", recursive: "recursive" };
        function xT(t) {
          return new ae(`/${xt.encode(t.multihash.bytes).toUpperCase().substring(1)}`);
        }
        ur();
        me();
        Re();
        vr();
        var RT = tQ.pin.Set;
        function p9e(t) {
          let e = t.Data;
          if (!e)
            throw new Error("No data present");
          let r = S8.default.decode(e), n = S8.default.decode.bytes;
          if (n <= 0)
            throw new Error("Invalid Set header length");
          if (n + r > e.length)
            throw new Error("Impossibly large set header length");
          let i2 = e.slice(n, r + n), o = RT.toObject(RT.decode(i2), { defaults: false, arrays: true, longs: Number, objects: false });
          if (o.version !== 1)
            throw new Error(`Unsupported Set version: ${o.version}`);
          if (o.fanout > t.Links.length)
            throw new Error("Impossibly large fanout");
          return { header: o, data: e.slice(r + n) };
        }
        function m9e(t, e) {
          let r = new Uint8Array(4);
          new DataView(r.buffer).setUint32(0, t, true);
          let i2 = U(e.toString()), o = Ae([r, i2], r.byteLength + i2.byteLength);
          return (0, oQ.default)(M(o));
        }
        async function* sQ(t, e) {
          let r = p9e(e), n = 0;
          for (let i2 of e.Links) {
            if (n < r.header.fanout) {
              let o = i2.Hash;
              if (!ST.equals(o)) {
                let s = await t.get(o), a = Rt(s);
                yield* sQ(t, a);
              }
            } else
              yield i2.Hash;
            n++;
          }
        }
        async function* tg(t, e, r) {
          let n = e.Links.find((s) => s.Name === r);
          if (!n)
            throw new Error("No link found with name " + r);
          let i2 = await t.get(n.Hash), o = Rt(i2);
          yield* sQ(t, o);
        }
        function y9e(t, e) {
          return r(e, 0);
          async function r(n, i2) {
            let o = RT.encode({ version: 1, fanout: v8, seed: i2 }).finish(), s = S8.default.encode(o.length), a = Ae([s, o]), u = [];
            for (let f = 0; f < v8; f++)
              u.push({ Name: "", Tsize: 1, Hash: ST });
            if (n.length <= iQ) {
              let f = n.map((d) => ({ link: { Name: "", Tsize: 1, Hash: d.key }, data: d.data || new Uint8Array() })).sort((d, m) => eh(d.link.Hash.bytes, m.link.Hash.bytes)), h = u.concat(f.map((d) => d.link));
              return { Data: Ae([a, ...f.map((d) => d.data)]), Links: h };
            } else {
              let f = n.reduce((p, d) => {
                let m = m9e(i2, d.key) % v8;
                return p[m] = m in p ? p[m].concat([d]) : [d], p;
              }, []), h = 0;
              for (let p of f) {
                let d = await r(p, i2 + 1);
                await l(d, h), h++;
              }
              return { Data: a, Links: u };
            }
            async function l(f, h) {
              let p = je(f), d = await xe.digest(p), m = I.createV0(d);
              await t.put(m, p);
              let y = f.Links.reduce((g, E) => g + (E.Tsize || 0), 0) + p.length;
              u[h] = { Name: "", Tsize: y, Hash: m };
            }
          }
        }
        async function AT(t, e, r) {
          let n = await y9e(t, r.map((u) => ({ key: u }))), i2 = je(n), o = await xe.digest(i2), s = I.createV0(o);
          await t.put(s, i2);
          let a = n.Links.reduce((u, l) => u + l.Tsize, 0) + i2.length;
          return { Name: e, Tsize: a, Hash: s };
        }
        var x8 = w(Jy(), 1);
        vr();
        On();
        si();
        async function w9e(t, e, r, n) {
          if (!await e.has(eg))
            return;
          let i2 = await e.get(eg), o = I.decode(i2), s = await t.get(o), a = Rt(s), u = 0, l = await (0, x8.default)(tg(t, a, zh.recursive)) + await (0, x8.default)(tg(t, a, zh.direct));
          for await (let f of tg(t, a, zh.recursive)) {
            u++;
            let h = { depth: 1 / 0 };
            f.version !== 0 && (h.version = f.version), f.code !== pt && (h.codec = f.code), await r.put(xT(f), ao(h)), n(u / l * 100, `Migrated recursive pin ${f}`);
          }
          for await (let f of tg(t, a, zh.direct)) {
            u++;
            let h = { depth: 0 };
            f.version !== 0 && (h.version = f.version), f.code !== pt && (h.codec = f.code), await r.put(xT(f), ao(h)), n(u / l * 100, `Migrated direct pin ${f}`);
          }
          await t.delete(o), await e.delete(eg);
        }
        async function E9e(t, e, r, n) {
          let i2 = [], o = [], s = 0, a = await (0, x8.default)(r.queryKeys({}));
          for await (let { key: p, value: d } of r.query({})) {
            s++;
            let m = Mn(d), y = I.create(m.version || 0, m.codec || pt, _r(xt.decode("b" + p.toString().toLowerCase().split("/").pop())));
            m.depth === 0 ? (n(s / a * 100, `Reverted direct pin ${y}`), o.push(y)) : (n(s / a * 100, `Reverted recursive pin ${y}`), i2.push(y));
          }
          n(100, "Updating pin root");
          let u = { Links: [await AT(t, zh.direct, o), await AT(t, zh.recursive, i2)] }, l = je(u), f = await xe.digest(l), h = I.createV0(f);
          await t.put(h, l), await e.put(eg, h.bytes);
        }
        async function aQ(t, e, r) {
          let n = t.blocks, i2 = t.datastore, o = t.pins;
          await n.open(), await i2.open(), await o.open();
          try {
            await r(n, i2, o, e);
          } finally {
            await o.close(), await i2.close(), await n.close();
          }
        }
        var cQ = { version: 9, description: "Migrates pins to datastore", migrate: (t, e = () => {
        }) => aQ(t, e, w9e), revert: (t, e = () => {
        }) => aQ(t, e, E9e) };
        c();
        c();
        var uQ = new ae("/config"), rg = new ae("/version");
        function ng(t) {
          let e = t;
          for (; e.db || e.child; )
            if (e = e.db || e.child, e.type === "level-js" || e.constructor.name === "Level")
              return e;
        }
        async function b9e(t, e, r) {
          let n = await e(t);
          if (n)
            return n;
          let i2 = ng(r);
          return i2 ? new Promise((o, s) => {
            let a = i2.store("readonly").get(t.toString());
            a.transaction.onabort = () => {
              s(a.transaction.error);
            }, a.transaction.oncomplete = () => {
              o(Boolean(a.result));
            };
          }) : false;
        }
        async function _9e(t, e, r, n) {
          if (await r(t))
            return e(t);
          let i2 = ng(n);
          if (!i2)
            throw Rn();
          return new Promise((o, s) => {
            let a = i2.store("readonly").get(t.toString());
            a.transaction.onabort = () => {
              s(a.transaction.error);
            }, a.transaction.oncomplete = () => {
              if (a.result)
                return o(a.result);
              s(Rn());
            };
          });
        }
        function R8(t) {
          let e = t.get.bind(t), r = t.has.bind(t);
          return t.get = (n) => _9e(n, e, r, t), t.has = (n) => b9e(n, r, t), t;
        }
        function TT(t) {
          return { ...t, root: R8(t.root), datastore: R8(t.datastore), pins: R8(t.pins), keys: R8(t.keys) };
        }
        Re();
        me();
        async function v9e(t, e, r = () => {
        }) {
          let n = ng(e);
          if (!n) {
            r(`${t} did not need an upgrade`);
            return;
          }
          r(`Upgrading ${t}`), await dQ(n, (o, s) => [{ type: "del", key: o }, { type: "put", key: U(o), value: s }]);
        }
        async function S9e(t, e, r = () => {
        }) {
          let n = ng(e);
          if (!n) {
            r(`${t} did not need a downgrade`);
            return;
          }
          r(`Downgrading ${t}`), await dQ(n, (o, s) => [{ type: "del", key: o }, { type: "put", key: M(o), value: s }]);
        }
        function fQ(t) {
          return t.child ? fQ(t.child) : t;
        }
        async function lQ(t, e, r) {
          let n = Object.entries(t).map(([s, a]) => ({ key: s, backend: fQ(a) })).filter(({ key: s, backend: a }) => a.constructor.name === "LevelDatastore").map(({ key: s, backend: a }) => ({ name: s, store: a }));
          e(0, `Migrating ${n.length} dbs`);
          let i2 = 0, o = (s) => {
            e(Math.round(i2 / n.length * 100), s);
          };
          for (let { name: s, store: a } of n) {
            await a.open();
            try {
              await r(s, a, o);
            } finally {
              i2++, await a.close();
            }
          }
          e(100, `Migrated ${n.length} dbs`);
        }
        var hQ = { version: 10, description: "Migrates datastore-level keys to binary", migrate: (t, e = () => {
        }) => lQ(t, e, v9e), revert: (t, e = () => {
        }) => lQ(t, e, S9e) };
        function dQ(t, e) {
          function r(n, i2) {
            let o = t.store("readwrite"), s = o.transaction, a = 0, u;
            s.onabort = () => i2(u || s.error || new Error("aborted by user")), s.oncomplete = () => i2();
            function l() {
              let f = n[a++], h = f.key, p;
              try {
                p = f.type === "del" ? o.delete(h) : o.put(f.value, h);
              } catch (d) {
                u = d, s.abort();
                return;
              }
              a < n.length && (p.onsuccess = l);
            }
            l();
          }
          return new Promise((n, i2) => {
            let o = t.iterator(), s = (u) => u;
            o._deserializeKey = o._deserializeValue = s, a();
            function a() {
              let u = (l, f, h) => {
                if (l || f === void 0) {
                  let p = (d) => {
                    if (d) {
                      i2(d);
                      return;
                    }
                    n();
                  };
                  o.end(p);
                  return;
                }
                r(e(f, h), a);
              };
              o.next(u);
            }
          });
        }
        c();
        var Ml = new ae("/local/filesroot");
        async function x9e(t, e = () => {
        }) {
          if (e(100, "Migrating MFS root to repo datastore"), await t.root.open(), await t.datastore.open(), await t.root.has(Ml)) {
            let r = await t.root.get(Ml);
            await t.datastore.put(Ml, r), await t.root.delete(Ml);
          }
          await t.datastore.close(), await t.root.close(), e(100, "Stored MFS root in repo datastore");
        }
        async function R9e(t, e = () => {
        }) {
          if (e(100, "Migrating MFS root to repo root datastore"), await t.root.open(), await t.datastore.open(), await t.datastore.has(Ml)) {
            let r = await t.datastore.get(Ml);
            await t.root.put(Ml, r), await t.datastore.delete(Ml);
          }
          await t.datastore.close(), await t.root.close(), e(100, "Stored MFS root in repo root datastore");
        }
        var pQ = { version: 11, description: "Store mfs root in the datastore", migrate: x9e, revert: R9e };
        c();
        var OT = w(Ea(), 1);
        c();
        var Hh = w(Ea(), 1), mQ = Hh.default.Reader, A9e = Hh.default.Writer, T9e = Hh.default.util, A8 = Hh.default.roots.default || (Hh.default.roots.default = {}), IT = A8.Protocols = (() => {
          function t(e) {
            if (this.protocols = [], e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.protocols = T9e.emptyArray, t.encode = function(r, n) {
            if (n || (n = A9e.create()), r.protocols != null && r.protocols.length)
              for (var i2 = 0; i2 < r.protocols.length; ++i2)
                n.uint32(10).string(r.protocols[i2]);
            return n;
          }, t.decode = function(r, n) {
            r instanceof mQ || (r = mQ.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new A8.Protocols(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.protocols && o.protocols.length || (o.protocols = []), o.protocols.push(r.string());
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof A8.Protocols)
              return r;
            var n = new A8.Protocols();
            if (r.protocols) {
              if (!Array.isArray(r.protocols))
                throw TypeError(".Protocols.protocols: array expected");
              n.protocols = [];
              for (var i2 = 0; i2 < r.protocols.length; ++i2)
                n.protocols[i2] = String(r.protocols[i2]);
            }
            return n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if ((n.arrays || n.defaults) && (i2.protocols = []), r.protocols && r.protocols.length) {
              i2.protocols = [];
              for (var o = 0; o < r.protocols.length; ++o)
                i2.protocols[o] = r.protocols[o];
            }
            return i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, Hh.default.util.toJSONOptions);
          }, t;
        })();
        c();
        var jc = w(Ea(), 1), j0 = jc.default.Reader, CT = jc.default.Writer, Lr = jc.default.util, Gn = jc.default.roots.default || (jc.default.roots.default = {}), PT = Gn.Addresses = (() => {
          function t(e) {
            if (this.addrs = [], e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.addrs = Lr.emptyArray, t.prototype.certifiedRecord = null, t.encode = function(r, n) {
            if (n || (n = CT.create()), r.addrs != null && r.addrs.length)
              for (var i2 = 0; i2 < r.addrs.length; ++i2)
                Gn.Addresses.Address.encode(r.addrs[i2], n.uint32(10).fork()).ldelim();
            return r.certifiedRecord != null && Object.hasOwnProperty.call(r, "certifiedRecord") && Gn.Addresses.CertifiedRecord.encode(r.certifiedRecord, n.uint32(18).fork()).ldelim(), n;
          }, t.decode = function(r, n) {
            r instanceof j0 || (r = j0.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new Gn.Addresses(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.addrs && o.addrs.length || (o.addrs = []), o.addrs.push(Gn.Addresses.Address.decode(r, r.uint32()));
                  break;
                case 2:
                  o.certifiedRecord = Gn.Addresses.CertifiedRecord.decode(r, r.uint32());
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof Gn.Addresses)
              return r;
            var n = new Gn.Addresses();
            if (r.addrs) {
              if (!Array.isArray(r.addrs))
                throw TypeError(".Addresses.addrs: array expected");
              n.addrs = [];
              for (var i2 = 0; i2 < r.addrs.length; ++i2) {
                if (typeof r.addrs[i2] != "object")
                  throw TypeError(".Addresses.addrs: object expected");
                n.addrs[i2] = Gn.Addresses.Address.fromObject(r.addrs[i2]);
              }
            }
            if (r.certifiedRecord != null) {
              if (typeof r.certifiedRecord != "object")
                throw TypeError(".Addresses.certifiedRecord: object expected");
              n.certifiedRecord = Gn.Addresses.CertifiedRecord.fromObject(r.certifiedRecord);
            }
            return n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if ((n.arrays || n.defaults) && (i2.addrs = []), n.defaults && (i2.certifiedRecord = null), r.addrs && r.addrs.length) {
              i2.addrs = [];
              for (var o = 0; o < r.addrs.length; ++o)
                i2.addrs[o] = Gn.Addresses.Address.toObject(r.addrs[o], n);
            }
            return r.certifiedRecord != null && r.hasOwnProperty("certifiedRecord") && (i2.certifiedRecord = Gn.Addresses.CertifiedRecord.toObject(r.certifiedRecord, n)), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, jc.default.util.toJSONOptions);
          }, t.Address = function() {
            function e(n) {
              if (n)
                for (var i2 = Object.keys(n), o = 0; o < i2.length; ++o)
                  n[i2[o]] != null && (this[i2[o]] = n[i2[o]]);
            }
            e.prototype.multiaddr = Lr.newBuffer([]), e.prototype.isCertified = null;
            let r;
            return Object.defineProperty(e.prototype, "_isCertified", { get: Lr.oneOfGetter(r = ["isCertified"]), set: Lr.oneOfSetter(r) }), e.encode = function(i2, o) {
              return o || (o = CT.create()), i2.multiaddr != null && Object.hasOwnProperty.call(i2, "multiaddr") && o.uint32(10).bytes(i2.multiaddr), i2.isCertified != null && Object.hasOwnProperty.call(i2, "isCertified") && o.uint32(16).bool(i2.isCertified), o;
            }, e.decode = function(i2, o) {
              i2 instanceof j0 || (i2 = j0.create(i2));
              for (var s = o === void 0 ? i2.len : i2.pos + o, a = new Gn.Addresses.Address(); i2.pos < s; ) {
                var u = i2.uint32();
                switch (u >>> 3) {
                  case 1:
                    a.multiaddr = i2.bytes();
                    break;
                  case 2:
                    a.isCertified = i2.bool();
                    break;
                  default:
                    i2.skipType(u & 7);
                    break;
                }
              }
              return a;
            }, e.fromObject = function(i2) {
              if (i2 instanceof Gn.Addresses.Address)
                return i2;
              var o = new Gn.Addresses.Address();
              return i2.multiaddr != null && (typeof i2.multiaddr == "string" ? Lr.base64.decode(i2.multiaddr, o.multiaddr = Lr.newBuffer(Lr.base64.length(i2.multiaddr)), 0) : i2.multiaddr.length && (o.multiaddr = i2.multiaddr)), i2.isCertified != null && (o.isCertified = Boolean(i2.isCertified)), o;
            }, e.toObject = function(i2, o) {
              o || (o = {});
              var s = {};
              return o.defaults && (o.bytes === String ? s.multiaddr = "" : (s.multiaddr = [], o.bytes !== Array && (s.multiaddr = Lr.newBuffer(s.multiaddr)))), i2.multiaddr != null && i2.hasOwnProperty("multiaddr") && (s.multiaddr = o.bytes === String ? Lr.base64.encode(i2.multiaddr, 0, i2.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(i2.multiaddr) : i2.multiaddr), i2.isCertified != null && i2.hasOwnProperty("isCertified") && (s.isCertified = i2.isCertified, o.oneofs && (s._isCertified = "isCertified")), s;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, jc.default.util.toJSONOptions);
            }, e;
          }(), t.CertifiedRecord = function() {
            function e(r) {
              if (r)
                for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                  r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
            }
            return e.prototype.seq = Lr.Long ? Lr.Long.fromBits(0, 0, true) : 0, e.prototype.raw = Lr.newBuffer([]), e.encode = function(n, i2) {
              return i2 || (i2 = CT.create()), n.seq != null && Object.hasOwnProperty.call(n, "seq") && i2.uint32(8).uint64(n.seq), n.raw != null && Object.hasOwnProperty.call(n, "raw") && i2.uint32(18).bytes(n.raw), i2;
            }, e.decode = function(n, i2) {
              n instanceof j0 || (n = j0.create(n));
              for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new Gn.Addresses.CertifiedRecord(); n.pos < o; ) {
                var a = n.uint32();
                switch (a >>> 3) {
                  case 1:
                    s.seq = n.uint64();
                    break;
                  case 2:
                    s.raw = n.bytes();
                    break;
                  default:
                    n.skipType(a & 7);
                    break;
                }
              }
              return s;
            }, e.fromObject = function(n) {
              if (n instanceof Gn.Addresses.CertifiedRecord)
                return n;
              var i2 = new Gn.Addresses.CertifiedRecord();
              return n.seq != null && (Lr.Long ? (i2.seq = Lr.Long.fromValue(n.seq)).unsigned = true : typeof n.seq == "string" ? i2.seq = parseInt(n.seq, 10) : typeof n.seq == "number" ? i2.seq = n.seq : typeof n.seq == "object" && (i2.seq = new Lr.LongBits(n.seq.low >>> 0, n.seq.high >>> 0).toNumber(true))), n.raw != null && (typeof n.raw == "string" ? Lr.base64.decode(n.raw, i2.raw = Lr.newBuffer(Lr.base64.length(n.raw)), 0) : n.raw.length && (i2.raw = n.raw)), i2;
            }, e.toObject = function(n, i2) {
              i2 || (i2 = {});
              var o = {};
              if (i2.defaults) {
                if (Lr.Long) {
                  var s = new Lr.Long(0, 0, true);
                  o.seq = i2.longs === String ? s.toString() : i2.longs === Number ? s.toNumber() : s;
                } else
                  o.seq = i2.longs === String ? "0" : 0;
                i2.bytes === String ? o.raw = "" : (o.raw = [], i2.bytes !== Array && (o.raw = Lr.newBuffer(o.raw)));
              }
              return n.seq != null && n.hasOwnProperty("seq") && (typeof n.seq == "number" ? o.seq = i2.longs === String ? String(n.seq) : n.seq : o.seq = i2.longs === String ? Lr.Long.prototype.toString.call(n.seq) : i2.longs === Number ? new Lr.LongBits(n.seq.low >>> 0, n.seq.high >>> 0).toNumber(true) : n.seq), n.raw != null && n.hasOwnProperty("raw") && (o.raw = i2.bytes === String ? Lr.base64.encode(n.raw, 0, n.raw.length) : i2.bytes === Array ? Array.prototype.slice.call(n.raw) : n.raw), o;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, jc.default.util.toJSONOptions);
            }, e;
          }(), t;
        })();
        c();
        var Yc = w(Ea(), 1), Y0 = Yc.default.Reader, DT = Yc.default.Writer, er = Yc.default.util, yn = Yc.default.roots.default || (Yc.default.roots.default = {}), kT = yn.Peer = (() => {
          function t(r) {
            if (this.addresses = [], this.protocols = [], this.metadata = [], r)
              for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
          }
          t.prototype.addresses = er.emptyArray, t.prototype.protocols = er.emptyArray, t.prototype.metadata = er.emptyArray, t.prototype.pubKey = null, t.prototype.peerRecordEnvelope = null;
          let e;
          return Object.defineProperty(t.prototype, "_pubKey", { get: er.oneOfGetter(e = ["pubKey"]), set: er.oneOfSetter(e) }), Object.defineProperty(t.prototype, "_peerRecordEnvelope", { get: er.oneOfGetter(e = ["peerRecordEnvelope"]), set: er.oneOfSetter(e) }), t.encode = function(n, i2) {
            if (i2 || (i2 = DT.create()), n.addresses != null && n.addresses.length)
              for (var o = 0; o < n.addresses.length; ++o)
                yn.Address.encode(n.addresses[o], i2.uint32(10).fork()).ldelim();
            if (n.protocols != null && n.protocols.length)
              for (var o = 0; o < n.protocols.length; ++o)
                i2.uint32(18).string(n.protocols[o]);
            if (n.metadata != null && n.metadata.length)
              for (var o = 0; o < n.metadata.length; ++o)
                yn.Metadata.encode(n.metadata[o], i2.uint32(26).fork()).ldelim();
            return n.pubKey != null && Object.hasOwnProperty.call(n, "pubKey") && i2.uint32(34).bytes(n.pubKey), n.peerRecordEnvelope != null && Object.hasOwnProperty.call(n, "peerRecordEnvelope") && i2.uint32(42).bytes(n.peerRecordEnvelope), i2;
          }, t.decode = function(n, i2) {
            n instanceof Y0 || (n = Y0.create(n));
            for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new yn.Peer(); n.pos < o; ) {
              var a = n.uint32();
              switch (a >>> 3) {
                case 1:
                  s.addresses && s.addresses.length || (s.addresses = []), s.addresses.push(yn.Address.decode(n, n.uint32()));
                  break;
                case 2:
                  s.protocols && s.protocols.length || (s.protocols = []), s.protocols.push(n.string());
                  break;
                case 3:
                  s.metadata && s.metadata.length || (s.metadata = []), s.metadata.push(yn.Metadata.decode(n, n.uint32()));
                  break;
                case 4:
                  s.pubKey = n.bytes();
                  break;
                case 5:
                  s.peerRecordEnvelope = n.bytes();
                  break;
                default:
                  n.skipType(a & 7);
                  break;
              }
            }
            return s;
          }, t.fromObject = function(n) {
            if (n instanceof yn.Peer)
              return n;
            var i2 = new yn.Peer();
            if (n.addresses) {
              if (!Array.isArray(n.addresses))
                throw TypeError(".Peer.addresses: array expected");
              i2.addresses = [];
              for (var o = 0; o < n.addresses.length; ++o) {
                if (typeof n.addresses[o] != "object")
                  throw TypeError(".Peer.addresses: object expected");
                i2.addresses[o] = yn.Address.fromObject(n.addresses[o]);
              }
            }
            if (n.protocols) {
              if (!Array.isArray(n.protocols))
                throw TypeError(".Peer.protocols: array expected");
              i2.protocols = [];
              for (var o = 0; o < n.protocols.length; ++o)
                i2.protocols[o] = String(n.protocols[o]);
            }
            if (n.metadata) {
              if (!Array.isArray(n.metadata))
                throw TypeError(".Peer.metadata: array expected");
              i2.metadata = [];
              for (var o = 0; o < n.metadata.length; ++o) {
                if (typeof n.metadata[o] != "object")
                  throw TypeError(".Peer.metadata: object expected");
                i2.metadata[o] = yn.Metadata.fromObject(n.metadata[o]);
              }
            }
            return n.pubKey != null && (typeof n.pubKey == "string" ? er.base64.decode(n.pubKey, i2.pubKey = er.newBuffer(er.base64.length(n.pubKey)), 0) : n.pubKey.length && (i2.pubKey = n.pubKey)), n.peerRecordEnvelope != null && (typeof n.peerRecordEnvelope == "string" ? er.base64.decode(n.peerRecordEnvelope, i2.peerRecordEnvelope = er.newBuffer(er.base64.length(n.peerRecordEnvelope)), 0) : n.peerRecordEnvelope.length && (i2.peerRecordEnvelope = n.peerRecordEnvelope)), i2;
          }, t.toObject = function(n, i2) {
            i2 || (i2 = {});
            var o = {};
            if ((i2.arrays || i2.defaults) && (o.addresses = [], o.protocols = [], o.metadata = []), n.addresses && n.addresses.length) {
              o.addresses = [];
              for (var s = 0; s < n.addresses.length; ++s)
                o.addresses[s] = yn.Address.toObject(n.addresses[s], i2);
            }
            if (n.protocols && n.protocols.length) {
              o.protocols = [];
              for (var s = 0; s < n.protocols.length; ++s)
                o.protocols[s] = n.protocols[s];
            }
            if (n.metadata && n.metadata.length) {
              o.metadata = [];
              for (var s = 0; s < n.metadata.length; ++s)
                o.metadata[s] = yn.Metadata.toObject(n.metadata[s], i2);
            }
            return n.pubKey != null && n.hasOwnProperty("pubKey") && (o.pubKey = i2.bytes === String ? er.base64.encode(n.pubKey, 0, n.pubKey.length) : i2.bytes === Array ? Array.prototype.slice.call(n.pubKey) : n.pubKey, i2.oneofs && (o._pubKey = "pubKey")), n.peerRecordEnvelope != null && n.hasOwnProperty("peerRecordEnvelope") && (o.peerRecordEnvelope = i2.bytes === String ? er.base64.encode(n.peerRecordEnvelope, 0, n.peerRecordEnvelope.length) : i2.bytes === Array ? Array.prototype.slice.call(n.peerRecordEnvelope) : n.peerRecordEnvelope, i2.oneofs && (o._peerRecordEnvelope = "peerRecordEnvelope")), o;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, Yc.default.util.toJSONOptions);
          }, t;
        })(), Fst = yn.Address = (() => {
          function t(r) {
            if (r)
              for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
          }
          t.prototype.multiaddr = er.newBuffer([]), t.prototype.isCertified = null;
          let e;
          return Object.defineProperty(t.prototype, "_isCertified", { get: er.oneOfGetter(e = ["isCertified"]), set: er.oneOfSetter(e) }), t.encode = function(n, i2) {
            return i2 || (i2 = DT.create()), n.multiaddr != null && Object.hasOwnProperty.call(n, "multiaddr") && i2.uint32(10).bytes(n.multiaddr), n.isCertified != null && Object.hasOwnProperty.call(n, "isCertified") && i2.uint32(16).bool(n.isCertified), i2;
          }, t.decode = function(n, i2) {
            n instanceof Y0 || (n = Y0.create(n));
            for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new yn.Address(); n.pos < o; ) {
              var a = n.uint32();
              switch (a >>> 3) {
                case 1:
                  s.multiaddr = n.bytes();
                  break;
                case 2:
                  s.isCertified = n.bool();
                  break;
                default:
                  n.skipType(a & 7);
                  break;
              }
            }
            return s;
          }, t.fromObject = function(n) {
            if (n instanceof yn.Address)
              return n;
            var i2 = new yn.Address();
            return n.multiaddr != null && (typeof n.multiaddr == "string" ? er.base64.decode(n.multiaddr, i2.multiaddr = er.newBuffer(er.base64.length(n.multiaddr)), 0) : n.multiaddr.length && (i2.multiaddr = n.multiaddr)), n.isCertified != null && (i2.isCertified = Boolean(n.isCertified)), i2;
          }, t.toObject = function(n, i2) {
            i2 || (i2 = {});
            var o = {};
            return i2.defaults && (i2.bytes === String ? o.multiaddr = "" : (o.multiaddr = [], i2.bytes !== Array && (o.multiaddr = er.newBuffer(o.multiaddr)))), n.multiaddr != null && n.hasOwnProperty("multiaddr") && (o.multiaddr = i2.bytes === String ? er.base64.encode(n.multiaddr, 0, n.multiaddr.length) : i2.bytes === Array ? Array.prototype.slice.call(n.multiaddr) : n.multiaddr), n.isCertified != null && n.hasOwnProperty("isCertified") && (o.isCertified = n.isCertified, i2.oneofs && (o._isCertified = "isCertified")), o;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, Yc.default.util.toJSONOptions);
          }, t;
        })(), Kst = yn.Metadata = (() => {
          function t(e) {
            if (e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.key = "", t.prototype.value = er.newBuffer([]), t.encode = function(r, n) {
            return n || (n = DT.create()), r.key != null && Object.hasOwnProperty.call(r, "key") && n.uint32(10).string(r.key), r.value != null && Object.hasOwnProperty.call(r, "value") && n.uint32(18).bytes(r.value), n;
          }, t.decode = function(r, n) {
            r instanceof Y0 || (r = Y0.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new yn.Metadata(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.key = r.string();
                  break;
                case 2:
                  o.value = r.bytes();
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof yn.Metadata)
              return r;
            var n = new yn.Metadata();
            return r.key != null && (n.key = String(r.key)), r.value != null && (typeof r.value == "string" ? er.base64.decode(r.value, n.value = er.newBuffer(er.base64.length(r.value)), 0) : r.value.length && (n.value = r.value)), n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            return n.defaults && (i2.key = "", n.bytes === String ? i2.value = "" : (i2.value = [], n.bytes !== Array && (i2.value = er.newBuffer(i2.value)))), r.key != null && r.hasOwnProperty("key") && (i2.key = r.key), r.value != null && r.hasOwnProperty("value") && (i2.value = n.bytes === String ? er.base64.encode(r.value, 0, r.value.length) : n.bytes === Array ? Array.prototype.slice.call(r.value) : r.value), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, Yc.default.util.toJSONOptions);
          }, t;
        })();
        c();
        var $h = w(Ea(), 1), yQ = $h.default.Reader, I9e = $h.default.Writer, Br = $h.default.util, T8 = $h.default.roots.default || ($h.default.roots.default = {}), gQ = T8.Envelope = (() => {
          function t(e) {
            if (e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.publicKey = Br.newBuffer([]), t.prototype.payloadType = Br.newBuffer([]), t.prototype.payload = Br.newBuffer([]), t.prototype.signature = Br.newBuffer([]), t.encode = function(r, n) {
            return n || (n = I9e.create()), r.publicKey != null && Object.hasOwnProperty.call(r, "publicKey") && n.uint32(10).bytes(r.publicKey), r.payloadType != null && Object.hasOwnProperty.call(r, "payloadType") && n.uint32(18).bytes(r.payloadType), r.payload != null && Object.hasOwnProperty.call(r, "payload") && n.uint32(26).bytes(r.payload), r.signature != null && Object.hasOwnProperty.call(r, "signature") && n.uint32(42).bytes(r.signature), n;
          }, t.decode = function(r, n) {
            r instanceof yQ || (r = yQ.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new T8.Envelope(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.publicKey = r.bytes();
                  break;
                case 2:
                  o.payloadType = r.bytes();
                  break;
                case 3:
                  o.payload = r.bytes();
                  break;
                case 5:
                  o.signature = r.bytes();
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof T8.Envelope)
              return r;
            var n = new T8.Envelope();
            return r.publicKey != null && (typeof r.publicKey == "string" ? Br.base64.decode(r.publicKey, n.publicKey = Br.newBuffer(Br.base64.length(r.publicKey)), 0) : r.publicKey.length && (n.publicKey = r.publicKey)), r.payloadType != null && (typeof r.payloadType == "string" ? Br.base64.decode(r.payloadType, n.payloadType = Br.newBuffer(Br.base64.length(r.payloadType)), 0) : r.payloadType.length && (n.payloadType = r.payloadType)), r.payload != null && (typeof r.payload == "string" ? Br.base64.decode(r.payload, n.payload = Br.newBuffer(Br.base64.length(r.payload)), 0) : r.payload.length && (n.payload = r.payload)), r.signature != null && (typeof r.signature == "string" ? Br.base64.decode(r.signature, n.signature = Br.newBuffer(Br.base64.length(r.signature)), 0) : r.signature.length && (n.signature = r.signature)), n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            return n.defaults && (n.bytes === String ? i2.publicKey = "" : (i2.publicKey = [], n.bytes !== Array && (i2.publicKey = Br.newBuffer(i2.publicKey))), n.bytes === String ? i2.payloadType = "" : (i2.payloadType = [], n.bytes !== Array && (i2.payloadType = Br.newBuffer(i2.payloadType))), n.bytes === String ? i2.payload = "" : (i2.payload = [], n.bytes !== Array && (i2.payload = Br.newBuffer(i2.payload))), n.bytes === String ? i2.signature = "" : (i2.signature = [], n.bytes !== Array && (i2.signature = Br.newBuffer(i2.signature)))), r.publicKey != null && r.hasOwnProperty("publicKey") && (i2.publicKey = n.bytes === String ? Br.base64.encode(r.publicKey, 0, r.publicKey.length) : n.bytes === Array ? Array.prototype.slice.call(r.publicKey) : r.publicKey), r.payloadType != null && r.hasOwnProperty("payloadType") && (i2.payloadType = n.bytes === String ? Br.base64.encode(r.payloadType, 0, r.payloadType.length) : n.bytes === Array ? Array.prototype.slice.call(r.payloadType) : r.payloadType), r.payload != null && r.hasOwnProperty("payload") && (i2.payload = n.bytes === String ? Br.base64.encode(r.payload, 0, r.payload.length) : n.bytes === Array ? Array.prototype.slice.call(r.payload) : r.payload), r.signature != null && r.hasOwnProperty("signature") && (i2.signature = n.bytes === String ? Br.base64.encode(r.signature, 0, r.signature.length) : n.bytes === Array ? Array.prototype.slice.call(r.signature) : r.signature), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, $h.default.util.toJSONOptions);
          }, t;
        })();
        c();
        var Ul = w(Ea(), 1), I8 = Ul.default.Reader, wQ = Ul.default.Writer, jr = Ul.default.util, js = Ul.default.roots.default || (Ul.default.roots.default = {}), EQ = js.PeerRecord = (() => {
          function t(e) {
            if (this.addresses = [], e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.peerId = jr.newBuffer([]), t.prototype.seq = jr.Long ? jr.Long.fromBits(0, 0, true) : 0, t.prototype.addresses = jr.emptyArray, t.encode = function(r, n) {
            if (n || (n = wQ.create()), r.peerId != null && Object.hasOwnProperty.call(r, "peerId") && n.uint32(10).bytes(r.peerId), r.seq != null && Object.hasOwnProperty.call(r, "seq") && n.uint32(16).uint64(r.seq), r.addresses != null && r.addresses.length)
              for (var i2 = 0; i2 < r.addresses.length; ++i2)
                js.PeerRecord.AddressInfo.encode(r.addresses[i2], n.uint32(26).fork()).ldelim();
            return n;
          }, t.decode = function(r, n) {
            r instanceof I8 || (r = I8.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new js.PeerRecord(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.peerId = r.bytes();
                  break;
                case 2:
                  o.seq = r.uint64();
                  break;
                case 3:
                  o.addresses && o.addresses.length || (o.addresses = []), o.addresses.push(js.PeerRecord.AddressInfo.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof js.PeerRecord)
              return r;
            var n = new js.PeerRecord();
            if (r.peerId != null && (typeof r.peerId == "string" ? jr.base64.decode(r.peerId, n.peerId = jr.newBuffer(jr.base64.length(r.peerId)), 0) : r.peerId.length && (n.peerId = r.peerId)), r.seq != null && (jr.Long ? (n.seq = jr.Long.fromValue(r.seq)).unsigned = true : typeof r.seq == "string" ? n.seq = parseInt(r.seq, 10) : typeof r.seq == "number" ? n.seq = r.seq : typeof r.seq == "object" && (n.seq = new jr.LongBits(r.seq.low >>> 0, r.seq.high >>> 0).toNumber(true))), r.addresses) {
              if (!Array.isArray(r.addresses))
                throw TypeError(".PeerRecord.addresses: array expected");
              n.addresses = [];
              for (var i2 = 0; i2 < r.addresses.length; ++i2) {
                if (typeof r.addresses[i2] != "object")
                  throw TypeError(".PeerRecord.addresses: object expected");
                n.addresses[i2] = js.PeerRecord.AddressInfo.fromObject(r.addresses[i2]);
              }
            }
            return n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if ((n.arrays || n.defaults) && (i2.addresses = []), n.defaults)
              if (n.bytes === String ? i2.peerId = "" : (i2.peerId = [], n.bytes !== Array && (i2.peerId = jr.newBuffer(i2.peerId))), jr.Long) {
                var o = new jr.Long(0, 0, true);
                i2.seq = n.longs === String ? o.toString() : n.longs === Number ? o.toNumber() : o;
              } else
                i2.seq = n.longs === String ? "0" : 0;
            if (r.peerId != null && r.hasOwnProperty("peerId") && (i2.peerId = n.bytes === String ? jr.base64.encode(r.peerId, 0, r.peerId.length) : n.bytes === Array ? Array.prototype.slice.call(r.peerId) : r.peerId), r.seq != null && r.hasOwnProperty("seq") && (typeof r.seq == "number" ? i2.seq = n.longs === String ? String(r.seq) : r.seq : i2.seq = n.longs === String ? jr.Long.prototype.toString.call(r.seq) : n.longs === Number ? new jr.LongBits(r.seq.low >>> 0, r.seq.high >>> 0).toNumber(true) : r.seq), r.addresses && r.addresses.length) {
              i2.addresses = [];
              for (var s = 0; s < r.addresses.length; ++s)
                i2.addresses[s] = js.PeerRecord.AddressInfo.toObject(r.addresses[s], n);
            }
            return i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, Ul.default.util.toJSONOptions);
          }, t.AddressInfo = function() {
            function e(r) {
              if (r)
                for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                  r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
            }
            return e.prototype.multiaddr = jr.newBuffer([]), e.encode = function(n, i2) {
              return i2 || (i2 = wQ.create()), n.multiaddr != null && Object.hasOwnProperty.call(n, "multiaddr") && i2.uint32(10).bytes(n.multiaddr), i2;
            }, e.decode = function(n, i2) {
              n instanceof I8 || (n = I8.create(n));
              for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new js.PeerRecord.AddressInfo(); n.pos < o; ) {
                var a = n.uint32();
                switch (a >>> 3) {
                  case 1:
                    s.multiaddr = n.bytes();
                    break;
                  default:
                    n.skipType(a & 7);
                    break;
                }
              }
              return s;
            }, e.fromObject = function(n) {
              if (n instanceof js.PeerRecord.AddressInfo)
                return n;
              var i2 = new js.PeerRecord.AddressInfo();
              return n.multiaddr != null && (typeof n.multiaddr == "string" ? jr.base64.decode(n.multiaddr, i2.multiaddr = jr.newBuffer(jr.base64.length(n.multiaddr)), 0) : n.multiaddr.length && (i2.multiaddr = n.multiaddr)), i2;
            }, e.toObject = function(n, i2) {
              i2 || (i2 = {});
              var o = {};
              return i2.defaults && (i2.bytes === String ? o.multiaddr = "" : (o.multiaddr = [], i2.bytes !== Array && (o.multiaddr = jr.newBuffer(o.multiaddr)))), n.multiaddr != null && n.hasOwnProperty("multiaddr") && (o.multiaddr = i2.bytes === String ? jr.base64.encode(n.multiaddr, 0, n.multiaddr.length) : i2.bytes === Array ? Array.prototype.slice.call(n.multiaddr) : n.multiaddr), o;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, Ul.default.util.toJSONOptions);
            }, e;
          }(), t;
        })();
        var NT = w(mw(), 1);
        OT.default.util.Long = void 0;
        OT.default.configure();
        async function C9e(t, e = () => {
        }) {
          e(0, "Storing each peerstore key under a single datastore key"), await t.datastore.open();
          let r = {}, n = [];
          for await (let { key: i2, value: o } of t.datastore.query({ prefix: "/peers" })) {
            n.push(i2);
            let s = i2.toString(), [a, u, l, f, h] = s.split("/");
            if (u === "peers" && !!["protos", "addrs", "metadata", "keys"].includes(l) && !!f)
              if (r[f] = r[f] || { addresses: [], protocols: [], metadata: [] }, l === "protos") {
                let p = IT.decode(o);
                r[f].protocols = p.protocols.sort();
              } else if (l === "addrs") {
                let p = PT.decode(o);
                r[f].addresses = p.addrs.sort((d, m) => new NT.Multiaddr(d.multiaddr).toString().localeCompare(new NT.Multiaddr(m.multiaddr).toString())), p.certifiedRecord && p.certifiedRecord.raw && (r[f].peerRecordEnvelope = p.certifiedRecord.raw);
              } else
                l === "metadata" ? r[f].metadata.push({ key: h, value: o }) : l === "keys" && (r[f].pubKey = o);
          }
          e(33, "Read peer data from store");
          for (let i2 of n)
            await t.datastore.delete(i2);
          e(66, "Removed existing peer data from store");
          for (let i2 of Object.keys(r)) {
            let o = r[i2];
            o.metadata = o.metadata.sort((a, u) => a.key.localeCompare(u.key));
            let s = kT.encode(o).finish();
            await t.datastore.put(new ae(`/peers/${i2}`), s);
          }
          await t.datastore.close(), e(100, "Stored each peerstore key under a single datastore key");
        }
        async function P9e(t, e = () => {
        }) {
          e(0, "Storing each peerstore key under a multiple datastore keys"), await t.datastore.open();
          let r = {}, n = [];
          for await (let { key: i2, value: o } of t.datastore.query({ prefix: "/peers" })) {
            n.push(i2);
            let s = i2.toString(), [a, u, l] = s.split("/");
            r[l] = kT.decode(o);
          }
          e(33, "Read peer data from store");
          for (let i2 of n)
            await t.datastore.delete(i2);
          e(66, "Removed existing peer data from store");
          for (let [i2, o] of Object.entries(r)) {
            if (o.protocols && o.protocols.length > 0 && await t.datastore.put(new ae(`/peers/protos/${i2}`), IT.encode({ protocols: o.protocols }).finish()), o.addresses && o.addresses.length > 0) {
              let s = o.peerRecordEnvelope, a;
              if (s) {
                let u = gQ.decode(s), l = EQ.decode(u.payload);
                a = { raw: s, seq: l.seq };
              }
              await t.datastore.put(new ae(`/peers/addrs/${i2}`), PT.encode({ addrs: o.addresses, certifiedRecord: a }).finish());
            }
            if (o.metadata && o.metadata.length > 0)
              for (let { key: s, value: a } of o.metadata)
                await t.datastore.put(new ae(`/peers/metadata/${i2}/${s}`), a);
            o.pubKey && await t.datastore.put(new ae(`/peers/keys/${i2}`), o.pubKey);
          }
          await t.datastore.close(), e(100, "Stored each peerstore key under multiple datastore keys");
        }
        var bQ = { version: 12, description: "Store each peerstore peer under a single datastore key", migrate: C9e, revert: P9e };
        var Gh = { description: "Empty migration.", migrate: () => {
        }, revert: () => {
        }, empty: true }, C8 = [Object.assign({ version: 1 }, Gh), Object.assign({ version: 2 }, Gh), Object.assign({ version: 3 }, Gh), Object.assign({ version: 4 }, Gh), Object.assign({ version: 5 }, Gh), Object.assign({ version: 6 }, Gh), Object.assign({ version: 7 }, Gh), JY, cQ, hQ, pQ, bQ];
        c();
        c();
        var _Q = w(Mi(), 1);
        var LT = {};
        ct(LT, { InvalidValueError: () => Z0, MissingRepoOptionsError: () => $a, NonReversibleMigrationError: () => Q0, NotInitializedRepoError: () => Fl, RequiredParameterError: () => X0 });
        c();
        var Q0 = class extends Error {
          constructor(e) {
            super(e), this.name = "NonReversibleMigrationError", this.code = Q0.code, this.message = e;
          }
        };
        Q0.code = "ERR_NON_REVERSIBLE_MIGRATION";
        var Fl = class extends Error {
          constructor(e) {
            super(e), this.name = "NotInitializedRepoError", this.code = Fl.code, this.message = e;
          }
        };
        Fl.code = "ERR_NOT_INITIALIZED_REPO";
        var X0 = class extends Error {
          constructor(e) {
            super(e), this.name = "RequiredParameterError", this.code = X0.code, this.message = e;
          }
        };
        X0.code = "ERR_REQUIRED_PARAMETER";
        var Z0 = class extends Error {
          constructor(e) {
            super(e), this.name = "InvalidValueError", this.code = Z0.code, this.message = e;
          }
        };
        Z0.code = "ERR_INVALID_VALUE";
        var $a = class extends Error {
          constructor(e) {
            super(e), this.name = "MissingRepoOptionsError", this.code = $a.code, this.message = e;
          }
        };
        $a.code = "ERR_MISSING_REPO_OPTIONS";
        var BT = (0, _Q.default)("ipfs:repo:migrator:repo:init");
        async function vQ(t) {
          if (!t)
            throw new $a("Please pass repo options when trying to open a repo");
          let e = t.root;
          try {
            await e.open();
            let r = await e.has(rg), n = await e.has(uQ);
            return !r || !n ? (BT(`Version entry present: ${r}`), BT(`Config entry present: ${n}`), false) : true;
          } catch (r) {
            return BT("While checking if repo is initialized error was thrown: " + r.message), false;
          } finally {
            if (e !== void 0)
              try {
                await e.close();
              } catch {
              }
          }
        }
        Re();
        me();
        async function MT(t) {
          if (!await vQ(t))
            throw new Fl("Repo is not initialized!");
          let e = t.root;
          await e.open();
          try {
            return parseInt(M(await e.get(rg)));
          } finally {
            await e.close();
          }
        }
        async function ig(t, e) {
          if (!e)
            throw new $a("Please pass repo options when trying to open a repo");
          let r = e.root;
          await r.open(), await r.put(rg, U(String(t))), await r.close();
        }
        var SQ = w(Mi(), 1), Ys = (0, SQ.default)("ipfs:repo:migrator");
        function k9e(t) {
          return t = t || C8, !Array.isArray(t) || t.length === 0 ? 0 : t[t.length - 1].version;
        }
        async function xQ(t, e, r, n, { ignoreLock: i2 = false, onProgress: o, isDryRun: s = false, migrations: a }) {
          if (a = a || C8, !t)
            throw new is.RequiredParameterError("Path argument is required!");
          if (!r)
            throw new is.RequiredParameterError("repoOptions argument is required!");
          if (!n)
            throw new is.RequiredParameterError("toVersion argument is required!");
          if (!Number.isInteger(n) || n <= 0)
            throw new is.InvalidValueError("Version has to be positive integer!");
          e = TT(e);
          let u = await MT(e);
          if (u === n) {
            Ys("Nothing to migrate.");
            return;
          }
          if (u > n)
            throw new is.InvalidValueError(`Current repo's version (${u}) is higher then toVersion (${n}), you probably wanted to revert it?`);
          AQ(a, u, n);
          let l;
          !s && !i2 && (l = await r.repoLock.lock(t));
          try {
            for (let f of a) {
              if (n !== void 0 && f.version > n)
                break;
              if (!(f.version <= u)) {
                Ys(`Migrating version ${f.version}`);
                try {
                  if (!s) {
                    let h = () => {
                    };
                    o && (h = (p, d) => o(f.version, p.toFixed(2), d)), await f.migrate(e, h);
                  }
                } catch (h) {
                  let p = f.version - 1;
                  throw Ys(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${p}`), await ig(p, e), new Error(`During migration to version ${f.version} exception was raised: ${h.stack || h.message || h}`);
                }
                Ys(`Migrating to version ${f.version} finished`);
              }
            }
            s || await ig(n || k9e(a), e), Ys("Repo successfully migrated", n !== void 0 ? `to version ${n}!` : "to latest version!");
          } finally {
            !s && !i2 && l && await l.close();
          }
        }
        async function RQ(t, e, r, n, { ignoreLock: i2 = false, onProgress: o, isDryRun: s = false, migrations: a }) {
          if (a = a || C8, !t)
            throw new is.RequiredParameterError("Path argument is required!");
          if (!r)
            throw new is.RequiredParameterError("repoOptions argument is required!");
          if (!n)
            throw new is.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
          if (!Number.isInteger(n) || n <= 0)
            throw new is.InvalidValueError("Version has to be positive integer!");
          e = TT(e);
          let u = await MT(e);
          if (u === n) {
            Ys("Nothing to revert.");
            return;
          }
          if (u < n)
            throw new is.InvalidValueError(`Current repo's version (${u}) is lower then toVersion (${n}), you probably wanted to migrate it?`);
          AQ(a, n, u, true);
          let l;
          !s && !i2 && (l = await r.repoLock.lock(t)), Ys(`Reverting from version ${u} to ${n}`);
          try {
            let f = a.slice().reverse();
            for (let h of f) {
              if (h.version <= n)
                break;
              if (!(h.version > u)) {
                Ys(`Reverting migration version ${h.version}`);
                try {
                  if (!s) {
                    let p = () => {
                    };
                    o && (p = (d, m) => o(h.version, d.toFixed(2), m)), await h.revert(e, p);
                  }
                } catch (p) {
                  let d = h.version;
                  throw Ys(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${d}`), await ig(d, e), p.message = `During reversion to version ${h.version} exception was raised: ${p.message}`, p;
                }
                Ys(`Reverting to version ${h.version} finished`);
              }
            }
            s || await ig(n, e), Ys(`All migrations successfully reverted to version ${n}!`);
          } finally {
            !s && !i2 && l && await l.close();
          }
        }
        function AQ(t, e, r, n = false) {
          let i2 = 0;
          for (let o of t) {
            if (o.version > r)
              break;
            if (o.version > e) {
              if (n && !o.revert)
                throw new is.NonReversibleMigrationError(`It is not possible to revert to version ${e} because migration version ${o.version} is not reversible. Cancelling reversion.`);
              i2++;
            }
          }
          if (i2 !== r - e)
            throw new is.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${e} to ${r}`);
        }
        var is = LT;
        var tZ = w(CQ(), 1);
        c();
        var NQ = w(Mi(), 1);
        me();
        Re();
        c();
        c();
        var Wh = class extends Error {
          constructor(e) {
            super(e), this.name = "LockExistsError", this.code = Wh.code;
          }
        };
        Wh.code = "ERR_LOCK_EXISTS";
        var Eo = class extends Error {
          constructor(e) {
            super(e), this.name = "NotFoundError", this.code = Eo.code;
          }
        };
        Eo.code = "ERR_NOT_FOUND";
        var jh = class extends Error {
          constructor(e) {
            super(e), this.name = "InvalidRepoVersionError", this.code = jh.code;
          }
        };
        jh.code = "ERR_INVALID_REPO_VERSION";
        var Yh = "ERR_REPO_NOT_INITIALIZED", PQ = "ERR_REPO_ALREADY_OPEN", DQ = "ERR_REPO_ALREADY_CLOSED";
        async function D8(t, e, r) {
          let n = await e(t);
          if (n)
            return n;
          let i2 = kQ(r);
          return i2 ? new Promise((o, s) => {
            let a = i2.store("readonly").get(t.toString());
            a.transaction.onabort = () => {
              s(a.transaction.error);
            }, a.transaction.oncomplete = () => {
              o(Boolean(a.result));
            };
          }) : false;
        }
        async function k8(t, e, r, n) {
          if (await r(t))
            return e(t);
          let i2 = kQ(n);
          if (!i2)
            throw new Eo();
          return new Promise((o, s) => {
            let a = i2.store("readonly").get(t.toString());
            a.transaction.onabort = () => {
              s(a.transaction.error);
            }, a.transaction.oncomplete = () => {
              if (a.result)
                return o(a.result);
              s(new Eo());
            };
          });
        }
        function kQ(t) {
          let e = t;
          for (; e.db || e.child; )
            if (e = e.db || e.child, e.type === "level-js" || e.constructor.name === "Level")
              return e;
        }
        var F9e = (0, NQ.default)("ipfs:repo:version"), UT = new ae("version");
        function OQ(t) {
          return { async exists() {
            return D8(UT, t.has.bind(t), t);
          }, async get() {
            let e = await k8(UT, t.get.bind(t), t.has.bind(t), t);
            return parseInt(M(e), 10);
          }, set(e) {
            return t.put(UT, U(String(e)));
          }, async check(e) {
            let r = await this.get();
            return F9e("comparing version: %s and %s", r, e), r === e || (r === 6 && e === 7 || e === 6 && r === 7);
          } };
        }
        c();
        var B8 = w(HT(), 1), $Q = w(_T(), 1), GQ = w(HQ(), 1), M8 = w(K(), 1);
        me();
        Re();
        var W9e = B8.default.default ? B8.default.default : B8.default, $T = new ae("config");
        function WQ(t) {
          let e = new W9e({ concurrency: 1 }), r = { async getAll(o = {}) {
            let s = await k8($T, t.get.bind(t), t.has.bind(t), t);
            return JSON.parse(M(s));
          }, async get(o, s = {}) {
            if (o == null)
              throw new Eo(`Key ${o} does not exist in config`);
            let a = await this.getAll(s), u = (0, $Q.default)(a, o);
            if (u === void 0)
              throw new Eo(`Key ${o} does not exist in config`);
            return u;
          }, set(o, s, a = {}) {
            if (typeof o != "string" && !(o instanceof String))
              throw (0, M8.default)(new Error("Invalid key type: " + typeof o), "ERR_INVALID_KEY");
            if (s === void 0 || s instanceof Uint8Array)
              throw (0, M8.default)(new Error("Invalid value type: " + typeof s), "ERR_INVALID_VALUE");
            return e.add(() => n({ key: o, value: s }, a.signal));
          }, replace(o, s = {}) {
            if (!o || o instanceof Uint8Array)
              throw (0, M8.default)(new Error("Invalid value type: " + typeof o), "ERR_INVALID_VALUE");
            return e.add(() => n({ key: void 0, value: o }, s.signal));
          }, async exists() {
            return D8($T, t.has.bind(t), t);
          } };
          return r;
          async function n(o, s) {
            if (s && s.aborted)
              return;
            let a = o.key, u = o.value;
            if (a) {
              let l = await r.getAll();
              return typeof l == "object" && l !== null && (0, GQ.default)(l, a, u), i2(l);
            }
            return i2(u);
          }
          function i2(o) {
            let s = U(JSON.stringify(o, null, 2));
            return t.put($T, s);
          }
        }
        c();
        var QQ = w(YQ(), 1);
        me();
        Re();
        var WT = new ae("datastore_spec");
        function XQ(t) {
          return { exists() {
            return t.has(WT);
          }, async get() {
            let e = await t.get(WT);
            return JSON.parse(M(e));
          }, async set(e) {
            return t.put(WT, U(JSON.stringify((0, QQ.default)(e, { deep: true }))));
          } };
        }
        c();
        Re();
        var jT = new ae("api");
        function ZQ(t) {
          return { async get() {
            let e = await t.get(jT);
            return e && e.toString();
          }, set(e) {
            return t.put(jT, U(e.toString()));
          }, delete() {
            return t.delete(jT);
          } };
        }
        c();
        var tX = w(Gi(), 1), rX = w(eX(), 1), nX = w(Ci(), 1);
        te();
        var iX = w(K(), 1);
        va();
        function oX(t) {
          return { open() {
            return t.open();
          }, close() {
            return t.close();
          }, query(e, r) {
            return t.query(e, r);
          }, queryKeys(e, r) {
            return t.queryKeys(e, r);
          }, async get(e, r) {
            let n = Vl(e);
            return n.isIdentity ? Promise.resolve(n.digest) : t.get(e, r);
          }, async *getMany(e, r) {
            for await (let n of e)
              yield this.get(n, r);
          }, async put(e, r, n) {
            let { isIdentity: i2 } = Vl(e);
            i2 || await t.put(e, r, n);
          }, async *putMany(e, r) {
            let n = (0, rX.default)();
            (globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout)(async () => {
              try {
                await (0, nX.default)(t.putMany(async function* () {
                  for await (let { key: o, value: s } of e)
                    Vl(o).isIdentity || (yield { key: o, value: s }), n.push({ key: o, value: s });
                }())), n.end();
              } catch (o) {
                n.end(o);
              }
            }), yield* n;
          }, has(e, r) {
            let { isIdentity: n } = Vl(e);
            return n ? Promise.resolve(true) : t.has(e, r);
          }, delete(e, r) {
            let { isIdentity: n } = Vl(e);
            return n ? Promise.resolve() : t.delete(e, r);
          }, deleteMany(e, r) {
            return t.deleteMany((0, tX.default)(e, (n) => !Vl(n).isIdentity), r);
          }, batch() {
            let e = t.batch();
            return { put(r, n) {
              let { isIdentity: i2 } = Vl(r);
              i2 || e.put(r, n);
            }, delete(r) {
              let { isIdentity: n } = Vl(r);
              n || e.delete(r);
            }, commit: (r) => e.commit(r) };
          } };
        }
        function Vl(t) {
          let e = I.asCID(t);
          if (e == null)
            throw (0, iX.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
          return e.multihash.code !== $r.code ? { isIdentity: false } : { isIdentity: true, digest: e.multihash.digest };
        }
        c();
        c();
        var sX = w(Mi(), 1), aX = (0, sX.default)("ipfs:repo:lock:memory"), cX = "repo.lock", og = {};
        async function j9e(t) {
          let e = t + "/" + cX;
          if (aX("locking %s", e), og[e] === true)
            throw new Wh(`Lock already being held for file: ${e}`);
          return og[e] = true, { async close() {
            og[e] && delete og[e];
          } };
        }
        async function Y9e(t) {
          let e = t + "/" + cX;
          return aX(`checking lock: ${e}`), Boolean(og[e]);
        }
        var U8 = { lock: j9e, locked: Y9e };
        var uX = { autoMigrate: true, onMigrationProgress: () => {
        }, repoOwner: true, repoLock: U8 };
        c();
        var QT = { Spec: { type: "mount", mounts: [{ mountpoint: "/blocks", type: "measure", prefix: "flatfs.datastore", child: { type: "flatfs", path: "blocks", sync: true, shardFunc: "/repo/flatfs/shard/v1/next-to-last/2" } }, { mountpoint: "/", type: "measure", prefix: "leveldb.datastore", child: { type: "levelds", path: "datastore", compression: "none" } }] } };
        c();
        te();
        var hX = w(K(), 1), dX = w(Mi(), 1), ZT = w(Gc(), 1);
        Vf();
        c();
        bp();
        zo();
        var lX = w(K(), 1);
        si();
        On();
        function sg(t) {
          let e = I.asCID(t);
          if (e == null)
            throw (0, lX.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
          let r = xt.encode(e.multihash.bytes);
          return new ae("/" + r.slice(1).toUpperCase(), false);
        }
        function XT(t) {
          return _r(xt.decode(`b${t.toString().toLowerCase().substring(1)}`));
        }
        c();
        var fX = w(Mi(), 1);
        var Q9e = (0, fX.default)("ipfs:repo:utils:walk-dag");
        async function* J0(t, e, r, n) {
          try {
            let i2 = await e.get(t, n), o = await r(t.code), s = N0({ bytes: i2, cid: t, codec: o });
            for (let [, a] of s.links())
              yield a, yield* J0(a, e, r, n);
          } catch (i2) {
            throw Q9e("Could not walk DAG for CID", t.toString(), i2), i2;
          }
        }
        function X9e(t) {
          let e = `Invalid type '${t}', must be one of {direct, indirect, recursive, all}`;
          return (0, hX.default)(new Error(e), "ERR_INVALID_PIN_TYPE");
        }
        var F8 = class {
          constructor({ pinstore: e, blockstore: r, loadCodec: n }) {
            this.pinstore = e, this.blockstore = r, this.loadCodec = n, this.log = (0, dX.default)("ipfs:repo:pin"), this.directPins = /* @__PURE__ */ new Set(), this.recursivePins = /* @__PURE__ */ new Set();
          }
          async pinDirectly(e, r = {}) {
            await this.blockstore.get(e, r);
            let n = { depth: 0 };
            return e.version !== 0 && (n.version = e.version), e.code !== pt && (n.codec = e.code), r.metadata && (n.metadata = r.metadata), this.pinstore.put(sg(e), ao(n));
          }
          unpin(e, r) {
            return this.pinstore.delete(sg(e), r);
          }
          async pinRecursively(e, r = {}) {
            await this.fetchCompleteDag(e, r);
            let n = { depth: 1 / 0 };
            e.version !== 0 && (n.version = e.version), e.code !== pt && (n.codec = e.code), r.metadata && (n.metadata = r.metadata), await this.pinstore.put(sg(e), ao(n));
          }
          async *directKeys(e) {
            for await (let r of this.pinstore.query({ filters: [(n) => Mn(n.value).depth === 0] })) {
              let n = Mn(r.value), i2 = n.version || 0, o = n.codec != null ? n.codec : pt, s = XT(r.key);
              yield { cid: I.create(i2, o, s), metadata: n.metadata };
            }
          }
          async *recursiveKeys(e) {
            for await (let r of this.pinstore.query({ filters: [(n) => Mn(n.value).depth === 1 / 0] })) {
              let n = Mn(r.value), i2 = n.version || 0, o = n.codec != null ? n.codec : pt, s = XT(r.key);
              yield { cid: I.create(i2, o, s), metadata: n.metadata };
            }
          }
          async *indirectKeys(e) {
            for await (let { cid: r } of this.recursiveKeys())
              for await (let n of J0(r, this.blockstore, this.loadCodec, e)) {
                let i2 = [vt.recursive];
                (await this.isPinnedWithType(n, i2)).pinned || (yield n);
              }
          }
          async isPinnedWithType(e, r, n) {
            Array.isArray(r) || (r = [r]);
            let i2 = r.includes(vt.all), o = r.includes(vt.direct), s = r.includes(vt.recursive), a = r.includes(vt.indirect);
            if (s || o || i2) {
              let f = await (0, ZT.default)(this.pinstore.query({ prefix: sg(e).toString(), filters: [(h) => {
                if (i2)
                  return true;
                let p = Mn(h.value);
                return r.includes(p.depth === 0 ? vt.direct : vt.recursive);
              }], limit: 1 }));
              if (f) {
                let h = Mn(f.value);
                return { cid: e, pinned: true, reason: h.depth === 0 ? vt.direct : vt.recursive, metadata: h.metadata };
              }
            }
            let u = this;
            async function* l(f, h) {
              for await (let { cid: p } of h)
                for await (let d of J0(p, u.blockstore, u.loadCodec))
                  if (d.equals(f)) {
                    yield p;
                    return;
                  }
            }
            if (i2 || a) {
              let f = await (0, ZT.default)(l(e, this.recursiveKeys()));
              if (f)
                return { cid: e, pinned: true, reason: vt.indirect, parent: f };
            }
            return { cid: e, pinned: false };
          }
          async fetchCompleteDag(e, r) {
            let n = /* @__PURE__ */ new Set(), i2 = async (o, s) => {
              if (n.has(o.toString()))
                return;
              n.add(o.toString());
              let a = await this.blockstore.get(o, s), u = await this.loadCodec(o.code), l = N0({ bytes: a, cid: o, codec: u });
              await Promise.all([...l.links()].map(([, f]) => i2(f, s)));
            };
            await i2(e, r);
          }
          static checkPinType(e) {
            if (typeof e != "string" || !Object.keys(vt).includes(e))
              throw X9e(e);
            return true;
          }
        };
        c();
        var mX = w(ei(), 1), yX = w(K(), 1);
        function gX(t, e) {
          return { open() {
            return e.open();
          }, close() {
            return e.close();
          }, query(r, n) {
            return e.query(r, n);
          }, queryKeys(r, n) {
            return e.queryKeys(r, n);
          }, async get(r, n) {
            return e.get(r, n);
          }, async *getMany(r, n) {
            yield* e.getMany(r, n);
          }, async put(r, n, i2) {
            await e.put(r, n, i2);
          }, async *putMany(r, n) {
            yield* e.putMany(r, n);
          }, has(r, n) {
            return e.has(r, n);
          }, async delete(r, n) {
            return await pX(r, t), e.delete(r, n);
          }, deleteMany(r, n) {
            return e.deleteMany((0, mX.default)(r, async (i2) => (await pX(i2, t), i2)), n);
          }, batch() {
            return e.batch();
          } };
        }
        async function pX(t, e) {
          let { pinned: r, reason: n } = await e.isPinnedWithType(t, vt.all);
          if (r)
            throw (0, yX.default)(new Error(`pinned: ${n}`), "ERR_BLOCK_PINNED");
        }
        var rZ = w(HX(), 1);
        c();
        te();
        var jX = w(Mi(), 1);
        var YX = w(d5(), 1), QX = w(WX(), 1), oI = w(Fc(), 1), q8 = w(ei(), 1), XX = w(Gi(), 1);
        si();
        var cg = (0, jX.default)("ipfs:repo:gc"), lSe = Rn().code, fSe = 256, hSe = new ae("/local/filesroot");
        function ZX({ gcLock: t, pins: e, blockstore: r, root: n, loadCodec: i2 }) {
          async function* o() {
            let s = Date.now();
            cg("Creating set of marked blocks");
            let a = await t.writeLock();
            try {
              let u = await dSe({ pins: e, blockstore: r, root: n, loadCodec: i2 }), l = r.queryKeys({});
              yield* pSe({ blockstore: r }, u, l), cg(`Complete (${Date.now() - s}ms)`);
            } finally {
              a();
            }
          }
          return o;
        }
        async function dSe({ pins: t, blockstore: e, loadCodec: r, root: n }) {
          let i2 = async function* () {
            let a;
            try {
              a = await n.get(hSe);
            } catch (l) {
              if (l.code === lSe) {
                cg("No blocks in MFS");
                return;
              }
              throw l;
            }
            let u = I.decode(a);
            yield u, yield* J0(u, e, r);
          }(), o = (0, oI.default)((0, q8.default)(t.recursiveKeys(), ({ cid: a }) => a), t.indirectKeys(), (0, q8.default)(t.directKeys(), ({ cid: a }) => a), i2), s = /* @__PURE__ */ new Set();
          for await (let a of (0, oI.default)(o, i2))
            s.add(xt.encode(a.multihash.bytes));
          return s;
        }
        async function* pSe({ blockstore: t }, e, r) {
          let n = 0, i2 = 0;
          yield* (0, QX.pipe)((0, YX.default)((0, q8.default)(r, async (s) => async function() {
            n++;
            try {
              let u = xt.encode(s.multihash.bytes);
              if (e.has(u))
                return null;
              try {
                await t.delete(s), i2++;
              } catch (l) {
                return { err: new Error(`Could not delete block with CID ${s}: ${l.message}`) };
              }
              return { cid: s };
            } catch (u) {
              let l = `Could delete block with CID ${s}`;
              return cg(l, u), { err: new Error(l + `: ${u.message}`) };
            }
          }), fSe), (s) => (0, XX.default)(s, Boolean)), cg(`Marked set has ${e.size} unique blocks. Blockstore has ${n} blocks. Deleted ${i2} blocks.`);
        }
        var Qi = (0, eZ.default)("ipfs:repo"), mSe = Number.MAX_SAFE_INTEGER, ySe = "repoAutoMigrate", sI = class {
          constructor(e, r, n, i2) {
            if (typeof e != "string")
              throw new Error("missing repo path");
            if (typeof r != "function")
              throw new Error("missing codec loader");
            this.options = Ze(uX, i2), this.closed = true, this.path = e, this.root = n.root, this.datastore = n.datastore, this.keys = n.keys;
            let o = n.blocks, s = n.pins;
            this.pins = new F8({ pinstore: s, blockstore: o, loadCodec: r });
            let a = gX(this.pins, o);
            this.blocks = oX(a), this.version = OQ(this.root), this.config = WQ(this.root), this.spec = XQ(this.root), this.apiAddr = ZQ(this.root), this.gcLock = (0, rZ.default)(e, { singleProcess: this.options.repoOwner !== false }), this.gc = ZX({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec: r });
          }
          async init(e) {
            Qi("initializing at: %s", this.path), await this._openRoot(), await this.config.replace(gSe(e)), await this.spec.set(wSe(e)), await this.version.set(12);
          }
          async isInitialized() {
            if (!this.closed)
              return true;
            try {
              return await this._openRoot(), await this._checkInitialized(), await this.root.close(), true;
            } catch {
              return false;
            }
          }
          async open() {
            if (!this.closed)
              throw (0, Xh.default)(new Error("repo is already open"), PQ);
            Qi("opening at: %s", this.path);
            try {
              if (await this._openRoot(), await this._checkInitialized(), this._lockfile = await this._openLock(), Qi("acquired repo.lock"), !await this.version.check(12))
                if (await this._isAutoMigrationEnabled())
                  await this._migrate(12, { root: this.root, datastore: this.datastore, pins: this.pins.pinstore, blocks: this.pins.blockstore, keys: this.keys });
                else
                  throw new jh("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
              Qi("creating datastore"), await this.datastore.open(), Qi("creating blocks"), await this.blocks.open(), Qi("creating keystore"), await this.keys.open(), Qi("creating pins"), await this.pins.pinstore.open(), this.closed = false, Qi("all opened");
            } catch (e) {
              if (this._lockfile)
                try {
                  await this._closeLock(), this._lockfile = null;
                } catch (r) {
                  Qi("error removing lock", r);
                }
              throw e;
            }
          }
          async _openRoot() {
            try {
              await this.root.open();
            } catch (e) {
              if (e.message !== "Already open")
                throw e;
            }
          }
          async _openLock() {
            let e = await this.options.repoLock.lock(this.path);
            if (typeof e.close != "function")
              throw (0, Xh.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
            return e;
          }
          _closeLock() {
            return this._lockfile && this._lockfile.close();
          }
          async _checkInitialized() {
            Qi("init check");
            let e;
            try {
              [e] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);
            } catch (r) {
              throw r.code === "ERR_NOT_FOUND" ? (0, Xh.default)(new Error("repo is not initialized yet"), Yh, { path: this.path }) : r;
            }
            if (!e)
              throw (0, Xh.default)(new Error("repo is not initialized yet"), Yh, { path: this.path });
          }
          async close() {
            if (this.closed)
              throw (0, Xh.default)(new Error("repo is already closed"), DQ);
            Qi("closing at: %s", this.path);
            try {
              await this.apiAddr.delete();
            } catch (e) {
              if (e.code !== Yh && !e.message.startsWith("ENOENT"))
                throw e;
            }
            await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins.pinstore].map((e) => e && e.close())), Qi("unlocking"), this.closed = true, await this._closeLock();
          }
          exists() {
            return this.version.exists();
          }
          async stat() {
            if (this.datastore && this.keys) {
              let [e, r, n, i2, o] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), JX(this.datastore), JX(this.keys)]), s = r.size + i2 + o;
              return { repoPath: this.path, storageMax: e, version: n, numObjects: r.count, repoSize: s };
            }
            throw (0, Xh.default)(new Error("repo is not initialized yet"), Yh, { path: this.path });
          }
          async _isAutoMigrationEnabled() {
            if (this.options.autoMigrate !== void 0)
              return this.options.autoMigrate;
            let e;
            try {
              e = await this.config.get(ySe);
            } catch (r) {
              if (r.code === Eo.code)
                e = true;
              else
                throw r;
            }
            return e;
          }
          async _migrate(e, r) {
            return await this.version.get() > e ? (Qi(`reverting to version ${e}`), RQ(this.path, r, this.options, e, { ignoreLock: true, onProgress: this.options.onMigrationProgress })) : (Qi(`migrating to version ${e}`), xQ(this.path, r, this.options, e, { ignoreLock: true, onProgress: this.options.onMigrationProgress }));
          }
          async _storageMaxStat() {
            try {
              let e = await this.config.get("Datastore.StorageMax");
              return BigInt((0, tZ.default)(e));
            } catch {
              return BigInt(mSe);
            }
          }
          async _blockStat() {
            let e = BigInt(0), r = BigInt(0);
            if (this.blocks)
              for await (let { key: n, value: i2 } of this.blocks.query({}))
                e += BigInt(1), r += BigInt(i2.byteLength), r += BigInt(n.bytes.byteLength);
            return { count: e, size: r };
          }
        };
        async function JX(t) {
          let e = BigInt(0);
          for await (let r of t.query({}))
            e += BigInt(r.value.byteLength), e += BigInt(r.key.uint8Array().byteLength);
          return e;
        }
        function nZ(t, e, r, n) {
          return new sI(t, e, r, n);
        }
        function gSe(t) {
          return t.Datastore = Object.assign({}, QT, (0, aI.default)(t, "datastore")), t;
        }
        function wSe(t) {
          let e = { ...QT.Spec, ...(0, aI.default)(t, "Datastore.Spec") };
          return { type: e.type, mounts: e.mounts.map((r) => ({ mountpoint: r.mountpoint, type: r.child.type, path: r.child.path, shardFunc: r.child.shardFunc })) };
        }
        c();
        var Tg = w(Gi(), 1), Oee = w(ei(), 1), fC = w(h0(), 1), hC = w(ug(), 1), Lee = w(Nee(), 1), Ql = class extends Wi {
          constructor(e, r) {
            super(), this.path = e, this.opts = r, r && r.db ? (this.database = r.db, delete r.db) : this.database = Lee.default;
          }
          _initDb() {
            return new Promise((e, r) => {
              this.db = this.database(this.path, { ...this.opts, valueEncoding: "binary", compression: false }, (n) => {
                if (n)
                  return r(n);
                e(this.db);
              });
            });
          }
          async open() {
            try {
              this.db ? await this.db.open() : this.db = await this._initDb();
            } catch (e) {
              throw m0.dbOpenFailedError(e);
            }
          }
          async put(e, r) {
            try {
              await this.db.put(e.toString(), r);
            } catch (n) {
              throw m0.dbWriteFailedError(n);
            }
          }
          async get(e) {
            let r;
            try {
              r = await this.db.get(e.toString());
            } catch (n) {
              throw n.notFound ? m0.notFoundError(n) : m0.dbWriteFailedError(n);
            }
            return r;
          }
          async has(e) {
            try {
              await this.db.get(e.toString());
            } catch (r) {
              if (r.notFound)
                return false;
              throw r;
            }
            return true;
          }
          async delete(e) {
            try {
              await this.db.del(e.toString());
            } catch (r) {
              throw m0.dbDeleteFailedError(r);
            }
          }
          close() {
            return this.db && this.db.close();
          }
          batch() {
            let e = [];
            return { put: (r, n) => {
              e.push({ type: "put", key: r.toString(), value: n });
            }, delete: (r) => {
              e.push({ type: "del", key: r.toString() });
            }, commit: () => this.db.batch(e) };
          }
          query(e) {
            let r = this._query({ values: true, prefix: e.prefix });
            Array.isArray(e.filters) && (r = e.filters.reduce((o, s) => (0, Tg.default)(o, s), r)), Array.isArray(e.orders) && (r = e.orders.reduce((o, s) => (0, hC.default)(o, s), r));
            let { offset: n, limit: i2 } = e;
            if (n) {
              let o = 0;
              r = (0, Tg.default)(r, () => o++ >= n);
            }
            return i2 && (r = (0, fC.default)(r, i2)), r;
          }
          queryKeys(e) {
            let r = (0, Oee.default)(this._query({ values: false, prefix: e.prefix }), ({ key: o }) => o);
            Array.isArray(e.filters) && (r = e.filters.reduce((o, s) => (0, Tg.default)(o, s), r)), Array.isArray(e.orders) && (r = e.orders.reduce((o, s) => (0, hC.default)(o, s), r));
            let { offset: n, limit: i2 } = e;
            if (n) {
              let o = 0;
              r = (0, Tg.default)(r, () => o++ >= n);
            }
            return i2 && (r = (0, fC.default)(r, i2)), r;
          }
          _query(e) {
            let r = { keys: true, keyAsBuffer: true, values: e.values };
            if (e.prefix != null) {
              let n = e.prefix.toString();
              r.gte = n, r.lt = n + "\xFF";
            }
            return NAe(this.db.iterator(r));
          }
        };
        function NAe(t) {
          return { [Symbol.asyncIterator]() {
            return { next: () => new Promise((e, r) => {
              t.next((n, i2, o) => {
                if (n)
                  return r(n);
                if (i2 == null)
                  return t.end((s) => {
                    if (s)
                      return r(s);
                    e({ done: true, value: void 0 });
                  });
                e({ done: false, value: { key: new ae(i2, false), value: o } });
              });
            }), return: () => new Promise((e, r) => {
              t.end((n) => {
                if (n)
                  return r(n);
                e({ done: true, value: void 0 });
              });
            }) };
          } };
        }
        c();
        var yC = w(Ci(), 1), gC = w(Mee(), 1);
        te();
        zo();
        On();
        si();
        Hr();
        var Kee = w(K(), 1);
        c();
        var pC = w(Ci(), 1), cd = w(Gi(), 1), mC = w(h0(), 1), Fee = w(Vs(), 1), Uee = (t, e) => async function* () {
          yield* (await (0, Fee.default)(t)).sort(e);
        }(), ja = class {
          open() {
            return Promise.reject(new Error(".open is not implemented"));
          }
          close() {
            return Promise.reject(new Error(".close is not implemented"));
          }
          put(e, r, n) {
            return Promise.reject(new Error(".put is not implemented"));
          }
          get(e, r) {
            return Promise.reject(new Error(".get is not implemented"));
          }
          has(e, r) {
            return Promise.reject(new Error(".has is not implemented"));
          }
          delete(e, r) {
            return Promise.reject(new Error(".delete is not implemented"));
          }
          async *putMany(e, r = {}) {
            for await (let { key: n, value: i2 } of e)
              await this.put(n, i2, r), yield { key: n, value: i2 };
          }
          async *getMany(e, r = {}) {
            for await (let n of e)
              yield this.get(n, r);
          }
          async *deleteMany(e, r = {}) {
            for await (let n of e)
              await this.delete(n, r), yield n;
          }
          batch() {
            let e = [], r = [];
            return { put(n, i2) {
              e.push({ key: n, value: i2 });
            }, delete(n) {
              r.push(n);
            }, commit: async (n) => {
              await (0, pC.default)(this.putMany(e, n)), e = [], await (0, pC.default)(this.deleteMany(r, n)), r = [];
            } };
          }
          async *_all(e, r) {
            throw new Error("._all is not implemented");
          }
          async *_allKeys(e, r) {
            throw new Error("._allKeys is not implemented");
          }
          query(e, r) {
            let n = this._all(e, r);
            if (e.prefix != null && (n = (0, cd.default)(n, (i2) => i2.key.toString().startsWith(e.prefix || ""))), Array.isArray(e.filters) && (n = e.filters.reduce((i2, o) => (0, cd.default)(i2, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i2, o) => Uee(i2, o), n)), e.offset != null) {
              let i2 = 0;
              n = (0, cd.default)(n, () => i2++ >= (e.offset || 0));
            }
            return e.limit != null && (n = (0, mC.default)(n, e.limit)), n;
          }
          queryKeys(e, r) {
            let n = this._allKeys(e, r);
            if (e.prefix != null && (n = (0, cd.default)(n, (i2) => i2.toString().startsWith(e.prefix || ""))), Array.isArray(e.filters) && (n = e.filters.reduce((i2, o) => (0, cd.default)(i2, o), n)), Array.isArray(e.orders) && (n = e.orders.reduce((i2, o) => Uee(i2, o), n)), e.offset != null) {
              let i2 = 0;
              n = (0, cd.default)(n, () => i2++ >= e.offset);
            }
            return e.limit != null && (n = (0, mC.default)(n, e.limit)), n;
          }
        };
        function y1(t) {
          let e = I.asCID(t);
          if (!e)
            throw (0, Kee.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
          return new ae("/" + xt.encode(e.multihash.bytes).slice(1).toUpperCase(), false);
        }
        function Xl(t) {
          return I.createV1(Un, _r(xt.decode("b" + t.toString().slice(1).toLowerCase())));
        }
        function wC(t) {
          let e = t.substring(0, 1);
          if (e === "/")
            return wC(t.substring(1));
          let r;
          e.toLowerCase() === "b" ? r = (o) => xt.decode(o.toLowerCase()).subarray(2) : e.toLowerCase() === "c" ? r = (o) => t9.decode(o.toLowerCase()).subarray(2) : e === "z" ? r = (o) => Ne.decode(o).subarray(2) : e === "Q" ? r = (o) => Ne.decode("z" + o) : r = (o) => xt.decode("b" + o.toLowerCase()).subarray(2);
          let n;
          for (let o = 1; o < t.length; o++)
            try {
              n = r(t.substring(0, o));
            } catch (s) {
              if (s.message !== "Unexpected end of data")
                throw s;
            }
          let i2 = "/C";
          return n && (i2 = `/${xt.encode(n).slice(1, -1).toUpperCase() || "C"}`), i2;
        }
        function OAe(t) {
          return { ...t, prefix: t.prefix ? wC(t.prefix) : void 0, filters: t.filters ? t.filters.map((e) => (r) => e({ key: Xl(r.key), value: r.value })) : void 0, orders: t.orders ? t.orders.map((e) => (r, n) => e({ key: Xl(r.key), value: r.value }, { key: Xl(n.key), value: n.value })) : void 0 };
        }
        function LAe(t) {
          return { ...t, prefix: t.prefix ? wC(t.prefix) : void 0, filters: t.filters ? t.filters.map((e) => (r) => e(Xl(r))) : void 0, orders: t.orders ? t.orders.map((e) => (r, n) => e(Xl(r), Xl(n))) : void 0 };
        }
        var RE = class extends ja {
          constructor(e) {
            super(), this.child = e;
          }
          open() {
            return this.child.open();
          }
          close() {
            return this.child.close();
          }
          async *query(e, r) {
            for await (let { key: n, value: i2 } of this.child.query(OAe(e), r))
              yield { key: Xl(n), value: i2 };
          }
          async *queryKeys(e, r) {
            for await (let n of this.child.queryKeys(LAe(e), r))
              yield Xl(n);
          }
          async get(e, r) {
            return this.child.get(y1(e), r);
          }
          async *getMany(e, r) {
            for await (let n of e)
              yield this.get(n, r);
          }
          async put(e, r, n) {
            await this.child.put(y1(e), r, n);
          }
          async *putMany(e, r) {
            let n = (0, gC.default)();
            (globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout)(async () => {
              try {
                let o = this.child;
                await (0, yC.default)(this.child.putMany(async function* () {
                  for await (let s of e) {
                    let a = y1(s.key);
                    await o.has(a, r) || (yield { key: a, value: s.value }), n.push(s);
                  }
                }())), n.end();
              } catch (o) {
                n.end(o);
              }
            }), yield* n;
          }
          has(e, r) {
            return this.child.has(y1(e), r);
          }
          delete(e, r) {
            return this.child.delete(y1(e), r);
          }
          deleteMany(e, r) {
            let n = (0, gC.default)();
            return (0, yC.default)(this.child.deleteMany(async function* () {
              for await (let i2 of e)
                yield y1(i2), n.push(i2);
              n.end();
            }(), r)).catch((i2) => {
              n.end(i2);
            }), n;
          }
        };
        function Vee(t, e, r) {
          let n = r.path || "ipfs";
          return nZ(n, (i2) => e.getCodec(i2), { root: new Ql(n, { prefix: "", version: 2 }), blocks: new RE(new Ql(`${n}/blocks`, { prefix: "", version: 2 })), datastore: new Ql(`${n}/datastore`, { prefix: "", version: 2 }), keys: new Ql(`${n}/keys`, { prefix: "", version: 2 }), pins: new Ql(`${n}/pins`, { prefix: "", version: 2 }) }, { autoMigrate: r.autoMigrate, onMigrationProgress: r.onMigrationProgress || t, repoLock: U8 });
        }
        Re();
        me();
        c();
        var Qt = w(D6(), 1);
        var Jhe = w(K(), 1);
        c();
        c();
        c();
        c();
        var zee = w(K(), 1);
        ur();
        Re();
        var AE = w(ai(), 1);
        yr();
        c();
        var qee = { ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID" };
        c();
        var Ig;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "publicKey", codec: ye }, 2: { name: "payloadType", codec: ye }, 3: { name: "payload", codec: ye }, 5: { name: "signature", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(Ig || (Ig = {}));
        var BAe, ln = class {
          constructor(e) {
            let { peerId: r, payloadType: n, payload: i2, signature: o } = e;
            this.peerId = r, this.payloadType = n, this.payload = i2, this.signature = o;
          }
          marshal() {
            if (this.peerId.publicKey == null)
              throw new Error("Missing public key");
            return this.marshaled == null && (this.marshaled = Ig.encode({ publicKey: this.peerId.publicKey, payloadType: this.payloadType, payload: this.payload, signature: this.signature })), this.marshaled;
          }
          equals(e) {
            return Ce(this.marshal(), e.marshal());
          }
          async validate(e) {
            let r = Hee(e, this.payloadType, this.payload);
            if (this.peerId.publicKey == null)
              throw new Error("Missing public key");
            return await ho(this.peerId.publicKey).verify(r, this.signature);
          }
        };
        BAe = ln;
        ln.createFromProtobuf = async (t) => {
          let e = Ig.decode(t), r = await sn(e.publicKey);
          return new ln({ peerId: r, payloadType: e.payloadType, payload: e.payload, signature: e.signature });
        };
        ln.seal = async (t, e) => {
          let r = t.domain, n = t.codec, i2 = t.marshal(), o = Hee(r, n, i2);
          if (e.privateKey == null)
            throw new Error("Missing private key");
          let a = await (await Jn(e.privateKey)).sign(o);
          return new ln({ peerId: e, payloadType: n, payload: i2, signature: a });
        };
        ln.openAndCertify = async (t, e) => {
          let r = await ln.createFromProtobuf(t);
          if (!await r.validate(e))
            throw (0, zee.default)(new Error("envelope signature is not valid for the given domain"), qee.ERR_SIGNATURE_NOT_VALID);
          return r;
        };
        var Hee = (t, e, r) => {
          let n = U(t), i2 = AE.default.encode(n.byteLength), o = AE.default.encode(e.length), s = AE.default.encode(r.length);
          return Ae([new Uint8Array(i2), n, new Uint8Array(o), e, new Uint8Array(s), r]);
        };
        c();
        c();
        function $ee(t, e) {
          let r = (n, i2) => n.toString().localeCompare(i2.toString());
          return t.length === e.length && e.sort(r) && t.sort(r).every((n, i2) => e[i2].equals(n));
        }
        c();
        var Cg;
        (function(t) {
          let e;
          (function(r) {
            r.codec = () => Xe({ 1: { name: "multiaddr", codec: ye } }), r.encode = (n) => Qe(n, r.codec()), r.decode = (n) => Ye(n, r.codec());
          })(e = t.AddressInfo || (t.AddressInfo = {})), t.codec = () => Xe({ 1: { name: "peerId", codec: ye }, 2: { name: "seq", codec: nl }, 3: { name: "addresses", codec: t.AddressInfo.codec(), repeats: true } }), t.encode = (r) => Qe(r, t.codec()), t.decode = (r) => Ye(r, t.codec());
        })(Cg || (Cg = {}));
        c();
        var Gee = "libp2p-peer-record", Wee = Uint8Array.from([3, 1]);
        var wn = class {
          constructor(e) {
            this.domain = wn.DOMAIN, this.codec = wn.CODEC;
            let { peerId: r, multiaddrs: n, seqNumber: i2 } = e;
            this.peerId = r, this.multiaddrs = n ?? [], this.seqNumber = i2 ?? BigInt(Date.now());
          }
          marshal() {
            return this.marshaled == null && (this.marshaled = Cg.encode({ peerId: this.peerId.toBytes(), seq: BigInt(this.seqNumber), addresses: this.multiaddrs.map((e) => ({ multiaddr: e.bytes })) })), this.marshaled;
          }
          equals(e) {
            return !(!(e instanceof wn) || !this.peerId.equals(e.peerId) || this.seqNumber !== e.seqNumber || !$ee(this.multiaddrs, e.multiaddrs));
          }
        };
        wn.createFromProtobuf = (t) => {
          let e = Cg.decode(t), r = Ir(e.peerId), n = (e.addresses ?? []).map((o) => new j(o.multiaddr)), i2 = e.seq;
          return new wn({ peerId: r, multiaddrs: n, seqNumber: i2 });
        };
        wn.DOMAIN = Gee;
        wn.CODEC = Wee;
        c();
        c();
        var TE = Symbol.for("@libp2p/topology");
        function jee(t) {
          return t != null && Boolean(t[TE]);
        }
        var Yee = () => {
        }, EC = class {
          constructor(e) {
            this.min = e.min ?? 0, this.max = e.max ?? 1 / 0, this.peers = /* @__PURE__ */ new Set(), this.onConnect = e.onConnect ?? Yee, this.onDisconnect = e.onDisconnect ?? Yee;
          }
          get [Symbol.toStringTag]() {
            return TE.toString();
          }
          get [TE]() {
            return true;
          }
          async setRegistrar(e) {
            this.registrar = e;
          }
          disconnect(e) {
            this.onDisconnect(e);
          }
        };
        function g1(t) {
          return new EC(t);
        }
        c();
        c();
        var ud = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, ru, Ue = class extends EventTarget {
          constructor() {
            super(...arguments), ru.set(this, /* @__PURE__ */ new Map());
          }
          listenerCount(e) {
            let r = ud(this, ru, "f").get(e);
            return r == null ? 0 : r.length;
          }
          addEventListener(e, r, n) {
            super.addEventListener(e, r, n);
            let i2 = ud(this, ru, "f").get(e);
            i2 == null && (i2 = [], ud(this, ru, "f").set(e, i2)), i2.push({ callback: r, once: (n !== true && n !== false && n?.once) ?? false });
          }
          removeEventListener(e, r, n) {
            super.removeEventListener(e.toString(), r ?? null, n);
            let i2 = ud(this, ru, "f").get(e);
            i2 != null && (i2 = i2.filter(({ callback: o }) => o !== r), ud(this, ru, "f").set(e, i2));
          }
          dispatchEvent(e) {
            let r = super.dispatchEvent(e), n = ud(this, ru, "f").get(e.type);
            return n == null || (n = n.filter(({ once: i2 }) => !i2), ud(this, ru, "f").set(e.type, n)), r;
          }
        };
        ru = /* @__PURE__ */ new WeakMap();
        var bC = class extends Event {
          constructor(e, r) {
            super(e, r), this.detail = r?.detail;
          }
        }, ee = globalThis.CustomEvent ?? bC;
        c();
        c();
        c();
        var _C = w(ai(), 1), w1 = (t, e, r) => {
          let n = _C.default.encode(t, e, r);
          return w1.bytes = _C.default.encode.bytes, e ?? Uint8Array.from(n);
        };
        w1.bytes = 0;
        var Qee = 8, MAe = 10 * 1024;
        function kr(t) {
          t = t ?? {};
          let e = Math.max(t.poolSize ?? MAe, t.minPoolSize ?? Qee), r = t.lengthEncoder ?? w1;
          return async function* (i2) {
            let o = new Uint8Array(e), s = 0;
            for await (let a of i2) {
              r(a.length, o, s);
              let u = o.slice(s, s + r.bytes);
              s += r.bytes, o.length - s < Qee && (o = new Uint8Array(e), s = 0), yield Ae([u, a.slice()], u.length + a.length);
            }
          };
        }
        kr.single = (t, e) => {
          e = e ?? {};
          let r = e.lengthEncoder ?? w1;
          return new qe(r(t.length), t.slice());
        };
        c();
        c();
        var vC = w(ai(), 1), Pg = (t) => {
          let e = vC.default.decode(t);
          return Pg.bytes = vC.default.decode.bytes, e;
        };
        Pg.bytes = 0;
        var IE = w(K(), 1), UAe = 8, FAe = 1024 * 1024 * 4, KAe = new qe(), Zl = { LENGTH: "readLength", DATA: "readData" }, VAe = { [Zl.LENGTH]: (t, e, r, n) => {
          let i2 = n?.lengthDecoder ?? Pg, o = n?.maxLengthLength ?? UAe, s = n?.maxDataLength ?? FAe;
          e.append(t);
          let a;
          try {
            a = i2(e.slice());
          } catch (u) {
            if (e.length > o)
              throw (0, IE.default)(new Error("message length too long"), "ERR_MSG_LENGTH_TOO_LONG");
            if (u instanceof RangeError)
              return { mode: Zl.LENGTH, buffer: e, chunk: void 0, state: void 0, data: void 0 };
            throw u;
          }
          if (a > s)
            throw (0, IE.default)(new Error("message data too long"), "ERR_MSG_DATA_TOO_LONG");
          return t = e.subarray(i2.bytes), e = new qe(), n?.onLength != null && n.onLength(a), a <= 0 ? { mode: Zl.LENGTH, chunk: t, buffer: e, data: KAe } : { mode: Zl.DATA, chunk: t, buffer: e, state: { dataLength: a }, data: void 0 };
        }, [Zl.DATA]: (t, e, r, n) => {
          if (e.append(t), r == null)
            throw new Error("state is required");
          if (e.length < r.dataLength)
            return { mode: Zl.DATA, buffer: e, state: r, chunk: void 0, data: void 0 };
          let { dataLength: i2 } = r, o = e.subarray(0, i2), s = e.length > i2 ? e.subarray(i2) : void 0;
          return e = new qe(), { mode: Zl.LENGTH, chunk: s, buffer: e, state: void 0, data: o };
        } };
        function Er(t) {
          return async function* (r) {
            let n = new qe(), i2 = Zl.LENGTH, o;
            for await (let s of r) {
              let a = new qe(s);
              for (; a != null; ) {
                let u = VAe[i2](a, n, o, t);
                if (i2 = u.mode, a = u.chunk, n = u.buffer, o = u.state, u.data != null) {
                  let l = u.data.slice();
                  t?.onData != null && t.onData(l), yield l;
                }
              }
            }
            if (n.length > 0)
              throw (0, IE.default)(new Error("unexpected end of input"), "ERR_UNEXPECTED_EOF");
          };
        }
        Er.fromReader = (t, e) => {
          let r = 1, n = async function* () {
            for (; ; )
              try {
                let { done: o, value: s } = await t.next(r);
                if (o === true)
                  return;
                s != null && (yield s);
              } catch (o) {
                if (o.code === "ERR_UNDER_READ")
                  return { done: true, value: null };
                throw o;
              } finally {
                r = 1;
              }
          }();
          return Er({ ...e ?? {}, onLength: (o) => {
            r = o;
          } })(n);
        };
        c();
        c();
        function Xee(t) {
          return globalThis?.Buffer?.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
        }
        var Zee = (t, e, r) => (e = e ?? Xee(4), new DataView(e.buffer, e.byteOffset, e.byteLength).setInt32(r ?? 0, t, false), e);
        Zee.bytes = 4;
        c();
        var Jee = (t) => {
          if (t.length < 4)
            throw RangeError("Could not decode int32BE");
          return new DataView(t.buffer, t.byteOffset, t.byteLength).getInt32(0, false);
        };
        Jee.bytes = 4;
        c();
        c();
        var Jl = class extends Error {
          constructor(e, r) {
            super(e ?? "The operation was aborted"), this.type = "aborted", this.code = r ?? "ABORT_ERR";
          }
        };
        c();
        function ete(t) {
          if (t != null) {
            if (typeof t[Symbol.iterator] == "function")
              return t[Symbol.iterator]();
            if (typeof t[Symbol.asyncIterator] == "function")
              return t[Symbol.asyncIterator]();
            if (typeof t.next == "function")
              return t;
          }
          throw new Error("argument is not an iterator or iterable");
        }
        function Pn(t, e, r) {
          let n = r ?? {}, i2 = ete(t);
          async function* o() {
            let s, a = () => {
              s?.();
            };
            for (e.addEventListener("abort", a); ; ) {
              let u;
              try {
                if (e.aborted) {
                  let { abortMessage: f, abortCode: h } = n;
                  throw new Jl(f, h);
                }
                let l = new Promise((f, h) => {
                  s = () => {
                    let { abortMessage: p, abortCode: d } = n;
                    h(new Jl(p, d));
                  };
                });
                u = await Promise.race([l, i2.next()]), s = null;
              } catch (l) {
                e.removeEventListener("abort", a);
                let f = l.type === "aborted" && e.aborted;
                if (f && n.onAbort != null && await n.onAbort(t), typeof i2.return == "function")
                  try {
                    let h = i2.return();
                    h instanceof Promise && h.catch((p) => {
                      n.onReturnError != null && n.onReturnError(p);
                    });
                  } catch (h) {
                    n.onReturnError != null && n.onReturnError(h);
                  }
                if (f && n.returnOnAbort === true)
                  return;
                throw l;
              }
              if (u.done === true)
                break;
              yield u.value;
            }
            e.removeEventListener("abort", a);
          }
          return o();
        }
        function qAe(t, e, r) {
          return (n) => t(Pn(n, e, r));
        }
        function as(t, e, r) {
          return { sink: qAe(t.sink, e, { ...r, onAbort: void 0 }), source: Pn(t.source, e, r) };
        }
        var zAe = C("libp2p-pubsub:peer-streams"), CE = class extends Ue {
          constructor(e) {
            super(), this.id = e.id, this.protocol = e.protocol, this._inboundAbortController = new AbortController(), this.closed = false;
          }
          get isReadable() {
            return Boolean(this.inboundStream);
          }
          get isWritable() {
            return Boolean(this.outboundStream);
          }
          write(e) {
            if (this.outboundStream == null) {
              let r = this.id.toString();
              throw new Error("No writable connection to " + r);
            }
            this.outboundStream.push(e);
          }
          attachInboundStream(e) {
            return this._rawInboundStream = e, this.inboundStream = Pn(Te(this._rawInboundStream, Er()), this._inboundAbortController.signal, { returnOnAbort: true }), this.dispatchEvent(new ee("stream:inbound")), this.inboundStream;
          }
          async attachOutboundStream(e) {
            let r = this.outboundStream;
            return this.outboundStream != null && await this.outboundStream.end(), this._rawOutboundStream = e, this.outboundStream = zs({ onEnd: (n) => {
              this._rawOutboundStream != null && this._rawOutboundStream.reset != null && this._rawOutboundStream.reset(), this._rawOutboundStream = void 0, this.outboundStream = void 0, n != null && this.dispatchEvent(new ee("close"));
            } }), Te(this.outboundStream, kr(), this._rawOutboundStream).catch((n) => {
              zAe.error(n);
            }), r == null && this.dispatchEvent(new ee("stream:outbound")), this.outboundStream;
          }
          close() {
            this.closed || (this.closed = true, this.outboundStream != null && this.outboundStream.end(), this.inboundStream != null && this._inboundAbortController.abort(), this._rawOutboundStream = void 0, this.outboundStream = void 0, this._rawInboundStream = void 0, this.inboundStream = void 0, this.dispatchEvent(new ee("close")));
          }
        };
        me();
        c();
        var PE = class {
          constructor(e, r, n) {
            this.gossip = e, this.msgs = /* @__PURE__ */ new Map(), this.history = [], this.msgIdToStrFn = n;
            for (let i2 = 0; i2 < r; i2++)
              this.history[i2] = [];
          }
          get size() {
            return this.msgs.size;
          }
          put(e, r, n = false) {
            let { msgIdStr: i2 } = e;
            return this.msgs.has(i2) ? false : (this.msgs.set(i2, { message: r, validated: n, originatingPeers: /* @__PURE__ */ new Set(), iwantCounts: /* @__PURE__ */ new Map() }), this.history[0].push({ ...e, topic: r.topic }), true);
          }
          observeDuplicate(e, r) {
            let n = this.msgs.get(e);
            n && !n.validated && n.originatingPeers.add(r);
          }
          get(e) {
            return this.msgs.get(this.msgIdToStrFn(e))?.message;
          }
          getWithIWantCount(e, r) {
            let n = this.msgs.get(e);
            if (!n)
              return null;
            let i2 = (n.iwantCounts.get(r) ?? 0) + 1;
            return n.iwantCounts.set(r, i2), { msg: n.message, count: i2 };
          }
          getGossipIDs(e) {
            let r = /* @__PURE__ */ new Map();
            for (let n = 0; n < this.gossip; n++)
              this.history[n].forEach((i2) => {
                let o = this.msgs.get(i2.msgIdStr);
                if (o && o.validated && e.has(i2.topic)) {
                  let s = r.get(i2.topic);
                  s || (s = [], r.set(i2.topic, s)), s.push(i2.msgId);
                }
              });
            return r;
          }
          validate(e) {
            let r = this.msgs.get(e);
            if (!r)
              return null;
            let { message: n, originatingPeers: i2 } = r;
            return r.validated = true, r.originatingPeers = /* @__PURE__ */ new Set(), { message: n, originatingPeers: i2 };
          }
          shift() {
            this.history[this.history.length - 1].forEach((r) => {
              this.msgs.delete(r.msgIdStr);
            }), this.history.pop(), this.history.unshift([]);
          }
          remove(e) {
            let r = this.msgs.get(e);
            return r ? (this.msgs.delete(e), r) : null;
          }
        };
        c();
        var ef;
        (function(t) {
          let e;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "subscribe", codec: P2, optional: true }, 2: { name: "topic", codec: pn, optional: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(e = t.SubOpts || (t.SubOpts = {}));
          let r;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "from", codec: ye, optional: true }, 2: { name: "data", codec: ye, optional: true }, 3: { name: "seqno", codec: ye, optional: true }, 4: { name: "topic", codec: pn }, 5: { name: "signature", codec: ye, optional: true }, 6: { name: "key", codec: ye, optional: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(r = t.Message || (t.Message = {}));
          let n;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "ihave", codec: t.ControlIHave.codec(), repeats: true }, 2: { name: "iwant", codec: t.ControlIWant.codec(), repeats: true }, 3: { name: "graft", codec: t.ControlGraft.codec(), repeats: true }, 4: { name: "prune", codec: t.ControlPrune.codec(), repeats: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(n = t.ControlMessage || (t.ControlMessage = {}));
          let i2;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "topicID", codec: pn, optional: true }, 2: { name: "messageIDs", codec: ye, repeats: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(i2 = t.ControlIHave || (t.ControlIHave = {}));
          let o;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "messageIDs", codec: ye, repeats: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(o = t.ControlIWant || (t.ControlIWant = {}));
          let s;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "topicID", codec: pn, optional: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(s = t.ControlGraft || (t.ControlGraft = {}));
          let a;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "topicID", codec: pn, optional: true }, 2: { name: "peers", codec: t.PeerInfo.codec(), repeats: true }, 3: { name: "backoff", codec: nl, optional: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(a = t.ControlPrune || (t.ControlPrune = {}));
          let u;
          (function(l) {
            l.codec = () => Xe({ 1: { name: "peerID", codec: ye, optional: true }, 2: { name: "signedPeerRecord", codec: ye, optional: true } }), l.encode = (f) => Qe(f, l.codec()), l.decode = (f) => Ye(f, l.codec());
          })(u = t.PeerInfo || (t.PeerInfo = {})), t.codec = () => Xe({ 1: { name: "subscriptions", codec: t.SubOpts.codec(), repeats: true }, 2: { name: "messages", codec: t.Message.codec(), repeats: true }, 3: { name: "control", codec: t.ControlMessage.codec(), optional: true } }), t.encode = (l) => Qe(l, t.codec()), t.decode = (l) => Ye(l, t.codec());
        })(ef || (ef = {}));
        c();
        var SC = "/floodsub/1.0.0", Dg = "/meshsub/1.0.0", kg = "/meshsub/1.1.0";
        var tte = "ERR_TOPIC_VALIDATOR_REJECT", rte = "ERR_TOPIC_VALIDATOR_IGNORE";
        c();
        c();
        function Qa(t = [], e) {
          return { subscriptions: [], messages: t, control: e ? { graft: e.graft || [], prune: e.prune || [], ihave: e.ihave || [], iwant: e.iwant || [] } : void 0 };
        }
        c();
        function Xa(t) {
          if (t.length <= 1)
            return t;
          let e = () => Math.floor(Math.random() * Math.floor(t.length));
          for (let r = 0; r < t.length; r++) {
            let n = e(), i2 = t[r];
            t[r] = t[n], t[n] = i2;
          }
          return t;
        }
        c();
        function DE(t) {
          return t === Dg || t === kg;
        }
        c();
        me();
        function nte(t) {
          return M(t, "base64");
        }
        c();
        c();
        var ld = "StrictSign", E1 = "StrictNoSign";
        c();
        var ite;
        (function(t) {
          t.StrictSign = "StrictSign", t.StrictNoSign = "StrictNoSign";
        })(ite || (ite = {}));
        var nu;
        (function(t) {
          t[t.Signing = 0] = "Signing", t[t.Author = 1] = "Author", t[t.Anonymous = 2] = "Anonymous";
        })(nu || (nu = {}));
        var Za;
        (function(t) {
          t.Accept = "accept", t.Ignore = "ignore", t.Reject = "reject";
        })(Za || (Za = {}));
        var yi;
        (function(t) {
          t.Error = "error", t.Ignore = "ignore", t.Reject = "reject", t.Blacklisted = "blacklisted";
        })(yi || (yi = {}));
        var oi;
        (function(t) {
          t.InvalidSignature = "invalid_signature", t.InvalidSeqno = "invalid_seqno", t.InvalidPeerId = "invalid_peerid", t.SignaturePresent = "signature_present", t.SeqnoPresent = "seqno_present", t.FromPresent = "from_present", t.TransformFailed = "transform_failed";
        })(oi || (oi = {}));
        var bo;
        (function(t) {
          t.duplicate = "duplicate", t.invalid = "invalid", t.valid = "valid";
        })(bo || (bo = {}));
        function xC(t) {
          switch (t) {
            case Za.Ignore:
              return yi.Ignore;
            case Za.Reject:
              return yi.Reject;
          }
        }
        async function RC(t, e) {
          switch (t) {
            case ld: {
              if (!e)
                throw Error("Must provide PeerId");
              if (e.privateKey == null)
                throw Error("Cannot sign message, no private key present");
              if (e.publicKey == null)
                throw Error("Cannot sign message, no public key present");
              let r = await Jn(e.privateKey);
              return { type: nu.Signing, author: e, key: e.publicKey, privateKey: r };
            }
            case E1:
              return { type: nu.Anonymous };
            default:
              throw new Error(`Unknown signature policy "${t}"`);
          }
        }
        c();
        c();
        c();
        var hr = "ERR_INVALID_PEER_SCORE_PARAMS";
        var dr = w(K(), 1), $Ae = { topics: {}, topicScoreCap: 10, appSpecificScore: () => 0, appSpecificWeight: 10, IPColocationFactorWeight: -5, IPColocationFactorThreshold: 10, IPColocationFactorWhitelist: /* @__PURE__ */ new Set(), behaviourPenaltyWeight: -10, behaviourPenaltyThreshold: 0, behaviourPenaltyDecay: 0.2, decayInterval: 1e3, decayToZero: 0.1, retainScore: 3600 * 1e3 }, GAe = { topicWeight: 0.5, timeInMeshWeight: 1, timeInMeshQuantum: 1, timeInMeshCap: 3600, firstMessageDeliveriesWeight: 1, firstMessageDeliveriesDecay: 0.5, firstMessageDeliveriesCap: 2e3, meshMessageDeliveriesWeight: -1, meshMessageDeliveriesDecay: 0.5, meshMessageDeliveriesCap: 100, meshMessageDeliveriesThreshold: 20, meshMessageDeliveriesWindow: 10, meshMessageDeliveriesActivation: 5e3, meshFailurePenaltyWeight: -1, meshFailurePenaltyDecay: 0.5, invalidMessageDeliveriesWeight: -1, invalidMessageDeliveriesDecay: 0.3 };
        function ote(t = {}) {
          return { ...$Ae, ...t, topics: t.topics ? Object.entries(t.topics).reduce((e, [r, n]) => (e[r] = WAe(n), e), {}) : {} };
        }
        function WAe(t = {}) {
          return { ...GAe, ...t };
        }
        function ste(t) {
          for (let [e, r] of Object.entries(t.topics))
            try {
              jAe(r);
            } catch (n) {
              throw (0, dr.default)(new Error(`invalid score parameters for topic ${e}: ${n.message}`), hr);
            }
          if (t.topicScoreCap < 0)
            throw (0, dr.default)(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), hr);
          if (t.appSpecificScore === null || t.appSpecificScore === void 0)
            throw (0, dr.default)(new Error("missing application specific score function"), hr);
          if (t.IPColocationFactorWeight > 0)
            throw (0, dr.default)(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), hr);
          if (t.IPColocationFactorWeight !== 0 && t.IPColocationFactorThreshold < 1)
            throw (0, dr.default)(new Error("invalid IPColocationFactorThreshold; must be at least 1"), hr);
          if (t.behaviourPenaltyWeight > 0)
            throw (0, dr.default)(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), hr);
          if (t.behaviourPenaltyWeight !== 0 && (t.behaviourPenaltyDecay <= 0 || t.behaviourPenaltyDecay >= 1))
            throw (0, dr.default)(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), hr);
          if (t.decayInterval < 1e3)
            throw (0, dr.default)(new Error("invalid DecayInterval; must be at least 1s"), hr);
          if (t.decayToZero <= 0 || t.decayToZero >= 1)
            throw (0, dr.default)(new Error("invalid DecayToZero; must be between 0 and 1"), hr);
        }
        function jAe(t) {
          if (t.topicWeight < 0)
            throw (0, dr.default)(new Error("invalid topic weight; must be >= 0"), hr);
          if (t.timeInMeshQuantum === 0)
            throw (0, dr.default)(new Error("invalid TimeInMeshQuantum; must be non zero"), hr);
          if (t.timeInMeshWeight < 0)
            throw (0, dr.default)(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), hr);
          if (t.timeInMeshWeight !== 0 && t.timeInMeshQuantum <= 0)
            throw (0, dr.default)(new Error("invalid TimeInMeshQuantum; must be positive"), hr);
          if (t.timeInMeshWeight !== 0 && t.timeInMeshCap <= 0)
            throw (0, dr.default)(new Error("invalid TimeInMeshCap; must be positive"), hr);
          if (t.firstMessageDeliveriesWeight < 0)
            throw (0, dr.default)(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), hr);
          if (t.firstMessageDeliveriesWeight !== 0 && (t.firstMessageDeliveriesDecay <= 0 || t.firstMessageDeliveriesDecay >= 1))
            throw (0, dr.default)(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), hr);
          if (t.firstMessageDeliveriesWeight !== 0 && t.firstMessageDeliveriesCap <= 0)
            throw (0, dr.default)(new Error("invalid FirstMessageDeliveriesCap; must be positive"), hr);
          if (t.meshMessageDeliveriesWeight > 0)
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), hr);
          if (t.meshMessageDeliveriesWeight !== 0 && (t.meshMessageDeliveriesDecay <= 0 || t.meshMessageDeliveriesDecay >= 1))
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), hr);
          if (t.meshMessageDeliveriesWeight !== 0 && t.meshMessageDeliveriesCap <= 0)
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesCap; must be positive"), hr);
          if (t.meshMessageDeliveriesWeight !== 0 && t.meshMessageDeliveriesThreshold <= 0)
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), hr);
          if (t.meshMessageDeliveriesWindow < 0)
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), hr);
          if (t.meshMessageDeliveriesWeight !== 0 && t.meshMessageDeliveriesActivation < 1e3)
            throw (0, dr.default)(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), hr);
          if (t.meshFailurePenaltyWeight > 0)
            throw (0, dr.default)(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), hr);
          if (t.meshFailurePenaltyWeight !== 0 && (t.meshFailurePenaltyDecay <= 0 || t.meshFailurePenaltyDecay >= 1))
            throw (0, dr.default)(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), hr);
          if (t.invalidMessageDeliveriesWeight > 0)
            throw (0, dr.default)(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), hr);
          if (t.invalidMessageDeliveriesDecay <= 0 || t.invalidMessageDeliveriesDecay >= 1)
            throw (0, dr.default)(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), hr);
        }
        c();
        var YAe = w(K(), 1), QAe = { gossipThreshold: -10, publishThreshold: -50, graylistThreshold: -80, acceptPXThreshold: 10, opportunisticGraftThreshold: 20 };
        function ate(t = {}) {
          return { ...QAe, ...t };
        }
        c();
        c();
        function cte(t, e, r, n) {
          let i2 = 0;
          if (Object.entries(e.topics).forEach(([s, a]) => {
            let u = r.topics[s];
            if (u === void 0)
              return;
            let l = 0;
            if (a.inMesh) {
              let d = a.meshTime / u.timeInMeshQuantum;
              d > u.timeInMeshCap && (d = u.timeInMeshCap), l += d * u.timeInMeshWeight;
            }
            let f = a.firstMessageDeliveries;
            if (f > u.firstMessageDeliveriesCap && (f = u.firstMessageDeliveriesCap), l += f * u.firstMessageDeliveriesWeight, a.meshMessageDeliveriesActive && a.meshMessageDeliveries < u.meshMessageDeliveriesThreshold) {
              let d = u.meshMessageDeliveriesThreshold - a.meshMessageDeliveries;
              l += d * d * u.meshMessageDeliveriesWeight;
            }
            l += a.meshFailurePenalty * u.meshFailurePenaltyWeight, l += a.invalidMessageDeliveries * a.invalidMessageDeliveries * u.invalidMessageDeliveriesWeight, i2 += l * u.topicWeight;
          }), r.topicScoreCap > 0 && i2 > r.topicScoreCap && (i2 = r.topicScoreCap), i2 += r.appSpecificScore(t) * r.appSpecificWeight, e.ips.forEach((s) => {
            if (r.IPColocationFactorWhitelist.has(s))
              return;
            let a = n.get(s), u = a ? a.size : 0;
            if (u > r.IPColocationFactorThreshold) {
              let l = u - r.IPColocationFactorThreshold;
              i2 += l * l * r.IPColocationFactorWeight;
            }
          }), e.behaviourPenalty > r.behaviourPenaltyThreshold) {
            let s = e.behaviourPenalty - r.behaviourPenaltyThreshold;
            i2 += s * s * r.behaviourPenaltyWeight;
          }
          return i2;
        }
        c();
        var fte = w(lte(), 1), Di;
        (function(t) {
          t[t.unknown = 0] = "unknown", t[t.valid = 1] = "valid", t[t.invalid = 2] = "invalid", t[t.ignored = 3] = "ignored";
        })(Di || (Di = {}));
        var kE = class {
          constructor() {
            this.records = /* @__PURE__ */ new Map(), this.queue = new fte.default();
          }
          ensureRecord(e) {
            let r = this.records.get(e);
            if (r)
              return r;
            r = { status: Di.unknown, firstSeen: Date.now(), validated: 0, peers: /* @__PURE__ */ new Set() }, this.records.set(e, r);
            let n = { msgId: e, expire: Date.now() + 12e4 };
            return this.queue.push(n), r;
          }
          gc() {
            let e = Date.now(), r = this.queue.peekFront();
            for (; r && r.expire < e; )
              this.records.delete(r.msgId), this.queue.shift(), r = this.queue.peekFront();
          }
          clear() {
            this.records.clear(), this.queue.clear();
          }
        };
        c();
        var Xi = w(K(), 1);
        c();
        function iu(t) {
          return t != null && typeof t.start == "function" && typeof t.stop == "function";
        }
        function gi(t) {
          return t != null && typeof t.init == "function";
        }
        var He = class {
          constructor(e = {}) {
            this.started = false, e.peerId != null && this.setPeerId(e.peerId), e.addressManager != null && this.setAddressManager(e.addressManager), e.peerStore != null && this.setPeerStore(e.peerStore), e.upgrader != null && this.setUpgrader(e.upgrader), e.metrics != null && this.setMetrics(e.metrics), e.registrar != null && this.setRegistrar(e.registrar), e.connectionManager != null && this.setConnectionManager(e.connectionManager), e.transportManager != null && this.setTransportManager(e.transportManager), e.connectionGater != null && this.setConnectionGater(e.connectionGater), e.contentRouting != null && this.setContentRouting(e.contentRouting), e.peerRouting != null && this.setPeerRouting(e.peerRouting), e.datastore != null && this.setDatastore(e.datastore), e.connectionProtector != null && this.setConnectionProtector(e.connectionProtector), e.dht != null && this.setDHT(e.dht), e.pubsub != null && this.setPubSub(e.pubsub);
          }
          isStarted() {
            return this.started;
          }
          async beforeStart() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              e.beforeStart != null && await e.beforeStart();
            }));
          }
          async start() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              await e.start();
            })), this.started = true;
          }
          async afterStart() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              e.afterStart != null && await e.afterStart();
            }));
          }
          async beforeStop() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              e.beforeStop != null && await e.beforeStop();
            }));
          }
          async stop() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              await e.stop();
            })), this.started = false;
          }
          async afterStop() {
            await Promise.all(Object.values(this).filter((e) => iu(e)).map(async (e) => {
              e.afterStop != null && await e.afterStop();
            }));
          }
          setPeerId(e) {
            return this.peerId = e, e;
          }
          getPeerId() {
            if (this.peerId == null)
              throw (0, Xi.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
            return this.peerId;
          }
          setMetrics(e) {
            return this.metrics = e, gi(e) && e.init(this), e;
          }
          getMetrics() {
            return this.metrics;
          }
          setAddressManager(e) {
            return this.addressManager = e, gi(e) && e.init(this), e;
          }
          getAddressManager() {
            if (this.addressManager == null)
              throw (0, Xi.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
            return this.addressManager;
          }
          setPeerStore(e) {
            return this.peerStore = e, gi(e) && e.init(this), e;
          }
          getPeerStore() {
            if (this.peerStore == null)
              throw (0, Xi.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
            return this.peerStore;
          }
          setUpgrader(e) {
            return this.upgrader = e, gi(e) && e.init(this), e;
          }
          getUpgrader() {
            if (this.upgrader == null)
              throw (0, Xi.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
            return this.upgrader;
          }
          setRegistrar(e) {
            return this.registrar = e, gi(e) && e.init(this), e;
          }
          getRegistrar() {
            if (this.registrar == null)
              throw (0, Xi.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
            return this.registrar;
          }
          setConnectionManager(e) {
            return this.connectionManager = e, gi(e) && e.init(this), e;
          }
          getConnectionManager() {
            if (this.connectionManager == null)
              throw (0, Xi.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
            return this.connectionManager;
          }
          setTransportManager(e) {
            return this.transportManager = e, gi(e) && e.init(this), e;
          }
          getTransportManager() {
            if (this.transportManager == null)
              throw (0, Xi.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
            return this.transportManager;
          }
          setConnectionGater(e) {
            return this.connectionGater = e, gi(e) && e.init(this), e;
          }
          getConnectionGater() {
            if (this.connectionGater == null)
              throw (0, Xi.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
            return this.connectionGater;
          }
          setContentRouting(e) {
            return this.contentRouting = e, gi(e) && e.init(this), e;
          }
          getContentRouting() {
            if (this.contentRouting == null)
              throw (0, Xi.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
            return this.contentRouting;
          }
          setPeerRouting(e) {
            return this.peerRouting = e, gi(e) && e.init(this), e;
          }
          getPeerRouting() {
            if (this.peerRouting == null)
              throw (0, Xi.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
            return this.peerRouting;
          }
          setDatastore(e) {
            return this.datastore = e, gi(e) && e.init(this), e;
          }
          getDatastore() {
            if (this.datastore == null)
              throw (0, Xi.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
            return this.datastore;
          }
          setConnectionProtector(e) {
            return this.connectionProtector = e, gi(e) && e.init(this), e;
          }
          getConnectionProtector() {
            return this.connectionProtector;
          }
          setDHT(e) {
            return this.dht = e, gi(e) && e.init(this), e;
          }
          getDHT() {
            if (this.dht == null)
              throw (0, Xi.default)(new Error("dht not set"), "ERR_SERVICE_MISSING");
            return this.dht;
          }
          setPubSub(e) {
            return this.pubsub = e, gi(e) && e.init(this), e;
          }
          getPubSub() {
            if (this.pubsub == null)
              throw (0, Xi.default)(new Error("pubsub not set"), "ERR_SERVICE_MISSING");
            return this.pubsub;
          }
        };
        var b1 = C("libp2p:gossipsub:score"), NE = class {
          constructor(e, r, n) {
            this.params = e, this.metrics = r, this.peerStats = /* @__PURE__ */ new Map(), this.peerIPs = /* @__PURE__ */ new Map(), this.scoreCache = /* @__PURE__ */ new Map(), this.deliveryRecords = new kE(), this.components = new He(), ste(e), this.scoreCacheValidityMs = n.scoreCacheValidityMs, this.computeScore = n.computeScore ?? cte;
          }
          init(e) {
            this.components = e;
          }
          get size() {
            return this.peerStats.size;
          }
          start() {
            if (this._backgroundInterval) {
              b1("Peer score already running");
              return;
            }
            this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval), b1("started");
          }
          stop() {
            if (!this._backgroundInterval) {
              b1("Peer score already stopped");
              return;
            }
            clearInterval(this._backgroundInterval), delete this._backgroundInterval, this.peerIPs.clear(), this.peerStats.clear(), this.deliveryRecords.clear(), b1("stopped");
          }
          background() {
            this.refreshScores(), this.updateIPs(), this.deliveryRecords.gc();
          }
          dumpPeerScoreStats() {
            return Object.fromEntries(Array.from(this.peerStats.entries()).map(([e, r]) => [e, r]));
          }
          refreshScores() {
            let e = Date.now(), r = this.params.decayToZero;
            this.peerStats.forEach((n, i2) => {
              if (!n.connected) {
                e > n.expire && (this.removeIPs(i2, n.ips), this.peerStats.delete(i2), this.scoreCache.delete(i2));
                return;
              }
              Object.entries(n.topics).forEach(([o, s]) => {
                let a = this.params.topics[o];
                a !== void 0 && (s.firstMessageDeliveries *= a.firstMessageDeliveriesDecay, s.firstMessageDeliveries < r && (s.firstMessageDeliveries = 0), s.meshMessageDeliveries *= a.meshMessageDeliveriesDecay, s.meshMessageDeliveries < r && (s.meshMessageDeliveries = 0), s.meshFailurePenalty *= a.meshFailurePenaltyDecay, s.meshFailurePenalty < r && (s.meshFailurePenalty = 0), s.invalidMessageDeliveries *= a.invalidMessageDeliveriesDecay, s.invalidMessageDeliveries < r && (s.invalidMessageDeliveries = 0), s.inMesh && (s.meshTime = e - s.graftTime, s.meshTime > a.meshMessageDeliveriesActivation && (s.meshMessageDeliveriesActive = true)));
              }), n.behaviourPenalty *= this.params.behaviourPenaltyDecay, n.behaviourPenalty < r && (n.behaviourPenalty = 0);
            });
          }
          score(e) {
            this.metrics?.scoreFnCalls.inc();
            let r = this.peerStats.get(e);
            if (!r)
              return 0;
            let n = Date.now(), i2 = this.scoreCache.get(e);
            if (i2 && i2.cacheUntil > n)
              return i2.score;
            this.metrics?.scoreFnRuns.inc();
            let o = this.computeScore(e, r, this.params, this.peerIPs), s = n + this.scoreCacheValidityMs;
            return i2 ? (this.metrics?.scoreCachedDelta.observe(Math.abs(o - i2.score)), i2.score = o, i2.cacheUntil = s) : this.scoreCache.set(e, { score: o, cacheUntil: s }), o;
          }
          addPenalty(e, r, n) {
            let i2 = this.peerStats.get(e);
            i2 && (i2.behaviourPenalty += r, this.metrics?.onScorePenalty(n));
          }
          addPeer(e) {
            let r = { connected: true, expire: 0, topics: {}, ips: [], behaviourPenalty: 0 };
            this.peerStats.set(e, r);
            let n = this.getIPs(e);
            this.setIPs(e, n, r.ips), r.ips = n;
          }
          removePeer(e) {
            let r = this.peerStats.get(e);
            if (!!r) {
              if (this.score(e) > 0) {
                this.removeIPs(e, r.ips), this.peerStats.delete(e);
                return;
              }
              Object.entries(r.topics).forEach(([n, i2]) => {
                i2.firstMessageDeliveries = 0;
                let o = this.params.topics[n].meshMessageDeliveriesThreshold;
                if (i2.inMesh && i2.meshMessageDeliveriesActive && i2.meshMessageDeliveries < o) {
                  let s = o - i2.meshMessageDeliveries;
                  i2.meshFailurePenalty += s * s;
                }
                i2.inMesh = false, i2.meshMessageDeliveriesActive = false;
              }), r.connected = false, r.expire = Date.now() + this.params.retainScore;
            }
          }
          graft(e, r) {
            let n = this.peerStats.get(e);
            if (n) {
              let i2 = this.getPtopicStats(n, r);
              i2 && (i2.inMesh = true, i2.graftTime = Date.now(), i2.meshTime = 0, i2.meshMessageDeliveriesActive = false);
            }
          }
          prune(e, r) {
            let n = this.peerStats.get(e);
            if (n) {
              let i2 = this.getPtopicStats(n, r);
              if (i2) {
                let o = this.params.topics[r].meshMessageDeliveriesThreshold;
                if (i2.meshMessageDeliveriesActive && i2.meshMessageDeliveries < o) {
                  let s = o - i2.meshMessageDeliveries;
                  i2.meshFailurePenalty += s * s;
                }
                i2.meshMessageDeliveriesActive = false, i2.inMesh = false;
              }
            }
          }
          validateMessage(e) {
            this.deliveryRecords.ensureRecord(e);
          }
          deliverMessage(e, r, n) {
            this.markFirstMessageDelivery(e, n);
            let i2 = this.deliveryRecords.ensureRecord(r), o = Date.now();
            if (i2.status !== Di.unknown) {
              b1("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", e, o - i2.firstSeen, Di[i2.status]);
              return;
            }
            i2.status = Di.valid, i2.validated = o, i2.peers.forEach((s) => {
              s !== e.toString() && this.markDuplicateMessageDelivery(s, n);
            });
          }
          rejectInvalidMessage(e, r) {
            this.markInvalidMessageDelivery(e, r);
          }
          rejectMessage(e, r, n, i2) {
            switch (i2) {
              case yi.Error:
                this.markInvalidMessageDelivery(e, n);
                return;
              case yi.Blacklisted:
                return;
            }
            let o = this.deliveryRecords.ensureRecord(r);
            if (o.status !== Di.unknown) {
              b1("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", e, Date.now() - o.firstSeen, Di[o.status]);
              return;
            }
            if (i2 === yi.Ignore) {
              o.status = Di.ignored, o.peers.clear();
              return;
            }
            o.status = Di.invalid, this.markInvalidMessageDelivery(e, n), o.peers.forEach((s) => {
              this.markInvalidMessageDelivery(s, n);
            }), o.peers.clear();
          }
          duplicateMessage(e, r, n) {
            let i2 = this.deliveryRecords.ensureRecord(r);
            if (!i2.peers.has(e))
              switch (i2.status) {
                case Di.unknown:
                  i2.peers.add(e);
                  break;
                case Di.valid:
                  i2.peers.add(e), this.markDuplicateMessageDelivery(e, n, i2.validated);
                  break;
                case Di.invalid:
                  this.markInvalidMessageDelivery(e, n);
                  break;
                case Di.ignored:
                  break;
              }
          }
          markInvalidMessageDelivery(e, r) {
            let n = this.peerStats.get(e);
            if (n) {
              let i2 = this.getPtopicStats(n, r);
              i2 && (i2.invalidMessageDeliveries += 1);
            }
          }
          markFirstMessageDelivery(e, r) {
            let n = this.peerStats.get(e);
            if (n) {
              let i2 = this.getPtopicStats(n, r);
              if (i2) {
                let o = this.params.topics[r].firstMessageDeliveriesCap;
                i2.firstMessageDeliveries = Math.min(o, i2.firstMessageDeliveries + 1), i2.inMesh && (o = this.params.topics[r].meshMessageDeliveriesCap, i2.meshMessageDeliveries = Math.min(o, i2.meshMessageDeliveries + 1));
              }
            }
          }
          markDuplicateMessageDelivery(e, r, n) {
            let i2 = this.peerStats.get(e);
            if (i2) {
              let o = n !== void 0 ? Date.now() : 0, s = this.getPtopicStats(i2, r);
              if (s && s.inMesh) {
                let a = this.params.topics[r];
                if (n !== void 0) {
                  let l = o - n, f = l > a.meshMessageDeliveriesWindow;
                  if (this.metrics?.onDuplicateMsgDelivery(r, l, f), f)
                    return;
                }
                let u = a.meshMessageDeliveriesCap;
                s.meshMessageDeliveries = Math.min(u, s.meshMessageDeliveries + 1);
              }
            }
          }
          getIPs(e) {
            return this.components.getConnectionManager().getConnections(ue(e)).map((r) => r.remoteAddr.toOptions().host);
          }
          setIPs(e, r, n) {
            e:
              for (let i2 of r) {
                for (let s of n)
                  if (i2 === s)
                    continue e;
                let o = this.peerIPs.get(i2);
                o || (o = /* @__PURE__ */ new Set(), this.peerIPs.set(i2, o)), o.add(e);
              }
            e:
              for (let i2 of n) {
                for (let s of r)
                  if (i2 === s)
                    continue e;
                let o = this.peerIPs.get(i2);
                !o || (o.delete(e), o.size || this.peerIPs.delete(i2));
              }
          }
          removeIPs(e, r) {
            r.forEach((n) => {
              let i2 = this.peerIPs.get(n);
              !i2 || (i2.delete(e), i2.size || this.peerIPs.delete(n));
            });
          }
          updateIPs() {
            this.peerStats.forEach((e, r) => {
              let n = this.getIPs(r);
              this.setIPs(r, n, e.ips), e.ips = n;
            });
          }
          getPtopicStats(e, r) {
            let n = e.topics[r];
            return n !== void 0 ? n : this.params.topics[r] !== void 0 ? (n = { inMesh: false, graftTime: 0, meshTime: 0, firstMessageDeliveries: 0, meshMessageDeliveries: 0, meshMessageDeliveriesActive: false, meshFailurePenalty: 0, invalidMessageDeliveries: 0 }, e.topics[r] = n, n) : null;
          }
        };
        c();
        var OE = class {
          constructor(e, r, n) {
            this.gossipsubIWantFollowupMs = e, this.msgIdToStrFn = r, this.metrics = n, this.promises = /* @__PURE__ */ new Map(), this.requestMsByMsg = /* @__PURE__ */ new Map(), this.requestMsByMsgExpire = 10 * e;
          }
          get size() {
            return this.promises.size;
          }
          get requestMsByMsgSize() {
            return this.requestMsByMsg.size;
          }
          addPromise(e, r) {
            let n = Math.floor(Math.random() * r.length), i2 = r[n], o = this.msgIdToStrFn(i2), s = this.promises.get(o);
            s || (s = /* @__PURE__ */ new Map(), this.promises.set(o, s));
            let a = Date.now();
            s.has(e) || (s.set(e, a + this.gossipsubIWantFollowupMs), this.metrics && (this.metrics.iwantPromiseStarted.inc(1), this.requestMsByMsg.has(o) || this.requestMsByMsg.set(o, a)));
          }
          getBrokenPromises() {
            let e = Date.now(), r = /* @__PURE__ */ new Map(), n = 0;
            return this.promises.forEach((i2, o) => {
              i2.forEach((s, a) => {
                s < e && (r.set(a, (r.get(a) ?? 0) + 1), i2.delete(a), n++);
              }), i2.size || this.promises.delete(o);
            }), this.metrics?.iwantPromiseBroken.inc(n), r;
          }
          deliverMessage(e) {
            this.trackMessage(e);
            let r = this.promises.get(e);
            r && (this.promises.delete(e), this.metrics && (this.metrics.iwantPromiseResolved.inc(1), this.metrics.iwantPromiseResolvedPeers.inc(r.size)));
          }
          rejectMessage(e, r) {
            switch (this.trackMessage(e), r) {
              case yi.Error:
                return;
            }
            this.promises.delete(e);
          }
          clear() {
            this.promises.clear();
          }
          prune() {
            let e = Date.now() - this.requestMsByMsgExpire;
            for (let [r, n] of this.requestMsByMsg.entries())
              if (n < e)
                this.requestMsByMsg.delete(r);
              else
                break;
          }
          trackMessage(e) {
            if (this.metrics) {
              let r = this.requestMsByMsg.get(e);
              r !== void 0 && (this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - r) / 1e3), this.requestMsByMsg.delete(e));
            }
          }
        };
        c();
        var _1 = class {
          constructor(e) {
            this.entries = /* @__PURE__ */ new Map(), this.validityMs = e.validityMs;
          }
          get size() {
            return this.entries.size;
          }
          put(e, r) {
            this.entries.set(e, { value: r, validUntilMs: Date.now() + this.validityMs });
          }
          prune() {
            let e = Date.now();
            for (let [r, n] of this.entries.entries())
              if (n.validUntilMs < e)
                this.entries.delete(r);
              else
                break;
          }
          has(e) {
            return this.entries.has(e);
          }
          get(e) {
            let r = this.entries.get(e);
            return r && r.validUntilMs >= Date.now() ? r.value : void 0;
          }
          clear() {
            this.entries.clear();
          }
        };
        c();
        var hte;
        (function(t) {
          t.forward = "forward", t.publish = "publish";
        })(hte || (hte = {}));
        var ou;
        (function(t) {
          t.Fanout = "fanout", t.Random = "random", t.Subscribed = "subscribed", t.Outbound = "outbound", t.NotEnough = "not_enough", t.Opportunistic = "opportunistic";
        })(ou || (ou = {}));
        var fd;
        (function(t) {
          t.Dc = "disconnected", t.BadScore = "bad_score", t.Prune = "prune", t.Unsub = "unsubscribed", t.Excess = "excess";
        })(fd || (fd = {}));
        var S1;
        (function(t) {
          t.GraftBackoff = "graft_backoff", t.BrokenPromise = "broken_promise", t.MessageDeficit = "message_deficit", t.IPColocation = "IP_colocation";
        })(S1 || (S1 = {}));
        var x1;
        (function(t) {
          t.LowScore = "low_score", t.MaxIhave = "max_ihave", t.MaxIasked = "max_iasked";
        })(x1 || (x1 = {}));
        var v1;
        (function(t) {
          t.graylist = "graylist", t.publish = "publish", t.gossip = "gossip", t.mesh = "mesh";
        })(v1 || (v1 = {}));
        function dte(t, e, r) {
          return { protocolsEnabled: t.gauge({ name: "gossipsub_protocol", help: "Status of enabled protocols", labelNames: ["protocol"] }), topicSubscriptionStatus: t.gauge({ name: "gossipsub_topic_subscription_status", help: "Status of our subscription to this topic", labelNames: ["topicStr"] }), topicPeersCount: t.gauge({ name: "gossipsub_topic_peer_count", help: "Number of peers subscribed to each topic", labelNames: ["topicStr"] }), meshPeerCounts: t.gauge({ name: "gossipsub_mesh_peer_count", help: "Number of peers in our mesh", labelNames: ["topicStr"] }), meshPeerInclusionEvents: t.gauge({ name: "gossipsub_mesh_peer_inclusion_events_total", help: "Number of times we include peers in a topic mesh for different reasons", labelNames: ["topic", "reason"] }), meshPeerChurnEvents: t.gauge({ name: "gossipsub_peer_churn_events_total", help: "Number of times we remove peers in a topic mesh for different reasons", labelNames: ["topic", "reason"] }), peersPerProtocol: t.gauge({ name: "gossipsub_peers_per_protocol_count", help: "Peers connected for each topic", labelNames: ["protocol"] }), heartbeatDuration: t.histogram({ name: "gossipsub_heartbeat_duration_seconds", help: "The time it takes to complete one iteration of the heartbeat", buckets: [0.01, 0.1, 1] }), heartbeatSkipped: t.gauge({ name: "gossipsub_heartbeat_skipped", help: "Heartbeat run took longer than heartbeat interval so next is skipped" }), asyncValidationResult: t.gauge({ name: "gossipsub_async_validation_result_total", help: "Message validation result for each topic", labelNames: ["topic", "acceptance"] }), asyncValidationMcacheHit: t.gauge({ name: "gossipsub_async_validation_mcache_hit_total", help: "Async validation result reported by the user layer", labelNames: ["hit"] }), rpcRecvBytes: t.gauge({ name: "gossipsub_rpc_recv_bytes_total", help: "RPC recv" }), rpcRecvCount: t.gauge({ name: "gossipsub_rpc_recv_count_total", help: "RPC recv" }), rpcRecvSubscription: t.gauge({ name: "gossipsub_rpc_recv_subscription_total", help: "RPC recv" }), rpcRecvMessage: t.gauge({ name: "gossipsub_rpc_recv_message_total", help: "RPC recv" }), rpcRecvControl: t.gauge({ name: "gossipsub_rpc_recv_control_total", help: "RPC recv" }), rpcRecvIHave: t.gauge({ name: "gossipsub_rpc_recv_ihave_total", help: "RPC recv" }), rpcRecvIWant: t.gauge({ name: "gossipsub_rpc_recv_iwant_total", help: "RPC recv" }), rpcRecvGraft: t.gauge({ name: "gossipsub_rpc_recv_graft_total", help: "RPC recv" }), rpcRecvPrune: t.gauge({ name: "gossipsub_rpc_recv_prune_total", help: "RPC recv" }), rpcRecvNotAccepted: t.gauge({ name: "gossipsub_rpc_rcv_not_accepted_total", help: "Total count of RPC dropped because acceptFrom() == false" }), rpcSentBytes: t.gauge({ name: "gossipsub_rpc_sent_bytes_total", help: "RPC sent" }), rpcSentCount: t.gauge({ name: "gossipsub_rpc_sent_count_total", help: "RPC sent" }), rpcSentSubscription: t.gauge({ name: "gossipsub_rpc_sent_subscription_total", help: "RPC sent" }), rpcSentMessage: t.gauge({ name: "gossipsub_rpc_sent_message_total", help: "RPC sent" }), rpcSentControl: t.gauge({ name: "gossipsub_rpc_sent_control_total", help: "RPC sent" }), rpcSentIHave: t.gauge({ name: "gossipsub_rpc_sent_ihave_total", help: "RPC sent" }), rpcSentIWant: t.gauge({ name: "gossipsub_rpc_sent_iwant_total", help: "RPC sent" }), rpcSentGraft: t.gauge({ name: "gossipsub_rpc_sent_graft_total", help: "RPC sent" }), rpcSentPrune: t.gauge({ name: "gossipsub_rpc_sent_prune_total", help: "RPC sent" }), msgPublishCount: t.gauge({ name: "gossipsub_msg_publish_count_total", help: "Total count of msg published by topic", labelNames: ["topic"] }), msgPublishPeers: t.gauge({ name: "gossipsub_msg_publish_peers_total", help: "Total count of peers that we publish a msg to", labelNames: ["topic"] }), msgPublishPeersByGroup: t.gauge({ name: "gossipsub_msg_publish_peers_by_group", help: "Total count of peers (by group) that we publish a msg to", labelNames: ["topic", "peerGroup"] }), msgPublishBytes: t.gauge({ name: "gossipsub_msg_publish_bytes_total", help: "Total count of msg publish data.length bytes", labelNames: ["topic"] }), msgForwardCount: t.gauge({ name: "gossipsub_msg_forward_count_total", help: "Total count of msg forwarded by topic", labelNames: ["topic"] }), msgForwardPeers: t.gauge({ name: "gossipsub_msg_forward_peers_total", help: "Total count of peers that we forward a msg to", labelNames: ["topic"] }), msgReceivedPreValidation: t.gauge({ name: "gossipsub_msg_received_prevalidation_total", help: "Total count of recv msgs before any validation", labelNames: ["topic"] }), msgReceivedStatus: t.gauge({ name: "gossipsub_msg_received_status_total", help: "Tracks distribution of recv msgs by duplicate, invalid, valid", labelNames: ["topic", "status"] }), msgReceivedInvalid: t.gauge({ name: "gossipsub_msg_received_invalid_total", help: "Tracks specific reason of invalid", labelNames: ["topic", "error"] }), duplicateMsgDeliveryDelay: t.histogram({ name: "gossisub_duplicate_msg_delivery_delay_seconds", help: "Time since the 1st duplicated message validated", labelNames: ["topic"], buckets: [0.25 * r.maxMeshMessageDeliveriesWindowSec, 0.5 * r.maxMeshMessageDeliveriesWindowSec, 1 * r.maxMeshMessageDeliveriesWindowSec, 2 * r.maxMeshMessageDeliveriesWindowSec, 4 * r.maxMeshMessageDeliveriesWindowSec] }), duplicateMsgLateDelivery: t.gauge({ name: "gossisub_duplicate_msg_late_delivery_total", help: "Total count of late duplicate message delivery by topic, which triggers P3 penalty", labelNames: ["topic"] }), scoreFnCalls: t.gauge({ name: "gossipsub_score_fn_calls_total", help: "Total times score() is called" }), scoreFnRuns: t.gauge({ name: "gossipsub_score_fn_runs_total", help: "Total times score() call actually computed computeScore(), no cache" }), scoreCachedDelta: t.histogram({ name: "gossipsub_score_cache_delta", help: "Delta of score between cached values that expired", buckets: [10, 100, 1e3] }), peersByScoreThreshold: t.gauge({ name: "gossipsub_peers_by_score_threshold_count", help: "Current count of peers by score threshold", labelNames: ["threshold"] }), score: t.avgMinMax({ name: "gossipsub_score", help: "Avg min max of gossip scores", labelNames: ["topic", "p"] }), scoreWeights: t.avgMinMax({ name: "gossipsub_score_weights", help: "Separate score weights", labelNames: ["topic", "p"] }), scorePerMesh: t.avgMinMax({ name: "gossipsub_score_per_mesh", help: "Histogram of the scores for each mesh topic", labelNames: ["topic"] }), scoringPenalties: t.gauge({ name: "gossipsub_scoring_penalties_total", help: "A counter of the kind of penalties being applied to peers", labelNames: ["penalty"] }), behaviourPenalty: t.histogram({ name: "gossipsub_peer_stat_behaviour_penalty", help: "Current peer stat behaviour_penalty at each scrape", buckets: [0.25 * r.behaviourPenaltyThreshold, 0.5 * r.behaviourPenaltyThreshold, 1 * r.behaviourPenaltyThreshold, 2 * r.behaviourPenaltyThreshold, 4 * r.behaviourPenaltyThreshold] }), ihaveRcvIgnored: t.gauge({ name: "gossipsub_ihave_rcv_ignored_total", help: "Total received IHAVE messages that we ignore for some reason", labelNames: ["reason"] }), ihaveRcvMsgids: t.gauge({ name: "gossipsub_ihave_rcv_msgids_total", help: "Total received IHAVE messages by topic", labelNames: ["topic"] }), ihaveRcvNotSeenMsgids: t.gauge({ name: "gossipsub_ihave_rcv_not_seen_msgids_total", help: "Total messages per topic we do not have, not actual requests", labelNames: ["topic"] }), iwantRcvMsgids: t.gauge({ name: "gossipsub_iwant_rcv_msgids_total", help: "Total received IWANT messages by topic", labelNames: ["topic"] }), iwantRcvDonthaveMsgids: t.gauge({ name: "gossipsub_iwant_rcv_dont_have_msgids_total", help: "Total requested messageIDs that we do not have" }), iwantPromiseStarted: t.gauge({ name: "gossipsub_iwant_promise_sent_total", help: "Total count of started IWANT promises" }), iwantPromiseResolved: t.gauge({ name: "gossipsub_iwant_promise_resolved_total", help: "Total count of resolved IWANT promises" }), iwantPromiseResolvedPeers: t.gauge({ name: "gossipsub_iwant_promise_resolved_peers", help: "Total count of peers we have asked IWANT promises that are resolved" }), iwantPromiseBroken: t.gauge({ name: "gossipsub_iwant_promise_broken", help: "Total count of broken IWANT promises" }), iwantPromiseDeliveryTime: t.histogram({ name: "gossipsub_iwant_promise_delivery_seconds", help: "Histogram of delivery time of resolved IWANT promises", buckets: [0.5 * r.gossipPromiseExpireSec, 1 * r.gossipPromiseExpireSec, 2 * r.gossipPromiseExpireSec, 4 * r.gossipPromiseExpireSec] }), cacheSize: t.gauge({ name: "gossipsub_cache_size", help: "Unbounded cache sizes", labelNames: ["cache"] }), mcacheSize: t.gauge({ name: "gossipsub_mcache_size", help: "Current mcache msg count" }), topicStrToLabel: e, toTopic(n) {
            return this.topicStrToLabel.get(n) ?? n;
          }, onJoin(n) {
            this.topicSubscriptionStatus.set({ topicStr: n }, 1), this.meshPeerCounts.set({ topicStr: n }, 0);
          }, onLeave(n) {
            this.topicSubscriptionStatus.set({ topicStr: n }, 0), this.meshPeerCounts.set({ topicStr: n }, 0);
          }, onAddToMesh(n, i2, o) {
            let s = this.toTopic(n);
            this.meshPeerInclusionEvents.inc({ topic: s, reason: i2 }, o);
          }, onRemoveFromMesh(n, i2, o) {
            let s = this.toTopic(n);
            this.meshPeerChurnEvents.inc({ topic: s, reason: i2 }, o);
          }, onReportValidationMcacheHit(n) {
            this.asyncValidationMcacheHit.inc({ hit: n ? "hit" : "miss" });
          }, onReportValidation(n, i2) {
            let o = this.toTopic(n);
            this.asyncValidationResult.inc({ topic: o, acceptance: i2 });
          }, onScorePenalty(n) {
            this.scoringPenalties.inc({ penalty: n }, 1);
          }, onIhaveRcv(n, i2, o) {
            let s = this.toTopic(n);
            this.ihaveRcvMsgids.inc({ topic: s }, i2), this.ihaveRcvNotSeenMsgids.inc({ topic: s }, o);
          }, onIwantRcv(n, i2) {
            for (let [o, s] of n) {
              let a = this.toTopic(o);
              this.iwantRcvMsgids.inc({ topic: a }, s);
            }
            this.iwantRcvDonthaveMsgids.inc(i2);
          }, onForwardMsg(n, i2) {
            let o = this.toTopic(n);
            this.msgForwardCount.inc({ topic: o }, 1), this.msgForwardPeers.inc({ topic: o }, i2);
          }, onPublishMsg(n, i2, o, s) {
            let a = this.toTopic(n);
            this.msgPublishCount.inc({ topic: a }, 1), this.msgPublishBytes.inc({ topic: a }, o * s), this.msgPublishPeers.inc({ topic: a }, o), this.msgPublishPeersByGroup.inc({ topic: a, peerGroup: "direct" }, i2.direct), this.msgPublishPeersByGroup.inc({ topic: a, peerGroup: "floodsub" }, i2.floodsub), this.msgPublishPeersByGroup.inc({ topic: a, peerGroup: "mesh" }, i2.mesh), this.msgPublishPeersByGroup.inc({ topic: a, peerGroup: "fanout" }, i2.fanout);
          }, onMsgRecvPreValidation(n) {
            let i2 = this.toTopic(n);
            this.msgReceivedPreValidation.inc({ topic: i2 }, 1);
          }, onMsgRecvResult(n, i2) {
            let o = this.toTopic(n);
            this.msgReceivedStatus.inc({ topic: o, status: i2 });
          }, onMsgRecvInvalid(n, i2) {
            let o = this.toTopic(n), s = i2.reason === yi.Error ? i2.error : i2.reason;
            this.msgReceivedInvalid.inc({ topic: o, error: s }, 1);
          }, onDuplicateMsgDelivery(n, i2, o) {
            if (this.duplicateMsgDeliveryDelay.observe(i2 / 1e3), o) {
              let s = this.toTopic(n);
              this.duplicateMsgLateDelivery.inc({ topic: s }, 1);
            }
          }, onRpcRecv(n, i2) {
            this.rpcRecvBytes.inc(i2), this.rpcRecvCount.inc(1), this.rpcRecvSubscription.inc(n.subscriptions.length), this.rpcRecvMessage.inc(n.messages.length), n.control && (this.rpcRecvControl.inc(1), this.rpcRecvIHave.inc(n.control.ihave.length), this.rpcRecvIWant.inc(n.control.iwant.length), this.rpcRecvGraft.inc(n.control.graft.length), this.rpcRecvPrune.inc(n.control.prune.length));
          }, onRpcSent(n, i2) {
            if (this.rpcSentBytes.inc(i2), this.rpcSentCount.inc(1), this.rpcSentSubscription.inc(n.subscriptions.length), this.rpcSentMessage.inc(n.messages.length), n.control) {
              let o = n.control.ihave.length, s = n.control.iwant.length, a = n.control.graft.length, u = n.control.prune.length;
              o > 0 && this.rpcSentIHave.inc(o), s > 0 && this.rpcSentIWant.inc(s), a > 0 && this.rpcSentGraft.inc(a), u > 0 && this.rpcSentPrune.inc(u), (o > 0 || s > 0 || a > 0 || u > 0) && this.rpcSentControl.inc(1);
            }
          }, registerScores(n, i2) {
            let o = 0, s = 0, a = 0, u = 0;
            for (let l of n)
              l >= i2.graylistThreshold && o++, l >= i2.publishThreshold && s++, l >= i2.gossipThreshold && a++, l >= 0 && u++;
            this.peersByScoreThreshold.set({ threshold: v1.graylist }, o), this.peersByScoreThreshold.set({ threshold: v1.publish }, s), this.peersByScoreThreshold.set({ threshold: v1.gossip }, a), this.peersByScoreThreshold.set({ threshold: v1.mesh }, u), this.score.set(n);
          }, registerScoreWeights(n) {
            for (let [i2, o] of n.byTopic)
              this.scoreWeights.set({ topic: i2, p: "p1" }, o.p1w), this.scoreWeights.set({ topic: i2, p: "p2" }, o.p2w), this.scoreWeights.set({ topic: i2, p: "p3" }, o.p3w), this.scoreWeights.set({ topic: i2, p: "p3b" }, o.p3bw), this.scoreWeights.set({ topic: i2, p: "p4" }, o.p4w);
            this.scoreWeights.set({ p: "p5" }, n.p5w), this.scoreWeights.set({ p: "p6" }, n.p6w), this.scoreWeights.set({ p: "p7" }, n.p7w);
          }, registerScorePerMesh(n, i2) {
            let o = /* @__PURE__ */ new Map();
            n.forEach((s, a) => {
              let u = this.topicStrToLabel.get(a) ?? "unknown", l = o.get(u);
              l || (l = /* @__PURE__ */ new Set(), o.set(u, l)), s.forEach((f) => l?.add(f));
            });
            for (let [s, a] of o) {
              let u = [];
              a.forEach((l) => {
                u.push(i2.get(l) ?? 0);
              }), this.scorePerMesh.set({ topic: s }, u);
            }
          } };
        }
        c();
        var QC = w(YC(), 1);
        ur();
        Re();
        yr();
        var lre = U("libp2p-pubsub:");
        async function fre(t, e, r) {
          switch (t.type) {
            case nu.Signing: {
              let n = { from: t.author.toBytes(), data: r, seqno: (0, QC.randomBytes)(8), topic: e, signature: void 0, key: void 0 }, i2 = Ae([lre, ef.Message.encode(n)]);
              return n.signature = await t.privateKey.sign(i2), n.key = t.key, n;
            }
            case nu.Author:
              return { from: t.author.toBytes(), data: r, seqno: (0, QC.randomBytes)(8), topic: e, signature: void 0, key: void 0 };
            case nu.Anonymous:
              return { from: void 0, data: r, seqno: void 0, topic: e, signature: void 0, key: void 0 };
          }
        }
        async function hre(t, e) {
          switch (t) {
            case E1:
              return e.signature != null ? { valid: false, error: oi.SignaturePresent } : e.seqno != null ? { valid: false, error: oi.SeqnoPresent } : e.key != null ? { valid: false, error: oi.FromPresent } : { valid: true, fromPeerId: null };
            case ld: {
              if (e.seqno == null)
                return { valid: false, error: oi.InvalidSeqno };
              if (e.seqno.length !== 8)
                return { valid: false, error: oi.InvalidSeqno };
              if (e.signature == null)
                return { valid: false, error: oi.InvalidSignature };
              if (e.from == null)
                return { valid: false, error: oi.InvalidPeerId };
              let r;
              try {
                r = Ir(e.from);
              } catch {
                return { valid: false, error: oi.InvalidPeerId };
              }
              let n;
              if (e.key) {
                if (n = ho(e.key), r.publicKey !== void 0 && !Ce(n.bytes, r.publicKey))
                  return { valid: false, error: oi.InvalidPeerId };
              } else {
                if (r.publicKey == null)
                  return { valid: false, error: oi.InvalidPeerId };
                n = ho(r.publicKey);
              }
              let i2 = { from: e.from, data: e.data, seqno: e.seqno, topic: e.topic, signature: void 0, key: void 0 }, o = Ae([lre, ef.Message.encode(i2)]);
              return await n.verify(o, e.signature) ? { valid: true, fromPeerId: r } : { valid: false, error: oi.InvalidSignature };
            }
          }
        }
        c();
        vr();
        c();
        var UIe = w(YC(), 1);
        Re();
        me();
        vr();
        c();
        var FIe = w(K(), 1);
        var dre = (t, e) => {
          let r = U(e.toString(16).padStart(16, "0"), "base16"), n = new Uint8Array(t.length + r.length);
          return n.set(t, 0), n.set(r, t.length), n;
        };
        function pre(t) {
          if (t.sequenceNumber == null)
            throw Error("missing seqno field");
          return dre(t.from.toBytes(), t.sequenceNumber);
        }
        async function mre(t) {
          return await xe.encode(t.data);
        }
        c();
        function KIe(t, e, r, n, i2) {
          let o = 0, s = /* @__PURE__ */ new Map();
          if (Object.entries(e.topics).forEach(([p, d]) => {
            let m = i2.get(p) ?? "unknown", y = r.topics[p];
            if (y === void 0)
              return;
            let g = s.get(m);
            g || (g = { p1w: 0, p2w: 0, p3w: 0, p3bw: 0, p4w: 0 }, s.set(m, g));
            let E = 0, b = 0, v = 0, S = 0, x = 0;
            d.inMesh && (E += Math.max(d.meshTime / y.timeInMeshQuantum, y.timeInMeshCap) * y.timeInMeshWeight);
            let T = d.firstMessageDeliveries;
            if (T > y.firstMessageDeliveriesCap && (T = y.firstMessageDeliveriesCap), b += T * y.firstMessageDeliveriesWeight, d.meshMessageDeliveriesActive && d.meshMessageDeliveries < y.meshMessageDeliveriesThreshold) {
              let F = y.meshMessageDeliveriesThreshold - d.meshMessageDeliveries;
              v += F * F * y.meshMessageDeliveriesWeight;
            }
            S += d.meshFailurePenalty * y.meshFailurePenaltyWeight, x += d.invalidMessageDeliveries * d.invalidMessageDeliveries * y.invalidMessageDeliveriesWeight, o += (E + b + v + S + x) * y.topicWeight, g.p1w += E, g.p2w += b, g.p3w += v, g.p3bw += S, g.p4w += x;
          }), r.topicScoreCap > 0 && o > r.topicScoreCap) {
            o = r.topicScoreCap;
            let p = r.topicScoreCap / o;
            for (let d of s.values())
              d.p1w *= p, d.p2w *= p, d.p3w *= p, d.p3bw *= p, d.p4w *= p;
          }
          let a = 0, u = 0, l = 0;
          return a += r.appSpecificScore(t) * r.appSpecificWeight, e.ips.forEach((p) => {
            if (r.IPColocationFactorWhitelist.has(p))
              return;
            let d = n.get(p), m = d ? d.size : 0;
            if (m > r.IPColocationFactorThreshold) {
              let y = m - r.IPColocationFactorThreshold;
              u += y * y * r.IPColocationFactorWeight;
            }
          }), l += e.behaviourPenalty * e.behaviourPenalty * r.behaviourPenaltyWeight, o += a + u + l, { byTopic: s, p5w: a, p6w: u, p7w: l, score: o };
        }
        function yre(t, e, r, n, i2) {
          let o = { byTopic: /* @__PURE__ */ new Map(), p5w: [], p6w: [], p7w: [], score: [] };
          for (let s of t) {
            let a = e.get(s);
            if (a) {
              let u = KIe(s, a, r, n, i2);
              for (let [l, f] of u.byTopic) {
                let h = o.byTopic.get(l);
                h || (h = { p1w: [], p2w: [], p3w: [], p3bw: [], p4w: [] }, o.byTopic.set(l, h)), h.p1w.push(f.p1w), h.p2w.push(f.p2w), h.p3w.push(f.p3w), h.p3bw.push(f.p3bw), h.p4w.push(f.p4w);
              }
              o.p5w.push(u.p5w), o.p6w.push(u.p6w), o.p7w.push(u.p7w), o.score.push(u.score);
            } else
              o.p5w.push(0), o.p6w.push(0), o.p7w.push(0), o.score.push(0);
          }
          return o;
        }
        c();
        function YE(t, e, r = () => true) {
          let n = /* @__PURE__ */ new Set();
          if (e <= 0)
            return n;
          for (let i2 of t) {
            if (n.size >= e)
              break;
            r(i2) && (n.add(i2), t.delete(i2));
          }
          return n;
        }
        function gre(t, e) {
          return YE(t, e, () => true);
        }
        var _o;
        (function(t) {
          t[t.started = 0] = "started", t[t.stopped = 1] = "stopped";
        })(_o || (_o = {}));
        var Fg = class extends Ue {
          constructor(e = {}) {
            super(), this.multicodecs = [kg, Dg], this.peers = /* @__PURE__ */ new Map(), this.direct = /* @__PURE__ */ new Set(), this.floodsubPeers = /* @__PURE__ */ new Set(), this.acceptFromWhitelist = /* @__PURE__ */ new Map(), this.topics = /* @__PURE__ */ new Map(), this.subscriptions = /* @__PURE__ */ new Set(), this.mesh = /* @__PURE__ */ new Map(), this.fanout = /* @__PURE__ */ new Map(), this.fanoutLastpub = /* @__PURE__ */ new Map(), this.gossip = /* @__PURE__ */ new Map(), this.control = /* @__PURE__ */ new Map(), this.peerhave = /* @__PURE__ */ new Map(), this.iasked = /* @__PURE__ */ new Map(), this.backoff = /* @__PURE__ */ new Map(), this.outbound = /* @__PURE__ */ new Map(), this.topicValidators = /* @__PURE__ */ new Map(), this.heartbeatTicks = 0, this.components = new He(), this.directPeerInitial = null, this.status = { code: _o.stopped }, this.heartbeatTimer = null, this.runHeartbeat = () => {
              let n = this.metrics?.heartbeatDuration.startTimer();
              this.heartbeat().catch((i2) => {
                this.log("Error running heartbeat", i2);
              }).finally(() => {
                if (n?.(), this.status.code === _o.started) {
                  clearTimeout(this.status.heartbeatTimeout);
                  let i2 = (Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval;
                  i2 < this.opts.heartbeatInterval * 0.25 && (i2 += this.opts.heartbeatInterval, this.metrics?.heartbeatSkipped.inc()), this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, i2);
                }
              });
            };
            let r = { fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: 6, Dlo: 4, Dhi: 12, Dscore: 4, Dout: 2, Dlazy: 6, heartbeatInterval: 1e3, fanoutTTL: 6e4, mcacheLength: 5, mcacheGossip: 3, seenTTL: 12e4, gossipsubIWantFollowupMs: 3e3, prunePeers: 16, pruneBackoff: 6e4, graftFloodThreshold: 1e4, opportunisticGraftPeers: 2, opportunisticGraftTicks: 60, directConnectTicks: 300, ...e, scoreParams: ote(e.scoreParams), scoreThresholds: ate(e.scoreThresholds) };
            if (this.globalSignaturePolicy = r.globalSignaturePolicy ?? ld, r.fallbackToFloodsub && this.multicodecs.push(SC), this.log = C(r.debugName ?? "libp2p:gossipsub"), this.opts = r, this.direct = new Set(r.directPeers.map((n) => n.id.toString())), this.seenCache = new _1({ validityMs: r.seenTTL }), this.publishedMessageIds = new _1({ validityMs: r.seenTTL }), e.msgIdFn)
              this.msgIdFn = e.msgIdFn;
            else
              switch (this.globalSignaturePolicy) {
                case ld:
                  this.msgIdFn = pre;
                  break;
                case E1:
                  this.msgIdFn = mre;
                  break;
              }
            if (e.fastMsgIdFn && (this.fastMsgIdFn = e.fastMsgIdFn, this.fastMsgIdCache = new _1({ validityMs: r.seenTTL })), this.msgIdToStrFn = e.msgIdToStrFn ?? nte, this.mcache = e.messageCache || new PE(r.mcacheGossip, r.mcacheLength, this.msgIdToStrFn), e.dataTransform && (this.dataTransform = e.dataTransform), e.metricsRegister) {
              if (!e.metricsTopicStrToLabel)
                throw Error("Must set metricsTopicStrToLabel with metrics");
              let n = Math.max(...Object.values(r.scoreParams.topics).map((o) => o.meshMessageDeliveriesWindow), 1e3), i2 = dte(e.metricsRegister, e.metricsTopicStrToLabel, { gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1e3, behaviourPenaltyThreshold: r.scoreParams.behaviourPenaltyThreshold, maxMeshMessageDeliveriesWindowSec: n / 1e3 });
              i2.mcacheSize.addCollect(() => this.onScrapeMetrics(i2));
              for (let o of this.multicodecs)
                i2.protocolsEnabled.set({ protocol: o }, 1);
              this.metrics = i2;
            } else
              this.metrics = null;
            this.gossipTracer = new OE(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics), this.score = new NE(this.opts.scoreParams, this.metrics, { scoreCacheValidityMs: r.heartbeatInterval });
          }
          getPeers() {
            return [...this.peers.keys()].map((e) => ue(e));
          }
          isStarted() {
            return this.status.code === _o.started;
          }
          async init(e) {
            this.components = e, this.score.init(e);
          }
          async start() {
            if (this.isStarted())
              return;
            this.log("starting"), this.publishConfig = await RC(this.globalSignaturePolicy, this.components.getPeerId()), await Promise.all(this.opts.directPeers.map(async (i2) => {
              await this.components.getPeerStore().addressBook.add(i2.id, i2.addrs);
            })), await this.components.getRegistrar().handle(this.multicodecs, this.onIncomingStream.bind(this));
            let e = g1({ onConnect: this.onPeerConnected.bind(this), onDisconnect: this.onPeerDisconnected.bind(this) }), r = await this.components.getRegistrar().register(this.multicodecs, e), n = setTimeout(this.runHeartbeat, 100);
            this.status = { code: _o.started, registrarTopologyId: r, heartbeatTimeout: n, hearbeatStartMs: Date.now() + 100 }, this.log("started"), this.score.start(), this.directPeerInitial = setTimeout(() => {
              Promise.resolve().then(async () => {
                await Promise.all(Array.from(this.direct).map(async (i2) => await this.connect(i2)));
              }).catch((i2) => {
                this.log(i2);
              });
            }, 1e3);
          }
          async stop() {
            if (this.log("stopping"), this.status.code !== _o.started)
              return;
            let { registrarTopologyId: e } = this.status;
            this.status = { code: _o.stopped }, this.components.getRegistrar().unregister(e);
            for (let r of this.peers.values())
              r.close();
            this.peers.clear(), this.subscriptions.clear(), this.heartbeatTimer && (this.heartbeatTimer.cancel(), this.heartbeatTimer = null), this.score.stop(), this.mesh.clear(), this.fanout.clear(), this.fanoutLastpub.clear(), this.gossip.clear(), this.control.clear(), this.peerhave.clear(), this.iasked.clear(), this.backoff.clear(), this.outbound.clear(), this.gossipTracer.clear(), this.seenCache.clear(), this.fastMsgIdCache && this.fastMsgIdCache.clear(), this.directPeerInitial && clearTimeout(this.directPeerInitial), this.log("stopped");
          }
          dumpPeerScoreStats() {
            return this.score.dumpPeerScoreStats();
          }
          onIncomingStream({ protocol: e, stream: r, connection: n }) {
            if (!this.isStarted())
              return;
            let i2 = n.remotePeer, s = this.addPeer(i2, e, n.stat.direction).attachInboundStream(r);
            this.pipePeerReadStream(i2, s).catch((a) => this.log(a));
          }
          onPeerConnected(e, r) {
            !this.isStarted() || (this.log("topology peer connected %p %s", e, r.stat.direction), Promise.resolve().then(async () => {
              try {
                let { stream: n, protocol: i2 } = await r.newStream(this.multicodecs);
                await this.addPeer(e, i2, r.stat.direction).attachOutboundStream(n);
              } catch (n) {
                this.log(n);
              }
              this.subscriptions.size > 0 && this.sendSubscriptions(e.toString(), Array.from(this.subscriptions), true);
            }));
          }
          onPeerDisconnected(e) {
            this.log("connection ended %p", e), this.removePeer(e);
          }
          addPeer(e, r, n) {
            let i2 = e.toString(), o = this.peers.get(i2);
            return o === void 0 && (this.log("new peer %p", e), o = new CE({ id: e, protocol: r }), this.peers.set(i2, o), o.addEventListener("close", () => this.removePeer(e))), this.score.addPeer(i2), r === SC && this.floodsubPeers.add(i2), this.metrics?.peersPerProtocol.inc({ protocol: r }, 1), this.outbound.get(i2) || this.outbound.set(i2, n === "outbound"), o;
          }
          removePeer(e) {
            let r = e.toString(), n = this.peers.get(r);
            if (n != null) {
              this.metrics?.peersPerProtocol.inc({ protocol: n.protocol }, -1), this.log("delete peer %p", e), this.peers.delete(r), n.close();
              for (let i2 of this.topics.values())
                i2.delete(r);
            }
            for (let [i2, o] of this.mesh)
              o.delete(r) === true && this.metrics?.onRemoveFromMesh(i2, fd.Dc, 1);
            for (let i2 of this.fanout.values())
              i2.delete(r);
            return this.floodsubPeers.delete(r), this.gossip.delete(r), this.control.delete(r), this.outbound.delete(r), this.score.removePeer(r), this.acceptFromWhitelist.delete(r), n;
          }
          get started() {
            return this.status.code === _o.started;
          }
          getMeshPeers(e) {
            let r = this.mesh.get(e);
            return r ? Array.from(r) : [];
          }
          getSubscribers(e) {
            let r = this.topics.get(e);
            return (r ? Array.from(r) : []).map((n) => ue(n));
          }
          getTopics() {
            return Array.from(this.subscriptions);
          }
          async pipePeerReadStream(e, r) {
            try {
              await Te(r, async (n) => {
                for await (let i2 of n)
                  try {
                    let o = i2 instanceof Uint8Array ? i2 : i2.slice(), s = ef.decode(o);
                    this.metrics?.onRpcRecv(s, o.length), this.opts.awaitRpcHandler ? await this.handleReceivedRpc(e, s) : this.handleReceivedRpc(e, s).catch((a) => this.log(a));
                  } catch (o) {
                    this.log(o);
                  }
              });
            } catch (n) {
              this.log.error(n), this.onPeerDisconnected(e);
            }
          }
          async handleReceivedRpc(e, r) {
            if (!this.acceptFrom(e.toString())) {
              this.log("received message from unacceptable peer %p", e), this.metrics?.rpcRecvNotAccepted.inc();
              return;
            }
            this.log("rpc from %p", e), r.subscriptions.length > 0 && (r.subscriptions.forEach((n) => {
              this.handleReceivedSubscription(e, n);
            }), this.dispatchEvent(new ee("subscription-change", { detail: { peerId: e, subscriptions: r.subscriptions.filter((n) => n.topic !== null).map((n) => ({ topic: n.topic ?? "", subscribe: Boolean(n.subscribe) })) } })));
            for (let n of r.messages) {
              let i2 = this.handleReceivedMessage(e, n).catch((o) => this.log(o));
              this.opts.awaitRpcMessageHandler && await i2;
            }
            r.control && await this.handleControlMessage(e.toString(), r.control);
          }
          handleReceivedSubscription(e, r) {
            if (r.topic == null)
              return;
            this.log("subscription update from %p topic %s", e, r.topic);
            let n = this.topics.get(r.topic);
            n == null && (n = /* @__PURE__ */ new Set(), this.topics.set(r.topic, n)), r.subscribe ? n.add(e.toString()) : n.delete(e.toString());
          }
          async handleReceivedMessage(e, r) {
            this.metrics?.onMsgRecvPreValidation(r.topic);
            let n = await this.validateReceivedMessage(e, r);
            switch (this.metrics?.onMsgRecvResult(r.topic, n.code), n.code) {
              case bo.duplicate:
                this.score.duplicateMessage(e.toString(), n.msgIdStr, r.topic), this.mcache.observeDuplicate(n.msgIdStr, e.toString());
                return;
              case bo.invalid:
                if (n.msgIdStr) {
                  let i2 = n.msgIdStr;
                  this.score.rejectMessage(e.toString(), i2, r.topic, n.reason), this.gossipTracer.rejectMessage(i2, n.reason);
                } else
                  this.score.rejectInvalidMessage(e.toString(), r.topic);
                this.metrics?.onMsgRecvInvalid(r.topic, n);
                return;
              case bo.valid:
                this.score.validateMessage(n.messageId.msgIdStr), this.gossipTracer.deliverMessage(n.messageId.msgIdStr), this.mcache.put(n.messageId, r, !this.opts.asyncValidation), this.subscriptions.has(r.topic) && (!this.components.getPeerId().equals(e) || this.opts.emitSelf) && (super.dispatchEvent(new ee("gossipsub:message", { detail: { propagationSource: e, msgId: n.messageId.msgIdStr, msg: n.msg } })), super.dispatchEvent(new ee("message", { detail: n.msg }))), this.opts.asyncValidation || this.forwardMessage(n.messageId.msgIdStr, r, e.toString());
            }
          }
          async validateReceivedMessage(e, r) {
            let n = this.fastMsgIdFn?.(r), i2 = n ? this.fastMsgIdCache?.get(n) : void 0;
            if (i2)
              return { code: bo.duplicate, msgIdStr: i2 };
            let o = await hre(this.globalSignaturePolicy, r);
            if (!o.valid)
              return { code: bo.invalid, reason: yi.Error, error: o.error };
            let s;
            try {
              let p = r.data ?? new Uint8Array(0);
              s = this.dataTransform ? this.dataTransform.inboundTransform(r.topic, p) : p;
            } catch (p) {
              return this.log("Invalid message, transform failed", p), { code: bo.invalid, reason: yi.Error, error: oi.TransformFailed };
            }
            if (r.from == null)
              return this.log("Invalid message, transform failed"), { code: bo.invalid, reason: yi.Error, error: oi.TransformFailed };
            let a = { from: Ir(r.from), data: s, sequenceNumber: r.seqno == null ? void 0 : BigInt(`0x${M(r.seqno, "base16")}`), topic: r.topic }, u = await this.msgIdFn(a), l = this.msgIdToStrFn(u), f = { msgId: u, msgIdStr: l };
            if (n && this.fastMsgIdCache?.put(n, l), this.seenCache.has(l))
              return { code: bo.duplicate, msgIdStr: l };
            this.seenCache.put(l);
            let h = this.topicValidators.get(r.topic);
            if (h != null) {
              let p;
              try {
                p = await h(a.topic, a, e);
              } catch (d) {
                let m = d.code;
                m === rte && (p = Za.Ignore), m === tte ? p = Za.Reject : p = Za.Ignore;
              }
              if (p !== Za.Accept)
                return { code: bo.invalid, reason: xC(p), msgIdStr: l };
            }
            return { code: bo.valid, messageId: f, msg: a };
          }
          getScore(e) {
            return this.score.score(e);
          }
          sendSubscriptions(e, r, n) {
            this.sendRpc(e, { subscriptions: r.map((i2) => ({ topic: i2, subscribe: n })), messages: [] });
          }
          async handleControlMessage(e, r) {
            if (r === void 0)
              return;
            let n = this.handleIHave(e, r.ihave), i2 = this.handleIWant(e, r.iwant), o = await this.handleGraft(e, r.graft);
            await this.handlePrune(e, r.prune), !(!n.length && !i2.length && !o.length) && this.sendRpc(e, Qa(i2, { iwant: n, prune: o }));
          }
          acceptFrom(e) {
            if (this.direct.has(e))
              return true;
            let r = Date.now(), n = this.acceptFromWhitelist.get(e);
            if (n && n.messagesAccepted < 128 && n.acceptUntil >= r)
              return n.messagesAccepted += 1, true;
            let i2 = this.score.score(e);
            return i2 >= 0 ? this.acceptFromWhitelist.set(e, { messagesAccepted: 0, acceptUntil: r + 1e3 }) : this.acceptFromWhitelist.delete(e), i2 >= this.opts.scoreThresholds.graylistThreshold;
          }
          handleIHave(e, r) {
            if (!r.length)
              return [];
            let n = this.score.score(e);
            if (n < this.opts.scoreThresholds.gossipThreshold)
              return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", e, n), this.metrics?.ihaveRcvIgnored.inc({ reason: x1.LowScore }), [];
            let i2 = (this.peerhave.get(e) ?? 0) + 1;
            if (this.peerhave.set(e, i2), i2 > 10)
              return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", e, i2), this.metrics?.ihaveRcvIgnored.inc({ reason: x1.MaxIhave }), [];
            let o = this.iasked.get(e) ?? 0;
            if (o >= 5e3)
              return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", e, o), this.metrics?.ihaveRcvIgnored.inc({ reason: x1.MaxIasked }), [];
            let s = /* @__PURE__ */ new Map();
            if (r.forEach(({ topicID: l, messageIDs: f }) => {
              if (!l || !this.mesh.has(l))
                return;
              let h = 0;
              f.forEach((p) => {
                let d = this.msgIdToStrFn(p);
                this.seenCache.has(d) || (s.set(d, p), h++);
              }), this.metrics?.onIhaveRcv(l, f.length, h);
            }), !s.size)
              return [];
            let a = s.size;
            a + o > 5e3 && (a = 5e3 - o), this.log("IHAVE: Asking for %d out of %d messages from %s", a, s.size, e);
            let u = Array.from(s.values());
            return Xa(u), u = u.slice(0, a), this.iasked.set(e, o + a), this.gossipTracer.addPromise(e, u), [{ messageIDs: u }];
          }
          handleIWant(e, r) {
            if (!r.length)
              return [];
            let n = this.score.score(e);
            if (n < this.opts.scoreThresholds.gossipThreshold)
              return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", e, n), [];
            let i2 = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = 0;
            return r.forEach(({ messageIDs: a }) => {
              a.forEach((u) => {
                let l = this.msgIdToStrFn(u), f = this.mcache.getWithIWantCount(l, e);
                if (f == null) {
                  s++;
                  return;
                }
                if (o.set(f.msg.topic, 1 + (o.get(f.msg.topic) ?? 0)), f.count > 3) {
                  this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", e, u);
                  return;
                }
                i2.set(l, f.msg);
              });
            }), this.metrics?.onIwantRcv(o, s), i2.size ? (this.log("IWANT: Sending %d messages to %s", i2.size, e), Array.from(i2.values())) : (this.log("IWANT: Could not provide any wanted messages to %s", e), []);
          }
          async handleGraft(e, r) {
            let n = [], i2 = this.score.score(e), o = Date.now(), s = this.opts.doPX;
            return r.forEach(({ topicID: a }) => {
              if (!a)
                return;
              let u = this.mesh.get(a);
              if (!u) {
                s = false;
                return;
              }
              if (u.has(e))
                return;
              if (this.direct.has(e)) {
                this.log("GRAFT: ignoring request from direct peer %s", e), n.push(a), s = false;
                return;
              }
              let l = this.backoff.get(a)?.get(e);
              if (typeof l == "number" && o < l) {
                this.log("GRAFT: ignoring backed off peer %s", e), this.score.addPenalty(e, 1, S1.GraftBackoff), s = false;
                let f = l + this.opts.graftFloodThreshold - this.opts.pruneBackoff;
                o < f && this.score.addPenalty(e, 1, S1.GraftBackoff), this.addBackoff(e, a), n.push(a);
                return;
              }
              if (i2 < 0) {
                this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", e, i2, a), n.push(a), s = false, this.addBackoff(e, a);
                return;
              }
              if (u.size >= this.opts.Dhi && !this.outbound.get(e)) {
                n.push(a), this.addBackoff(e, a);
                return;
              }
              this.log("GRAFT: Add mesh link from %s in %s", e, a), this.score.graft(e, a), u.add(e), this.metrics?.onAddToMesh(a, ou.Subscribed, 1);
            }), n.length ? await Promise.all(n.map((a) => this.makePrune(e, a, s))) : [];
          }
          async handlePrune(e, r) {
            let n = this.score.score(e);
            for (let { topicID: i2, backoff: o, peers: s } of r) {
              if (i2 == null)
                continue;
              let a = this.mesh.get(i2);
              if (!a)
                return;
              if (this.log("PRUNE: Remove mesh link to %s in %s", e, i2), this.score.prune(e, i2), a.has(e) && (a.delete(e), this.metrics?.onRemoveFromMesh(i2, fd.Unsub, 1)), typeof o == "number" && o > 0 ? this.doAddBackoff(e, i2, o * 1e3) : this.addBackoff(e, i2), s.length) {
                if (n < this.opts.scoreThresholds.acceptPXThreshold) {
                  this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", e, n, i2);
                  continue;
                }
                await this.pxConnect(s);
              }
            }
          }
          addBackoff(e, r) {
            this.doAddBackoff(e, r, this.opts.pruneBackoff);
          }
          doAddBackoff(e, r, n) {
            let i2 = this.backoff.get(r);
            i2 || (i2 = /* @__PURE__ */ new Map(), this.backoff.set(r, i2));
            let o = Date.now() + n;
            (i2.get(e) ?? 0) < o && i2.set(e, o);
          }
          applyIwantPenalties() {
            this.gossipTracer.getBrokenPromises().forEach((e, r) => {
              this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", r, e), this.score.addPenalty(r, e, S1.BrokenPromise);
            });
          }
          clearBackoff() {
            if (this.heartbeatTicks % 15 !== 0)
              return;
            let e = Date.now();
            this.backoff.forEach((r, n) => {
              r.forEach((i2, o) => {
                i2 < e && r.delete(o);
              }), r.size === 0 && this.backoff.delete(n);
            });
          }
          async directConnect() {
            let e = [];
            this.direct.forEach((r) => {
              let n = this.peers.get(r);
              (!n || !n.isWritable) && e.push(r);
            }), await Promise.all(e.map(async (r) => await this.connect(r)));
          }
          async pxConnect(e) {
            e.length > this.opts.prunePeers && (Xa(e), e = e.slice(0, this.opts.prunePeers));
            let r = [];
            await Promise.all(e.map(async (n) => {
              if (!n.peerID)
                return;
              let i2 = Ir(n.peerID).toString();
              if (!this.peers.has(i2)) {
                if (!n.signedPeerRecord) {
                  r.push(i2);
                  return;
                }
                try {
                  let o = await ln.openAndCertify(n.signedPeerRecord, "libp2p-peer-record"), s = o.peerId;
                  if (!o.peerId.equals(i2)) {
                    this.log("bogus peer record obtained through px: peer ID %p doesn't match expected peer %p", s, i2);
                    return;
                  }
                  if (!await this.components.getPeerStore().addressBook.consumePeerRecord(o)) {
                    this.log("bogus peer record obtained through px: could not add peer record to address book");
                    return;
                  }
                  r.push(i2);
                } catch {
                  this.log("bogus peer record obtained through px: invalid signature or not a peer record");
                }
              }
            })), r.length && await Promise.all(r.map(async (n) => await this.connect(n)));
          }
          async connect(e) {
            this.log("Initiating connection with %s", e), await (await this.components.getConnectionManager().openConnection(ue(e))).newStream(this.multicodecs);
          }
          subscribe(e) {
            if (this.status.code !== _o.started)
              throw new Error("Pubsub has not started");
            if (!this.subscriptions.has(e)) {
              this.subscriptions.add(e);
              for (let r of this.peers.keys())
                this.sendSubscriptions(r, [e], true);
            }
            this.join(e);
          }
          unsubscribe(e) {
            if (this.status.code !== _o.started)
              throw new Error("Pubsub is not started");
            let r = this.subscriptions.delete(e);
            if (this.log("unsubscribe from %s - am subscribed %s", e, r), r)
              for (let n of this.peers.keys())
                this.sendSubscriptions(n, [e], false);
            this.leave(e).catch((n) => {
              this.log(n);
            });
          }
          join(e) {
            if (this.status.code !== _o.started)
              throw new Error("Gossipsub has not started");
            if (this.mesh.has(e))
              return;
            this.log("JOIN %s", e), this.metrics?.onJoin(e);
            let r = /* @__PURE__ */ new Set(), n = this.fanout.get(e);
            if (n && (this.fanout.delete(e), this.fanoutLastpub.delete(e), n.forEach((i2) => {
              !this.direct.has(i2) && this.score.score(i2) >= 0 && r.add(i2);
            }), this.metrics?.onAddToMesh(e, ou.Fanout, r.size)), r.size < this.opts.D) {
              let i2 = r.size;
              this.getRandomGossipPeers(e, this.opts.D, (s) => !r.has(s) && !this.direct.has(s) && this.score.score(s) >= 0).forEach((s) => {
                r.add(s);
              }), this.metrics?.onAddToMesh(e, ou.Random, r.size - i2);
            }
            this.mesh.set(e, r), r.forEach((i2) => {
              this.log("JOIN: Add mesh link to %s in %s", i2, e), this.sendGraft(i2, e);
            });
          }
          async leave(e) {
            if (this.status.code !== _o.started)
              throw new Error("Gossipsub has not started");
            this.log("LEAVE %s", e), this.metrics?.onLeave(e);
            let r = this.mesh.get(e);
            r && (await Promise.all(Array.from(r).map(async (n) => (this.log("LEAVE: Remove mesh link to %s in %s", n, e), await this.sendPrune(n, e)))), this.mesh.delete(e));
          }
          selectPeersToForward(e, r, n) {
            let i2 = /* @__PURE__ */ new Set(), o = this.topics.get(e);
            o && (this.direct.forEach((a) => {
              o.has(a) && r !== a && !n?.has(a) && i2.add(a);
            }), this.floodsubPeers.forEach((a) => {
              o.has(a) && r !== a && !n?.has(a) && this.score.score(a) >= this.opts.scoreThresholds.publishThreshold && i2.add(a);
            }));
            let s = this.mesh.get(e);
            return s && s.size > 0 && s.forEach((a) => {
              r !== a && !n?.has(a) && i2.add(a);
            }), i2;
          }
          selectPeersToPublish(e) {
            let r = /* @__PURE__ */ new Set(), n = { direct: 0, floodsub: 0, mesh: 0, fanout: 0 }, i2 = this.topics.get(e);
            if (i2)
              if (this.opts.floodPublish)
                i2.forEach((o) => {
                  this.direct.has(o) ? (r.add(o), n.direct++) : this.score.score(o) >= this.opts.scoreThresholds.publishThreshold && (r.add(o), n.floodsub++);
                });
              else {
                this.direct.forEach((s) => {
                  i2.has(s) && (r.add(s), n.direct++);
                }), this.floodsubPeers.forEach((s) => {
                  i2.has(s) && this.score.score(s) >= this.opts.scoreThresholds.publishThreshold && (r.add(s), n.floodsub++);
                });
                let o = this.mesh.get(e);
                if (o && o.size > 0)
                  o.forEach((s) => {
                    r.add(s), n.mesh++;
                  });
                else {
                  let s = this.fanout.get(e);
                  if (s && s.size > 0)
                    s.forEach((a) => {
                      r.add(a), n.fanout++;
                    });
                  else {
                    let a = this.getRandomGossipPeers(e, this.opts.D, (u) => this.score.score(u) >= this.opts.scoreThresholds.publishThreshold);
                    a.size > 0 && (this.fanout.set(e, a), a.forEach((u) => {
                      r.add(u), n.fanout++;
                    }));
                  }
                  this.fanoutLastpub.set(e, Date.now());
                }
              }
            return { tosend: r, tosendCount: n };
          }
          forwardMessage(e, r, n, i2) {
            n && this.score.deliverMessage(n, e, r.topic);
            let o = this.selectPeersToForward(r.topic, n, i2), s = Qa([r]);
            o.forEach((a) => {
              this.sendRpc(a, s);
            }), this.metrics?.onForwardMsg(r.topic, o.size);
          }
          async publish(e, r) {
            let n = this.dataTransform ? this.dataTransform.outboundTransform(e, r) : r;
            if (this.publishConfig == null)
              throw Error("PublishError.Uninitialized");
            let i2 = await fre(this.publishConfig, e, n);
            if (i2.from == null)
              throw Error("PublishError.InvalidMessage");
            let o = { from: Ir(i2.from), data: r, sequenceNumber: i2.seqno == null ? void 0 : BigInt(`0x${M(i2.seqno, "base16")}`), topic: e, signature: i2.signature, key: i2.key }, s = await this.msgIdFn(o), a = this.msgIdToStrFn(s);
            if (this.seenCache.has(a))
              throw Error("PublishError.Duplicate");
            let { tosend: u, tosendCount: l } = this.selectPeersToPublish(i2.topic), f = this.opts.emitSelf === true && this.subscriptions.has(e);
            if (u.size === 0 && !this.opts.allowPublishToZeroPeers && !f)
              throw Error("PublishError.InsufficientPeers");
            this.seenCache.put(a), this.mcache.put({ msgId: s, msgIdStr: a }, i2, true), this.publishedMessageIds.put(a);
            let h = Qa([i2]);
            for (let p of u)
              this.sendRpc(p, h) || u.delete(p);
            return this.metrics?.onPublishMsg(e, l, u.size, i2.data != null ? i2.data.length : 0), f && (u.add(this.components.getPeerId().toString()), super.dispatchEvent(new ee("gossipsub:message", { detail: { propagationSource: this.components.getPeerId(), msgId: a, msg: o } })), super.dispatchEvent(new ee("message", { detail: o }))), { recipients: Array.from(u.values()).map((p) => ue(p)) };
          }
          reportMessageValidationResult(e, r, n) {
            if (n === Za.Accept) {
              let i2 = this.mcache.validate(e);
              if (this.metrics?.onReportValidationMcacheHit(i2 !== null), i2 != null) {
                let { message: o, originatingPeers: s } = i2;
                this.score.deliverMessage(r.toString(), e, o.topic), this.forwardMessage(e, i2.message, r.toString(), s), this.metrics?.onReportValidation(o.topic, n);
              }
            } else {
              let i2 = this.mcache.remove(e);
              if (this.metrics?.onReportValidationMcacheHit(i2 !== null), i2) {
                let o = xC(n), { message: s, originatingPeers: a } = i2;
                this.score.rejectMessage(r.toString(), e, s.topic, o);
                for (let u of a)
                  this.score.rejectMessage(u, e, s.topic, o);
                this.metrics?.onReportValidation(s.topic, n);
              }
            }
          }
          sendGraft(e, r) {
            let i2 = Qa([], { graft: [{ topicID: r }] });
            this.sendRpc(e, i2);
          }
          async sendPrune(e, r) {
            let n = [await this.makePrune(e, r, this.opts.doPX)], i2 = Qa([], { prune: n });
            this.sendRpc(e, i2);
          }
          sendRpc(e, r) {
            let n = this.peers.get(e);
            if (!n || !n.isWritable)
              return this.log(`Cannot send RPC to ${e} as there is no open stream to it available`), false;
            let i2 = this.control.get(e);
            i2 && (this.piggybackControl(e, r, i2), this.control.delete(e));
            let o = this.gossip.get(e);
            o && (this.piggybackGossip(e, r, o), this.gossip.delete(e));
            let s = ef.encode(r);
            return n.write(s), this.metrics?.onRpcSent(r, s.length), true;
          }
          piggybackControl(e, r, n) {
            let i2 = n.graft.filter(({ topicID: s }) => (s && this.mesh.get(s) || /* @__PURE__ */ new Set()).has(e)), o = n.prune.filter(({ topicID: s }) => !(s && this.mesh.get(s) || /* @__PURE__ */ new Set()).has(e));
            !i2.length && !o.length || (r.control ? (r.control.graft = r.control.graft.concat(i2), r.control.prune = r.control.prune.concat(o)) : r.control = { graft: i2, prune: o, ihave: [], iwant: [] });
          }
          piggybackGossip(e, r, n) {
            r.control || (r.control = { ihave: [], iwant: [], graft: [], prune: [] }), r.control.ihave = n;
          }
          async sendGraftPrune(e, r, n) {
            let i2 = this.opts.doPX;
            for (let [o, s] of e) {
              let a = s.map((h) => ({ topicID: h })), u = [], l = r.get(o);
              l && (u = await Promise.all(l.map(async (h) => await this.makePrune(o, h, i2 && !(n.get(o) ?? false)))), r.delete(o));
              let f = Qa([], { graft: a, prune: u });
              this.sendRpc(o, f);
            }
            for (let [o, s] of r) {
              let a = await Promise.all(s.map(async (l) => await this.makePrune(o, l, i2 && !(n.get(o) ?? false)))), u = Qa([], { prune: a });
              this.sendRpc(o, u);
            }
          }
          emitGossip(e) {
            let r = this.mcache.getGossipIDs(new Set(e.keys()));
            for (let [n, i2] of e)
              this.doEmitGossip(n, i2, r.get(n) ?? []);
          }
          doEmitGossip(e, r, n) {
            if (!n.length || (Xa(n), n.length > 5e3 && this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", n.length), !r.size))
              return;
            let i2 = this.opts.Dlazy, o = 0.25 * r.size, s = r;
            o > i2 && (i2 = o), i2 > s.size ? i2 = s.size : s = Xa(Array.from(s)).slice(0, i2), s.forEach((a) => {
              let u = n;
              n.length > 5e3 && (u = Xa(u.slice()).slice(0, 5e3)), this.pushGossip(a, { topicID: e, messageIDs: u });
            });
          }
          flush() {
            for (let [e, r] of this.gossip.entries())
              this.gossip.delete(e), this.sendRpc(e, Qa([], { ihave: r }));
            for (let [e, r] of this.control.entries())
              this.control.delete(e), this.sendRpc(e, Qa([], { graft: r.graft, prune: r.prune }));
          }
          pushGossip(e, r) {
            this.log("Add gossip to %s", e);
            let n = this.gossip.get(e) || [];
            this.gossip.set(e, n.concat(r));
          }
          async makePrune(e, r, n) {
            if (this.score.prune(e, r), this.peers.get(e).protocol === Dg)
              return { topicID: r, peers: [] };
            let i2 = BigInt(this.opts.pruneBackoff / 1e3);
            if (!n)
              return { topicID: r, peers: [], backoff: i2 };
            let o = this.getRandomGossipPeers(r, this.opts.prunePeers, (a) => a !== e && this.score.score(a) >= 0), s = await Promise.all(Array.from(o).map(async (a) => {
              let u = ue(a);
              return { peerID: u.toBytes(), signedPeerRecord: await this.components.getPeerStore().addressBook.getRawEnvelope(u) };
            }));
            return { topicID: r, peers: s, backoff: i2 };
          }
          async heartbeat() {
            let { D: e, Dlo: r, Dhi: n, Dscore: i2, Dout: o, fanoutTTL: s } = this.opts;
            this.heartbeatTicks++;
            let a = /* @__PURE__ */ new Map(), u = (m) => {
              let y = a.get(m);
              return y === void 0 && (y = this.score.score(m), a.set(m, y)), y;
            }, l = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
            this.clearBackoff(), this.peerhave.clear(), this.metrics?.cacheSize.set({ cache: "iasked" }, this.iasked.size), this.iasked.clear(), this.applyIwantPenalties(), this.heartbeatTicks % this.opts.directConnectTicks === 0 && await this.directConnect(), this.fastMsgIdCache?.prune(), this.seenCache.prune(), this.gossipTracer.prune(), this.publishedMessageIds.prune();
            let p = /* @__PURE__ */ new Map();
            this.mesh.forEach((m, y) => {
              let g = this.topics.get(y), E = /* @__PURE__ */ new Set(), b = /* @__PURE__ */ new Set();
              if (p.set(y, b), g) {
                let x = Xa(Array.from(g)), T = this.backoff.get(y);
                for (let R of x) {
                  let O = this.peers.get(R);
                  if (O && DE(O.protocol) && !m.has(R) && !this.direct.has(R)) {
                    let F = u(R);
                    (!T || !T.has(R)) && F >= 0 && E.add(R), F >= this.opts.scoreThresholds.gossipThreshold && b.add(R);
                  }
                }
              }
              let v = (x, T) => {
                this.log("HEARTBEAT: Remove mesh link to %s in %s", x, y), this.addBackoff(x, y), m.delete(x), u(x) >= this.opts.scoreThresholds.gossipThreshold && b.add(x), this.metrics?.onRemoveFromMesh(y, T, 1);
                let R = f.get(x);
                R ? R.push(y) : f.set(x, [y]);
              }, S = (x, T) => {
                this.log("HEARTBEAT: Add mesh link to %s in %s", x, y), this.score.graft(x, y), m.add(x), b.delete(x), this.metrics?.onAddToMesh(y, T, 1);
                let R = l.get(x);
                R ? R.push(y) : l.set(x, [y]);
              };
              if (m.forEach((x) => {
                let T = u(x);
                T < 0 && (this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", x, T, y), v(x, fd.BadScore), h.set(x, true));
              }), m.size < r) {
                let x = e - m.size;
                gre(E, x).forEach((R) => {
                  S(R, ou.NotEnough);
                });
              }
              if (m.size > n) {
                let x = Array.from(m);
                x.sort((R, O) => u(O) - u(R)), x = x.slice(0, i2).concat(Xa(x.slice(i2)));
                let T = 0;
                if (x.slice(0, e).forEach((R) => {
                  this.outbound.get(R) && T++;
                }), T < o) {
                  let R = (F) => {
                    let z = x[F];
                    for (let W = F; W > 0; W--)
                      x[W] = x[W - 1];
                    x[0] = z;
                  };
                  if (T > 0) {
                    let F = T;
                    for (let z = 1; z < e && F > 0; z++)
                      this.outbound.get(x[z]) && (R(z), F--);
                  }
                  let O = e - T;
                  for (let F = e; F < x.length && O > 0; F++)
                    this.outbound.get(x[F]) && (R(F), O--);
                }
                x.slice(e).forEach((R) => {
                  v(R, fd.Excess);
                });
              }
              if (m.size >= r) {
                let x = 0;
                if (m.forEach((T) => {
                  this.outbound.get(T) && x++;
                }), x < o) {
                  let T = o - x;
                  YE(E, T, (O) => this.outbound.get(O) === true).forEach((O) => {
                    S(O, ou.Outbound);
                  });
                }
              }
              if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && m.size > 1) {
                let x = Array.from(m).sort((O, F) => u(O) - u(F)), T = Math.floor(m.size / 2), R = u(x[T]);
                if (R < this.opts.scoreThresholds.opportunisticGraftThreshold) {
                  let O = this.opts.opportunisticGraftPeers, F = YE(E, O, (z) => u(z) > R);
                  for (let z of F)
                    this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", z, y), S(z, ou.Opportunistic);
                }
              }
            });
            let d = Date.now();
            this.fanoutLastpub.forEach((m, y) => {
              m + s < d && (this.fanout.delete(y), this.fanoutLastpub.delete(y));
            }), this.fanout.forEach((m, y) => {
              let g = this.topics.get(y);
              m.forEach((S) => {
                (!g.has(S) || u(S) < this.opts.scoreThresholds.publishThreshold) && m.delete(S);
              });
              let E = this.topics.get(y), b = [], v = /* @__PURE__ */ new Set();
              if (p.set(y, v), E) {
                let S = Xa(Array.from(E));
                for (let x of S) {
                  let T = this.peers.get(x);
                  if (T && DE(T.protocol) && !m.has(x) && !this.direct.has(x)) {
                    let R = u(x);
                    R >= this.opts.scoreThresholds.publishThreshold && b.push(x), R >= this.opts.scoreThresholds.gossipThreshold && v.add(x);
                  }
                }
              }
              if (m.size < e) {
                let S = e - m.size;
                b.slice(0, S).forEach((x) => {
                  m.add(x), v?.delete(x);
                });
              }
            }), this.emitGossip(p), await this.sendGraftPrune(l, f, h), this.flush(), this.mcache.shift(), this.dispatchEvent(new ee("gossipsub:heartbeat"));
          }
          getRandomGossipPeers(e, r, n = () => true) {
            let i2 = this.topics.get(e);
            if (!i2)
              return /* @__PURE__ */ new Set();
            let o = [];
            return i2.forEach((s) => {
              let a = this.peers.get(s);
              !a || DE(a.protocol) && n(s) && o.push(s);
            }), o = Xa(o), r > 0 && o.length > r && (o = o.slice(0, r)), new Set(o);
          }
          onScrapeMetrics(e) {
            e.mcacheSize.set(this.mcache.size), e.cacheSize.set({ cache: "direct" }, this.direct.size), e.cacheSize.set({ cache: "seenCache" }, this.seenCache.size), e.cacheSize.set({ cache: "fastMsgIdCache" }, this.fastMsgIdCache?.size ?? 0), e.cacheSize.set({ cache: "publishedMessageIds" }, this.publishedMessageIds.size), e.cacheSize.set({ cache: "mcache" }, this.mcache.size), e.cacheSize.set({ cache: "score" }, this.score.size), e.cacheSize.set({ cache: "gossipTracer.promises" }, this.gossipTracer.size), e.cacheSize.set({ cache: "gossipTracer.requests" }, this.gossipTracer.requestMsByMsgSize), e.cacheSize.set({ cache: "topics" }, this.topics.size), e.cacheSize.set({ cache: "subscriptions" }, this.subscriptions.size), e.cacheSize.set({ cache: "mesh" }, this.mesh.size), e.cacheSize.set({ cache: "fanout" }, this.fanout.size), e.cacheSize.set({ cache: "peers" }, this.peers.size), e.cacheSize.set({ cache: "acceptFromWhitelist" }, this.acceptFromWhitelist.size), e.cacheSize.set({ cache: "gossip" }, this.gossip.size), e.cacheSize.set({ cache: "control" }, this.control.size), e.cacheSize.set({ cache: "peerhave" }, this.peerhave.size), e.cacheSize.set({ cache: "outbound" }, this.outbound.size);
            let r = 0;
            for (let s of this.backoff.values())
              r += s.size;
            e.cacheSize.set({ cache: "backoff" }, r);
            for (let [s, a] of this.topics)
              e.topicPeersCount.set({ topicStr: s }, a.size);
            for (let [s, a] of this.mesh)
              e.meshPeerCounts.set({ topicStr: s }, a.size);
            let n = [], i2 = /* @__PURE__ */ new Map();
            e.behaviourPenalty.reset();
            for (let s of this.peers.keys()) {
              let a = this.score.score(s);
              n.push(a), i2.set(s, a), e.behaviourPenalty.observe(this.score.peerStats.get(s)?.behaviourPenalty ?? 0);
            }
            e.registerScores(n, this.opts.scoreThresholds), e.registerScorePerMesh(this.mesh, i2);
            let o = yre(this.peers.keys(), this.score.peerStats, this.score.params, this.score.peerIPs, e.topicStrToLabel);
            e.registerScoreWeights(o);
          }
        };
        Fg.multicodec = kg;
        var Ere = () => ({ gossipsub: new Fg({ allowPublishToZeroPeers: true, fallbackToFloodsub: true, emitSelf: true }) });
        c();
        te();
        c();
        var Are = w(Xu(), 1);
        c();
        c();
        function XC(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var gd = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, au, Kg = class {
          constructor() {
            au.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && gd(this, au, "f")[this.size - 1].priority >= r.priority) {
              gd(this, au, "f").push(n);
              return;
            }
            let i2 = XC(gd(this, au, "f"), n, (o, s) => s.priority - o.priority);
            gd(this, au, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = gd(this, au, "f").shift();
            return e?.run;
          }
          filter(e) {
            return gd(this, au, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return gd(this, au, "f").length;
          }
        };
        au = /* @__PURE__ */ new WeakMap();
        var tr = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, be = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Wn, qg, zg, af, eb, Hg, QE, Js, Vg, vo, XE, So, $g, sf, P1, D1, wd, ZE, bre, _re, Rre, vre, Sre, xre, JE, ZC, JC, tb, rb = () => {
        }, pCe = new hi(), eP = class extends Error {
        }, Gg = class extends Are.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), Wn.add(this), qg.set(this, void 0), zg.set(this, void 0), af.set(this, 0), eb.set(this, void 0), Hg.set(this, void 0), QE.set(this, 0), Js.set(this, void 0), Vg.set(this, void 0), vo.set(this, void 0), XE.set(this, void 0), So.set(this, 0), $g.set(this, void 0), sf.set(this, void 0), P1.set(this, rb), D1.set(this, rb), wd.set(this, void 0), ZE.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: Kg, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            tr(this, qg, e.carryoverConcurrencyCount, "f"), tr(this, zg, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), tr(this, eb, e.intervalCap, "f"), tr(this, Hg, e.interval, "f"), tr(this, vo, new e.queueClass(), "f"), tr(this, XE, e.queueClass, "f"), this.concurrency = e.concurrency, tr(this, wd, e.timeout, "f"), tr(this, ZE, e.throwOnTimeout === true, "f"), tr(this, sf, e.autoStart === false, "f");
          }
          get concurrency() {
            return be(this, $g, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            tr(this, $g, e, "f"), be(this, Wn, "m", tb).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                tr(this, So, (a = be(this, So, "f"), a++, a), "f"), tr(this, af, (u = be(this, af, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new eP("The task was aborted."));
                    return;
                  }
                  let f = await (be(this, wd, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? be(this, wd, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? be(this, ZE, "f") : r.throwOnTimeout) && i2(pCe);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                be(this, Wn, "m", Rre).call(this);
              };
              be(this, vo, "f").enqueue(o, r), be(this, Wn, "m", JE).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return be(this, sf, "f") ? (tr(this, sf, false, "f"), be(this, Wn, "m", tb).call(this), this) : this;
          }
          pause() {
            tr(this, sf, true, "f");
          }
          clear() {
            tr(this, vo, new (be(this, XE, "f"))(), "f");
          }
          async onEmpty() {
            if (be(this, vo, "f").size !== 0)
              return new Promise((e) => {
                let r = be(this, P1, "f");
                tr(this, P1, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(be(this, vo, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  be(this, vo, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(be(this, So, "f") === 0 && be(this, vo, "f").size === 0))
              return new Promise((e) => {
                let r = be(this, D1, "f");
                tr(this, D1, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return be(this, vo, "f").size;
          }
          sizeBy(e) {
            return be(this, vo, "f").filter(e).length;
          }
          get pending() {
            return be(this, So, "f");
          }
          get isPaused() {
            return be(this, sf, "f");
          }
          get timeout() {
            return be(this, wd, "f");
          }
          set timeout(e) {
            tr(this, wd, e, "f");
          }
        };
        qg = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), af = /* @__PURE__ */ new WeakMap(), eb = /* @__PURE__ */ new WeakMap(), Hg = /* @__PURE__ */ new WeakMap(), QE = /* @__PURE__ */ new WeakMap(), Js = /* @__PURE__ */ new WeakMap(), Vg = /* @__PURE__ */ new WeakMap(), vo = /* @__PURE__ */ new WeakMap(), XE = /* @__PURE__ */ new WeakMap(), So = /* @__PURE__ */ new WeakMap(), $g = /* @__PURE__ */ new WeakMap(), sf = /* @__PURE__ */ new WeakMap(), P1 = /* @__PURE__ */ new WeakMap(), D1 = /* @__PURE__ */ new WeakMap(), wd = /* @__PURE__ */ new WeakMap(), ZE = /* @__PURE__ */ new WeakMap(), Wn = /* @__PURE__ */ new WeakSet(), bre = function() {
          return be(this, zg, "f") || be(this, af, "f") < be(this, eb, "f");
        }, _re = function() {
          return be(this, So, "f") < be(this, $g, "f");
        }, Rre = function() {
          var e;
          tr(this, So, (e = be(this, So, "f"), e--, e), "f"), be(this, Wn, "m", JE).call(this), this.emit("next");
        }, vre = function() {
          be(this, P1, "f").call(this), tr(this, P1, rb, "f"), be(this, So, "f") === 0 && (be(this, D1, "f").call(this), tr(this, D1, rb, "f"), this.emit("idle"));
        }, Sre = function() {
          be(this, Wn, "m", JC).call(this), be(this, Wn, "m", ZC).call(this), tr(this, Vg, void 0, "f");
        }, xre = function() {
          let e = Date.now();
          if (be(this, Js, "f") === void 0) {
            let r = be(this, QE, "f") - e;
            if (r < 0)
              tr(this, af, be(this, qg, "f") ? be(this, So, "f") : 0, "f");
            else
              return be(this, Vg, "f") === void 0 && tr(this, Vg, setTimeout(() => {
                be(this, Wn, "m", Sre).call(this);
              }, r), "f"), true;
          }
          return false;
        }, JE = function() {
          if (be(this, vo, "f").size === 0)
            return be(this, Js, "f") && clearInterval(be(this, Js, "f")), tr(this, Js, void 0, "f"), be(this, Wn, "m", vre).call(this), false;
          if (!be(this, sf, "f")) {
            let e = !be(this, Wn, "m", xre).call(this);
            if (be(this, Wn, "a", bre) && be(this, Wn, "a", _re)) {
              let r = be(this, vo, "f").dequeue();
              return r ? (this.emit("active"), r(), e && be(this, Wn, "m", ZC).call(this), true) : false;
            }
          }
          return false;
        }, ZC = function() {
          be(this, zg, "f") || be(this, Js, "f") !== void 0 || (tr(this, Js, setInterval(() => {
            be(this, Wn, "m", JC).call(this);
          }, be(this, Hg, "f")), "f"), tr(this, QE, Date.now() + be(this, Hg, "f"), "f"));
        }, JC = function() {
          be(this, af, "f") === 0 && be(this, So, "f") === 0 && be(this, Js, "f") && (clearInterval(be(this, Js, "f")), tr(this, Js, void 0, "f")), tr(this, af, be(this, qg, "f") ? be(this, So, "f") : 0, "f"), be(this, Wn, "m", tb).call(this);
        }, tb = function() {
          for (; be(this, Wn, "m", JE).call(this); )
            ;
        };
        var Ire = w(K(), 1);
        var tP = w(Vi(), 1);
        var Ed = C("libp2p-delegated-peer-routing"), Tre = 3e4, mCe = 4, nb = class {
          constructor(e) {
            if (e == null)
              throw new Error("missing ipfs http client");
            this.client = e, this.started = false, this.abortController = new AbortController(), this.httpQueue = new Gg({ concurrency: mCe });
            let { protocol: r, host: n, port: i2 } = e.getEndpointConfig();
            Ed(`enabled DelegatedPeerRouting via ${r}://${n}:${i2}`);
          }
          isStarted() {
            return this.started;
          }
          start() {
            this.started = true;
          }
          stop() {
            this.httpQueue.clear(), this.abortController.abort(), this.abortController = new AbortController(), this.started = false;
          }
          async findPeer(e, r = {}) {
            Ed("findPeer starts: %p", e), r.timeout = r.timeout ?? Tre, r.signal = (0, tP.default)([this.abortController.signal].concat(r.signal != null ? [r.signal] : []));
            let n = Ar(), i2 = Ar();
            this.httpQueue.add(async () => (n.resolve(), await i2.promise));
            try {
              await n.promise;
              for await (let o of this.client.dht.findPeer(e, r))
                if (o.name === "FINAL_PEER")
                  return { id: o.peer.id, multiaddrs: o.peer.multiaddrs.map((a) => new j(a.toString())), protocols: [] };
            } catch (o) {
              throw Ed.error("findPeer errored: %o", o), o;
            } finally {
              i2.resolve(), Ed("findPeer finished: %p", e);
            }
            throw (0, Ire.default)(new Error("Not found"), "ERR_NOT_FOUND");
          }
          async *getClosestPeers(e, r = {}) {
            let n, i2 = I.asCID(e);
            i2 != null ? n = i2 : n = Ir(e), Ed("getClosestPeers starts: %s", n), r.timeout = r.timeout ?? Tre, r.signal = (0, tP.default)([this.abortController.signal].concat(r.signal != null ? [r.signal] : []));
            let o = Ar(), s = Ar();
            this.httpQueue.add(async () => (o.resolve(), await s.promise));
            try {
              await o.promise;
              for await (let a of this.client.dht.query(n, r))
                a.name === "PEER_RESPONSE" && (yield* a.closer.map((u) => ({ id: u.id, multiaddrs: u.multiaddrs.map((l) => new j(l.toString())), protocols: [] })));
            } catch (a) {
              throw Ed.error("getClosestPeers errored:", a), a;
            } finally {
              s.resolve(), Ed("getClosestPeers finished: %b", e);
            }
          }
        };
        c();
        var sP = w(Ci(), 1);
        c();
        var Lre = w(Xu(), 1);
        c();
        c();
        function rP(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var bd = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, cu, Wg = class {
          constructor() {
            cu.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && bd(this, cu, "f")[this.size - 1].priority >= r.priority) {
              bd(this, cu, "f").push(n);
              return;
            }
            let i2 = rP(bd(this, cu, "f"), n, (o, s) => s.priority - o.priority);
            bd(this, cu, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = bd(this, cu, "f").shift();
            return e?.run;
          }
          filter(e) {
            return bd(this, cu, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return bd(this, cu, "f").length;
          }
        };
        cu = /* @__PURE__ */ new WeakMap();
        var rr = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, _e = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, jn, Yg, Qg, uf, cb, Xg, ib, ea, jg, xo, ob, Ro, Zg, cf, k1, N1, _d, sb, Cre, Pre, Ore, Dre, kre, Nre, ab, nP, iP, ub, lb = () => {
        }, yCe = new hi(), oP = class extends Error {
        }, O1 = class extends Lre.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), jn.add(this), Yg.set(this, void 0), Qg.set(this, void 0), uf.set(this, 0), cb.set(this, void 0), Xg.set(this, void 0), ib.set(this, 0), ea.set(this, void 0), jg.set(this, void 0), xo.set(this, void 0), ob.set(this, void 0), Ro.set(this, 0), Zg.set(this, void 0), cf.set(this, void 0), k1.set(this, lb), N1.set(this, lb), _d.set(this, void 0), sb.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: Wg, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            rr(this, Yg, e.carryoverConcurrencyCount, "f"), rr(this, Qg, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), rr(this, cb, e.intervalCap, "f"), rr(this, Xg, e.interval, "f"), rr(this, xo, new e.queueClass(), "f"), rr(this, ob, e.queueClass, "f"), this.concurrency = e.concurrency, rr(this, _d, e.timeout, "f"), rr(this, sb, e.throwOnTimeout === true, "f"), rr(this, cf, e.autoStart === false, "f");
          }
          get concurrency() {
            return _e(this, Zg, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            rr(this, Zg, e, "f"), _e(this, jn, "m", ub).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                rr(this, Ro, (a = _e(this, Ro, "f"), a++, a), "f"), rr(this, uf, (u = _e(this, uf, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new oP("The task was aborted."));
                    return;
                  }
                  let f = await (_e(this, _d, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? _e(this, _d, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? _e(this, sb, "f") : r.throwOnTimeout) && i2(yCe);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                _e(this, jn, "m", Ore).call(this);
              };
              _e(this, xo, "f").enqueue(o, r), _e(this, jn, "m", ab).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return _e(this, cf, "f") ? (rr(this, cf, false, "f"), _e(this, jn, "m", ub).call(this), this) : this;
          }
          pause() {
            rr(this, cf, true, "f");
          }
          clear() {
            rr(this, xo, new (_e(this, ob, "f"))(), "f");
          }
          async onEmpty() {
            if (_e(this, xo, "f").size !== 0)
              return new Promise((e) => {
                let r = _e(this, k1, "f");
                rr(this, k1, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(_e(this, xo, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  _e(this, xo, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(_e(this, Ro, "f") === 0 && _e(this, xo, "f").size === 0))
              return new Promise((e) => {
                let r = _e(this, N1, "f");
                rr(this, N1, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return _e(this, xo, "f").size;
          }
          sizeBy(e) {
            return _e(this, xo, "f").filter(e).length;
          }
          get pending() {
            return _e(this, Ro, "f");
          }
          get isPaused() {
            return _e(this, cf, "f");
          }
          get timeout() {
            return _e(this, _d, "f");
          }
          set timeout(e) {
            rr(this, _d, e, "f");
          }
        };
        Yg = /* @__PURE__ */ new WeakMap(), Qg = /* @__PURE__ */ new WeakMap(), uf = /* @__PURE__ */ new WeakMap(), cb = /* @__PURE__ */ new WeakMap(), Xg = /* @__PURE__ */ new WeakMap(), ib = /* @__PURE__ */ new WeakMap(), ea = /* @__PURE__ */ new WeakMap(), jg = /* @__PURE__ */ new WeakMap(), xo = /* @__PURE__ */ new WeakMap(), ob = /* @__PURE__ */ new WeakMap(), Ro = /* @__PURE__ */ new WeakMap(), Zg = /* @__PURE__ */ new WeakMap(), cf = /* @__PURE__ */ new WeakMap(), k1 = /* @__PURE__ */ new WeakMap(), N1 = /* @__PURE__ */ new WeakMap(), _d = /* @__PURE__ */ new WeakMap(), sb = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakSet(), Cre = function() {
          return _e(this, Qg, "f") || _e(this, uf, "f") < _e(this, cb, "f");
        }, Pre = function() {
          return _e(this, Ro, "f") < _e(this, Zg, "f");
        }, Ore = function() {
          var e;
          rr(this, Ro, (e = _e(this, Ro, "f"), e--, e), "f"), _e(this, jn, "m", ab).call(this), this.emit("next");
        }, Dre = function() {
          _e(this, k1, "f").call(this), rr(this, k1, lb, "f"), _e(this, Ro, "f") === 0 && (_e(this, N1, "f").call(this), rr(this, N1, lb, "f"), this.emit("idle"));
        }, kre = function() {
          _e(this, jn, "m", iP).call(this), _e(this, jn, "m", nP).call(this), rr(this, jg, void 0, "f");
        }, Nre = function() {
          let e = Date.now();
          if (_e(this, ea, "f") === void 0) {
            let r = _e(this, ib, "f") - e;
            if (r < 0)
              rr(this, uf, _e(this, Yg, "f") ? _e(this, Ro, "f") : 0, "f");
            else
              return _e(this, jg, "f") === void 0 && rr(this, jg, setTimeout(() => {
                _e(this, jn, "m", kre).call(this);
              }, r), "f"), true;
          }
          return false;
        }, ab = function() {
          if (_e(this, xo, "f").size === 0)
            return _e(this, ea, "f") && clearInterval(_e(this, ea, "f")), rr(this, ea, void 0, "f"), _e(this, jn, "m", Dre).call(this), false;
          if (!_e(this, cf, "f")) {
            let e = !_e(this, jn, "m", Nre).call(this);
            if (_e(this, jn, "a", Cre) && _e(this, jn, "a", Pre)) {
              let r = _e(this, xo, "f").dequeue();
              return r ? (this.emit("active"), r(), e && _e(this, jn, "m", nP).call(this), true) : false;
            }
          }
          return false;
        }, nP = function() {
          _e(this, Qg, "f") || _e(this, ea, "f") !== void 0 || (rr(this, ea, setInterval(() => {
            _e(this, jn, "m", iP).call(this);
          }, _e(this, Xg, "f")), "f"), rr(this, ib, Date.now() + _e(this, Xg, "f"), "f"));
        }, iP = function() {
          _e(this, uf, "f") === 0 && _e(this, Ro, "f") === 0 && _e(this, ea, "f") && (clearInterval(_e(this, ea, "f")), rr(this, ea, void 0, "f")), rr(this, uf, _e(this, Yg, "f") ? _e(this, Ro, "f") : 0, "f"), _e(this, jn, "m", ub).call(this);
        }, ub = function() {
          for (; _e(this, jn, "m", ab).call(this); )
            ;
        };
        var Bre = w(K(), 1), Jg = w(Vi(), 1), ec = C("libp2p:delegated-content-routing"), fb = 3e4, gCe = 4, wCe = 2, hb = class {
          constructor(e) {
            if (e == null)
              throw new Error("missing ipfs http client");
            this.client = e, this.started = false, this.abortController = new AbortController(), this.httpQueue = new O1({ concurrency: gCe }), this.httpQueueRefs = new O1({ concurrency: wCe });
            let { protocol: r, host: n, port: i2 } = e.getEndpointConfig();
            ec(`enabled DelegatedContentRouting via ${r}://${n}:${i2}`);
          }
          isStarted() {
            return this.started;
          }
          start() {
            this.started = true;
          }
          stop() {
            this.httpQueue.clear(), this.httpQueueRefs.clear(), this.abortController.abort(), this.abortController = new AbortController(), this.started = false;
          }
          async *findProviders(e, r = {}) {
            ec("findProviders starts: %c", e), r.timeout = r.timeout ?? fb, r.signal = (0, Jg.default)([this.abortController.signal].concat(r.signal != null ? [r.signal] : []));
            let n = Ar(), i2 = Ar();
            this.httpQueue.add(async () => (n.resolve(), await i2.promise));
            try {
              await n.promise;
              for await (let o of this.client.dht.findProvs(e, r))
                o.name === "PROVIDER" && (yield* o.providers.map((s) => ({ id: s.id, protocols: [], multiaddrs: s.multiaddrs.map((u) => new j(u.toString())) })));
            } catch (o) {
              throw ec.error("findProviders errored:", o), o;
            } finally {
              i2.resolve(), ec("findProviders finished: %c", e);
            }
          }
          async provide(e, r = {}) {
            ec("provide starts: %c", e), r.timeout = r.timeout ?? fb, r.signal = (0, Jg.default)([this.abortController.signal].concat(r.signal != null ? [r.signal] : [])), await this.httpQueueRefs.add(async () => {
              await this.client.block.stat(e, r), await (0, sP.default)(this.client.dht.provide(e, r));
            }), ec("provide finished: %c", e);
          }
          async put(e, r, n = {}) {
            ec("put value start: %b", e), n.timeout = n.timeout ?? fb, n.signal = (0, Jg.default)([this.abortController.signal].concat(n.signal != null ? [n.signal] : [])), await this.httpQueue.add(async () => {
              await (0, sP.default)(this.client.dht.put(e, r, n));
            }), ec("put value finished: %b", e);
          }
          async get(e, r = {}) {
            return ec("get value start: %b", e), r.timeout = r.timeout ?? fb, r.signal = (0, Jg.default)([this.abortController.signal].concat(r.signal != null ? [r.signal] : [])), await this.httpQueue.add(async () => {
              for await (let n of this.client.dht.get(e, r))
                if (n.name === "VALUE")
                  return ec("get value finished: %b", e), n.value;
              throw (0, Bre.default)(new Error("Not found"), "ERR_NOT_FOUND");
            });
          }
        };
        c();
        c();
        var ECe = (t) => Promise.reject(new Error(`No base found for "${t}"`)), L1 = class {
          constructor(e) {
            this._basesByName = {}, this._basesByPrefix = {}, this._loadBase = e.loadBase || ECe;
            for (let r of e.bases)
              this.addBase(r);
          }
          addBase(e) {
            if (this._basesByName[e.name] || this._basesByPrefix[e.prefix])
              throw new Error(`Codec already exists for codec "${e.name}"`);
            this._basesByName[e.name] = e, this._basesByPrefix[e.prefix] = e;
          }
          removeBase(e) {
            delete this._basesByName[e.name], delete this._basesByPrefix[e.prefix];
          }
          async getBase(e) {
            if (this._basesByName[e])
              return this._basesByName[e];
            if (this._basesByPrefix[e])
              return this._basesByPrefix[e];
            let r = await this._loadBase(e);
            return this._basesByName[r.name] == null && this._basesByPrefix[r.prefix] == null && this.addBase(r), r;
          }
          listBases() {
            return Object.values(this._basesByName);
          }
        };
        c();
        var bCe = (t) => Promise.reject(new Error(`No codec found for "${t}"`)), B1 = class {
          constructor(e) {
            this._codecsByName = {}, this._codecsByCode = {}, this._loadCodec = e.loadCodec || bCe;
            for (let r of e.codecs)
              this.addCodec(r);
          }
          addCodec(e) {
            if (this._codecsByName[e.name] || this._codecsByCode[e.code])
              throw new Error(`Resolver already exists for codec "${e.name}"`);
            this._codecsByName[e.name] = e, this._codecsByCode[e.code] = e;
          }
          removeCodec(e) {
            delete this._codecsByName[e.name], delete this._codecsByCode[e.code];
          }
          async getCodec(e) {
            let r = typeof e == "string" ? this._codecsByName : this._codecsByCode;
            if (r[e])
              return r[e];
            let n = await this._loadCodec(e);
            return r[e] == null && this.addCodec(n), n;
          }
          listCodecs() {
            return Object.values(this._codecsByName);
          }
        };
        c();
        var _Ce = (t) => Promise.reject(new Error(`No hasher found for "${t}"`)), M1 = class {
          constructor(e) {
            this._hashersByName = {}, this._hashersByCode = {}, this._loadHasher = e.loadHasher || _Ce;
            for (let r of e.hashers)
              this.addHasher(r);
          }
          addHasher(e) {
            if (this._hashersByName[e.name] || this._hashersByCode[e.code])
              throw new Error(`Resolver already exists for codec "${e.name}"`);
            this._hashersByName[e.name] = e, this._hashersByCode[e.code] = e;
          }
          removeHasher(e) {
            delete this._hashersByName[e.name], delete this._hashersByCode[e.code];
          }
          async getHasher(e) {
            let r = typeof e == "string" ? this._hashersByName : this._hashersByCode;
            if (r[e])
              return r[e];
            let n = await this._loadHasher(e);
            return r[e] == null && this.addHasher(n), n;
          }
          listHashers() {
            return Object.values(this._hashersByName);
          }
        };
        var ePe = w(Z9(), 1);
        va();
        o2();
        c();
        c();
        te();
        c();
        c();
        var tc = w($7(), 1);
        var vd = w(Vp(), 1);
        c();
        function aP(t) {
          try {
            t = L0(new j(t));
          } catch {
          }
          return t = t.toString(), t;
        }
        c();
        var Mre = () => {
        };
        var Ure = C("ipfs-http-client:lib:error-handler"), vCe = Ze.bind({ ignoreUndefined: true }), SCe = tc.isBrowser || tc.isWebWorker ? location.protocol : "http", xCe = tc.isBrowser || tc.isWebWorker ? location.hostname : "localhost", RCe = tc.isBrowser || tc.isWebWorker ? location.port : "5001", ACe = (t = {}) => {
          let e, r = {}, n;
          if (typeof t == "string" || j.isMultiaddr(t))
            e = new URL(aP(t));
          else if (t instanceof URL)
            e = t;
          else if (typeof t.url == "string" || j.isMultiaddr(t.url))
            e = new URL(aP(t.url)), r = t;
          else if (t.url instanceof URL)
            e = t.url, r = t;
          else {
            r = t || {};
            let i2 = (r.protocol || SCe).replace(":", ""), o = (r.host || xCe).split(":")[0], s = r.port || RCe;
            e = new URL(`${i2}://${o}:${s}`);
          }
          if (r.apiPath ? e.pathname = r.apiPath : (e.pathname === "/" || e.pathname === void 0) && (e.pathname = "api/v0"), tc.isNode) {
            let i2 = Mre(e);
            n = r.agent || new i2({ keepAlive: true, maxSockets: 6 });
          }
          return { ...r, host: e.host, protocol: e.protocol.replace(":", ""), port: Number(e.port), apiPath: e.pathname, url: e, agent: n };
        }, TCe = async (t) => {
          let e;
          try {
            if ((t.headers.get("Content-Type") || "").startsWith("application/json")) {
              let n = await t.json();
              Ure(n), e = n.Message || n.message;
            } else
              e = await t.text();
          } catch (n) {
            Ure("Failed to parse error response", n), e = n.message;
          }
          let r = new vd.default.HTTPError(t);
          throw e && (e.includes("deadline has elapsed") && (r = new vd.default.TimeoutError()), e && e.includes("context deadline exceeded") && (r = new vd.default.TimeoutError())), e && e.includes("request timed out") && (r = new vd.default.TimeoutError()), e && (r.message = e), r;
        }, ICe = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g, Fre = (t) => t.replace(ICe, function(e) {
          return "-" + e.toLowerCase();
        }), CCe = (t) => typeof t == "string" ? ju(t) : t, lf = class extends vd.default {
          constructor(e = {}) {
            let r = ACe(e);
            super({ timeout: CCe(r.timeout || 0) || void 0, headers: r.headers, base: `${r.url}`, handleError: TCe, transformSearchParams: (i2) => {
              let o = new URLSearchParams();
              for (let [s, a] of i2)
                a !== "undefined" && a !== "null" && s !== "signal" && o.append(Fre(s), a), s === "timeout" && !isNaN(a) && o.append(Fre(s), a);
              return o;
            }, agent: r.agent }), delete this.get, delete this.put, delete this.delete, delete this.options;
            let n = this.fetch;
            this.fetch = (i2, o = {}) => (typeof i2 == "string" && !i2.startsWith("/") && (i2 = `${r.url}/${i2}`), n.call(this, i2, vCe(o, { method: "POST" })));
          }
        }, tpt = vd.default.HTTPError;
        var P = (t) => (e) => t(new lf(e), e);
        c();
        c();
        function db(t) {
          if (t != null)
            return typeof t == "string" ? t : t.toString(8).padStart(4, "0");
        }
        c();
        var Kre = w(K(), 1);
        function pb(t) {
          if (t == null)
            return;
          let e;
          if (t.secs != null && (e = { secs: t.secs, nsecs: t.nsecs }), t.Seconds != null && (e = { secs: t.Seconds, nsecs: t.FractionalNanoseconds }), Array.isArray(t) && (e = { secs: t[0], nsecs: t[1] }), t instanceof Date) {
            let r = t.getTime(), n = Math.floor(r / 1e3);
            e = { secs: n, nsecs: (r - n * 1e3) * 1e3 };
          }
          if (!!Object.prototype.hasOwnProperty.call(e, "secs")) {
            if (e != null && e.nsecs != null && (e.nsecs < 0 || e.nsecs > 999999999))
              throw (0, Kre.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
            return e;
          }
        }
        function k({ arg: t, searchParams: e, hashAlg: r, mtime: n, mode: i2, ...o } = {}) {
          e && (o = { ...o, ...e }), r && (o.hash = r), n != null && (n = pb(n), o.mtime = n.secs, o.mtimeNsecs = n.nsecs), i2 != null && (o.mode = db(i2)), o.timeout && !isNaN(o.timeout) && (o.timeout = `${o.timeout}ms`), t == null ? t = [] : Array.isArray(t) || (t = [t]);
          let s = new URLSearchParams(o);
          return t.forEach((a) => s.append("arg", a)), s;
        }
        var Vre = P((t) => {
          async function e(r = {}) {
            return ((await (await t.post("bitswap/wantlist", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).Keys || []).map((i2) => I.parse(i2["/"]));
          }
          return e;
        });
        c();
        te();
        var qre = P((t) => {
          async function e(r, n = {}) {
            return ((await (await t.post("bitswap/wantlist", { signal: n.signal, searchParams: k({ ...n, peer: r.toString() }), headers: n.headers })).json()).Keys || []).map((o) => I.parse(o["/"]));
          }
          return e;
        });
        c();
        te();
        var mb = P((t) => {
          async function e(r = {}) {
            let n = await t.post("bitswap/stat", { searchParams: k(r), signal: r.signal, headers: r.headers });
            return PCe(await n.json());
          }
          return e;
        });
        function PCe(t) {
          return { provideBufLen: t.ProvideBufLen, wantlist: (t.Wantlist || []).map((e) => I.parse(e["/"])), peers: (t.Peers || []).map((e) => ue(e)), blocksReceived: BigInt(t.BlocksReceived), dataReceived: BigInt(t.DataReceived), blocksSent: BigInt(t.BlocksSent), dataSent: BigInt(t.DataSent), dupBlksReceived: BigInt(t.DupBlksReceived), dupDataReceived: BigInt(t.DupDataReceived) };
        }
        c();
        var zre = P((t) => {
          async function e(r, n = {}) {
            return (await t.post("bitswap/unwant", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers })).json();
          }
          return e;
        });
        function Hre(t) {
          return { wantlist: Vre(t), wantlistForPeer: qre(t), unwant: zre(t), stat: mb(t) };
        }
        c();
        c();
        var yb = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("block/get", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers });
            return new Uint8Array(await i2.arrayBuffer());
          }
          return e;
        });
        c();
        te();
        c();
        c();
        c();
        var Gre = w(K(), 1), Wre = w(S0(), 1), jre = w(v0(), 1), Yre = w(Vs(), 1);
        async function Qre(t) {
          if (Jo(t))
            return new Blob([t]);
          if (typeof t == "string" || t instanceof String)
            return new Blob([t.toString()]);
          if (Vc(t))
            return t;
          if (qc(t) && (t = (0, jre.default)(t)), Symbol.iterator in t || Symbol.asyncIterator in t) {
            let e = (0, Wre.default)(t), { value: r, done: n } = await e.peek();
            if (n)
              return $re(e);
            if (e.push(r), Number.isInteger(r))
              return new Blob([Uint8Array.from(await (0, Yre.default)(e))]);
            if (Jo(r) || typeof r == "string" || r instanceof String)
              return $re(e);
          }
          throw (0, Gre.default)(new Error(`Unexpected input: ${t}`), "ERR_UNEXPECTED_INPUT");
        }
        async function $re(t) {
          let e = [];
          for await (let r of t)
            e.push(r);
          return new Blob(e);
        }
        function Xre(t) {
          return w5(t, Qre, true);
        }
        c();
        function Zre(t) {
          if (t != null)
            return typeof t == "string" ? t : t.toString(8).padStart(4, "0");
        }
        async function En(t, e, r = {}) {
          let n = [], i2 = new FormData(), o = 0, s = 0;
          for await (let { content: a, path: u, mode: l, mtime: f } of Xre(t)) {
            let h = "", p = a ? "file" : "dir";
            o > 0 && (h = `-${o}`);
            let d = p + h, m = [];
            if (l != null && m.push(`mode=${Zre(l)}`), f != null) {
              let { secs: y, nsecs: g } = f;
              m.push(`mtime=${y}`), g != null && m.push(`mtime-nsecs=${g}`);
            }
            if (m.length && (d = `${d}?${m.join("&")}`), a) {
              i2.set(d, a, u != null ? encodeURIComponent(u) : void 0);
              let y = s + a.size;
              n.push({ name: u, start: s, end: y }), s = y;
            } else if (u != null)
              i2.set(d, new File([""], encodeURIComponent(u), { type: "application/x-directory" }));
            else
              throw new Error("path or content or both must be set");
            o++;
          }
          return { total: s, parts: n, headers: r, body: i2 };
        }
        c();
        var Jre = w(Vi(), 1);
        function DCe(t) {
          return t.filter(Boolean);
        }
        function bn(...t) {
          return (0, Jre.anySignal)(DCe(t));
        }
        var ene = P((t) => {
          async function e(r, n = {}) {
            let i2 = new AbortController(), o = bn(i2.signal, n.signal), s;
            try {
              s = await (await t.post("block/put", { signal: o, searchParams: k(n), ...await En([r], i2, n.headers) })).json();
            } catch (a) {
              if (n.format === "dag-pb")
                return e(r, { ...n, format: "protobuf" });
              if (n.format === "dag-cbor")
                return e(r, { ...n, format: "cbor" });
              throw a;
            }
            return I.parse(s.Key);
          }
          return e;
        });
        c();
        te();
        var tne = P((t) => {
          async function* e(r, n = {}) {
            Array.isArray(r) || (r = [r]);
            let i2 = await t.post("block/rm", { signal: n.signal, searchParams: k({ arg: r.map((o) => o.toString()), "stream-channels": true, ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield kCe(o);
          }
          return e;
        });
        function kCe(t) {
          let e = { cid: I.parse(t.Hash) };
          return t.Error && (e.error = new Error(t.Error)), e;
        }
        c();
        te();
        var rne = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("block/stat", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers })).json();
            return { cid: I.parse(o.Key), size: o.Size };
          }
          return e;
        });
        function nne(t) {
          return { get: yb(t), put: ene(t), rm: tne(t), stat: rne(t) };
        }
        c();
        c();
        var ine = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("bootstrap/add", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), { Peers: o } = await i2.json();
            return { Peers: o.map((s) => new j(s)) };
          }
          return e;
        });
        c();
        var one = P((t) => {
          async function e(r = {}) {
            let n = await t.post("bootstrap/rm", { signal: r.signal, searchParams: k({ ...r, all: true }), headers: r.headers }), { Peers: i2 } = await n.json();
            return { Peers: i2.map((o) => new j(o)) };
          }
          return e;
        });
        c();
        var sne = P((t) => {
          async function e(r = {}) {
            let n = await t.post("bootstrap/list", { signal: r.signal, searchParams: k(r), headers: r.headers }), { Peers: i2 } = await n.json();
            return { Peers: i2.map((o) => new j(o)) };
          }
          return e;
        });
        c();
        var ane = P((t) => {
          async function e(r = {}) {
            let n = await t.post("bootstrap/add", { signal: r.signal, searchParams: k({ ...r, default: true }), headers: r.headers }), { Peers: i2 } = await n.json();
            return { Peers: i2.map((o) => new j(o)) };
          }
          return e;
        });
        c();
        var cne = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("bootstrap/rm", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), { Peers: o } = await i2.json();
            return { Peers: o.map((s) => new j(s)) };
          }
          return e;
        });
        function une(t) {
          return { add: ine(t), clear: one(t), list: sne(t), reset: ane(t), rm: cne(t) };
        }
        c();
        c();
        c();
        var lne = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("config/profile/apply", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json();
            return { original: o.OldCfg, updated: o.NewCfg };
          }
          return e;
        });
        c();
        c();
        function St(t) {
          if (t == null)
            return t;
          let e = /^[A-Z]+$/, r = {};
          return Object.keys(t).reduce((n, i2) => (e.test(i2) ? n[i2.toLowerCase()] = t[i2] : e.test(i2[0]) ? n[i2[0].toLowerCase() + i2.slice(1)] = t[i2] : n[i2] = t[i2], n), r);
        }
        var fne = P((t) => {
          async function e(r = {}) {
            return (await (await t.post("config/profile/list", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).map((o) => St(o));
          }
          return e;
        });
        function hne(t) {
          return { apply: lne(t), list: fne(t) };
        }
        c();
        var dne = P((t) => async (r, n = {}) => {
          if (!r)
            throw new Error("key argument is required");
          return (await (await t.post("config", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json()).Value;
        });
        c();
        var pne = P((t) => async (r = {}) => await (await t.post("config/show", { signal: r.signal, searchParams: k({ ...r }), headers: r.headers })).json());
        c();
        Re();
        var mne = P((t) => async (r, n = {}) => {
          let i2 = new AbortController(), o = bn(i2.signal, n.signal);
          await (await t.post("config/replace", { signal: o, searchParams: k(n), ...await En([U(JSON.stringify(r))], i2, n.headers) })).text();
        });
        c();
        var yne = P((t) => async (r, n, i2 = {}) => {
          if (typeof r != "string")
            throw new Error("Invalid key type");
          let o = { ...i2, ...NCe(r, n) };
          await (await t.post("config", { signal: i2.signal, searchParams: k(o), headers: i2.headers })).text();
        }), NCe = (t, e) => {
          switch (typeof e) {
            case "boolean":
              return { arg: [t, e.toString()], bool: true };
            case "string":
              return { arg: [t, e] };
            default:
              return { arg: [t, JSON.stringify(e)], json: true };
          }
        };
        function gne(t) {
          return { getAll: pne(t), get: dne(t), set: yne(t), replace: mne(t), profiles: hne(t) };
        }
        c();
        c();
        var wne = P((t) => {
          async function* e(r, n = {}) {
            yield* (await t.post("dag/export", { signal: n.signal, searchParams: k({ arg: r.toString() }), headers: n.headers })).iterator();
          }
          return e;
        });
        c();
        c();
        te();
        var cP = w(K(), 1);
        async function* uP(t, e, r, n, i2) {
          let o = async (l) => {
            let f = await r.getCodec(l.code), h = await n(l, i2);
            return f.decode(h);
          }, s = e.split("/").filter(Boolean), a = await o(t), u = t;
          for (; s.length; ) {
            let l = s.shift();
            if (!l)
              throw (0, cP.default)(new Error(`Could not resolve path "${e}"`), "ERR_INVALID_PATH");
            if (Object.prototype.hasOwnProperty.call(a, l))
              a = a[l], yield { value: a, remainderPath: s.join("/") };
            else
              throw (0, cP.default)(new Error(`no link named "${l}" under ${u}`), "ERR_NO_LINK");
            let f = I.asCID(a);
            f && (u = f, a = await o(a));
          }
          yield { value: a, remainderPath: "" };
        }
        var Ene = w(Gc(), 1), bne = w(qi(), 1), _ne = w(K(), 1);
        var vne = (t, e) => P((n, i2) => {
          let o = yb(i2);
          return async (a, u = {}) => {
            if (u.path) {
              let d = u.localResolve ? await (0, Ene.default)(uP(a, u.path, t, o, u)) : await (0, bne.default)(uP(a, u.path, t, o, u));
              if (!d)
                throw (0, _ne.default)(new Error("Not found"), "ERR_NOT_FOUND");
              return d;
            }
            let l = await t.getCodec(a.code), f = await o(a, u);
            return { value: l.decode(f), remainderPath: "" };
          };
        })(e);
        c();
        te();
        var Sne = P((t) => {
          async function* e(r, n = {}) {
            let i2 = new AbortController(), o = bn(i2.signal, n.signal), { headers: s, body: a } = await En(r, i2, n.headers), u = await t.post("dag/import", { signal: o, headers: s, body: a, searchParams: k({ "pin-roots": n.pinRoots }) });
            for await (let { Root: l } of u.ndjson())
              if (l !== void 0) {
                let { Cid: { "/": f }, PinErrorMsg: h } = l;
                yield { root: { cid: I.parse(f), pinErrorMsg: h } };
              }
          }
          return e;
        });
        c();
        te();
        var gb = (t, e) => P((n) => async (o, s = {}) => {
          let a = { storeCodec: "dag-cbor", hashAlg: "sha2-256", ...s }, u;
          if (a.inputCodec) {
            if (!(o instanceof Uint8Array))
              throw new Error("Can only inputCodec on raw bytes that can be decoded");
            u = o;
          } else
            u = (await t.getCodec(a.storeCodec)).encode(o), a.inputCodec = a.storeCodec;
          let l = new AbortController(), f = bn(l.signal, a.signal), p = await (await n.post("dag/put", { timeout: a.timeout, signal: f, searchParams: k(a), ...await En([u], l, a.headers) })).json();
          return I.parse(p.Cid["/"]);
        })(e);
        c();
        te();
        var xne = P((t) => async (r, n = {}) => {
          let o = await (await t.post("dag/resolve", { signal: n.signal, searchParams: k({ arg: `${r}${n.path ? `/${n.path}`.replace(/\/[/]+/g, "/") : ""}`, ...n }), headers: n.headers })).json();
          return { cid: I.parse(o.Cid["/"]), remainderPath: o.RemPath };
        });
        function Rne(t, e) {
          return { export: wne(e), get: vne(t, e), import: Sne(e), put: gb(t, e), resolve: xne(e) };
        }
        c();
        c();
        c();
        Re();
        c();
        var ls = (t) => {
          if (t.Type === 0)
            return { name: "SENDING_QUERY", type: t.Type };
          if (t.Type === 1)
            return { from: ue(t.ID), name: "PEER_RESPONSE", type: t.Type, messageType: 0, messageName: "PUT_VALUE", closer: (t.Responses || []).map(({ ID: e, Addrs: r }) => ({ id: ue(e), multiaddrs: r.map((n) => new j(n)), protocols: [] })), providers: (t.Responses || []).map(({ ID: e, Addrs: r }) => ({ id: ue(e), multiaddrs: r.map((n) => new j(n)), protocols: [] })) };
          if (t.Type === 2) {
            let e = { id: t.ID ?? ue(t.ID), multiaddrs: [], protocols: [] };
            return t.Responses && t.Responses.length && (e = { id: ue(t.Responses[0].ID), multiaddrs: t.Responses[0].Addrs.map((r) => new j(r)), protocols: [] }), { name: "FINAL_PEER", type: t.Type, peer: e };
          }
          if (t.Type === 3)
            return { name: "QUERY_ERROR", type: t.Type, error: new Error(t.Extra) };
          if (t.Type === 4)
            return { name: "PROVIDER", type: t.Type, providers: t.Responses.map(({ ID: e, Addrs: r }) => ({ id: ue(e), multiaddrs: r.map((n) => new j(n)), protocols: [] })) };
          if (t.Type === 5)
            return { name: "VALUE", type: t.Type, value: U(t.Extra, "base64pad") };
          if (t.Type === 6) {
            let e = t.Responses.map(({ ID: r }) => ue(r));
            if (!e.length)
              throw new Error("No peer found");
            return { name: "ADDING_PEER", type: t.Type, peer: e[0] };
          }
          if (t.Type === 7)
            return { name: "DIALING_PEER", type: t.Type, peer: ue(t.ID) };
          throw new Error("Unknown DHT event type");
        };
        var Ane = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("dht/findpeer", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield ls(o);
          }
          return e;
        });
        c();
        var Tne = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("dht/findprovs", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield ls(o);
          }
          return e;
        });
        c();
        me();
        var Ine = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("dht/get", { signal: n.signal, searchParams: k({ arg: r instanceof Uint8Array ? M(r) : r.toString(), ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield ls(o);
          }
          return e;
        });
        c();
        var Cne = P((t) => {
          async function* e(r, n = { recursive: false }) {
            let i2 = Array.isArray(r) ? r : [r], o = await t.post("dht/provide", { signal: n.signal, searchParams: k({ arg: i2.map((s) => s.toString()), ...n }), headers: n.headers });
            for await (let s of o.ndjson())
              yield ls(s);
          }
          return e;
        });
        c();
        me();
        var Pne = P((t) => {
          async function* e(r, n, i2 = {}) {
            let o = new AbortController(), s = bn(o.signal, i2.signal), a = await t.post("dht/put", { signal: s, searchParams: k({ arg: r instanceof Uint8Array ? M(r) : r.toString(), ...i2 }), ...await En([n], o, i2.headers) });
            for await (let u of a.ndjson())
              yield ls(u);
          }
          return e;
        });
        c();
        var Dne = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("dht/query", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield ls(o);
          }
          return e;
        });
        function kne(t) {
          return { findPeer: Ane(t), findProvs: Tne(t), get: Ine(t), provide: Cne(t), put: Pne(t), query: Dne(t) };
        }
        c();
        c();
        var Nne = P((t) => {
          async function e(r = {}) {
            return (await t.post("diag/cmds", { signal: r.signal, searchParams: k(r), headers: r.headers })).json();
          }
          return e;
        });
        c();
        var One = P((t) => {
          async function e(r = {}) {
            return (await t.post("diag/net", { signal: r.signal, searchParams: k(r), headers: r.headers })).json();
          }
          return e;
        });
        c();
        var Lne = P((t) => {
          async function e(r = {}) {
            return (await t.post("diag/sys", { signal: r.signal, searchParams: k(r), headers: r.headers })).json();
          }
          return e;
        });
        function Bne(t) {
          return { cmds: Nne(t), net: One(t), sys: Lne(t) };
        }
        c();
        c();
        var Mne = P((t) => {
          async function e(r, n, i2 = {}) {
            await (await t.post("files/chmod", { signal: i2.signal, searchParams: k({ arg: r, mode: n, ...i2 }), headers: i2.headers })).text();
          }
          return e;
        });
        c();
        te();
        var Une = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = Array.isArray(r) ? r : [r];
            await (await t.post("files/cp", { signal: i2.signal, searchParams: k({ arg: o.concat(n).map((a) => I.asCID(a) ? `/ipfs/${a}` : a), ...i2 }), headers: i2.headers })).text();
          }
          return e;
        });
        c();
        te();
        var Fne = P((t) => {
          async function e(r, n = {}) {
            if (!r || typeof r != "string")
              throw new Error("ipfs.files.flush requires a path");
            let o = await (await t.post("files/flush", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json();
            return I.parse(o.Cid);
          }
          return e;
        });
        c();
        te();
        c();
        function e3(t) {
          let e = St(t);
          return Object.prototype.hasOwnProperty.call(e, "mode") && (e.mode = parseInt(e.mode, 8)), Object.prototype.hasOwnProperty.call(e, "mtime") && (e.mtime = { secs: e.mtime, nsecs: e.mtimeNsecs || 0 }, delete e.mtimeNsecs), e;
        }
        var Vne = P((t) => {
          async function* e(r, n = {}) {
            if (!r)
              throw new Error("ipfs.files.ls requires a path");
            let i2 = await t.post("files/ls", { signal: n.signal, searchParams: k({ arg: I.asCID(r) ? `/ipfs/${r}` : r, long: true, ...n, stream: true }), headers: n.headers });
            for await (let o of i2.ndjson())
              if ("Entries" in o)
                for (let s of o.Entries || [])
                  yield Kne(e3(s));
              else
                yield Kne(e3(o));
          }
          return e;
        });
        function Kne(t) {
          return t.hash && (t.cid = I.parse(t.hash)), delete t.hash, t.type = t.type === 1 ? "directory" : "file", t;
        }
        c();
        var qne = P((t) => {
          async function e(r, n = {}) {
            await (await t.post("files/mkdir", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).text();
          }
          return e;
        });
        c();
        var zne = P((t) => {
          async function e(r, n, i2 = {}) {
            Array.isArray(r) || (r = [r]), await (await t.post("files/mv", { signal: i2.signal, searchParams: k({ arg: r.concat(n), ...i2 }), headers: i2.headers })).text();
          }
          return e;
        });
        c();
        var Gne = w($ne(), 1), Wne = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("files/read", { signal: n.signal, searchParams: k({ arg: r, count: n.length, ...n }), headers: n.headers });
            yield* (0, Gne.default)(i2.body);
          }
          return e;
        });
        c();
        var jne = w(Vp(), 1), Yne = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("files/rm", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), o = await i2.text();
            if (o !== "") {
              let s = new jne.default.HTTPError(i2);
              throw s.message = o, s;
            }
          }
          return e;
        });
        c();
        te();
        var wb = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("files/stat", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json();
            return o.WithLocality = o.WithLocality || false, qCe(e3(o));
          }
          return e;
        });
        function qCe(t) {
          return t.cid = I.parse(t.hash), delete t.hash, t;
        }
        c();
        var Qne = P((t) => {
          async function e(r, n = {}) {
            await (await t.post("files/touch", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).text();
          }
          return e;
        });
        c();
        var Xne = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = new AbortController(), s = bn(o.signal, i2.signal);
            await (await t.post("files/write", { signal: s, searchParams: k({ arg: r, streamChannels: true, count: i2.length, ...i2 }), ...await En([{ content: n, path: "arg", mode: db(i2.mode), mtime: pb(i2.mtime) }], o, i2.headers) })).text();
          }
          return e;
        });
        function Zne(t) {
          return { chmod: Mne(t), cp: Une(t), flush: Fne(t), ls: Vne(t), mkdir: qne(t), mv: zne(t), read: Wne(t), rm: Yne(t), stat: wb(t), touch: Qne(t), write: Xne(t) };
        }
        c();
        c();
        var Jne = w(K(), 1), eie = P((t) => async (r, n, i2 = {}) => {
          throw (0, Jne.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
        });
        c();
        var tie = P((t) => {
          async function e(r, n = { type: "Ed25519" }) {
            let o = await (await t.post("key/gen", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json();
            return St(o);
          }
          return e;
        });
        c();
        var rie = P((t) => {
          async function e(r, n, i2, o = {}) {
            let a = await (await t.post("key/import", { signal: o.signal, searchParams: k({ arg: r, pem: n, password: i2, ...o }), headers: o.headers })).json();
            return St(a);
          }
          return e;
        });
        c();
        var nie = w(K(), 1), iie = P((t) => async (r, n = {}) => {
          throw (0, nie.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
        });
        c();
        var oie = P((t) => {
          async function e(r = {}) {
            return ((await (await t.post("key/list", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).Keys || []).map((o) => St(o));
          }
          return e;
        });
        c();
        var sie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = await t.post("key/rename", { signal: i2.signal, searchParams: k({ arg: [r, n], ...i2 }), headers: i2.headers });
            return St(await o.json());
          }
          return e;
        });
        c();
        var aie = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("key/rm", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json();
            return St(o.Keys[0]);
          }
          return e;
        });
        function cie(t) {
          return { export: eie(t), gen: tie(t), import: rie(t), info: iie(t), list: oie(t), rename: sie(t), rm: aie(t) };
        }
        c();
        c();
        var uie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = await t.post("log/level", { signal: i2.signal, searchParams: k({ arg: [r, n], ...i2 }), headers: i2.headers });
            return St(await o.json());
          }
          return e;
        });
        c();
        var lie = P((t) => {
          async function e(r = {}) {
            return (await (await t.post("log/ls", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).Strings;
          }
          return e;
        });
        c();
        var fie = P((t) => {
          async function* e(r = {}) {
            yield* (await t.post("log/tail", { signal: r.signal, searchParams: k(r), headers: r.headers })).ndjson();
          }
          return e;
        });
        function hie(t) {
          return { level: uie(t), ls: lie(t), tail: fie(t) };
        }
        c();
        c();
        var die = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("name/publish", { signal: n.signal, searchParams: k({ arg: `${r}`, ...n }), headers: n.headers });
            return St(await i2.json());
          }
          return e;
        });
        c();
        var pie = P((t) => {
          async function* e(r, n = {}) {
            let i2 = await t.post("name/resolve", { signal: n.signal, searchParams: k({ arg: r, stream: true, ...n }), headers: n.headers });
            for await (let o of i2.ndjson())
              yield o.Path;
          }
          return e;
        });
        c();
        c();
        var mie = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("name/pubsub/cancel", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers });
            return St(await i2.json());
          }
          return e;
        });
        c();
        var yie = P((t) => {
          async function e(r = {}) {
            let n = await t.post("name/pubsub/state", { signal: r.signal, searchParams: k(r), headers: r.headers });
            return St(await n.json());
          }
          return e;
        });
        c();
        var gie = P((t) => {
          async function e(r = {}) {
            return (await (await t.post("name/pubsub/subs", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).Strings || [];
          }
          return e;
        });
        function wie(t) {
          return { cancel: mie(t), state: yie(t), subs: gie(t) };
        }
        function Eie(t) {
          return { publish: die(t), resolve: pie(t), pubsub: wie(t) };
        }
        c();
        c();
        te();
        var bie = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("object/data", { signal: n.signal, searchParams: k({ arg: `${r instanceof Uint8Array ? I.decode(r) : r}`, ...n }), headers: n.headers })).arrayBuffer();
            return new Uint8Array(o, 0, o.byteLength);
          }
          return e;
        });
        c();
        te();
        Re();
        var _ie = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("object/get", { signal: n.signal, searchParams: k({ arg: `${r instanceof Uint8Array ? I.decode(r) : r}`, dataEncoding: "base64", ...n }), headers: n.headers })).json();
            return { Data: U(o.Data, "base64pad"), Links: (o.Links || []).map((s) => ({ Name: s.Name, Hash: I.parse(s.Hash), Tsize: s.Size })) };
          }
          return e;
        });
        c();
        te();
        var vie = P((t) => {
          async function e(r, n = {}) {
            return ((await (await t.post("object/links", { signal: n.signal, searchParams: k({ arg: `${r instanceof Uint8Array ? I.decode(r) : r}`, ...n }), headers: n.headers })).json()).Links || []).map((s) => ({ Name: s.Name, Tsize: s.Size, Hash: I.parse(s.Hash) }));
          }
          return e;
        });
        c();
        te();
        var Sie = P((t) => {
          async function e(r = {}) {
            let n = await t.post("object/new", { signal: r.signal, searchParams: k({ arg: r.template, ...r }), headers: r.headers }), { Hash: i2 } = await n.json();
            return I.parse(i2);
          }
          return e;
        });
        c();
        var xie = (t, e) => P((n) => {
          let i2 = gb(t, e);
          async function o(s, a = {}) {
            return i2(s, { ...a, storeCodec: "dag-pb", hashAlg: "sha2-256", version: 1 });
          }
          return o;
        })(e);
        c();
        te();
        var Rie = P((t) => {
          async function e(r, n = {}) {
            let o = await (await t.post("object/stat", { signal: n.signal, searchParams: k({ arg: `${r}`, ...n }), headers: n.headers })).json();
            return { ...o, Hash: I.parse(o.Hash) };
          }
          return e;
        });
        c();
        c();
        te();
        var Aie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = await t.post("object/patch/add-link", { signal: i2.signal, searchParams: k({ arg: [`${r}`, n.Name || n.name || "", (n.Hash || n.cid || "").toString() || null], ...i2 }), headers: i2.headers }), { Hash: s } = await o.json();
            return I.parse(s);
          }
          return e;
        });
        c();
        te();
        var Tie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = new AbortController(), s = bn(o.signal, i2.signal), a = await t.post("object/patch/append-data", { signal: s, searchParams: k({ arg: `${r}`, ...i2 }), ...await En([n], o, i2.headers) }), { Hash: u } = await a.json();
            return I.parse(u);
          }
          return e;
        });
        c();
        te();
        var Iie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = await t.post("object/patch/rm-link", { signal: i2.signal, searchParams: k({ arg: [`${r}`, n.Name || n.name || null], ...i2 }), headers: i2.headers }), { Hash: s } = await o.json();
            return I.parse(s);
          }
          return e;
        });
        c();
        te();
        var Cie = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = new AbortController(), s = bn(o.signal, i2.signal), a = await t.post("object/patch/set-data", { signal: s, searchParams: k({ arg: [`${r}`], ...i2 }), ...await En([n], o, i2.headers) }), { Hash: u } = await a.json();
            return I.parse(u);
          }
          return e;
        });
        function Pie(t) {
          return { addLink: Aie(t), appendData: Tie(t), rmLink: Iie(t), setData: Cie(t) };
        }
        function Die(t, e) {
          return { data: bie(e), get: _ie(e), links: vie(e), new: Sie(e), put: xie(t, e), stat: Rie(e), patch: Pie(e) };
        }
        c();
        c();
        te();
        var Eb = P((t) => {
          async function* e(r, n = {}) {
            for await (let { path: i2, recursive: o, metadata: s } of xa(r)) {
              let a = await t.post("pin/add", { signal: n.signal, searchParams: k({ ...n, arg: i2, recursive: o, metadata: s ? JSON.stringify(s) : void 0, stream: true }), headers: n.headers });
              for await (let u of a.ndjson()) {
                if (u.Pins) {
                  for (let l of u.Pins)
                    yield I.parse(l);
                  continue;
                }
                yield I.parse(u);
              }
            }
          }
          return e;
        });
        c();
        var kie = w(qi(), 1);
        function Nie(t) {
          let e = Eb(t);
          return P(() => {
            async function r(n, i2 = {}) {
              return (0, kie.default)(e([{ path: n, ...i2 }], i2));
            }
            return r;
          })(t);
        }
        c();
        te();
        function Oie(t, e, r) {
          let n = { type: t, cid: I.parse(e) };
          return r && (n.metadata = r), n;
        }
        var Lie = P((t) => {
          async function* e(r = {}) {
            let n = [];
            r.paths && (n = Array.isArray(r.paths) ? r.paths : [r.paths]);
            let i2 = await t.post("pin/ls", { signal: r.signal, searchParams: k({ ...r, arg: n.map((o) => `${o}`), stream: true }), headers: r.headers });
            for await (let o of i2.ndjson()) {
              if (o.Keys) {
                for (let s of Object.keys(o.Keys))
                  yield Oie(o.Keys[s].Type, s, o.Keys[s].Metadata);
                return;
              }
              yield Oie(o.Type, o.Cid, o.Metadata);
            }
          }
          return e;
        });
        c();
        te();
        var bb = P((t) => {
          async function* e(r, n = {}) {
            for await (let { path: i2, recursive: o } of xa(r)) {
              let s = new URLSearchParams(n.searchParams);
              s.append("arg", `${i2}`), o != null && s.set("recursive", String(o));
              let a = await t.post("pin/rm", { signal: n.signal, headers: n.headers, searchParams: k({ ...n, arg: `${i2}`, recursive: o }) });
              for await (let u of a.ndjson()) {
                if (u.Pins) {
                  yield* u.Pins.map((l) => I.parse(l));
                  continue;
                }
                yield I.parse(u);
              }
            }
          }
          return e;
        });
        c();
        var Bie = w(qi(), 1);
        var Mie = (t) => {
          let e = bb(t);
          return P(() => {
            async function r(n, i2 = {}) {
              return (0, Bie.default)(e([{ path: n, ...i2 }], i2));
            }
            return r;
          })(t);
        };
        c();
        c();
        c();
        te();
        var _b = ({ Name: t, Status: e, Cid: r }) => ({ cid: I.parse(r), name: t, status: e }), Uie = (t) => {
          if (typeof t == "string" && t !== "")
            return t;
          throw new TypeError("service name must be passed");
        }, Fie = (t) => {
          if (I.asCID(t))
            return t.toString();
          throw new TypeError(`CID instance expected instead of ${typeof t}`);
        }, U1 = ({ service: t, cid: e, name: r, status: n, all: i2 }) => {
          let o = k({ service: Uie(t), name: r, force: i2 ? true : void 0 });
          if (e)
            for (let s of e)
              o.append("cid", Fie(s));
          if (n)
            for (let s of n)
              o.append("status", s);
          return o;
        }, Kie = ({ cid: t, service: e, background: r, name: n, origins: i2 }) => {
          let o = k({ arg: Fie(t), service: Uie(e), name: n, background: r ? true : void 0 });
          if (i2)
            for (let s of i2)
              o.append("origin", s.toString());
          return o;
        };
        function Vie(t) {
          async function e(r, { timeout: n, signal: i2, headers: o, ...s }) {
            let a = await t.post("pin/remote/add", { timeout: n, signal: i2, headers: o, searchParams: Kie({ cid: r, ...s }) });
            return _b(await a.json());
          }
          return e;
        }
        c();
        function qie(t) {
          async function* e({ timeout: r, signal: n, headers: i2, ...o }) {
            let s = await t.post("pin/remote/ls", { timeout: r, signal: n, headers: i2, searchParams: U1(o) });
            for await (let a of s.ndjson())
              yield _b(a);
          }
          return e;
        }
        c();
        function zie(t) {
          async function e({ timeout: r, signal: n, headers: i2, ...o }) {
            await t.post("pin/remote/rm", { timeout: r, signal: n, headers: i2, searchParams: U1({ ...o, all: false }) });
          }
          return e;
        }
        c();
        function Hie(t) {
          async function e({ timeout: r, signal: n, headers: i2, ...o }) {
            await t.post("pin/remote/rm", { timeout: r, signal: n, headers: i2, searchParams: U1({ ...o, all: true }) });
          }
          return e;
        }
        c();
        c();
        c();
        function $ie(t) {
          let e = String(t);
          if (e === "undefined")
            throw Error("endpoint is required");
          return e[e.length - 1] === "/" ? e.slice(0, -1) : e;
        }
        function Gie(t) {
          return { service: t.Service, endpoint: new URL(t.ApiEndpoint), ...t.Stat && { stat: zCe(t.Stat) } };
        }
        function zCe(t) {
          switch (t.Status) {
            case "valid": {
              let { Pinning: e, Pinned: r, Queued: n, Failed: i2 } = t.PinCount;
              return { status: "valid", pinCount: { queued: n, pinning: e, pinned: r, failed: i2 } };
            }
            case "invalid":
              return { status: "invalid" };
            default:
              return { status: t.Status };
          }
        }
        function Wie(t) {
          async function e(r, n) {
            let { endpoint: i2, key: o, headers: s, timeout: a, signal: u } = n;
            await t.post("pin/remote/service/add", { timeout: a, signal: u, searchParams: k({ arg: [r, $ie(i2), o] }), headers: s });
          }
          return e;
        }
        c();
        function jie(t) {
          async function e(r = {}) {
            let { stat: n, headers: i2, timeout: o, signal: s } = r, a = await t.post("pin/remote/service/ls", { timeout: o, signal: s, headers: i2, searchParams: n === true ? k({ stat: n }) : void 0 }), { RemoteServices: u } = await a.json();
            return u.map(Gie);
          }
          return e;
        }
        c();
        function Yie(t) {
          async function e(r, n = {}) {
            await t.post("pin/remote/service/rm", { signal: n.signal, headers: n.headers, searchParams: k({ arg: r }) });
          }
          return e;
        }
        function Qie(t) {
          let e = new lf(t);
          return { add: Wie(e), ls: jie(e), rm: Yie(e) };
        }
        function Xie(t) {
          let e = new lf(t);
          return { add: Vie(e), ls: qie(e), rm: zie(e), rmAll: Hie(e), service: Qie(t) };
        }
        function Zie(t) {
          return { addAll: Eb(t), add: Nie(t), ls: Lie(t), rmAll: bb(t), rm: Mie(t), remote: Xie(t) };
        }
        c();
        c();
        c();
        Re();
        me();
        ma();
        var Jie = (t) => Array.isArray(t) ? t.map(lP) : t, lP = (t) => M(fP(t)), fP = (t) => qm.decode(t), eoe = (t) => BigInt(`0x${M(qm.decode(t), "base16")}`), F1 = (t) => qm.encode(U(t));
        var toe = P((t) => {
          async function e(r = {}) {
            let { Strings: n } = await (await t.post("pubsub/ls", { signal: r.signal, searchParams: k(r), headers: r.headers })).json();
            return Jie(n) || [];
          }
          return e;
        });
        c();
        var roe = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("pubsub/peers", { signal: n.signal, searchParams: k({ arg: F1(r), ...n }), headers: n.headers }), { Strings: o } = await i2.json();
            return o || [];
          }
          return e;
        });
        c();
        var noe = P((t) => {
          async function e(r, n, i2 = {}) {
            let o = k({ arg: F1(r), ...i2 }), s = new AbortController(), a = bn(s.signal, i2.signal);
            await (await t.post("pubsub/pub", { signal: a, searchParams: o, ...await En([n], s, i2.headers) })).text();
          }
          return e;
        });
        c();
        var HCe = C("ipfs-http-client:pubsub:subscribe"), ioe = (t, e) => P((r) => {
          async function n(i2, o, s = {}) {
            s.signal = e.subscribe(i2, o, s.signal);
            let a, u, l = new Promise((h, p) => {
              a = h, u = p;
            }), f = setTimeout(() => a(), 1e3);
            return r.post("pubsub/sub", { signal: s.signal, searchParams: k({ arg: F1(i2), ...s }), headers: s.headers }).catch((h) => {
              e.unsubscribe(i2, o), u(h);
            }).then((h) => {
              clearTimeout(f), h && ($Ce(h, { onMessage: (p) => {
                if (!!o) {
                  if (typeof o == "function") {
                    o(p);
                    return;
                  }
                  typeof o.handleEvent == "function" && o.handleEvent(p);
                }
              }, onEnd: () => e.unsubscribe(i2, o), onError: s.onError }), a());
            }), l;
          }
          return n;
        })(t);
        async function $Ce(t, { onMessage: e, onEnd: r, onError: n }) {
          n = n || HCe;
          try {
            for await (let i2 of t.ndjson())
              try {
                if (!i2.from)
                  continue;
                e({ from: ue(i2.from), data: fP(i2.data), sequenceNumber: eoe(i2.seqno), topic: lP(i2.topicIDs[0]) });
              } catch (o) {
                o.message = `Failed to parse pubsub message: ${o.message}`, n(o, false, i2);
              }
          } catch (i2) {
            GCe(i2) || n(i2, true);
          } finally {
            r();
          }
        }
        var GCe = (t) => {
          switch (t.type) {
            case "aborted":
              return true;
            case "abort":
              return true;
            default:
              return t.name === "AbortError";
          }
        };
        c();
        var ooe = (t, e) => {
          async function r(n, i2) {
            e.unsubscribe(n, i2);
          }
          return r;
        };
        c();
        var vb = class {
          constructor() {
            this._subs = /* @__PURE__ */ new Map();
          }
          subscribe(e, r, n) {
            let i2 = this._subs.get(e) || [];
            if (i2.find((s) => s.handler === r))
              throw new Error(`Already subscribed to ${e} with this handler`);
            let o = new AbortController();
            return this._subs.set(e, [{ handler: r, controller: o }].concat(i2)), n && n.addEventListener("abort", () => this.unsubscribe(e, r)), o.signal;
          }
          unsubscribe(e, r) {
            let n = this._subs.get(e) || [], i2;
            r ? (this._subs.set(e, n.filter((o) => o.handler !== r)), i2 = n.filter((o) => o.handler === r)) : (this._subs.set(e, []), i2 = n), (this._subs.get(e) || []).length || this._subs.delete(e), i2.forEach((o) => o.controller.abort());
          }
        };
        function soe(t) {
          let e = new vb();
          return { ls: toe(t), peers: roe(t), publish: noe(t), subscribe: ioe(t, e), unsubscribe: ooe(t, e) };
        }
        c();
        te();
        c();
        var aoe = P((t) => {
          async function* e(r = {}) {
            yield* (await t.post("refs/local", { signal: r.signal, transform: St, searchParams: k(r), headers: r.headers })).ndjson();
          }
          return e;
        });
        var coe = P((t, e) => Object.assign(async function* (n, i2 = {}) {
          let o = Array.isArray(n) ? n : [n];
          yield* (await t.post("refs", { signal: i2.signal, searchParams: k({ arg: o.map((a) => `${a instanceof Uint8Array ? I.decode(a) : a}`), ...i2 }), headers: i2.headers, transform: St })).ndjson();
        }, { local: aoe(e) }));
        c();
        c();
        te();
        var uoe = P((t) => {
          async function* e(r = {}) {
            yield* (await t.post("repo/gc", { signal: r.signal, searchParams: k(r), headers: r.headers, transform: (i2) => ({ err: i2.Error ? new Error(i2.Error) : null, cid: (i2.Key || {})["/"] ? I.parse(i2.Key["/"]) : null }) })).ndjson();
          }
          return e;
        });
        c();
        var Sb = P((t) => {
          async function e(r = {}) {
            let i2 = await (await t.post("repo/stat", { signal: r.signal, searchParams: k(r), headers: r.headers })).json();
            return { numObjects: BigInt(i2.NumObjects), repoSize: BigInt(i2.RepoSize), repoPath: i2.RepoPath, version: i2.Version, storageMax: BigInt(i2.StorageMax) };
          }
          return e;
        });
        c();
        var loe = P((t) => {
          async function e(r = {}) {
            return (await (await t.post("repo/version", { signal: r.signal, searchParams: k(r), headers: r.headers })).json()).Version;
          }
          return e;
        });
        function foe(t) {
          return { gc: uoe(t), stat: Sb(t), version: loe(t) };
        }
        c();
        c();
        var hoe = P((t) => {
          async function* e(r = {}) {
            yield* (await t.post("stats/bw", { signal: r.signal, searchParams: k(r), headers: r.headers, transform: (i2) => ({ totalIn: BigInt(i2.TotalIn), totalOut: BigInt(i2.TotalOut), rateIn: parseFloat(i2.RateIn), rateOut: parseFloat(i2.RateOut) }) })).ndjson();
          }
          return e;
        });
        function doe(t) {
          return { bitswap: mb(t), repo: Sb(t), bw: hoe(t) };
        }
        c();
        c();
        var poe = P((t) => {
          async function e(r = {}) {
            let n = await t.post("swarm/addrs", { signal: r.signal, searchParams: k(r), headers: r.headers }), { Addrs: i2 } = await n.json();
            return Object.keys(i2).map((o) => ({ id: ue(o), addrs: (i2[o] || []).map((s) => new j(s)) }));
          }
          return e;
        });
        c();
        var moe = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("swarm/connect", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), { Strings: o } = await i2.json();
            return o || [];
          }
          return e;
        });
        c();
        var yoe = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("swarm/disconnect", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), { Strings: o } = await i2.json();
            return o || [];
          }
          return e;
        });
        c();
        var goe = P((t) => {
          async function e(r = {}) {
            let n = await t.post("swarm/addrs/local", { signal: r.signal, searchParams: k(r), headers: r.headers }), { Strings: i2 } = await n.json();
            return (i2 || []).map((o) => new j(o));
          }
          return e;
        });
        c();
        var woe = P((t) => {
          async function e(r = {}) {
            let n = await t.post("swarm/peers", { signal: r.signal, searchParams: k(r), headers: r.headers }), { Peers: i2 } = await n.json();
            return (i2 || []).map((o) => ({ addr: new j(o.Addr), peer: ue(o.Peer), muxer: o.Muxer, latency: o.Latency, streams: o.Streams, direction: o.Direction == null ? void 0 : o.Direction === 0 ? "inbound" : "outbound" }));
          }
          return e;
        });
        function Eoe(t) {
          return { addrs: poe(t), connect: moe(t), disconnect: yoe(t), localAddrs: goe(t), peers: woe(t) };
        }
        c();
        c();
        te();
        var xb = P((t) => {
          async function* e(r, n = {}) {
            let i2 = new AbortController(), o = bn(i2.signal, n.signal), { headers: s, body: a, total: u, parts: l } = await En(r, i2, n.headers), [f, h] = typeof n.progress == "function" ? WCe(u, l, n.progress) : [void 0, void 0], p = await t.post("add", { searchParams: k({ "stream-channels": true, ...n, progress: Boolean(f) }), onUploadProgress: h, signal: o, headers: s, body: a });
            for await (let d of p.ndjson())
              d = St(d), d.hash !== void 0 ? yield YCe(d) : f && f(d.bytes || 0, d.name);
          }
          return e;
        }), WCe = (t, e, r) => e ? [void 0, jCe(t, e, r)] : [r, void 0], jCe = (t, e, r) => {
          let n = 0, i2 = e.length;
          return ({ loaded: o, total: s }) => {
            let a = Math.floor(o / s * t);
            for (; n < i2; ) {
              let { start: u, end: l, name: f } = e[n];
              if (a < l) {
                r(a - u, f);
                break;
              } else
                r(l - u, f), n += 1;
            }
          };
        };
        function YCe({ name: t, hash: e, size: r, mode: n, mtime: i2, mtimeNsecs: o }) {
          let s = { path: t, cid: I.parse(e), size: parseInt(r) };
          return n != null && (s.mode = parseInt(n, 8)), i2 != null && (s.mtime = { secs: i2, nsecs: o || 0 }), s;
        }
        var boe = w(qi(), 1);
        function _oe(t) {
          let e = xb(t);
          return P(() => {
            async function r(n, i2 = {}) {
              return await (0, boe.default)(e(f5(n), i2));
            }
            return r;
          })(t);
        }
        c();
        var voe = P((t) => {
          async function* e(r, n = {}) {
            yield* (await t.post("cat", { signal: n.signal, searchParams: k({ arg: r.toString(), ...n }), headers: n.headers })).iterator();
          }
          return e;
        });
        c();
        var Soe = P((t) => async (r = {}) => (await t.post("commands", { signal: r.signal, searchParams: k(r), headers: r.headers })).json());
        c();
        var xoe = P((t) => async (r, n = {}) => (await (await t.post("dns", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers })).json()).Path);
        c();
        var Roe = P((t) => () => {
          let e = new URL(t.opts.base || "");
          return { host: e.hostname, port: e.port, protocol: e.protocol, pathname: e.pathname, "api-path": e.pathname };
        });
        c();
        te();
        var Aoe = P((t) => {
          async function* e(r, n = {}) {
            let i2 = { arg: `${r instanceof Uint8Array ? I.decode(r) : r}`, ...n };
            i2.compressionLevel && (i2["compression-level"] = i2.compressionLevel, delete i2.compressionLevel), yield* (await t.post("get", { signal: n.signal, searchParams: k(i2), headers: n.headers })).iterator();
          }
          return e;
        });
        c();
        var Rb = P((t) => {
          async function e(r = {}) {
            let i2 = await (await t.post("id", { signal: r.signal, searchParams: k({ arg: r.peerId ? r.peerId.toString() : void 0, ...r }), headers: r.headers })).json(), o = { ...St(i2) };
            return o.id = ue(o.id), o.addresses && (o.addresses = o.addresses.map((s) => new j(s))), o;
          }
          return e;
        });
        c();
        var Toe = (t) => {
          let e = Rb(t);
          async function r(n = {}) {
            let i2 = await e(n);
            return Boolean(i2 && i2.addresses && i2.addresses.length);
          }
          return r;
        };
        c();
        te();
        var Ioe = P((t, e) => {
          async function* r(n, i2 = {}) {
            let o = `${n instanceof Uint8Array ? I.decode(n) : n}`;
            async function s(u) {
              let l = u.Hash;
              if (l.includes("/")) {
                let h = l.startsWith("/ipfs/") ? l : `/ipfs/${l}`;
                l = (await wb(e)(h)).cid;
              } else
                l = I.parse(l);
              let f = { name: u.Name, path: o + (u.Name ? `/${u.Name}` : ""), size: u.Size, cid: l, type: QCe(u) };
              return u.Mode && (f.mode = parseInt(u.Mode, 8)), u.Mtime !== void 0 && u.Mtime !== null && (f.mtime = { secs: u.Mtime }, u.MtimeNsecs !== void 0 && u.MtimeNsecs !== null && (f.mtime.nsecs = u.MtimeNsecs)), f;
            }
            let a = await t.post("ls", { signal: i2.signal, searchParams: k({ arg: o, ...i2 }), headers: i2.headers });
            for await (let u of a.ndjson()) {
              if (u = u.Objects, !u)
                throw new Error("expected .Objects in results");
              if (u = u[0], !u)
                throw new Error("expected one array in results.Objects");
              let l = u.Links;
              if (!Array.isArray(l))
                throw new Error("expected one array in results.Objects[0].Links");
              if (!l.length) {
                yield s(u);
                return;
              }
              yield* l.map(s);
            }
          }
          return r;
        });
        function QCe(t) {
          switch (t.Type) {
            case 1:
            case 5:
              return "dir";
            case 2:
              return "file";
            default:
              return "file";
          }
        }
        c();
        var Coe = P((t) => {
          async function e(r = {}) {
            let n = await t.post("dns", { signal: r.signal, searchParams: k(r), headers: r.headers });
            return St(await n.json());
          }
          return e;
        });
        c();
        var Poe = P((t) => {
          async function* e(r, n = {}) {
            yield* (await t.post("ping", { signal: n.signal, searchParams: k({ arg: `${r}`, ...n }), headers: n.headers, transform: St })).ndjson();
          }
          return e;
        });
        c();
        var Doe = P((t) => {
          async function e(r, n = {}) {
            let i2 = await t.post("resolve", { signal: n.signal, searchParams: k({ arg: r, ...n }), headers: n.headers }), { Path: o } = await i2.json();
            return o;
          }
          return e;
        });
        c();
        var koe = w(K(), 1), Noe = P((t) => async (r = {}) => {
          throw (0, koe.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
        });
        c();
        var Ooe = P((t) => {
          async function e(r = {}) {
            await (await t.post("shutdown", { signal: r.signal, searchParams: k(r), headers: r.headers })).text();
          }
          return e;
        });
        c();
        var Loe = P((t) => {
          async function e(r = {}) {
            let n = await t.post("version", { signal: r.signal, searchParams: k(r), headers: r.headers });
            return { ...St(await n.json()), "ipfs-http-client": "1.0.0" };
          }
          return e;
        });
        var tPe = w(hP(), 1);
        te();
        var rPe = w(dP(), 1);
        function Moe(t = {}) {
          let e = { name: $r.name, code: $r.code, encode: (l) => l, decode: (l) => l }, r = Object.values(Sa);
          (t.ipld && t.ipld.bases ? t.ipld.bases : []).forEach((l) => r.push(l));
          let n = new L1({ bases: r, loadBase: t.ipld && t.ipld.loadBase }), i2 = Object.values(sw);
          [At, vc, vp, ePe, e].concat(t.ipld && t.ipld.codecs || []).forEach((l) => i2.push(l));
          let o = new B1({ codecs: i2, loadCodec: t.ipld && t.ipld.loadCodec }), s = Object.values(ow);
          (t.ipld && t.ipld.hashers ? t.ipld.hashers : []).forEach((l) => s.push(l));
          let a = new M1({ hashers: s, loadHasher: t.ipld && t.ipld.loadHasher });
          return { add: _oe(t), addAll: xb(t), bitswap: Hre(t), block: nne(t), bootstrap: une(t), cat: voe(t), commands: Soe(t), config: gne(t), dag: Rne(o, t), dht: kne(t), diag: Bne(t), dns: xoe(t), files: Zne(t), get: Aoe(t), getEndpointConfig: Roe(t), id: Rb(t), isOnline: Toe(t), key: cie(t), log: hie(t), ls: Ioe(t), mount: Coe(t), name: Eie(t), object: Die(o, t), pin: Zie(t), ping: Poe(t), pubsub: soe(t), refs: coe(t), repo: foe(t), resolve: Doe(t), start: Noe(t), stats: doe(t), stop: Ooe(t), swarm: Eoe(t), version: Loe(t), bases: n, codecs: o, hashers: a };
        }
        c();
        c();
        var Ub = w(K(), 1);
        c();
        c();
        var Sse = w(K(), 1);
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        c();
        var ta = /* @__PURE__ */ Object.create(null);
        ta.open = "0";
        ta.close = "1";
        ta.ping = "2";
        ta.pong = "3";
        ta.message = "4";
        ta.upgrade = "5";
        ta.noop = "6";
        var t3 = /* @__PURE__ */ Object.create(null);
        Object.keys(ta).forEach((t) => {
          t3[ta[t]] = t;
        });
        var Uoe = { type: "error", data: "parser error" };
        var nPe = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", iPe = typeof ArrayBuffer == "function", oPe = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t && t.buffer instanceof ArrayBuffer, sPe = ({ type: t, data: e }, r, n) => nPe && e instanceof Blob ? r ? n(e) : Foe(e, n) : iPe && (e instanceof ArrayBuffer || oPe(e)) ? r ? n(e) : Foe(new Blob([e]), n) : n(ta[t] + (e || "")), Foe = (t, e) => {
          let r = new FileReader();
          return r.onload = function() {
            let n = r.result.split(",")[1];
            e("b" + n);
          }, r.readAsDataURL(t);
        }, Ab = sPe;
        c();
        c();
        var Koe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r3 = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
        for (let t = 0; t < Koe.length; t++)
          r3[Koe.charCodeAt(t)] = t;
        var Voe = (t) => {
          let e = t.length * 0.75, r = t.length, n, i2 = 0, o, s, a, u;
          t[t.length - 1] === "=" && (e--, t[t.length - 2] === "=" && e--);
          let l = new ArrayBuffer(e), f = new Uint8Array(l);
          for (n = 0; n < r; n += 4)
            o = r3[t.charCodeAt(n)], s = r3[t.charCodeAt(n + 1)], a = r3[t.charCodeAt(n + 2)], u = r3[t.charCodeAt(n + 3)], f[i2++] = o << 2 | s >> 4, f[i2++] = (s & 15) << 4 | a >> 2, f[i2++] = (a & 3) << 6 | u & 63;
          return l;
        };
        var aPe = typeof ArrayBuffer == "function", cPe = (t, e) => {
          if (typeof t != "string")
            return { type: "message", data: qoe(t, e) };
          let r = t.charAt(0);
          return r === "b" ? { type: "message", data: uPe(t.substring(1), e) } : t3[r] ? t.length > 1 ? { type: t3[r], data: t.substring(1) } : { type: t3[r] } : Uoe;
        }, uPe = (t, e) => {
          if (aPe) {
            let r = Voe(t);
            return qoe(r, e);
          } else
            return { base64: true, data: t };
        }, qoe = (t, e) => {
          switch (e) {
            case "blob":
              return t instanceof ArrayBuffer ? new Blob([t]) : t;
            case "arraybuffer":
            default:
              return t;
          }
        }, Tb = cPe;
        var zoe = String.fromCharCode(30), Hoe = (t, e) => {
          let r = t.length, n = new Array(r), i2 = 0;
          t.forEach((o, s) => {
            Ab(o, false, (a) => {
              n[s] = a, ++i2 === r && e(n.join(zoe));
            });
          });
        }, $oe = (t, e) => {
          let r = t.split(zoe), n = [];
          for (let i2 = 0; i2 < r.length; i2++) {
            let o = Tb(r[i2], e);
            if (n.push(o), o.type === "error")
              break;
          }
          return n;
        }, pP = 4;
        c();
        function Tr(t) {
          if (t)
            return lPe(t);
        }
        function lPe(t) {
          for (var e in Tr.prototype)
            t[e] = Tr.prototype[e];
          return t;
        }
        Tr.prototype.on = Tr.prototype.addEventListener = function(t, e) {
          return this._callbacks = this._callbacks || {}, (this._callbacks["$" + t] = this._callbacks["$" + t] || []).push(e), this;
        };
        Tr.prototype.once = function(t, e) {
          function r() {
            this.off(t, r), e.apply(this, arguments);
          }
          return r.fn = e, this.on(t, r), this;
        };
        Tr.prototype.off = Tr.prototype.removeListener = Tr.prototype.removeAllListeners = Tr.prototype.removeEventListener = function(t, e) {
          if (this._callbacks = this._callbacks || {}, arguments.length == 0)
            return this._callbacks = {}, this;
          var r = this._callbacks["$" + t];
          if (!r)
            return this;
          if (arguments.length == 1)
            return delete this._callbacks["$" + t], this;
          for (var n, i2 = 0; i2 < r.length; i2++)
            if (n = r[i2], n === e || n.fn === e) {
              r.splice(i2, 1);
              break;
            }
          return r.length === 0 && delete this._callbacks["$" + t], this;
        };
        Tr.prototype.emit = function(t) {
          this._callbacks = this._callbacks || {};
          for (var e = new Array(arguments.length - 1), r = this._callbacks["$" + t], n = 1; n < arguments.length; n++)
            e[n - 1] = arguments[n];
          if (r) {
            r = r.slice(0);
            for (var n = 0, i2 = r.length; n < i2; ++n)
              r[n].apply(this, e);
          }
          return this;
        };
        Tr.prototype.emitReserved = Tr.prototype.emit;
        Tr.prototype.listeners = function(t) {
          return this._callbacks = this._callbacks || {}, this._callbacks["$" + t] || [];
        };
        Tr.prototype.hasListeners = function(t) {
          return !!this.listeners(t).length;
        };
        c();
        c();
        var fs = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
        function Ib(t, ...e) {
          return e.reduce((r, n) => (t.hasOwnProperty(n) && (r[n] = t[n]), r), {});
        }
        var fPe = setTimeout, hPe = clearTimeout;
        function uu(t, e) {
          e.useNativeTimers ? (t.setTimeoutFn = fPe.bind(fs), t.clearTimeoutFn = hPe.bind(fs)) : (t.setTimeoutFn = setTimeout.bind(fs), t.clearTimeoutFn = clearTimeout.bind(fs));
        }
        var dPe = 1.33;
        function Goe(t) {
          return typeof t == "string" ? pPe(t) : Math.ceil((t.byteLength || t.size) * dPe);
        }
        function pPe(t) {
          let e = 0, r = 0;
          for (let n = 0, i2 = t.length; n < i2; n++)
            e = t.charCodeAt(n), e < 128 ? r += 1 : e < 2048 ? r += 2 : e < 55296 || e >= 57344 ? r += 3 : (n++, r += 4);
          return r;
        }
        var mP = class extends Error {
          constructor(e, r, n) {
            super(e), this.description = r, this.context = n, this.type = "TransportError";
          }
        }, Sd = class extends Tr {
          constructor(e) {
            super(), this.writable = false, uu(this, e), this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket;
          }
          onError(e, r, n) {
            return super.emitReserved("error", new mP(e, r, n)), this;
          }
          open() {
            return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this;
          }
          close() {
            return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
          }
          send(e) {
            this.readyState === "open" && this.write(e);
          }
          onOpen() {
            this.readyState = "open", this.writable = true, super.emitReserved("open");
          }
          onData(e) {
            let r = Tb(e, this.socket.binaryType);
            this.onPacket(r);
          }
          onPacket(e) {
            super.emitReserved("packet", e);
          }
          onClose(e) {
            this.readyState = "closed", super.emitReserved("close", e);
          }
        };
        c();
        var Qoe = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), yP = 64, mPe = {}, Woe = 0, Cb = 0, joe;
        function Yoe(t) {
          let e = "";
          do
            e = Qoe[t % yP] + e, t = Math.floor(t / yP);
          while (t > 0);
          return e;
        }
        function Pb() {
          let t = Yoe(+new Date());
          return t !== joe ? (Woe = 0, joe = t) : t + "." + Yoe(Woe++);
        }
        for (; Cb < yP; Cb++)
          mPe[Qoe[Cb]] = Cb;
        c();
        function Db(t) {
          let e = "";
          for (let r in t)
            t.hasOwnProperty(r) && (e.length && (e += "&"), e += encodeURIComponent(r) + "=" + encodeURIComponent(t[r]));
          return e;
        }
        function Xoe(t) {
          let e = {}, r = t.split("&");
          for (let n = 0, i2 = r.length; n < i2; n++) {
            let o = r[n].split("=");
            e[decodeURIComponent(o[0])] = decodeURIComponent(o[1]);
          }
          return e;
        }
        c();
        c();
        var Zoe = false;
        try {
          Zoe = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
        } catch {
        }
        var Joe = Zoe;
        function gP(t) {
          let e = t.xdomain;
          try {
            if (typeof XMLHttpRequest < "u" && (!e || Joe))
              return new XMLHttpRequest();
          } catch {
          }
          if (!e)
            try {
              return new fs[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
            } catch {
            }
        }
        function yPe() {
        }
        var gPe = function() {
          return new gP({ xdomain: false }).responseType != null;
        }(), kb = class extends Sd {
          constructor(e) {
            if (super(e), this.polling = false, typeof location < "u") {
              let n = location.protocol === "https:", i2 = location.port;
              i2 || (i2 = n ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || i2 !== e.port, this.xs = e.secure !== n;
            }
            let r = e && e.forceBase64;
            this.supportsBinary = gPe && !r;
          }
          get name() {
            return "polling";
          }
          doOpen() {
            this.poll();
          }
          pause(e) {
            this.readyState = "pausing";
            let r = () => {
              this.readyState = "paused", e();
            };
            if (this.polling || !this.writable) {
              let n = 0;
              this.polling && (n++, this.once("pollComplete", function() {
                --n || r();
              })), this.writable || (n++, this.once("drain", function() {
                --n || r();
              }));
            } else
              r();
          }
          poll() {
            this.polling = true, this.doPoll(), this.emitReserved("poll");
          }
          onData(e) {
            let r = (n) => {
              if (this.readyState === "opening" && n.type === "open" && this.onOpen(), n.type === "close")
                return this.onClose({ description: "transport closed by the server" }), false;
              this.onPacket(n);
            };
            $oe(e, this.socket.binaryType).forEach(r), this.readyState !== "closed" && (this.polling = false, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
          }
          doClose() {
            let e = () => {
              this.write([{ type: "close" }]);
            };
            this.readyState === "open" ? e() : this.once("open", e);
          }
          write(e) {
            this.writable = false, Hoe(e, (r) => {
              this.doWrite(r, () => {
                this.writable = true, this.emitReserved("drain");
              });
            });
          }
          uri() {
            let e = this.query || {}, r = this.opts.secure ? "https" : "http", n = "";
            this.opts.timestampRequests !== false && (e[this.opts.timestampParam] = Pb()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.opts.port && (r === "https" && Number(this.opts.port) !== 443 || r === "http" && Number(this.opts.port) !== 80) && (n = ":" + this.opts.port);
            let i2 = Db(e), o = this.opts.hostname.indexOf(":") !== -1;
            return r + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + n + this.opts.path + (i2.length ? "?" + i2 : "");
          }
          request(e = {}) {
            return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new hs(this.uri(), e);
          }
          doWrite(e, r) {
            let n = this.request({ method: "POST", data: e });
            n.on("success", r), n.on("error", (i2, o) => {
              this.onError("xhr post error", i2, o);
            });
          }
          doPoll() {
            let e = this.request();
            e.on("data", this.onData.bind(this)), e.on("error", (r, n) => {
              this.onError("xhr poll error", r, n);
            }), this.pollXhr = e;
          }
        }, hs = class extends Tr {
          constructor(e, r) {
            super(), uu(this, r), this.opts = r, this.method = r.method || "GET", this.uri = e, this.async = r.async !== false, this.data = r.data !== void 0 ? r.data : null, this.create();
          }
          create() {
            let e = Ib(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
            e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs;
            let r = this.xhr = new gP(e);
            try {
              r.open(this.method, this.uri, this.async);
              try {
                if (this.opts.extraHeaders) {
                  r.setDisableHeaderCheck && r.setDisableHeaderCheck(true);
                  for (let n in this.opts.extraHeaders)
                    this.opts.extraHeaders.hasOwnProperty(n) && r.setRequestHeader(n, this.opts.extraHeaders[n]);
                }
              } catch {
              }
              if (this.method === "POST")
                try {
                  r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                } catch {
                }
              try {
                r.setRequestHeader("Accept", "*/*");
              } catch {
              }
              "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {
                r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
                  this.onError(typeof r.status == "number" ? r.status : 0);
                }, 0));
              }, r.send(this.data);
            } catch (n) {
              this.setTimeoutFn(() => {
                this.onError(n);
              }, 0);
              return;
            }
            typeof document < "u" && (this.index = hs.requestsCount++, hs.requests[this.index] = this);
          }
          onError(e) {
            this.emitReserved("error", e, this.xhr), this.cleanup(true);
          }
          cleanup(e) {
            if (!(typeof this.xhr > "u" || this.xhr === null)) {
              if (this.xhr.onreadystatechange = yPe, e)
                try {
                  this.xhr.abort();
                } catch {
                }
              typeof document < "u" && delete hs.requests[this.index], this.xhr = null;
            }
          }
          onLoad() {
            let e = this.xhr.responseText;
            e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup());
          }
          abort() {
            this.cleanup();
          }
        };
        hs.requestsCount = 0;
        hs.requests = {};
        if (typeof document < "u") {
          if (typeof attachEvent == "function")
            attachEvent("onunload", ese);
          else if (typeof addEventListener == "function") {
            let t = "onpagehide" in fs ? "pagehide" : "unload";
            addEventListener(t, ese, false);
          }
        }
        function ese() {
          for (let t in hs.requests)
            hs.requests.hasOwnProperty(t) && hs.requests[t].abort();
        }
        c();
        c();
        var tse = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, r) => r(e, 0))(), n3 = fs.WebSocket || fs.MozWebSocket, Nb = true, rse = "arraybuffer";
        var nse = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative", Ob = class extends Sd {
          constructor(e) {
            super(e), this.supportsBinary = !e.forceBase64;
          }
          get name() {
            return "websocket";
          }
          doOpen() {
            if (!this.check())
              return;
            let e = this.uri(), r = this.opts.protocols, n = nse ? {} : Ib(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
            this.opts.extraHeaders && (n.headers = this.opts.extraHeaders);
            try {
              this.ws = Nb && !nse ? r ? new n3(e, r) : new n3(e) : new n3(e, r, n);
            } catch (i2) {
              return this.emitReserved("error", i2);
            }
            this.ws.binaryType = this.socket.binaryType || rse, this.addEventListeners();
          }
          addEventListeners() {
            this.ws.onopen = () => {
              this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
            }, this.ws.onclose = (e) => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
          }
          write(e) {
            this.writable = false;
            for (let r = 0; r < e.length; r++) {
              let n = e[r], i2 = r === e.length - 1;
              Ab(n, this.supportsBinary, (o) => {
                let s = {};
                Nb || (n.options && (s.compress = n.options.compress), this.opts.perMessageDeflate && (typeof o == "string" ? Buffer.byteLength(o) : o.length) < this.opts.perMessageDeflate.threshold && (s.compress = false));
                try {
                  Nb ? this.ws.send(o) : this.ws.send(o, s);
                } catch {
                }
                i2 && tse(() => {
                  this.writable = true, this.emitReserved("drain");
                }, this.setTimeoutFn);
              });
            }
          }
          doClose() {
            typeof this.ws < "u" && (this.ws.close(), this.ws = null);
          }
          uri() {
            let e = this.query || {}, r = this.opts.secure ? "wss" : "ws", n = "";
            this.opts.port && (r === "wss" && Number(this.opts.port) !== 443 || r === "ws" && Number(this.opts.port) !== 80) && (n = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = Pb()), this.supportsBinary || (e.b64 = 1);
            let i2 = Db(e), o = this.opts.hostname.indexOf(":") !== -1;
            return r + "://" + (o ? "[" + this.opts.hostname + "]" : this.opts.hostname) + n + this.opts.path + (i2.length ? "?" + i2 : "");
          }
          check() {
            return !!n3;
          }
        };
        var wP = { websocket: Ob, polling: kb };
        c();
        var wPe = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, EPe = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
        function K1(t) {
          let e = t, r = t.indexOf("["), n = t.indexOf("]");
          r != -1 && n != -1 && (t = t.substring(0, r) + t.substring(r, n).replace(/:/g, ";") + t.substring(n, t.length));
          let i2 = wPe.exec(t || ""), o = {}, s = 14;
          for (; s--; )
            o[EPe[s]] = i2[s] || "";
          return r != -1 && n != -1 && (o.source = e, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = true), o.pathNames = bPe(o, o.path), o.queryKey = _Pe(o, o.query), o;
        }
        function bPe(t, e) {
          let r = /\/{2,9}/g, n = e.replace(r, "/").split("/");
          return (e.substr(0, 1) == "/" || e.length === 0) && n.splice(0, 1), e.substr(e.length - 1, 1) == "/" && n.splice(n.length - 1, 1), n;
        }
        function _Pe(t, e) {
          let r = {};
          return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(n, i2, o) {
            i2 && (r[i2] = o);
          }), r;
        }
        var Ao = class extends Tr {
          constructor(e, r = {}) {
            super(), e && typeof e == "object" && (r = e, e = null), e ? (e = K1(e), r.hostname = e.host, r.secure = e.protocol === "https" || e.protocol === "wss", r.port = e.port, e.query && (r.query = e.query)) : r.host && (r.hostname = K1(r.host).host), uu(this, r), this.secure = r.secure != null ? r.secure : typeof location < "u" && location.protocol === "https:", r.hostname && !r.port && (r.port = this.secure ? "443" : "80"), this.hostname = r.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = r.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = r.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: "/engine.io", agent: false, withCredentials: false, upgrade: true, timestampParam: "t", rememberUpgrade: false, rejectUnauthorized: true, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: true }, r), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = Xoe(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && addEventListener("beforeunload", () => {
              this.transport && (this.transport.removeAllListeners(), this.transport.close());
            }, false), this.hostname !== "localhost" && (this.offlineEventListener = () => {
              this.onClose("transport close", { description: "network connection lost" });
            }, addEventListener("offline", this.offlineEventListener, false))), this.open();
          }
          createTransport(e) {
            let r = Object.assign({}, this.opts.query);
            r.EIO = pP, r.transport = e, this.id && (r.sid = this.id);
            let n = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: r, socket: this, hostname: this.hostname, secure: this.secure, port: this.port });
            return new wP[e](n);
          }
          open() {
            let e;
            if (this.opts.rememberUpgrade && Ao.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
              e = "websocket";
            else if (this.transports.length === 0) {
              this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
              }, 0);
              return;
            } else
              e = this.transports[0];
            this.readyState = "opening";
            try {
              e = this.createTransport(e);
            } catch {
              this.transports.shift(), this.open();
              return;
            }
            e.open(), this.setTransport(e);
          }
          setTransport(e) {
            this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (r) => this.onClose("transport close", r));
          }
          probe(e) {
            let r = this.createTransport(e), n = false;
            Ao.priorWebsocketSuccess = false;
            let i2 = () => {
              n || (r.send([{ type: "ping", data: "probe" }]), r.once("packet", (h) => {
                if (!n)
                  if (h.type === "pong" && h.data === "probe") {
                    if (this.upgrading = true, this.emitReserved("upgrading", r), !r)
                      return;
                    Ao.priorWebsocketSuccess = r.name === "websocket", this.transport.pause(() => {
                      n || this.readyState !== "closed" && (f(), this.setTransport(r), r.send([{ type: "upgrade" }]), this.emitReserved("upgrade", r), r = null, this.upgrading = false, this.flush());
                    });
                  } else {
                    let p = new Error("probe error");
                    p.transport = r.name, this.emitReserved("upgradeError", p);
                  }
              }));
            };
            function o() {
              n || (n = true, f(), r.close(), r = null);
            }
            let s = (h) => {
              let p = new Error("probe error: " + h);
              p.transport = r.name, o(), this.emitReserved("upgradeError", p);
            };
            function a() {
              s("transport closed");
            }
            function u() {
              s("socket closed");
            }
            function l(h) {
              r && h.name !== r.name && o();
            }
            let f = () => {
              r.removeListener("open", i2), r.removeListener("error", s), r.removeListener("close", a), this.off("close", u), this.off("upgrading", l);
            };
            r.once("open", i2), r.once("error", s), r.once("close", a), this.once("close", u), this.once("upgrading", l), r.open();
          }
          onOpen() {
            if (this.readyState = "open", Ao.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
              let e = 0, r = this.upgrades.length;
              for (; e < r; e++)
                this.probe(this.upgrades[e]);
            }
          }
          onPacket(e) {
            if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
              switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
                case "open":
                  this.onHandshake(JSON.parse(e.data));
                  break;
                case "ping":
                  this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
                  break;
                case "error":
                  let r = new Error("server error");
                  r.code = e.data, this.onError(r);
                  break;
                case "message":
                  this.emitReserved("data", e.data), this.emitReserved("message", e.data);
                  break;
              }
          }
          onHandshake(e) {
            this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
          }
          resetPingTimeout() {
            this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
              this.onClose("ping timeout");
            }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
          }
          onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
          }
          flush() {
            if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
              let e = this.getWritablePackets();
              this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush");
            }
          }
          getWritablePackets() {
            if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
              return this.writeBuffer;
            let r = 1;
            for (let n = 0; n < this.writeBuffer.length; n++) {
              let i2 = this.writeBuffer[n].data;
              if (i2 && (r += Goe(i2)), n > 0 && r > this.maxPayload)
                return this.writeBuffer.slice(0, n);
              r += 2;
            }
            return this.writeBuffer;
          }
          write(e, r, n) {
            return this.sendPacket("message", e, r, n), this;
          }
          send(e, r, n) {
            return this.sendPacket("message", e, r, n), this;
          }
          sendPacket(e, r, n, i2) {
            if (typeof r == "function" && (i2 = r, r = void 0), typeof n == "function" && (i2 = n, n = null), this.readyState === "closing" || this.readyState === "closed")
              return;
            n = n || {}, n.compress = n.compress !== false;
            let o = { type: e, data: r, options: n };
            this.emitReserved("packetCreate", o), this.writeBuffer.push(o), i2 && this.once("flush", i2), this.flush();
          }
          close() {
            let e = () => {
              this.onClose("forced close"), this.transport.close();
            }, r = () => {
              this.off("upgrade", r), this.off("upgradeError", r), e();
            }, n = () => {
              this.once("upgrade", r), this.once("upgradeError", r);
            };
            return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
              this.upgrading ? n() : e();
            }) : this.upgrading ? n() : e()), this;
          }
          onError(e) {
            Ao.priorWebsocketSuccess = false, this.emitReserved("error", e), this.onClose("transport error", e);
          }
          onClose(e, r) {
            (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && removeEventListener("offline", this.offlineEventListener, false), this.readyState = "closed", this.id = null, this.emitReserved("close", e, r), this.writeBuffer = [], this.prevBufferLen = 0);
          }
          filterUpgrades(e) {
            let r = [], n = 0, i2 = e.length;
            for (; n < i2; n++)
              ~this.transports.indexOf(e[n]) && r.push(e[n]);
            return r;
          }
        };
        Ao.protocol = pP;
        var J8t = Ao.protocol;
        function ise(t, e = "", r) {
          let n = t;
          r = r || typeof location < "u" && location, t == null && (t = r.protocol + "//" + r.host), typeof t == "string" && (t.charAt(0) === "/" && (t.charAt(1) === "/" ? t = r.protocol + t : t = r.host + t), /^(https?|wss?):\/\//.test(t) || (typeof r < "u" ? t = r.protocol + "//" + t : t = "https://" + t), n = K1(t)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/";
          let o = n.host.indexOf(":") !== -1 ? "[" + n.host + "]" : n.host;
          return n.id = n.protocol + "://" + o + ":" + n.port + e, n.href = n.protocol + "://" + o + (r && r.port === n.port ? "" : ":" + n.port), n;
        }
        c();
        c();
        var SP = {};
        ct(SP, { Decoder: () => s3, Encoder: () => _P, PacketType: () => Ct, protocol: () => cse });
        c();
        c();
        c();
        var vPe = typeof ArrayBuffer == "function", SPe = (t) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t.buffer instanceof ArrayBuffer, ose = Object.prototype.toString, xPe = typeof Blob == "function" || typeof Blob < "u" && ose.call(Blob) === "[object BlobConstructor]", RPe = typeof File == "function" || typeof File < "u" && ose.call(File) === "[object FileConstructor]";
        function o3(t) {
          return vPe && (t instanceof ArrayBuffer || SPe(t)) || xPe && t instanceof Blob || RPe && t instanceof File;
        }
        function i3(t, e) {
          if (!t || typeof t != "object")
            return false;
          if (Array.isArray(t)) {
            for (let r = 0, n = t.length; r < n; r++)
              if (i3(t[r]))
                return true;
            return false;
          }
          if (o3(t))
            return true;
          if (t.toJSON && typeof t.toJSON == "function" && arguments.length === 1)
            return i3(t.toJSON(), true);
          for (let r in t)
            if (Object.prototype.hasOwnProperty.call(t, r) && i3(t[r]))
              return true;
          return false;
        }
        function sse(t) {
          let e = [], r = t.data, n = t;
          return n.data = EP(r, e), n.attachments = e.length, { packet: n, buffers: e };
        }
        function EP(t, e) {
          if (!t)
            return t;
          if (o3(t)) {
            let r = { _placeholder: true, num: e.length };
            return e.push(t), r;
          } else if (Array.isArray(t)) {
            let r = new Array(t.length);
            for (let n = 0; n < t.length; n++)
              r[n] = EP(t[n], e);
            return r;
          } else if (typeof t == "object" && !(t instanceof Date)) {
            let r = {};
            for (let n in t)
              Object.prototype.hasOwnProperty.call(t, n) && (r[n] = EP(t[n], e));
            return r;
          }
          return t;
        }
        function ase(t, e) {
          return t.data = bP(t.data, e), t.attachments = void 0, t;
        }
        function bP(t, e) {
          if (!t)
            return t;
          if (t && t._placeholder)
            return e[t.num];
          if (Array.isArray(t))
            for (let r = 0; r < t.length; r++)
              t[r] = bP(t[r], e);
          else if (typeof t == "object")
            for (let r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (t[r] = bP(t[r], e));
          return t;
        }
        var cse = 5, Ct;
        (function(t) {
          t[t.CONNECT = 0] = "CONNECT", t[t.DISCONNECT = 1] = "DISCONNECT", t[t.EVENT = 2] = "EVENT", t[t.ACK = 3] = "ACK", t[t.CONNECT_ERROR = 4] = "CONNECT_ERROR", t[t.BINARY_EVENT = 5] = "BINARY_EVENT", t[t.BINARY_ACK = 6] = "BINARY_ACK";
        })(Ct || (Ct = {}));
        var _P = class {
          constructor(e) {
            this.replacer = e;
          }
          encode(e) {
            return (e.type === Ct.EVENT || e.type === Ct.ACK) && i3(e) ? (e.type = e.type === Ct.EVENT ? Ct.BINARY_EVENT : Ct.BINARY_ACK, this.encodeAsBinary(e)) : [this.encodeAsString(e)];
          }
          encodeAsString(e) {
            let r = "" + e.type;
            return (e.type === Ct.BINARY_EVENT || e.type === Ct.BINARY_ACK) && (r += e.attachments + "-"), e.nsp && e.nsp !== "/" && (r += e.nsp + ","), e.id != null && (r += e.id), e.data != null && (r += JSON.stringify(e.data, this.replacer)), r;
          }
          encodeAsBinary(e) {
            let r = sse(e), n = this.encodeAsString(r.packet), i2 = r.buffers;
            return i2.unshift(n), i2;
          }
        }, s3 = class extends Tr {
          constructor(e) {
            super(), this.reviver = e;
          }
          add(e) {
            let r;
            if (typeof e == "string")
              r = this.decodeString(e), r.type === Ct.BINARY_EVENT || r.type === Ct.BINARY_ACK ? (this.reconstructor = new vP(r), r.attachments === 0 && super.emitReserved("decoded", r)) : super.emitReserved("decoded", r);
            else if (o3(e) || e.base64)
              if (this.reconstructor)
                r = this.reconstructor.takeBinaryData(e), r && (this.reconstructor = null, super.emitReserved("decoded", r));
              else
                throw new Error("got binary data when not reconstructing a packet");
            else
              throw new Error("Unknown type: " + e);
          }
          decodeString(e) {
            let r = 0, n = { type: Number(e.charAt(0)) };
            if (Ct[n.type] === void 0)
              throw new Error("unknown packet type " + n.type);
            if (n.type === Ct.BINARY_EVENT || n.type === Ct.BINARY_ACK) {
              let o = r + 1;
              for (; e.charAt(++r) !== "-" && r != e.length; )
                ;
              let s = e.substring(o, r);
              if (s != Number(s) || e.charAt(r) !== "-")
                throw new Error("Illegal attachments");
              n.attachments = Number(s);
            }
            if (e.charAt(r + 1) === "/") {
              let o = r + 1;
              for (; ++r && !(e.charAt(r) === "," || r === e.length); )
                ;
              n.nsp = e.substring(o, r);
            } else
              n.nsp = "/";
            let i2 = e.charAt(r + 1);
            if (i2 !== "" && Number(i2) == i2) {
              let o = r + 1;
              for (; ++r; ) {
                let s = e.charAt(r);
                if (s == null || Number(s) != s) {
                  --r;
                  break;
                }
                if (r === e.length)
                  break;
              }
              n.id = Number(e.substring(o, r + 1));
            }
            if (e.charAt(++r)) {
              let o = this.tryParse(e.substr(r));
              if (s3.isPayloadValid(n.type, o))
                n.data = o;
              else
                throw new Error("invalid payload");
            }
            return n;
          }
          tryParse(e) {
            try {
              return JSON.parse(e, this.reviver);
            } catch {
              return false;
            }
          }
          static isPayloadValid(e, r) {
            switch (e) {
              case Ct.CONNECT:
                return typeof r == "object";
              case Ct.DISCONNECT:
                return r === void 0;
              case Ct.CONNECT_ERROR:
                return typeof r == "string" || typeof r == "object";
              case Ct.EVENT:
              case Ct.BINARY_EVENT:
                return Array.isArray(r) && r.length > 0;
              case Ct.ACK:
              case Ct.BINARY_ACK:
                return Array.isArray(r);
            }
          }
          destroy() {
            this.reconstructor && this.reconstructor.finishedReconstruction();
          }
        }, vP = class {
          constructor(e) {
            this.packet = e, this.buffers = [], this.reconPack = e;
          }
          takeBinaryData(e) {
            if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
              let r = ase(this.reconPack, this.buffers);
              return this.finishedReconstruction(), r;
            }
            return null;
          }
          finishedReconstruction() {
            this.reconPack = null, this.buffers = [];
          }
        };
        c();
        function To(t, e, r) {
          return t.on(e, r), function() {
            t.off(e, r);
          };
        }
        var APe = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }), V1 = class extends Tr {
          constructor(e, r, n) {
            super(), this.connected = false, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = r, n && n.auth && (this.auth = n.auth), this.io._autoConnect && this.open();
          }
          get disconnected() {
            return !this.connected;
          }
          subEvents() {
            if (this.subs)
              return;
            let e = this.io;
            this.subs = [To(e, "open", this.onopen.bind(this)), To(e, "packet", this.onpacket.bind(this)), To(e, "error", this.onerror.bind(this)), To(e, "close", this.onclose.bind(this))];
          }
          get active() {
            return !!this.subs;
          }
          connect() {
            return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
          }
          open() {
            return this.connect();
          }
          send(...e) {
            return e.unshift("message"), this.emit.apply(this, e), this;
          }
          emit(e, ...r) {
            if (APe.hasOwnProperty(e))
              throw new Error('"' + e + '" is a reserved event name');
            r.unshift(e);
            let n = { type: Ct.EVENT, data: r };
            if (n.options = {}, n.options.compress = this.flags.compress !== false, typeof r[r.length - 1] == "function") {
              let s = this.ids++, a = r.pop();
              this._registerAckCallback(s, a), n.id = s;
            }
            let i2 = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
            return this.flags.volatile && (!i2 || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(n), this.packet(n)) : this.sendBuffer.push(n)), this.flags = {}, this;
          }
          _registerAckCallback(e, r) {
            let n = this.flags.timeout;
            if (n === void 0) {
              this.acks[e] = r;
              return;
            }
            let i2 = this.io.setTimeoutFn(() => {
              delete this.acks[e];
              for (let o = 0; o < this.sendBuffer.length; o++)
                this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
              r.call(this, new Error("operation has timed out"));
            }, n);
            this.acks[e] = (...o) => {
              this.io.clearTimeoutFn(i2), r.apply(this, [null, ...o]);
            };
          }
          packet(e) {
            e.nsp = this.nsp, this.io._packet(e);
          }
          onopen() {
            typeof this.auth == "function" ? this.auth((e) => {
              this.packet({ type: Ct.CONNECT, data: e });
            }) : this.packet({ type: Ct.CONNECT, data: this.auth });
          }
          onerror(e) {
            this.connected || this.emitReserved("connect_error", e);
          }
          onclose(e, r) {
            this.connected = false, delete this.id, this.emitReserved("disconnect", e, r);
          }
          onpacket(e) {
            if (e.nsp === this.nsp)
              switch (e.type) {
                case Ct.CONNECT:
                  if (e.data && e.data.sid) {
                    let i2 = e.data.sid;
                    this.onconnect(i2);
                  } else
                    this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                  break;
                case Ct.EVENT:
                case Ct.BINARY_EVENT:
                  this.onevent(e);
                  break;
                case Ct.ACK:
                case Ct.BINARY_ACK:
                  this.onack(e);
                  break;
                case Ct.DISCONNECT:
                  this.ondisconnect();
                  break;
                case Ct.CONNECT_ERROR:
                  this.destroy();
                  let n = new Error(e.data.message);
                  n.data = e.data.data, this.emitReserved("connect_error", n);
                  break;
              }
          }
          onevent(e) {
            let r = e.data || [];
            e.id != null && r.push(this.ack(e.id)), this.connected ? this.emitEvent(r) : this.receiveBuffer.push(Object.freeze(r));
          }
          emitEvent(e) {
            if (this._anyListeners && this._anyListeners.length) {
              let r = this._anyListeners.slice();
              for (let n of r)
                n.apply(this, e);
            }
            super.emit.apply(this, e);
          }
          ack(e) {
            let r = this, n = false;
            return function(...i2) {
              n || (n = true, r.packet({ type: Ct.ACK, id: e, data: i2 }));
            };
          }
          onack(e) {
            let r = this.acks[e.id];
            typeof r == "function" && (r.apply(this, e.data), delete this.acks[e.id]);
          }
          onconnect(e) {
            this.id = e, this.connected = true, this.emitBuffered(), this.emitReserved("connect");
          }
          emitBuffered() {
            this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
              this.notifyOutgoingListeners(e), this.packet(e);
            }), this.sendBuffer = [];
          }
          ondisconnect() {
            this.destroy(), this.onclose("io server disconnect");
          }
          destroy() {
            this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
          }
          disconnect() {
            return this.connected && this.packet({ type: Ct.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
          }
          close() {
            return this.disconnect();
          }
          compress(e) {
            return this.flags.compress = e, this;
          }
          get volatile() {
            return this.flags.volatile = true, this;
          }
          timeout(e) {
            return this.flags.timeout = e, this;
          }
          onAny(e) {
            return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
          }
          prependAny(e) {
            return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
          }
          offAny(e) {
            if (!this._anyListeners)
              return this;
            if (e) {
              let r = this._anyListeners;
              for (let n = 0; n < r.length; n++)
                if (e === r[n])
                  return r.splice(n, 1), this;
            } else
              this._anyListeners = [];
            return this;
          }
          listenersAny() {
            return this._anyListeners || [];
          }
          onAnyOutgoing(e) {
            return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
          }
          prependAnyOutgoing(e) {
            return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
          }
          offAnyOutgoing(e) {
            if (!this._anyOutgoingListeners)
              return this;
            if (e) {
              let r = this._anyOutgoingListeners;
              for (let n = 0; n < r.length; n++)
                if (e === r[n])
                  return r.splice(n, 1), this;
            } else
              this._anyOutgoingListeners = [];
            return this;
          }
          listenersAnyOutgoing() {
            return this._anyOutgoingListeners || [];
          }
          notifyOutgoingListeners(e) {
            if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
              let r = this._anyOutgoingListeners.slice();
              for (let n of r)
                n.apply(this, e.data);
            }
          }
        };
        c();
        function xd(t) {
          t = t || {}, this.ms = t.min || 100, this.max = t.max || 1e4, this.factor = t.factor || 2, this.jitter = t.jitter > 0 && t.jitter <= 1 ? t.jitter : 0, this.attempts = 0;
        }
        xd.prototype.duration = function() {
          var t = this.ms * Math.pow(this.factor, this.attempts++);
          if (this.jitter) {
            var e = Math.random(), r = Math.floor(e * this.jitter * t);
            t = (Math.floor(e * 10) & 1) == 0 ? t - r : t + r;
          }
          return Math.min(t, this.max) | 0;
        };
        xd.prototype.reset = function() {
          this.attempts = 0;
        };
        xd.prototype.setMin = function(t) {
          this.ms = t;
        };
        xd.prototype.setMax = function(t) {
          this.max = t;
        };
        xd.prototype.setJitter = function(t) {
          this.jitter = t;
        };
        var q1 = class extends Tr {
          constructor(e, r) {
            var n;
            super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (r = e, e = void 0), r = r || {}, r.path = r.path || "/socket.io", this.opts = r, uu(this, r), this.reconnection(r.reconnection !== false), this.reconnectionAttempts(r.reconnectionAttempts || 1 / 0), this.reconnectionDelay(r.reconnectionDelay || 1e3), this.reconnectionDelayMax(r.reconnectionDelayMax || 5e3), this.randomizationFactor((n = r.randomizationFactor) !== null && n !== void 0 ? n : 0.5), this.backoff = new xd({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(r.timeout == null ? 2e4 : r.timeout), this._readyState = "closed", this.uri = e;
            let i2 = r.parser || SP;
            this.encoder = new i2.Encoder(), this.decoder = new i2.Decoder(), this._autoConnect = r.autoConnect !== false, this._autoConnect && this.open();
          }
          reconnection(e) {
            return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;
          }
          reconnectionAttempts(e) {
            return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
          }
          reconnectionDelay(e) {
            var r;
            return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (r = this.backoff) === null || r === void 0 || r.setMin(e), this);
          }
          randomizationFactor(e) {
            var r;
            return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (r = this.backoff) === null || r === void 0 || r.setJitter(e), this);
          }
          reconnectionDelayMax(e) {
            var r;
            return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (r = this.backoff) === null || r === void 0 || r.setMax(e), this);
          }
          timeout(e) {
            return arguments.length ? (this._timeout = e, this) : this._timeout;
          }
          maybeReconnectOnOpen() {
            !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
          }
          open(e) {
            if (~this._readyState.indexOf("open"))
              return this;
            this.engine = new Ao(this.uri, this.opts);
            let r = this.engine, n = this;
            this._readyState = "opening", this.skipReconnect = false;
            let i2 = To(r, "open", function() {
              n.onopen(), e && e();
            }), o = To(r, "error", (s) => {
              n.cleanup(), n._readyState = "closed", this.emitReserved("error", s), e ? e(s) : n.maybeReconnectOnOpen();
            });
            if (this._timeout !== false) {
              let s = this._timeout;
              s === 0 && i2();
              let a = this.setTimeoutFn(() => {
                i2(), r.close(), r.emit("error", new Error("timeout"));
              }, s);
              this.opts.autoUnref && a.unref(), this.subs.push(function() {
                clearTimeout(a);
              });
            }
            return this.subs.push(i2), this.subs.push(o), this;
          }
          connect(e) {
            return this.open(e);
          }
          onopen() {
            this.cleanup(), this._readyState = "open", this.emitReserved("open");
            let e = this.engine;
            this.subs.push(To(e, "ping", this.onping.bind(this)), To(e, "data", this.ondata.bind(this)), To(e, "error", this.onerror.bind(this)), To(e, "close", this.onclose.bind(this)), To(this.decoder, "decoded", this.ondecoded.bind(this)));
          }
          onping() {
            this.emitReserved("ping");
          }
          ondata(e) {
            this.decoder.add(e);
          }
          ondecoded(e) {
            this.emitReserved("packet", e);
          }
          onerror(e) {
            this.emitReserved("error", e);
          }
          socket(e, r) {
            let n = this.nsps[e];
            return n || (n = new V1(this, e, r), this.nsps[e] = n), n;
          }
          _destroy(e) {
            let r = Object.keys(this.nsps);
            for (let n of r)
              if (this.nsps[n].active)
                return;
            this._close();
          }
          _packet(e) {
            let r = this.encoder.encode(e);
            for (let n = 0; n < r.length; n++)
              this.engine.write(r[n], e.options);
          }
          cleanup() {
            this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
          }
          _close() {
            this.skipReconnect = true, this._reconnecting = false, this.onclose("forced close"), this.engine && this.engine.close();
          }
          disconnect() {
            return this._close();
          }
          onclose(e, r) {
            this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, r), this._reconnection && !this.skipReconnect && this.reconnect();
          }
          reconnect() {
            if (this._reconnecting || this.skipReconnect)
              return this;
            let e = this;
            if (this.backoff.attempts >= this._reconnectionAttempts)
              this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = false;
            else {
              let r = this.backoff.duration();
              this._reconnecting = true;
              let n = this.setTimeoutFn(() => {
                e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((i2) => {
                  i2 ? (e._reconnecting = false, e.reconnect(), this.emitReserved("reconnect_error", i2)) : e.onreconnect();
                }));
              }, r);
              this.opts.autoUnref && n.unref(), this.subs.push(function() {
                clearTimeout(n);
              });
            }
          }
          onreconnect() {
            let e = this.backoff.attempts;
            this._reconnecting = false, this.backoff.reset(), this.emitReserved("reconnect", e);
          }
        };
        var a3 = {};
        function c3(t, e) {
          typeof t == "object" && (e = t, t = void 0), e = e || {};
          let r = ise(t, e.path || "/socket.io"), n = r.source, i2 = r.id, o = r.path, s = a3[i2] && o in a3[i2].nsps, a = e.forceNew || e["force new connection"] || e.multiplex === false || s, u;
          return a ? u = new q1(n, e) : (a3[i2] || (a3[i2] = new q1(n, e)), u = a3[i2]), r.query && !e.query && (e.query = r.queryKey), u.socket(r.path, e);
        }
        Object.assign(c3, { Manager: q1, Socket: V1, io: c3, connect: c3 });
        c();
        c();
        c();
        var u3 = w(K(), 1), pse = w(uh(), 1);
        me();
        c();
        var lse = w(K(), 1);
        var use = 64 * 1024, TPe = 5 * 1e3, Lb = class {
          constructor(e, r) {
            this.label = e.label, this.open = Ar(), this.channel = e, this.channel.binaryType = "arraybuffer", this.log = r.log, typeof this.channel.bufferedAmountLowThreshold == "number" && (this.channel.bufferedAmountLowThreshold = use), e.addEventListener("message", (i2) => {
              r.onMessage(i2);
            }), e.addEventListener("bufferedamountlow", () => {
              this.log("stop backpressure: bufferedAmount %d", this.channel.bufferedAmount), this.open.resolve();
            }), e.addEventListener("open", () => {
              this.open.resolve(), r.onOpen();
            }), e.addEventListener("close", () => {
              r.onClose();
            }), e.addEventListener("error", (i2) => {
              if (i2.error?.message === "Transport channel closed")
                return this.close();
              r.log.error('channel encounter an error in state "%s" message: "%s" detail: "%s', e.readyState, i2.error?.message, i2.error?.errorDetail);
              let o = i2.error instanceof Error ? i2.error : new Error(`datachannel error: ${i2.error?.message} ${i2.error?.errorDetail}`);
              r.onError((0, lse.default)(o, "ERR_DATA_CHANNEL"));
            });
            let n = false;
            this.closingInterval = setInterval(() => {
              e.readyState === "closing" ? (n && r.onClose(), n = true) : n = false;
            }, TPe);
          }
          async send(e) {
            await this.open.promise, this.channel.send(e), this.channel.bufferedAmount > use && (this.log("start backpressure: bufferedAmount %d", this.channel.bufferedAmount), this.open = Ar());
          }
          close() {
            clearInterval(this.closingInterval), this.channel.close();
          }
          get bufferedAmount() {
            return this.channel.bufferedAmount;
          }
        };
        var mse = w(AP(), 1), CPe = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }] };
        function PPe() {
          if (typeof globalThis > "u")
            throw (0, u3.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
          let t = { RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate };
          if (t.RTCPeerConnection == null)
            throw (0, u3.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
          return t;
        }
        var Rd = class extends Ue {
          constructor(e) {
            super(), this.id = e.id ?? M((0, pse.default)(4), "hex").slice(0, 7), this.log = C(`libp2p:webrtc-peer:${e.logPrefix}:${this.id}`), this.wrtc = e.wrtc ?? PPe(), this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, CPe, e.peerConnectionConfig)), this.closed = false, this.connected = Ar(), this.source = zs(), this.sink = async (r) => {
              if (await this.connected.promise, this.channel == null)
                throw (0, u3.default)(new Error("Connected but no channel?!"), "ERR_DATA_CHANNEL");
              for await (let n of r)
                await this.channel.send(n);
              await this.close();
            };
          }
          handleDataChannelEvent(e) {
            let r = e.channel;
            if (r == null) {
              this.close((0, u3.default)(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")).catch((n) => {
                this.log("Error closing after event channel was found to be null", n);
              });
              return;
            }
            this.channel = new Lb(r, { log: this.log, onMessage: (n) => {
              this.source.push(new Uint8Array(n.data));
            }, onOpen: () => {
              this.connected.resolve(), this.dispatchEvent(new ee("ready"));
            }, onClose: () => {
              this.close().catch((n) => {
                this.log("error closing connection after channel close", n);
              });
            }, onError: (n) => {
              this.close(n).catch((i2) => {
                this.log("error closing connection after channel error", i2);
              });
            } });
          }
          async close(e) {
            if (this.closed = true, e == null && this.channel != null)
              for (; this.channel.bufferedAmount > 0; )
                await (0, mse.default)(100);
            this.channel?.close(), this.peerConnection.close(), this.source.end(e), this.dispatchEvent(new ee("close"));
          }
        };
        c();
        var yse = w(K(), 1), z1 = class extends Ue {
          constructor(e) {
            super(), this.log = e.log, this.peerConnection = e.peerConnection, this.wrtc = e.wrtc, this.status = "idle", this.peerConnection.addEventListener("negotiationneeded", () => {
              this.log("peer connection negotiation needed"), this.handleRenegotiate({ type: "renegotiate" }).catch((r) => {
                this.log.error("could not renegotiate %o", r);
              });
            });
          }
          async handleSignal(e) {
            if (this.log('incoming signal "%s"', e.type), e.type === "offer")
              return await this.handleOffer(e);
            if (e.type === "answer")
              return await this.handleAnswer(e);
            if (e.type === "candidate")
              return await this.handleCandidate(e);
            if (e.type === "renegotiate")
              return await this.handleRenegotiate(e);
            if (e.type === "goodbye")
              return await this.handleGoodye(e);
            this.log(`Unknown signal type ${e.type}`);
          }
          async handleOffer(e) {
          }
          async handleAnswer(e) {
          }
          async handleRenegotiate(e) {
          }
          async handleGoodye(e) {
            this.peerConnection.close();
          }
          async handleCandidate(e) {
            let r = new this.wrtc.RTCIceCandidate(e.candidate);
            try {
              await this.peerConnection.addIceCandidate(r);
            } catch (n) {
              if (r.address == null || r.address.endsWith(".local"))
                this.log("ignoring unsupported ICE candidate.");
              else
                throw (0, yse.default)(n, "ERR_ADD_ICE_CANDIDATE");
            }
          }
        };
        var gse = C("libp2p:webrtc-peer:receiver"), l3 = class extends Rd {
          constructor(e = {}) {
            super({ ...e, logPrefix: "receiver" }), this.handshake = new TP({ log: this.log, peerConnection: this.peerConnection, wrtc: this.wrtc, answerOptions: e.answerOptions }), this.handshake.addEventListener("signal", (r) => this.dispatchEvent(new ee("signal", { detail: r.detail }))), this.peerConnection.addEventListener("datachannel", (r) => {
              this.handleDataChannelEvent(r);
            });
          }
          handleSignal(e) {
            this.handshake.handleSignal(e).catch((r) => {
              this.log("error handling signal %o %o", e, r);
            });
          }
        }, TP = class extends z1 {
          constructor(e) {
            super(e), this.options = e, this.status = "idle", this.iceCandidates = [];
          }
          async handleRenegotiate() {
            gse.trace("renegotiate"), this.dispatchEvent(new ee("signal", { detail: { type: "renegotiate" } }));
          }
          async handleOffer(e) {
            await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(e));
            for (let n of this.iceCandidates)
              await this.handleCandidate(n);
            this.iceCandidates = [];
            let r = await this.peerConnection.createAnswer(this.options.answerOptions);
            await this.peerConnection.setLocalDescription(r), gse.trace("handle offer", this.peerConnection.localDescription), this.dispatchEvent(new ee("signal", { detail: this.peerConnection.localDescription ?? r }));
          }
          async handleCandidate(e) {
            if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {
              this.iceCandidates.push(e);
              return;
            }
            await super.handleCandidate(e);
          }
        };
        c();
        var Ese = w(uh(), 1);
        me();
        c();
        var DPe = (t) => {
          let e = t.on || t.addListener || t.addEventListener, r = t.off || t.removeListener || t.removeEventListener;
          if (!e || !r)
            throw new TypeError("Emitter is not compatible");
          return { addListener: e.bind(t), removeListener: r.bind(t) };
        };
        function kPe(t, e, r) {
          let n, i2 = new Promise((o, s) => {
            if (r = { rejectionEvents: ["error"], multiArgs: false, resolveImmediately: false, ...r }, !(r.count >= 0 && (r.count === Number.POSITIVE_INFINITY || Number.isInteger(r.count))))
              throw new TypeError("The `count` option should be at least 0 or more");
            let a = [e].flat(), u = [], { addListener: l, removeListener: f } = DPe(t), h = (...d) => {
              let m = r.multiArgs ? d : d[0];
              r.filter && !r.filter(m) || (u.push(m), r.count === u.length && (n(), o(u)));
            }, p = (d) => {
              n(), s(d);
            };
            n = () => {
              for (let d of a)
                f(d, h);
              for (let d of r.rejectionEvents)
                f(d, p);
            };
            for (let d of a)
              l(d, h);
            for (let d of r.rejectionEvents)
              l(d, p);
            r.resolveImmediately && o(u);
          });
          if (i2.cancel = n, typeof r.timeout == "number") {
            let o = nn(i2, r.timeout);
            return o.cancel = n, o;
          }
          return i2;
        }
        function wse(t, e, r) {
          typeof r == "function" && (r = { filter: r }), r = { ...r, count: 1, resolveImmediately: false };
          let n = kPe(t, e, r), i2 = n.then((o) => o[0]);
          return i2.cancel = n.cancel, i2;
        }
        var bse = w(AP(), 1);
        var IP = C("libp2p:webrtc-peer:initator"), NPe = 1e3, f3 = class extends Rd {
          constructor(e = {}) {
            super({ ...e, logPrefix: "initiator" }), this.handleDataChannelEvent({ channel: this.peerConnection.createDataChannel(e.dataChannelLabel ?? M((0, Ese.default)(20), "hex").slice(0, 7), e.dataChannelInit) }), this.handshake = new CP({ log: this.log, peerConnection: this.peerConnection, wrtc: this.wrtc, offerOptions: e.offerOptions }), this.handshake.addEventListener("signal", (r) => {
              this.dispatchEvent(new ee("signal", { detail: r.detail }));
            });
          }
          handleSignal(e) {
            this.handshake.handleSignal(e).catch((r) => {
              this.log("error handling signal %o %o", e, r);
            });
          }
        }, CP = class extends z1 {
          constructor(e) {
            super(e), this.options = e, this.status = "idle", this.peerConnection.addEventListener("icecandidate", (r) => {
              if (r.candidate == null)
                return;
              let n = { type: "candidate", candidate: { candidate: r.candidate.candidate, sdpMLineIndex: r.candidate.sdpMLineIndex, sdpMid: r.candidate.sdpMid } };
              IP.trace("create candidate", n), this.dispatchEvent(new ee("signal", { detail: n })), this.dispatchEvent(new ee("ice-candidate"));
            });
          }
          async handleRenegotiate() {
            if (this.status === "negotiating") {
              this.log("already negotiating, queueing");
              return;
            }
            this.status = "negotiating";
            let e = await this.peerConnection.createOffer(this.options.offerOptions);
            await this.peerConnection.setLocalDescription(e), await wse(this, "ice-candidate"), await (0, bse.default)(NPe), IP.trace("renegotiate", this.peerConnection.localDescription), this.dispatchEvent(new ee("signal", { detail: this.peerConnection.localDescription ?? e }));
          }
          async handleAnswer(e) {
            IP.trace("handle answer", e), await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(e)), this.status = "idle";
          }
        };
        c();
        var PP = C("libp2p:webrtc-star:socket");
        function Bb(t, e) {
          let { sink: r, source: n } = t, i2 = { remoteAddr: e.remoteAddr, async sink(o) {
            e.signal != null && (o = Pn(o, e.signal));
            try {
              await r(o);
            } catch (s) {
              s.type !== "aborted" && PP.error(s);
            }
          }, source: e.signal != null ? Pn(n, e.signal) : n, timeline: { open: Date.now() }, async close() {
            if (t.closed)
              return;
            let o = Date.now(), s = setTimeout(() => {
              if (i2.remoteAddr != null) {
                let { host: a, port: u } = i2.remoteAddr.toOptions();
                PP("timeout closing socket to %s:%s after %dms, destroying it manually", a, u, Date.now() - o);
              }
              t.closed || t.close().catch((a) => {
                PP.error("could not close socket", a);
              });
            }, 2e3);
            try {
              await t.close();
            } finally {
              clearTimeout(s);
            }
          } };
          return t.addEventListener("close", () => {
            i2.timeline.close == null && (i2.timeline.close = Date.now());
          }, { once: true }), i2;
        }
        c();
        function Mb(t) {
          let e = t.toString().split("/"), r = t.protos()[1].name, n = t.protos()[2].name, i2 = t.stringTuples()[1][1];
          if (r !== "tcp" || n !== "ws" && n !== "wss")
            throw new Error(`invalid multiaddr: ${t.toString()}`);
          if (!j.isName(t))
            return `http://${e[2]}:${e[4]}`;
          if (n === "ws")
            return `http://${e[2]}${i2 == null || i2 === "80" ? "" : `:${i2}`}`;
          if (n === "wss")
            return `https://${e[2]}${i2 == null || i2 === "443" ? "" : `:${i2}`}`;
          throw new Error("invalid multiaddr: " + t.toString());
        }
        function _se(t) {
          let e = "/libp2p-webrtc-star";
          if (t.startsWith(e)) {
            t = t.substring(e.length, t.length);
            let r = new j(t), n = r.stringTuples().filter((i2) => i2[0] === 421)[0];
            if (n[1] == null)
              throw new Error("invalid multiaddr: " + t);
            r = r.decapsulate("p2p"), r = r.encapsulate("/p2p-webrtc-star"), r = r.encapsulate(`/p2p/${n[1]}`), t = r.toString();
          }
          return t;
        }
        var wi = C("libp2p:webrtc-star:listener"), LPe = { transports: ["websocket"], "force new connection": true, path: "/socket.io-next/" }, DP = class extends Ue {
          constructor(e, r, n, i2, o) {
            super(), this.signallingAddr = r, this.socket = c3(e, LPe), this.connections = [], this.channels = /* @__PURE__ */ new Map(), this.pendingSignals = /* @__PURE__ */ new Map(), this.upgrader = n, this.handler = i2, this.channelOptions = o, this.handleWsHandshake = this.handleWsHandshake.bind(this), this.socket.once("connect_error", (s) => {
              this.dispatchEvent(new ee("error", { detail: s }));
            }), this.socket.once("error", (s) => {
              this.dispatchEvent(new ee("error", { detail: s }));
            }), this.socket.on("ws-handshake", this.handleWsHandshake), this.socket.on("ws-peer", (s) => {
              this.dispatchEvent(new ee("peer", { detail: s }));
            }), this.socket.on("connect", () => this.socket.emit("ss-join", r.toString())), this.socket.once("connect", () => {
              this.dispatchEvent(new ee("listening"));
            });
          }
          _createChannel(e, r, n) {
            let i2 = { ...this.channelOptions }, o = new l3(i2), s = (a) => {
              let u = a.detail;
              wi.error("incoming connection errored", u);
            };
            return o.addEventListener("error", s), o.addEventListener("close", () => {
              o.removeEventListener("error", s);
            }, { once: true }), o.addEventListener("signal", (a) => {
              let u = a.detail;
              this.socket.emit("ss-handshake", { intentId: e, srcMultiaddr: r, dstMultiaddr: n, answer: true, signal: u });
            }), o.addEventListener("ready", () => {
              let a = Bb(o, { remoteAddr: this.signallingAddr });
              wi("new inbound connection %s", a.remoteAddr);
              try {
                this.upgrader.upgradeInbound(a).then((u) => {
                  wi("inbound connection %s upgraded", a.remoteAddr), this.connections.push(a);
                  let l = () => {
                    this.connections = this.connections.filter((f) => f !== a), this.channels.delete(e), this.pendingSignals.delete(e);
                  };
                  o.addEventListener("close", l, { once: true }), this.dispatchEvent(new ee("connection", { detail: u })), this.handler(u);
                }).catch((u) => {
                  wi.error("inbound connection failed to upgrade", u), a.close().catch((l) => {
                    wi.error("inbound connection failed to close after failing to upgrade", l);
                  });
                });
              } catch (u) {
                wi.error("inbound connection failed to upgrade", u), a.close().catch((l) => {
                  wi.error("inbound connection failed to close after failing to upgrade", l);
                });
              }
            }, { once: true }), o;
          }
          handleWsHandshake(e) {
            if (wi('incoming handshake. signal type "%s" is answer %s', e.signal.type, e.answer), e.answer === true || e.err != null || e.intentId == null)
              return;
            let r = e.intentId, n = this.pendingSignals.get(r);
            n == null && (n = [], this.pendingSignals.set(r, n)), n.push(e);
            let i2 = this.channels.get(r);
            if (i2 == null) {
              if (e.signal.type !== "offer") {
                wi("handshake is not an offer and channel does not exist, buffering until we receive an offer");
                return;
              }
              wi("creating new channel to handle offer handshake"), i2 = this._createChannel(e.intentId, e.srcMultiaddr, e.dstMultiaddr), this.channels.set(r, i2);
            } else
              wi("channel already exists, using it to handle handshake");
            for (; n.length > 0; ) {
              let o = n.shift();
              o?.signal != null && i2.handleSignal(o.signal);
            }
          }
          async close() {
            this.socket.emit("ss-leave", this.signallingAddr.toString()), this.socket.removeAllListeners(), this.socket.close(), await Promise.all([...this.connections.map(async (e) => await e.close()), ...Array.from(this.channels.values()).map(async (e) => await e.close())]), this.dispatchEvent(new ee("close"));
          }
        }, kP = class extends Ue {
          constructor(e, r, n, i2, o) {
            super(), this.upgrader = e, this.handler = r, this.peerId = n, this.transport = i2, this.options = o;
          }
          async listen(e) {
            if (this.listeningAddr != null)
              throw (0, Sse.default)(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
            let r = Ar();
            this.listeningAddr = e;
            let n;
            e.protoCodes().includes(421) ? n = e : n = e.encapsulate(`/p2p/${this.peerId.toString()}`), this.signallingUrl = Mb(e), wi("connecting to signalling server on: %s", this.signallingUrl);
            let i2 = new DP(this.signallingUrl, n, this.upgrader, this.handler, this.options.channelOptions);
            return i2.addEventListener("error", (o) => {
              let s = o.detail;
              wi("error connecting to signalling server %o", s), i2.close().catch((a) => {
                wi.error("error closing server after error", a);
              }), r.reject(s);
            }), i2.addEventListener("listening", () => {
              wi("connected to signalling server"), this.dispatchEvent(new ee("listening")), r.resolve();
            }), i2.addEventListener("peer", (o) => {
              this.transport.peerDiscovered(o.detail);
            }), i2.addEventListener("connection", (o) => {
              let s = o.detail;
              if (s.remoteAddr == null)
                try {
                  s.remoteAddr = e.decapsulateCode(421).encapsulate(`/p2p/${s.remotePeer.toString()}`);
                } catch (a) {
                  wi.error("could not determine remote address", a);
                }
              this.dispatchEvent(new ee("connection", { detail: s }));
            }), this.transport.sigServers.set(this.signallingUrl, i2), await r.promise;
          }
          async close() {
            if (this.signallingUrl != null) {
              let e = this.transport.sigServers.get(this.signallingUrl);
              e != null && (await e.close(), this.transport.sigServers.delete(this.signallingUrl));
            }
            this.dispatchEvent(new ee("close")), this.listeningAddr = void 0;
          }
          getAddrs() {
            return this.listeningAddr != null ? [this.listeningAddr] : [];
          }
        };
        function xse(t, e, r, n, i2) {
          return new kP(t, e, r, n, i2);
        }
        var Rse = w(uh(), 1);
        c();
        var H1 = Symbol.for("@libp2p/transport");
        c();
        var rc = Symbol.for("@libp2p/peer-discovery");
        var MPe = "RTCPeerConnection" in globalThis, Ad = C("libp2p:webrtc-star"), UPe = () => {
        }, NP = class extends Ue {
          constructor() {
            super(...arguments), this.started = false;
          }
          get [rc]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/webrtc-star-discovery";
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started = true;
          }
          async stop() {
            this.started = false;
          }
          dispatchEvent(e) {
            return this.isStarted() ? super.dispatchEvent(e) : false;
          }
        }, Fb = class {
          constructor(e) {
            this.components = new He(), e?.wrtc != null && (this.wrtc = e.wrtc), this.sigServers = /* @__PURE__ */ new Map(), this.discovery = new NP(), this.peerDiscovered = this.peerDiscovered.bind(this);
          }
          get [H1]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/webrtc-star";
          }
          init(e) {
            this.components = e;
          }
          async dial(e, r) {
            let n = await this._connect(e, r), i2 = Bb(n, { remoteAddr: e, signal: r.signal });
            Ad("new outbound connection %s", i2.remoteAddr);
            let o = await r.upgrader.upgradeOutbound(i2);
            return Ad("outbound connection %s upgraded", i2.remoteAddr), o;
          }
          async _connect(e, r) {
            if (r.signal?.aborted === true)
              throw new Jl();
            let n = { ...r.channelOptions ?? {} };
            this.wrtc != null && (n.wrtc = this.wrtc);
            let i2 = e.toOptions(), o = M((0, Rse.default)(36), "hex");
            return await new Promise((s, a) => {
              let u = this.sigServers.get(Mb(e));
              if (u?.socket == null)
                return a((0, Ub.default)(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
              let l = false;
              Ad("dialing %s:%s", i2.host, i2.port);
              let f = new f3(n), h = (y) => {
                let g = y.detail;
                if (!l) {
                  let E = `connection error ${i2.host}:${i2.port}: ${g.message}`;
                  Ad.error(E), m(g);
                }
              }, p = () => {
                l = true, Ad("connection opened %s:%s", i2.host, i2.port), m();
              }, d = () => {
                Ad.error("connection aborted %s:%s", i2.host, i2.port), f.close().finally(() => {
                  m(new Jl());
                });
              }, m = (y) => {
                f.removeEventListener("ready", p), r.signal?.removeEventListener("abort", d), y == null ? s(f) : a(y);
              };
              f.addEventListener("ready", p, { once: true }), f.addEventListener("close", () => {
                f.removeEventListener("error", h);
              }), r.signal?.addEventListener("abort", d), f.addEventListener("signal", (y) => {
                let g = y.detail;
                u.socket.emit("ss-handshake", { intentId: o, srcMultiaddr: u.signallingAddr.toString(), dstMultiaddr: e.toString(), signal: g });
              }), u.socket.on("ws-handshake", (y) => {
                y.intentId === o && y.err != null && f.close().finally(() => {
                  a((0, Ub.default)(new Error(y.err), "ERR_SIGNALLING_FAILED"));
                }), !(y.intentId !== o || y.answer == null || f.closed) && f.handleSignal(y.signal);
              });
            });
          }
          createListener(e) {
            if (!MPe && this.wrtc == null)
              throw (0, Ub.default)(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
            return e.channelOptions = e.channelOptions ?? {}, this.wrtc != null && (e.channelOptions.wrtc = this.wrtc), xse(e.upgrader, e.handler ?? UPe, this.components.getPeerId(), this, e);
          }
          filter(e) {
            return e = Array.isArray(e) ? e : [e], e.filter((r) => r.protoCodes().includes(290) ? false : X6.matches(r));
          }
          peerDiscovered(e) {
            Ad("peer discovered: %s", e), e = _se(e);
            let r = new j(e), n = r.getPeerId();
            if (n == null)
              return;
            let i2 = ue(n);
            this.discovery.dispatchEvent(new ee("peer", { detail: { id: i2, multiaddrs: [r], protocols: [] } }));
          }
        };
        function Ase() {
          let t = new Fb();
          return { transports: [t], peerDiscovery: [t.discovery], connectionManager: { maxParallelDials: 150, maxDialsPerPeer: 4, dialTimeout: 1e4, autoDial: true }, nat: { enabled: false }, metrics: { enabled: true } };
        }
        c();
        c();
        c();
        var d3 = w(K(), 1);
        c();
        var _t;
        (function(t) {
          t.NOT_STARTED_YET = "The libp2p node is not started yet", t.DHT_DISABLED = "DHT is not available", t.PUBSUB_DISABLED = "PubSub is not available", t.CONN_ENCRYPTION_REQUIRED = "At least one connection encryption module is required", t.ERR_TRANSPORTS_REQUIRED = "At least one transport module is required", t.ERR_PROTECTOR_REQUIRED = "Private network is enforced, but no protector was provided", t.NOT_FOUND = "Not found";
        })(_t || (_t = {}));
        var q;
        (function(t) {
          t.DHT_DISABLED = "ERR_DHT_DISABLED", t.ERR_PUBSUB_DISABLED = "ERR_PUBSUB_DISABLED", t.PUBSUB_NOT_STARTED = "ERR_PUBSUB_NOT_STARTED", t.DHT_NOT_STARTED = "ERR_DHT_NOT_STARTED", t.CONN_ENCRYPTION_REQUIRED = "ERR_CONN_ENCRYPTION_REQUIRED", t.ERR_TRANSPORTS_REQUIRED = "ERR_TRANSPORTS_REQUIRED", t.ERR_PROTECTOR_REQUIRED = "ERR_PROTECTOR_REQUIRED", t.ERR_PEER_DIAL_INTERCEPTED = "ERR_PEER_DIAL_INTERCEPTED", t.ERR_CONNECTION_INTERCEPTED = "ERR_CONNECTION_INTERCEPTED", t.ERR_INVALID_PROTOCOLS_FOR_STREAM = "ERR_INVALID_PROTOCOLS_FOR_STREAM", t.ERR_CONNECTION_ENDED = "ERR_CONNECTION_ENDED", t.ERR_CONNECTION_FAILED = "ERR_CONNECTION_FAILED", t.ERR_NODE_NOT_STARTED = "ERR_NODE_NOT_STARTED", t.ERR_ALREADY_ABORTED = "ERR_ALREADY_ABORTED", t.ERR_TOO_MANY_ADDRESSES = "ERR_TOO_MANY_ADDRESSES", t.ERR_NO_VALID_ADDRESSES = "ERR_NO_VALID_ADDRESSES", t.ERR_RELAYED_DIAL = "ERR_RELAYED_DIAL", t.ERR_DIALED_SELF = "ERR_DIALED_SELF", t.ERR_DISCOVERED_SELF = "ERR_DISCOVERED_SELF", t.ERR_DUPLICATE_TRANSPORT = "ERR_DUPLICATE_TRANSPORT", t.ERR_ENCRYPTION_FAILED = "ERR_ENCRYPTION_FAILED", t.ERR_HOP_REQUEST_FAILED = "ERR_HOP_REQUEST_FAILED", t.ERR_INVALID_KEY = "ERR_INVALID_KEY", t.ERR_INVALID_MESSAGE = "ERR_INVALID_MESSAGE", t.ERR_INVALID_PARAMETERS = "ERR_INVALID_PARAMETERS", t.ERR_INVALID_PEER = "ERR_INVALID_PEER", t.ERR_MUXER_UNAVAILABLE = "ERR_MUXER_UNAVAILABLE", t.ERR_NOT_FOUND = "ERR_NOT_FOUND", t.ERR_TIMEOUT = "ERR_TIMEOUT", t.ERR_TRANSPORT_UNAVAILABLE = "ERR_TRANSPORT_UNAVAILABLE", t.ERR_TRANSPORT_DIAL_FAILED = "ERR_TRANSPORT_DIAL_FAILED", t.ERR_UNSUPPORTED_PROTOCOL = "ERR_UNSUPPORTED_PROTOCOL", t.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED = "ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED", t.ERR_INVALID_MULTIADDR = "ERR_INVALID_MULTIADDR", t.ERR_SIGNATURE_NOT_VALID = "ERR_SIGNATURE_NOT_VALID", t.ERR_FIND_SELF = "ERR_FIND_SELF", t.ERR_NO_ROUTERS_AVAILABLE = "ERR_NO_ROUTERS_AVAILABLE", t.ERR_CONNECTION_NOT_MULTIPLEXED = "ERR_CONNECTION_NOT_MULTIPLEXED", t.ERR_NO_DIAL_TOKENS = "ERR_NO_DIAL_TOKENS", t.ERR_KEYCHAIN_REQUIRED = "ERR_KEYCHAIN_REQUIRED", t.ERR_INVALID_CMS = "ERR_INVALID_CMS", t.ERR_MISSING_KEYS = "ERR_MISSING_KEYS", t.ERR_NO_KEY = "ERR_NO_KEY", t.ERR_INVALID_KEY_NAME = "ERR_INVALID_KEY_NAME", t.ERR_INVALID_KEY_TYPE = "ERR_INVALID_KEY_TYPE", t.ERR_KEY_ALREADY_EXISTS = "ERR_KEY_ALREADY_EXISTS", t.ERR_INVALID_KEY_SIZE = "ERR_INVALID_KEY_SIZE", t.ERR_KEY_NOT_FOUND = "ERR_KEY_NOT_FOUND", t.ERR_OLD_KEY_NAME_INVALID = "ERR_OLD_KEY_NAME_INVALID", t.ERR_NEW_KEY_NAME_INVALID = "ERR_NEW_KEY_NAME_INVALID", t.ERR_PASSWORD_REQUIRED = "ERR_PASSWORD_REQUIRED", t.ERR_PEM_REQUIRED = "ERR_PEM_REQUIRED", t.ERR_CANNOT_READ_KEY = "ERR_CANNOT_READ_KEY", t.ERR_MISSING_PRIVATE_KEY = "ERR_MISSING_PRIVATE_KEY", t.ERR_MISSING_PUBLIC_KEY = "ERR_MISSING_PUBLIC_KEY", t.ERR_INVALID_OLD_PASS_TYPE = "ERR_INVALID_OLD_PASS_TYPE", t.ERR_INVALID_NEW_PASS_TYPE = "ERR_INVALID_NEW_PASS_TYPE", t.ERR_INVALID_PASS_LENGTH = "ERR_INVALID_PASS_LENGTH", t.ERR_NOT_IMPLEMENTED = "ERR_NOT_IMPLEMENTED", t.ERR_WRONG_PING_ACK = "ERR_WRONG_PING_ACK", t.ERR_INVALID_RECORD = "ERR_INVALID_RECORD", t.ERR_ALREADY_SUCCEEDED = "ERR_ALREADY_SUCCEEDED";
        })(q || (q = {}));
        c();
        var Tse = w(K(), 1), Ise = w(Gi(), 1), Cse = w(ei(), 1);
        async function* h3(t, e) {
          yield* (0, Cse.default)(t, async (r) => (await e.addressBook.add(r.id, r.multiaddrs), r));
        }
        function Kb(t) {
          let e = /* @__PURE__ */ new Set();
          return (0, Ise.default)(t, (r) => e.has(r.id.toString()) ? false : (e.add(r.id.toString()), true));
        }
        async function* Vb(t, e = 1) {
          let r = 0;
          for await (let n of t)
            r++, yield n;
          if (r < e)
            throw (0, Tse.default)(new Error("not found"), "NOT_FOUND");
        }
        var kse = w($o(), 1), LP = w(Fc(), 1);
        var Nse = w(Gc(), 1), Ose = w(Ci(), 1), Lse = w(Gi(), 1), zb = w(OP(), 1), Bse = w(In(), 1), Dse = C("libp2p:peer-routing"), qb = class {
          constructor(e, r) {
            this.components = e, this.routers = r.routers, this.refreshManagerInit = r.refreshManager ?? {}, this.started = false, this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started || this.routers.length === 0 || this.timeoutId != null || this.refreshManagerInit.enabled === false || (this.timeoutId = (0, zb.setDelayedInterval)(this._findClosestPeersTask, this.refreshManagerInit.interval, this.refreshManagerInit.bootDelay), this.started = true);
          }
          async _findClosestPeersTask() {
            if (this.abortController == null)
              try {
                this.abortController = new kse.TimeoutController(this.refreshManagerInit.timeout ?? 1e4);
                try {
                  (0, Bse.setMaxListeners)?.(1 / 0, this.abortController.signal);
                } catch {
                }
                await (0, Ose.default)(this.getClosestPeers(this.components.getPeerId().toBytes(), { signal: this.abortController.signal }));
              } catch (e) {
                Dse.error(e);
              } finally {
                this.abortController?.clear(), this.abortController = void 0;
              }
          }
          async stop() {
            (0, zb.clearDelayedInterval)(this.timeoutId), this.abortController?.abort(), this.started = false;
          }
          async findPeer(e, r) {
            if (this.routers.length === 0)
              throw (0, d3.default)(new Error("No peer routers available"), q.ERR_NO_ROUTERS_AVAILABLE);
            if (e.toString() === this.components.getPeerId().toString())
              throw (0, d3.default)(new Error("Should not try to find self"), q.ERR_FIND_SELF);
            let n = await Te((0, LP.default)(...this.routers.map((i2) => async function* () {
              try {
                yield await i2.findPeer(e, r);
              } catch (o) {
                Dse.error(o);
              }
            }())), (i2) => (0, Lse.default)(i2, Boolean), (i2) => h3(i2, this.components.getPeerStore()), async (i2) => await (0, Nse.default)(i2));
            if (n != null)
              return n;
            throw (0, d3.default)(new Error(_t.NOT_FOUND), q.ERR_NOT_FOUND);
          }
          async *getClosestPeers(e, r) {
            if (this.routers.length === 0)
              throw (0, d3.default)(new Error("No peer routers available"), q.ERR_NO_ROUTERS_AVAILABLE);
            yield* Te((0, LP.default)(...this.routers.map((n) => n.getClosestPeers(e, r))), (n) => h3(n, this.components.getPeerStore()), (n) => Kb(n), (n) => Vb(n));
          }
        };
        c();
        var ff = w(K(), 1);
        var Mse = w(Ci(), 1), Use = w(Fc(), 1);
        var Hb = class {
          constructor(e, r) {
            this.routers = r.routers ?? [], this.started = false, this.components = e;
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started = true;
          }
          async stop() {
            this.started = false;
          }
          async *findProviders(e, r = {}) {
            if (this.routers.length === 0)
              throw (0, ff.default)(new Error("No content this.routers available"), q.ERR_NO_ROUTERS_AVAILABLE);
            yield* Te((0, Use.default)(...this.routers.map((n) => n.findProviders(e, r))), (n) => h3(n, this.components.getPeerStore()), (n) => Kb(n), (n) => Vb(n));
          }
          async provide(e, r = {}) {
            if (this.routers.length === 0)
              throw (0, ff.default)(new Error("No content routers available"), q.ERR_NO_ROUTERS_AVAILABLE);
            await Promise.all(this.routers.map(async (n) => await n.provide(e, r)));
          }
          async put(e, r, n) {
            if (!this.isStarted())
              throw (0, ff.default)(new Error(_t.NOT_STARTED_YET), q.DHT_NOT_STARTED);
            let i2 = this.components.getDHT();
            i2 != null && await (0, Mse.default)(i2.put(e, r, n));
          }
          async get(e, r) {
            if (!this.isStarted())
              throw (0, ff.default)(new Error(_t.NOT_STARTED_YET), q.DHT_NOT_STARTED);
            let n = this.components.getDHT();
            if (n != null) {
              for await (let i2 of n.get(e, r))
                if (i2.name === "VALUE")
                  return i2.value;
            }
            throw (0, ff.default)(new Error(_t.NOT_FOUND), q.ERR_NOT_FOUND);
          }
          async *getMany(e, r, n) {
            if (!this.isStarted())
              throw (0, ff.default)(new Error(_t.NOT_STARTED_YET), q.DHT_NOT_STARTED);
            if (r == null || r === 0)
              return;
            let i2 = 0, o = this.components.getDHT();
            if (o != null) {
              for await (let s of o.get(e, n))
                if (s.name === "VALUE" && (yield { from: s.from, val: s.value }, i2++, i2 === r))
                  break;
            }
            if (i2 === 0)
              throw (0, ff.default)(new Error(_t.NOT_FOUND), q.ERR_NOT_FOUND);
          }
        };
        c();
        var BP = w(K(), 1);
        function zPe(t) {
          let e = t.getPeerId();
          if (e == null)
            throw (0, BP.default)(new Error(`${t.toString()} does not have a valid peer type`), q.ERR_INVALID_MULTIADDR);
          try {
            return ue(e);
          } catch {
            throw (0, BP.default)(new Error(`${t.toString()} is not a valid peer type`), q.ERR_INVALID_MULTIADDR);
          }
        }
        function Td(t) {
          if (Go(t))
            return { id: t, multiaddrs: [], protocols: [] };
          typeof t == "string" && (t = new j(t));
          let e;
          return j.isMultiaddr(t) && (e = t, t = zPe(t)), { id: t, multiaddrs: e != null ? [e] : [], protocols: [] };
        }
        c();
        var HPe = (t) => t, $b = class extends Ue {
          constructor(e, r) {
            super();
            let { listen: n = [], announce: i2 = [] } = r;
            this.components = e, this.listen = new Set(n.map((o) => o.toString())), this.announce = new Set(i2.map((o) => o.toString())), this.observed = /* @__PURE__ */ new Set(), this.announceFilter = r.announceFilter ?? HPe;
          }
          getListenAddrs() {
            return Array.from(this.listen).map((e) => new j(e));
          }
          getAnnounceAddrs() {
            return Array.from(this.announce).map((e) => new j(e));
          }
          getObservedAddrs() {
            return Array.from(this.observed).map((e) => new j(e));
          }
          addObservedAddr(e) {
            let r = new j(e), n = r.getPeerId();
            n != null && ue(n).equals(this.components.getPeerId()) && (r = r.decapsulate(new j(`/p2p/${this.components.getPeerId().toString()}`)));
            let i2 = r.toString();
            this.observed.has(i2) || (this.observed.add(i2), this.dispatchEvent(new ee("change:addresses")));
          }
          getAddresses() {
            let e = this.getAnnounceAddrs().map((n) => n.toString());
            e.length === 0 && (e = this.components.getTransportManager().getAddrs().map((n) => n.toString())), e = e.concat(this.getObservedAddrs().map((n) => n.toString()));
            let r = new Set(e);
            return this.announceFilter(Array.from(r).map((n) => new j(n))).map((n) => n.getPeerId() === this.components.getPeerId().toString() ? n : n.encapsulate(`/p2p/${this.components.getPeerId().toString()}`));
          }
        };
        c();
        var WP = w(K(), 1);
        c();
        c();
        var Fse = C("libp2p:connection-manager:latency-monitor:visibility-change-emitter"), Gb = class extends Ue {
          constructor() {
            super(), this.hidden = "hidden", this.visibilityChange = "visibilityChange", globalThis.document != null && (this._initializeVisibilityVarNames(), this._addVisibilityChangeListener());
          }
          _initializeVisibilityVarNames() {
            let e = "hidden", r = "visibilitychange";
            typeof globalThis.document.hidden < "u" ? (e = "hidden", r = "visibilitychange") : typeof globalThis.document.mozHidden < "u" ? (e = "mozHidden", r = "mozvisibilitychange") : typeof globalThis.document.msHidden < "u" ? (e = "msHidden", r = "msvisibilitychange") : typeof globalThis.document.webkitHidden < "u" && (e = "webkitHidden", r = "webkitvisibilitychange"), this.hidden = e, this.visibilityChange = r;
          }
          _addVisibilityChangeListener() {
            typeof globalThis.document.addEventListener > "u" || typeof document[this.hidden] > "u" ? Fse("Checking page visibility requires a browser that supports the Page Visibility API.") : globalThis.document.addEventListener(this.visibilityChange, this._handleVisibilityChange.bind(this), false);
          }
          isVisible() {
            if (!(this.hidden === void 0 || document[this.hidden] === void 0))
              return document[this.hidden] == null;
          }
          _handleVisibilityChange() {
            let e = globalThis.document[this.hidden] === false;
            Fse(e ? "Page Visible" : "Page Hidden"), this.dispatchEvent(new ee("visibilityChange", { detail: e }));
          }
        };
        var lu = C("libp2p:connection-manager:latency-monitor"), Wb = class extends Ue {
          constructor(e = {}) {
            super();
            let { latencyCheckIntervalMs: r, dataEmitIntervalMs: n, asyncTestFn: i2, latencyRandomPercentage: o } = e;
            this.latencyCheckIntervalMs = r ?? 500, this.latencyRandomPercentage = o ?? 10, this.latencyCheckMultiply = 2 * (this.latencyRandomPercentage / 100) * this.latencyCheckIntervalMs, this.latencyCheckSubtract = this.latencyCheckMultiply / 2, this.dataEmitIntervalMs = n === null || n === 0 ? void 0 : n ?? 5 * 1e3, lu("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", this.latencyCheckIntervalMs, this.dataEmitIntervalMs), this.dataEmitIntervalMs != null ? lu("Expecting ~%s events per summary", this.latencyCheckIntervalMs / this.dataEmitIntervalMs) : lu("Not emitting summaries"), this.asyncTestFn = i2, globalThis.process?.hrtime != null ? (lu("Using process.hrtime for timing"), this.now = globalThis.process.hrtime, this.getDeltaMS = (s) => {
              let a = this.now(s);
              return a[0] * 1e3 + a[1] / 1e6;
            }) : typeof window < "u" && window.performance?.now != null ? (lu("Using performance.now for timing"), this.now = window.performance.now.bind(window.performance), this.getDeltaMS = (s) => Math.round(this.now() - s)) : (lu("Using Date.now for timing"), this.now = Date.now, this.getDeltaMS = (s) => this.now() - s), this.latencyData = this.initLatencyData();
          }
          start() {
            $Pe() && (this.visibilityChangeEmitter = new Gb(), this.visibilityChangeEmitter.addEventListener("visibilityChange", (e) => {
              let { detail: r } = e;
              r ? this._startTimers() : (this._emitSummary(), this._stopTimers());
            })), this.visibilityChangeEmitter?.isVisible() === true && this._startTimers();
          }
          stop() {
            this._stopTimers();
          }
          _startTimers() {
            this.checkLatencyID == null && (this.checkLatency(), this.dataEmitIntervalMs != null && (this.emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs), typeof this.emitIntervalID.unref == "function" && this.emitIntervalID.unref()));
          }
          _stopTimers() {
            this.checkLatencyID != null && (clearTimeout(this.checkLatencyID), this.checkLatencyID = void 0), this.emitIntervalID != null && (clearInterval(this.emitIntervalID), this.emitIntervalID = void 0);
          }
          _emitSummary() {
            let e = this.getSummary();
            e.events > 0 && this.dispatchEvent(new ee("data", { detail: e }));
          }
          getSummary() {
            let e = { events: this.latencyData.events, minMs: this.latencyData.minMs, maxMs: this.latencyData.maxMs, avgMs: this.latencyData.events > 0 ? this.latencyData.totalMs / this.latencyData.events : Number.POSITIVE_INFINITY, lengthMs: this.getDeltaMS(this.latencyData.startTime) };
            return this.latencyData = this.initLatencyData(), lu.trace("Summary: %O", e), e;
          }
          checkLatency() {
            let e = Math.random() * this.latencyCheckMultiply - this.latencyCheckSubtract, r = { deltaOffset: Math.ceil(this.latencyCheckIntervalMs + e), startTime: this.now() }, n = () => {
              if (this.checkLatencyID == null)
                return;
              let i2 = this.getDeltaMS(r.startTime) - r.deltaOffset;
              this.checkLatency(), this.latencyData.events++, this.latencyData.minMs = Math.min(this.latencyData.minMs, i2), this.latencyData.maxMs = Math.max(this.latencyData.maxMs, i2), this.latencyData.totalMs += i2, lu.trace("MS: %s Data: %O", i2, this.latencyData);
            };
            lu.trace("localData: %O", r), this.checkLatencyID = setTimeout(() => {
              this.asyncTestFn != null ? (r.deltaOffset = 0, r.startTime = this.now(), this.asyncTestFn(n)) : (r.deltaOffset -= 1, n());
            }, r.deltaOffset), typeof this.checkLatencyID.unref == "function" && this.checkLatencyID.unref();
          }
          initLatencyData() {
            return { startTime: this.now(), minMs: Number.POSITIVE_INFINITY, maxMs: Number.NEGATIVE_INFINITY, events: 0, totalMs: 0 };
          }
        };
        function $Pe() {
          return typeof globalThis.window < "u";
        }
        var jP = w(y2(), 1);
        c();
        var MP = class extends Map {
          constructor(e) {
            super();
            let { system: r, component: n, metric: i2, metrics: o } = e;
            this.system = r ?? "libp2p", this.component = n, this.metric = i2, this.metrics = o, this.updateComponentMetric();
          }
          set(e, r) {
            return super.set(e, r), this.updateComponentMetric(), this;
          }
          delete(e) {
            let r = super.delete(e);
            return this.updateComponentMetric(), r;
          }
          clear() {
            super.clear(), this.updateComponentMetric();
          }
          updateComponentMetric() {
            this.metrics.updateComponentMetric({ system: this.system, component: this.component, metric: this.metric, value: this.size });
          }
        };
        function Dn(t) {
          let { system: e, component: r, metric: n, metrics: i2 } = t, o;
          return i2 != null ? o = new MP({ system: e, component: r, metric: n, metrics: i2 }) : o = /* @__PURE__ */ new Map(), o;
        }
        var wae = w(In(), 1);
        c();
        var jb = "OPEN", UP = "CLOSING", Yb = "CLOSED";
        c();
        var lae = w(Vs(), 1), fae = w(Gi(), 1);
        var j1 = w(K(), 1);
        var hae = w($o(), 1);
        c();
        var nc = class extends Error {
          constructor(e = "The operation was aborted") {
            super(e), this.code = nc.code, this.type = nc.type;
          }
          static get code() {
            return "ABORT_ERR";
          }
          static get type() {
            return "aborted";
          }
        };
        var dae = w(Vi(), 1), pae = w(In(), 1);
        c();
        var p3 = w(K(), 1), Wse = w(Vi(), 1), jse = w($se(), 1), FP = w(In(), 1);
        var Gse = C("libp2p:dialer:dial-request"), Qb = class {
          constructor(e) {
            let { addrs: r, dialAction: n, dialer: i2 } = e;
            this.addrs = r, this.dialer = i2, this.dialAction = n;
          }
          async run(e = {}) {
            let r = this.dialer.getTokens(this.addrs.length);
            if (r.length < 1)
              throw (0, p3.default)(new Error("No dial tokens available"), q.ERR_NO_DIAL_TOKENS);
            let n = new jse.default();
            for (let a of r)
              n.push(a).catch((u) => {
                Gse.error(u);
              });
            let i2 = this.addrs.map(() => {
              let a = new AbortController();
              try {
                (0, FP.setMaxListeners)?.(1 / 0, a.signal);
              } catch {
              }
              return a;
            });
            if (e.signal != null)
              try {
                (0, FP.setMaxListeners)?.(1 / 0, e.signal);
              } catch {
              }
            let o = 0, s = false;
            try {
              return await Promise.any(this.addrs.map(async (a, u) => {
                let l = await n.shift();
                if (s)
                  throw this.dialer.releaseToken(r.splice(r.indexOf(l), 1)[0]), (0, p3.default)(new Error("dialAction already succeeded"), q.ERR_ALREADY_SUCCEEDED);
                let f = i2[u];
                if (f == null)
                  throw (0, p3.default)(new Error("dialAction did not come with an AbortController"), q.ERR_INVALID_PARAMETERS);
                let h;
                try {
                  let p = f.signal;
                  h = await this.dialAction(a, { ...e, signal: e.signal != null ? (0, Wse.anySignal)([p, e.signal]) : p }), i2[u] = void 0;
                } finally {
                  o++, this.addrs.length - o >= r.length ? n.push(l).catch((p) => {
                    Gse.error(p);
                  }) : this.dialer.releaseToken(r.splice(r.indexOf(l), 1)[0]);
                }
                if (h == null)
                  throw (0, p3.default)(new Error("dialAction led to empty object"), q.ERR_TRANSPORT_DIAL_FAILED);
                return s = true, h;
              }));
            } finally {
              i2.forEach((a) => {
                a !== void 0 && a.abort();
              }), r.forEach((a) => this.dialer.releaseToken(a));
            }
          }
        };
        c();
        c();
        var aae = w(Jb(), 1);
        function zP(t) {
          let { address: e } = t.nodeAddress();
          return Boolean((0, aae.default)(e));
        }
        function W1(t, e) {
          let r = zP(t.multiaddr), n = zP(e.multiaddr);
          return r && !n ? 1 : !r && n || t.isCertified && !e.isCertified ? -1 : !t.isCertified && e.isCertified ? 1 : 0;
        }
        c();
        var cae = { computeThrottleMaxQueueSize: 1e3, computeThrottleTimeout: 2e3, movingAverageIntervals: [6e4, 3e5, 9e5], maxOldPeersRetention: 50 };
        var mae = w(ug(), 1);
        var yae = w(ei(), 1), ic = C("libp2p:dialer"), uae = "dialler", oDe = "pending-dials", sDe = "pending-dial-targets", e_ = class {
          constructor(e = {}) {
            this.components = new He(), this.started = false, this.addressSorter = e.addressSorter ?? W1, this.maxAddrsToDial = e.maxAddrsToDial ?? 25, this.timeout = e.dialTimeout ?? 3e4, this.maxDialsPerPeer = e.maxDialsPerPeer ?? 4, this.tokens = [...new Array(e.maxParallelDials ?? 100)].map((r, n) => n), this.pendingDials = Dn({ component: uae, metric: oDe, metrics: e.metrics }), this.pendingDialTargets = Dn({ component: uae, metric: sDe, metrics: e.metrics });
            for (let [r, n] of Object.entries(e.resolvers ?? {}))
              j.resolvers.set(r, n);
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started = true;
          }
          async stop() {
            this.started = false;
            for (let e of this.pendingDials.values())
              try {
                e.controller.abort();
              } catch (r) {
                ic.error(r);
              }
            this.pendingDials.clear();
            for (let e of this.pendingDialTargets.values())
              e.reject(new nc("Dialer was destroyed"));
            this.pendingDialTargets.clear();
          }
          async dial(e, r = {}) {
            let { id: n, multiaddrs: i2 } = Td(e);
            if (this.components.getPeerId().equals(n))
              throw (0, j1.default)(new Error("Tried to dial self"), q.ERR_DIALED_SELF);
            if (ic("check multiaddrs %p", n), i2 != null && i2.length > 0 && (ic("storing multiaddrs %p", n, i2), await this.components.getPeerStore().addressBook.add(n, i2)), await this.components.getConnectionGater().denyDialPeer(n))
              throw (0, j1.default)(new Error("The dial request is blocked by gater.allowDialPeer"), q.ERR_PEER_DIAL_INTERCEPTED);
            ic("creating dial target for %p", n);
            let o = await this._createCancellableDialTarget(n);
            if (o.addrs.length === 0)
              throw (0, j1.default)(new Error("The dial request has no valid addresses"), q.ERR_NO_VALID_ADDRESSES);
            let s = this.pendingDials.get(o.id) ?? this._createPendingDial(o, r);
            try {
              let a = await s.promise;
              return ic("dial succeeded to %s", o.id), a;
            } catch (a) {
              throw ic("dial failed to %s", o.id, a), s.controller.signal.aborted && (a.code = q.ERR_TIMEOUT), ic.error(a), a;
            } finally {
              s.destroy();
            }
          }
          async _createCancellableDialTarget(e) {
            let r = `${parseInt(String(Math.random() * 1e9), 10).toString()}${Date.now()}`, n = new Promise((i2, o) => {
              this.pendingDialTargets.set(r, { resolve: i2, reject: o });
            });
            try {
              return await Promise.race([this._createDialTarget(e), n]);
            } finally {
              this.pendingDialTargets.delete(r);
            }
          }
          async _createDialTarget(e) {
            let r = await Te(await this.components.getPeerStore().addressBook.get(e), (o) => (0, fae.default)(o, async (s) => !await this.components.getConnectionGater().denyDialMultiaddr(e, s.multiaddr)), (o) => (0, mae.default)(o, this.addressSorter), (o) => (0, yae.default)(o, (s) => {
              let a = s.multiaddr;
              return e.toString() === a.getPeerId() ? a : a.encapsulate(`/p2p/${e.toString()}`);
            }), async (o) => await (0, lae.default)(o)), n = [];
            for (let o of r)
              (await this._resolve(o)).forEach((a) => n.push(a));
            let i2 = n.filter((o) => this.components.getTransportManager().transportForMultiaddr(o));
            if (i2.length > this.maxAddrsToDial)
              throw await this.components.getPeerStore().delete(e), (0, j1.default)(new Error("dial with more addresses than allowed"), q.ERR_TOO_MANY_ADDRESSES);
            return { id: e.toString(), addrs: i2 };
          }
          _createPendingDial(e, r = {}) {
            let n = async (l, f = {}) => {
              if (f.signal?.aborted === true)
                throw (0, j1.default)(new Error("already aborted"), q.ERR_ALREADY_ABORTED);
              return await this.components.getTransportManager().dial(l, f);
            }, i2 = new Qb({ addrs: e.addrs, dialAction: n, dialer: this }), o = new hae.TimeoutController(this.timeout), s = [o.signal];
            r.signal != null && s.push(r.signal);
            let a = (0, dae.anySignal)(s);
            try {
              (0, pae.setMaxListeners)?.(1 / 0, a);
            } catch {
            }
            let u = { dialRequest: i2, controller: o, promise: i2.run({ ...r, signal: a }), destroy: () => {
              o.clear(), this.pendingDials.delete(e.id);
            } };
            return this.pendingDials.set(e.id, u), u;
          }
          getTokens(e) {
            let r = Math.min(e, this.maxDialsPerPeer, this.tokens.length), n = this.tokens.splice(0, r);
            return ic("%d tokens request, returning %d, %d remaining", e, r, this.tokens.length), n;
          }
          releaseToken(e) {
            this.tokens.includes(e) || (ic("token %d released", e), this.tokens.push(e));
          }
          async _resolve(e) {
            if (!e.protoNames().includes("dnsaddr"))
              return [e];
            let n = await this._resolveRecord(e);
            return (await Promise.all(n.map(async (s) => await this._resolve(s)))).flat().reduce((s, a) => (s.find((u) => u.equals(a)) == null && s.push(a), s), []);
          }
          async _resolveRecord(e) {
            try {
              return e = new j(e.toString()), await e.resolve();
            } catch (r) {
              return ic.error(`multiaddr ${e.toString()} could not be resolved`, r), [];
            }
          }
        };
        var ki = C("libp2p:connection-manager"), aDe = { maxConnections: 1 / 0, minConnections: 0, maxData: 1 / 0, maxSentData: 1 / 0, maxReceivedData: 1 / 0, maxEventLoopDelay: 1 / 0, pollInterval: 2e3, autoDialInterval: 1e4, movingAverageInterval: 6e4, defaultPeerValue: 0.5 }, gae = "connection-manager", cDe = "peer-connections", uDe = "peer-values", t_ = class extends Ue {
          constructor(e) {
            if (super(), this.components = new He(), this.opts = Ze.call({ ignoreUndefined: true }, aDe, e), this.opts.maxConnections < this.opts.minConnections)
              throw (0, WP.default)(new Error("Connection Manager maxConnections must be greater than minConnections"), q.ERR_INVALID_PARAMETERS);
            ki("options: %o", this.opts), this.peerValues = Dn({ component: gae, metric: uDe, metrics: this.components.getMetrics() }), this.connections = Dn({ component: gae, metric: cDe, metrics: this.components.getMetrics() }), this.started = false, this._checkMetrics = this._checkMetrics.bind(this), this.latencyMonitor = new Wb({ latencyCheckIntervalMs: e.pollInterval, dataEmitIntervalMs: e.pollInterval });
            try {
              (0, wae.setMaxListeners)?.(1 / 0, this);
            } catch {
            }
            this.dialer = new e_(this.opts), this.onConnect = this.onConnect.bind(this), this.onDisconnect = this.onDisconnect.bind(this);
          }
          init(e) {
            this.components = e, this.dialer.init(e);
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.components.getMetrics() != null && (this.timer = this.timer ?? (0, jP.default)(this._checkMetrics, this.opts.pollInterval)), this.latencyMonitor.start(), this._onLatencyMeasure = this._onLatencyMeasure.bind(this), this.latencyMonitor.addEventListener("data", this._onLatencyMeasure), await this.dialer.start(), this.started = true, ki("started");
          }
          async afterStart() {
            this.components.getUpgrader().addEventListener("connection", this.onConnect), this.components.getUpgrader().addEventListener("connectionEnd", this.onDisconnect);
          }
          async beforeStop() {
            this.components.getUpgrader().removeEventListener("connection", this.onConnect), this.components.getUpgrader().removeEventListener("connectionEnd", this.onDisconnect);
          }
          async stop() {
            this.timer?.clear(), this.latencyMonitor.removeEventListener("data", this._onLatencyMeasure), this.latencyMonitor.stop(), await this.dialer.stop(), this.started = false, await this._close(), ki("stopped");
          }
          async _close() {
            let e = [];
            for (let r of this.connections.values())
              for (let n of r)
                e.push((async () => {
                  try {
                    await n.close();
                  } catch (i2) {
                    ki.error(i2);
                  }
                })());
            ki("closing %d connections", e.length), await Promise.all(e), this.connections.clear();
          }
          setPeerValue(e, r) {
            if (r < 0 || r > 1)
              throw new Error("value should be a number between 0 and 1");
            this.peerValues.set(e.toString(), r);
          }
          async _checkMetrics() {
            let e = this.components.getMetrics();
            if (e != null)
              try {
                let r = e.getGlobal().getMovingAverages(), n = r.dataReceived[this.opts.movingAverageInterval].movingAverage;
                await this._checkMaxLimit("maxReceivedData", n);
                let i2 = r.dataSent[this.opts.movingAverageInterval].movingAverage;
                await this._checkMaxLimit("maxSentData", i2);
                let o = n + i2;
                await this._checkMaxLimit("maxData", o), ki.trace("metrics update", o);
              } finally {
                this.timer = (0, jP.default)(this._checkMetrics, this.opts.pollInterval);
              }
          }
          onConnect(e) {
            this._onConnect(e).catch((r) => {
              ki.error(r);
            });
          }
          async _onConnect(e) {
            let { detail: r } = e;
            if (!this.started) {
              await r.close();
              return;
            }
            let n = r.remotePeer, i2 = n.toString(), o = this.connections.get(i2);
            o != null ? o.push(r) : this.connections.set(i2, [r]), n.publicKey != null && await this.components.getPeerStore().keyBook.set(n, n.publicKey), this.peerValues.has(i2) || this.peerValues.set(i2, this.opts.defaultPeerValue);
            let s = this.getConnections().length, a = s - this.opts.maxConnections;
            await this._checkMaxLimit("maxConnections", s, a), this.dispatchEvent(new ee("peer:connect", { detail: r }));
          }
          onDisconnect(e) {
            let { detail: r } = e;
            if (!this.started)
              return;
            let n = r.remotePeer.toString(), i2 = this.connections.get(n);
            i2 != null && i2.length > 1 ? (i2 = i2.filter((o) => o.id !== r.id), this.connections.set(n, i2)) : i2 != null && (this.connections.delete(n), this.peerValues.delete(r.remotePeer.toString()), this.dispatchEvent(new ee("peer:disconnect", { detail: r })), this.components.getMetrics()?.onPeerDisconnected(r.remotePeer));
          }
          getConnections(e) {
            if (e != null)
              return this.connections.get(e.toString()) ?? [];
            let r = [];
            for (let n of this.connections.values())
              r = r.concat(n);
            return r;
          }
          async openConnection(e, r) {
            ki("dial to %p", e);
            let n = this.getConnections(e);
            if (n.length > 0)
              return ki("had an existing connection to %p", e), n[0];
            let i2 = await this.dialer.dial(e, r), o = this.connections.get(e.toString());
            o == null && (o = [], this.connections.set(e.toString(), o));
            let s = false;
            for (let a of o)
              a.id === i2.id && (s = true);
            return s || o.push(i2), i2;
          }
          async closeConnections(e) {
            let r = this.connections.get(e.toString()) ?? [];
            await Promise.all(r.map(async (n) => await n.close()));
          }
          getAll(e) {
            if (!Go(e))
              throw (0, WP.default)(new Error("peerId must be an instance of peer-id"), q.ERR_INVALID_PARAMETERS);
            let r = e.toString(), n = this.connections.get(r);
            return n != null ? n.filter((i2) => i2.stat.status === jb) : [];
          }
          _onLatencyMeasure(e) {
            let { detail: r } = e;
            this._checkMaxLimit("maxEventLoopDelay", r.avgMs, 1).catch((n) => {
              ki.error(n);
            });
          }
          async _checkMaxLimit(e, r, n = 1) {
            let i2 = this.opts[e];
            ki.trace("checking limit of %s. current value: %d of %d", e, r, i2), r > i2 && (ki("%s: limit exceeded: %p, %d, pruning %d connection(s)", this.components.getPeerId(), e, r, n), await this._maybePruneConnections(n));
          }
          async _maybePruneConnections(e) {
            let r = this.getConnections();
            if (r.length <= this.opts.minConnections || e < 1)
              return;
            let n = Array.from(new Map([...this.peerValues.entries()].sort((o, s) => o[1] - s[1])));
            ki.trace("sorted peer values: %j", n);
            let i2 = [];
            for (let [o] of n) {
              ki("too many connections open - closing a connection to %p", o);
              for (let s of r)
                if (s.remotePeer.toString() === o && i2.push(s), i2.length === e)
                  break;
            }
            await Promise.all(i2.map(async (o) => {
              try {
                await o.close();
              } catch (s) {
                ki.error(s);
              }
              this.onDisconnect(new ee("connectionEnd", { detail: o }));
            }));
          }
        };
        c();
        var YP = w(y2(), 1), Eae = w(Vs(), 1);
        var bae = w(Gi(), 1), _ae = w(ug(), 1), df = C("libp2p:connection-manager:auto-dialler"), lDe = { enabled: true, minConnections: 0, autoDialInterval: 1e4 }, r_ = class {
          constructor(e, r) {
            this.components = e, this.options = Ze.call({ ignoreUndefined: true }, lDe, r), this.running = false, this._autoDial = this._autoDial.bind(this), df("options: %j", this.options);
          }
          isStarted() {
            return this.running;
          }
          async start() {
            if (!this.options.enabled) {
              df("not enabled");
              return;
            }
            this.running = true, this._autoDial().catch((e) => {
              df.error("could start autodial", e);
            }), df("started");
          }
          async stop() {
            if (!this.options.enabled) {
              df("not enabled");
              return;
            }
            this.running = false, this.autoDialTimeout != null && this.autoDialTimeout.clear(), df("stopped");
          }
          async _autoDial() {
            this.autoDialTimeout != null && this.autoDialTimeout.clear();
            let e = this.options.minConnections;
            if (this.components.getConnectionManager().getConnections().length >= e) {
              this.autoDialTimeout = (0, YP.default)(this._autoDial, this.options.autoDialInterval);
              return;
            }
            let r = await this.components.getPeerStore().all(), n = await Te(r.sort(() => Math.random() > 0.5 ? 1 : -1), (i2) => (0, bae.default)(i2, (o) => !o.id.equals(this.components.getPeerId())), (i2) => (0, _ae.default)(i2, (o, s) => s.protocols.length > o.protocols.length || s.id.publicKey != null && o.id.publicKey == null ? 1 : -1), async (i2) => await (0, Eae.default)(i2));
            for (let i2 = 0; this.running && i2 < n.length && this.components.getConnectionManager().getConnections().length < e; i2++) {
              if (!this.running)
                return;
              let o = n[i2];
              if (this.components.getConnectionManager().getConnections(o.id).length === 0) {
                df("connecting to a peerStore stored peer %p", o.id);
                try {
                  await this.components.getConnectionManager().openConnection(o.id);
                } catch (s) {
                  df.error("could not connect to peerStore stored peer", s);
                }
              }
            }
            !this.running || (this.autoDialTimeout = (0, YP.default)(this._autoDial, this.options.autoDialInterval));
          }
        };
        c();
        var Dae = w(K(), 1);
        c();
        var rt;
        (function(t) {
          let e;
          (function(s) {
            s.SUCCESS = "SUCCESS", s.HOP_SRC_ADDR_TOO_LONG = "HOP_SRC_ADDR_TOO_LONG", s.HOP_DST_ADDR_TOO_LONG = "HOP_DST_ADDR_TOO_LONG", s.HOP_SRC_MULTIADDR_INVALID = "HOP_SRC_MULTIADDR_INVALID", s.HOP_DST_MULTIADDR_INVALID = "HOP_DST_MULTIADDR_INVALID", s.HOP_NO_CONN_TO_DST = "HOP_NO_CONN_TO_DST", s.HOP_CANT_DIAL_DST = "HOP_CANT_DIAL_DST", s.HOP_CANT_OPEN_DST_STREAM = "HOP_CANT_OPEN_DST_STREAM", s.HOP_CANT_SPEAK_RELAY = "HOP_CANT_SPEAK_RELAY", s.HOP_CANT_RELAY_TO_SELF = "HOP_CANT_RELAY_TO_SELF", s.STOP_SRC_ADDR_TOO_LONG = "STOP_SRC_ADDR_TOO_LONG", s.STOP_DST_ADDR_TOO_LONG = "STOP_DST_ADDR_TOO_LONG", s.STOP_SRC_MULTIADDR_INVALID = "STOP_SRC_MULTIADDR_INVALID", s.STOP_DST_MULTIADDR_INVALID = "STOP_DST_MULTIADDR_INVALID", s.STOP_RELAY_REFUSED = "STOP_RELAY_REFUSED", s.MALFORMED_MESSAGE = "MALFORMED_MESSAGE";
          })(e = t.Status || (t.Status = {}));
          let r;
          (function(s) {
            s[s.SUCCESS = 100] = "SUCCESS", s[s.HOP_SRC_ADDR_TOO_LONG = 220] = "HOP_SRC_ADDR_TOO_LONG", s[s.HOP_DST_ADDR_TOO_LONG = 221] = "HOP_DST_ADDR_TOO_LONG", s[s.HOP_SRC_MULTIADDR_INVALID = 250] = "HOP_SRC_MULTIADDR_INVALID", s[s.HOP_DST_MULTIADDR_INVALID = 251] = "HOP_DST_MULTIADDR_INVALID", s[s.HOP_NO_CONN_TO_DST = 260] = "HOP_NO_CONN_TO_DST", s[s.HOP_CANT_DIAL_DST = 261] = "HOP_CANT_DIAL_DST", s[s.HOP_CANT_OPEN_DST_STREAM = 262] = "HOP_CANT_OPEN_DST_STREAM", s[s.HOP_CANT_SPEAK_RELAY = 270] = "HOP_CANT_SPEAK_RELAY", s[s.HOP_CANT_RELAY_TO_SELF = 280] = "HOP_CANT_RELAY_TO_SELF", s[s.STOP_SRC_ADDR_TOO_LONG = 320] = "STOP_SRC_ADDR_TOO_LONG", s[s.STOP_DST_ADDR_TOO_LONG = 321] = "STOP_DST_ADDR_TOO_LONG", s[s.STOP_SRC_MULTIADDR_INVALID = 350] = "STOP_SRC_MULTIADDR_INVALID", s[s.STOP_DST_MULTIADDR_INVALID = 351] = "STOP_DST_MULTIADDR_INVALID", s[s.STOP_RELAY_REFUSED = 390] = "STOP_RELAY_REFUSED", s[s.MALFORMED_MESSAGE = 400] = "MALFORMED_MESSAGE";
          })(r || (r = {})), function(s) {
            s.codec = () => xi(r);
          }(e = t.Status || (t.Status = {}));
          let n;
          (function(s) {
            s.HOP = "HOP", s.STOP = "STOP", s.STATUS = "STATUS", s.CAN_HOP = "CAN_HOP";
          })(n = t.Type || (t.Type = {}));
          let i2;
          (function(s) {
            s[s.HOP = 1] = "HOP", s[s.STOP = 2] = "STOP", s[s.STATUS = 3] = "STATUS", s[s.CAN_HOP = 4] = "CAN_HOP";
          })(i2 || (i2 = {})), function(s) {
            s.codec = () => xi(i2);
          }(n = t.Type || (t.Type = {}));
          let o;
          (function(s) {
            s.codec = () => Xe({ 1: { name: "id", codec: ye }, 2: { name: "addrs", codec: ye, repeats: true } }), s.encode = (a) => Qe(a, s.codec()), s.decode = (a) => Ye(a, s.codec());
          })(o = t.Peer || (t.Peer = {})), t.codec = () => Xe({ 1: { name: "type", codec: t.Type.codec(), optional: true }, 2: { name: "srcPeer", codec: t.Peer.codec(), optional: true }, 3: { name: "dstPeer", codec: t.Peer.codec(), optional: true }, 4: { name: "code", codec: t.Status.codec(), optional: true } }), t.encode = (s) => Qe(s, t.codec()), t.decode = (s) => Ye(s, t.codec());
        })(rt || (rt = {}));
        c();
        var fDe = C("libp2p:stream:converter");
        function QP(t, e = {}) {
          let { stream: r, remoteAddr: n } = t, { sink: i2, source: o } = r, s = { async sink(u) {
            e.signal != null && (u = Pn(u, e.signal));
            try {
              await i2(u), await a();
            } catch (l) {
              l.type !== "aborted" && fDe(l);
            }
          }, source: e.signal != null ? Pn(o, e.signal) : o, remoteAddr: n, timeline: { open: Date.now(), close: void 0 }, async close() {
            await i2(async function* () {
              yield new Uint8Array(0);
            }()), await a();
          } };
          async function a() {
            return s.timeline.close == null && (s.timeline.close = Date.now()), await Promise.resolve();
          }
          return s;
        }
        c();
        var fu = "/libp2p/circuit/relay/0.1.0";
        c();
        function vae(t) {
          let e = /* @__PURE__ */ new Map();
          async function r(o) {
            let s = o.toString().split("/p2p-circuit").find((p) => p !== ""), a = new j(s), u = a.getPeerId();
            if (u == null)
              throw new Error("Could not determine relay peer from multiaddr");
            let l = ue(u);
            await t.peerStore.addressBook.add(l, [a]);
            let f = await t.connectionManager.openConnection(l), h = f.remoteAddr.encapsulate("/p2p-circuit");
            e.set(f.remotePeer.toString(), h), i2.dispatchEvent(new ee("listening"));
          }
          function n() {
            let o = [];
            for (let s of e.values())
              o.push(s);
            return o;
          }
          let i2 = Object.assign(new Ue(), { close: async () => await Promise.resolve(), listen: r, getAddrs: n });
          return t.connectionManager.addEventListener("peer:disconnect", (o) => {
            let { detail: s } = o;
            e.delete(s.remotePeer.toString()) && i2.dispatchEvent(new ee("close"));
          }), i2;
        }
        c();
        var XP = w(K(), 1);
        c();
        function Sae(t, e) {
          t.write({ type: rt.Type.STATUS, code: e });
        }
        function n_(t, e) {
          try {
            t.dstPeer?.addrs != null && t.dstPeer.addrs.forEach((r) => new j(r));
          } catch (r) {
            throw Sae(e, t.type === rt.Type.HOP ? rt.Status.HOP_DST_MULTIADDR_INVALID : rt.Status.STOP_DST_MULTIADDR_INVALID), r;
          }
          try {
            t.srcPeer?.addrs != null && t.srcPeer.addrs.forEach((r) => new j(r));
          } catch (r) {
            throw Sae(e, t.type === rt.Type.HOP ? rt.Status.HOP_SRC_MULTIADDR_INVALID : rt.Status.STOP_SRC_MULTIADDR_INVALID), r;
          }
        }
        c();
        c();
        var xae = w(ei(), 1);
        function Io(t) {
          let e = zs(), r = by(t.source), n = Ar(), i2, o = t.sink(async function* () {
            yield* e, yield* await n.promise;
          }());
          o.catch((a) => {
            i2 = a;
          });
          let s = { sink: async (a) => i2 != null ? await Promise.reject(i2) : (n.resolve(a), await o), source: (0, xae.default)(r, (a) => a.slice()) };
          return { reader: r, writer: e, stream: s, rest: () => e.end(), write: e.push, read: async () => {
            let a = await r.next();
            if (a.value != null)
              return a.value.slice();
          } };
        }
        var g3 = C("libp2p:circuit:stream-handler"), hu = class {
          constructor(e) {
            let { stream: r, maxLength: n = 4096 } = e;
            this.stream = r, this.shake = Io(this.stream), this.decoder = Er.fromReader(this.shake.reader, { maxDataLength: n });
          }
          async read() {
            let e = await this.decoder.next();
            if (e.value != null) {
              let r = rt.decode(e.value.slice());
              return g3("read message type", r.type), r;
            }
            g3("read received no value, closing stream"), this.close();
          }
          write(e) {
            g3("write message type %s", e.type), this.shake.write(kr.single(rt.encode(e)).slice());
          }
          rest() {
            return this.shake.rest(), this.shake.stream;
          }
          end(e) {
            this.write(e), this.close();
          }
          close() {
            g3("closing the stream"), this.rest().sink([]).catch((e) => {
              g3.error(e);
            });
          }
        };
        c();
        var w3 = C("libp2p:circuit:stop");
        function Rae(t) {
          let { connection: e, request: r, streamHandler: n } = t;
          try {
            n_(r, n);
          } catch (i2) {
            w3.error("invalid stop request via peer %p %o", e.remotePeer, i2);
            return;
          }
          return w3("stop request is valid"), n.write({ type: rt.Type.STATUS, code: rt.Status.SUCCESS }), n.rest();
        }
        async function Aae(t) {
          let { connection: e, request: r } = t, { stream: n } = await e.newStream([fu]);
          w3("starting stop request to %p", e.remotePeer);
          let i2 = new hu({ stream: n });
          i2.write(r);
          let o = await i2.read();
          if (o == null) {
            i2.close();
            return;
          }
          if (o.code === rt.Status.SUCCESS)
            return w3("stop request to %p was successful", e.remotePeer), i2.rest();
          w3("stop request failed with code %d", o.code), i2.close();
        }
        var ds = C("libp2p:circuit:hop");
        async function Tae(t) {
          let { connection: e, request: r, streamHandler: n, circuit: i2, connectionManager: o } = t;
          if (!i2.hopEnabled())
            return ds("HOP request received but we are not acting as a relay"), n.end({ type: rt.Type.STATUS, code: rt.Status.HOP_CANT_SPEAK_RELAY });
          try {
            n_(r, n);
          } catch (h) {
            ds.error("invalid hop request via peer %p %o", e.remotePeer, h);
            return;
          }
          if (r.dstPeer == null) {
            ds("HOP request received but we do not receive a dstPeer");
            return;
          }
          let s = Ir(r.dstPeer.id), a = o.getConnections(s);
          if (a.length === 0 && !i2.hopActive())
            return ds("HOP request received but we are not connected to the destination peer"), n.end({ type: rt.Type.STATUS, code: rt.Status.HOP_NO_CONN_TO_DST });
          if (a.length === 0)
            return ds("did not have connection to remote peer"), n.end({ type: rt.Type.STATUS, code: rt.Status.HOP_NO_CONN_TO_DST });
          let u = { type: rt.Type.STOP, dstPeer: r.dstPeer, srcPeer: r.srcPeer }, l;
          try {
            ds("performing STOP request");
            let h = await Aae({ connection: a[0], request: u });
            if (h == null)
              throw new Error("Could not stop");
            l = h;
          } catch (h) {
            ds.error(h);
            return;
          }
          ds("hop request from %p is valid", e.remotePeer), n.write({ type: rt.Type.STATUS, code: rt.Status.SUCCESS });
          let f = n.rest();
          return ds("creating related connections"), await Te(f, l, f);
        }
        async function Iae(t) {
          let { connection: e, request: r } = t, { stream: n } = await e.newStream(fu), i2 = new hu({ stream: n });
          i2.write(r);
          let o = await i2.read();
          if (o == null)
            throw (0, XP.default)(new Error("HOP request had no response"), q.ERR_HOP_REQUEST_FAILED);
          if (o.code === rt.Status.SUCCESS)
            return ds("hop request was successful"), i2.rest();
          throw ds("hop request failed with code %d, closing stream", o.code), i2.close(), (0, XP.default)(new Error(`HOP request failed with code "${o.code ?? "unknown"}"`), q.ERR_HOP_REQUEST_FAILED);
        }
        async function Cae(t) {
          let { connection: e } = t, { stream: r } = await e.newStream(fu), n = new hu({ stream: r });
          n.write({ type: rt.Type.CAN_HOP });
          let i2 = await n.read();
          return await n.close(), !(i2 == null || i2.code !== rt.Status.SUCCESS);
        }
        function Pae(t) {
          let { connection: e, streamHandler: r, circuit: n } = t, i2 = n.hopEnabled();
          ds("can hop (%s) request from %p", i2, e.remotePeer), r.end({ type: rt.Type.STATUS, code: i2 ? rt.Status.SUCCESS : rt.Status.HOP_CANT_SPEAK_RELAY });
        }
        var ps = C("libp2p:circuit"), i_ = class {
          constructor() {
            this.components = new He();
          }
          init(e) {
            this.components = e, this.components.getRegistrar().handle(fu, (r) => {
              this._onProtocol(r).catch((n) => {
                ps.error(n);
              });
            }).catch((r) => {
              ps.error(r);
            });
          }
          hopEnabled() {
            return true;
          }
          hopActive() {
            return true;
          }
          get [H1]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "libp2p/circuit-relay-v1";
          }
          async _onProtocol(e) {
            let { connection: r, stream: n } = e, i2 = new hu({ stream: n }), o = await i2.read();
            if (o == null) {
              ps("request was invalid, could not read from stream"), i2.write({ type: rt.Type.STATUS, code: rt.Status.MALFORMED_MESSAGE }), i2.close();
              return;
            }
            let s;
            switch (o.type) {
              case rt.Type.CAN_HOP: {
                ps("received CAN_HOP request from %p", r.remotePeer), await Pae({ circuit: this, connection: r, streamHandler: i2 });
                break;
              }
              case rt.Type.HOP: {
                ps("received HOP request from %p", r.remotePeer), s = await Tae({ connection: r, request: o, streamHandler: i2, circuit: this, connectionManager: this.components.getConnectionManager() });
                break;
              }
              case rt.Type.STOP: {
                ps("received STOP request from %p", r.remotePeer), s = await Rae({ connection: r, request: o, streamHandler: i2 });
                break;
              }
              default: {
                ps("Request of type %s not supported", o.type), i2.write({ type: rt.Type.STATUS, code: rt.Status.MALFORMED_MESSAGE }), i2.close();
                return;
              }
            }
            if (s != null) {
              let a = new j(o.dstPeer.addrs[0]), u = new j(o.srcPeer.addrs[0]), l = QP({ stream: s, remoteAddr: a, localAddr: u }), f = o.type === rt.Type.HOP ? "relay" : "inbound";
              ps("new %s connection %s", f, l.remoteAddr);
              let h = await this.components.getUpgrader().upgradeInbound(l);
              ps("%s connection %s upgraded", f, l.remoteAddr), this.handler != null && this.handler(h);
            }
          }
          async dial(e, r = {}) {
            let n = e.toString().split("/p2p-circuit"), i2 = new j(n[0]), o = new j(n[n.length - 1]), s = i2.getPeerId(), a = o.getPeerId();
            if (s == null || a == null) {
              let d = "Circuit relay dial failed as addresses did not have peer id";
              throw ps.error(d), (0, Dae.default)(new Error(d), q.ERR_RELAYED_DIAL);
            }
            let u = ue(s), l = ue(a), f = false, p = this.components.getConnectionManager().getConnections(u)[0];
            p == null && (await this.components.getPeerStore().addressBook.add(u, [i2]), p = await this.components.getConnectionManager().openConnection(u, r), f = true);
            try {
              let d = await Iae({ connection: p, request: { type: rt.Type.HOP, srcPeer: { id: this.components.getPeerId().toBytes(), addrs: this.components.getAddressManager().getAddresses().map((g) => g.bytes) }, dstPeer: { id: l.toBytes(), addrs: [new j(o).bytes] } } }), m = i2.encapsulate(`/p2p-circuit/p2p/${this.components.getPeerId().toString()}`), y = QP({ stream: d, remoteAddr: e, localAddr: m });
              return ps("new outbound connection %s", y.remoteAddr), await this.components.getUpgrader().upgradeOutbound(y);
            } catch (d) {
              throw ps.error("Circuit relay dial failed", d), f && await p.close(), d;
            }
          }
          createListener(e) {
            return this.handler = e.handler, vae({ connectionManager: this.components.getConnectionManager(), peerStore: this.components.getPeerStore() });
          }
          filter(e) {
            return e = Array.isArray(e) ? e : [e], e.filter((r) => _h.matches(r));
          }
        };
        c();
        var u_ = w(OP(), 1);
        c();
        Re();
        me();
        c();
        te();
        vr();
        async function o_(t) {
          let e = new TextEncoder().encode(t), r = await xe.digest(e);
          return I.createV0(r);
        }
        c();
        var ZP = "hop_relay", JP = "true", s_ = "/libp2p/relay";
        var kae = w(ug(), 1), Nae = w(Vs(), 1);
        var E3 = C("libp2p:auto-relay"), pDe = () => {
        }, a_ = class {
          constructor(e, r) {
            this.components = e, this.addressSorter = r.addressSorter ?? W1, this.maxListeners = r.maxListeners ?? 1, this.listenRelays = /* @__PURE__ */ new Set(), this.onError = r.onError ?? pDe, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerDisconnected = this._onPeerDisconnected.bind(this), this.components.getPeerStore().addEventListener("change:protocols", (n) => {
              this._onProtocolChange(n).catch((i2) => {
                E3.error(i2);
              });
            }), this.components.getConnectionManager().addEventListener("peer:disconnect", this._onPeerDisconnected);
          }
          async _onProtocolChange(e) {
            let { peerId: r, protocols: n } = e.detail, i2 = r.toString();
            if (n.find((s) => s === fu) == null) {
              this.listenRelays.has(i2) && await this._removeListenRelay(i2);
              return;
            }
            if (!this.listenRelays.has(i2))
              try {
                let s = this.components.getConnectionManager().getConnections(r);
                if (s.length === 0)
                  return;
                let a = s[0];
                if (a.remoteAddr.protoCodes().includes(290)) {
                  E3(`relayed connection to ${i2} will not be used to hop on`);
                  return;
                }
                await Cae({ connection: a }) && (await this.components.getPeerStore().metadataBook.setValue(r, ZP, U(JP)), await this._addListenRelay(a, i2));
              } catch (s) {
                this.onError(s);
              }
          }
          _onPeerDisconnected(e) {
            let i2 = e.detail.remotePeer.toString();
            !this.listenRelays.has(i2) || this._removeListenRelay(i2).catch((o) => {
              E3.error(o);
            });
          }
          async _addListenRelay(e, r) {
            try {
              if (this.listenRelays.size >= this.maxListeners)
                return;
              let n = await Te(await this.components.getPeerStore().addressBook.get(e.remotePeer), (o) => (0, kae.default)(o, this.addressSorter), async (o) => await (0, Nae.default)(o));
              (await Promise.all(n.map(async (o) => {
                try {
                  let s = o.multiaddr;
                  return s.getPeerId() == null && (s = s.encapsulate(`/p2p/${e.remotePeer.toString()}`)), s = s.encapsulate("/p2p-circuit"), await this.components.getTransportManager().listen([s]), true;
                } catch (s) {
                  E3.error("error listening on circuit address", s), this.onError(s);
                }
                return false;
              }))).includes(true) && this.listenRelays.add(r);
            } catch (n) {
              this.onError(n), this.listenRelays.delete(r);
            }
          }
          async _removeListenRelay(e) {
            this.listenRelays.delete(e) && await this._listenOnAvailableHopRelays([e]);
          }
          async _listenOnAvailableHopRelays(e = []) {
            if (this.listenRelays.size >= this.maxListeners)
              return;
            let r = [], n = await this.components.getPeerStore().all();
            for (let { id: i2, metadata: o } of n) {
              let s = i2.toString();
              if (this.listenRelays.has(s) || e.includes(s))
                continue;
              let a = o.get(ZP);
              if (a == null || M(a) !== JP)
                continue;
              let u = this.components.getConnectionManager().getConnections(i2);
              if (u.length === 0) {
                r.push(i2);
                continue;
              }
              if (await this._addListenRelay(u[0], s), this.listenRelays.size >= this.maxListeners)
                return;
            }
            for (let i2 of r)
              if (await this._tryToListenOnRelay(i2), this.listenRelays.size >= this.maxListeners)
                return;
            try {
              let i2 = await o_(s_);
              for await (let o of this.components.getContentRouting().findProviders(i2)) {
                if (o.multiaddrs.length === 0)
                  continue;
                let s = o.id;
                if (await this.components.getPeerStore().addressBook.add(s, o.multiaddrs), await this._tryToListenOnRelay(s), this.listenRelays.size >= this.maxListeners)
                  return;
              }
            } catch (i2) {
              this.onError(i2);
            }
          }
          async _tryToListenOnRelay(e) {
            try {
              let r = await this.components.getConnectionManager().openConnection(e);
              await this._addListenRelay(r, e.toString());
            } catch (r) {
              E3.error("Could not use %p as relay", e, r), this.onError(r, `could not connect and listen on known hop relay ${e.toString()}`);
            }
          }
        };
        var Oae = C("libp2p:relay"), c_ = class {
          constructor(e, r) {
            this.components = e, this.autoRelay = r.autoRelay?.enabled !== false ? new a_(e, { addressSorter: r.addressSorter, ...r.autoRelay }) : void 0, this.started = false, this.init = r, this._advertiseService = this._advertiseService.bind(this);
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.init.hop.enabled !== false && this.init.advertise.enabled !== false && (this.timeout = (0, u_.setDelayedInterval)(this._advertiseService, this.init.advertise.ttl, this.init.advertise.bootDelay)), this.started = true;
          }
          async stop() {
            this.timeout != null && (0, u_.clearDelayedInterval)(this.timeout), this.started = false;
          }
          async _advertiseService() {
            try {
              let e = await o_(s_);
              await this.components.getContentRouting().provide(e);
            } catch (e) {
              e.code === q.ERR_NO_ROUTERS_AVAILABLE ? (Oae.error("a content router, such as a DHT, must be provided in order to advertise the relay service", e), await this.stop()) : Oae.error(e);
            }
          }
        };
        c();
        var yce = w(zae(), 1);
        c();
        var D7t = w(ace(), 1), k7t = w(i6(), 1), du = w(st(), 1);
        c();
        var C7t = w(tD(), 1), uce = w(st(), 1), cce = uce.default.pki, lce = (t, e) => {
          let r = cce.rsa.setPublicKey(e.n, e.e), n = cce.createCertificate();
          n.publicKey = r, n.serialNumber = "01", n.validity.notBefore = new Date(), n.validity.notAfter = new Date(), n.validity.notAfter.setFullYear(n.validity.notBefore.getFullYear() + 10);
          let i2 = [{ name: "organizationName", value: "ipfs" }, { shortName: "OU", value: "keystore" }, { name: "commonName", value: t.id }];
          return n.setSubject(i2), n.setIssuer(i2), n.setExtensions([{ name: "basicConstraints", cA: true }, { name: "keyUsage", keyCertSign: true, digitalSignature: true, nonRepudiation: true, keyEncipherment: true, dataEncipherment: true }, { name: "extKeyUsage", serverAuth: true, clientAuth: true, codeSigning: true, emailProtection: true, timeStamping: true }, { name: "nsCertType", client: true, server: true, email: true, objsign: true, sslCA: true, emailCA: true, objCA: true }]), n.sign(e), n;
        };
        async function fce(t, e) {
          let r = t.map(e), i2 = (await Promise.all(r)).findIndex((o) => o);
          return t[i2];
        }
        var pu = w(K(), 1);
        Re();
        me();
        var HDe = C("libp2p:keychain:cms"), iD = /* @__PURE__ */ new WeakMap(), d_ = class {
          constructor(e, r) {
            if (e == null)
              throw (0, pu.default)(new Error("keychain is required"), q.ERR_KEYCHAIN_REQUIRED);
            this.keychain = e, iD.set(this, { dek: r });
          }
          async encrypt(e, r) {
            if (!(r instanceof Uint8Array))
              throw (0, pu.default)(new Error("Plain data must be a Uint8Array"), q.ERR_INVALID_PARAMETERS);
            let n = await this.keychain.findKeyByName(e), i2 = await this.keychain.getPrivateKey(e), o = iD.get(this);
            if (o == null)
              throw (0, pu.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
            let s = o.dek, a = du.default.pki.decryptRsaPrivateKey(i2, s), u = await lce(n, a), l = du.default.pkcs7.createEnvelopedData();
            l.addRecipient(u), l.content = du.default.util.createBuffer(r), l.encrypt();
            let f = du.default.asn1.toDer(l.toAsn1()).getBytes();
            return U(f, "ascii");
          }
          async decrypt(e) {
            if (!(e instanceof Uint8Array))
              throw (0, pu.default)(new Error("CMS data is required"), q.ERR_INVALID_PARAMETERS);
            let r;
            try {
              let f = du.default.util.createBuffer(M(e, "ascii")), h = du.default.asn1.fromDer(f);
              r = du.default.pkcs7.messageFromAsn1(h);
            } catch (f) {
              throw HDe.error(f), (0, pu.default)(new Error("Invalid CMS"), q.ERR_INVALID_CMS);
            }
            let n = r.recipients.filter((f) => f.issuer.find((h) => h.shortName === "O" && h.value === "ipfs")).filter((f) => f.issuer.find((h) => h.shortName === "CN")).map((f) => ({ recipient: f, keyId: f.issuer.find((h) => h.shortName === "CN").value })), i2 = await fce(n, async (f) => {
              try {
                if (await this.keychain.findKeyById(f.keyId) != null)
                  return true;
              } catch {
                return false;
              }
              return false;
            });
            if (i2 == null) {
              let f = n.map((h) => h.keyId);
              throw (0, pu.default)(new Error(`Decryption needs one of the key(s): ${f.join(", ")}`), q.ERR_MISSING_KEYS, { missingKeys: f });
            }
            let o = await this.keychain.findKeyById(i2.keyId);
            if (o == null)
              throw (0, pu.default)(new Error("No key available to decrypto"), q.ERR_NO_KEY);
            let s = await this.keychain.getPrivateKey(o.name), a = iD.get(this);
            if (a == null)
              throw (0, pu.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
            let u = a.dek, l = du.default.pki.decryptRsaPrivateKey(s, u);
            return r.decrypt(i2.recipient, l), U(r.content.getBytes(), "ascii");
          }
        };
        var Gt = w(K(), 1);
        me();
        Re();
        c();
        c();
        c();
        var F7t = w(jp(), 1), $De = w(st(), 1);
        me();
        Re();
        c();
        var WDe = w(K(), 1);
        c();
        var dce = w(vx(), 1), pce = w(gr(), 1), mce = w(K(), 1), hce = { sha1: "sha1", "sha2-256": "sha256", "sha2-512": "sha512" };
        function b3(t, e, r, n, i2) {
          if (i2 !== "sha1" && i2 !== "sha2-256" && i2 !== "sha2-512") {
            let a = Object.keys(hce).join(" / ");
            throw (0, mce.default)(new Error(`Hash '${i2}' is unknown or not supported. Must be ${a}`), "ERR_UNSUPPORTED_HASH_TYPE");
          }
          let o = hce[i2], s = (0, dce.default)(t, e, r, n, o);
          return pce.default.encode64(s, null);
        }
        var p_ = C("libp2p:keychain"), YDe = "/pkcs8/", gce = "/info/", mf = /* @__PURE__ */ new WeakMap(), Pd = { minKeyLength: 112 / 8, minSaltLength: 128 / 8, minIterationCount: 1e3 }, oD = { dek: { keyLength: 512 / 8, iterationCount: 1e4, salt: "you should override this value with a crypto secure random number", hash: "sha2-512" } };
        function mu(t) {
          return t == null || typeof t != "string" ? false : t === (0, yce.default)(t.trim()) && t.length > 0;
        }
        async function pr() {
          let r = Math.random() * 800 + 200;
          await new Promise((n) => setTimeout(n, r));
        }
        function oc(t) {
          return new ae(YDe + t);
        }
        function yf(t) {
          return new ae(gce + t);
        }
        var _3 = class {
          constructor(e, r) {
            if (this.components = e, this.init = Ze(oD, r), this.init.pass != null && this.init.pass?.length < 20)
              throw new Error("pass must be least 20 characters");
            if (this.init.dek?.keyLength != null && this.init.dek.keyLength < Pd.minKeyLength)
              throw new Error(`dek.keyLength must be least ${Pd.minKeyLength} bytes`);
            if (this.init.dek?.salt?.length != null && this.init.dek.salt.length < Pd.minSaltLength)
              throw new Error(`dek.saltLength must be least ${Pd.minSaltLength} bytes`);
            if (this.init.dek?.iterationCount != null && this.init.dek.iterationCount < Pd.minIterationCount)
              throw new Error(`dek.iterationCount must be least ${Pd.minIterationCount}`);
            let n = this.init.pass != null && this.init.dek?.salt != null ? b3(this.init.pass, this.init.dek?.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
            mf.set(this, { dek: n });
          }
          get cms() {
            let e = mf.get(this);
            if (e == null)
              throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
            let r = e.dek;
            return new d_(this, r);
          }
          static generateOptions() {
            let e = Object.assign({}, oD), r = Math.ceil(Pd.minSaltLength / 3) * 3;
            return e.dek.salt = M(Fs(r), "base64"), e;
          }
          static get options() {
            return oD;
          }
          async createKey(e, r, n = 2048) {
            if (!mu(e) || e === "self")
              throw await pr(), (0, Gt.default)(new Error("Invalid key name"), q.ERR_INVALID_KEY_NAME);
            if (typeof r != "string")
              throw await pr(), (0, Gt.default)(new Error("Invalid key type"), q.ERR_INVALID_KEY_TYPE);
            let i2 = oc(e);
            if (await this.components.getDatastore().has(i2))
              throw await pr(), (0, Gt.default)(new Error("Key name already exists"), q.ERR_KEY_ALREADY_EXISTS);
            switch (r.toLowerCase()) {
              case "rsa":
                if (!Number.isSafeInteger(n) || n < 2048)
                  throw await pr(), (0, Gt.default)(new Error("Invalid RSA key size"), q.ERR_INVALID_KEY_SIZE);
                break;
              default:
                break;
            }
            let s;
            try {
              let a = await sR(r, n), u = await a.id(), l = mf.get(this);
              if (l == null)
                throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
              let f = l.dek, h = await a.export(f);
              s = { name: e, id: u };
              let p = this.components.getDatastore().batch();
              p.put(i2, U(h)), p.put(yf(e), U(JSON.stringify(s))), await p.commit();
            } catch (a) {
              throw await pr(), a;
            }
            return s;
          }
          async listKeys() {
            let e = { prefix: gce }, r = [];
            for await (let n of this.components.getDatastore().query(e))
              r.push(JSON.parse(M(n.value)));
            return r;
          }
          async findKeyById(e) {
            try {
              return (await this.listKeys()).find((n) => n.id === e);
            } catch (r) {
              throw await pr(), r;
            }
          }
          async findKeyByName(e) {
            if (!mu(e))
              throw await pr(), (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
            let r = yf(e);
            try {
              let n = await this.components.getDatastore().get(r);
              return JSON.parse(M(n));
            } catch (n) {
              throw await pr(), p_.error(n), (0, Gt.default)(new Error(`Key '${e}' does not exist.`), q.ERR_KEY_NOT_FOUND);
            }
          }
          async removeKey(e) {
            if (!mu(e) || e === "self")
              throw await pr(), (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
            let r = oc(e), n = await this.findKeyByName(e), i2 = this.components.getDatastore().batch();
            return i2.delete(r), i2.delete(yf(e)), await i2.commit(), n;
          }
          async renameKey(e, r) {
            if (!mu(e) || e === "self")
              throw await pr(), (0, Gt.default)(new Error(`Invalid old key name '${e}'`), q.ERR_OLD_KEY_NAME_INVALID);
            if (!mu(r) || r === "self")
              throw await pr(), (0, Gt.default)(new Error(`Invalid new key name '${r}'`), q.ERR_NEW_KEY_NAME_INVALID);
            let n = oc(e), i2 = oc(r), o = yf(e), s = yf(r);
            if (await this.components.getDatastore().has(i2))
              throw await pr(), (0, Gt.default)(new Error(`Key '${r}' already exists`), q.ERR_KEY_ALREADY_EXISTS);
            try {
              let u = await this.components.getDatastore().get(n), l = await this.components.getDatastore().get(o), f = JSON.parse(M(l));
              f.name = r;
              let h = this.components.getDatastore().batch();
              return h.put(i2, u), h.put(s, U(JSON.stringify(f))), h.delete(n), h.delete(o), await h.commit(), f;
            } catch (u) {
              throw await pr(), u;
            }
          }
          async exportKey(e, r) {
            if (!mu(e))
              throw await pr(), (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
            if (r == null)
              throw await pr(), (0, Gt.default)(new Error("Password is required"), q.ERR_PASSWORD_REQUIRED);
            let n = oc(e);
            try {
              let i2 = await this.components.getDatastore().get(n), o = M(i2), s = mf.get(this);
              if (s == null)
                throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
              let a = s.dek;
              return await (await Mc(o, a)).export(r);
            } catch (i2) {
              throw await pr(), i2;
            }
          }
          async importKey(e, r, n) {
            if (!mu(e) || e === "self")
              throw await pr(), (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
            if (r == null)
              throw await pr(), (0, Gt.default)(new Error("PEM encoded key is required"), q.ERR_PEM_REQUIRED);
            let i2 = oc(e);
            if (await this.components.getDatastore().has(i2))
              throw await pr(), (0, Gt.default)(new Error(`Key '${e}' already exists`), q.ERR_KEY_ALREADY_EXISTS);
            let s;
            try {
              s = await Mc(r, n);
            } catch {
              throw await pr(), (0, Gt.default)(new Error("Cannot read the key, most likely the password is wrong"), q.ERR_CANNOT_READ_KEY);
            }
            let a;
            try {
              a = await s.id();
              let f = mf.get(this);
              if (f == null)
                throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
              let h = f.dek;
              r = await s.export(h);
            } catch (f) {
              throw await pr(), f;
            }
            let u = { name: e, id: a }, l = this.components.getDatastore().batch();
            return l.put(i2, U(r)), l.put(yf(e), U(JSON.stringify(u))), await l.commit(), u;
          }
          async importPeer(e, r) {
            try {
              if (!mu(e))
                throw (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
              if (r == null || r.privateKey == null)
                throw (0, Gt.default)(new Error("Peer.privKey is required"), q.ERR_MISSING_PRIVATE_KEY);
              let n = await Jn(r.privateKey), i2 = oc(e);
              if (await this.components.getDatastore().has(i2))
                throw await pr(), (0, Gt.default)(new Error(`Key '${e}' already exists`), q.ERR_KEY_ALREADY_EXISTS);
              let s = mf.get(this);
              if (s == null)
                throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
              let a = s.dek, u = await n.export(a), l = { name: e, id: r.toString() }, f = this.components.getDatastore().batch();
              return f.put(i2, U(u)), f.put(yf(e), U(JSON.stringify(l))), await f.commit(), l;
            } catch (n) {
              throw await pr(), n;
            }
          }
          async getPrivateKey(e) {
            if (!mu(e))
              throw await pr(), (0, Gt.default)(new Error(`Invalid key name '${e}'`), q.ERR_INVALID_KEY_NAME);
            try {
              let r = oc(e), n = await this.components.getDatastore().get(r);
              return M(n);
            } catch (r) {
              throw await pr(), p_.error(r), (0, Gt.default)(new Error(`Key '${e}' does not exist.`), q.ERR_KEY_NOT_FOUND);
            }
          }
          async rotateKeychainPass(e, r) {
            if (typeof e != "string")
              throw await pr(), (0, Gt.default)(new Error(`Invalid old pass type '${typeof e}'`), q.ERR_INVALID_OLD_PASS_TYPE);
            if (typeof r != "string")
              throw await pr(), (0, Gt.default)(new Error(`Invalid new pass type '${typeof r}'`), q.ERR_INVALID_NEW_PASS_TYPE);
            if (r.length < 20)
              throw await pr(), (0, Gt.default)(new Error(`Invalid pass length ${r.length}`), q.ERR_INVALID_PASS_LENGTH);
            p_("recreating keychain");
            let n = mf.get(this);
            if (n == null)
              throw (0, Gt.default)(new Error("dek missing"), q.ERR_INVALID_PARAMETERS);
            let i2 = n.dek;
            this.init.pass = r;
            let o = r != null && this.init.dek?.salt != null ? b3(r, this.init.dek.salt, this.init.dek?.iterationCount, this.init.dek?.keyLength, this.init.dek?.hash) : "";
            mf.set(this, { dek: o });
            let s = await this.listKeys();
            for (let a of s) {
              let u = await this.components.getDatastore().get(oc(a.name)), l = M(u), f = await Mc(l, i2), h = o.toString(), p = await f.export(h), d = this.components.getDatastore().batch(), m = { name: a.name, id: a.id };
              d.put(oc(a.name), U(p)), d.put(yf(a.name), U(JSON.stringify(m))), await d.commit();
            }
            p_("keychain reconstructed");
          }
        };
        c();
        var uD = w(sD(), 1), bce = w(Mp(), 1);
        c();
        c();
        var aD = class {
          constructor(e) {
            if (typeof e != "number")
              throw new Error("must provide a timespan to the moving average constructor");
            if (e <= 0)
              throw new Error("must provide a timespan > 0 to the moving average constructor");
            this.timespan = e, this.movingAverage = 0, this.variance = 0, this.deviation = 0, this.forecast = 0;
          }
          alpha(e, r) {
            return 1 - Math.exp(-(e - r) / this.timespan);
          }
          push(e, r) {
            if (this.previousTime != null) {
              let n = this.alpha(e, this.previousTime), i2 = r - this.movingAverage, o = n * i2;
              this.movingAverage = n * r + (1 - n) * this.movingAverage, this.variance = (1 - n) * (this.variance + i2 * o), this.deviation = Math.sqrt(this.variance), this.forecast = this.movingAverage + n * i2;
            } else
              this.movingAverage = r;
            this.previousTime = e;
          }
        };
        function cD(t) {
          return new aD(t);
        }
        var Ece = w(y2(), 1), Z1 = class extends Ue {
          constructor(e) {
            super(), this.enabled = e.enabled, this.queue = [], this.stats = { dataReceived: 0n, dataSent: 0n }, this.frequencyLastTime = Date.now(), this.frequencyAccumulators = {}, this.movingAverages = { dataReceived: [], dataSent: [] }, this.computeThrottleMaxQueueSize = e.computeThrottleMaxQueueSize, this.computeThrottleTimeout = e.computeThrottleTimeout, this._update = this._update.bind(this), this.movingAverageIntervals = e.movingAverageIntervals;
            for (let r = 0; r < e.initialCounters.length; r++) {
              let n = e.initialCounters[r];
              this.stats[n] = 0n, this.movingAverages[n] = [];
              for (let i2 = 0; i2 < this.movingAverageIntervals.length; i2++) {
                let o = this.movingAverageIntervals[i2];
                (this.movingAverages[n][o] = cD(o)).push(this.frequencyLastTime, 0);
              }
            }
          }
          start() {
            !this.enabled || this.queue.length > 0 && this._resetComputeTimeout();
          }
          stop() {
            this.timeout != null && (this.timeout.clear(), this.timeout = null);
          }
          getSnapshot() {
            return Object.assign({}, this.stats);
          }
          getMovingAverages() {
            return Object.assign({}, this.movingAverages);
          }
          push(e, r) {
            this.queue.push([e, r, Date.now()]), this._resetComputeTimeout();
          }
          _resetComputeTimeout() {
            this.timeout = (0, Ece.default)(this._update, this._nextTimeout());
          }
          _nextTimeout() {
            let e = this.queue.length / this.computeThrottleMaxQueueSize;
            return Math.max(this.computeThrottleTimeout * (1 - e), 0);
          }
          _update() {
            if (this.timeout = null, this.queue.length > 0) {
              let e = ["", 0, 0];
              for (e of this.queue)
                this._applyOp(e);
              this.queue = [], e.length > 2 && e[0] !== "" && this._updateFrequency(e[2]), this.dispatchEvent(new ee("update", { detail: this.stats }));
            }
          }
          _updateFrequency(e) {
            let r = e - this.frequencyLastTime;
            this._updateFrequencyFor("dataReceived", r, e), this._updateFrequencyFor("dataSent", r, e), this.frequencyLastTime = e;
          }
          _updateFrequencyFor(e, r, n) {
            let i2 = this.frequencyAccumulators[e] ?? 0;
            this.frequencyAccumulators[e] = 0;
            let s = i2 / (r ?? 1) * 1e3, a = this.movingAverages[e];
            a == null && (a = this.movingAverages[e] = []);
            let u = this.movingAverageIntervals;
            for (let l = 0; l < u.length; l++) {
              let f = u[l], h = a[f];
              h == null && (h = a[f] = cD(f)), h.push(n, s);
            }
          }
          _applyOp(e) {
            let r = e[0], n = e[1];
            if (typeof n != "number")
              throw new Error("invalid increment number");
            let i2;
            Object.prototype.hasOwnProperty.call(this.stats, r) ? i2 = this.stats[r] : i2 = this.stats[r] = 0n, this.stats[r] = i2 + BigInt(n), this.frequencyAccumulators[r] == null && (this.frequencyAccumulators[r] = 0), this.frequencyAccumulators[r] += n;
          }
        };
        var XDe = ["dataReceived", "dataSent"], ZDe = { in: "dataReceived", out: "dataSent" }, m_ = class {
          constructor(e) {
            this.enabled = e.enabled, this.statsInit = { ...e, initialCounters: XDe }, this.globalStats = new Z1(this.statsInit), this.peerStats = /* @__PURE__ */ new Map(), this.protocolStats = /* @__PURE__ */ new Map(), this.oldPeers = (0, bce.default)(e.maxOldPeersRetention ?? cae.maxOldPeersRetention), this.running = false, this._onMessage = this._onMessage.bind(this), this.systems = /* @__PURE__ */ new Map();
          }
          isStarted() {
            return this.running;
          }
          async start() {
            !this.enabled || (this.running = true);
          }
          async stop() {
            if (!!this.running) {
              this.running = false, this.globalStats.stop();
              for (let e of this.peerStats.values())
                e.stop();
              for (let e of this.protocolStats.values())
                e.stop();
            }
          }
          getGlobal() {
            return this.globalStats;
          }
          getPeers() {
            return Array.from(this.peerStats.keys());
          }
          getComponentMetrics() {
            return this.systems;
          }
          updateComponentMetric(e) {
            let { system: r = "libp2p", component: n, metric: i2, value: o } = e;
            this.systems.has(r) || this.systems.set(r, /* @__PURE__ */ new Map());
            let s = this.systems.get(r);
            if (s == null)
              throw new Error("Unknown metric system");
            s.has(n) || s.set(n, /* @__PURE__ */ new Map());
            let a = s.get(n);
            if (a == null)
              throw new Error("Unknown metric component");
            a.set(i2, o);
          }
          forPeer(e) {
            let r = e.toString();
            return this.peerStats.get(r) ?? this.oldPeers.get(r);
          }
          getProtocols() {
            return Array.from(this.protocolStats.keys());
          }
          forProtocol(e) {
            return this.protocolStats.get(e);
          }
          onPeerDisconnected(e) {
            let r = e.toString(), n = this.peerStats.get(r);
            n != null && (n.stop(), this.peerStats.delete(r), this.oldPeers.set(r, n));
          }
          _onMessage(e) {
            if (!this.running)
              return;
            let { remotePeer: r, protocol: n, direction: i2, dataLength: o } = e, s = ZDe[i2], a = this.forPeer(r);
            if (a == null) {
              let u = new Z1(this.statsInit);
              this.peerStats.set(r.toString(), u), a = u;
            }
            if (a.push(s, o), this.globalStats.push(s, o), n != null) {
              let u = this.forProtocol(n);
              if (u == null) {
                let l = new Z1(this.statsInit);
                this.protocolStats.set(n, l), u = l;
              }
              u.push(s, o);
            }
          }
          updatePlaceholder(e, r) {
            if (!this.running)
              return;
            let n = e.toString(), i2 = this.peerStats.get(n) ?? this.oldPeers.get(n), o = r.toString(), s = this.peerStats.get(o) ?? this.oldPeers.get(o), a = i2;
            s != null && (a = JDe(s, a), this.oldPeers.remove(o)), this.peerStats.delete(e.toString()), this.peerStats.set(o, a), a.start();
          }
          trackStream(e) {
            let { stream: r, remotePeer: n, protocol: i2 } = e;
            if (!this.running)
              return r;
            let o = r.source;
            r.source = (0, uD.default)(o, (a) => this._onMessage({ remotePeer: n, protocol: i2, direction: "in", dataLength: a.length }));
            let s = r.sink;
            return r.sink = async (a) => await Te(a, (u) => (0, uD.default)(u, (l) => {
              this._onMessage({ remotePeer: n, protocol: i2, direction: "out", dataLength: l.length });
            }), s), r;
          }
        };
        function JDe(t, e) {
          return t.stop(), e.stop(), t.queue = [...t.queue, ...e.queue], t;
        }
        c();
        c();
        c();
        async function v3(t) {
          try {
            let e = await t;
            return { isFulfilled: true, isRejected: false, value: e };
          } catch (e) {
            return { isFulfilled: false, isRejected: true, reason: e };
          }
        }
        c();
        c();
        var lD = class {
          value;
          next;
          constructor(e) {
            this.value = e;
          }
        }, S3 = class {
          #e;
          #t;
          #r;
          constructor() {
            this.clear();
          }
          enqueue(e) {
            let r = new lD(e);
            this.#e ? (this.#t.next = r, this.#t = r) : (this.#e = r, this.#t = r), this.#r++;
          }
          dequeue() {
            let e = this.#e;
            if (!!e)
              return this.#e = this.#e.next, this.#r--, e.value;
          }
          clear() {
            this.#e = void 0, this.#t = void 0, this.#r = 0;
          }
          get size() {
            return this.#r;
          }
          *[Symbol.iterator]() {
            let e = this.#e;
            for (; e; )
              yield e.value, e = e.next;
          }
        };
        function fD(t) {
          if (!((Number.isInteger(t) || t === Number.POSITIVE_INFINITY) && t > 0))
            throw new TypeError("Expected `concurrency` to be a number from 1 and up");
          let e = new S3(), r = 0, n = () => {
            r--, e.size > 0 && e.dequeue()();
          }, i2 = async (a, u, l) => {
            r++;
            let f = (async () => a(...l))();
            u(f);
            try {
              await f;
            } catch {
            }
            n();
          }, o = (a, u, l) => {
            e.enqueue(i2.bind(void 0, a, u, l)), (async () => (await Promise.resolve(), r < t && e.size > 0 && e.dequeue()()))();
          }, s = (a, ...u) => new Promise((l) => {
            o(a, l, u);
          });
          return Object.defineProperties(s, { activeCount: { get: () => r }, pendingCount: { get: () => e.size }, clearQueue: { value: () => {
            e.clear();
          } } }), s;
        }
        async function hD(t, e = {}) {
          let { concurrency: r = Number.POSITIVE_INFINITY } = e, n = fD(r);
          return Promise.all(t.map((i2) => i2 && typeof i2.then == "function" ? v3(i2) : typeof i2 == "function" ? v3(n(() => i2())) : v3(Promise.resolve(i2))));
        }
        var J1 = w(K(), 1);
        var Dd = C("libp2p:transports"), y_ = class extends Ue {
          constructor(e, r = {}) {
            super(), this.components = e, this.started = false, this.transports = /* @__PURE__ */ new Map(), this.listeners = Dn({ component: "transport-manager", metric: "listeners", metrics: this.components.getMetrics() }), this.faultTolerance = r.faultTolerance ?? kd.FATAL_ALL;
          }
          add(e) {
            let r = e[Symbol.toStringTag];
            if (r == null)
              throw (0, J1.default)(new Error("Transport must have a valid tag"), q.ERR_INVALID_KEY);
            if (this.transports.has(r))
              throw (0, J1.default)(new Error("There is already a transport with this tag"), q.ERR_DUPLICATE_TRANSPORT);
            Dd("adding transport %s", r), this.transports.set(r, e), this.listeners.has(r) || this.listeners.set(r, []);
          }
          isStarted() {
            return this.started;
          }
          async start() {
            let e = this.components.getAddressManager().getListenAddrs();
            await this.listen(e), this.started = true;
          }
          async stop() {
            let e = [];
            for (let [r, n] of this.listeners)
              for (Dd("closing listeners for %s", r); n.length > 0; ) {
                let i2 = n.pop();
                i2 != null && e.push(i2.close());
              }
            await Promise.all(e), Dd("all listeners closed");
            for (let r of this.listeners.keys())
              this.listeners.set(r, []);
            this.started = false;
          }
          async dial(e, r) {
            let n = this.transportForMultiaddr(e);
            if (n == null)
              throw (0, J1.default)(new Error(`No transport available for address ${String(e)}`), q.ERR_TRANSPORT_UNAVAILABLE);
            try {
              return await n.dial(e, { ...r, upgrader: this.components.getUpgrader() });
            } catch (i2) {
              throw i2.code == null && (i2.code = q.ERR_TRANSPORT_DIAL_FAILED), i2;
            }
          }
          getAddrs() {
            let e = [];
            for (let r of this.listeners.values())
              for (let n of r)
                e = [...e, ...n.getAddrs()];
            return e;
          }
          getTransports() {
            return Array.of(...this.transports.values());
          }
          transportForMultiaddr(e) {
            for (let r of this.transports.values())
              if (r.filter([e]).length > 0)
                return r;
          }
          async listen(e) {
            if (e == null || e.length === 0) {
              Dd("no addresses were provided for listening, this node is dial only");
              return;
            }
            let r = [];
            for (let [n, i2] of this.transports.entries()) {
              let o = i2.filter(e), s = [];
              for (let l of o) {
                Dd("creating listener for %s on %s", n, l);
                let f = i2.createListener({ upgrader: this.components.getUpgrader() }), h = this.listeners.get(n);
                h == null && (h = [], this.listeners.set(n, h)), h.push(f), f.addEventListener("listening", () => {
                  this.dispatchEvent(new ee("listener:listening", { detail: f }));
                }), f.addEventListener("close", () => {
                  this.dispatchEvent(new ee("listener:close", { detail: f }));
                }), s.push(f.listen(l));
              }
              if (s.length === 0) {
                r.push(n);
                continue;
              }
              if ((await hD(s)).find((l) => l.isFulfilled) == null && this.faultTolerance !== kd.NO_FATAL)
                throw (0, J1.default)(new Error(`Transport (${n}) could not listen on any available address`), q.ERR_NO_VALID_ADDRESSES);
            }
            if (r.length === this.transports.size) {
              let n = `no valid addresses were provided for transports [${r.join(", ")}]`;
              if (this.faultTolerance === kd.FATAL_ALL)
                throw (0, J1.default)(new Error(n), q.ERR_NO_VALID_ADDRESSES);
              Dd(`libp2p in dial mode only: ${n}`);
            }
          }
          async remove(e) {
            Dd("removing %s", e);
            for (let r of this.listeners.get(e) ?? [])
              await r.close();
            this.transports.delete(e), this.listeners.delete(e);
          }
          async removeAll() {
            let e = [];
            for (let r of this.transports.keys())
              e.push(this.remove(r));
            await Promise.all(e);
          }
        }, kd;
        (function(t) {
          t[t.FATAL_ALL = 0] = "FATAL_ALL", t[t.NO_FATAL = 1] = "NO_FATAL";
        })(kd || (kd = {}));
        c();
        var Oi = w(K(), 1);
        c();
        c();
        var xce = w(K(), 1);
        c();
        var dD = w(K(), 1);
        Re();
        var _ce = w(Gc(), 1);
        me();
        var vce = U(`
`);
        function g_(t) {
          let e = new qe(t, vce);
          return kr.single(e).slice();
        }
        function sc(t, e) {
          t.push(g_(e).slice());
        }
        function Sce(t, e) {
          let r = new qe();
          for (let n of e)
            r.append(g_(n));
          t.push(r.slice());
        }
        async function pD(t, e) {
          let r = 1, n = { [Symbol.asyncIterator]: () => n, next: async () => await t.next(r) }, i2 = n;
          e?.signal != null && (i2 = Pn(n, e.signal));
          let s = await Te(i2, Er({ onLength: (a) => {
            r = a;
          } }), async (a) => await (0, _ce.default)(a));
          if (s == null)
            throw (0, dD.default)(new Error("no buffer returned"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
          if (s[s.length - 1] !== vce[0])
            throw (0, dD.default)(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
          return s.slice(0, -1);
        }
        async function em(t, e) {
          let r = await pD(t, e);
          return M(r);
        }
        Re();
        var tm = C("libp2p:mss:select");
        async function yD(t, e, r, n) {
          e = Array.isArray(e) ? [...e] : [e];
          let { reader: i2, writer: o, rest: s, stream: a } = Io(t), u = e.shift();
          if (u == null)
            throw new Error("At least one protocol must be specified");
          r != null ? (tm('select: write ["%s", "%s"]', r, u), Sce(o, [U(r), U(u)])) : (tm('select: write "%s"', u), sc(o, U(u)));
          let l = await em(i2, n);
          if (tm('select: read "%s"', l), l === r && (l = await em(i2, n), tm('select: read "%s"', l)), l === u)
            return s(), { stream: a, protocol: u };
          for (let f of e) {
            tm('select: write "%s"', f), sc(o, U(f));
            let h = await em(i2, n);
            if (tm('select: read "%s" for "%s"', h, f), h === f)
              return s(), { stream: a, protocol: f };
          }
          throw s(), (0, xce.default)(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
        }
        c();
        c();
        var Nd = "/multistream/1.0.0";
        Re();
        var x3 = C("libp2p:mss:handle");
        async function Rce(t, e, r) {
          e = Array.isArray(e) ? e : [e];
          let { writer: n, reader: i2, rest: o, stream: s } = Io(t);
          for (; ; ) {
            let a = await em(i2, r);
            if (x3('read "%s"', a), a === Nd) {
              x3('respond with "%s" for "%s"', Nd, a), sc(n, U(Nd));
              continue;
            }
            if (e.includes(a))
              return sc(n, U(a)), x3('respond with "%s" for "%s"', a, a), o(), { stream: s, protocol: a };
            if (a === "ls") {
              sc(n, new qe(...e.map((u) => g_(U(u))))), x3('respond with "%s" for %s', e, a);
              continue;
            }
            sc(n, U("na")), x3('respond with "na" for "%s"', a);
          }
        }
        c();
        me();
        Re();
        var eke = C("libp2p:mss:ls");
        async function Ace(t, e) {
          let { reader: r, writer: n, rest: i2, stream: o } = Io(t);
          eke('write "ls"'), sc(n, U("ls")), i2();
          let s = await pD(r, e), a = by([s]), u = [];
          return await Te(a, Er(), async (f) => {
            for await (let h of f)
              u.push(M(h.slice(0, -1)));
          }), { stream: o, protocols: u };
        }
        var w_ = class {
          constructor(e) {
            this.stream = e, this.shaken = false;
          }
          async _handshake(e) {
            if (this.shaken)
              return;
            let { stream: r } = await yD(this.stream, Nd, void 0, e);
            this.stream = r, this.shaken = true;
          }
        }, rm = class extends w_ {
          async select(e, r) {
            return await yD(this.stream, e, this.shaken ? void 0 : Nd, r);
          }
          async ls(e) {
            await this._handshake(e);
            let r = await Ace(this.stream, e), { stream: n, protocols: i2 } = r;
            return this.stream = n, i2;
          }
        }, nm = class extends w_ {
          async handle(e, r) {
            return await Rce(this.stream, e, r);
          }
        };
        var ED = w(Ice(), 1);
        c();
        var gD = w(K(), 1);
        c();
        var Cce = Symbol.for("@libp2p/connection");
        var rke = C("libp2p:connection"), wD = class {
          constructor(e) {
            let { remoteAddr: r, remotePeer: n, newStream: i2, close: o, getStreams: s, stat: a } = e;
            this.id = `${parseInt(String(Math.random() * 1e9)).toString(36)}${Date.now()}`, this.remoteAddr = r, this.remotePeer = n, this.stat = { ...a, status: jb }, this._newStream = i2, this._close = o, this._getStreams = s, this.registry = /* @__PURE__ */ new Map(), this.tags = [], this._closing = false;
          }
          get [Symbol.toStringTag]() {
            return "Connection";
          }
          get [Cce]() {
            return true;
          }
          get streams() {
            return this._getStreams();
          }
          async newStream(e, r) {
            if (this.stat.status === UP)
              throw (0, gD.default)(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
            if (this.stat.status === Yb)
              throw (0, gD.default)(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
            Array.isArray(e) || (e = [e]);
            let { stream: n, protocol: i2 } = await this._newStream(e, r);
            return this.addStream(n, { protocol: i2, metadata: {} }), { stream: n, protocol: i2 };
          }
          addStream(e, r = {}) {
            this.registry.set(e.id, { protocol: r.protocol ?? "", metadata: r.metadata ?? {} });
          }
          removeStream(e) {
            this.registry.delete(e);
          }
          async close() {
            if (!(this.stat.status === Yb || this._closing)) {
              this.stat.status = UP;
              try {
                this.streams.forEach((e) => e.close());
              } catch (e) {
                rke.error(e);
              }
              this._closing = true, await this._close(), this._closing = false, this.stat.timeline.close = Date.now(), this.stat.status = Yb;
            }
          }
        };
        function Pce(t) {
          return new wD(t);
        }
        var qr = C("libp2p:upgrader"), E_ = class extends Ue {
          constructor(e, r) {
            super(), this.components = e, this.connectionEncryption = /* @__PURE__ */ new Map(), r.connectionEncryption.forEach((n) => {
              this.connectionEncryption.set(n.protocol, n);
            }), this.muxers = /* @__PURE__ */ new Map(), r.muxers.forEach((n) => {
              this.muxers.set(n.protocol, n);
            });
          }
          async upgradeInbound(e) {
            let r, n, i2, o, s, a, u, l = this.components.getMetrics();
            if (await this.components.getConnectionGater().denyInboundConnection(e))
              throw (0, Oi.default)(new Error("The multiaddr connection is blocked by gater.acceptConnection"), q.ERR_CONNECTION_INTERCEPTED);
            if (l != null) {
              ({ setTarget: a, proxy: u } = (0, ED.default)());
              let p = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
              a({ toString: () => p }), e = l.trackStream({ stream: e, remotePeer: u });
            }
            qr("starting the inbound connection upgrade");
            let f = e, h = this.components.getConnectionProtector();
            h != null && (qr("protecting the inbound connection"), f = await h.protect(e));
            try {
              if ({ conn: r, remotePeer: n, protocol: s } = await this._encryptInbound(f), await this.components.getConnectionGater().denyInboundEncryptedConnection(n, { ...f, ...r }))
                throw (0, Oi.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), q.ERR_CONNECTION_INTERCEPTED);
              if (this.muxers.size > 0) {
                let p = await this._multiplexInbound({ ...f, ...r }, this.muxers);
                o = p.muxerFactory, i2 = p.stream;
              } else
                i2 = r;
            } catch (p) {
              throw qr.error("Failed to upgrade inbound connection", p), await e.close(p), p;
            }
            if (await this.components.getConnectionGater().denyInboundUpgradedConnection(n, { ...f, ...r }))
              throw (0, Oi.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), q.ERR_CONNECTION_INTERCEPTED);
            return l != null && (l.updatePlaceholder(u, n), a(n)), qr("Successfully upgraded inbound connection"), this._createConnection({ cryptoProtocol: s, direction: "inbound", maConn: e, upgradedConn: i2, muxerFactory: o, remotePeer: n });
          }
          async upgradeOutbound(e) {
            let r = e.remoteAddr.getPeerId();
            if (r == null)
              throw (0, Oi.default)(new Error("outbound connection must have a peer id"), q.ERR_INVALID_MULTIADDR);
            let n = ue(r);
            if (await this.components.getConnectionGater().denyOutboundConnection(n, e))
              throw (0, Oi.default)(new Error("The multiaddr connection is blocked by connectionGater.denyOutboundConnection"), q.ERR_CONNECTION_INTERCEPTED);
            let i2, o, s, a, u, l, f, h = this.components.getMetrics();
            if (h != null) {
              ({ setTarget: l, proxy: f } = (0, ED.default)());
              let m = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
              l({ toB58String: () => m }), e = h.trackStream({ stream: e, remotePeer: f });
            }
            qr("Starting the outbound connection upgrade");
            let p = e, d = this.components.getConnectionProtector();
            d != null && (p = await d.protect(e));
            try {
              if ({ conn: i2, remotePeer: o, protocol: a } = await this._encryptOutbound(p, n), await this.components.getConnectionGater().denyOutboundEncryptedConnection(o, { ...p, ...i2 }))
                throw (0, Oi.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), q.ERR_CONNECTION_INTERCEPTED);
              if (this.muxers.size > 0) {
                let m = await this._multiplexOutbound({ ...p, ...i2 }, this.muxers);
                u = m.muxerFactory, s = m.stream;
              } else
                s = i2;
            } catch (m) {
              throw qr.error("Failed to upgrade outbound connection", m), await e.close(m), m;
            }
            if (await this.components.getConnectionGater().denyOutboundUpgradedConnection(o, { ...p, ...i2 }))
              throw (0, Oi.default)(new Error("The multiaddr connection is blocked by gater.acceptEncryptedConnection"), q.ERR_CONNECTION_INTERCEPTED);
            return h != null && (h.updatePlaceholder(f, o), l(o)), qr("Successfully upgraded outbound connection"), this._createConnection({ cryptoProtocol: a, direction: "outbound", maConn: e, upgradedConn: s, muxerFactory: u, remotePeer: o });
          }
          _createConnection(e) {
            let { cryptoProtocol: r, direction: n, maConn: i2, upgradedConn: o, remotePeer: s, muxerFactory: a } = e, u, l, f;
            a != null && (u = a.createStreamMuxer(this.components, { onIncomingStream: (d) => {
              f != null && Promise.resolve().then(async () => {
                let m = new nm(d), y = this.components.getRegistrar().getProtocols(), { stream: g, protocol: E } = await m.handle(y);
                qr("%s: incoming stream opened on %s", n, E);
                let b = this.components.getMetrics();
                b?.trackStream({ stream: g, remotePeer: s, protocol: E }), f != null && (f.addStream(d, { protocol: E }), this._onStream({ connection: f, stream: { ...d, ...g }, protocol: E }));
              }).catch((m) => {
                qr.error(m), d.timeline.close == null && d.close();
              });
            }, onStreamEnd: (d) => {
              f?.removeStream(d.id);
            } }), l = async (d, m = {}) => {
              if (u == null)
                throw (0, Oi.default)(new Error("Stream is not multiplexed"), q.ERR_MUXER_UNAVAILABLE);
              qr("%s: starting new stream on %s", n, d);
              let y = u.newStream(), g = new rm(y), E = this.components.getMetrics();
              try {
                let { stream: b, protocol: v } = await g.select(d, m);
                return E != null && (b = E.trackStream({ stream: b, remotePeer: s, protocol: v })), { stream: { ...y, ...b }, protocol: v };
              } catch (b) {
                throw qr.error("could not create new stream", b), y.timeline.close == null && y.close(), b.code != null ? b : (0, Oi.default)(b, q.ERR_UNSUPPORTED_PROTOCOL);
              }
            }, Te(o, u, o).catch(qr.error));
            let h = i2.timeline;
            i2.timeline = new Proxy(h, { set: (...d) => (f != null && d[1] === "close" && d[2] != null && h.close == null && (async () => {
              try {
                f.stat.status === "OPEN" && await f.close();
              } catch (m) {
                qr.error(m);
              } finally {
                this.dispatchEvent(new ee("connectionEnd", { detail: f }));
              }
            })().catch((m) => {
              qr.error(m);
            }), Reflect.set(...d)) }), i2.timeline.upgraded = Date.now();
            let p = () => {
              throw (0, Oi.default)(new Error("connection is not multiplexed"), q.ERR_CONNECTION_NOT_MULTIPLEXED);
            };
            return f = Pce({ remoteAddr: i2.remoteAddr, remotePeer: s, stat: { status: "OPEN", direction: n, timeline: i2.timeline, multiplexer: u?.protocol, encryption: r }, newStream: l ?? p, getStreams: () => u != null ? u.streams : p(), close: async () => {
              await i2.close(), u != null && await Promise.all(u.streams.map(async (d) => {
                await d.close();
              }));
            } }), this.dispatchEvent(new ee("connection", { detail: f })), f;
          }
          _onStream(e) {
            let { connection: r, stream: n, protocol: i2 } = e;
            this.components.getRegistrar().getHandler(i2)({ connection: r, stream: n, protocol: i2 });
          }
          async _encryptInbound(e) {
            let r = new nm(e), n = Array.from(this.connectionEncryption.keys());
            qr("handling inbound crypto protocol selection", n);
            try {
              let { stream: i2, protocol: o } = await r.handle(n), s = this.connectionEncryption.get(o);
              if (s == null)
                throw new Error(`no crypto module found for ${o}`);
              return qr("encrypting inbound connection..."), { ...await s.secureInbound(this.components.getPeerId(), i2), protocol: o };
            } catch (i2) {
              throw (0, Oi.default)(i2, q.ERR_ENCRYPTION_FAILED);
            }
          }
          async _encryptOutbound(e, r) {
            let n = new rm(e), i2 = Array.from(this.connectionEncryption.keys());
            qr("selecting outbound crypto protocol", i2);
            try {
              let { stream: o, protocol: s } = await n.select(i2), a = this.connectionEncryption.get(s);
              if (a == null)
                throw new Error(`no crypto module found for ${s}`);
              return qr("encrypting outbound connection to %p", r), { ...await a.secureOutbound(this.components.getPeerId(), o, r), protocol: s };
            } catch (o) {
              throw (0, Oi.default)(o, q.ERR_ENCRYPTION_FAILED);
            }
          }
          async _multiplexOutbound(e, r) {
            let n = new rm(e), i2 = Array.from(r.keys());
            qr("outbound selecting muxer %s", i2);
            try {
              let { stream: o, protocol: s } = await n.select(i2);
              qr("%s selected as muxer protocol", s);
              let a = r.get(s);
              return { stream: o, muxerFactory: a };
            } catch (o) {
              throw qr.error("error multiplexing outbound stream", o), (0, Oi.default)(o, q.ERR_MUXER_UNAVAILABLE);
            }
          }
          async _multiplexInbound(e, r) {
            let n = new nm(e), i2 = Array.from(r.keys());
            qr("inbound handling muxers %s", i2);
            try {
              let { stream: o, protocol: s } = await n.handle(i2), a = r.get(s);
              return { stream: o, muxerFactory: a };
            } catch (o) {
              throw qr.error("error multiplexing inbound stream", o), (0, Oi.default)(o, q.ERR_MUXER_UNAVAILABLE);
            }
          }
        };
        c();
        var _D = w(K(), 1);
        var Dce = C("libp2p:registrar");
        function bD(t, e) {
          for (let r of t)
            if (e.includes(r))
              return true;
          return false;
        }
        var b_ = class {
          constructor(e) {
            this.topologies = /* @__PURE__ */ new Map(), this.handlers = /* @__PURE__ */ new Map(), this.components = e, this._onDisconnect = this._onDisconnect.bind(this), this._onProtocolChange = this._onProtocolChange.bind(this), this.components.getConnectionManager().addEventListener("peer:disconnect", this._onDisconnect), this.components.getPeerStore().addEventListener("change:protocols", this._onProtocolChange);
          }
          getProtocols() {
            let e = /* @__PURE__ */ new Set();
            for (let r of this.topologies.values())
              r.protocols.forEach((n) => e.add(n));
            for (let r of this.handlers.keys())
              e.add(r);
            return Array.from(e).sort();
          }
          getHandler(e) {
            let r = this.handlers.get(e);
            if (r == null)
              throw new Error(`No handler registered for protocol ${e}`);
            return r;
          }
          getTopologies(e) {
            let r = [];
            for (let { topology: n, protocols: i2 } of this.topologies.values())
              i2.includes(e) && r.push(n);
            return r;
          }
          async handle(e, r) {
            let n = Array.isArray(e) ? e : [e];
            for (let i2 of n) {
              if (this.handlers.has(i2))
                throw (0, _D.default)(new Error(`Handler already registered for protocol ${i2}`), q.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);
              this.handlers.set(i2, r);
            }
            await this.components.getPeerStore().protoBook.add(this.components.getPeerId(), n);
          }
          async unhandle(e) {
            let r = Array.isArray(e) ? e : [e];
            r.forEach((n) => {
              this.handlers.delete(n);
            }), await this.components.getPeerStore().protoBook.remove(this.components.getPeerId(), r);
          }
          async register(e, r) {
            if (!jee(r))
              throw Dce.error("topology must be an instance of interfaces/topology"), (0, _D.default)(new Error("topology must be an instance of interfaces/topology"), q.ERR_INVALID_PARAMETERS);
            let n = `${(Math.random() * 1e9).toString(36)}${Date.now()}`;
            return this.topologies.set(n, { topology: r, protocols: Array.isArray(e) ? e : [e] }), await r.setRegistrar(this), n;
          }
          unregister(e) {
            this.topologies.delete(e);
          }
          _onDisconnect(e) {
            let r = e.detail;
            this.components.getPeerStore().protoBook.get(r.remotePeer).then((n) => {
              for (let { topology: i2, protocols: o } of this.topologies.values())
                bD(n, o) && i2.onDisconnect(r.remotePeer);
            }).catch((n) => {
              Dce.error(n);
            });
          }
          _onProtocolChange(e) {
            let { peerId: r, protocols: n, oldProtocols: i2 } = e.detail, o = i2.filter((a) => !n.includes(a)), s = n.filter((a) => !i2.includes(a));
            for (let { topology: a, protocols: u } of this.topologies.values())
              bD(o, u) && a.onDisconnect(r);
            for (let { topology: a, protocols: u } of this.topologies.values())
              if (bD(s, u)) {
                let l = this.components.getConnectionManager().getConnections(r)[0];
                if (l == null)
                  continue;
                a.onConnect(r, l);
              }
          }
        };
        c();
        var Ld = w(K(), 1);
        var vD = w(Ci(), 1), SD = w(Gc(), 1);
        Re();
        c();
        var Od;
        (function(t) {
          t.codec = () => Xe({ 5: { name: "protocolVersion", codec: pn, optional: true }, 6: { name: "agentVersion", codec: pn, optional: true }, 1: { name: "publicKey", codec: ye, optional: true }, 2: { name: "listenAddrs", codec: ye, repeats: true }, 4: { name: "observedAddr", codec: ye, optional: true }, 3: { name: "protocols", codec: pn, repeats: true }, 8: { name: "signedPeerRecord", codec: ye, optional: true } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(Od || (Od = {}));
        c();
        c();
        var __ = "0.0.0", kce = "libp2p";
        var Nce = `js-libp2p/${__}`;
        var Oce = "0.1.0", Lce = "id", Bce = "id/push", Mce = "1.0.0", Uce = "1.0.0";
        var R3 = w($o(), 1);
        var br = C("libp2p:identify"), v_ = 6e4, Fce = 1024 * 8, im = class {
          constructor(e, r) {
            this.components = e, this.started = false, this.init = r, this.handleMessage = this.handleMessage.bind(this), this.identifyProtocolStr = `/${r.protocolPrefix}/${Lce}/${Mce}`, this.identifyPushProtocolStr = `/${r.protocolPrefix}/${Bce}/${Uce}`, this.host = { protocolVersion: `${r.protocolPrefix}/${Oce}`, ...r.host }, this.components.getConnectionManager().addEventListener("peer:connect", (n) => {
              let i2 = n.detail;
              this.identify(i2).catch(br.error);
            }), this.components.getPeerStore().addEventListener("change:multiaddrs", (n) => {
              let { peerId: i2 } = n.detail;
              this.components.getPeerId().equals(i2) && this.pushToPeerStore().catch((o) => br.error(o));
            }), this.components.getPeerStore().addEventListener("change:protocols", (n) => {
              let { peerId: i2 } = n.detail;
              this.components.getPeerId().equals(i2) && this.pushToPeerStore().catch((o) => br.error(o));
            });
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started || (await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "AgentVersion", U(this.host.agentVersion)), await this.components.getPeerStore().metadataBook.setValue(this.components.getPeerId(), "ProtocolVersion", U(this.host.protocolVersion)), await this.components.getRegistrar().handle([this.identifyProtocolStr, this.identifyPushProtocolStr], (e) => {
              this.handleMessage(e)?.catch((r) => {
                br.error(r);
              });
            }), this.started = true);
          }
          async stop() {
            await this.components.getRegistrar().unhandle(this.identifyProtocolStr), await this.components.getRegistrar().unhandle(this.identifyPushProtocolStr), this.started = false;
          }
          async push(e) {
            let r = await this.components.getPeerStore().addressBook.getRawEnvelope(this.components.getPeerId()), n = this.components.getAddressManager().getAddresses().map((s) => s.bytes), i2 = await this.components.getPeerStore().protoBook.get(this.components.getPeerId()), o = e.map(async (s) => {
              let a = new R3.TimeoutController(this.init.timeout ?? v_), u;
              try {
                u = (await s.newStream([this.identifyPushProtocolStr], { signal: a.signal })).stream;
                let f = as(u, a.signal);
                await Te([Od.encode({ listenAddrs: n, signedPeerRecord: r, protocols: i2 })], kr(), f, vD.default);
              } catch (l) {
                br.error("could not push identify update to peer", l);
              } finally {
                u?.close(), a.clear();
              }
            });
            await Promise.all(o);
          }
          async pushToPeerStore() {
            if (!this.isStarted())
              return;
            let e = [];
            for (let r of this.components.getConnectionManager().getConnections()) {
              let n = r.remotePeer;
              !(await this.components.getPeerStore().get(n)).protocols.includes(this.identifyPushProtocolStr) || e.push(r);
            }
            await this.push(e);
          }
          async _identify(e, r = {}) {
            let { stream: n } = await e.newStream([this.identifyProtocolStr], r), i2 = n, o, s = r.signal;
            s == null && (o = new R3.TimeoutController(this.init.timeout ?? v_), s = o.signal), i2 = as(n, s);
            try {
              let a = await Te([], i2, Er({ maxDataLength: this.init.maxIdentifyMessageSize ?? Fce }), async (u) => await (0, SD.default)(u));
              if (a == null)
                throw (0, Ld.default)(new Error("No data could be retrieved"), q.ERR_CONNECTION_ENDED);
              try {
                return Od.decode(a);
              } catch (u) {
                throw (0, Ld.default)(u, q.ERR_INVALID_MESSAGE);
              }
            } finally {
              o?.clear(), n.close();
            }
          }
          async identify(e, r = {}) {
            let n = await this._identify(e, r), { publicKey: i2, listenAddrs: o, protocols: s, observedAddr: a, signedPeerRecord: u, agentVersion: l, protocolVersion: f } = n;
            if (i2 == null)
              throw (0, Ld.default)(new Error("public key was missing from identify message"), q.ERR_MISSING_PUBLIC_KEY);
            let h = await sn(i2);
            if (!e.remotePeer.equals(h))
              throw (0, Ld.default)(new Error("identified peer does not match the expected peer"), q.ERR_INVALID_PEER);
            if (this.components.getPeerId().equals(h))
              throw (0, Ld.default)(new Error("identified peer is our own peer id?"), q.ERR_INVALID_PEER);
            let p = im.getCleanMultiaddr(a);
            if (u != null) {
              br("received signed peer record from %p", h);
              try {
                let d = await ln.openAndCertify(u, wn.DOMAIN);
                if (!d.peerId.equals(h))
                  throw (0, Ld.default)(new Error("identified peer does not match the expected peer"), q.ERR_INVALID_PEER);
                if (await this.components.getPeerStore().addressBook.consumePeerRecord(d)) {
                  await this.components.getPeerStore().protoBook.set(h, s), l != null && await this.components.getPeerStore().metadataBook.setValue(h, "AgentVersion", U(l)), f != null && await this.components.getPeerStore().metadataBook.setValue(h, "ProtocolVersion", U(f)), br("identify completed for peer %p and protocols %o", h, s);
                  return;
                }
              } catch (d) {
                br("received invalid envelope, discard it and fallback to listenAddrs is available", d);
              }
            } else
              br("no signed peer record received from %p", h);
            br("falling back to legacy addresses from %p", h);
            try {
              await this.components.getPeerStore().addressBook.set(h, o.map((d) => new j(d)));
            } catch (d) {
              br.error("received invalid addrs", d);
            }
            await this.components.getPeerStore().protoBook.set(h, s), l != null && await this.components.getPeerStore().metadataBook.setValue(h, "AgentVersion", U(l)), f != null && await this.components.getPeerStore().metadataBook.setValue(h, "ProtocolVersion", U(f)), br("identify completed for peer %p and protocols %o", h, s), br("received observed address of %s", p?.toString());
          }
          handleMessage(e) {
            let { protocol: r } = e;
            switch (r) {
              case this.identifyProtocolStr:
                return this._handleIdentify(e);
              case this.identifyPushProtocolStr:
                return this._handlePush(e);
              default:
                br.error("cannot handle unknown protocol %s", r);
            }
          }
          async _handleIdentify(e) {
            let { connection: r, stream: n } = e, i2 = new R3.TimeoutController(this.init.timeout ?? v_);
            try {
              let o = this.components.getPeerId().publicKey ?? new Uint8Array(0), s = await this.components.getPeerStore().get(this.components.getPeerId()), a = this.components.getAddressManager().getAddresses().map((h) => h.decapsulateCode(Tn("p2p").code)), u = s.peerRecordEnvelope;
              if (a.length > 0 && u == null) {
                let h = new wn({ peerId: this.components.getPeerId(), multiaddrs: a }), p = await ln.seal(h, this.components.getPeerId());
                await this.components.getPeerStore().addressBook.consumePeerRecord(p), u = p.marshal();
              }
              let l = Od.encode({ protocolVersion: this.host.protocolVersion, agentVersion: this.host.agentVersion, publicKey: o, listenAddrs: a.map((h) => h.bytes), signedPeerRecord: u, observedAddr: r.remoteAddr.bytes, protocols: s.protocols }), f = as(n, i2.signal);
              await Te([l], kr(), f, vD.default);
            } catch (o) {
              br.error("could not respond to identify request", o);
            } finally {
              n.close(), i2.clear();
            }
          }
          async _handlePush(e) {
            let { connection: r, stream: n } = e, i2 = new R3.TimeoutController(this.init.timeout ?? v_), o;
            try {
              let a = as(n, i2.signal), u = await Te([], a, Er({ maxDataLength: this.init.maxIdentifyMessageSize ?? Fce }), async (l) => await (0, SD.default)(l));
              u != null && (o = Od.decode(u));
            } catch (a) {
              return br.error("received invalid message", a);
            } finally {
              n.close(), i2.clear();
            }
            if (o == null)
              return br.error("received invalid message");
            let s = r.remotePeer;
            if (this.components.getPeerId().equals(s)) {
              br("received push from ourselves?");
              return;
            }
            if (br("received push from %p", s), o.signedPeerRecord != null) {
              br("received signedPeerRecord in push");
              try {
                let a = await ln.openAndCertify(o.signedPeerRecord, wn.DOMAIN);
                if (await this.components.getPeerStore().addressBook.consumePeerRecord(a)) {
                  br("consumed signedPeerRecord sent in push"), await this.components.getPeerStore().protoBook.set(s, o.protocols);
                  return;
                } else
                  br("failed to consume signedPeerRecord sent in push");
              } catch (a) {
                br("received invalid envelope, discard it and fallback to listenAddrs is available", a);
              }
            } else
              br("did not receive signedPeerRecord in push");
            try {
              await this.components.getPeerStore().addressBook.set(s, o.listenAddrs.map((a) => new j(a)));
            } catch (a) {
              br.error("received invalid addrs", a);
            }
            try {
              await this.components.getPeerStore().protoBook.set(s, o.protocols);
            } catch (a) {
              br.error("received invalid protocols", a);
            }
            br("handled push from %p", s);
          }
          static getCleanMultiaddr(e) {
            if (e != null && e.length > 0)
              try {
                return new j(e);
              } catch {
              }
          }
        };
        c();
        var S_ = w(K(), 1);
        c();
        var A3;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "identifier", codec: pn } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(A3 || (A3 = {}));
        var na;
        (function(t) {
          let e;
          (function(n) {
            n.OK = "OK", n.NOT_FOUND = "NOT_FOUND", n.ERROR = "ERROR";
          })(e = t.StatusCode || (t.StatusCode = {}));
          let r;
          (function(n) {
            n[n.OK = 0] = "OK", n[n.NOT_FOUND = 1] = "NOT_FOUND", n[n.ERROR = 2] = "ERROR";
          })(r || (r = {})), function(n) {
            n.codec = () => xi(r);
          }(e = t.StatusCode || (t.StatusCode = {})), t.codec = () => Xe({ 1: { name: "status", codec: t.StatusCode.codec() }, 2: { name: "data", codec: ye } }), t.encode = (n) => Qe(n, t.codec()), t.decode = (n) => Ye(n, t.codec());
        })(na || (na = {}));
        c();
        var Kce = "0.0.1", Vce = "fetch";
        var qce = C("libp2p:fetch"), x_ = class {
          constructor(e, r) {
            this.started = false, this.components = e, this.protocol = `/${r.protocolPrefix ?? "libp2p"}/${Vce}/${Kce}`, this.lookupFunctions = /* @__PURE__ */ new Map(), this.handleMessage = this.handleMessage.bind(this);
          }
          async start() {
            await this.components.getRegistrar().handle(this.protocol, (e) => {
              this.handleMessage(e).catch((r) => {
                qce.error(r);
              });
            }), this.started = true;
          }
          async stop() {
            await this.components.getRegistrar().unhandle(this.protocol), this.started = false;
          }
          isStarted() {
            return this.started;
          }
          async fetch(e, r, n = {}) {
            qce("dialing %s to %p", this.protocol, e);
            let i2 = await this.components.getConnectionManager().openConnection(e, n), { stream: o } = await i2.newStream([this.protocol], n), s = o;
            n.signal != null && (s = as(o, n.signal));
            let a = Io(s);
            a.write(kr.single(A3.encode({ identifier: r })).slice());
            let u = na.decode((await Er.fromReader(a.reader).next()).value.slice());
            switch (u.status) {
              case na.StatusCode.OK:
                return u.data;
              case na.StatusCode.NOT_FOUND:
                return null;
              case na.StatusCode.ERROR: {
                let l = new TextDecoder().decode(u.data);
                throw (0, S_.default)(new Error("Error in fetch protocol response: " + l), q.ERR_INVALID_PARAMETERS);
              }
              default:
                throw (0, S_.default)(new Error("Unknown response status"), q.ERR_INVALID_MESSAGE);
            }
          }
          async handleMessage(e) {
            let { stream: r } = e, n = Io(r), i2 = A3.decode((await Er.fromReader(n.reader).next()).value.slice()), o, s = this._getLookupFunction(i2.identifier);
            if (s != null) {
              let a = await s(i2.identifier);
              a != null ? o = { status: na.StatusCode.OK, data: a } : o = { status: na.StatusCode.NOT_FOUND, data: new Uint8Array(0) };
            } else {
              let a = new TextEncoder().encode("No lookup function registered for key: " + i2.identifier);
              o = { status: na.StatusCode.ERROR, data: a };
            }
            n.write(kr.single(na.encode(o)).slice());
          }
          _getLookupFunction(e) {
            for (let r of this.lookupFunctions.keys())
              if (e.startsWith(r))
                return this.lookupFunctions.get(r);
          }
          registerLookupFunction(e, r) {
            if (this.lookupFunctions.has(e))
              throw (0, S_.default)(new Error("Fetch protocol handler for key prefix '" + e + "' already registered"), q.ERR_KEY_ALREADY_EXISTS);
            this.lookupFunctions.set(e, r);
          }
          unregisterLookupFunction(e, r) {
            r != null && this.lookupFunctions.get(e) !== r || this.lookupFunctions.delete(e);
          }
        };
        c();
        var Gce = w(K(), 1);
        var Wce = w(Gc(), 1);
        yr();
        c();
        var zce = "1.0.0", Hce = "ping";
        var $ce = C("libp2p:ping"), R_ = class {
          constructor(e, r) {
            this.components = e, this.started = false, this.protocol = `/${r.protocolPrefix}/${Hce}/${zce}`;
          }
          async start() {
            await this.components.getRegistrar().handle(this.protocol, this.handleMessage), this.started = true;
          }
          async stop() {
            await this.components.getRegistrar().unhandle(this.protocol), this.started = false;
          }
          isStarted() {
            return this.started;
          }
          handleMessage(e) {
            let { stream: r } = e;
            Te(r, r).catch((n) => {
              $ce.error(n);
            });
          }
          async ping(e, r = {}) {
            $ce("dialing %s to %p", this.protocol, e);
            let n = await this.components.getConnectionManager().openConnection(e, r), { stream: i2 } = await n.newStream([this.protocol], r), o = Date.now(), s = Fs(32), a = i2;
            r.signal != null && (a = as(i2, r.signal));
            try {
              let u = await Te([s], a, async (f) => await (0, Wce.default)(f)), l = Date.now();
              if (u == null || !Ce(s, u))
                throw (0, Gce.default)(new Error("Received wrong ping ack"), q.ERR_WRONG_PING_ACK);
              return l - o;
            } finally {
              i2.close();
            }
          }
        };
        c();
        c();
        async function jce() {
          throw new Error("Not supported in browsers");
        }
        var TD = w(xD(), 1), Zce = w(Jb(), 1);
        var Jce = w(K(), 1);
        c();
        c();
        function Qce(t) {
          return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t) || /^::1$/.test(t);
        }
        function Xce(t) {
          let { address: e } = t.nodeAddress();
          return Qce(e);
        }
        var RD = C("libp2p:nat"), AD = 7200;
        function dke(t = 1024, e = 65535) {
          return Math.floor(Math.random() * (e - t + 1) + t);
        }
        var T_ = class {
          constructor(e, r) {
            if (this.components = e, this.started = false, this.enabled = r.enabled, this.externalAddress = r.externalAddress, this.localAddress = r.localAddress, this.description = r.description ?? `${kce}@${__} ${this.components.getPeerId().toString()}`, this.ttl = r.ttl ?? AD, this.keepAlive = r.keepAlive ?? true, this.gateway = r.gateway, this.ttl < AD)
              throw (0, Jce.default)(new Error(`NatManager ttl should be at least ${AD} seconds`), q.ERR_INVALID_PARAMETERS);
          }
          isStarted() {
            return this.started;
          }
          start() {
          }
          afterStart() {
            TD.isBrowser || !this.enabled || this.started || (this.started = true, this._start().catch((e) => {
              RD.error(e);
            }));
          }
          async _start() {
            let e = this.components.getTransportManager().getAddrs();
            for (let r of e) {
              let { family: n, host: i2, port: o, transport: s } = r.toOptions();
              if (!r.isThinWaistAddress() || s !== "tcp" || Xce(r) || n !== 4)
                continue;
              let a = await this._getClient(), u = this.externalAddress ?? await a.externalIp();
              if ((0, Zce.default)(u))
                throw new Error(`${u} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
              let l = dke();
              RD(`opening uPnP connection from ${u}:${l} to ${i2}:${o}`), await a.map({ publicPort: l, localPort: o, localAddress: this.localAddress, protocol: s.toUpperCase() === "TCP" ? "TCP" : "UDP" }), this.components.getAddressManager().addObservedAddr(j.fromNodeAddress({ family: 4, address: u, port: l }, s));
            }
          }
          async _getClient() {
            return this.client != null ? this.client : (this.client = await jce({ description: this.description, ttl: this.ttl, keepAlive: this.keepAlive, gateway: this.gateway }), this.client);
          }
          async stop() {
            if (!(TD.isBrowser || this.client == null))
              try {
                await this.client.close(), this.client = void 0;
              } catch (e) {
                RD.error(e);
              }
          }
        };
        c();
        var pke = C("libp2p:peer-record-updater"), I_ = class {
          constructor(e) {
            this.components = e, this.started = false, this.update = this.update.bind(this);
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started = true, this.components.getTransportManager().addEventListener("listener:listening", this.update), this.components.getTransportManager().addEventListener("listener:close", this.update), this.components.getAddressManager().addEventListener("change:addresses", this.update);
          }
          async stop() {
            this.started = false, this.components.getTransportManager().removeEventListener("listener:listening", this.update), this.components.getTransportManager().removeEventListener("listener:close", this.update), this.components.getAddressManager().removeEventListener("change:addresses", this.update);
          }
          update() {
            Promise.resolve().then(async () => {
              let e = new wn({ peerId: this.components.getPeerId(), multiaddrs: this.components.getAddressManager().getAddresses().map((n) => n.decapsulateCode(Tn("p2p").code)) }), r = await ln.seal(e, this.components.getPeerId());
              await this.components.getPeerStore().addressBook.consumePeerRecord(r);
            }).catch((e) => {
              pke.error("Could not update self peer record: %o", e);
            });
          }
        };
        c();
        var eue = w(K(), 1);
        var C_ = class {
          constructor(e) {
            this.dht = e;
          }
          async findPeer(e, r = {}) {
            for await (let n of this.dht.findPeer(e, r))
              if (n.name === "FINAL_PEER")
                return n.peer;
            throw (0, eue.default)(new Error(_t.NOT_FOUND), q.ERR_NOT_FOUND);
          }
          async *getClosestPeers(e, r = {}) {
            for await (let n of this.dht.getClosestPeers(e, r))
              n.name === "PEER_RESPONSE" && (yield* n.closer);
          }
        };
        c();
        c();
        var D_ = w(K(), 1);
        c();
        var wt = { ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS", ERR_NOT_FOUND: "ERR_NOT_FOUND" };
        var tue = w(Vs(), 1), rue = w(Gi(), 1), nue = w(ei(), 1), iue = w(sD(), 1);
        var mr = C("libp2p:peer-store:address-book"), P_ = "change:multiaddrs";
        async function mke() {
          return true;
        }
        var k_ = class {
          constructor(e, r, n) {
            this.dispatchEvent = e, this.store = r, this.addressFilter = n ?? mke;
          }
          async consumePeerRecord(e) {
            mr.trace("consumePeerRecord await write lock");
            let r = await this.store.lock.writeLock();
            mr.trace("consumePeerRecord got write lock");
            let n, i2, o;
            try {
              let s;
              try {
                s = wn.createFromProtobuf(e.payload);
              } catch {
                return mr.error("invalid peer record received"), false;
              }
              n = s.peerId;
              let a = s.multiaddrs;
              if (!n.equals(e.peerId))
                return mr("signing key does not match PeerId in the PeerRecord"), false;
              if (a == null || a.length === 0)
                return false;
              if (await this.store.has(n) && (i2 = await this.store.load(n), i2.peerRecordEnvelope != null)) {
                let l = await ln.createFromProtobuf(i2.peerRecordEnvelope), f = wn.createFromProtobuf(l.payload);
                if (f.seqNumber >= s.seqNumber)
                  return mr("sequence number was lower or equal to existing sequence number - stored: %d received: %d", f.seqNumber, s.seqNumber), false;
              }
              let u = await ID(n, a, this.addressFilter, true);
              o = await this.store.patchOrCreate(n, { addresses: u, peerRecordEnvelope: e.marshal() }), mr("stored provided peer record for %p", s.peerId);
            } finally {
              mr.trace("consumePeerRecord release write lock"), r();
            }
            return this.dispatchEvent(new ee(P_, { detail: { peerId: n, multiaddrs: o.addresses.map(({ multiaddr: s }) => s), oldMultiaddrs: i2 == null ? [] : i2.addresses.map(({ multiaddr: s }) => s) } })), true;
          }
          async getRawEnvelope(e) {
            mr.trace("getRawEnvelope await read lock");
            let r = await this.store.lock.readLock();
            mr.trace("getRawEnvelope got read lock");
            try {
              return (await this.store.load(e)).peerRecordEnvelope;
            } catch (n) {
              if (n.code !== wt.ERR_NOT_FOUND)
                throw n;
            } finally {
              mr.trace("getRawEnvelope release read lock"), r();
            }
          }
          async getPeerRecord(e) {
            let r = await this.getRawEnvelope(e);
            if (r != null)
              return await ln.createFromProtobuf(r);
          }
          async get(e) {
            e = on(e), mr.trace("get wait for read lock");
            let r = await this.store.lock.readLock();
            mr.trace("get got read lock");
            try {
              return (await this.store.load(e)).addresses;
            } catch (n) {
              if (n.code !== wt.ERR_NOT_FOUND)
                throw n;
            } finally {
              mr.trace("get release read lock"), r();
            }
            return [];
          }
          async set(e, r) {
            if (e = on(e), !Array.isArray(r))
              throw mr.error("multiaddrs must be an array of Multiaddrs"), (0, D_.default)(new Error("multiaddrs must be an array of Multiaddrs"), wt.ERR_INVALID_PARAMETERS);
            mr.trace("set await write lock");
            let n = await this.store.lock.writeLock();
            mr.trace("set got write lock");
            let i2 = false, o, s;
            try {
              let a = await ID(e, r, this.addressFilter);
              if (a.length === 0)
                return;
              try {
                if (o = await this.store.load(e), i2 = true, (/* @__PURE__ */ new Set([...a.map(({ multiaddr: u }) => u.toString()), ...o.addresses.map(({ multiaddr: u }) => u.toString())])).size === o.addresses.length && a.length === o.addresses.length)
                  return;
              } catch (u) {
                if (u.code !== wt.ERR_NOT_FOUND)
                  throw u;
              }
              s = await this.store.patchOrCreate(e, { addresses: a }), mr("set multiaddrs for %p", e);
            } finally {
              mr.trace("set multiaddrs for %p", e), mr("set release write lock"), n();
            }
            this.dispatchEvent(new ee(P_, { detail: { peerId: e, multiaddrs: s.addresses.map((a) => a.multiaddr), oldMultiaddrs: o == null ? [] : o.addresses.map(({ multiaddr: a }) => a) } })), i2 || this.dispatchEvent(new ee("peer", { detail: { id: e, multiaddrs: s.addresses.map((a) => a.multiaddr), protocols: s.protocols } }));
          }
          async add(e, r) {
            if (e = on(e), !Array.isArray(r))
              throw mr.error("multiaddrs must be an array of Multiaddrs"), (0, D_.default)(new Error("multiaddrs must be an array of Multiaddrs"), wt.ERR_INVALID_PARAMETERS);
            mr.trace("add await write lock");
            let n = await this.store.lock.writeLock();
            mr.trace("add got write lock");
            let i2, o, s;
            try {
              let a = await ID(e, r, this.addressFilter);
              if (a.length === 0)
                return;
              try {
                if (o = await this.store.load(e), i2 = true, (/* @__PURE__ */ new Set([...a.map(({ multiaddr: u }) => u.toString()), ...o.addresses.map(({ multiaddr: u }) => u.toString())])).size === o.addresses.length)
                  return;
              } catch (u) {
                if (u.code !== wt.ERR_NOT_FOUND)
                  throw u;
              }
              s = await this.store.mergeOrCreate(e, { addresses: a }), mr("added multiaddrs for %p", e);
            } finally {
              mr.trace("set release write lock"), n();
            }
            this.dispatchEvent(new ee(P_, { detail: { peerId: e, multiaddrs: s.addresses.map((a) => a.multiaddr), oldMultiaddrs: o == null ? [] : o.addresses.map(({ multiaddr: a }) => a) } })), i2 === true && this.dispatchEvent(new ee("peer", { detail: { id: e, multiaddrs: s.addresses.map((a) => a.multiaddr), protocols: s.protocols } }));
          }
          async delete(e) {
            e = on(e), mr.trace("delete await write lock");
            let r = await this.store.lock.writeLock();
            mr.trace("delete got write lock");
            let n;
            try {
              try {
                n = await this.store.load(e);
              } catch (i2) {
                if (i2.code !== wt.ERR_NOT_FOUND)
                  throw i2;
              }
              await this.store.patchOrCreate(e, { addresses: [] });
            } finally {
              mr.trace("delete release write lock"), r();
            }
            n != null && this.dispatchEvent(new ee(P_, { detail: { peerId: e, multiaddrs: [], oldMultiaddrs: n == null ? [] : n.addresses.map(({ multiaddr: i2 }) => i2) } }));
          }
        };
        async function ID(t, e, r, n = false) {
          return await Te(e, (i2) => (0, iue.default)(i2, (o) => {
            if (!j.isMultiaddr(o))
              throw mr.error("multiaddr must be an instance of Multiaddr"), (0, D_.default)(new Error("multiaddr must be an instance of Multiaddr"), wt.ERR_INVALID_PARAMETERS);
          }), (i2) => (0, rue.default)(i2, async (o) => await r(t, o)), (i2) => (0, nue.default)(i2, (o) => ({ multiaddr: new j(o.toString()), isCertified: n })), async (i2) => await (0, tue.default)(i2));
        }
        c();
        var sue = w(K(), 1);
        yr();
        var ac = C("libp2p:peer-store:key-book"), oue = "change:pubkey", N_ = class {
          constructor(e, r) {
            this.dispatchEvent = e, this.store = r;
          }
          async set(e, r) {
            if (e = on(e), !(r instanceof Uint8Array))
              throw ac.error("publicKey must be an instance of Uint8Array to store data"), (0, sue.default)(new Error("publicKey must be an instance of PublicKey"), wt.ERR_INVALID_PARAMETERS);
            ac.trace("set await write lock");
            let n = await this.store.lock.writeLock();
            ac.trace("set got write lock");
            let i2 = false, o;
            try {
              try {
                if (o = await this.store.load(e), o.pubKey != null && Ce(o.pubKey, r))
                  return;
              } catch (s) {
                if (s.code !== wt.ERR_NOT_FOUND)
                  throw s;
              }
              await this.store.patchOrCreate(e, { pubKey: r }), i2 = true;
            } finally {
              ac.trace("set release write lock"), n();
            }
            i2 && this.dispatchEvent(new ee(oue, { detail: { peerId: e, publicKey: r, oldPublicKey: o?.pubKey } }));
          }
          async get(e) {
            e = on(e), ac.trace("get await write lock");
            let r = await this.store.lock.readLock();
            ac.trace("get got write lock");
            try {
              return (await this.store.load(e)).pubKey;
            } catch (n) {
              if (n.code !== wt.ERR_NOT_FOUND)
                throw n;
            } finally {
              ac("get release write lock"), r();
            }
          }
          async delete(e) {
            e = on(e), ac.trace("delete await write lock");
            let r = await this.store.lock.writeLock();
            ac.trace("delete got write lock");
            let n;
            try {
              try {
                n = await this.store.load(e);
              } catch (i2) {
                if (i2.code !== wt.ERR_NOT_FOUND)
                  throw i2;
              }
              await this.store.patchOrCreate(e, { pubKey: void 0 });
            } catch (i2) {
              if (i2.code !== wt.ERR_NOT_FOUND)
                throw i2;
            } finally {
              ac.trace("delete release write lock"), r();
            }
            this.dispatchEvent(new ee(oue, { detail: { peerId: e, publicKey: void 0, oldPublicKey: n?.pubKey } }));
          }
        };
        c();
        var CD = w(K(), 1);
        yr();
        var vn = C("libp2p:peer-store:metadata-book"), O_ = "change:metadata", L_ = class {
          constructor(e, r) {
            this.dispatchEvent = e, this.store = r;
          }
          async get(e) {
            e = on(e), vn.trace("get await read lock");
            let r = await this.store.lock.readLock();
            vn.trace("get got read lock");
            try {
              return (await this.store.load(e)).metadata;
            } catch (n) {
              if (n.code !== wt.ERR_NOT_FOUND)
                throw n;
            } finally {
              vn.trace("get release read lock"), r();
            }
            return /* @__PURE__ */ new Map();
          }
          async getValue(e, r) {
            e = on(e), vn.trace("getValue await read lock");
            let n = await this.store.lock.readLock();
            vn.trace("getValue got read lock");
            try {
              return (await this.store.load(e)).metadata.get(r);
            } catch (i2) {
              if (i2.code !== wt.ERR_NOT_FOUND)
                throw i2;
            } finally {
              vn.trace("getValue release write lock"), n();
            }
          }
          async set(e, r) {
            if (e = on(e), !(r instanceof Map))
              throw vn.error("valid metadata must be provided to store data"), (0, CD.default)(new Error("valid metadata must be provided"), wt.ERR_INVALID_PARAMETERS);
            vn.trace("set await write lock");
            let n = await this.store.lock.writeLock();
            vn.trace("set got write lock");
            let i2;
            try {
              try {
                i2 = await this.store.load(e);
              } catch (o) {
                if (o.code !== wt.ERR_NOT_FOUND)
                  throw o;
              }
              await this.store.mergeOrCreate(e, { metadata: r });
            } finally {
              vn.trace("set release write lock"), n();
            }
            this.dispatchEvent(new ee(O_, { detail: { peerId: e, metadata: r, oldMetadata: i2 == null ? /* @__PURE__ */ new Map() : i2.metadata } }));
          }
          async setValue(e, r, n) {
            if (e = on(e), typeof r != "string" || !(n instanceof Uint8Array))
              throw vn.error("valid key and value must be provided to store data"), (0, CD.default)(new Error("valid key and value must be provided"), wt.ERR_INVALID_PARAMETERS);
            vn.trace("setValue await write lock");
            let i2 = await this.store.lock.writeLock();
            vn.trace("setValue got write lock");
            let o, s;
            try {
              try {
                o = await this.store.load(e);
                let a = o.metadata.get(r);
                if (a != null && Ce(n, a))
                  return;
              } catch (a) {
                if (a.code !== wt.ERR_NOT_FOUND)
                  throw a;
              }
              s = await this.store.mergeOrCreate(e, { metadata: /* @__PURE__ */ new Map([[r, n]]) });
            } finally {
              vn.trace("setValue release write lock"), i2();
            }
            this.dispatchEvent(new ee(O_, { detail: { peerId: e, metadata: s.metadata, oldMetadata: o == null ? /* @__PURE__ */ new Map() : o.metadata } }));
          }
          async delete(e) {
            e = on(e), vn.trace("delete await write lock");
            let r = await this.store.lock.writeLock();
            vn.trace("delete got write lock");
            let n;
            try {
              try {
                n = await this.store.load(e);
              } catch (i2) {
                if (i2.code !== wt.ERR_NOT_FOUND)
                  throw i2;
              }
              n != null && await this.store.patch(e, { metadata: /* @__PURE__ */ new Map() });
            } finally {
              vn.trace("delete release write lock"), r();
            }
            n != null && this.dispatchEvent(new ee(O_, { detail: { peerId: e, metadata: /* @__PURE__ */ new Map(), oldMetadata: n.metadata } }));
          }
          async deleteValue(e, r) {
            e = on(e), vn.trace("deleteValue await write lock");
            let n = await this.store.lock.writeLock();
            vn.trace("deleteValue got write lock");
            let i2, o;
            try {
              o = await this.store.load(e), i2 = o.metadata, i2.delete(r), await this.store.patch(e, { metadata: i2 });
            } catch (s) {
              if (s.code !== wt.ERR_NOT_FOUND)
                throw s;
            } finally {
              vn.trace("deleteValue release write lock"), n();
            }
            i2 != null && this.dispatchEvent(new ee(O_, { detail: { peerId: e, metadata: i2, oldMetadata: o == null ? /* @__PURE__ */ new Map() : o.metadata } }));
          }
        };
        c();
        var M_ = w(K(), 1);
        var Sn = C("libp2p:peer-store:proto-book"), B_ = "change:protocols", U_ = class {
          constructor(e, r) {
            this.dispatchEvent = e, this.store = r;
          }
          async get(e) {
            Sn.trace("get wait for read lock");
            let r = await this.store.lock.readLock();
            Sn.trace("get got read lock");
            try {
              return (await this.store.load(e)).protocols;
            } catch (n) {
              if (n.code !== wt.ERR_NOT_FOUND)
                throw n;
            } finally {
              Sn.trace("get release read lock"), r();
            }
            return [];
          }
          async set(e, r) {
            if (e = on(e), !Array.isArray(r))
              throw Sn.error("protocols must be provided to store data"), (0, M_.default)(new Error("protocols must be provided"), wt.ERR_INVALID_PARAMETERS);
            Sn.trace("set await write lock");
            let n = await this.store.lock.writeLock();
            Sn.trace("set got write lock");
            let i2, o;
            try {
              try {
                if (i2 = await this.store.load(e), (/* @__PURE__ */ new Set([...r])).size === i2.protocols.length)
                  return;
              } catch (s) {
                if (s.code !== wt.ERR_NOT_FOUND)
                  throw s;
              }
              o = await this.store.patchOrCreate(e, { protocols: r }), Sn("stored provided protocols for %p", e);
            } finally {
              Sn.trace("set release write lock"), n();
            }
            this.dispatchEvent(new ee(B_, { detail: { peerId: e, protocols: o.protocols, oldProtocols: i2 == null ? [] : i2.protocols } }));
          }
          async add(e, r) {
            if (e = on(e), !Array.isArray(r))
              throw Sn.error("protocols must be provided to store data"), (0, M_.default)(new Error("protocols must be provided"), wt.ERR_INVALID_PARAMETERS);
            Sn.trace("add await write lock");
            let n = await this.store.lock.writeLock();
            Sn.trace("add got write lock");
            let i2, o;
            try {
              try {
                if (i2 = await this.store.load(e), (/* @__PURE__ */ new Set([...i2.protocols, ...r])).size === i2.protocols.length)
                  return;
              } catch (s) {
                if (s.code !== wt.ERR_NOT_FOUND)
                  throw s;
              }
              o = await this.store.mergeOrCreate(e, { protocols: r }), Sn("added provided protocols for %p", e);
            } finally {
              Sn.trace("add release write lock"), n();
            }
            this.dispatchEvent(new ee(B_, { detail: { peerId: e, protocols: o.protocols, oldProtocols: i2 == null ? [] : i2.protocols } }));
          }
          async remove(e, r) {
            if (e = on(e), !Array.isArray(r))
              throw Sn.error("protocols must be provided to store data"), (0, M_.default)(new Error("protocols must be provided"), wt.ERR_INVALID_PARAMETERS);
            Sn.trace("remove await write lock");
            let n = await this.store.lock.writeLock();
            Sn.trace("remove got write lock");
            let i2, o;
            try {
              try {
                i2 = await this.store.load(e);
                let s = new Set(i2.protocols);
                for (let a of r)
                  s.delete(a);
                if (i2.protocols.length === s.size)
                  return;
                r = Array.from(s);
              } catch (s) {
                if (s.code !== wt.ERR_NOT_FOUND)
                  throw s;
              }
              o = await this.store.patchOrCreate(e, { protocols: r });
            } finally {
              Sn.trace("remove release write lock"), n();
            }
            this.dispatchEvent(new ee(B_, { detail: { peerId: e, protocols: o.protocols, oldProtocols: i2 == null ? [] : i2.protocols } }));
          }
          async delete(e) {
            e = on(e), Sn.trace("delete await write lock");
            let r = await this.store.lock.writeLock();
            Sn.trace("delete got write lock");
            let n;
            try {
              try {
                n = await this.store.load(e);
              } catch (i2) {
                if (i2.code !== wt.ERR_NOT_FOUND)
                  throw i2;
              }
              await this.store.patchOrCreate(e, { protocols: [] });
            } finally {
              Sn.trace("delete release write lock"), r();
            }
            n != null && this.dispatchEvent(new ee(B_, { detail: { peerId: e, protocols: [], oldProtocols: n.protocols } }));
          }
        };
        c();
        var $D = w(K(), 1);
        si();
        c();
        var I3;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "addresses", codec: PD.codec(), repeats: true }, 2: { name: "protocols", codec: pn, repeats: true }, 3: { name: "metadata", codec: DD.codec(), repeats: true }, 4: { name: "pubKey", codec: ye, optional: true }, 5: { name: "peerRecordEnvelope", codec: ye, optional: true } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(I3 || (I3 = {}));
        var PD;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "multiaddr", codec: ye }, 2: { name: "isCertified", codec: P2, optional: true } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(PD || (PD = {}));
        var DD;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "key", codec: pn }, 2: { name: "value", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(DD || (DD = {}));
        c();
        c();
        var due = w(Xu(), 1);
        c();
        c();
        function kD(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var Bd = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, yu, C3 = class {
          constructor() {
            yu.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && Bd(this, yu, "f")[this.size - 1].priority >= r.priority) {
              Bd(this, yu, "f").push(n);
              return;
            }
            let i2 = kD(Bd(this, yu, "f"), n, (o, s) => s.priority - o.priority);
            Bd(this, yu, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = Bd(this, yu, "f").shift();
            return e?.run;
          }
          filter(e) {
            return Bd(this, yu, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return Bd(this, yu, "f").length;
          }
        };
        yu = /* @__PURE__ */ new WeakMap();
        var nr = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, ve = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Yn, D3, k3, wf, z_, N3, F_, ia, P3, Co, K_, Po, O3, gf, om, sm, Md, V_, aue, cue, hue, uue, lue, fue, q_, ND, OD, H_, $_ = () => {
        }, yke = new hi(), LD = class extends Error {
        }, am = class extends due.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), Yn.add(this), D3.set(this, void 0), k3.set(this, void 0), wf.set(this, 0), z_.set(this, void 0), N3.set(this, void 0), F_.set(this, 0), ia.set(this, void 0), P3.set(this, void 0), Co.set(this, void 0), K_.set(this, void 0), Po.set(this, 0), O3.set(this, void 0), gf.set(this, void 0), om.set(this, $_), sm.set(this, $_), Md.set(this, void 0), V_.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: C3, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            nr(this, D3, e.carryoverConcurrencyCount, "f"), nr(this, k3, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), nr(this, z_, e.intervalCap, "f"), nr(this, N3, e.interval, "f"), nr(this, Co, new e.queueClass(), "f"), nr(this, K_, e.queueClass, "f"), this.concurrency = e.concurrency, nr(this, Md, e.timeout, "f"), nr(this, V_, e.throwOnTimeout === true, "f"), nr(this, gf, e.autoStart === false, "f");
          }
          get concurrency() {
            return ve(this, O3, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            nr(this, O3, e, "f"), ve(this, Yn, "m", H_).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                nr(this, Po, (a = ve(this, Po, "f"), a++, a), "f"), nr(this, wf, (u = ve(this, wf, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new LD("The task was aborted."));
                    return;
                  }
                  let f = await (ve(this, Md, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? ve(this, Md, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? ve(this, V_, "f") : r.throwOnTimeout) && i2(yke);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                ve(this, Yn, "m", hue).call(this);
              };
              ve(this, Co, "f").enqueue(o, r), ve(this, Yn, "m", q_).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return ve(this, gf, "f") ? (nr(this, gf, false, "f"), ve(this, Yn, "m", H_).call(this), this) : this;
          }
          pause() {
            nr(this, gf, true, "f");
          }
          clear() {
            nr(this, Co, new (ve(this, K_, "f"))(), "f");
          }
          async onEmpty() {
            if (ve(this, Co, "f").size !== 0)
              return new Promise((e) => {
                let r = ve(this, om, "f");
                nr(this, om, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(ve(this, Co, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  ve(this, Co, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(ve(this, Po, "f") === 0 && ve(this, Co, "f").size === 0))
              return new Promise((e) => {
                let r = ve(this, sm, "f");
                nr(this, sm, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return ve(this, Co, "f").size;
          }
          sizeBy(e) {
            return ve(this, Co, "f").filter(e).length;
          }
          get pending() {
            return ve(this, Po, "f");
          }
          get isPaused() {
            return ve(this, gf, "f");
          }
          get timeout() {
            return ve(this, Md, "f");
          }
          set timeout(e) {
            nr(this, Md, e, "f");
          }
        };
        D3 = /* @__PURE__ */ new WeakMap(), k3 = /* @__PURE__ */ new WeakMap(), wf = /* @__PURE__ */ new WeakMap(), z_ = /* @__PURE__ */ new WeakMap(), N3 = /* @__PURE__ */ new WeakMap(), F_ = /* @__PURE__ */ new WeakMap(), ia = /* @__PURE__ */ new WeakMap(), P3 = /* @__PURE__ */ new WeakMap(), Co = /* @__PURE__ */ new WeakMap(), K_ = /* @__PURE__ */ new WeakMap(), Po = /* @__PURE__ */ new WeakMap(), O3 = /* @__PURE__ */ new WeakMap(), gf = /* @__PURE__ */ new WeakMap(), om = /* @__PURE__ */ new WeakMap(), sm = /* @__PURE__ */ new WeakMap(), Md = /* @__PURE__ */ new WeakMap(), V_ = /* @__PURE__ */ new WeakMap(), Yn = /* @__PURE__ */ new WeakSet(), aue = function() {
          return ve(this, k3, "f") || ve(this, wf, "f") < ve(this, z_, "f");
        }, cue = function() {
          return ve(this, Po, "f") < ve(this, O3, "f");
        }, hue = function() {
          var e;
          nr(this, Po, (e = ve(this, Po, "f"), e--, e), "f"), ve(this, Yn, "m", q_).call(this), this.emit("next");
        }, uue = function() {
          ve(this, om, "f").call(this), nr(this, om, $_, "f"), ve(this, Po, "f") === 0 && (ve(this, sm, "f").call(this), nr(this, sm, $_, "f"), this.emit("idle"));
        }, lue = function() {
          ve(this, Yn, "m", OD).call(this), ve(this, Yn, "m", ND).call(this), nr(this, P3, void 0, "f");
        }, fue = function() {
          let e = Date.now();
          if (ve(this, ia, "f") === void 0) {
            let r = ve(this, F_, "f") - e;
            if (r < 0)
              nr(this, wf, ve(this, D3, "f") ? ve(this, Po, "f") : 0, "f");
            else
              return ve(this, P3, "f") === void 0 && nr(this, P3, setTimeout(() => {
                ve(this, Yn, "m", lue).call(this);
              }, r), "f"), true;
          }
          return false;
        }, q_ = function() {
          if (ve(this, Co, "f").size === 0)
            return ve(this, ia, "f") && clearInterval(ve(this, ia, "f")), nr(this, ia, void 0, "f"), ve(this, Yn, "m", uue).call(this), false;
          if (!ve(this, gf, "f")) {
            let e = !ve(this, Yn, "m", fue).call(this);
            if (ve(this, Yn, "a", aue) && ve(this, Yn, "a", cue)) {
              let r = ve(this, Co, "f").dequeue();
              return r ? (this.emit("active"), r(), e && ve(this, Yn, "m", ND).call(this), true) : false;
            }
          }
          return false;
        }, ND = function() {
          ve(this, k3, "f") || ve(this, ia, "f") !== void 0 || (nr(this, ia, setInterval(() => {
            ve(this, Yn, "m", OD).call(this);
          }, ve(this, N3, "f")), "f"), nr(this, F_, Date.now() + ve(this, N3, "f"), "f"));
        }, OD = function() {
          ve(this, wf, "f") === 0 && ve(this, Po, "f") === 0 && ve(this, ia, "f") && (clearInterval(ve(this, ia, "f")), nr(this, ia, void 0, "f")), nr(this, wf, ve(this, D3, "f") ? ve(this, Po, "f") : 0, "f"), ve(this, Yn, "m", H_).call(this);
        }, H_ = function() {
          for (; ve(this, Yn, "m", q_).call(this); )
            ;
        };
        c();
        Lp();
        c();
        var BD = "lock:worker:request-read", MD = "lock:worker:release-read", UD = "lock:master:grant-read", FD = "lock:worker:request-write", KD = "lock:worker:release-write", VD = "lock:master:grant-write";
        c();
        var Ef = {}, cm = (t) => {
          t.addEventListener("message", (e) => {
            cm.dispatchEvent("message", t, e);
          }), t.port != null && t.port.addEventListener("message", (e) => {
            cm.dispatchEvent("message", t, e);
          });
        };
        cm.addEventListener = (t, e) => {
          Ef[t] == null && (Ef[t] = []), Ef[t].push(e);
        };
        cm.removeEventListener = (t, e) => {
          Ef[t] != null && (Ef[t] = Ef[t].filter((r) => r === e));
        };
        cm.dispatchEvent = function(t, e, r) {
          Ef[t] != null && Ef[t].forEach((n) => n(e, r));
        };
        var qD = cm;
        var pue = (t, e, r, n, i2) => (o, s) => {
          if (s.data.type !== r)
            return;
          let a = { type: s.data.type, name: s.data.name, identifier: s.data.identifier };
          t.dispatchEvent(new MessageEvent(e, { data: { name: a.name, handler: async () => (o.postMessage({ type: i2, name: a.name, identifier: a.identifier }), await new Promise((u) => {
            let l = (f) => {
              if (f == null || f.data == null)
                return;
              let h = { type: f.data.type, name: f.data.name, identifier: f.data.identifier };
              h.type === n && h.identifier === a.identifier && (o.removeEventListener("message", l), u());
            };
            o.addEventListener("message", l);
          })) } }));
        }, mue = (t, e, r, n) => async () => {
          let i2 = jf();
          return globalThis.postMessage({ type: e, identifier: i2, name: t }), await new Promise((o) => {
            let s = (a) => {
              if (a == null || a.data == null)
                return;
              let u = { type: a.data.type, identifier: a.data.identifier };
              u.type === r && u.identifier === i2 && (globalThis.removeEventListener("message", s), o(() => {
                globalThis.postMessage({ type: n, identifier: i2, name: t });
              }));
            };
            globalThis.addEventListener("message", s);
          });
        }, gke = { singleProcess: false }, yue = (t) => {
          if (t = Object.assign({}, gke, t), Boolean(globalThis.document) || t.singleProcess) {
            let r = new EventTarget();
            return qD.addEventListener("message", pue(r, "requestReadLock", BD, MD, UD)), qD.addEventListener("message", pue(r, "requestWriteLock", FD, KD, VD)), r;
          }
          return { isWorker: true, readLock: (r) => mue(r, BD, UD, MD), writeLock: (r) => mue(r, FD, VD, KD) };
        };
        var Ud = {}, bf;
        async function zD(t, e) {
          let r, n = new Promise((i2) => {
            r = i2;
          });
          return t.add(async () => await nn((async () => await new Promise((i2) => {
            r(() => {
              i2();
            });
          }))(), e.timeout)), await n;
        }
        var wke = (t, e) => {
          if (bf.isWorker === true)
            return { readLock: bf.readLock(t, e), writeLock: bf.writeLock(t, e) };
          let r = new am({ concurrency: 1 }), n;
          return { async readLock() {
            if (n != null)
              return await zD(n, e);
            n = new am({ concurrency: e.concurrency, autoStart: false });
            let i2 = n, o = zD(n, e);
            return r.add(async () => (i2.start(), await i2.onIdle().then(() => {
              n === i2 && (n = null);
            }))), await o;
          }, async writeLock() {
            return n = null, await zD(r, e);
          } };
        }, Eke = { name: "lock", concurrency: 1 / 0, timeout: 846e5, global: globalThis, singleProcess: false };
        function HD(t) {
          let e = Object.assign({}, Eke, t);
          return bf == null && (bf = yue(e), bf.isWorker !== true && (bf.addEventListener("requestReadLock", (r) => {
            Ud[r.data.name] != null && Ud[r.data.name].readLock().then(async (n) => await r.data.handler().finally(() => n()));
          }), bf.addEventListener("requestWriteLock", async (r) => {
            Ud[r.data.name] != null && Ud[r.data.name].writeLock().then(async (n) => await r.data.handler().finally(() => n()));
          }))), Ud[e.name] == null && (Ud[e.name] = wke(e.name, e)), Ud[e.name];
        }
        yr();
        var gue = C("libp2p:peer-store:store"), wue = "/peers/", G_ = class {
          constructor() {
            this.components = new He(), this.lock = HD({ name: "peer-store", singleProcess: true });
          }
          init(e) {
            this.components = e;
          }
          _peerIdToDatastoreKey(e) {
            if (e.type == null)
              throw gue.error("peerId must be an instance of peer-id to store data"), (0, $D.default)(new Error("peerId must be an instance of peer-id"), wt.ERR_INVALID_PARAMETERS);
            let r = e.toCID().toString();
            return new ae(`${wue}${r}`);
          }
          async has(e) {
            return await this.components.getDatastore().has(this._peerIdToDatastoreKey(e));
          }
          async delete(e) {
            await this.components.getDatastore().delete(this._peerIdToDatastoreKey(e));
          }
          async load(e) {
            let r = await this.components.getDatastore().get(this._peerIdToDatastoreKey(e)), n = I3.decode(r), i2 = /* @__PURE__ */ new Map();
            for (let o of n.metadata)
              i2.set(o.key, o.value);
            return { ...n, id: e, addresses: n.addresses.map(({ multiaddr: o, isCertified: s }) => ({ multiaddr: new j(o), isCertified: s ?? false })), metadata: i2, pubKey: n.pubKey ?? void 0, peerRecordEnvelope: n.peerRecordEnvelope ?? void 0 };
          }
          async save(e) {
            if (e.pubKey != null && e.id.publicKey != null && !Ce(e.pubKey, e.id.publicKey))
              throw gue.error("peer publicKey bytes do not match peer id publicKey bytes"), (0, $D.default)(new Error("publicKey bytes do not match peer id publicKey bytes"), wt.ERR_INVALID_PARAMETERS);
            let r = /* @__PURE__ */ new Set(), n = e.addresses.filter((s) => r.has(s.multiaddr.toString()) ? false : (r.add(s.multiaddr.toString()), true)).sort((s, a) => s.multiaddr.toString().localeCompare(a.multiaddr.toString())).map(({ multiaddr: s, isCertified: a }) => ({ multiaddr: s.bytes, isCertified: a })), i2 = [];
            [...e.metadata.keys()].sort().forEach((s) => {
              let a = e.metadata.get(s);
              a != null && i2.push({ key: s, value: a });
            });
            let o = I3.encode({ addresses: n, protocols: e.protocols.sort(), pubKey: e.pubKey, metadata: i2, peerRecordEnvelope: e.peerRecordEnvelope });
            return await this.components.getDatastore().put(this._peerIdToDatastoreKey(e.id), o), await this.load(e.id);
          }
          async patch(e, r) {
            let n = await this.load(e);
            return await this._patch(e, r, n);
          }
          async patchOrCreate(e, r) {
            let n;
            try {
              n = await this.load(e);
            } catch (i2) {
              if (i2.code !== wt.ERR_NOT_FOUND)
                throw i2;
              n = { id: e, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
            }
            return await this._patch(e, r, n);
          }
          async _patch(e, r, n) {
            return await this.save({ ...n, ...r, id: e });
          }
          async merge(e, r) {
            let n = await this.load(e);
            return await this._merge(e, r, n);
          }
          async mergeOrCreate(e, r) {
            let n;
            try {
              n = await this.load(e);
            } catch (i2) {
              if (i2.code !== wt.ERR_NOT_FOUND)
                throw i2;
              n = { id: e, addresses: [], protocols: [], metadata: /* @__PURE__ */ new Map() };
            }
            return await this._merge(e, r, n);
          }
          async _merge(e, r, n) {
            let i2 = /* @__PURE__ */ new Map();
            return n.addresses.forEach((o) => {
              i2.set(o.multiaddr.toString(), o.isCertified);
            }), (r.addresses ?? []).forEach((o) => {
              let s = o.multiaddr.toString(), u = Boolean(i2.get(s)) || o.isCertified;
              i2.set(s, u);
            }), await this.save({ id: e, addresses: Array.from(i2.entries()).map(([o, s]) => ({ multiaddr: new j(o), isCertified: s })), protocols: Array.from(/* @__PURE__ */ new Set([...n.protocols ?? [], ...r.protocols ?? []])), metadata: new Map([...n.metadata?.entries() ?? [], ...r.metadata?.entries() ?? []]), pubKey: r.pubKey ?? n?.pubKey, peerRecordEnvelope: r.peerRecordEnvelope ?? n?.peerRecordEnvelope });
          }
          async *all() {
            for await (let e of this.components.getDatastore().queryKeys({ prefix: wue })) {
              let r = e.toString().split("/")[2], n = xt.decode(r);
              yield this.load(Ir(n));
            }
          }
        };
        var ys = C("libp2p:peer-store"), W_ = class extends Ue {
          constructor(e = {}) {
            super(), this.components = new He(), this.store = new G_(), this.addressBook = new k_(this.dispatchEvent.bind(this), this.store, e.addressFilter), this.keyBook = new N_(this.dispatchEvent.bind(this), this.store), this.metadataBook = new L_(this.dispatchEvent.bind(this), this.store), this.protoBook = new U_(this.dispatchEvent.bind(this), this.store);
          }
          init(e) {
            this.components = e, this.store.init(e);
          }
          async forEach(e) {
            ys.trace("getPeers await read lock");
            let r = await this.store.lock.readLock();
            ys.trace("getPeers got read lock");
            try {
              for await (let n of this.store.all())
                n.id.equals(this.components.getPeerId()) || e(n);
            } finally {
              ys.trace("getPeers release read lock"), r();
            }
          }
          async all() {
            let e = [];
            return await this.forEach((r) => {
              e.push(r);
            }), e;
          }
          async delete(e) {
            ys.trace("delete await write lock");
            let r = await this.store.lock.writeLock();
            ys.trace("delete got write lock");
            try {
              await this.store.delete(e);
            } finally {
              ys.trace("delete release write lock"), r();
            }
          }
          async get(e) {
            ys.trace("get await read lock");
            let r = await this.store.lock.readLock();
            ys.trace("get got read lock");
            try {
              return await this.store.load(e);
            } finally {
              ys.trace("get release read lock"), r();
            }
          }
          async has(e) {
            ys.trace("has await read lock");
            let r = await this.store.lock.readLock();
            ys.trace("has got read lock");
            try {
              return await this.store.has(e);
            } finally {
              ys.trace("has release read lock"), r();
            }
          }
        };
        c();
        var GD = w(Ci(), 1), Eue = w(K(), 1), j_ = class {
          constructor(e) {
            this.dht = e;
          }
          async provide(e) {
            await (0, GD.default)(this.dht.provide(e));
          }
          async *findProviders(e, r = {}) {
            for await (let n of this.dht.findProviders(e, r))
              n.name === "PROVIDER" && (yield* n.providers);
          }
          async put(e, r, n) {
            await (0, GD.default)(this.dht.put(e, r, n));
          }
          async get(e, r) {
            for await (let n of this.dht.get(e, r))
              if (n.name === "VALUE")
                return n.value;
            throw (0, Eue.default)(new Error("Not found"), "ERR_NOT_FOUND");
          }
        };
        c();
        var _ue = w($o(), 1), bue = C("libp2p:dialer:auto-dialer"), Y_ = class {
          constructor(e, r) {
            this.components = e, this.enabled = r.enabled, this.minConnections = r.minConnections, this.dialTimeout = r.dialTimeout;
          }
          handle(e) {
            let { detail: r } = e;
            if (!this.enabled)
              return;
            if (this.components.getConnectionManager().getConnections(r.id).length === 0) {
              let i2 = this.minConnections ?? 0, o = this.components.getConnectionManager().getConnections();
              if (i2 > o.length) {
                bue("auto-dialing discovered peer %p with timeout %d", r.id, this.dialTimeout);
                let s = new _ue.TimeoutController(this.dialTimeout);
                this.components.getConnectionManager().openConnection(r.id, { signal: s.signal }).catch((a) => {
                  bue.error("could not connect to discovered peer %p with %o", r.id, a);
                }).finally(() => {
                  s.clear();
                });
              }
            }
          }
        };
        c();
        c();
        c();
        c();
        var jD = w(Mi(), 1), YD = w(xue(), 1);
        c();
        c();
        var Rue = globalThis.fetch, Aue = globalThis.Headers, ORt = globalThis.Request, LRt = globalThis.Response;
        function Q_(t, e, r) {
          return `${t}?name=${e}&type=${r}`;
        }
        async function Tue(t) {
          return await (await Rue(t, { headers: new Aue({ accept: "application/dns-json" }) })).json();
        }
        function Fd(t, e) {
          return `${e}_${t}`;
        }
        var WD = Object.assign((0, jD.default)("dns-over-http-resolver"), { error: (0, jD.default)("dns-over-http-resolver:error") }), QD = class {
          constructor(e = {}) {
            this._cache = new YD.default({ max: e?.maxCache ?? 100 }), this._TXTcache = new YD.default({ max: e?.maxCache ?? 100 }), this._servers = ["https://cloudflare-dns.com/dns-query", "https://dns.google/resolve"], this._request = e.request ?? Tue;
          }
          getServers() {
            return this._servers;
          }
          _getShuffledServers() {
            let e = [...this._servers];
            for (let r = e.length - 1; r > 0; r--) {
              let n = Math.floor(Math.random() * r), i2 = e[r];
              e[r] = e[n], e[n] = i2;
            }
            return e;
          }
          setServers(e) {
            this._servers = e;
          }
          async resolve(e, r = "A") {
            switch (r) {
              case "A":
                return await this.resolve4(e);
              case "AAAA":
                return await this.resolve6(e);
              case "TXT":
                return await this.resolveTxt(e);
              default:
                throw new Error(`${r} is not supported`);
            }
          }
          async resolve4(e) {
            let r = "A", n = this._cache.get(Fd(e, r));
            if (n != null)
              return n;
            for (let i2 of this._getShuffledServers())
              try {
                let o = await this._request(Q_(i2, e, r)), s = o.Answer.map((u) => u.data), a = Math.min(...o.Answer.map((u) => u.TTL));
                return this._cache.set(Fd(e, r), s, { ttl: a }), s;
              } catch {
                WD.error(`${i2} could not resolve ${e} record ${r}`);
              }
            throw new Error(`Could not resolve ${e} record ${r}`);
          }
          async resolve6(e) {
            let r = "AAAA", n = this._cache.get(Fd(e, r));
            if (n != null)
              return n;
            for (let i2 of this._getShuffledServers())
              try {
                let o = await this._request(Q_(i2, e, r)), s = o.Answer.map((u) => u.data), a = Math.min(...o.Answer.map((u) => u.TTL));
                return this._cache.set(Fd(e, r), s, { ttl: a }), s;
              } catch {
                WD.error(`${i2} could not resolve ${e} record ${r}`);
              }
            throw new Error(`Could not resolve ${e} record ${r}`);
          }
          async resolveTxt(e) {
            let r = "TXT", n = this._TXTcache.get(Fd(e, r));
            if (n != null)
              return n;
            for (let i2 of this._getShuffledServers())
              try {
                let o = await this._request(Q_(i2, e, r)), s = o.Answer.map((u) => [u.data.replace(/['"]+/g, "")]), a = Math.min(...o.Answer.map((u) => u.TTL));
                return this._TXTcache.set(Fd(e, r), s, { ttl: a }), s;
              } catch {
                WD.error(`${i2} could not resolve ${e} record ${r}`);
              }
            throw new Error(`Could not resolve ${e} record ${r}`);
          }
          clearCache() {
            this._cache.clear(), this._TXTcache.clear();
          }
        }, Iue = QD;
        var Cue = Iue;
        var { code: xke } = Tn("dnsaddr");
        async function Pue(t) {
          let e = new Cue(), r = t.getPeerId(), [, n] = t.stringTuples().find(([s]) => s === xke) ?? [];
          if (n == null)
            throw new Error("No hostname found in multiaddr");
          let o = (await e.resolveTxt(`_dnsaddr.${n}`)).flat().map((s) => s.split("=")[1]);
          return r != null && (o = o.filter((s) => s.includes(r))), o;
        }
        var X_ = w(K(), 1), Tke = { addresses: { listen: [], announce: [], noAnnounce: [], announceFilter: (t) => t }, connectionManager: { maxConnections: 300, minConnections: 50, autoDial: true, autoDialInterval: 1e4, maxParallelDials: 100, maxDialsPerPeer: 4, dialTimeout: 3e4, resolvers: { dnsaddr: Pue }, addressSorter: W1 }, connectionGater: {}, transportManager: { faultTolerance: kd.FATAL_ALL }, metrics: { enabled: false, computeThrottleMaxQueueSize: 1e3, computeThrottleTimeout: 2e3, movingAverageIntervals: [60 * 1e3, 5 * 60 * 1e3, 15 * 60 * 1e3], maxOldPeersRetention: 50 }, peerRouting: { refreshManager: { enabled: true, interval: 6e5, bootDelay: 1e4 } }, nat: { enabled: true, ttl: 7200, keepAlive: true }, relay: { enabled: true, advertise: { bootDelay: 9e5, enabled: false, ttl: 18e5 }, hop: { enabled: false, active: false }, autoRelay: { enabled: false, maxListeners: 2 } }, identify: { protocolPrefix: "ipfs", host: { agentVersion: Nce }, timeout: 3e4 }, ping: { protocolPrefix: "ipfs" }, fetch: { protocolPrefix: "libp2p" } };
        function Due(t) {
          let e = Ze(Tke, t);
          if (e.transports == null || e.transports.length < 1)
            throw (0, X_.default)(new Error(_t.ERR_TRANSPORTS_REQUIRED), q.ERR_TRANSPORTS_REQUIRED);
          if (e.connectionEncryption == null || e.connectionEncryption.length === 0)
            throw (0, X_.default)(new Error(_t.CONN_ENCRYPTION_REQUIRED), q.CONN_ENCRYPTION_REQUIRED);
          if (e.connectionProtector === null && globalThis.process?.env?.LIBP2P_FORCE_PNET != null)
            throw (0, X_.default)(new Error(_t.ERR_PROTECTOR_REQUIRED), q.ERR_PROTECTOR_REQUIRED);
          return e;
        }
        c();
        c();
        c();
        var Ei;
        (function(t) {
          t.RSA = "RSA", t.Ed25519 = "Ed25519", t.Secp256k1 = "Secp256k1";
        })(Ei || (Ei = {}));
        var XD;
        (function(t) {
          t[t.RSA = 0] = "RSA", t[t.Ed25519 = 1] = "Ed25519", t[t.Secp256k1 = 2] = "Secp256k1";
        })(XD || (XD = {}));
        (function(t) {
          t.codec = () => xi(XD);
        })(Ei || (Ei = {}));
        var gu;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "Type", codec: Ei.codec() }, 2: { name: "Data", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(gu || (gu = {}));
        var wu;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "Type", codec: Ei.codec() }, 2: { name: "Data", codec: ye } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(wu || (wu = {}));
        var cTt = w(Aa(), 1), uTt = w(i6(), 1), Xke = w(st(), 1), ale = w(K(), 1);
        Re();
        c();
        var Cke = w(K(), 1);
        ur();
        Re();
        c();
        c();
        var Zi = { get(t = globalThis) {
          let e = t.crypto;
          if (e == null || e.subtle == null)
            throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
          return e;
        } };
        c();
        c();
        c();
        var Pke = w(K(), 1);
        c();
        var aAt = w(gr(), 1), cAt = w(L2(), 1), kue = w(st(), 1);
        Re();
        me();
        ur();
        function oa(t, e) {
          let r = Uint8Array.from(t.abs().toByteArray());
          if (r = r[0] === 0 ? r.slice(1) : r, e != null) {
            if (r.length > e)
              throw new Error("byte array longer than desired length");
            r = Ae([new Uint8Array(e - r.length), r]);
          }
          return M(r, "base64url");
        }
        function Do(t) {
          let e = Nue(t);
          return new kue.default.jsbn.BigInteger(M(e, "base16"), 16);
        }
        function Nue(t, e) {
          let r = U(t, "base64urlpad");
          if (e != null) {
            if (r.length > e)
              throw new Error("byte array longer than desired length");
            r = Ae([new Uint8Array(e - r.length), r]);
          }
          return r;
        }
        me();
        ur();
        yr();
        var Dke = { "P-256": 256, "P-384": 384, "P-521": 521 }, kke = Object.keys(Dke), wAt = kke.join(" / ");
        c();
        ma();
        c();
        ur();
        Re();
        function ZD(t) {
          let e = t?.algorithm ?? "AES-GCM", r = t?.keyLength ?? 16, n = t?.nonceLength ?? 12, i2 = t?.digest ?? "SHA-256", o = t?.saltLength ?? 16, s = t?.iterations ?? 32767, a = Zi.get();
          r *= 8;
          async function u(h, p) {
            let d = a.getRandomValues(new Uint8Array(o)), m = a.getRandomValues(new Uint8Array(n)), y = { name: e, iv: m };
            typeof p == "string" && (p = U(p));
            let g = { name: "PBKDF2", salt: d, iterations: s, hash: { name: i2 } }, E = await a.subtle.importKey("raw", p, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]), b = await a.subtle.deriveKey(g, E, { name: e, length: r }, true, ["encrypt"]), v = await a.subtle.encrypt(y, b, h);
            return Ae([d, y.iv, new Uint8Array(v)]);
          }
          async function l(h, p) {
            let d = h.slice(0, o), m = h.slice(o, o + n), y = h.slice(o + n), g = { name: e, iv: m };
            typeof p == "string" && (p = U(p));
            let E = { name: "PBKDF2", salt: d, iterations: s, hash: { name: i2 } }, b = await a.subtle.importKey("raw", p, { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]), v = await a.subtle.deriveKey(E, b, { name: e, length: r }, true, ["decrypt"]), S = await a.subtle.decrypt(g, v, y);
            return new Uint8Array(S);
          }
          return { encrypt: u, decrypt: l };
        }
        var nk = {};
        ct(nk, { RsaPrivateKey: () => lm, RsaPublicKey: () => B3, fromJwk: () => Vke, generateKeyPair: () => qke, unmarshalRsaPrivateKey: () => Fke, unmarshalRsaPublicKey: () => Kke });
        c();
        vr();
        var rk = w(K(), 1);
        yr();
        me();
        var WAt = w(Bx(), 1), L3 = w(st(), 1);
        c();
        c();
        var Lue = w(uh(), 1), Bue = w(K(), 1);
        function J_(t) {
          if (isNaN(t) || t <= 0)
            throw (0, Bue.default)(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
          return (0, Lue.default)(t);
        }
        me();
        Re();
        var Kd = {};
        ct(Kd, { jwkToPkcs1: () => Oke, jwkToPkix: () => Bke, pkcs1ToJwk: () => Nke, pkixToJwk: () => Lke });
        c();
        var CAt = w(Aa(), 1), PAt = w(sh(), 1), Eu = w(st(), 1);
        Re();
        me();
        var JD = w(K(), 1);
        function Nke(t) {
          let e = Eu.default.asn1.fromDer(M(t, "ascii")), r = Eu.default.pki.privateKeyFromAsn1(e);
          return { kty: "RSA", n: oa(r.n), e: oa(r.e), d: oa(r.d), p: oa(r.p), q: oa(r.q), dp: oa(r.dP), dq: oa(r.dQ), qi: oa(r.qInv), alg: "RS256" };
        }
        function Oke(t) {
          if (t.n == null || t.e == null || t.d == null || t.p == null || t.q == null || t.dp == null || t.dq == null || t.qi == null)
            throw (0, JD.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
          let e = Eu.default.pki.privateKeyToAsn1({ n: Do(t.n), e: Do(t.e), d: Do(t.d), p: Do(t.p), q: Do(t.q), dP: Do(t.dp), dQ: Do(t.dq), qInv: Do(t.qi) });
          return U(Eu.default.asn1.toDer(e).getBytes(), "ascii");
        }
        function Lke(t) {
          let e = Eu.default.asn1.fromDer(M(t, "ascii")), r = Eu.default.pki.publicKeyFromAsn1(e);
          return { kty: "RSA", n: oa(r.n), e: oa(r.e) };
        }
        function Bke(t) {
          if (t.n == null || t.e == null)
            throw (0, JD.default)(new Error("JWK was missing components"), "ERR_INVALID_PARAMETERS");
          let e = Eu.default.pki.publicKeyToAsn1({ n: Do(t.n), e: Do(t.e) });
          return U(Eu.default.asn1.toDer(e).getBytes(), "ascii");
        }
        c();
        var OAt = w(sh(), 1), ek = w(st(), 1);
        function Mue(t, e) {
          return e.map((r) => Do(t[r]));
        }
        function Uue(t) {
          return ek.default.pki.setRsaPrivateKey(...Mue(t, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
        }
        function Fue(t) {
          return ek.default.pki.setRsaPublicKey(...Mue(t, ["n", "e"]));
        }
        var Kue = w(K(), 1);
        async function Vue(t) {
          let e = await Zi.get().subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: t, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, true, ["sign", "verify"]), r = await Hue(e);
          return { privateKey: r[0], publicKey: r[1] };
        }
        async function tk(t) {
          let r = [await Zi.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["sign"]), await Mke(t)], n = await Hue({ privateKey: r[0], publicKey: r[1] });
          return { privateKey: n[0], publicKey: n[1] };
        }
        async function que(t, e) {
          let r = await Zi.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["sign"]), n = await Zi.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, r, Uint8Array.from(e));
          return new Uint8Array(n, 0, n.byteLength);
        }
        async function zue(t, e, r) {
          let n = await Zi.get().subtle.importKey("jwk", t, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, false, ["verify"]);
          return await Zi.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, n, e, r);
        }
        async function Hue(t) {
          if (t.privateKey == null || t.publicKey == null)
            throw (0, Kue.default)(new Error("Private and public key are required"), "ERR_INVALID_PARAMETERS");
          return await Promise.all([Zi.get().subtle.exportKey("jwk", t.privateKey), Zi.get().subtle.exportKey("jwk", t.publicKey)]);
        }
        async function Mke(t) {
          return await Zi.get().subtle.importKey("jwk", { kty: t.kty, n: t.n, e: t.e }, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, true, ["verify"]);
        }
        function $ue(t, e, r, n) {
          let i2 = e ? Fue(t) : Uue(t), o = M(Uint8Array.from(r), "ascii"), s = n(o, i2);
          return U(s, "ascii");
        }
        function Gue(t, e) {
          return $ue(t, true, e, (r, n) => n.encrypt(r));
        }
        function Wue(t, e) {
          return $ue(t, false, e, (r, n) => n.decrypt(r));
        }
        c();
        ma();
        async function um(t, e) {
          let n = await ZD().encrypt(t, e);
          return to.encode(n);
        }
        var B3 = class {
          constructor(e) {
            this._key = e;
          }
          async verify(e, r) {
            return await zue(this._key, r, e);
          }
          marshal() {
            return Kd.jwkToPkix(this._key);
          }
          get bytes() {
            return gu.encode({ Type: Ei.RSA, Data: this.marshal() });
          }
          encrypt(e) {
            return Gue(this._key, e);
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, lm = class {
          constructor(e, r) {
            this._key = e, this._publicKey = r;
          }
          genSecret() {
            return J_(16);
          }
          async sign(e) {
            return await que(this._key, e);
          }
          get public() {
            if (this._publicKey == null)
              throw (0, rk.default)(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
            return new B3(this._publicKey);
          }
          decrypt(e) {
            return Wue(this._key, e);
          }
          marshal() {
            return Kd.jwkToPkcs1(this._key);
          }
          get bytes() {
            return wu.encode({ Type: Ei.RSA, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await this.public.hash();
            return M(e, "base58btc");
          }
          async export(e, r = "pkcs-8") {
            if (r === "pkcs-8") {
              let n = new L3.default.util.ByteBuffer(this.marshal()), i2 = L3.default.asn1.fromDer(n), o = L3.default.pki.privateKeyFromAsn1(i2), s = { algorithm: "aes256", count: 1e4, saltSize: 128 / 8, prfAlgorithm: "sha512" };
              return L3.default.pki.encryptRsaPrivateKey(o, e, s);
            } else {
              if (r === "libp2p-key")
                return await um(this.bytes, e);
              throw (0, rk.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
            }
          }
        };
        async function Fke(t) {
          let e = Kd.pkcs1ToJwk(t), r = await tk(e);
          return new lm(r.privateKey, r.publicKey);
        }
        function Kke(t) {
          let e = Kd.pkixToJwk(t);
          return new B3(e);
        }
        async function Vke(t) {
          let e = await tk(t);
          return new lm(e.privateKey, e.publicKey);
        }
        async function qke(t) {
          let e = await Vue(t);
          return new lm(e.privateKey, e.publicKey);
        }
        var ok = {};
        ct(ok, { Ed25519PrivateKey: () => Vd, Ed25519PublicKey: () => M3, generateKeyPair: () => Gke, generateKeyPairFromSeed: () => Jue, unmarshalEd25519PrivateKey: () => Hke, unmarshalEd25519PublicKey: () => $ke });
        c();
        var ik = w(K(), 1);
        yr();
        vr();
        Hr();
        va();
        c();
        var fm = 32, bu = 64, ev = 32;
        async function jue() {
          let t = hh.randomPrivateKey(), e = await t0(t);
          return { privateKey: Zue(t, e), publicKey: e };
        }
        async function Yue(t) {
          if (t.length !== ev)
            throw new TypeError('"seed" must be 32 bytes in length.');
          if (!(t instanceof Uint8Array))
            throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
          let e = t, r = await t0(e);
          return { privateKey: Zue(e, r), publicKey: r };
        }
        async function Que(t, e) {
          let r = t.slice(0, ev);
          return await l6(e, r);
        }
        async function Xue(t, e, r) {
          return await f6(e, r, t);
        }
        function Zue(t, e) {
          let r = new Uint8Array(bu);
          for (let n = 0; n < ev; n++)
            r[n] = t[n], r[ev + n] = e[n];
          return r;
        }
        var M3 = class {
          constructor(e) {
            this._key = hm(e, fm);
          }
          async verify(e, r) {
            return await Xue(this._key, r, e);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return gu.encode({ Type: Ei.Ed25519, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, Vd = class {
          constructor(e, r) {
            this._key = hm(e, bu), this._publicKey = hm(r, fm);
          }
          async sign(e) {
            return await Que(this._key, e);
          }
          get public() {
            return new M3(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return wu.encode({ Type: Ei.Ed25519, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await $r.digest(this.public.bytes);
            return Ne.encode(e.bytes).substring(1);
          }
          async export(e, r = "libp2p-key") {
            if (r === "libp2p-key")
              return await um(this.bytes, e);
            throw (0, ik.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        };
        function Hke(t) {
          if (t.length > bu) {
            t = hm(t, bu + fm);
            let n = t.slice(0, bu), i2 = t.slice(bu, t.length);
            return new Vd(n, i2);
          }
          t = hm(t, bu);
          let e = t.slice(0, bu), r = t.slice(fm);
          return new Vd(e, r);
        }
        function $ke(t) {
          return t = hm(t, fm), new M3(t);
        }
        async function Gke() {
          let { privateKey: t, publicKey: e } = await jue();
          return new Vd(t, e);
        }
        async function Jue(t) {
          let { privateKey: e, publicKey: r } = await Yue(t);
          return new Vd(e, r);
        }
        function hm(t, e) {
          if (t = Uint8Array.from(t ?? []), t.length !== e)
            throw (0, ik.default)(new Error(`Key must be a Uint8Array of length ${e}, got ${t.length}`), "ERR_INVALID_KEY_TYPE");
          return t;
        }
        var ak = {};
        ct(ak, { Secp256k1PrivateKey: () => F3, Secp256k1PublicKey: () => U3, generateKeyPair: () => Qke, unmarshalSecp256k1PrivateKey: () => jke, unmarshalSecp256k1PublicKey: () => Yke });
        c();
        vr();
        var sle = w(K(), 1);
        yr();
        me();
        c();
        var dm = w(K(), 1);
        vr();
        function ele() {
          return Ii.randomPrivateKey();
        }
        async function tle(t, e) {
          let { digest: r } = await xe.digest(e);
          try {
            return await w6(r, t);
          } catch (n) {
            throw (0, dm.default)(n, "ERR_INVALID_INPUT");
          }
        }
        async function rle(t, e, r) {
          try {
            let { digest: n } = await xe.digest(r);
            return E6(e, n, t);
          } catch (n) {
            throw (0, dm.default)(n, "ERR_INVALID_INPUT");
          }
        }
        function nle(t) {
          return Tt.fromHex(t).toRawBytes(true);
        }
        function ile(t) {
          try {
            a0(t, true);
          } catch (e) {
            throw (0, dm.default)(e, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        function sk(t) {
          try {
            Tt.fromHex(t);
          } catch (e) {
            throw (0, dm.default)(e, "ERR_INVALID_PUBLIC_KEY");
          }
        }
        function ole(t) {
          try {
            return a0(t, true);
          } catch (e) {
            throw (0, dm.default)(e, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        var U3 = class {
          constructor(e) {
            sk(e), this._key = e;
          }
          async verify(e, r) {
            return await rle(this._key, r, e);
          }
          marshal() {
            return nle(this._key);
          }
          get bytes() {
            return gu.encode({ Type: Ei.Secp256k1, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
        }, F3 = class {
          constructor(e, r) {
            this._key = e, this._publicKey = r ?? ole(e), ile(this._key), sk(this._publicKey);
          }
          async sign(e) {
            return await tle(this._key, e);
          }
          get public() {
            return new U3(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return wu.encode({ Type: Ei.Secp256k1, Data: this.marshal() });
          }
          equals(e) {
            return Ce(this.bytes, e.bytes);
          }
          async hash() {
            let { bytes: e } = await xe.digest(this.bytes);
            return e;
          }
          async id() {
            let e = await this.public.hash();
            return M(e, "base58btc");
          }
          async export(e, r = "libp2p-key") {
            if (r === "libp2p-key")
              return await um(this.bytes, e);
            throw (0, sle.default)(new Error(`export format '${r}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        };
        function jke(t) {
          return new F3(t);
        }
        function Yke(t) {
          return new U3(t);
        }
        async function Qke() {
          let t = await ele();
          return new F3(t);
        }
        var cle = { rsa: nk, ed25519: ok, secp256k1: ak };
        function Zke(t) {
          let e = Object.keys(cle).join(" / ");
          return (0, ale.default)(new Error(`invalid or unsupported key type ${t}. Must be ${e}`), "ERR_UNSUPPORTED_KEY_TYPE");
        }
        function ck(t) {
          if (t = t.toLowerCase(), t === "rsa" || t === "ed25519" || t === "secp256k1")
            return cle[t];
          throw Zke(t);
        }
        async function uk(t, e) {
          return await ck(t).generateKeyPair(e ?? 2048);
        }
        function ule(t, e) {
          return e = (e ?? "rsa").toLowerCase(), ck(e), t.bytes;
        }
        function lle(t, e) {
          return e = (e ?? "rsa").toLowerCase(), ck(e), t.bytes;
        }
        Re();
        c();
        var lk;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "id", codec: ye }, 2: { name: "pubKey", codec: ye, optional: true }, 3: { name: "privKey", codec: ye, optional: true } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(lk || (lk = {}));
        var tv = async () => {
          let t = await uk("Ed25519"), e = await hle(t);
          if (e.type === "Ed25519")
            return e;
          throw new Error(`Generated unexpected PeerId type "${e.type}"`);
        };
        var fle = async (t) => {
          let e = await uk("RSA", t?.bits ?? 2048), r = await hle(e);
          if (r.type === "RSA")
            return r;
          throw new Error(`Generated unexpected PeerId type "${r.type}"`);
        };
        async function hle(t) {
          return await sn(ule(t.public), lle(t));
        }
        ur();
        Re();
        var q3 = w(K(), 1);
        c();
        var gs = w(K(), 1);
        var rv = class extends Ue {
          get [rc]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/dummy-dht";
          }
          get wan() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          get lan() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          get() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          findProviders() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          findPeer() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          getClosestPeers() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          provide() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          put() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          async getMode() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          async setMode() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
          async refreshRoutingTable() {
            throw (0, gs.default)(new Error(_t.DHT_DISABLED), q.DHT_DISABLED);
          }
        };
        c();
        var _u = w(K(), 1);
        var nv = class extends Ue {
          isStarted() {
            return false;
          }
          start() {
          }
          stop() {
          }
          get globalSignaturePolicy() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          get multicodecs() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          getPeers() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          getTopics() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          subscribe() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          unsubscribe() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          getSubscribers() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
          async publish() {
            throw (0, _u.default)(new Error(_t.PUBSUB_DISABLED), q.ERR_PUBSUB_DISABLED);
          }
        };
        c();
        c();
        c();
        function vu(t, e) {
          let r = { [Symbol.iterator]: () => r, next: () => {
            let n = t.next(), i2 = n.value;
            return n.done === true || i2 == null ? { done: true, value: void 0 } : { done: false, value: e(i2) };
          } };
          return r;
        }
        var K3 = class {
          constructor(e) {
            if (this.map = /* @__PURE__ */ new Map(), e != null)
              for (let [r, n] of e.entries())
                this.map.set(r.toString(), n);
          }
          [Symbol.iterator]() {
            return this.entries();
          }
          clear() {
            this.map.clear();
          }
          delete(e) {
            this.map.delete(e.toString());
          }
          entries() {
            return vu(this.map.entries(), (e) => [ue(e[0]), e[1]]);
          }
          forEach(e) {
            this.map.forEach((r, n) => {
              e(r, ue(n), this);
            });
          }
          get(e) {
            return this.map.get(e.toString());
          }
          has(e) {
            return this.map.has(e.toString());
          }
          set(e, r) {
            this.map.set(e.toString(), r);
          }
          keys() {
            return vu(this.map.keys(), (e) => ue(e));
          }
          values() {
            return this.map.values();
          }
          get size() {
            return this.map.size;
          }
        };
        c();
        var V3 = class {
          constructor(e) {
            if (this.set = /* @__PURE__ */ new Set(), e != null)
              for (let r of e)
                this.set.add(r.toString());
          }
          get size() {
            return this.set.size;
          }
          [Symbol.iterator]() {
            return this.values();
          }
          add(e) {
            this.set.add(e.toString());
          }
          clear() {
            this.set.clear();
          }
          delete(e) {
            this.set.delete(e.toString());
          }
          entries() {
            return vu(this.set.entries(), (e) => {
              let r = ue(e[0]);
              return [r, r];
            });
          }
          forEach(e) {
            this.set.forEach((r) => {
              let n = ue(r);
              e(n, n, this);
            });
          }
          has(e) {
            return this.set.has(e.toString());
          }
          values() {
            return vu(this.set.values(), (e) => ue(e));
          }
        };
        c();
        var pm = class {
          constructor(e) {
            if (this.list = [], e != null)
              for (let r of e)
                this.list.push(r.toString());
          }
          [Symbol.iterator]() {
            return vu(this.list.entries(), (e) => ue(e[1]));
          }
          concat(e) {
            let r = new pm(this);
            for (let n of e)
              r.push(n);
            return r;
          }
          entries() {
            return vu(this.list.entries(), (e) => [e[0], ue(e[1])]);
          }
          every(e) {
            return this.list.every((r, n) => e(ue(r), n, this));
          }
          filter(e) {
            let r = new pm();
            return this.list.forEach((n, i2) => {
              let o = ue(n);
              e(o, i2, this) && r.push(o);
            }), r;
          }
          find(e) {
            let r = this.list.find((n, i2) => e(ue(n), i2, this));
            if (r != null)
              return ue(r);
          }
          findIndex(e) {
            return this.list.findIndex((r, n) => e(ue(r), n, this));
          }
          forEach(e) {
            this.list.forEach((r, n) => {
              e(ue(r), n, this);
            });
          }
          includes(e) {
            return this.list.includes(e.toString());
          }
          indexOf(e) {
            return this.list.indexOf(e.toString());
          }
          pop() {
            let e = this.list.pop();
            if (e != null)
              return ue(e);
          }
          push(...e) {
            for (let r of e)
              this.list.push(r.toString());
          }
          shift() {
            let e = this.list.shift();
            if (e != null)
              return ue(e);
          }
          unshift(...e) {
            let r = this.list.length;
            for (let n = e.length - 1; n > -1; n--)
              r = this.list.unshift(e[n].toString());
            return r;
          }
          get length() {
            return this.list.length;
          }
        };
        var Su = C("libp2p"), fk = class extends Ue {
          constructor(e) {
            super(), this.initializables = [], this.started = false, this.peerId = e.peerId, this.components = new He({ peerId: e.peerId, datastore: e.datastore ?? new ny(), connectionGater: { denyDialPeer: async () => await Promise.resolve(false), denyDialMultiaddr: async () => await Promise.resolve(false), denyInboundConnection: async () => await Promise.resolve(false), denyOutboundConnection: async () => await Promise.resolve(false), denyInboundEncryptedConnection: async () => await Promise.resolve(false), denyOutboundEncryptedConnection: async () => await Promise.resolve(false), denyInboundUpgradedConnection: async () => await Promise.resolve(false), denyOutboundUpgradedConnection: async () => await Promise.resolve(false), filterMultiaddrForPeer: async () => await Promise.resolve(true), ...e.connectionGater } }), this.components.setPeerStore(new W_({ addressFilter: this.components.getConnectionGater().filterMultiaddrForPeer, ...e.peerStore })), this.services = [this.components], e.metrics.enabled && (this.metrics = this.components.setMetrics(new m_(e.metrics))), this.peerStore = this.components.getPeerStore(), this.peerStore.addEventListener("peer", (s) => {
              let { detail: a } = s;
              this.dispatchEvent(new ee("peer:discovery", { detail: a }));
            }), e.connectionProtector != null && this.components.setConnectionProtector(e.connectionProtector), this.components.setUpgrader(new E_(this.components, { connectionEncryption: (e.connectionEncryption ?? []).map((s) => this.configureComponent(s)), muxers: (e.streamMuxers ?? []).map((s) => this.configureComponent(s)) })), this.connectionManager = this.components.setConnectionManager(new t_(e.connectionManager)), this.registrar = this.components.setRegistrar(new b_(this.components)), this.components.setTransportManager(new y_(this.components, e.transportManager)), this.components.setAddressManager(new $b(this.components, e.addresses)), this.configureComponent(new I_(this.components)), this.configureComponent(new r_(this.components, { enabled: e.connectionManager.autoDial, minConnections: e.connectionManager.minConnections, autoDialInterval: e.connectionManager.autoDialInterval }));
            let r = _3.generateOptions();
            this.keychain = this.configureComponent(new _3(this.components, { ...r, ...e.keychain })), this.services.push(new T_(this.components, e.nat)), e.transports.forEach((s) => {
              this.components.getTransportManager().add(this.configureComponent(s));
            }), e.streamMuxers != null && e.streamMuxers.length > 0 && (this.identifyService = new im(this.components, { ...e.identify }), this.configureComponent(this.identifyService)), e.dht != null ? this.dht = this.components.setDHT(e.dht) : this.dht = new rv(), e.pubsub != null ? this.pubsub = this.components.setPubSub(e.pubsub) : this.pubsub = new nv();
            let n = (e.peerRouters ?? []).map((s) => this.configureComponent(s));
            e.dht != null && (n.push(this.configureComponent(new C_(this.dht))), this.dht.addEventListener("peer", (s) => {
              this.onDiscoveryPeer(s);
            })), this.peerRouting = this.components.setPeerRouting(this.configureComponent(new qb(this.components, { ...e.peerRouting, routers: n })));
            let i2 = (e.contentRouters ?? []).map((s) => this.configureComponent(s));
            e.dht != null && i2.push(this.configureComponent(new j_(this.dht))), this.contentRouting = this.components.setContentRouting(this.configureComponent(new Hb(this.components, { routers: i2 }))), e.relay.enabled && (this.components.getTransportManager().add(this.configureComponent(new i_())), this.configureComponent(new c_(this.components, { addressSorter: e.connectionManager.addressSorter, ...e.relay }))), this.fetchService = this.configureComponent(new x_(this.components, { ...e.fetch })), this.pingService = this.configureComponent(new R_(this.components, { ...e.ping }));
            let o = this.configureComponent(new Y_(this.components, { enabled: e.connectionManager.autoDial !== false, minConnections: e.connectionManager.minConnections, dialTimeout: e.connectionManager.dialTimeout ?? 3e4 }));
            this.addEventListener("peer:discovery", (s) => {
              !this.isStarted() || o.handle(s);
            });
            for (let s of e.peerDiscovery ?? [])
              this.configureComponent(s), s.addEventListener("peer", (a) => {
                this.onDiscoveryPeer(a);
              });
          }
          configureComponent(e) {
            return iu(e) && this.services.push(e), gi(e) && this.initializables.push(e), e;
          }
          async start() {
            if (!this.started) {
              this.started = true, Su("libp2p is starting");
              try {
                this.initializables.forEach((e) => {
                  e.init(this.components);
                }), await Promise.all(this.services.map(async (e) => {
                  e.beforeStart != null && await e.beforeStart();
                })), await Promise.all(this.services.map((e) => e.start())), await Promise.all(this.services.map(async (e) => {
                  e.afterStart != null && await e.afterStart();
                })), Su("libp2p has started"), await this.components.getPeerStore().forEach((e) => {
                  this.dispatchEvent(new ee("peer:discovery", { detail: { id: e.id, multiaddrs: e.addresses.map((r) => r.multiaddr), protocols: e.protocols } }));
                });
              } catch (e) {
                throw Su.error("An error occurred starting libp2p", e), await this.stop(), e;
              }
            }
          }
          async stop() {
            !this.started || (Su("libp2p is stopping"), this.started = false, await Promise.all(this.services.map(async (e) => {
              e.beforeStop != null && await e.beforeStop();
            })), await Promise.all(this.services.map((e) => e.stop())), await Promise.all(this.services.map(async (e) => {
              e.afterStop != null && await e.afterStop();
            })), Su("libp2p has stopped"));
          }
          async loadKeychain() {
            if (this.keychain != null)
              try {
                await this.keychain.findKeyByName("self");
              } catch {
                await this.keychain.importPeer("self", this.peerId);
              }
          }
          isStarted() {
            return this.started;
          }
          getConnections(e) {
            return this.components.getConnectionManager().getConnections(e);
          }
          getPeers() {
            let e = new V3();
            for (let r of this.components.getConnectionManager().getConnections())
              e.add(r.remotePeer);
            return Array.from(e);
          }
          async dial(e, r = {}) {
            let { id: n, multiaddrs: i2 } = Td(e);
            return await this.components.getPeerStore().addressBook.add(n, i2), await this.components.getConnectionManager().openConnection(n, r);
          }
          async dialProtocol(e, r, n = {}) {
            if (r == null)
              throw (0, q3.default)(new Error("no protocols were provided to open a stream"), q.ERR_INVALID_PROTOCOLS_FOR_STREAM);
            if (r = Array.isArray(r) ? r : [r], r.length === 0)
              throw (0, q3.default)(new Error("no protocols were provided to open a stream"), q.ERR_INVALID_PROTOCOLS_FOR_STREAM);
            return await (await this.dial(e, n)).newStream(r, n);
          }
          getMultiaddrs() {
            return this.components.getAddressManager().getAddresses();
          }
          async hangUp(e) {
            let { id: r } = Td(e);
            await this.components.getConnectionManager().closeConnections(r);
          }
          async getPublicKey(e, r = {}) {
            if (Su("getPublicKey %p", e), e.publicKey != null)
              return e.publicKey;
            let n = await this.peerStore.get(e);
            if (n.pubKey != null)
              return n.pubKey;
            if (this.dht == null)
              throw (0, q3.default)(new Error("Public key was not in the peer store and the DHT is not enabled"), q.ERR_NO_ROUTERS_AVAILABLE);
            let i2 = Ae([U("/pk/"), e.multihash.digest]);
            for await (let o of this.dht.get(i2, r))
              if (o.name === "VALUE") {
                let s = ho(o.value);
                return await this.peerStore.keyBook.set(e, o.value), s.bytes;
              }
            throw (0, q3.default)(new Error(`Node not responding with its public key: ${e.toString()}`), q.ERR_INVALID_RECORD);
          }
          async fetch(e, r, n = {}) {
            let { id: i2, multiaddrs: o } = Td(e);
            return o != null && await this.components.getPeerStore().addressBook.add(i2, o), await this.fetchService.fetch(i2, r, n);
          }
          async ping(e, r = {}) {
            let { id: n, multiaddrs: i2 } = Td(e);
            return i2.length > 0 && await this.components.getPeerStore().addressBook.add(n, i2), await this.pingService.ping(n, r);
          }
          async handle(e, r) {
            return await this.components.getRegistrar().handle(e, r);
          }
          async unhandle(e) {
            return await this.components.getRegistrar().unhandle(e);
          }
          onDiscoveryPeer(e) {
            let { detail: r } = e;
            if (r.id.toString() === this.peerId.toString()) {
              Su.error(new Error(q.ERR_DISCOVERED_SELF));
              return;
            }
            r.multiaddrs.length > 0 && this.components.getPeerStore().addressBook.add(r.id, r.multiaddrs).catch((n) => Su.error(n)), r.protocols.length > 0 && this.components.getPeerStore().protoBook.set(r.id, r.protocols).catch((n) => Su.error(n)), this.dispatchEvent(new ee("peer:discovery", { detail: r }));
          }
        };
        async function dle(t) {
          return t.peerId == null && (t.peerId = await tv()), new fk(Due(t));
        }
        async function ple(t) {
          return await dle(t);
        }
        c();
        c();
        c();
        var Vle = w(_le(), 1);
        c();
        vr();
        Re();
        me();
        ur();
        var gk = w(Jb(), 1);
        c();
        var vle = "/lan", Sle = "/ipfs", xle = "/kad/1.0.0", Rle = "/dht/record", yk = "/dht/provider";
        var Ale = Number(3e5), Tle = Number(30 * 1e3), Ile = Number(5 * 6e4), Cle = Number(30 * 1e3), Ple = Number(30 * 1e3);
        var oNe = U("/pk/");
        function ym(t) {
          return { ...t, multiaddrs: t.multiaddrs.filter((e) => {
            let [[r, n]] = e.stringTuples();
            return r !== 4 && r !== 6 || n == null ? false : !(0, gk.default)(n);
          }) };
        }
        function gm(t) {
          return { ...t, multiaddrs: t.multiaddrs.filter((e) => {
            let [[r, n]] = e.stringTuples();
            return r !== 4 && r !== 6 || n == null ? false : (0, gk.default)(n);
          }) };
        }
        async function uc(t) {
          return (await xe.digest(t)).digest;
        }
        async function ko(t) {
          return await uc(t.toBytes());
        }
        function xu(t) {
          return new ae(`${Rle}/${M(t, "base32")}`, false);
        }
        function Dle(t) {
          return Ae([oNe, t.toBytes()]);
        }
        function kle(t) {
          return M(t.slice(0, 4)) === "/pk/";
        }
        function Nle(t) {
          return Ir(t.slice(4));
        }
        function wk(t, e) {
          let r = new Date();
          return new Vr(t, e, r).serialize();
        }
        c();
        var Kle = w(Xu(), 1);
        c();
        c();
        function bk(t, e, r) {
          let n = 0, i2 = t.length;
          for (; i2 > 0; ) {
            let o = Math.trunc(i2 / 2), s = n + o;
            r(t[s], e) <= 0 ? (n = ++s, i2 -= o + 1) : i2 = o;
          }
          return n;
        }
        var zd = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Ru, H3 = class {
          constructor() {
            Ru.set(this, []);
          }
          enqueue(e, r) {
            r = { priority: 0, ...r };
            let n = { priority: r.priority, run: e };
            if (this.size && zd(this, Ru, "f")[this.size - 1].priority >= r.priority) {
              zd(this, Ru, "f").push(n);
              return;
            }
            let i2 = bk(zd(this, Ru, "f"), n, (o, s) => s.priority - o.priority);
            zd(this, Ru, "f").splice(i2, 0, n);
          }
          dequeue() {
            let e = zd(this, Ru, "f").shift();
            return e?.run;
          }
          filter(e) {
            return zd(this, Ru, "f").filter((r) => r.priority === e.priority).map((r) => r.run);
          }
          get size() {
            return zd(this, Ru, "f").length;
          }
        };
        Ru = /* @__PURE__ */ new WeakMap();
        var ir = function(t, e, r, n, i2) {
          if (n === "m")
            throw new TypeError("Private method is not writable");
          if (n === "a" && !i2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof e == "function" ? t !== e || !i2 : !e.has(t))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return n === "a" ? i2.call(t, r) : i2 ? i2.value = r : e.set(t, r), r;
        }, Se = function(t, e, r, n) {
          if (r === "a" && !n)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof e == "function" ? t !== e || !n : !e.has(t))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return r === "m" ? n : r === "a" ? n.call(t) : n ? n.value : e.get(t);
        }, Qn, G3, W3, Sf, lv, j3, sv, sa, $3, No, av, Oo, Y3, vf, wm, Em, Hd, cv, Ole, Lle, Fle, Ble, Mle, Ule, uv, _k, vk, fv, hv = () => {
        }, sNe = new hi(), Sk = class extends Error {
        }, Au = class extends Kle.default {
          constructor(e) {
            var r, n, i2, o;
            if (super(), Qn.add(this), G3.set(this, void 0), W3.set(this, void 0), Sf.set(this, 0), lv.set(this, void 0), j3.set(this, void 0), sv.set(this, 0), sa.set(this, void 0), $3.set(this, void 0), No.set(this, void 0), av.set(this, void 0), Oo.set(this, 0), Y3.set(this, void 0), vf.set(this, void 0), wm.set(this, hv), Em.set(this, hv), Hd.set(this, void 0), cv.set(this, void 0), e = { carryoverConcurrencyCount: false, intervalCap: Number.POSITIVE_INFINITY, interval: 0, concurrency: Number.POSITIVE_INFINITY, autoStart: true, queueClass: H3, ...e }, !(typeof e.intervalCap == "number" && e.intervalCap >= 1))
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n = (r = e.intervalCap) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : ""}\` (${typeof e.intervalCap})`);
            if (e.interval === void 0 || !(Number.isFinite(e.interval) && e.interval >= 0))
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i2 = e.interval) === null || i2 === void 0 ? void 0 : i2.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof e.interval})`);
            ir(this, G3, e.carryoverConcurrencyCount, "f"), ir(this, W3, e.intervalCap === Number.POSITIVE_INFINITY || e.interval === 0, "f"), ir(this, lv, e.intervalCap, "f"), ir(this, j3, e.interval, "f"), ir(this, No, new e.queueClass(), "f"), ir(this, av, e.queueClass, "f"), this.concurrency = e.concurrency, ir(this, Hd, e.timeout, "f"), ir(this, cv, e.throwOnTimeout === true, "f"), ir(this, vf, e.autoStart === false, "f");
          }
          get concurrency() {
            return Se(this, Y3, "f");
          }
          set concurrency(e) {
            if (!(typeof e == "number" && e >= 1))
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);
            ir(this, Y3, e, "f"), Se(this, Qn, "m", fv).call(this);
          }
          async add(e, r = {}) {
            return new Promise((n, i2) => {
              let o = async () => {
                var s, a, u;
                ir(this, Oo, (a = Se(this, Oo, "f"), a++, a), "f"), ir(this, Sf, (u = Se(this, Sf, "f"), u++, u), "f");
                try {
                  if (!((s = r.signal) === null || s === void 0) && s.aborted) {
                    i2(new Sk("The task was aborted."));
                    return;
                  }
                  let f = await (Se(this, Hd, "f") === void 0 && r.timeout === void 0 ? e({ signal: r.signal }) : nn(Promise.resolve(e({ signal: r.signal })), r.timeout === void 0 ? Se(this, Hd, "f") : r.timeout, () => {
                    (r.throwOnTimeout === void 0 ? Se(this, cv, "f") : r.throwOnTimeout) && i2(sNe);
                  }));
                  n(f), this.emit("completed", f);
                } catch (l) {
                  i2(l), this.emit("error", l);
                }
                Se(this, Qn, "m", Fle).call(this);
              };
              Se(this, No, "f").enqueue(o, r), Se(this, Qn, "m", uv).call(this), this.emit("add");
            });
          }
          async addAll(e, r) {
            return Promise.all(e.map(async (n) => this.add(n, r)));
          }
          start() {
            return Se(this, vf, "f") ? (ir(this, vf, false, "f"), Se(this, Qn, "m", fv).call(this), this) : this;
          }
          pause() {
            ir(this, vf, true, "f");
          }
          clear() {
            ir(this, No, new (Se(this, av, "f"))(), "f");
          }
          async onEmpty() {
            if (Se(this, No, "f").size !== 0)
              return new Promise((e) => {
                let r = Se(this, wm, "f");
                ir(this, wm, () => {
                  r(), e();
                }, "f");
              });
          }
          async onSizeLessThan(e) {
            if (!(Se(this, No, "f").size < e))
              return new Promise((r) => {
                let n = () => {
                  Se(this, No, "f").size < e && (this.removeListener("next", n), r());
                };
                this.on("next", n);
              });
          }
          async onIdle() {
            if (!(Se(this, Oo, "f") === 0 && Se(this, No, "f").size === 0))
              return new Promise((e) => {
                let r = Se(this, Em, "f");
                ir(this, Em, () => {
                  r(), e();
                }, "f");
              });
          }
          get size() {
            return Se(this, No, "f").size;
          }
          sizeBy(e) {
            return Se(this, No, "f").filter(e).length;
          }
          get pending() {
            return Se(this, Oo, "f");
          }
          get isPaused() {
            return Se(this, vf, "f");
          }
          get timeout() {
            return Se(this, Hd, "f");
          }
          set timeout(e) {
            ir(this, Hd, e, "f");
          }
        };
        G3 = /* @__PURE__ */ new WeakMap(), W3 = /* @__PURE__ */ new WeakMap(), Sf = /* @__PURE__ */ new WeakMap(), lv = /* @__PURE__ */ new WeakMap(), j3 = /* @__PURE__ */ new WeakMap(), sv = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), $3 = /* @__PURE__ */ new WeakMap(), No = /* @__PURE__ */ new WeakMap(), av = /* @__PURE__ */ new WeakMap(), Oo = /* @__PURE__ */ new WeakMap(), Y3 = /* @__PURE__ */ new WeakMap(), vf = /* @__PURE__ */ new WeakMap(), wm = /* @__PURE__ */ new WeakMap(), Em = /* @__PURE__ */ new WeakMap(), Hd = /* @__PURE__ */ new WeakMap(), cv = /* @__PURE__ */ new WeakMap(), Qn = /* @__PURE__ */ new WeakSet(), Ole = function() {
          return Se(this, W3, "f") || Se(this, Sf, "f") < Se(this, lv, "f");
        }, Lle = function() {
          return Se(this, Oo, "f") < Se(this, Y3, "f");
        }, Fle = function() {
          var e;
          ir(this, Oo, (e = Se(this, Oo, "f"), e--, e), "f"), Se(this, Qn, "m", uv).call(this), this.emit("next");
        }, Ble = function() {
          Se(this, wm, "f").call(this), ir(this, wm, hv, "f"), Se(this, Oo, "f") === 0 && (Se(this, Em, "f").call(this), ir(this, Em, hv, "f"), this.emit("idle"));
        }, Mle = function() {
          Se(this, Qn, "m", vk).call(this), Se(this, Qn, "m", _k).call(this), ir(this, $3, void 0, "f");
        }, Ule = function() {
          let e = Date.now();
          if (Se(this, sa, "f") === void 0) {
            let r = Se(this, sv, "f") - e;
            if (r < 0)
              ir(this, Sf, Se(this, G3, "f") ? Se(this, Oo, "f") : 0, "f");
            else
              return Se(this, $3, "f") === void 0 && ir(this, $3, setTimeout(() => {
                Se(this, Qn, "m", Mle).call(this);
              }, r), "f"), true;
          }
          return false;
        }, uv = function() {
          if (Se(this, No, "f").size === 0)
            return Se(this, sa, "f") && clearInterval(Se(this, sa, "f")), ir(this, sa, void 0, "f"), Se(this, Qn, "m", Ble).call(this), false;
          if (!Se(this, vf, "f")) {
            let e = !Se(this, Qn, "m", Ule).call(this);
            if (Se(this, Qn, "a", Ole) && Se(this, Qn, "a", Lle)) {
              let r = Se(this, No, "f").dequeue();
              return r ? (this.emit("active"), r(), e && Se(this, Qn, "m", _k).call(this), true) : false;
            }
          }
          return false;
        }, _k = function() {
          Se(this, W3, "f") || Se(this, sa, "f") !== void 0 || (ir(this, sa, setInterval(() => {
            Se(this, Qn, "m", vk).call(this);
          }, Se(this, j3, "f")), "f"), ir(this, sv, Date.now() + Se(this, j3, "f"), "f"));
        }, vk = function() {
          Se(this, Sf, "f") === 0 && Se(this, Oo, "f") === 0 && Se(this, sa, "f") && (clearInterval(Se(this, sa, "f")), ir(this, sa, void 0, "f")), ir(this, Sf, Se(this, G3, "f") ? Se(this, Oo, "f") : 0, "f"), Se(this, Qn, "m", fv).call(this);
        }, fv = function() {
          for (; Se(this, Qn, "m", uv).call(this); )
            ;
        };
        var qle = w($o(), 1);
        var xk = "routing-table-size", aNe = "ping-queue-size", cNe = "ping-running", dv = class {
          constructor(e) {
            this.components = new He();
            let { kBucketSize: r, pingTimeout: n, lan: i2, pingConcurrency: o, protocol: s } = e;
            this.log = C(`libp2p:kad-dht:${i2 ? "lan" : "wan"}:routing-table`), this.kBucketSize = r ?? 20, this.pingTimeout = n ?? 1e4, this.pingConcurrency = o ?? 10, this.lan = i2, this.running = false, this.protocol = s;
            let a = () => {
              this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: aNe, value: this.pingQueue.size }), this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: cNe, value: this.pingQueue.pending });
            };
            this.pingQueue = new Au({ concurrency: this.pingConcurrency }), this.pingQueue.addListener("add", a), this.pingQueue.addListener("next", a), this._onPing = this._onPing.bind(this);
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.running;
          }
          async start() {
            this.running = true;
            let e = new Vle.default({ localNodeId: await ko(this.components.getPeerId()), numberOfNodesPerKBucket: this.kBucketSize, numberOfNodesToPing: 1 });
            e.on("ping", this._onPing), this.kb = e;
          }
          async stop() {
            this.running = false, this.pingQueue.clear(), this.kb = void 0;
          }
          _onPing(e, r) {
            this.pingQueue.add(async () => {
              if (!this.running)
                return;
              let n = 0;
              try {
                await Promise.all(e.map(async (i2) => {
                  let o;
                  try {
                    o = new qle.TimeoutController(this.pingTimeout);
                    let s = { signal: o.signal };
                    this.log("pinging old contact %p", i2.peer);
                    let a = await this.components.getConnectionManager().openConnection(i2.peer, s), { stream: u } = await a.newStream(this.protocol, s);
                    u.close(), n++;
                  } catch (s) {
                    this.running && this.kb != null && (this.log.error("could not ping peer %p", i2.peer, s), this.log("evicting old contact after ping failed %p", i2), this.kb.remove(i2.id));
                  } finally {
                    o?.clear(), this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: xk, value: this.size });
                  }
                })), this.running && n < e.length && this.kb != null && (this.log("adding new contact %p", r.peer), this.kb.add(r));
              } catch (i2) {
                this.log.error("could not process k-bucket ping event", i2);
              }
            }).catch((n) => {
              this.log.error("could not process k-bucket ping event", n);
            });
          }
          get size() {
            return this.kb == null ? 0 : this.kb.count();
          }
          async find(e) {
            let r = await ko(e), n = this.closestPeer(r);
            if (n != null && e.equals(n))
              return n;
          }
          closestPeer(e) {
            let r = this.closestPeers(e, 1);
            if (r.length > 0)
              return r[0];
          }
          closestPeers(e, r = this.kBucketSize) {
            return this.kb == null ? [] : this.kb.closest(e, r).map((i2) => i2.peer);
          }
          async add(e) {
            if (this.kb == null)
              throw new Error("RoutingTable is not started");
            let r = await ko(e);
            this.kb.add({ id: r, peer: e }), this.log("added %p with kad id %b", e, r), this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: xk, value: this.size });
          }
          async remove(e) {
            if (this.kb == null)
              throw new Error("RoutingTable is not started");
            let r = await ko(e);
            this.kb.remove(r), this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: xk, value: this.size });
          }
        };
        c();
        c();
        var zle = [77591, 22417, 43971, 28421, 740, 29829, 71467, 228973, 196661, 78537, 27689, 36431, 44415, 14362, 19456, 106025, 96308, 2882, 49509, 21149, 87173, 131409, 75844, 23676, 121838, 30291, 17492, 2953, 7564, 110620, 129477, 127283, 53113, 72417, 165166, 109690, 21200, 102125, 24049, 71504, 90342, 25307, 72039, 26812, 26715, 32264, 133800, 71161, 88956, 171987, 51779, 24425, 16671, 30251, 186294, 247761, 14202, 2121, 8465, 35024, 4876, 85917, 169730, 3638, 256836, 96184, 943, 18678, 6583, 52907, 35807, 112254, 214097, 18796, 11595, 9243, 23554, 887, 268203, 382004, 24590, 111335, 11625, 16619, 29039, 102425, 69006, 97976, 92362, 32552, 63717, 41433, 128974, 137630, 59943, 10019, 13986, 35430, 33665, 108037, 43799, 43280, 38195, 29078, 58629, 18265, 14425, 46832, 235538, 40830, 77881, 110717, 58937, 3463, 325358, 51300, 47623, 117252, 19007, 10170, 20540, 91237, 294813, 4951, 79841, 56232, 36270, 128547, 69209, 66275, 100156, 32063, 73531, 34439, 80937, 28892, 44466, 88595, 216307, 32583, 49620, 16605, 82127, 45807, 21630, 78726, 20235, 40163, 111007, 96926, 5567, 72083, 21665, 58844, 39419, 179767, 48328, 42662, 51550, 5251, 37811, 49608, 81056, 50854, 55513, 20922, 18891, 197409, 164656, 32593, 71449, 220474, 58919, 85682, 67854, 13758, 35066, 3565, 61905, 214793, 119572, 141419, 21504, 10302, 27354, 67003, 46131, 32668, 15165, 64871, 34450, 17821, 2757, 11452, 34189, 5160, 12257, 85523, 560, 53385, 65887, 119549, 135620, 312353, 115979, 122356, 10867, 193231, 124537, 54783, 90675, 120791, 4715, 142253, 50943, 17271, 43358, 25331, 4917, 120566, 34580, 12878, 33786, 160528, 32523, 4869, 301307, 104817, 81491, 23276, 8832, 97911, 31265, 52065, 7998, 49622, 9715, 43998, 34091, 84587, 20664, 69041, 29419, 53205, 10838, 58288, 116145, 6185, 5154, 141795, 35924, 21307, 144738, 43730, 12085, 8279, 10002, 119, 133779, 199668, 72938, 31768, 39176, 67875, 38453, 9700, 44144, 4121, 116048, 41733, 12868, 82669, 92308, 128, 34262, 11332, 7712, 90764, 36141, 13553, 71312, 77470, 117314, 96549, 49135, 23602, 54468, 28605, 6327, 62308, 17171, 67531, 21319, 14105, 894, 107722, 46157, 8503, 51069, 100472, 45138, 15246, 14577, 35609, 191464, 1757, 13364, 161349, 32067, 91705, 81144, 52339, 5408, 91066, 21983, 14157, 100545, 4372, 26630, 129112, 1423, 29676, 213626, 4397, 88436, 99190, 6877, 49958, 26122, 114348, 60661, 29818, 293118, 50042, 179738, 16400, 163423, 89627, 31040, 43973, 36638, 45952, 5153, 1894, 109322, 1898, 134021, 12402, 112077, 68309, 190269, 69866, 31938, 107383, 11522, 105232, 11248, 14868, 39852, 71707, 186525, 16530, 38162, 106212, 11700, 5130, 16608, 26998, 59586, 108399, 230033, 43683, 48135, 82179, 2073, 5015, 196684, 189293, 16378, 23452, 8301, 35640, 11632, 214551, 29240, 57644, 33137, 91949, 55157, 52384, 117313, 5090, 17717, 89668, 49363, 82238, 241035, 66216, 29066, 184088, 97206, 62820, 26595, 4241, 135635, 173672, 8202, 459, 71355, 146294, 29587, 3008, 135385, 141203, 14803, 6634, 45094, 69362, 50925, 546, 51884, 62011, 83296, 234584, 44515, 56050, 89476, 87751, 19373, 12691, 149923, 19794, 13833, 35846, 87557, 58339, 2884, 19145, 25647, 12224, 11024, 77338, 64608, 122297, 53025, 7205, 36189, 36294, 170779, 21750, 7739, 173883, 75192, 35664, 224240, 113121, 30181, 26267, 27036, 117827, 92015, 106516, 55628, 203549, 67949, 60462, 60844, 35911, 20457, 1820, 920, 19773, 8738, 73173, 181993, 38521, 98254, 76257, 46008, 92796, 5384, 26868, 151566, 22124, 2411, 15919, 186872, 180021, 28099, 152961, 78811, 80237, 62352, 102653, 74259, 184890, 16792, 123702, 224945, 29940, 19512, 75283, 14059, 112691, 92811, 233329, 20411, 138569, 53341, 109802, 50600, 134528, 66747, 5529, 166531, 31578, 64732, 67189, 1596, 126357, 967, 167999, 206598, 109752, 119431, 207825, 78791, 91938, 10301, 27311, 24233, 252343, 28831, 32812, 66002, 112267, 90895, 8786, 8095, 16824, 22866, 21813, 60507, 174833, 19549, 130985, 117051, 52110, 6938, 81923, 123864, 38061, 919, 18680, 53534, 46739, 112893, 161529, 85429, 26761, 11900, 81121, 91968, 15390, 217947, 56524, 1713, 6654, 37089, 85630, 138866, 61850, 16491, 75577, 16884, 98296, 73523, 6140, 44645, 6062, 36366, 29844, 57946, 37932, 42472, 5266, 20834, 19309, 33753, 127182, 134259, 35810, 41805, 45878, 312001, 14881, 47757, 49251, 120050, 44252, 3708, 25856, 107864, 120347, 1228, 36550, 41682, 34496, 47025, 8393, 173365, 246526, 12894, 161607, 35670, 90785, 126572, 2095, 124731, 157033, 58694, 554, 12786, 9642, 4817, 16136, 47864, 174698, 66992, 4639, 69284, 10625, 40710, 27763, 51738, 30404, 264105, 137904, 109882, 52487, 42824, 57514, 2740, 10479, 146799, 107390, 16586, 88038, 174951, 9410, 16185, 44158, 5568, 40658, 46108, 12763, 97385, 26175, 108859, 664, 230732, 67470, 46663, 14395, 50750, 141320, 93140, 15361, 47997, 55784, 6791, 307840, 118569, 107326, 18056, 58281, 260415, 54691, 8790, 73332, 45633, 7511, 45674, 143373, 14031, 11799, 94491, 35646, 96544, 14560, 26049, 32983, 25791, 83814, 42094, 231370, 63955, 139212, 2359, 169908, 3108, 183486, 105867, 28197, 32941, 124968, 26402, 88267, 149768, 23053, 3078, 19091, 52924, 25383, 19209, 111548, 97361, 3959, 24880, 235061, 9099, 24921, 161254, 151405, 20508, 7159, 34381, 20133, 11434, 74036, 19974, 34769, 36585, 1076, 22454, 17354, 38727, 235160, 111547, 96454, 117448, 156940, 91330, 37299, 7310, 26915, 117060, 51369, 22620, 61861, 322264, 106850, 111694, 15091, 2624, 40345, 300446, 177064, 1707, 27389, 54792, 327783, 132669, 183543, 59003, 17744, 20603, 151134, 106923, 53084, 71803, 279424, 319816, 11579, 21946, 16728, 38274, 72711, 5085, 83391, 88646, 40159, 25027, 34680, 10752, 12988, 54126, 30365, 18338, 100445, 230674, 44874, 84974, 143877, 123253, 139372, 28082, 91477, 144002, 13096, 219729, 46016, 50029, 42377, 14601, 6660, 58244, 58978, 23918, 88206, 113611, 64452, 17541, 41032, 10942, 12021, 49189, 10978, 40175, 37156, 10947, 71709, 106894, 112538, 57007, 137486, 150608, 152719, 40615, 7746, 279716, 13101, 19524, 28708, 40578, 72320, 1096, 182051, 94527, 51275, 22833, 45164, 81917, 77519, 48508, 5421, 140302, 37845, 149830, 5587, 27579, 5357, 428725, 248187, 6326, 206760, 39814, 32585, 89923, 44341, 288753, 284443, 96368, 31201, 94189, 119504, 20359, 52073, 103216, 179, 27934, 32801, 96035, 34111, 34309, 101326, 18198, 20704, 210266, 37643, 27880, 141873, 106e3, 19414, 56614, 167714, 66483, 107885, 86602, 4379, 20796, 75467, 4987, 5017, 118857, 26003, 34308, 114428, 29198, 6686, 29697, 73632, 3739, 69795, 16798, 41504, 7207, 30722, 21436, 36735, 28067, 28545, 3239, 11221, 36031, 41889, 100010, 19247, 317673, 29495, 174554, 6424, 129725, 53845, 94986, 7955, 59676, 2604, 191497, 19735, 102214, 62954, 23844, 11872, 179525, 261436, 34492, 428, 78404, 142035, 16747, 17246, 27578, 37021, 33672, 57944, 26056, 135760, 2369, 61674, 122066, 31327, 19374, 157065, 40553, 130982, 69619, 71290, 38855, 72100, 92903, 95940, 51422, 165999, 65713, 57873, 50726, 7288, 20272, 2081, 42326, 22624, 81120, 57914, 79352, 19447, 1684, 72302, 11774, 302559, 161481, 96396, 13692, 414988, 3721, 79066, 56627, 46883, 21150, 11747, 12184, 5856, 113458, 176117, 84416, 52079, 27933, 3354, 59765, 141359, 2212, 216309, 2555, 23458, 196722, 142463, 45701, 44548, 28798, 19418, 215, 29916, 9396, 10574, 114226, 84475, 13520, 18694, 34056, 4524, 90302, 62930, 13539, 19407, 77209, 7728, 38088, 9535, 2263, 23875, 183945, 17750, 26274, 67172, 10585, 28042, 22199, 7478, 51331, 66030, 26774, 192929, 31434, 25850, 50197, 52926, 178158, 4679, 181256, 70184, 229600, 9959, 105594, 72158, 73974, 2726, 35085, 78087, 23284, 35568, 51713, 155676, 5401, 27254, 11966, 17569, 223253, 71993, 103357, 111477, 55722, 30504, 26034, 46774, 35392, 36285, 214814, 41143, 163465, 1051, 16094, 81044, 6636, 76489, 179102, 20712, 39178, 35683, 125177, 54219, 30617, 52994, 25324, 50123, 2543, 87529, 58995, 10688, 125199, 12388, 60158, 125481, 131646, 7642, 133350, 65874, 3438, 97277, 101450, 10075, 56344, 116821, 50778, 60547, 98016, 106135, 13859, 14255, 16300, 77373, 173521, 8285, 45932, 37426, 4054, 114295, 55947, 7703, 39114, 52, 51119, 128135, 19714, 60715, 9554, 50492, 88180, 2823, 118271, 52993, 122625, 97919, 23859, 37895, 25040, 33614, 32102, 20431, 3577, 9275, 15686, 43031, 157741, 110358, 1884, 40291, 125391, 13736, 5008, 64881, 87336, 77381, 70711, 43032, 49155, 118587, 70494, 4318, 10168, 30126, 12580, 10524, 280104, 104001, 145413, 2862, 84140, 6603, 106005, 13566, 12780, 11251, 42830, 571, 179910, 82443, 13146, 469, 42714, 32591, 265217, 424024, 92553, 54721, 134100, 6007, 15242, 114681, 59030, 16718, 85465, 200214, 85982, 55174, 165013, 23493, 56964, 82529, 109150, 32706, 27568, 82442, 5350, 14976, 13165, 44890, 60021, 21343, 33978, 17264, 4655, 22328, 27819, 75730, 16567, 55483, 14510, 17926, 45827, 150609, 3704, 7385, 272531, 161543, 76904, 122163, 52405, 2039, 19165, 41623, 14423, 228354, 3369, 176360, 85491, 7122, 35789, 303724, 4465, 13628, 2233, 55311, 118771, 20713, 10006, 221519, 45115, 71021, 35650, 29775, 7337, 10864, 20665, 21142, 1746, 15080, 1624, 32449, 10905, 105743, 229797, 7701, 3940, 22997, 178467, 57208, 389057, 39683, 59403, 63344, 63125, 54847, 69691, 18336, 56448, 3362, 37202, 18282, 29648, 138224, 35867, 10495, 5911, 28814, 26653, 31514, 176702, 26550, 45621, 11734, 4525, 40543, 73944, 121080, 27858, 155561, 14887, 44670, 30742, 8796, 107455, 113472, 56369, 75581, 183777, 240095, 133699, 153299, 8768, 160464, 26058, 49078, 103971, 21875, 71486, 44888, 17156, 9678, 89541, 123019, 102337, 3972, 83930, 21245, 87852, 109660, 287918, 183019, 686, 10100, 39177, 283941, 11274, 24736, 26793, 26214, 25995, 77011, 141580, 4070, 23742, 46285, 46632, 30700, 26669, 19056, 35951, 115575, 174034, 56097, 35463, 87425, 24575, 44245, 38701, 82317, 85922, 281616, 100333, 147697, 61503, 7730, 84330, 8530, 59917, 61597, 17173, 9092, 32658, 90288, 193136, 39023, 20381, 56654, 31132, 7779, 1919, 1375, 117128, 30819, 11169, 40938, 23935, 115201, 101155, 151034, 4835, 11231, 74550, 89388, 59951, 91704, 107312, 167882, 115062, 12732, 72738, 88703, 464019, 158267, 57995, 60496, 737, 14371, 123867, 4174, 243339, 159946, 7568, 16025, 134556, 110916, 38103, 191, 80226, 88794, 29688, 27230, 10454, 76308, 57647, 77409, 113483, 66864, 14745, 19808, 12023, 46583, 84805, 16015, 17102, 2231, 20611, 3547, 95740, 250131, 34559, 108894, 8498, 15853, 159169, 148920, 20942, 2813, 93160, 45188, 210613, 45531, 52587, 149062, 39782, 28194, 57849, 60965, 84954, 89766, 84453, 100927, 16501, 27658, 165311, 103841, 54192, 207341, 19558, 20084, 319622, 5672, 205467, 98462, 61849, 36279, 13609, 147177, 24726, 165015, 209489, 59591, 31157, 6551, 117580, 75060, 141146, 277310, 21072, 22023, 106474, 63041, 137443, 122965, 68371, 5383, 42146, 98961, 113467, 30863, 23794, 4843, 99630, 30392, 82679, 13699, 241612, 33601, 93146, 24319, 18643, 32155, 95669, 40440, 15333, 34089, 67799, 142144, 58245, 38633, 114531, 117400, 77861, 188726, 5507, 2568, 8853, 10987, 107222, 2663, 2421, 11530, 13345, 30075, 41785, 118661, 104786, 17459, 12490, 16281, 71936, 193555, 17431, 5944, 71758, 26485, 77317, 20803, 367167, 158, 7362, 93430, 11735, 172445, 46002, 11532, 54482, 930, 62911, 2235, 23004, 179236, 4764, 101859, 208113, 22477, 55163, 95579, 14098, 67320, 162556, 90709, 156949, 3826, 57492, 4025, 34092, 87442, 104565, 6718, 186015, 28214, 14209, 10039, 107186, 233912, 58877, 81637, 55265, 39828, 6194, 145813, 50831, 105849, 4974, 88319, 122296, 10272, 197216, 95714, 51540, 72418, 23324, 91555, 8743, 140452, 250249, 51666, 34124, 7229, 38592, 129641, 78169, 174242, 22464, 149964, 51450, 14034, 10026, 95376, 26190, 120062, 14401, 8700, 265, 31386, 143573, 7203, 229889, 61567, 4227, 140981, 2466, 72052, 10787, 10062, 30958, 6099, 38471, 30103, 23202, 208101, 70847, 467, 58934, 32271, 32984, 36637, 24107, 30771, 17109, 73353, 13650, 2098, 157040, 67366, 66904, 106018, 265380, 107238, 18535, 44025, 32681, 144983, 62505, 91295, 56120, 3082, 77508, 10322, 63023, 36700, 81885, 224127, 16721, 45023, 239261, 111272, 13852, 7866, 149243, 204199, 32309, 22084, 42029, 38316, 126644, 104973, 14406, 43454, 67322, 61310, 15789, 40285, 24026, 181047, 6301, 70927, 23319, 115823, 27248, 66693, 115875, 278566, 63007, 146844, 56841, 59007, 87368, 180001, 22370, 42114, 80605, 12022, 10374, 308, 25079, 14689, 12618, 63368, 7936, 264973, 212291, 136713, 95999, 105801, 18965, 32075, 48700, 52230, 35119, 96912, 32992, 8586, 16606, 101333, 101812, 14969, 39930, 759, 193090, 27387, 42914, 12937, 5058, 62646, 64528, 38624, 25743, 37502, 3716, 4435, 30352, 178687, 26461, 132611, 42002, 138442, 35833, 59582, 16345, 8048, 60319, 49349, 309, 47800, 49739, 90482, 26405, 34470, 63786, 32479, 85028, 39866, 47846, 11649, 23934, 29466, 2816, 42864, 31828, 7410, 74885, 49632, 47629, 111801, 90749, 19536, 18767, 105764, 59606, 21223, 10746, 76298, 22220, 39408, 7190, 79654, 64856, 11602, 82156, 272765, 17079, 70089, 245473, 51813, 184407, 384678, 1576, 122249, 5064, 27481, 6188, 25790, 74361, 27541, 318284, 45430, 31488, 620, 93579, 45723, 192118, 22670, 51913, 4162, 70244, 35966, 26397, 16199, 50899, 209613, 121702, 287507, 2993, 36101, 132229, 67345, 33062, 76295, 118628, 78705, 52316, 34375, 107083, 107454, 44863, 127561, 33964, 3073, 154010, 190914, 55967, 39074, 6272, 31047, 5550, 41123, 26154, 98638, 47110, 19998, 148091, 50229, 31329, 59900, 195442, 19106, 61347, 73497, 70015, 682, 45850, 25776, 38022, 148951, 6288, 37411, 232526, 109277, 27286, 32342, 9262, 5220, 16651, 23175, 46740, 129438, 78614, 121925, 66914, 88710, 127952, 5563, 21500, 34521, 10739, 14863, 191006, 62956, 17359, 16749, 67027, 56284, 69134, 43301, 35039, 58883, 54466, 60823, 404451, 75743, 59856, 86979, 7923, 34273, 83785, 32142, 7693, 268986, 197428, 282681, 17049, 22346, 22990, 92245, 107180, 3357, 37104, 96724, 49153, 7683, 31197, 43267, 82231, 164276, 23696, 20848, 188364, 22309, 24821, 158707, 1018, 22514, 70922, 27792, 45589, 59709, 10765, 736, 35218, 63479, 51987, 24275, 63588, 55361, 92929, 81964, 4658, 20122, 12330, 44058, 13065, 311456, 72224, 8337, 211229, 38979, 22590, 138478, 52757, 32595, 133600, 8838, 31549, 94412, 43391, 90056, 1585, 94802, 127271, 6223, 31889, 137038, 132910, 2165, 57616, 230152, 6080, 10748, 36737, 74579, 134062, 50525, 180532, 119270, 34556, 76155, 82394, 52595, 29258, 31435, 87820, 67996, 26943, 183878, 38007, 2410, 13526, 180297, 69856, 3503, 187396, 167700, 7838, 16701, 9199, 56267, 3661, 37407, 65994, 23767, 5708, 62508, 221700, 67088, 86978, 46776, 84434, 32088, 5612, 9149, 88244, 21685, 95151, 46750, 189612, 2979, 506311, 2594, 3628, 40074, 105039, 78243, 28523, 6651, 38058, 71999, 30992, 12764, 68261, 108991, 6165, 26450, 61961, 13400, 22426, 7490, 60890, 109623, 2070, 12958, 50355, 67979, 257096, 7213, 42578, 52121, 35716, 65461, 7516, 124758, 39268, 302, 64712, 14977, 1467, 219452, 2840, 34229, 11121, 21602, 19270, 63574, 8024, 1532, 17331, 79839, 78885, 52029, 180767, 57957, 6069, 91265, 61380, 55767, 8927, 32881, 287603, 22149, 35029, 68876, 6428, 199567, 46926, 13412, 104132, 21434, 366616, 45060, 110046, 81924, 128910, 45886, 52821, 130416, 29416, 77342, 21762, 67329, 121432, 79924, 11724, 38625, 81006, 102033, 28338, 13326, 3250, 82056, 82526, 38212, 21112, 12382, 111495, 3263, 7414, 86274, 93490, 40844, 30224, 45212, 24019, 48411, 71367, 24941, 76729, 57776, 3769, 38114, 202019, 197745, 31953, 237533, 33270, 201580, 255648, 100798, 44741, 32241, 98468, 106931, 10085, 15090, 170358, 33154, 66787, 18819, 69760, 25061, 234005, 82660, 6295, 131975, 16874, 9076, 4094, 25005, 17740, 40908, 19533, 220019, 44330, 99792, 50040, 19619, 13950, 55228, 24423, 31253, 95308, 103177, 184795, 28590, 82285, 5059, 3210, 75525, 49894, 70007, 56178, 10580, 36051, 139681, 21617, 98736, 3555, 106306, 164189, 37352, 63915, 47824, 24883, 145530, 61904, 28444, 11483, 19837, 145446, 30420, 112972, 85939, 11835, 191233, 2262, 20705, 58630, 1753, 148334, 1197, 144714, 6887, 11223, 107667, 60879, 77914, 4151, 57417, 81594, 96681, 169430, 1784, 20444, 95138, 254041, 27038, 596, 7117, 72808, 13759, 3353, 126776, 21074, 55322, 27081, 36942, 39547, 139830, 179275, 4453, 713, 8722, 71399, 19204, 25785, 22794, 23923, 104114, 11291, 25458, 102309, 88396, 75288, 230440, 206396, 104551, 58447, 130857, 37247, 94734, 31548, 176529, 226077, 65159, 20104, 10096, 66881, 94191, 237909, 27109, 37404, 1520, 27421, 25220, 113003, 23423, 24884, 50585, 6286, 231877, 150800, 11789, 3226, 90004, 60642, 5053, 202400, 61442, 132531, 175329, 57138, 30116, 103847, 9973, 75367, 16452, 32360, 59119, 21246, 10191, 164804, 23305, 61051, 37348, 154530, 13214, 5468, 50403, 66754, 130976, 50559, 80515, 14436, 155492, 84017, 5472, 43107, 41240, 2890, 90431, 70188, 382, 76234, 48040, 50211, 281038, 237007, 32115, 142178, 1536, 22761, 96429, 1811, 31243, 1679, 49143, 55209, 17402, 235054, 61494, 7462, 77030, 34925, 87609, 78002, 9499, 9027, 73289, 201078, 101379, 63544, 27666, 5469, 10642, 30029, 49816, 132979, 95620, 58086, 351930, 116300, 2110, 2043, 30845, 6154, 11279, 16727, 4122, 2277, 27281, 4971, 3650, 39060, 61970, 65951, 39674, 75686, 38151, 11370, 130809, 177895, 32665, 63725, 122267, 7857, 39618, 118483, 44792, 157755, 178624, 136994, 24260, 41308, 22471, 12404, 21707, 12486, 30473, 52781, 50246, 20247, 39065, 909, 56825, 103158, 128603, 31542, 1089, 41935, 32744, 12428, 37963, 84420, 33134, 72921, 208449, 42622, 168151, 127335, 147107, 46699, 38216, 12591, 94342, 85814, 31423, 24944, 2605, 87542, 67473, 192551, 4496, 56321, 91819, 17630, 6300, 256183, 114569, 202090, 33209, 35289, 34897, 24967, 40520, 43470, 5344, 10199, 34810, 14283, 10381, 10017, 62923, 49924, 23233, 64539, 13051, 35686, 19698, 11570, 135555, 120868, 44924, 87065, 52318, 52335, 47586, 140906, 245885, 109834, 78668, 9065, 46990, 25258, 72022, 61243, 40838, 4545, 146387, 10537, 11557, 17470, 36930, 68104, 46711, 24264, 79401, 81043, 18225, 120488, 24746, 84338, 81652, 28266, 13776, 21878, 46973, 1047, 230465, 73357, 95777, 24973, 210160, 62210, 58404, 110633, 169651, 6937, 41870, 9909, 26822, 191062, 76553, 27519, 96256, 239070, 2478, 205678, 67955, 58532, 20601, 50120, 19148, 78501, 195724, 110740, 8249, 109665, 27446, 30568, 57631, 31425, 49752, 32820, 65504, 50079, 3663, 102256, 219898, 23849, 211315, 14645, 4359, 91767, 9528, 12449, 49366, 7941, 49763, 107848, 8930, 27086, 50686, 9744, 10447, 81935, 39513, 46514, 1670, 29229, 6172, 22312, 137280, 97759, 9806, 14445, 22976, 56458, 73391, 34983, 93760, 174219, 52573, 33149, 59747, 2429, 136277, 75123, 165263, 91040, 7446, 57632, 48633, 97140, 246081, 84766, 151684, 79918, 93268, 120346, 54059, 54875, 77858, 32996, 103590, 45276, 11968, 19600, 25849, 17159, 132907, 42828, 16817, 4913, 99462, 103303, 27395, 5737, 74184, 20749, 21160, 14377, 77062, 131403, 158735, 10999, 27799, 77785, 9320, 34366, 51593, 61070, 33746, 47048, 29268, 36675, 30262, 53297, 9832, 82e3, 20188, 122292, 39917, 7331, 18160, 68301, 185935, 134830, 15031, 4935, 10004, 165845, 185534, 46923, 30109, 44134, 122631, 18874, 22903, 112790, 26561, 18549, 348902, 82871, 140345, 255565, 135390, 63556, 103747, 145055, 179600, 145662, 296111, 61661, 211987, 23952, 52342, 126343, 48450, 32919, 44277, 82185, 9591, 62139, 205363, 376969, 394874, 108461, 18040, 120885, 14798, 39863, 16571, 16794, 58271, 81025, 55206, 14640, 118656, 6361, 44092, 85970, 6262, 153863, 108244, 180200, 72264, 79947, 38044, 10050, 5735, 61221, 80712, 5471, 115689, 11391, 11661, 184257, 20010, 60116, 30320, 19327, 134598, 45455, 27542, 18004, 125092, 452272, 1549, 91523, 46567, 180063, 156026, 2608, 11174, 58848, 37788, 65907, 80194, 30490, 5786, 40775, 119519, 106241, 11323, 156297, 8425, 61495, 2617, 29675, 2425, 59886, 112582, 49142, 59618, 4863, 50597, 86710, 50650, 168632, 27693, 85641, 83643, 18993, 25768, 84284, 28090, 93592, 36627, 312804, 43381, 9887, 9402, 100931, 97165, 3311, 173330, 66805, 28935, 4963, 184460, 3201, 78102, 19126, 21607, 37496, 24938, 22615, 16153, 32862, 134792, 153318, 61120, 6067, 2812, 12826, 12792, 23825, 37559, 64662, 202250, 102694, 155488, 85881, 149193, 46233, 65383, 15521, 106982, 11358, 176786, 25752, 39717, 34208, 24510, 32464, 77742, 39371, 72028, 138229, 60688, 71386, 102834, 132477, 2208, 11548, 63670, 271279, 28351, 30338, 38620, 32491, 99845, 143885, 152266, 13252, 2825, 178663, 108097, 1775, 78201, 14897, 113573, 163346, 62292, 171129, 22183, 96598, 38733, 64971, 166776, 117445, 9968, 146393, 44677, 74867, 20908, 97328, 12761, 25656, 26785, 9148, 112344, 26115, 99176, 110121, 22437, 49547, 6180, 79320, 5835, 31392, 43328, 33377, 75870, 119860, 69497, 80273, 7325, 155219, 43167, 111173, 28347, 20222, 3763, 71752, 55041, 47252, 14618, 28088, 15012, 97805, 194698, 54636, 2036, 41349, 6173, 96604, 61530, 51859, 43782, 13361, 24334, 22668, 24792, 7070, 23441, 16789, 3209, 36211, 208475, 26242, 32880, 122181, 182407, 21444, 31060, 88459, 29929, 77907, 12716, 10934, 97005, 20599, 31690, 8403, 58445, 30303, 22700, 10336, 86731, 103115, 337709, 72556, 46788, 112566, 47684, 67089, 53548, 36874, 56487, 41387, 125985, 26893, 40071, 106683, 73712, 18787, 40105, 72992, 67246, 137276, 50802, 36790, 70328, 138827, 22466, 39263, 183295, 29858, 50975, 9322, 57397, 10654, 24364, 30383, 55799, 41600, 23584, 127295, 296610, 129078, 143558, 244131, 86397, 36049, 1085, 80677, 3820, 108139, 5476, 34767, 24683, 7758, 13060, 7239, 131671, 250593, 59556, 103392, 29810, 4188, 252323, 39404, 116877, 7651, 43600, 40338, 13554, 157253, 39196, 25978, 144387, 61211, 234, 50104, 6129, 10449, 93777, 9240, 356378, 274148, 4439, 72970, 3724, 147770, 78680, 62570, 115877, 40027, 40547, 36817, 224392, 64609, 34795, 165027, 67440, 2477, 37206, 23431, 50754, 164797, 46018, 94995, 170982, 27051, 7957, 22767, 3674, 27900, 56419, 18930, 60701, 41302, 2692, 84749, 339721, 61996, 111094, 80221, 50129, 1045, 8153, 62945, 19202, 8250, 37208, 37418, 32560, 79477, 41106, 88569, 33963, 36693, 5892, 30570, 1581, 66471, 49647, 11922, 160717, 29442, 5643, 114865, 82962, 95982, 132098, 22633, 22838, 94726, 54556, 28566, 205039, 162340, 33216, 16849, 35847, 221339, 94851, 26533, 71469, 1805, 3804, 12935, 45483, 71020, 36310, 65381, 192960, 34240, 35165, 59773, 1248, 46954, 155332, 96864, 4246, 388800, 16129, 57133, 74592, 44807, 442014, 38203, 42574, 80818, 91592, 26377, 36424, 65760, 977, 77387, 22628, 147610, 28018, 30561, 98454, 6969, 119628, 63648, 18170, 36854, 26601, 64018, 22027, 37279, 51395, 152934, 21153, 9430, 58760, 194742, 5330, 55115, 34158, 28917, 174111, 13171, 122326, 1526, 43896, 66094, 25325, 4234, 148354, 11450, 275, 18999, 112191, 44365, 22723, 68409, 8733, 57746, 96565, 75007, 14196, 108844, 29475, 88599, 177563, 100792, 106156, 86323, 93726, 14248, 135341, 194131, 40126, 47099, 14779, 8272, 39597, 95983, 171398, 65882, 28052, 10393, 47213, 40689, 22120, 72212, 106829, 34964, 109146, 753, 648, 21660, 30047, 17527, 181025, 5619, 145357, 4085, 216883, 9359, 186951, 24779, 53931, 24545, 36197, 223296, 62628, 168101, 4243, 107313, 30321, 26642, 13049, 51059, 31027, 107912, 807, 73550, 26551, 84369, 122422, 165872, 49754, 74213, 234264, 33151, 52014, 33100, 87183, 22365, 52500, 40013, 23302, 5652, 72723, 21404, 26107, 48434, 587, 94049, 168493, 96418, 32871, 70860, 31709, 25128, 443, 71597, 166253, 15670, 70994, 26341, 133675, 28280, 75491, 54756, 47955, 56028, 26182, 11952, 113272, 472197, 64640, 110753, 17919, 337, 50642, 22576, 142, 87371, 53391, 93210, 126694, 15285, 19642, 85667, 14148, 1506, 42092, 52962, 33243, 11970, 20734, 135843, 57044, 58880, 13002, 219134, 22876, 64754, 232519, 4257, 43120, 321573, 24799, 64526, 124728, 52579, 81472, 70831, 276848, 17403, 74359, 23021, 182101, 74597, 23744, 148267, 12055, 7976, 5349, 11772, 67540, 167347, 65318, 18720, 127832, 108238, 22828, 90233, 9987, 259080, 118185, 73209, 79270, 13775, 90100, 137742, 90799, 70569, 15699, 19961, 9087, 67475, 57872, 39731, 8810, 134897, 131868, 146849, 19898, 3334, 2281, 167061, 91073, 60356, 467742, 74712, 188, 53179, 137679, 92769, 29241, 9537, 132595, 80119, 1041, 88962, 5976, 40171, 44911, 102859, 139059, 104558, 98987, 47761, 19272, 71472, 113864, 175377, 73338, 10857, 23402, 23758, 1591, 139864, 5644, 4076, 118760, 16427, 134198, 18853, 20291, 100849, 37423, 22038, 36677, 19071, 195521, 57445, 11069, 31869, 55718, 66882, 148490, 44, 41296, 75242, 49704, 166810, 9906, 20943, 122258, 49112, 105667, 15969, 10344, 6408, 187694, 21399, 72742, 58970, 14867, 14376, 81889, 41856, 23225, 15042, 56993, 16074, 131389, 74276, 72407, 53875, 383108, 53597, 37363, 68993, 44854, 122548, 430927, 198279, 38430, 80409, 12245, 2981, 628, 2818, 17760, 37437, 238229, 7968, 46892, 2200, 3730, 34190, 65983, 37959, 112291, 87850, 70827, 6522, 20750, 73913, 111621, 41652, 19587, 2780, 58668, 25916, 85259, 18200, 168962, 95781, 42445, 102050, 7776, 57662, 103313, 47742, 96358, 41964, 66174, 100396, 29069, 204735, 19679, 27978, 7479, 40264, 22534, 61183, 36081, 107436, 58223, 14680, 23002, 101311, 24716, 124108, 12908, 5646, 31750, 40380, 14215, 232799, 102772, 14122, 96775, 61398, 50917, 12096, 149880, 67833, 598749, 124194, 155871, 49216, 790, 14677, 65319, 56917, 7440, 145744, 95701, 12206, 49405, 129269, 76199, 45732, 9767, 11058, 9047, 210885, 11051, 7392, 26307, 2130, 8132, 147526, 20802, 232698, 115660, 50060, 59789, 57344, 107623, 80343, 112676, 23291, 9866, 160971, 34032, 118291, 15719, 59730, 164911, 28975, 2659, 58046, 78480, 21854, 66209, 53863, 109085, 116045, 29021, 46481, 107552, 22130, 18764, 70254, 31272, 11300, 52460, 43933, 84738, 20721, 53869, 190840, 79673, 105300, 7561, 321817, 66924, 13940, 33281, 101046, 183181, 32176, 71878, 5678, 62924, 79535, 56646, 40303, 19559, 27703, 93042, 73368, 42187, 3670, 37376, 46440, 7023, 36816, 109628, 20680, 5940, 276440, 275233, 170848, 112093, 136996, 14984, 20226, 111441, 77693, 112960, 48577, 39370, 55707, 50314, 123404, 26570, 54281, 61372, 123391, 4857, 35928, 246740, 132507, 106646, 44241, 7196, 92258, 9825, 37688, 51197, 303141, 5590, 15476, 132986, 10955, 85782, 34486, 26696, 7991, 28813, 18858, 39546, 11703, 11365, 38185, 5716, 93555, 11925, 40121, 60002, 6985, 10976, 171384, 3887, 43394, 13337, 56346, 6381, 252336, 39573, 75042, 53711, 1028, 31781, 44295, 95925, 131713, 7214, 68125, 43571, 70954, 213234, 1628, 8760, 13391, 65485, 17320, 56038, 1710, 25248, 60803, 57399, 19839, 3870, 326, 281556, 50945, 72400, 21460, 316244, 75619, 56246, 98775, 481, 13513, 55765, 50427, 7388, 123519, 32929, 57908, 27124, 61316, 101097, 57467, 30228, 48792, 10788, 20402, 37318, 50526, 155730, 34456, 158065, 145305, 17832, 43733, 64052, 4506, 35072, 205355, 177028, 184004, 187081, 68616, 35938, 83703, 10367, 36892, 93186, 260137, 51934, 89970, 4985, 23445, 26755, 21558, 7948, 78741, 23376, 124405, 85594, 68596, 57536, 49351, 12619, 56593, 132668, 99924, 109728, 71844, 71935, 196018, 65464, 17617, 14987, 89701, 143773, 33997, 8687, 22701, 33258, 2914, 4436, 72108, 85610, 9671, 49067, 2327, 82988, 1361, 1672, 44033, 35777, 30269, 24057, 10605, 82236, 616, 15793, 13919, 47249, 112086, 116698, 9484, 80207, 90574, 33304, 68624, 93127, 56101, 42210, 160929, 4827, 38995, 38095, 4701, 125119, 5027, 33680, 9236, 231236, 14135, 87837, 23318, 70261, 78893, 30151, 81482, 14332, 1084, 74256, 27532, 46644, 79185, 3148, 62615, 6981, 55672, 31668, 36825, 1849, 14536, 37446, 14738, 23779, 43058, 162749, 72199, 1168, 21346, 5592, 85932, 85302, 9668, 18351, 57135, 150360, 2080, 228015, 77953, 34670, 119302, 151751, 31009, 106725, 84265, 45214, 59289, 74178, 113071, 263206, 111009, 4021, 44449, 188119, 192629, 123592, 392506, 292847, 114487, 12831, 205858, 9852, 20780, 79648, 75767, 357014, 97721, 18166, 21005, 67950, 33226, 204009, 16536, 2987, 11335, 66717, 144910, 47950, 17262, 55060, 15063, 2934, 51038, 26775, 178497, 66008, 3427, 49433, 128592, 20036, 157553, 63861, 3089, 23015, 51210, 28696, 35933, 49942, 71135, 231518, 99620, 17248, 21835, 176536, 20676, 16944, 38700, 165831, 233253, 295625, 36723, 13023, 52745, 10907, 19423, 67972, 125868, 95473, 82875, 1183, 108455, 52685, 33417, 64095, 21433, 52438, 33191, 127809, 44505, 211823, 7810, 2752, 95548, 162031, 7185, 91196, 47563, 61721, 33359, 17897, 23682, 42806, 178101, 22874, 49707, 199897, 75419, 82456, 8618, 11171, 79712, 116847, 18783, 44190, 46564, 5346, 59046, 95032, 7893, 14916, 3214, 26800, 24172, 121453, 34362, 10250, 17408, 18888, 4840, 68696, 22831, 13162, 36005, 32512, 14800, 62357, 41723, 45046, 27247, 37486, 5372, 2564, 34261, 298500, 66509, 133920, 89138, 31305, 117697, 19097, 108304, 81386, 84106, 23802, 46411, 63304, 946, 51417, 41777, 41041, 19501, 115864, 60743, 294354, 37955, 94165, 18116, 1156, 17937, 20645, 57114, 90804, 58042, 48643, 92288, 9861, 2557, 88546, 61333, 101008, 12853, 5148, 87856, 4152, 144503, 73841, 18718, 9789, 147565, 10846, 42085, 12789, 30223, 8993, 56352, 67203, 2448, 28215, 6052, 23540, 126319, 75933, 36689, 80235, 23231, 23561, 21383, 38800, 77548, 102798, 21234, 31468, 158608, 46188, 63960, 191679, 8051, 67014, 11185, 170078, 42186, 28827, 34777, 41930, 212079, 12421, 34750, 24111, 110344, 73918, 45171, 70826, 141949, 40063, 23979, 24254, 37309, 26724, 27179, 24718, 83648, 54938, 14591, 17425, 29525, 102675, 48975, 48654, 12316, 8929, 60640, 41709, 50168, 63264, 89812, 50716, 48632, 38755, 138583, 160123, 55579, 71829, 24230, 233277, 46322, 39650, 166388, 34718, 24108, 98252, 7031, 106695, 62498, 18258, 35062, 217827, 78731, 34824, 33354, 19520, 60852, 2432, 60224, 8587, 2836, 62955, 702, 20227, 42285, 40560, 95592, 62486, 11094, 53035, 143291, 18842, 46177, 77994, 1770, 9657, 107422, 172915, 32655, 128716, 25886, 25164, 156740, 119928, 165875, 85817, 11007, 89110, 33956, 12652, 65156, 180266, 8494, 36889, 19958, 20955, 96, 1264, 118288, 135769, 44754, 86671, 5632, 19026, 168220, 289120, 33569, 93821, 66144, 70635, 7687, 5642, 2714, 55445, 56636, 71545, 184182, 93133, 7332, 37389, 12643, 52315, 22729, 11014, 158742, 17050, 152889, 50178, 34601, 41945, 52136, 9948, 26914, 63548, 95721, 115951, 40759, 8960, 158258, 38938, 49232, 48325, 42234, 81523, 253019, 66128, 40978, 20048, 238048, 38760, 62928, 122560, 118532, 43687, 137472, 163689, 26680, 9878, 17448, 51035, 16211, 60834, 36749, 29178, 14241, 59868, 150086, 2305, 26477, 42422, 34342, 165341, 83279, 33894, 14257, 29928, 12743, 13957, 125571, 89134, 66712, 10952, 16507, 147839, 30146, 7249, 16565, 45399, 39874, 114565, 215780, 31990, 230881, 171477, 102, 196546, 44538, 10880, 84948, 281705, 86651, 10617, 31395, 2342, 453658, 43569, 60561, 132901, 21845, 17727, 58556, 258242, 22262, 58728, 4008, 77997, 11806, 37431, 30599, 81375, 109137, 185787, 114085, 217292, 97453, 169085, 30593, 60212, 11544, 102056, 65580, 2384, 91655, 4855, 95725, 7295, 157994, 16228, 20669, 53276, 141590, 105246, 17334, 25440, 76067, 17967, 39321, 38911, 11362, 28559, 63807, 21627, 26468, 85816, 40120, 1025, 15234, 58319, 69516, 66512, 124548, 75845, 78873, 22137, 46681, 51242, 85683, 32909, 76747, 35555, 43396, 101465, 1765, 73094, 1077, 2962, 39028, 66777, 57831, 42048, 15828, 13962, 36041, 63657, 52412, 5242, 58846, 2141, 5506, 219012, 134451, 3936, 182230, 17558, 17153, 152237, 22621, 49377, 170216, 35257, 68233, 65374, 6510, 11126, 212151, 7184, 2480, 22517, 3437, 33073, 30156, 16557, 3768, 55067, 86829, 91e3, 12350, 148650, 66017, 79424, 70885, 49066, 28250, 21369, 51213, 34533, 11510, 3258, 18176, 18465, 84413, 6315, 36411, 163765, 4346, 356, 107618, 598, 13727, 285026, 162695, 8749, 14583, 7132, 63521, 184253, 32378, 25991, 5604, 30961, 53675, 4874, 84693, 5086, 34811, 26978, 56564, 7904, 33519, 51221, 113942, 69253, 6664, 125563, 22055, 220680, 102008, 742, 51930, 19494, 176108, 44424, 35123, 13025, 75685, 11759, 74335, 22250, 181453, 131147, 16984, 132115, 154311, 11991, 76452, 52609, 85351, 196, 30969, 9198, 74919, 2529, 56838, 71779, 29187, 116304, 3504, 62330, 41190, 86153, 28393, 254926, 104228, 105189, 13264, 84359, 3574, 12415, 8534, 57147, 10175, 188174, 59504, 60932, 66318, 16407, 107921, 17638, 99103, 49278, 28403, 39786, 145865, 8462, 3558, 43406, 142271, 29139, 21989, 36552, 93955, 72365, 7176, 13556, 106185, 37957, 321774, 17782, 129017, 51154, 27938, 24952, 1935, 39366, 2791, 33489, 41582, 56078, 24558, 9311, 5449, 218786, 27808, 190429, 68013, 36020, 86003, 29735, 3404, 87348, 119357, 115714, 2324, 86796, 81973, 40992, 43376, 93621, 28784, 16808, 36367, 2517, 2909, 191926, 24978, 55303, 53308, 205724, 60068, 3098, 21375, 64784, 23949, 26579, 63121, 12319, 80145, 39967, 97861, 6757, 70143, 67642, 37082, 34698, 69140, 122883, 46151, 62187, 80934, 429, 19437, 135071, 137885, 222647, 13331, 154065, 327, 61778, 74257, 40116, 37493, 14855, 85079, 237641, 42342, 102164, 199965, 71204, 4662, 29368, 5042, 113914, 122214, 8955, 13149, 102503, 43173, 5659, 163787, 69003, 307084, 63392, 171080, 21390, 81918, 86666, 36622, 24126, 28887, 5736, 28054, 207170, 163428, 79891, 346467, 95363, 38980, 111806, 80828, 9200, 19288, 294896, 114468, 87405, 111715, 141705, 7015, 72754, 68463, 48738, 243147, 33397, 101210, 37051, 98801, 82847, 20397, 4940, 185559, 18716, 54718, 83491, 11725, 40803, 1128, 12128, 23060, 5174, 7745, 67007, 46701, 1571, 27807, 180186, 256996, 18975, 16837, 7877, 212758, 250379, 15440, 87954, 57755, 24719, 124057, 83461, 258, 50864, 8874, 29038, 71289, 31627, 15429, 9005, 4061, 113851, 107716, 82819, 13651, 79656, 117851, 17539, 111446, 12938, 39724, 190787, 4352, 15402, 21070, 62708, 8539, 23777, 73853, 13552, 38810, 86117, 16285, 56400, 1718, 75342, 142863, 29033, 378, 110113, 180321, 32586, 23606, 26393, 160984, 207987, 23783, 8406, 16904, 24596, 47274, 11693, 46539, 60524, 78595, 48423, 31718, 20170, 9009, 146268, 15183, 191060, 172765, 1349, 138436, 37365, 10970, 40509, 225817, 20021, 70394, 152138, 21541, 66559, 66544, 89352, 2725, 17258, 91345, 7313, 3815, 115868, 8660, 40362, 4071, 103524, 39388, 118275, 21950, 6549, 38226, 32754, 209574, 29201, 43495, 18028, 20296, 40597, 18370, 47520, 202450, 24134, 2219, 8195, 69545, 38041, 136934, 46374, 19041, 159811, 84865, 58620, 846, 98749, 13569, 30714, 97246, 32186, 4479, 27355, 92973, 35214, 151491, 75963, 37631, 1561, 27200, 238083, 23182, 60756, 12291, 25766, 39355, 102333, 87362, 65741, 59906, 19538, 201575, 48772, 102938, 24438, 292580, 39964, 66366, 9004, 61379, 50548, 37622, 38732, 28379, 68180, 76622, 17488, 69849, 5963, 7219, 48143, 43413, 55358, 540, 58691, 29506, 19245, 52193, 48621, 5518, 13048, 118625, 44755, 191081, 42061, 89197, 2259, 60665, 66994, 71210, 51232, 3585, 142096, 55024, 7892, 8345, 58653, 463307, 65658, 64319, 137941, 136323, 53499, 12746, 43492, 6978, 95163, 29925, 60175, 5128, 7352, 41463, 184756, 121146, 20473, 18426, 4598, 5309, 54580, 14277, 121151, 10691, 56711, 43880, 63409, 76682, 11830, 172218, 264898, 32632, 66536, 81062, 31649, 25788, 92774, 60222, 11100, 63159, 9432, 224657, 25240, 53613, 152, 138620, 163829, 2397, 85345, 12501, 37507, 64932, 38575, 43522, 65789, 80198, 78796, 35226, 3851, 108891, 73311, 3060, 28391, 93671, 39663, 46142, 30982, 66041, 37281, 68157, 26553, 71872, 81142, 211527, 39747, 118119, 22695, 2859, 11066, 20232, 168911, 7933, 197005, 17066, 111071, 44434, 133994, 120798, 12766, 227798, 45756, 132852, 29917, 36076, 55352, 65281, 129800, 41958, 18944, 84678, 18580, 168093, 132621, 39997, 54092, 27740, 32354, 3770, 114118, 103242, 43918, 15899, 18574, 145944, 3190, 123469, 219903, 24169, 100571, 62403, 16776, 92779, 14535, 17168, 16475, 14304, 37231, 1712, 28218, 242754, 61688, 28980, 1318, 51359, 222657, 99200, 67989, 31772, 23932, 35351, 201251, 49041, 27306, 19128, 40135, 3986, 77333, 19649, 120683, 151927, 21081, 7076, 78375, 77501, 101599, 8011, 89585, 96715, 58179, 5378, 102138, 106793, 26051, 217276, 4197, 16297, 27014, 46721, 13322, 22806, 5278, 29629, 70632, 9647, 71519, 58818, 40603, 128530, 8903, 36770, 56900, 31483, 26935, 43845, 34265, 34920, 87658, 6114, 84767, 64250, 47318, 50720, 19264, 162514, 33357, 13117, 6705, 46696, 75032, 71054, 87004, 42035, 69138, 11903, 99854, 102328, 19611, 34525, 69312, 6431, 49842, 101600, 133178, 108751, 41829, 89939, 225664, 48916, 99556, 9195, 130387, 5960, 36857, 116724, 53518, 94002, 39077, 53996, 6945, 22261, 64291, 8314, 152785, 57588, 16522, 9091, 5048, 87671, 35441, 39509, 1945, 12423, 158923, 178413, 37549, 14095, 1475, 73188, 62878, 4819, 24012, 68534, 42606, 4010, 120809, 57497, 59564, 101758, 103718, 32701, 80116, 12345, 95834, 46918, 21468, 53213, 15665, 31200, 3867, 5140, 96013, 250744, 21016, 10069, 13968, 35449, 180829, 27683, 39704, 59956, 22893, 3115, 26293, 32785, 75934, 62445, 141162, 62720, 2018, 83638, 19949, 114012, 95006, 3330, 99829, 130935, 309272, 9565, 55874, 121727, 37017, 23586, 319858, 40970, 27602, 8625, 112329, 61060, 100088, 118525, 25922, 16232, 1907, 60671, 51583, 44553, 80993, 5262, 94679, 8676, 940, 20736, 11823, 3020, 16476, 12340, 152600, 97416, 3703, 25744, 66826, 16245, 16876, 46446, 84798, 74227, 176020, 45192, 61955, 75496, 23946, 23626, 40372, 26036, 6149, 11822, 30582, 16541, 41914, 82385, 232823, 40921, 80773, 14930, 3631, 7517, 39619, 4348, 36180, 126106, 138939, 62611, 1477, 113512, 47321, 25052, 14546, 118881, 29060, 23589, 128322, 36795, 18401, 137921, 104699, 267929, 36194, 172791, 18113, 4766, 188215, 30083, 332586, 94089, 5805, 77909, 22194, 68234, 154976, 43220, 40660, 70001, 184893, 138095, 11128, 103010, 22663, 5108, 212615, 8485, 5565, 49222, 54614, 26530, 42639, 16319, 55062, 152662, 105595, 21114, 22216, 10294, 68158, 10436, 86950, 7206, 62115, 3977, 3657, 59874, 456, 118617, 18156, 106663, 112229, 80992, 17442, 8217, 55551, 5133, 34344, 251927, 51153, 39364, 201321, 7816, 66803, 23057, 156724, 145664, 14276, 95705, 979, 2796, 6875, 13429, 212525, 50602, 26276, 28284, 3424, 19465, 52397, 46963, 31420, 51399, 206476, 92317, 48851, 637, 100820, 83349, 10317, 60227, 21972, 6908, 282439, 32857, 224767, 95629, 83882, 42106, 87338, 69757, 29840, 68709, 37665, 45244, 114577, 49188, 175943, 54009, 186746, 106158, 70168, 3358, 234002, 50555, 9221, 129338, 9562, 20118, 32923, 78479, 118280, 65752, 4977, 10474, 102174, 60947, 129006, 10570, 83451, 8598, 8078, 159367, 123785, 80438, 16742, 5905, 5281, 181513, 42402, 6977, 163136, 93179, 42191, 14968, 50421, 112401, 105440, 33456, 57347, 121611, 4221, 94954, 36517, 24046, 27796, 6255, 33394, 72990, 135408, 116627, 1233, 57874, 25654, 95419, 68156, 401399, 313338, 55208, 45573, 93124, 119251, 47200, 38196, 11909, 130667, 45391, 73904, 64964, 167846, 4137, 115606, 52036, 62214, 7969, 160925, 7187, 1132, 134835, 40309, 73195, 64494, 80472, 444841, 61111, 26500, 45323, 40743, 53625, 52797, 22659, 15631, 29739, 36706, 28841, 39147, 102836, 26794, 10536, 14845, 87305, 45874, 12241, 127587, 83833, 57183, 79722, 30844, 41304, 84655, 20825, 92500, 3722, 25655, 27811, 10157, 81634, 31362, 34088, 92487, 70123, 22190, 185100, 72658, 139035, 192523, 88241, 2078, 230490, 44528, 85638, 100198, 22088, 29982, 291233, 241062, 13865, 4445, 137791, 37835, 107218, 31726, 19718, 38234, 72528, 23046, 19177, 66695, 5109, 17251, 28077, 5617, 21554, 47839, 72425, 133825, 1486, 73065, 181275, 141508, 21768, 62971, 63082, 2512, 34200, 9904, 120309, 6392, 91243, 68416, 268253, 41199, 116757, 138551, 185526, 41246, 28986, 4093, 19057, 17295, 4148, 245766, 122360, 35356, 112075, 20301, 75441, 10998, 7977, 19769, 62922, 937, 63547, 100196, 26427, 157820, 20983, 236696, 22935, 8140, 90315, 156004, 47204, 140973, 7726, 45097, 52725, 22636, 23436, 257282, 105247, 522, 88389, 216031, 202204, 46812, 211666, 19693, 68828, 81691, 45925, 11256, 30292, 372, 5236, 167826, 88328, 232776, 151611, 5360, 82104, 18841, 80393, 25465, 18285, 20320, 72377, 31730, 33160, 45803, 38715, 27705, 37379, 24163, 18360, 103586, 4015, 32305, 269494, 91252, 20080, 36567, 54650, 7797, 57073, 12650, 31164, 42209, 6375, 261663, 105528, 81661, 106002, 2800, 5375, 17247, 43151, 4442, 15727, 194619, 100855, 144898, 62320, 78465, 39929, 16454, 1967, 28311, 61363, 17219, 9395, 8745, 121445, 76939, 80385, 162380, 22009, 54191, 44248, 16299, 122830, 48151, 74429, 78291, 64755, 14238, 44966, 2511, 17712, 67954, 93583, 829, 105899, 49935, 84750, 11591, 33185, 85447, 42717, 27409, 208542, 28965, 62052, 52525, 5597, 25694, 65594, 16343, 63224, 276188, 12475, 9331, 127507, 38522, 57287, 24128, 133161, 79723, 105548, 133695, 48917, 27558, 43278, 46520, 13778, 141954, 110785, 83366, 17715, 46317, 105763, 66298, 147013, 41086, 94180, 16478, 220447, 44611, 730, 19722, 78975, 117889, 125643, 26254, 16574, 18480, 65006, 15806, 38549, 246418, 46052, 36056, 8440, 34984, 30170, 3163, 59800, 4458, 115442, 4283, 41970, 33507, 104078, 1653, 22, 121158, 276486, 3655, 6338, 24048, 133421, 23641, 2161, 24422, 36006, 8086, 10675, 181474, 12307, 29514, 59143, 14729, 52509, 87128, 122470, 19446, 80852, 33314, 24573, 119864, 14237, 9652, 57779, 6612, 51851, 15284, 98871, 90581, 124466, 156831, 21190, 22015, 71380, 161906, 87247, 69201, 18392, 17908, 108470, 72962, 40719, 14338, 17911, 95260, 43339, 20610, 78916, 20710, 72451, 11315, 31448, 17263, 58853, 178878, 48111, 116002, 45497, 80506, 82605, 85880, 36300, 121755, 25215, 36118, 301929, 88728, 405223, 276136, 553, 34704, 212438, 49970, 78329, 922, 20711, 25036, 257130, 38295, 145369, 18128, 15385, 30829, 55656, 48345, 8012, 3561, 28004, 122041, 192900, 58338, 112508, 41085, 29976, 87040, 47117, 23905, 4336, 92061, 138880, 97407, 42083, 172121, 6256, 25192, 172671, 5, 93568, 1420, 12677, 31605, 56743, 40620, 6015, 78415, 231077, 31298, 80026, 13902, 19048, 24924, 170586, 32955, 176119, 87859, 36731, 6773, 27711, 24658, 26475, 115216, 133207, 93250, 95820, 88522, 8317, 5714, 124047, 55219, 86860, 19677, 23961, 22928, 162209, 8904, 225992, 359835, 56084, 96201, 29392, 96558, 86071, 93643, 55114, 13347, 8183, 95129, 82012, 2017, 123336, 34219, 115554, 157159, 47747, 101684, 41008, 18735, 193781, 104151, 226906, 7552, 179874, 124113, 31159, 21162, 44010, 14771, 51268, 166128, 31382, 73124, 77438, 92830, 205709, 12113, 1292, 38937, 13114, 1334, 2118, 15597, 69581, 14449, 21934, 76618, 48728, 67038, 14967, 51495, 24243, 87736, 147249, 26720, 11119, 46063, 43749, 5843, 44147, 152629, 133428, 65703, 14269, 45604, 57982, 28672, 55616, 45957, 8438, 95433, 37698, 220862, 132034, 39456, 61870, 4161, 26501, 73560, 56418, 9845, 4654, 20916, 10456, 88920, 119358, 9015, 65931, 96507, 48029, 38534, 21676, 109081, 43078, 34943, 25089, 6131, 28766, 23665, 5477, 10255, 16695, 67, 45778, 42443, 42770, 29534, 23733, 100513, 62617, 42630, 48746, 14191, 43753, 50295, 26007, 8792, 57243, 43119, 54725, 164253, 58250, 112304, 131796, 25165, 4651, 3188, 24831, 47748, 3705, 19540, 13211, 102095, 5593, 18699, 23666, 32005, 117571, 33541, 60584, 74573, 86311, 99443, 25172, 27222, 168938, 7143, 11853, 53560, 18834, 19960, 86522, 28217, 53266, 117700, 72989, 34323, 18721, 66450, 34346, 74056, 47217, 202002, 46269, 9429, 68582, 75458, 37823, 82843, 96652, 32549, 145144, 27958, 19820, 158086, 31955, 201406, 135379, 31207, 192545, 12950, 51704, 9094, 248263, 76147, 64028, 110009, 79407, 89345, 99284, 223492, 47966, 26848, 15359, 201137, 2861, 110507, 71231, 72297, 31851, 118777, 71039, 151051, 240855, 16333, 50766, 14727, 7939, 4149, 80908, 418780, 88378, 59276, 1327, 7284, 38576, 79814, 65820, 42199, 84860, 49574, 62596, 12396, 70598, 40117, 8648, 7994, 16836, 7630, 14047, 359699, 106878, 525, 29037, 28064, 13380, 11675, 50669, 74216, 103539, 180314, 27449, 56299, 172344, 19274, 7301, 246099, 32043, 19422, 36506, 129317, 6806, 30140, 4614, 46639, 66926, 932, 86600, 6322, 27847, 233103, 10541, 39025, 34887, 3517, 12972, 26220, 2031, 66561, 115015, 48658, 47596, 12714, 33845, 3893, 16165, 35237, 89983, 14769, 11962, 147224, 47018, 29977, 27979, 5552, 82338, 86023, 131368, 1218, 24853, 237840, 132193, 15455, 40873, 3668, 65351, 53388, 15229, 59889, 272245, 47934, 11858, 34347, 18038, 90853, 86981, 300602, 19343, 114181, 29362, 84921, 6095, 106059, 79472, 38015, 1206, 48741, 6208, 8e4, 21916, 17423, 6002, 108083, 24479, 34931, 56661, 9511, 26995, 100694, 163853, 35997, 81254, 58321, 18919, 171890, 86877, 91341, 74503, 70477, 53412, 7027, 59281, 39892, 131302, 5864, 15947, 61301, 67466, 162369, 47956, 27874, 35624, 282324, 21270, 111847, 102548, 41482, 30955, 116737, 28264, 8592, 55458, 22301, 75090, 29821, 30697, 51709, 3041, 19208, 8038, 24634, 30467, 87509, 126428, 19389, 18814, 152686, 20701, 83474, 45832, 80891, 105808, 11378, 153223, 120770, 98186, 150633, 49838, 9141, 12755, 30962, 5260, 74490, 21256, 31678, 65062, 33326, 289838, 187831, 20595, 89768, 2805, 58535, 10844, 70085, 12090, 2451, 138068, 98544, 24461, 4511, 6754, 41684, 28203, 3383, 65355, 82833, 30161, 83924, 234361, 128424, 28921, 222594, 33975, 125491, 34069, 11508, 67464, 144226, 41850, 98703, 34371, 7901, 21254, 38398, 65651, 23549, 53883, 213340, 123269, 12028, 71764, 177701, 28758, 2623, 68395, 11549, 15232, 68603, 9660, 63116, 36079, 57093, 31198, 20475, 48467, 89984, 35619, 186847, 107469, 31389, 43631, 73867, 41949, 68841, 114250, 1605, 30564, 63403, 17588, 27680, 99533, 12641, 70325, 50428, 73426, 78379, 11855, 91651, 72081, 91720, 60198, 15743, 12065, 83398, 140046, 6761, 46598, 45900, 5068, 886, 62448, 148968, 37347, 19405, 9680, 15819, 43496, 63370, 75667, 163700, 37639, 3633, 22774, 34341, 183131, 134335, 37200, 23915, 7054, 14194, 12970, 26438, 13350, 285521, 25594, 8219, 104410, 91039, 168804, 138480, 149734, 15907, 33818, 61132, 60082, 4622, 110187, 56736, 13551, 73571, 3945, 73463, 65498, 17758, 263266, 17593, 2710, 27585, 54469, 38200, 45367, 63754, 28881, 3473, 12791, 98287, 31895, 65787, 4463, 94536, 24951, 36332, 59901, 28803, 52130, 86403, 7668, 181822, 74831, 18977, 9850, 177206, 145485, 109798, 7292, 31421, 26280, 77211, 58511, 12507, 127004, 11113, 147, 8729, 56208, 43066, 79926, 129937, 31345, 83947, 39915, 46146, 98763, 42566, 1337, 13192, 18323, 105163, 80570, 117753, 16555, 72883, 11077, 159438, 40764, 70933, 83329, 26066, 12276, 72059, 21655, 173836, 126713, 69454, 153482, 91585, 70644, 102558, 110483, 6764, 127864, 190133, 3961, 101798, 20945, 71138, 82402, 90884, 69669, 44753, 923, 16939, 59700, 164258, 25969, 27082, 31399, 43846, 6306, 246093, 51342, 6153, 151581, 202801, 182731, 56475, 162188, 89426, 141356, 14355, 121815, 27536, 28023, 65257, 77523, 106668, 127314, 24947, 12790, 38796, 169698, 23555, 10725, 44573, 183083, 42088, 62716, 43265, 105958, 32050, 44067, 50118, 1668, 3874, 6243, 318411, 16599, 1691, 94999, 52378, 28671, 216728, 123258, 2059, 34969, 69225, 5913, 136280, 171443, 141515, 91662, 22175, 135282, 80020, 92270, 1663, 4808, 4482, 3495, 34691, 5226, 109830, 108512, 17342, 107488, 11606, 123190, 100247, 29666, 146527, 113014, 15794, 30894, 13224, 39585, 243192, 22351, 9903, 7836, 47699, 11078, 25468, 122291, 48821, 26780, 122679, 75521, 81450, 630, 4895, 92900, 55074, 74293, 17441, 3563, 111657, 103102, 51613, 12318, 52370, 36191, 68245, 34269, 40445, 41354, 122901, 168604, 182500, 62012, 42557, 11259, 24428, 115113, 86345, 12362, 3909, 78430, 86852, 134602, 20459, 47853, 93879, 22577, 7659, 3688, 38555, 13349, 17381, 56715, 91639, 12493, 10895, 92438, 3142, 37057, 28928, 2004, 36427, 32268, 34222, 209974, 10432, 67436, 41989, 173518, 107930, 27079, 62729, 30908, 55558, 5828, 45031, 14902, 53546, 8204, 144263, 60255, 14520, 88212, 86582, 109589, 69356, 8064, 47449, 8505, 66558, 16886, 4844, 52817, 111260, 215129, 12941, 91118, 650, 20770, 6273, 73089, 40618, 62790, 2873, 35002, 14023, 97208, 19386, 102646, 36993, 143736, 135457, 35385, 113601, 17893, 32627, 84439, 100619, 56016, 6581, 57264, 172160, 45452, 111710, 203627, 70131, 24100, 322787, 1996, 35665, 70078, 22358, 90922, 83658, 4097, 63200, 58499, 14542, 99153, 52159, 6615, 12414, 63415, 31986, 16823, 1579, 65405, 137809, 8841, 16898, 48082, 259, 33014, 42375, 12260, 179850, 73667, 91389, 98882, 29532, 17311, 326251, 41092, 5928, 20742, 44964, 48019, 43505, 9317, 49265, 6643, 192712, 48424, 163487, 19861, 20113, 70848, 31928, 105333, 23685, 78563, 14638, 54755, 7158, 24142, 44018, 20774, 125255, 20331, 24280, 10163, 1285, 2336, 39851, 4299, 117269, 46714, 63816, 87779, 159624, 11731, 9971, 990, 137317, 108831, 50994, 74554, 162680, 23640, 131597, 146962, 170620, 34829, 91205, 21184, 1913, 63616, 18427, 93136, 156592, 17519, 67565, 115882, 138220, 78622, 88535, 18115, 2711, 33554, 109492, 54298, 971, 24914, 25863, 36363, 45715, 27099, 194995, 14299, 178181, 111488, 72395, 322385, 157719, 130787, 11897, 81843, 83999, 11369, 49280, 118604, 40922, 61332, 110343, 53407, 75639, 40582, 300440, 54722, 25637, 13694, 48248, 48278, 194521, 56203, 52779, 48783, 72627, 10953, 376, 16733, 280238, 26351, 230789, 15132, 25168, 137270, 3588, 63704, 73376, 94031, 74284, 19443, 159557, 9697, 39901, 13351, 119050, 15406, 146455, 3460, 29556, 75195, 37673, 102524, 92329, 47289, 98413, 15311, 100684, 56345, 7116, 95480, 11590, 7200, 167, 23610, 58426, 17730, 136656, 27944, 53151, 2701, 8824, 103124, 3017, 90744, 113588, 53216, 79736, 65940, 26931, 498, 29568, 80540, 143543, 21292, 1740, 59268, 16561, 180816, 42323, 50174, 40890, 52866, 10703, 57169, 4700, 17191, 4424, 93511, 49698, 166650, 26972, 48631, 165169, 82879, 69326, 202970, 4007, 2376, 231325, 139592, 22119, 62851, 37504, 68816, 58345, 67398, 186643, 43331, 277416, 53749, 15746, 23102, 17432, 4793, 151138, 48822, 54265, 48203, 198688, 14305, 54287, 2291, 18018, 113378, 123260, 7180, 97549, 87027, 120085, 2920, 76080, 8190, 102005, 5641, 64580, 14955, 59802, 54028, 58884, 19367, 81779, 412567, 85957, 97053, 103637, 78871, 29364, 27637, 141728, 4767, 30686, 112738, 130146, 42745, 12730, 105040, 14844, 232, 210944, 36581, 152317, 135543, 29744, 3129, 55647, 58149, 46319, 27265, 17499, 28005, 59948, 7170, 34138, 5702, 293047, 110892, 408, 91760, 218674, 18469, 46095, 81403, 14389, 4610, 35672, 73060, 11006, 74848, 104820, 118143, 190357, 20043, 105358, 141735, 5115, 27093, 45924, 123073, 52599, 29433, 9616, 238350, 78610, 24851, 58858, 26769, 31969, 24613, 18294, 4982, 32735, 39639, 143563, 112073, 202205, 12567, 4873, 88601, 44897, 81503, 101648, 81362, 34662, 85277, 17574, 48173, 21435, 221188, 40215, 39576, 80786, 26544, 64668, 81841, 10731, 37733, 247986, 149188, 127703, 495, 18382, 54388, 72446, 43071, 30974, 198723, 89608, 41360, 190, 33045, 8386, 31658, 19992, 237838, 119015, 137622, 50890, 100913, 6460, 116233, 267230, 26621, 104129, 65114, 14190, 41542, 14888, 85962, 23342, 23041, 26453, 43725, 71809, 45186, 4770, 46452, 53894, 56616, 221286, 18973, 9038, 109299, 55365, 19366, 26863, 18808, 60909, 69353, 41738, 83463, 12100, 68561, 72860, 3980, 13796, 49340, 12332, 31311, 27418, 4255, 53430, 18976, 45523, 510, 14224, 30477, 26581, 4530, 3651, 101663, 139840, 22709, 150861, 31996, 63923, 120623, 262522, 3076, 10528, 2929, 14672, 130238, 18087, 9816, 121894, 100308, 25085, 55111, 14565, 18952, 53293, 2042, 369988, 23674, 61789, 133529, 28783, 108293, 35477, 47119, 36448, 71049, 40015, 33055, 78598, 198442, 1833, 159937, 40654, 77444, 189245, 113153, 8621, 18599, 38553, 35223, 166072, 2375, 11659, 21786, 89523, 6032, 12116, 63046, 159398, 18454, 3678, 32521, 47626, 11411, 103527, 38896, 42946, 15696, 26370, 10185, 8413, 37080, 165583, 4331, 63555, 14907, 72220, 50056, 6623, 62236, 36565, 49783, 10049, 17503, 100581, 55951, 146244, 24724, 9626, 17969, 25524, 109300, 173965, 99994, 101056, 46459, 43647, 53737, 277968, 8347, 123521, 74858, 33829, 44762, 77574, 877, 81377, 222525, 123532, 30602, 43881, 53145, 2973, 16284, 81940, 61281, 127044, 63620, 9875, 14756, 114829, 19032, 9202, 52759, 119141, 23928, 120551, 19607, 3599, 33401, 76821, 73233, 117430, 39968, 36539, 7071, 5446, 121735, 194059, 15206, 45283, 6706, 15603, 65615, 1207, 165723, 92275, 34773, 104447, 8396, 32353, 205240, 164323, 13600, 60555, 79205, 25532, 22907, 33410, 57480, 107111, 69630, 32137, 47832, 70913, 33161, 20321, 2371, 117348, 10714, 86246, 1625, 11763, 17900, 268, 78457, 99175, 97940, 101092, 86660, 32221, 14041, 128504, 125080, 53744, 124263, 31017, 13897, 403, 31859, 21964, 5633, 111630, 5547, 77329, 17961, 18241, 84995, 25984, 12983, 67491, 62168, 47262, 5241, 297, 51191, 7351, 8967, 147212, 82060, 16821, 782, 11033, 82431, 62957, 5026, 43459, 77963, 203477, 53528, 6247, 191852, 87774, 74164, 215654, 13467, 1522, 219964, 28589, 244104, 16242, 117821, 67725, 72570, 156792, 17186, 15979, 26990, 44128, 193014, 35276, 57125, 16212, 166451, 68017, 6905, 77608, 16364, 53777, 75921, 76426, 37975, 26203, 269296, 64099, 84122, 12077, 38533, 830, 4407, 20139, 963, 43028, 38902, 42911, 37503, 83343, 85045, 16979, 1165, 60835, 137387, 58380, 86990, 110066, 134540, 56331, 193845, 81238, 17922, 163093, 38744, 110641, 12502, 56404, 34862, 26865, 125964, 12965, 111648, 25547, 7771, 27196, 136980, 9555, 29551, 107158, 57885, 18831, 37705, 35505, 101742, 13970, 102109, 62548, 124657, 23328, 11124, 89592, 146376, 248050, 6241, 22033, 18337, 80685, 29898, 11908, 216623, 67721, 106162, 146610, 21377, 15085, 91552, 42041, 62560, 122532, 125336, 102365, 121537, 142559, 29693, 223919, 11515, 110495, 18776, 22494, 5895, 185059, 103592, 229351, 51220, 100102, 37027, 257855, 29359, 54123, 36066, 106493, 12244, 79258, 32002, 432, 56205, 94836, 90182, 6726, 14762, 29391, 48938, 26864, 38083, 60364, 3310, 60192, 14766, 205567, 57504, 110760, 22649, 24666, 46333, 21517, 3430, 13135, 28873, 27052, 158809, 11597, 20529, 6695, 23138, 22960, 37137, 45574, 6545, 305877, 43423, 26153, 24769, 59844, 14501, 10430, 134352, 56169, 13213, 103432, 49523, 35181, 13435, 12408, 129475, 64620, 230854, 77390, 51990, 15653, 83248, 33466, 44571, 117828, 51481, 2187, 10559, 68019, 18021, 54895, 48247, 18354, 33737, 4554, 108595, 37288, 39767, 116707, 9175, 3726, 108877, 21616, 83684, 49862, 1938, 8543, 276466, 20134, 108498, 48770, 102254, 31914, 131520, 185291, 100559, 51890, 209, 19526, 76471, 50544, 71814, 99351, 8172, 198526, 28816, 20419, 9109, 98389, 136777, 76479, 75596, 30635, 165417, 48216, 120220, 25955, 211071, 39314, 24308, 32164, 2559, 146280, 43403, 9233, 17947, 90585, 1786, 86920, 125662, 2457, 64741, 32152, 32918, 122882, 78538, 44001, 31723, 56426, 23375, 103172, 88177, 145697, 52506, 49319, 68016, 31664, 41488, 18486, 110400, 7030, 28241, 986, 109199, 19900, 42147, 56864, 65287, 49183, 7858, 24e3, 30453, 840, 16673, 25907, 68916, 89927, 6309, 158335, 36407, 199737, 130464, 13137, 59603, 201778, 195292, 21015, 42466, 179062, 172561, 89492, 11075, 180407, 31868, 72493, 20998, 60217, 9865, 19530, 39274, 130266, 54539, 21623, 12535, 13505, 40641, 73375, 4087, 85633, 2153, 3117, 70680, 55788, 92096, 47509, 98493, 37490, 271936, 151475, 3032, 16171, 96642, 34106, 78425, 125761, 19591, 3366, 19316, 54508, 24183, 50786, 194248, 91528, 33253, 34622, 108355, 41741, 705, 3814, 3883, 108929, 13203, 67831, 10142, 59754, 68208, 29128, 84820, 56880, 38794, 24972, 48571, 40821, 40476, 18137, 164254, 24064, 236309, 79181, 11282, 395, 39169, 2013, 51587, 28551, 9645, 701, 109513, 115899, 113566, 12762, 62045, 58322, 103726, 41343, 40866, 244102, 143816, 2490, 70346, 40973, 52618, 15412, 30720, 104315, 38917, 42027, 93676, 17513, 107418, 20706, 123890, 13399, 97727, 24044, 87962, 65606, 44250, 98044, 65276, 74790, 101473, 19350, 91570, 1326, 87790, 172042, 7577, 100813, 86896, 85891, 41512, 108130, 27794, 14875, 71431, 12835, 156250, 58135, 3759, 22476, 42176, 115873, 34686, 56523, 73643, 108505, 51491, 20838, 12721, 32863, 45700, 29496, 13700, 34294, 55360, 29206, 155942, 123812, 7706, 163234, 203, 132720, 49358, 144431, 8130, 175788, 35818, 3270, 76832, 25710, 54095, 97274, 28779, 94621, 74396, 19092, 128242, 58067, 20885, 14670, 93255, 15107, 63291, 23654, 126900, 129421, 59294, 262659, 9798, 3251, 67344, 28600, 44629, 50672, 29072, 26999, 31526, 23183, 49175, 165843, 175455, 17282, 175411, 32022, 45989, 30298, 90690, 78118, 83156, 23749, 35636, 31317, 7069, 80381, 94561, 133756, 14960, 97404, 6138, 41065, 78041, 32843, 16601, 34123, 9559, 146529, 123377, 96395, 54441, 42012, 84257, 123541, 10745, 22139, 106459, 11720, 150883, 172651, 154996, 110538, 4728, 53447, 25704, 2009, 71152, 119354, 21166, 66604, 1429, 216162, 8637, 122250, 63520, 27180, 29172, 36124, 276428, 107787, 77184, 4680, 14952, 104903, 24418, 14793, 51561, 52931, 8371, 26342, 48526, 7118, 92066, 67280, 40653, 8847, 34597, 105438, 14198, 50163, 61188, 146286, 50315, 41205, 170829, 161496, 585, 197359, 95056, 1687, 365794, 91349, 48507, 5804, 49263, 5146, 104902, 96365, 117343, 132222, 46084, 96919, 16875, 8073, 262381, 79982, 52663, 13928, 16056, 153908, 15145, 109256, 132308, 18763, 24904, 167644, 13618, 40750, 18686, 147124, 114709, 150038, 52849, 2938, 12568, 48617, 8778, 5459, 44202, 44591, 74914, 17183, 248689, 13878, 7822, 80060, 23116, 194037, 18487, 2067, 7798, 43077, 33678, 244028, 31320, 74273, 2794, 19466, 8218, 36280, 183997, 48124, 19416, 29656, 19280, 98734, 7715, 18311, 30701, 133602, 150307, 126956, 7378, 2933, 79903, 13178, 12593, 86571, 26604, 92446, 13574, 44205, 65699, 427599, 21118, 8245, 14407, 27877, 47936, 33542, 7916, 26460, 117762, 21596, 37818, 2249, 127359, 209394, 60044, 47677, 308089, 36791, 154971, 31417, 6998, 150042, 174360, 12255, 43009, 29335, 48739, 3912, 101398, 53340, 2580, 146939, 151295, 45360, 125275, 15273, 45383, 27456, 48761, 23314, 8750, 60801, 85823, 104759, 27894, 123685, 66968, 39480, 26917, 55290, 83305, 2696, 98390, 57569, 145853, 340733, 4919, 20024, 52268, 30884, 7413, 203685, 70989, 112855, 4129, 50536, 349518, 68205, 332641, 159581, 135361, 236026, 37563, 176404, 64899, 6578, 122033, 63871, 1850, 85234, 82089, 66124, 74145, 121098, 107351, 12687, 36881, 117334, 13136, 14698, 85933, 93866, 18047, 32620, 310, 15094, 46e3, 88451, 23632, 36645, 27940, 87618, 80520, 58892, 20976, 27702, 140090, 96075, 67841, 103292, 238964, 87778, 107338, 17019, 83427, 67522, 7302, 8261, 47570, 116787, 8730, 80484, 61772, 174422, 56005, 131193, 52875, 14588, 28471, 59817, 9586, 15720, 158155, 51307, 109734, 15196, 11025, 59331, 3884, 52626, 102602, 84797, 25158, 27314, 4437, 20488, 76214, 189248, 35023, 114952, 157376, 2827, 62439, 102878, 129749, 36405, 10329, 109339, 108633, 36662, 1254, 13267, 5470, 87105, 58004, 15397, 10434, 159667, 21864, 52022, 179464, 3013, 32147, 31496, 116832, 18494, 105502, 129227, 107267, 50033, 13481, 9954, 24267, 22141, 16257, 116154, 36185, 950, 115685, 11305, 176708, 2048, 178671, 112573, 287867, 162328, 497663, 95170, 50979, 193861, 50987, 30368, 136257, 31830, 46549, 15119, 169876, 23788, 17462, 249887, 57377, 1949, 35448, 14791, 43769, 210091, 3783, 34612, 282103, 88380, 245190, 5457, 20491, 98908, 11402, 86899, 117916, 16028, 162584, 60644, 320177, 156096, 31065, 55876, 22e3, 77655, 9992, 23397, 13757, 317623, 63978, 215255, 2443, 17648, 93231, 27388, 104529, 93807, 55505, 140477, 12046, 112040, 70887, 40152, 94365, 112353, 25063, 114679, 266061, 71248, 119555, 15589, 2244, 617, 14129, 211431, 70110, 100652, 7777, 4383, 85911, 89221, 21010, 120615, 58357, 86405, 37554, 41647, 18, 15143, 69662, 60491, 14714, 186134, 148344, 42347, 5410, 168175, 44535, 42449, 343894, 129417, 99682, 20659, 27272, 140483, 63455, 222159, 17536, 13722, 42637, 62324, 11976, 114691, 148109, 2283, 32057, 182393, 4295, 147364, 33705, 2075, 44303, 30274, 28331, 63740, 69740, 29148, 10346, 44862, 33716, 73937, 153333, 12930, 38784, 247159, 2515, 41053, 20256, 83368, 256189, 54639, 115240, 5096, 24661, 175419, 153552, 26516, 141, 138176, 63885, 34115, 47222, 55709, 2765, 28479, 38875, 236608, 12229, 22921, 77291, 54426, 45388, 2860, 57787, 114579, 295139, 105782, 17826, 71066, 19119, 54364, 69385, 16568, 12323, 28057, 33346, 34919, 124763, 155533, 101386, 31644, 8627, 49001, 303600, 29868, 63213, 9103, 77280, 71333, 9696, 138789, 37059, 24823, 5057, 21352, 32368, 114208, 56803, 19424, 10445, 58514, 8661, 209508, 26187, 171838, 10460, 63454, 14016, 122504, 41328, 21329, 46618, 32493, 38225, 7855, 31763, 7945, 29876, 8734, 6438, 24205, 97490, 139977, 130740, 47323, 33195, 85390, 57194, 13813, 60600, 21313, 96251, 7699, 27584, 170521, 139271, 1363, 4402, 336738, 129223, 84983, 69150, 13147, 3590, 163929, 207225, 155260, 55916, 20288, 4503, 8398, 98490, 11773, 27512, 37113, 84976, 86558, 28365, 11756, 116005, 182148, 13733, 115313, 47644, 67208, 85069, 9347, 14995, 226141, 14704, 101835, 41159, 35314, 13113, 63526, 214039, 29978, 50446, 83339, 17440, 129441, 72522, 118641, 97816, 24907, 73844, 15717, 118884, 167255, 96509, 162793, 30847, 36849, 51297, 78974, 77793, 10427, 1873, 2972, 9999, 35074, 28190, 64297, 146836, 46298, 60038, 163007, 108919, 61219, 2403, 75022, 127339, 4233, 110389, 69022, 9833, 128097, 88016, 79390, 222936, 22570, 94657, 28462, 56956, 38803, 81536, 30474, 152794, 19566, 16481, 147408, 74574, 81895, 20731, 1918, 1366, 76367, 187321, 54494, 24366, 21690, 61696, 33283, 107477, 77499, 31112, 414383, 74362, 18463, 218441, 120929, 59848, 258629, 201924, 69269, 454, 19989, 13054, 59894, 3623, 58908, 20681, 35723, 78523, 102680, 38988, 184112, 108087, 50944, 132704, 52966, 21699, 18860, 96349, 201411, 82697, 85395, 95658, 5093, 6427, 177894, 44191, 32755, 26961, 155739, 6249, 31310, 81030, 26574, 84311, 120155, 86730, 113535, 7424, 48888, 13516, 45747, 98098, 20077, 183995, 81945, 43210, 26704, 40420, 75831, 45648, 11180, 6855, 57927, 65528, 124096, 34851, 2598, 156633, 107572, 127352, 38169, 123845, 60142, 62722, 105584, 232364, 23211, 68120, 1601, 22169, 89299, 747, 258039, 80572, 7258, 152249, 11862, 101204, 8834, 121434, 33761, 19175, 133142, 46343, 40178, 48723, 3589, 41977, 30210, 38868, 62257, 10087, 82658, 87827, 90646, 16415, 47552, 351723, 28298, 72225, 91146, 272760, 1701, 11295, 1652, 109651, 300747, 51863, 198800, 29446, 11794, 32345, 37538, 22356, 33102, 37590, 113544, 37970, 11478, 179743, 25454, 103417, 59905, 221970, 105196, 145604, 7817, 164809, 102360, 16974, 75840, 255333, 56902, 6659, 1954, 645, 59400, 67769, 7689, 18675, 5215, 13793, 20536, 27852, 3387, 29523, 259718, 16860, 94625, 43143, 29245, 15848, 233581, 22685, 63631, 78557, 22836, 133302, 84513, 1348, 51826, 47129, 98836, 58284, 1830, 1749, 94642, 10933, 6145, 12506, 10975, 13879, 103781, 144434, 10268, 28409, 32346, 52968, 121567, 107374, 77268, 23686, 35097, 10501, 155275, 15303, 47136, 21102, 168741, 55332, 90385, 15996, 84817, 681, 137803, 25054, 142275, 6163, 38175, 8056, 124296, 240642, 65621, 4934, 178205, 16101, 62803, 60964, 18230, 100622, 76465, 44689, 14545, 9543, 47514, 16852, 93380, 28048, 12047, 107106, 37575, 101485, 77047, 57326, 34819, 96137, 76916, 6469, 46264, 115983, 75768, 87668, 69942, 13027, 165, 8373, 114231, 26434, 52844, 42799, 182044, 23580, 146254, 38081, 43236, 33883, 146220, 382894, 14606, 46035, 36481, 166621, 35417, 95382, 2957, 59384, 60428, 36358, 66343, 75378, 22267, 22950, 83528, 17577, 56474, 25285, 4619, 179691, 75355, 95836, 53295, 34588, 171410, 4487, 14679, 84208, 44015, 18562, 109133, 54101, 11531, 86052, 174479, 303157, 28095, 9953, 35642, 14564, 39802, 16145, 77606, 117406, 53038, 121117, 53624, 22062, 1212, 7632, 127157, 237292, 189087, 10478, 127345, 102515, 181997, 86752, 87623, 10966, 121602, 68783, 68681, 83042, 114380, 138349, 191305, 67176, 50085, 39016, 1427, 42384, 1412, 67118, 122616, 72389, 25260, 2237, 13576, 137346, 19938, 20304, 2191, 68759, 5373, 61364, 238507, 75814, 23931, 69565, 38993, 131741, 38364, 12528, 87762, 5679, 129853, 5310, 186831, 32653, 90338, 260176, 389531, 108118, 26843, 43985, 50175, 30563, 25106, 56965, 18130, 140428, 4542, 165503, 117991, 24219, 229605, 1819, 129663, 1240, 3797, 76093, 18398, 71339, 51919, 93043, 27175, 47060, 216257, 6483, 35051, 1217, 16512, 80798, 129064, 13225, 69339, 8548, 237079, 72298, 2575, 34280, 51379, 117910, 55671, 53345, 247552, 29486, 39328, 140821, 34681, 57045, 60177, 5004, 90269, 78522, 2479, 322607, 48474, 61296, 13057, 31558, 4678, 59271, 6699, 27044, 31988, 35944, 12503, 83480, 4389, 136508, 3781, 114121, 70279, 4488, 155829, 42214, 2898, 68191, 75695, 305850, 45041, 74344, 106509, 30087, 17429, 93292, 12477, 290, 23080, 114802, 35714, 18751, 26554, 105424, 17775, 2144, 2412, 100610, 65192, 113975, 52975, 180272, 135050, 129815, 76238, 106483, 21440, 63186, 4260, 46189, 9711, 28249, 4169, 23429, 23390, 8324, 141585, 63809, 67668, 38457, 38063, 39226, 59972, 1189, 203916, 62368, 14403, 16949, 61767, 85801, 1739, 40147, 35049, 76757, 33124, 62102, 15780, 103593, 103009, 53484, 22952, 67973, 114645, 6566, 5245, 50462, 7601, 8288, 3513, 194571, 80276, 1908, 54592, 5124, 58571, 2513, 6800, 273997, 193904, 1119, 17991, 117245, 2508, 129156, 82366, 26278, 71465, 63341, 56943, 39662, 106116, 94966, 156875, 9736, 2204, 122308, 94418, 27134, 1280, 24539, 49022, 45314, 3764, 50904, 46424, 30699, 28087, 293839, 9400, 33646, 40165, 822, 147499, 50263, 116179, 29085, 11863, 31314, 5578, 17797, 5104, 12454, 1604, 15342, 219206, 10232, 67800, 94261, 25872, 13565, 90339, 78971, 75377, 26649, 41184, 47695, 11514, 35369, 20767, 14227, 41953, 309396, 148270, 147938, 33074, 14453, 27499, 109019, 39018, 25738, 240196, 158931, 52820, 8612, 95853, 21524, 137010, 84901, 70869, 70021, 116794, 48404, 38771, 6732, 1070, 70990, 187297, 49140, 5238, 576, 3564, 253975, 16027, 16483, 2811, 37775, 19034, 25259, 4053, 2e3, 70083, 95774, 19713, 33431, 92703, 91314, 42381, 288770, 48194, 95985, 3991, 77418, 13406, 241328, 245086, 56533, 35275, 62725, 9246, 51924, 70181, 95331, 16163, 31410, 79016, 39312, 120878, 119371, 275987, 80124, 27712, 9186, 220, 23598, 146167, 85209, 68238, 282190, 57048, 31273, 30555, 80913, 17594, 75779, 59160, 135002, 101219, 189377, 29225, 96735, 60126, 62522, 104e3, 27620, 86814, 17240, 147533, 11001, 5425, 43682, 410, 49460, 87270, 69480, 46315, 59448, 1816, 76201, 9431, 11788, 87960, 29063, 65539, 47347, 11678, 33846, 7008, 196704, 9895, 6753, 8633, 120892, 59970, 572824, 115934, 6646, 202559, 892, 48351, 37611, 251282, 57823, 67263, 57750, 26527, 34485, 90747, 7685, 88370, 6144, 64182, 1709, 41969, 21458, 62327, 181657, 49247, 225330, 122600, 114574, 107124, 85361, 111833, 63243, 71420, 15655, 191178, 72430, 18063, 51425, 54002, 12364, 53225, 86557, 18193, 97580, 41232, 138398, 67821, 128724, 8944, 233212, 101353, 52099, 42127, 14006, 120107, 32789, 32132, 3498, 18123, 33758, 56058, 5779, 128760, 59888, 98869, 18445, 84702, 51911, 13234, 218379, 20093, 39031, 8074, 70195, 20708, 23462, 24355, 131384, 60189, 26390, 10403, 41060, 7140, 10781, 49410, 42261, 87202, 82566, 41663, 43105, 60276, 2768, 5733, 74176, 28329, 2297, 145430, 131632, 83615, 122915, 105441, 655, 224102, 5284, 136426, 67763, 16294, 188511, 32538, 61049, 27893, 3394, 13951, 159099, 28542, 17930, 145360, 9492, 190122, 32285, 78855, 26440, 13570, 58648, 73908, 4239, 124561, 2444, 74172, 53131, 11468, 10794, 73566, 11623, 35343, 64710, 30481, 4163, 10328, 38309, 29901, 10538, 154377, 76132, 92405, 24839, 11679, 3465, 13449, 11637, 7824, 2337, 57754, 1260, 14458, 41118, 19878, 38661, 13416, 159180, 37074, 163164, 54137, 28627, 52134, 184900, 8520, 40385, 29546, 30502, 22386, 66527, 107458, 6850, 24022, 47983, 30603, 35083, 8934, 304066, 39500, 9, 28261, 33026, 77251, 9374, 44833, 116312, 34990, 29236, 63563, 125639, 135405, 165398, 159055, 55690, 88141, 69643, 236964, 31983, 25572, 20436, 36746, 60896, 31850, 16179, 11828, 5888, 3043, 66368, 9750, 31167, 7915, 53111, 36430, 1333, 64344, 93659, 20061, 60596, 180191, 51630, 6792, 30244, 43509, 101058, 22409, 420, 44210, 109783, 43223, 27030, 72477, 72831, 32679, 29235, 7675, 47556, 12258, 39907, 149412, 84926, 118247, 24692, 71717, 105038, 86009, 45941, 41189, 89453, 29856, 52543, 30627, 226798, 67303, 59230, 67415, 34408, 1367, 99685, 16867, 128419, 52147, 4111, 125381, 117881, 16173, 44093, 102224, 31575, 23234, 24870, 83790, 127407, 239098, 3200, 994, 1255, 100903, 242275, 117266, 55116, 38205, 16140, 29662, 11307, 40414, 208793, 123355, 56470, 4862, 75600, 30119, 58218, 70828, 24075, 26974, 7802, 192353, 4851, 5475, 78720, 66596, 3409, 28573, 64396, 30381, 30690, 59859, 88256, 5406, 99945, 103064, 34463, 37727, 24238, 86643, 60088, 4057, 23741, 5967, 162904, 38240, 28356, 93858, 25510, 122879, 6897, 3278, 7057, 11971, 4400, 35461, 211413, 21395, 59615, 39471, 87233, 55795, 128426, 3051, 22470, 41950, 14705, 3974, 180108, 80476, 78442, 204996, 91987, 15634, 67610, 139015, 142373, 35611, 51134, 10387, 4353, 153456, 57749, 181039, 14183, 68447, 151532, 21107, 36452, 20551, 3186, 46247, 46383, 129666, 88736, 140662, 146243, 2066, 8360, 7978, 64818, 106963, 17896, 47801, 10723, 114821, 223295, 74192, 3293, 3393, 16987, 74064, 11277, 91622, 4270, 29828, 27951, 387869, 103235, 1374, 61988, 120083, 477, 145892, 128378, 11779, 211263, 61354, 18221, 17869, 46530, 83061, 108538, 157981, 90608, 67199, 95080, 49064, 195814, 12302, 66307, 10348, 231346, 160732, 112859, 63633, 146558, 21271, 31037, 198802, 47622, 12862, 95710, 3910, 77850, 73961, 85585, 34752, 61e3, 4082, 24595, 103679, 71107, 8208, 79568, 150019, 16615, 24961, 139857, 32664, 197366, 4559, 54735, 32696, 4126, 162019, 75698, 13916, 70108, 159638, 19834, 9349, 24675, 175560, 49643, 18206, 52459, 27992, 10809, 88865, 401975, 133172, 29e3, 34558, 30915, 3658, 25834, 42430, 36562, 125265, 18182, 10155, 40149, 97082, 208980, 19575, 60853, 90529, 66545, 9600, 789, 46420, 2317, 88593, 55595, 98980, 115302, 5742, 169155, 1073, 177901, 3472, 11189, 63711, 78643, 65472, 50459, 127979, 93, 42202, 67053, 21720, 157650, 11145, 141378, 42033, 22824, 85705, 79114, 35584, 15974, 1510, 54172, 28562, 12451, 104226, 19190, 97151, 73024, 20948, 5151, 81741, 21499, 29006, 84183, 198074, 54003, 45120, 170125, 26240, 35177, 28389, 64863, 79974, 60778, 176915, 232183, 45342, 2038, 80253, 41564, 40703, 32689, 5430, 100689, 5366, 23007, 134279, 14266, 26712, 73993, 24934, 64242, 52113, 102887, 61801, 46415, 201049, 54251, 62133, 122757, 164883, 30815, 139966, 2319, 30842, 766, 13362, 10287, 134518, 86111, 81665, 82440, 28333, 43019, 18963, 8804, 161944, 23439, 102144, 101145, 80029, 39052, 248708, 30350, 117340, 11878, 128467, 974, 138625, 63961, 5237, 74778, 61834, 67040, 43814, 13690, 65947, 33809, 232476, 115258, 181745, 28824, 94013, 9510, 10246, 93722, 81976, 7217, 114383, 3493, 16014, 69045, 72692, 12145, 80981, 9507, 6692, 1620, 60820, 330444, 35474, 33962, 4797, 7053, 295463, 46445, 27026, 12491, 77988, 49524, 35675, 90947, 29114, 166705, 101385, 133782, 32704, 6186, 84595, 176031, 185623, 45966, 151302, 63069, 1699, 107491, 947, 15458, 74452, 196212, 6046, 10498, 12163, 10239, 35191, 243951, 9277, 9090, 29539, 54460, 22820, 26514, 112549, 60372, 51753, 48756, 21812, 70861, 260326, 41, 44222, 10441, 16961, 48148, 138771, 216194, 5914, 52153, 53400, 212036, 56519, 26245, 10117, 45888, 15294, 138019, 90913, 26368, 43842, 42111, 23348, 6082, 194845, 161089, 156206, 51546, 11647, 30759, 302912, 262094, 8635, 78876, 26535, 35283, 54183, 31183, 85484, 147873, 12989, 5197, 6356, 72894, 65347, 20150, 27370, 73787, 1493, 45918, 12366, 190217, 20724, 13858, 10981, 67449, 81213, 7553, 14115, 72242, 271517, 11842, 48310, 88743, 143726, 22177, 3290, 243231, 58452, 62937, 12592, 1654, 40066, 33477, 13751, 9921, 128442, 15868, 7106, 75236, 83773, 10775, 36938, 10482, 170465, 17368, 17469, 161508, 32752, 98340, 800, 19824, 264456, 3901, 87319, 2867, 26782, 9630, 113102, 185815, 24197, 44584, 86366, 40224, 3636, 140916, 31731, 267731, 9567, 53678, 72984, 29389, 27963, 17106, 50282, 284911, 60170, 8322, 12608, 23374, 89652, 5268, 39044, 229766, 8869, 151350, 31436, 177342, 12269, 183212, 120418, 116270, 2843, 78888, 69192, 7865, 184099, 1086, 129897, 18383, 70508, 20242, 18508, 229924, 124569, 35749, 50589, 55626, 9884, 83115, 40971, 30671, 18135, 14452, 38861, 17844, 201826, 5549, 26413, 17189, 13561, 38539, 10679, 143331, 3314, 36785, 171194, 49685, 187713, 67506, 4618, 104039, 17060, 195080, 50648, 33159, 19238, 67559, 134840, 28599, 157523, 17130, 38064, 117398, 94355, 31918, 13575, 34538, 40326, 13997, 3494, 348283, 62481, 26862, 3603, 104426, 244363, 153709, 112487, 304612, 199674, 41239, 35545, 54869, 293005, 28223, 26277, 26899, 4533, 18518, 15492, 38587, 80488, 70485, 160395, 263, 60162, 11382, 222152, 4696, 250751, 51921, 182609, 10707, 48463, 46243, 1227, 49111, 111564, 46502, 33342, 56846, 68541, 63559, 858, 139927, 16654, 229375, 76759, 26478, 33205, 95828, 23399, 92945, 2637, 35630, 28470, 143992, 50214, 14174, 21456, 166191, 65665, 1711, 21594, 78019, 97599, 111701, 36, 147151, 110246, 189022, 43021, 30397, 40757, 131935, 42065, 73335, 48039, 26596, 28984, 15102, 2361, 7421, 202167, 69744, 43766, 52826, 3642, 83304, 33873, 75140, 63169, 192389, 36551, 92748, 13039, 123959, 233220, 21738, 84447, 77230, 20228, 187852, 19095, 25799, 92136, 108774, 29237, 53947, 2299, 118106, 2687, 8830, 42331, 202924, 33667, 2023, 73763, 30704, 19363, 19779, 16737, 35629, 48081, 24068, 101013, 162338, 291912, 13749, 24745, 328289, 167679, 70086, 48299, 23306, 16732, 17801, 43322, 54589, 3586, 63653, 43624, 53474, 925, 109177, 251316, 43805, 13082, 19511, 86565, 142182, 92461, 17117, 101033, 103319, 64589, 4022, 4351, 235897, 5352, 82705, 107142, 46391, 156084, 5860, 61365, 10558, 13045, 7717, 18357, 33922, 12590, 33065, 6928, 46993, 783, 46937, 67846, 8952, 26295, 6107, 119656, 18799, 17458, 50747, 4229, 179559, 112727, 118080, 20683, 41464, 125468, 51560, 49749, 44231, 7359, 35339, 62988, 136487, 67015, 5208, 29150, 24956, 105186, 48858, 6143, 18097, 6972, 16404, 73489, 58742, 97196, 36357, 164616, 5834, 32267, 13746, 147733, 15113, 132091, 34127, 106298, 39729, 106426, 22294, 9780, 15602, 36213, 71502, 42808, 66802, 599, 60755, 5851, 39120, 67363, 108623, 126368, 72770, 91263, 32486, 30596, 151717, 7951, 52002, 43103, 11768, 68942, 40901, 39344, 24037, 127500, 116890, 48403, 16926, 86750, 17745, 48648, 159545, 34460, 58419, 5634, 114317, 67865, 31462, 23352, 24010, 98185, 125708, 69686, 68337, 13610, 26271, 70691, 2980, 4768, 27225, 102402, 75453, 28106, 8104, 6931, 1176, 6274, 6475, 112635, 22498, 6176, 238686, 26832, 28893, 90319, 14441, 15682, 15087, 39517, 45270, 109134, 104440, 45965, 47645, 81772, 7876, 52683, 87720, 12898, 4505, 185665, 2769, 113401, 15664, 57592, 105229, 137381, 97059, 119268, 6876, 43309, 33886, 128363, 35476, 144249, 67013, 143587, 83367, 25703, 91436, 59347, 53236, 2289, 16519, 19844, 46309, 58558, 99834, 23313, 218816, 231303, 36388, 51333, 183535, 109792, 139277, 54306, 90139, 18235, 8275, 32710, 37677, 82464, 86025, 92204, 88842, 117723, 37570, 128723, 234242, 76350, 73795, 34896, 148247, 58424, 11105, 11744, 45746, 63372, 17118, 49772, 199520, 81902, 38004, 22911, 33752, 3125, 1995, 53792, 4689, 26909, 108150, 146062, 69674, 41811, 161444, 84855, 8999, 28561, 16731, 93937, 3189, 21967, 24890, 22943, 1356, 145300, 51569, 28802, 517, 118679, 31703, 40607, 48098, 108854, 25003, 10233, 73969, 177495, 5248, 24516, 215347, 146192, 48712, 60626, 69188, 40735, 5866, 586, 101541, 6509, 47590, 52129, 5969, 222045, 110933, 25733, 24223, 65339, 62812, 2414, 155418, 35819, 16022, 78423, 43138, 20995, 128255, 240673, 46745, 236093, 72176, 57085, 97841, 61248, 107, 36068, 193177, 105427, 55726, 215229, 20446, 47228, 100420, 87091, 14429, 121708, 23605, 21157, 187721, 21880, 2997, 203976, 99166, 95068, 25877, 7724, 98925, 83401, 4829, 13182, 18229, 13718, 239662, 38653, 116505, 153497, 30589, 89029, 38962, 181302, 43853, 78872, 180301, 4786, 248240, 7401, 106136, 112590, 77745, 19731, 60880, 77789, 125748, 135487, 5975, 48627, 34084, 12419, 215770, 47557, 254582, 10364, 106495, 21856, 67539, 88981, 38805, 21428, 48732, 42316, 12149, 16078, 52808, 25327, 51322, 33850, 51147, 12253, 122354, 46077, 56483, 254553, 115417, 81834, 150991, 94662, 86668, 7381, 12841, 100650, 18218, 15741, 22372, 68294, 50705, 15535, 84660, 61887, 22553, 72299, 31361, 24824, 17743, 46820, 64288, 31582, 77006, 111674, 116384, 30760, 80920, 86149, 77192, 51979, 79691, 60342, 122805, 103800, 240873, 160744, 233114, 78962, 54920, 8608, 3484, 316104, 72548, 24337, 5088, 230040, 21926, 10172, 36838, 26, 86221, 83458, 102176, 12062, 17571, 41929, 41170, 28428, 68239, 41750, 103930, 2634, 18313, 53019, 34825, 97837, 63115, 24606, 73157, 152474, 14715, 91439, 37033, 109806, 140259, 30668, 174760, 380, 135597, 95673, 136073, 65073, 134249, 13829, 17279, 122305, 4420, 46444, 10237, 64848, 203623, 70728, 10349, 182885, 65075, 24519, 25783, 40318, 34139, 22222, 63394, 55266, 102764, 41422, 20126, 65100, 90408, 53640, 35128, 48932, 11192, 38935, 96839, 34782, 39492, 19396, 41332, 6250, 5511, 19492, 51304, 25936, 104466, 54099, 73771, 86115, 5080, 7669, 30891, 111700, 13931, 25276, 72289, 135447, 14820, 258641, 25265, 31005, 281179, 75286, 393, 95359, 14623, 13584, 6680, 101227, 80173, 44933, 76666, 54542, 13244, 39348, 458, 25379, 109451, 134348, 81143, 6959, 65554, 12027, 51311, 8716, 57589, 140731, 28467, 23316, 17272, 30458, 25980, 55229, 77197, 83798, 28302, 114784, 7428, 34548, 26241, 14712, 39336, 103304, 18928, 54080, 12870, 334, 87722, 15208, 16895, 142098, 114262, 39820, 83913, 57817, 28682, 7721, 14900, 108672, 11250, 62246, 42849, 415188, 1724, 26555, 24549, 25505, 26443, 107450, 145899, 61035, 43528, 6901, 60726, 65906, 267741, 21338, 147590, 42079, 18924, 73017, 135236, 15393, 5206, 4026, 84185, 1531, 5988, 113890, 82647, 303391, 7386, 69844, 71611, 189865, 76523, 31877, 13315, 19314, 198575, 32821, 1928, 67641, 25913, 104475, 103489, 3297, 70391, 18406, 15446, 113347, 19295, 93790, 27856, 1792, 167471, 116449, 8541, 4408, 41757, 63233, 25765, 86680, 64501, 27034, 24816, 34975, 6079, 4486, 49693, 36229, 16917, 21581, 62426, 27862, 11612, 54284, 35702, 194034, 355, 24277, 48262, 87411, 70504, 310164, 118018, 12516, 47559, 43502, 57433, 107139, 9290, 66533, 80863, 14634, 34312, 91725, 28606, 21342, 67241, 72355, 43244, 375789, 37402, 174015, 105070, 8342, 44167, 67494, 1890, 16365, 11723, 271002, 1865, 47918, 8350, 45564, 27742, 25110, 125803, 8553, 49504, 81925, 62211, 4534, 15491, 19011, 80373, 206920, 667, 102405, 128623, 245524, 5553, 113309, 192739, 65766, 19567, 22832, 261958, 29679, 21293, 71134, 20962, 105123, 24721, 860, 21752, 33448, 18372, 157167, 94822, 35770, 173224, 232737, 75729, 28937, 46828, 28062, 25453, 5207, 140366, 36665, 30652, 6169, 67920, 150458, 92040, 23186, 184604, 92330, 20891, 176492, 49427, 27828, 38305, 42495, 143982, 49560, 25503, 90043, 29747, 65328, 47830, 12932, 11068, 77721, 9003, 25213, 94205, 140426, 46090, 89945, 138173, 192691, 33329, 112232, 129905, 35709, 27514, 1841, 19957, 31411, 127476, 53572, 17497, 173549, 55063, 175135, 19841, 69314, 5192, 237921, 117660, 150697, 4060, 273045, 50414, 98940, 65348, 153665, 164423, 58804, 156695, 48994, 213928, 86036, 28608, 8355, 39574, 34540, 16927, 135680, 18374, 151587, 10830, 53805, 16878, 16623, 4282, 48030, 8537, 14986, 46102, 13062, 72897, 72, 33050, 108227, 39451, 45935, 651, 113320, 40535, 95176, 57450, 48843, 5003, 19019, 10407, 211163, 3848, 1068, 4988, 32091, 30095, 41692, 15099, 43602, 107434, 50744, 7627, 171349, 16313, 150832, 352665, 207750, 33937, 38256, 51091, 156e3, 87889, 90663, 84175, 24908, 114900, 50365, 31494, 83829, 5398, 169342, 47521, 54818, 18935, 8356, 43094, 41212, 174536, 10082, 92550, 6678, 60614, 23355, 69721, 14796, 34149, 128830, 58187, 3179, 208, 40325, 28399, 225029, 401412, 51150, 31580, 207268, 6657, 10993, 69818, 64282, 289845, 23308, 12961, 38447, 6681, 52944, 31855, 2572, 47646, 120728, 179148, 37240, 45196, 218274, 4816, 3695, 21961, 50084, 35209, 18073, 51452, 27004, 6100, 33941, 1377, 84831, 171214, 85, 141510, 9078, 99227, 32610, 6417, 11718, 49868, 65579, 87902, 73018, 49062, 46280, 61742, 21512, 40862, 107733, 15941, 29168, 157765, 144919, 14487, 5767, 158014, 140070, 7241, 573, 71584, 16921, 223566, 40331, 179473, 35081, 47926, 140885, 41508, 52104, 59180, 42310, 32811, 29048, 123517, 102413, 80208, 10104, 14746, 12649, 153641, 126022, 37965, 113017, 4171, 83, 142592, 2809, 6362, 50416, 71323, 116894, 260776, 16204, 1524, 5760, 30351, 12658, 20703, 54403, 36083, 45408, 74772, 4946, 14485, 50759, 111222, 10890, 2195, 167147, 92962, 130534, 16283, 177256, 35016, 15472, 210156, 151187, 73922, 117691, 43250, 52051, 37392, 24811, 24358, 30830, 5775, 818, 21969, 1476, 127322, 151783, 58392, 31021, 106913, 65215, 89407, 90802, 28531, 11690, 20234, 95249, 44602, 37256, 18707, 11928, 5161, 4410, 26571, 51903, 49768, 22008, 25252, 65780, 209499, 68769, 203726, 13249, 137363, 48845, 86823, 6658, 5674, 31881, 1083, 1823, 108676, 34518, 166752, 13791, 14287, 91576, 91429, 8665, 11529, 26401, 16191, 91972, 30964, 5254, 28486, 54697, 79613, 66520, 18447, 22870, 45203, 194466, 22822, 51703, 12278, 76716, 44595, 73455, 33546, 12235, 144843, 36154, 51247, 11116, 33040, 3180, 225753, 60864, 1972, 28469, 12891, 28879, 10338, 144157, 56294, 353058, 38302, 41447, 87532, 110616, 27065, 168438, 6557, 1213, 50804, 144643, 24817, 2390, 136531, 38174, 247513, 16190, 4059, 122791, 131994, 137430, 39506, 57650, 16305, 5188, 54309, 106128, 20628, 88071, 67394, 395446, 250285, 66176, 91254, 1399, 114196, 43915, 60230, 44853, 27206, 106353, 43013, 18733, 345105, 226453, 51202, 16607, 57106, 117175, 35492, 10476, 89598, 127439, 15187, 39624, 13688, 61570, 10615, 31111, 59370, 6238, 175252, 32143, 224492, 41388, 95408, 34384, 148238, 78307, 38959, 9340, 160091, 61443, 15737, 11216, 41244, 170, 38299, 102443, 113097, 26382, 14027, 33707, 3957, 76300, 66160, 19431, 18900, 6952, 1717, 108656, 82206, 188021, 257335, 27295, 43999, 41210, 31777, 46956, 57457, 12657, 11489, 15697, 48060, 204748, 53583, 82422, 284790, 30503, 137341, 8120, 19615, 220311, 15991, 10217, 63424, 9808, 67431, 70976, 98221, 4491, 15177, 28535, 144789, 751, 13230, 2394, 1504, 33977, 132104, 30316, 22230, 931, 97193, 185240, 24826, 22687, 174322, 15307, 22988, 1390, 188745, 180325, 29580, 59068, 74903, 18994, 29195, 79, 15436, 7622, 38462, 11566, 138710, 44828, 45774, 37768, 99236, 68137, 84083, 19282, 22698, 17134, 74807, 126662, 173497, 46248, 16938, 119735, 3212, 28292, 213652, 49013, 9975, 32180, 45660, 86250, 4801, 68788, 95490, 77482, 113751, 11994, 44624, 94452, 46839, 128497, 100316, 5798, 58588, 73184, 202987, 65417, 37790, 88524, 1606, 43156, 97964, 105717, 34947, 11203, 100060, 37742, 130074, 93653, 107799, 94311, 196106, 41347, 8035, 10780, 16390, 27883, 118236, 167395, 1979, 25006, 19375, 31628, 18916, 144723, 78502, 114047, 103107, 86492, 107686, 5844, 20934, 206963, 23556, 22591, 16562, 146333, 20167, 10471, 117434, 33085, 2863, 9740, 36669, 41849, 37271, 22790, 18209, 28979, 8231, 12952, 54408, 21731, 25130, 45208, 55748, 138120, 75826, 414, 29593, 9925, 292865, 25999, 683, 123149, 7036, 92159, 86055, 61827, 103680, 23176, 54918, 58466, 57578, 13305, 5709, 86479, 16697, 31064, 17660, 200919, 10770, 49793, 33423, 32370, 52047, 16488, 62555, 6459, 8426, 83493, 7763, 59725, 82812, 18628, 67760, 79405, 68557, 9612, 7673, 28102, 56517, 69620, 171797, 32458, 29541, 15870, 81109, 32080, 207644, 71495, 21202, 11039, 91036, 61230, 2810, 130800, 32260, 4613, 60590, 37112, 75214, 33979, 126402, 155062, 30642, 63875, 12810, 194463, 82799, 47664, 16725, 36685, 43367, 61099, 449, 172150, 102867, 21691, 301838, 36745, 7130, 18671, 57316, 34852, 38034, 54182, 35578, 65900, 99486, 19771, 3456, 2658, 16914, 99866, 28390, 28109, 8262, 21147, 34353, 20006, 4228, 137085, 1675, 203023, 283196, 198286, 214375, 163329, 290603, 152574, 40471, 83506, 30068, 14730, 23177, 131539, 34759, 27668, 32178, 71896, 104799, 116305, 85430, 119262, 42860, 25160, 8911, 23428, 49437, 105322, 6519, 16203, 6349, 74711, 1230, 38045, 8540, 75165, 44736, 25909, 51026, 317034, 4984, 32281, 91312, 27060, 44431, 17817, 45363, 155937, 239085, 35697, 59784, 91993, 29531, 126740, 213757, 76560, 167776, 285273, 24262, 8237, 65030, 41160, 74437, 48804, 118916, 13159, 37842, 1031, 75349, 1478, 11655, 108777, 23435, 277425, 101734, 67469, 70231, 124711, 43532, 28514, 65526, 54956, 1e3, 21882, 17728, 25302, 40952, 52214, 149632, 1999, 2111, 3259, 63362, 89961, 220561, 39777, 26335, 9063, 10572, 12416, 34551, 34623, 38604, 24723, 5947, 15588, 69927, 66252, 119177, 69173, 46629, 28714, 70715, 212408, 20521, 406913, 74380, 11716, 50659, 50862, 37009, 88460, 130101, 7210, 53853, 538, 65120, 151950, 55806, 163748, 52837, 13153, 21100, 16674, 64536, 6091, 138201, 44837, 58547, 3723, 163, 2177, 32288, 85454, 34033, 8497, 14282, 25742, 10535, 10741, 79559, 117493, 243787, 49337, 100718, 79495, 40139, 42956, 7551, 55433, 15421, 31509, 23034, 45081, 547, 61176, 53434, 328001, 8470, 36263, 30145, 4519, 74173, 53935, 11845, 73774, 60211, 78025, 3, 4102, 73782, 109293, 315332, 48412, 26683, 13714, 6865, 20128, 18490, 104141, 325, 39470, 171970, 115860, 15707, 7268, 73301, 74336, 31370, 2368, 111827, 107757, 136231, 142844, 97138, 96638, 84053, 38691, 23801, 1588, 10573, 122098, 77039, 240, 186135, 146101, 11996, 18143, 112963, 46171, 155836, 348769, 47795, 121213, 116266, 132515, 3344, 144804, 31286, 99187, 255838, 129694, 35894, 48779, 55235, 148582, 71967, 65282, 15174, 13920, 47080, 6147, 108242, 157593, 125025, 7136, 1286, 28957, 127956, 28402, 98813, 20805, 7532, 109417, 40610, 5041, 32958, 15142, 18408, 108596, 33543, 50517, 27748, 80114, 233434, 91447, 487, 37094, 100048, 30541, 43477, 10639, 89862, 155868, 37667, 8726, 60684, 237903, 73408, 99589, 12190, 38739, 97348, 3914, 13594, 2680, 149016, 13907, 30171, 28343, 23530, 115225, 61104, 35821, 147679, 14337, 4297, 244282, 24085, 326976, 56428, 7851, 21303, 131620, 71446, 83253, 68692, 111870, 5224, 15813, 38197, 49026, 45057, 13660, 3306, 76345, 40671, 27905, 91072, 996, 68527, 62085, 91351, 122634, 55109, 168209, 2024, 27560, 112707, 17352, 8306, 167115, 169921, 166958, 5031, 46020, 11844, 67284, 19130, 76185, 6920, 32849, 5450, 14610, 22451, 21002, 17392, 31872, 66682, 84796, 13709, 40210, 59898, 12029, 8719, 53564, 21462, 91884, 21647, 88379, 194428, 12754, 37797, 132826, 160016, 22567, 54383, 53186, 77611, 31107, 8339, 4694, 19185, 90355, 23597, 17222, 140675, 28442, 23668, 55977, 9128, 61555, 28774, 155229, 17658, 9390, 24379, 69357, 15752, 127381, 239631, 62460, 93181, 55913, 45133, 140155, 18676, 25249, 33164, 29581, 82837, 67223, 22362, 29975, 7317, 52813, 1943, 29613, 20012, 207130, 49617, 49651, 5636, 15334, 36313, 29226, 28084, 95247, 72072, 19e3, 224932, 15811, 114, 32127, 38097, 37508, 88507, 37225, 27359, 91626, 12193, 69279, 20608, 11055, 88156, 92808, 2152, 57259, 55275, 72789, 24475, 104414, 1708, 9882, 3818, 48661, 66897, 1631, 34806, 227930, 85815, 87753, 18321, 250664, 72733, 25107, 206797, 50891, 8082, 196411, 92596, 96764, 152823, 65514, 22819, 387277, 62176, 51225, 40329, 15563, 189, 3659, 73670, 64357, 51793, 275136, 33482, 86653, 74615, 67058, 11318, 125720, 15388, 22388, 8267, 1730, 102663, 170910, 40784, 7144, 85373, 13040, 7088, 94309, 583, 44224, 140424, 77439, 18496, 164026, 36578, 4722, 9151, 5824, 63365, 26510, 35199, 40500, 79277, 32495, 44614, 35233, 9566, 203293, 152144, 7097, 2330, 183480, 98629, 13423, 330887, 44130, 68600, 30939, 97829, 31012, 345465, 56747, 94879, 4939, 160027, 149761, 99423, 46099, 32251, 15332, 8761, 96094, 128555, 5763, 235318, 222223, 55729, 30241, 55420, 201746, 3987, 81382, 8259, 49325, 23287, 7719, 24633, 251100, 92311, 18591, 110533, 64759, 170260, 393860, 7175, 21144, 132887, 3593, 75346, 101277, 91109, 16387, 259187, 11627, 57459, 173829, 44694, 55780, 49797, 89192, 120443, 62622, 3904, 14814, 23887, 1027, 112258, 64955, 99800, 11132, 66353, 36202, 48624, 18158, 88481, 96882, 43059, 11040, 2455, 7077, 21651, 181159, 99126, 100434, 61388, 68186, 19161, 110468, 120052, 8819, 55324, 41494, 7014, 37689, 3618, 87729, 92615, 207943, 9823, 128657, 12587, 15857, 6379, 67628, 51216, 71775, 157617, 63244, 1503, 3864, 218754, 110864, 5769, 21492, 7243, 1192, 87921, 85529, 31512, 18537, 42698, 35350, 73510, 84474, 34301, 8991, 21013, 35034, 566, 38832, 19838, 35586, 37216, 39413, 55006, 12178, 59742, 856, 84563, 6900, 25632, 17437, 49786, 30723, 13847, 70845, 4044, 7843, 23944, 235976, 55530, 48942, 6518, 20939, 73769, 192653, 52936, 95207, 23895, 132542, 142982, 22632, 87452, 48042, 54018, 178468, 10728, 26230, 23559, 363, 81269, 142012, 5718, 346258, 31456, 84333, 246476, 51018, 66692, 101804, 120570, 39962, 30373, 70593, 2864, 60541, 19425, 54209, 104092, 7201, 31545, 48018, 25865, 15442, 46257, 40443, 8328, 6451, 111782, 47527, 97754, 33046, 470, 245116, 31095, 39, 91934, 87208, 73470, 36708, 36521, 12801, 70624, 36272, 8892, 79768, 12427, 55454, 103756, 5908, 52390, 62962, 22720, 141138, 94634, 41689, 128402, 126390, 6628, 106394, 35527, 134394, 82727, 254651, 194502, 148064, 89549, 3202, 28359, 957, 21954, 27906, 49840, 142747, 8307, 24206, 48978, 1186, 71728, 133038, 71474, 91306, 6333, 110959, 74600, 70387, 18983, 62609, 56057, 22970, 1147, 135850, 1321, 28834, 3578, 59715, 102227, 32827, 81415, 99952, 55636, 257598, 390, 22702, 35701, 85872, 402916, 39216, 189795, 14929, 19467, 10112, 144422, 61514, 5279, 63421, 134686, 41436, 8424, 51925, 10598, 132295, 124416, 4604, 194739, 210929, 57866, 31829, 51626, 50007, 9976, 91878, 61906, 56168, 81906, 60918, 61859, 40017, 23059, 16887, 40927, 62064, 12785, 32893, 32913, 21782, 93965, 20169, 44387, 79084, 38463, 11457, 93950, 27127, 157050, 2697, 337088, 5116, 54128, 48255, 33279, 8821, 27352, 25515, 124022, 65710, 28906, 38557, 33390, 1722, 104435, 72215, 38551, 12094, 30978, 25113, 6671, 37355, 175109, 42862, 98024, 65406, 221276, 59624, 118012, 64637, 78760, 86697, 21426, 1639, 40350, 12584, 67193, 84144, 31396, 7863, 143011, 69629, 63112, 9454, 28666, 65798, 46372, 134721, 6314, 51402, 30837, 151922, 2847, 38676, 38008, 92823, 136245, 17540, 5504, 109295, 205242, 37606, 5211, 214892, 1586, 20670, 208711, 137743, 19328, 40652, 16995, 20023, 14657, 154919, 34422, 12996, 13918, 38221, 47690, 16398, 2959, 37680, 89122, 6721, 198469, 91876, 172043, 83898, 101992, 26084, 94570, 3635, 76958, 22853, 76497, 38266, 176590, 168403, 44464, 142840, 79180, 184594, 1984, 41806, 83147, 11985, 6546, 366068, 59732, 24533, 271505, 8736, 39084, 222992, 93429, 28962, 58985, 86665, 8432, 30028, 14548, 32439, 54424, 165029, 55175, 27458, 69046, 121277, 46168, 33732, 20661, 24581, 135574, 123110, 37556, 79260, 72611, 16957, 12939, 46162, 58238, 44907, 72936, 253758, 41324, 32518, 96480, 11949, 124438, 65280, 43256, 34107, 53533, 43531, 37037, 28366, 45970, 32741, 173438, 6121, 194202, 62969, 26355, 30314, 58370, 28455, 1848, 50519, 82830, 90393, 21761, 295490, 10936, 256940, 133568, 44050, 20269, 4089, 27457, 21610, 219460, 36743, 14821, 101388, 52005, 13124, 30979, 140816, 167362, 26054, 18458, 60789, 34917, 40447, 26606, 33422, 9066, 3452, 83614, 5761, 20263, 137238, 25038, 91310, 101, 52322, 74548, 42572, 38084, 214054, 186568, 31802, 17665, 30620, 141936, 37730, 14420, 4265, 187218, 49640, 188208, 51441, 55388, 96452, 66659, 40869, 42039, 60967, 221027, 19234, 178581, 29105, 96050, 9165, 196118, 157335, 3738, 40354, 117436, 2965, 34136, 59659, 15570, 50843, 230035, 31444, 71260, 43886, 18316, 5387, 38500, 168508, 17406, 32174, 8828, 103373, 143806, 90367, 3560, 18719, 122310, 16508, 26719, 2541, 105429, 6645, 37998, 73190, 10591, 235916, 49737, 87112, 233941, 53188, 32193, 79154, 4544, 52905, 126477, 7580, 63501, 57314, 3216, 31337, 6541, 103083, 60846, 49, 9756, 15481, 1355, 43840, 14319, 13743, 27486, 10222, 73114, 230718, 418644, 16706, 6674, 279748, 23058, 45273, 295831, 86306, 2743, 5535, 88773, 21829, 35253, 120938, 31153, 3169, 16839, 42847, 8751, 80974, 33942, 36867, 35514, 16485, 26474, 77775, 56877, 5391, 48346, 3882, 108713, 31403, 27804, 55248, 26235, 43821, 136104, 40118, 175507, 28034, 203908, 18732, 1788, 34030, 106427, 36958, 54359, 7251, 44936, 15356, 69139, 455, 157915, 22173, 140291, 50348, 43275, 82066, 49621, 54952, 15216, 36226, 96695, 66855, 6936, 1987, 8227, 196087, 4631, 68827, 99004, 47541, 110265, 17953, 147605, 110242, 58520, 31312, 38724, 329975, 642, 3155, 34497, 75937, 6207, 73843, 6120, 17249, 51429, 117746, 3218, 910, 68961, 319671, 14938, 29555, 34700, 1649, 66673, 72268, 9655, 76800, 153087, 6941, 210168, 27130, 35398, 1780, 73242, 3135, 56689, 19556, 165307, 8765, 35967, 121458, 13333, 70453, 17350, 117253, 22265, 13340, 44265, 39869, 441, 3742, 135025, 23581, 33309, 16543, 17731, 13291, 157637, 283005, 21408, 101360, 63887, 52312, 83873, 5338, 233779, 23759, 186949, 34531, 177320, 38069, 156465, 91004, 19353, 59852, 68160, 14891, 1338, 1072, 29823, 1950, 28901, 81407, 313445, 73038, 84807, 162348, 240257, 37162, 138934, 16111, 58013, 41253, 102951, 16457, 96056, 19541, 56402, 67217, 41638, 94381, 89674, 29481, 37456, 80815, 151579, 13937, 13683, 132537, 19699, 134545, 67020, 29816, 222341, 141235, 427578, 48868, 129557, 233342, 23077, 87871, 16213, 18728, 16184, 9469, 37913, 19680, 2798, 171356, 178328, 13216, 50049, 72690, 71904, 124644, 55455, 7504, 29052, 41036, 266546, 19899, 30391, 188755, 8659, 59469, 16, 104298, 112943, 53865, 76203, 138226, 68857, 139953, 14125, 107625, 119795, 173133, 4398, 50273, 48808, 54390, 16466, 122086, 31835, 67035, 50971, 48859, 7508, 46427, 66477, 73021, 84615, 39985, 83076, 46779, 201569, 53336, 36443, 60865, 168164, 143810, 51393, 25548, 169307, 32896, 24485, 38424, 21837, 29087, 275813, 51674, 6714, 64883, 46169, 187369, 55186, 76192, 12852, 12018, 62134, 31067, 118303, 16542, 12125, 10579, 4928, 26291, 43854, 7091, 10946, 253716, 109062, 39283, 17261, 113012, 258512, 47764, 125126, 32646, 55892, 80279, 201623, 149872, 3192, 385, 1208, 48750, 5376, 58738, 22335, 5427, 82416, 47811, 32435, 143086, 38930, 94128, 59975, 156037, 37977, 38224, 62485, 7698, 50405, 71027, 16462, 21559, 136153, 34131, 107506, 162069, 63703, 3101, 215029, 40407, 4178, 3774, 9187, 80019, 17880, 97926, 67579, 2600, 18405, 8351, 47924, 86638, 70820, 92206, 86453, 29610, 42241, 119200, 3198, 15466, 67813, 57863, 35454, 4779, 99518, 4649, 104641, 144269, 33730, 38073, 65864, 6838, 109456, 193298, 154007, 5623, 45741, 30846, 182578, 25573, 157224, 1543, 58575, 138703, 146140, 44971, 49356, 18275, 59064, 20300, 13122, 11848, 24453, 11973, 9797, 86843, 2919, 25530, 49210, 1130, 161220, 76788, 75373, 85604, 34926, 36014, 17777, 17255, 51533, 11676, 92226, 51845, 119859, 21525, 5936, 18507, 28050, 1140, 31418, 14857, 34207, 47859, 10750, 36382, 32079, 106909, 59426, 87757, 38393, 110042, 15965, 97104, 33757, 35344, 97993, 53979, 33651, 45407, 41884, 82515, 173089, 7177, 58371, 35365, 47543, 51927, 35587, 10670, 23544, 29306, 84233, 39976, 76076, 62097, 9007, 8668, 28119, 78281, 120790, 19835, 143020, 54968, 18670, 64959, 20649, 34469, 42570, 33001, 136570, 87796, 120044, 1106, 58700, 63951, 127623, 12805, 83057, 40212, 31773, 49850, 7361, 54336, 347524, 101314, 23751, 19569, 48791, 29174, 49369, 20467, 7465, 75842, 38281, 623, 112457, 60210, 28849, 51003, 94720, 6426, 90047, 85560, 43761, 3579, 85105, 34607, 90410, 118528, 7224, 42907, 111163, 18168, 6960, 161135, 191298, 5247, 100584, 127552, 171568, 20121, 91173, 12636, 54615, 20199, 63730, 98105, 2396, 40387, 14438, 125012, 4765, 33235, 12865, 45299, 37728, 82098, 77872, 114037, 59253, 19675, 24838, 398016, 102561, 11446, 17069, 57508, 178277, 65836, 99941, 26114, 2585, 271882, 136866, 50126, 11027, 155648, 118367, 14585, 8910, 123015, 335383, 40434, 41016, 53021, 14439, 87098, 176860, 201543, 121888, 2358, 9286, 5739, 22666, 54270, 37884, 169381, 33984, 93859, 16124, 89364, 72207, 51639, 76366, 99029, 65812, 2198, 12147, 174891, 194289, 6986, 30252, 88822, 21284, 11445, 288337, 160821, 33034, 100869, 43852, 25761, 52882, 1144, 103809, 1924, 84458, 86079, 43411, 13542, 139276, 18141, 34978, 41298, 7276, 26481, 173800, 33210, 17951, 142652, 33616, 33677, 2210, 19941, 98568, 2486, 192414, 80136, 12058, 235883, 50963, 249638, 29572, 27221, 47034, 6124, 72107, 63346, 97620, 158513, 299699, 40388, 23235, 37176, 224244, 198386, 121323, 67992, 23827, 63170, 17838, 106622, 158590, 26807, 5345, 23489, 91891, 55474, 74834, 37981, 13058, 5977, 72552, 34706, 26828, 145172, 19904, 21367, 34043, 960, 77092, 91381, 4733, 47446, 7680, 41697, 5170, 16960, 14741, 46101, 13656, 473, 51842, 37433, 11103, 11551, 121951, 13191, 97536, 165932, 50397, 51628, 129028, 9069, 44885, 6590, 59195, 47045, 32940, 225472, 90345, 21833, 13303, 29407, 96615, 141951, 5198, 6028, 18395, 7181, 3861, 14966, 156358, 167182, 36529, 55253, 25942, 173153, 30959, 27261, 50691, 150176, 162201, 38467, 48462, 80602, 42163, 118482, 168, 108756, 26011, 17166, 54149, 456538, 22512, 91374, 13816, 90358, 131615, 18132, 226707, 1824, 28139, 26860, 42253, 93877, 77351, 65575, 8980, 80574, 22020, 27948, 40422, 91324, 76376, 13528, 39281, 91685, 82215, 122541, 144066, 1983, 193851, 17283, 26320, 2739, 194978, 4790, 26845, 42627, 61300, 65815, 174612, 55133, 4200, 191130, 79771, 158321, 52280, 166796, 221620, 62461, 11278, 4067, 88152, 83409, 31717, 121367, 13522, 47325, 37945, 10406, 174348, 249321, 154101, 64912, 29938, 51775, 17220, 15776, 166138, 78890, 84425, 54121, 42861, 16368, 24572, 291647, 10197, 32073, 22651, 11677, 97509, 26952, 35787, 18424, 41910, 71614, 94977, 72318, 41594, 70024, 275419, 37702, 60199, 7335, 39107, 61315, 18271, 18394, 33768, 87884, 104277, 123724, 7277, 56288, 71981, 189803, 49320, 3352, 6798, 14240, 8954, 69220, 94433, 57372, 28620, 68863, 193727, 85575, 42309, 41667, 67689, 42081, 22543, 44824, 12719, 28540, 114236, 101553, 27638, 27296, 4300, 5353, 4663, 19379, 94098, 3758, 95888, 95144, 80344, 87320, 28447, 259518, 12718, 71391, 152731, 37063, 24132, 31911, 104896, 15672, 103782, 1521, 4945, 72541, 23717, 122632, 15619, 87175, 206120, 29428, 189780, 61416, 28350, 44457, 972, 1175, 47233, 198738, 95789, 41907, 21953, 97034, 59341, 22864, 53713, 16873, 32971, 20693, 20954, 31336, 21477, 16169, 38370, 16412, 9019, 3841, 24599, 21938, 17085, 6484, 81198, 76413, 5849, 72514, 12320, 65247, 276175, 37234, 59796, 52642, 16312, 57349, 198507, 94148, 46134, 18958, 125552, 1747, 18725, 151873, 14901, 5490, 68287, 29470, 3689, 64794, 40814, 26018, 25692, 54450, 2703, 88278, 124886, 173087, 174e3, 24159, 179477, 24276, 46004, 201876, 209202, 445, 52876, 31948, 30206, 157610, 39180, 18439, 44124, 50469, 5774, 96278, 222758, 200216, 50290, 45486, 20435, 46986, 46276, 140133, 142326, 15569, 13363, 47522, 92583, 2182, 7135, 16853, 22998, 30272, 4952, 63263, 35623, 39096, 53789, 44864, 20053, 110392, 124213, 4630, 16087, 28221, 127787, 25839, 77481, 44693, 13464, 113146, 6983, 27069, 55717, 50102, 4760, 7107, 26186, 66507, 59145, 36032, 104182, 71328, 29425, 64317, 50781, 47465, 94298, 69706, 74899, 22754, 120756, 25108, 93077, 56834, 73286, 39928, 16218, 41699, 176763, 7555, 70819, 50083, 26895, 23315, 26014, 16773, 123079, 41712, 5719, 31516, 90427, 158540, 85051, 183128, 40864, 27505, 55392, 9058, 45224, 96857, 30901, 136622, 96557, 56304, 120061, 11501, 151448, 5773, 89743, 7769, 86069, 2935, 18471, 41628, 10114, 33660, 110170, 49479, 26745, 92846, 33221, 26731, 18795, 87076, 8550, 2100, 29972, 120289, 3077, 72490, 33784, 2630, 208722, 50861, 63483, 79029, 6419, 39467, 14302, 45286, 64207, 9686, 67513, 44170, 1050, 77246, 59266, 17055, 53801, 7150, 11111, 42432, 4278, 94579, 362117, 36175, 42902, 41933, 39002, 98489, 22913, 74161, 84773, 57036, 17556, 162288, 74485, 178760, 93867, 73635, 128860, 50362, 261, 67455, 80001, 46080, 35662, 4368, 25247, 19230, 74393, 22588, 1822, 27682, 235324, 13798, 85998, 13194, 235067, 23514, 71669, 147632, 23191, 134748, 214683, 105101, 1518, 25489, 247114, 7380, 54842, 26922, 3971, 26361, 20844, 68642, 170517, 77339, 123255, 8963, 77818, 150998, 48466, 36806, 2732, 23261, 11741, 236162, 18243, 126216, 28690, 50546, 16385, 92760, 197383, 246558, 201295, 88255, 67588, 71687, 176076, 172653, 169058, 33906, 63747, 24835, 157621, 43338, 30050, 46152, 132741, 2770, 51371, 94835, 6614, 15112, 11749, 56936, 1250, 19027, 399017, 58036, 100215, 23388, 55815, 308768, 124152, 94803, 9521, 64186, 8971, 28, 30427, 62163, 7616, 103838, 35079, 29203, 131235, 7743, 17389, 10882, 37420, 61460, 228512, 85363, 41581, 131077, 62822, 119647, 10130, 54445, 26925, 19968, 29016, 24446, 74028, 24176, 61448, 67185, 9254, 8563, 119129, 9771, 99184, 37716, 39514, 10532, 221512, 258753, 218630, 55980, 23394, 32141, 61924, 66749, 32411, 3741, 36475, 26678, 77010, 44946, 91203, 128749, 116953, 20476, 49625, 53116, 13735, 102335, 29376, 51946, 83407, 67892, 59212, 34685, 21083, 1546, 112982, 32972, 74397, 1078, 190545, 16082, 86140, 58591, 89611, 101531, 10061, 105104, 76319, 20035, 17551, 52611, 169061, 190842, 100780, 23907, 90413, 115619, 9675, 34710, 193435, 49443, 129734, 11183, 258877, 16318, 136182, 126808, 44635, 27304, 192375, 2599, 125648, 47051, 12091, 23814, 721, 58800, 40137, 66726, 97930, 60877, 74487, 7942, 54326, 9841, 41428, 13762, 8211, 85383, 6950, 99177, 79806, 201786, 296464, 124087, 13144, 29741, 41721, 47634, 55088, 254286, 106408, 17041, 99064, 12942, 64086, 45233, 14005, 2612, 55827, 255, 7984, 13980, 38574, 12776, 46654, 73499, 249951, 2101, 26676, 25996, 132326, 116415, 119062, 50449, 31033, 23038, 11589, 179252, 20007, 14860, 129270, 21143, 17796, 144715, 60106, 70758, 69842, 34674, 282133, 44014, 16774, 57268, 38528, 24053, 46373, 201667, 28327, 471023, 51889, 102667, 21193, 114909, 84132, 69317, 96723, 67969, 16134, 68145, 15058, 28765, 32035, 2524, 101089, 98664, 25045, 76571, 14957, 86040, 118506, 262428, 154764, 81573, 39681, 283900, 73287, 127825, 544, 80448, 52347, 38512, 175971, 15180, 45467, 33086, 46552, 48894, 81107, 43213, 36672, 54025, 76703, 8053, 7608, 13299, 56619, 20752, 238099, 54164, 105133, 1444, 32942, 953, 37564, 8e3, 66316, 119463, 106817, 404, 13667, 149108, 128597, 31267, 10269, 49836, 106150, 1484, 52330, 76965, 160486, 171648, 38456, 31263, 22424, 37738, 66245, 67467, 143369, 60471, 75610, 20895, 115528, 86070, 60854, 40796, 49347, 18989, 15030, 11371, 37578, 15779, 79867, 10187, 86462, 46402, 155626, 93200, 40229, 7090, 57547, 108053, 99598, 11088, 47505, 41218, 206017, 2173, 20988, 30219, 22919, 80563, 57566, 42369, 93141, 41675, 2407, 182519, 120495, 27154, 16702, 29456, 14349, 7958, 16688, 117177, 140375, 42467, 261919, 74916, 153569, 10836, 34742, 49526, 7621, 105997, 12212, 2270, 392377, 7755, 17959, 25086, 232152, 138791, 33847, 13860, 35316, 5811, 1344, 71259, 50452, 207539, 92635, 50359, 5821, 33674, 30255, 2086, 2587, 96264, 17543, 42, 6029, 9580, 43007, 139248, 82831, 12917, 29607, 25786, 51467, 42137, 85161, 100698, 31561, 88989, 121990, 278500, 3602, 109344, 37982, 15279, 116442, 28936, 30880, 87894, 58079, 128661, 126731, 67392, 28051, 146885, 4861, 16216, 97344, 42827, 147561, 153948, 22684, 21335, 47685, 1853, 43349, 15185, 59642, 10229, 25520, 187921, 108972, 5579, 98037, 24945, 6697, 19193, 63734, 137934, 75056, 89740, 19767, 224268, 56138, 63643, 151661, 39313, 70618, 84031, 89723, 84074, 13703, 85626, 35460, 8867, 64845, 3439, 57906, 99776, 63968, 49270, 81130, 34356, 16210, 23547, 36446, 34090, 140028, 72439, 2221, 22163, 57058, 363492, 113754, 18913, 95451, 48663, 54464, 54037, 176097, 68425, 3023, 34906, 29482, 117389, 341780, 80431, 58330, 16753, 92616, 60907, 94846, 147486, 4498, 48646, 7773, 46801, 7778, 18946, 464978, 47558, 33223, 177444, 7328, 15626, 63337, 94700, 11743, 9351, 255024, 39098, 16447, 42647, 96230, 39769, 58840, 10068, 63439, 35800, 65843, 58823, 413844, 9156, 51258, 7434, 61791, 85018, 6872, 3692, 28096, 7121, 33024, 6009, 75532, 31997, 192535, 9661, 3304, 9547, 14753, 31987, 25314, 55689, 15896, 20430, 39472, 31340, 99744, 25398, 115569, 54883, 28719, 205423, 23071, 57855, 64638, 149867, 25671, 82403, 37616, 20668, 39989, 77996, 74948, 140555, 175248, 64810, 36515, 46595, 4958, 248773, 24045, 28728, 136673, 168704, 20804, 114833, 100325, 27135, 21205, 96151, 153134, 45992, 7093, 13992, 76047, 1980, 19432, 145001, 75159, 87462, 17710, 1013, 45556, 34297, 144882, 20648, 26061, 11319, 129567, 108555, 18872, 464580, 33386, 22717, 65948, 167189, 5603, 135042, 79542, 8801, 202632, 18114, 91882, 5973, 5239, 67315, 4431, 60916, 47819, 71693, 32597, 32606, 18183, 45072, 80329, 76385, 24749, 51305, 40314, 156514, 14693, 130345, 13168, 66214, 18029, 12858, 34801, 27628, 14544, 10823, 40522, 40185, 33739, 148694, 23548, 9923, 61012, 28859, 17933, 19442, 34364, 99849, 164107, 141167, 30629, 21054, 6744, 36491, 8096, 42474, 41706, 155060, 30650, 10600, 163442, 1143, 96655, 61390, 52359, 7559, 51568, 64256, 203854, 4467, 22453, 14504, 436398, 7878, 6980, 8293, 63610, 293747, 16167, 35763, 19627, 147603, 15419, 18032, 110744, 51346, 33681, 54571, 40472, 48615, 39073, 21604, 13754, 173027, 92560, 11083, 47299, 63062, 11813, 52007, 29883, 9734, 139722, 15953, 1550, 20651, 13616, 49306, 16113, 90089, 92326, 7584, 30712, 72424, 164858, 6831, 152871, 55746, 197721, 34167, 196442, 6022, 112107, 55215, 7538, 123381, 4920, 43539, 77165, 8939, 50392, 34192, 20225, 79762, 22505, 58667, 40770, 29788, 97180, 82835, 4568, 8579, 13273, 363569, 35898, 49983, 436, 36598, 3237, 131691, 62418, 35591, 8101, 4073, 379438, 65218, 76072, 33887, 2968, 27573, 212619, 288680, 68278, 72851, 150504, 217896, 6913, 121339, 22017, 35340, 51072, 43616, 75043, 31437, 10833, 81487, 4364, 22968, 41454, 106687, 85446, 19863, 109625, 149241, 524, 141850, 214404, 54376, 657, 237023, 9401, 108137, 53800, 32474, 49712, 53334, 126876, 27337, 45552, 177696, 8269, 15036, 12097, 42240, 2328, 125374, 119295, 99715, 2500, 19624, 39441, 27220, 102691, 60957, 94543, 39101, 18566, 67362, 13975, 78230, 25017, 34017, 239007, 90027, 39351, 41681, 35354, 43822, 1043, 916, 58587, 141983, 94818, 38799, 75459, 41114, 67432, 16195, 36606, 59568, 22272, 126769, 31424, 68659, 12287, 134302, 257977, 5756, 207285, 95637, 47248, 117689, 19583, 77451, 22373, 12200, 54993, 117118, 34244, 29386, 34562, 53819, 71267, 64172, 77665, 49368, 7716, 59301, 25749, 45426, 194789, 17297, 2650, 1766, 32501, 45198, 20403, 20984, 6600, 14171, 94604, 19037, 5402, 29896, 9938, 59935, 109708, 88081, 145182, 44844, 39167, 352626, 164173, 35374, 45982, 6122, 154, 73419, 220487, 53834, 53601, 17992, 8609, 229321, 5610, 68098, 66815, 71012, 95069, 140968, 27396, 8957, 134489, 24656, 86659, 56598, 134852, 17316, 123838, 255436, 6613, 41610, 138033, 81452, 32023, 32396, 123687, 63398, 8693, 29712, 30407, 19296, 121188, 3551, 36099, 20032, 111948, 56624, 16547, 27453, 35916, 15378, 52039, 56849, 13489, 22214, 73177, 53097, 277349, 2157, 14029, 187886, 10260, 141743, 246460, 91880, 50869, 3788, 49486, 133566, 54950, 33120, 129337, 53768, 18333, 9525, 26902, 312251, 10297, 9020, 70759, 16647, 112432, 59260, 84609, 9818, 82766, 73569, 468, 46001, 75780, 55028, 52106, 11498, 43645, 108069, 17150, 17753, 29417, 16705, 31799, 9606, 289, 122254, 115975, 8620, 6133, 255357, 56908, 14456, 133464, 43554, 79224, 11247, 29630, 160, 12756, 25464, 65960, 350428, 62521, 321796, 100359, 67358, 35169, 46172, 113128, 48988, 88868, 31094, 33266, 6847, 60887, 98188, 49659, 69117, 92977, 220228, 13947, 80181, 35103, 62170, 97351, 13475, 2440, 199768, 19498, 36597, 46971, 25234, 67806, 62881, 84717, 73648, 181966, 10488, 94149, 21550, 26655, 63436, 48375, 14405, 165650, 9621, 24439, 28043, 42735, 4490, 29963, 56674, 45373, 1934, 262446, 50855, 67098, 26898, 5261, 52696, 40644, 33900, 9440, 180286, 87162, 22940, 19704, 26936, 69769, 10254, 101759, 27406, 12243, 48e3, 73926, 113215, 54935, 5726, 192787, 4312, 106216, 9366, 11550, 52949, 23457, 212271, 277152, 133895, 108374, 6191, 96477, 29980, 218916, 58024, 54696, 40853, 91124, 65894, 91170, 65908, 252552, 6793, 29212, 15389, 44516, 122515, 52617, 35058, 9017, 103536, 39510, 49136, 19242, 130652, 662077, 74699, 47024, 31422, 8517, 73351, 24399, 13867, 128360, 4810, 4434, 61779, 111983, 61036, 17798, 110240, 59722, 102960, 39688, 10001, 23803, 23039, 176498, 56659, 44814, 134295, 17188, 77577, 74466, 226175, 102472, 154333, 63900, 111747, 18062, 41171, 79669, 32773, 408933, 42562, 28931, 30907, 107388, 43487, 2946, 240310, 23938, 24354, 319, 184983, 7927, 6488, 1422, 10790, 68809, 68209, 64775, 4361, 202, 17123, 59634, 51200, 44391, 18188, 17843, 2619, 74278, 3230, 9540, 47187, 21702, 36274, 56894, 43907, 16310, 34790, 16866, 6150, 5561, 13587, 107545, 108873, 126867, 86986, 28640, 33427, 19017, 5762, 80637, 17430, 46903, 2047, 131055, 25958, 13558, 5444, 47152, 13900, 44563, 122857, 45348, 70863, 39593, 54332, 38068, 33637, 318, 40310, 143467, 18502, 24520, 11377, 62013, 28942, 27246, 28269, 83545, 17999, 59015, 90707, 30065, 15161, 34720, 1263, 37008, 2012, 6060, 98575, 92933, 5721, 299, 199555, 24578, 29223, 2985, 743, 115825, 109523, 136657, 47454, 26378, 53586, 3733, 174945, 93340, 244456, 5693, 37386, 28782, 89767, 27545, 23573, 18798, 136425, 34320, 84778, 20041, 48453, 38215, 7477, 71958, 40621, 8773, 5874, 187927, 105965, 51100, 43533, 18083, 8443, 10180, 43597, 2003, 183999, 69689, 12216, 129696, 146188, 62389, 34044, 68410, 12765, 43273, 26949, 266807, 3345, 34477, 79197, 5688, 47539, 213110, 21634, 22257, 50092, 32222, 42346, 39530, 63668, 98, 134978, 74022, 5152, 59088, 174145, 37220, 9934, 9545, 118937, 5724, 87240, 19875, 15784, 40143, 23263, 87513, 181654, 285152, 37881, 263241, 4966, 43934, 10433, 186657, 6470, 74416, 225854, 25908, 142677, 246262, 32280, 6192, 75890, 45546, 143264, 135305, 29742, 47013, 77787, 11732, 126658, 8763, 37950, 21806, 57557, 113464, 89465, 108995, 164574, 23894, 22996, 23169, 15369, 23117, 17642, 130607, 40503, 36239, 280990, 44666, 9981, 40427, 147487, 26869, 168452, 32886, 32991, 46798, 240839, 15111, 70502, 65697, 88548, 44145, 28701, 48767, 31139, 206777, 35659, 181164, 166262, 14554, 171445, 31786, 66523, 76607, 17956, 6507, 31279, 90476, 116611, 167918, 6560, 1243, 115324, 80128, 41867, 55897, 187323, 37069, 32596, 189444, 145931, 13390, 105530, 65709, 26805, 6999, 55714, 41300, 22915, 68951, 22138, 21120, 22264, 10058, 19945, 33635, 56123, 99085, 10032, 5818, 6016, 46649, 57476, 35264, 94413, 112522, 262288, 93686, 83038, 14341, 23204, 28807, 66084, 77987, 6101, 126673, 7133, 38126, 5923, 122091, 170240, 97772, 46874, 215746, 43948, 41622, 3272, 55596, 8332, 146411, 251315, 13533, 8561, 81521, 115449, 48616, 175175, 2063, 186556, 3036, 134537, 75772, 29728, 82360, 22973, 186559, 86348, 89100, 38388, 82297, 45610, 2613, 87082, 9986, 177812, 57884, 23591, 47485, 42543, 33582, 44713, 74439, 257444, 252451, 31825, 35631, 38540, 33066, 5147, 13973, 4343, 51830, 70378, 22827, 26448, 95560, 36896, 241741, 48067, 203953, 298860, 61620, 20450, 3220, 67272, 6586, 107662, 100160, 108684, 6929, 57226, 4762, 7457, 1320, 40404, 77204, 99309, 62750, 208653, 59977, 44e3, 74315, 34332, 5819, 172217, 64904, 114077, 18147, 84012, 1791, 98456, 90930, 21446, 116669, 103938, 7422, 85140, 59713, 5768, 326211, 16239, 75411, 13229, 29398, 10758, 236107, 1539, 112472, 95979, 152154, 151294, 306, 21196, 38146, 10700, 6891, 84282, 109646, 56492, 40539, 6589, 119491, 51354, 30685, 140209, 136906, 29622, 73617, 49553, 70525, 51671, 166869, 139616, 74395, 37439, 49595, 45678, 11959, 33211, 86560, 52434, 9282, 62690, 112155, 130810, 5243, 108261, 99970, 265613, 72551, 80049, 6391, 33365, 90721, 66737, 69872, 87011, 1860, 9032, 112544, 60905, 37371, 89015, 140351, 19076, 850, 373531, 2802, 36725, 218795, 72062, 28990, 16550, 24614, 7815, 6187, 26336, 33373, 32162, 42791, 73555, 32062, 23386, 10244, 56392, 49442, 27076, 136262, 12412, 14883, 1134, 33675, 97153, 199281, 15608, 100152, 74072, 47942, 254301, 36451, 16026, 10687, 65067, 56708, 254030, 30290, 50490, 13864, 57941, 259331, 35588, 23485, 43486, 24869, 21620, 92971, 22072, 88645, 1048, 182050, 13343, 32452, 14825, 19509, 3325, 216938, 45740, 99716, 189082, 53740, 78245, 25609, 24311, 176777, 47340, 308354, 40669, 66085, 14102, 125339, 9225, 128709, 97207, 1271, 200933, 78439, 113451, 88975, 18324, 46521, 11819, 18570, 141756, 72512, 170020, 52754, 63550, 118515, 103073, 93330, 32736, 50499, 14722, 31600, 68452, 398867, 29316, 172786, 18417, 104924, 2606, 5670, 84818, 16288, 67106, 59580, 82929, 607401, 291, 85829, 359, 15897, 35830, 50696, 65630, 52672, 22115, 356968, 29895, 40837, 231192, 34024, 38957, 26722, 406, 23335, 124952, 72068, 68804, 13268, 147101, 164740, 276569, 162596, 66943, 11569, 26654, 66358, 4777, 23229, 102127, 5848, 978, 2921, 59666, 5371, 28212, 90108, 42938, 39320, 2499, 4271, 108792, 33510, 125072, 71653, 65239, 38250, 66357, 38577, 13964, 86251, 35708, 50755, 36010, 29448, 12209, 3844, 38222, 206337, 100876, 67827, 137088, 14167, 252225, 84163, 195270, 1306, 5703, 54198, 779, 46802, 22028, 51124, 86759, 70560, 113164, 35685, 162145, 45471, 34561, 422, 2611, 6464, 47486, 19223, 38246, 9191, 18331, 89942, 243642, 212364, 15893, 17518, 22617, 6409, 30046, 126182, 59716, 36560, 104428, 18846, 26592, 19458, 50793, 147333, 30826, 1388, 27647, 10922, 14495, 33545, 19269, 135828, 39727, 41601, 46931, 233379, 49169, 131130, 182112, 16276, 82381, 118209, 142445, 128310, 19672, 28740, 82907, 33436, 3118, 102206, 28723, 24819, 41937, 38854, 5157, 3881, 111491, 1142, 9776, 421673, 152241, 29309, 14961, 87854, 6054, 15424, 3796, 82656, 54996, 2108, 55367, 239450, 154525, 9643, 118103, 106041, 64601, 68549, 48707, 30266, 25772, 18740, 9462, 229669, 91798, 112152, 191327, 14493, 72828, 8175, 66636, 236474, 25817, 87351, 129027, 76653, 20422, 22983, 71240, 27846, 44661, 12399, 46158, 77704, 53101, 35032, 11072, 17300, 109294, 33638, 24408, 1895, 11241, 760, 17584, 82479, 125877, 63150, 141075, 34259, 23274, 81698, 15732, 43577, 48340, 91584, 14688, 16379, 24481, 150280, 96420, 262050, 48635, 43727, 61819, 56268, 72003, 88178, 17281, 79912, 13218, 122519, 125295, 166396, 11811, 2171, 118930, 67746, 17636, 178278, 174656, 95661, 173039, 83845, 79689, 17473, 98555, 127696, 203415, 54730, 22925, 232239, 9309, 12136, 175026, 20740, 180188, 10747, 39816, 314017, 266131, 10040, 175732, 112550, 220651, 31974, 37393, 888, 23008, 86799, 4303, 64905, 148467, 75337, 251, 3284, 370102, 50264, 9835, 5438, 23655, 4481, 29851, 329, 12855, 7162, 64931, 78141, 12804, 42372, 296771, 83547, 18624, 34874, 86271, 3360, 48665, 77735, 88767, 11463, 63527, 28889, 22258, 29140, 194315, 113924, 25499, 6406, 31334, 1845, 4802, 49184, 43455, 35469, 127594, 92970, 61038, 115005, 38840, 87761, 106838, 8811, 20572, 55637, 11162, 96721, 132425, 108925, 2948, 125457, 36356, 3502, 75270, 27622, 127192, 2561, 123095, 49394, 61155, 16897, 110064, 9699, 89448, 53356, 19628, 220310, 21622, 83036, 9885, 112214, 6087, 26713, 17901, 161912, 91492, 3440, 68594, 9266, 92238, 8087, 6866, 150194, 72175, 80701, 13459, 31836, 43243, 239700, 95846, 44749, 50647, 21945, 230538, 120612, 132371, 244604, 5193, 105637, 34661, 41341, 68775, 85393, 1874, 8771, 33718, 49672, 77403, 595452, 99507, 6490, 58895, 128742, 7704, 39239, 73217, 43816, 62824, 37804, 199976, 22361, 80005, 87514, 94832, 14089, 4574, 139975, 59142, 75523, 100268, 43906, 53442, 15152, 2547, 186002, 17011, 19513, 204282, 3343, 60568, 128318, 119250, 4298, 51871, 41336, 71759, 21921, 45074, 98169, 145889, 99427, 11350, 1237, 5520, 28799, 7803, 53702, 21026, 136352, 38293, 128690, 12158, 90132, 44600, 10184, 26957, 39459, 126025, 78904, 82999, 59373, 39301, 150198, 120529, 153042, 20177, 50089, 14764, 271571, 30530, 123161, 38975, 101562, 22941, 5648, 124654, 109243, 69817, 71675, 49162, 106884, 21241, 107795, 30258, 16572, 188262, 141456, 7688, 60718, 8271, 11044, 32440, 104608, 103419, 236109, 93156, 43293, 128929, 42107, 67180, 25201, 115254, 185488, 130954, 72813, 167547, 20537, 39969, 38432, 22582, 184022, 1139, 27199, 5655, 17767, 97412, 122606, 209377, 27070, 35871, 326617, 188954, 42680, 73512, 80911, 22629, 3011, 95021, 315242, 157737, 383, 41821, 41808, 19335, 27950, 15674, 25677, 110950, 35375, 76835, 59108, 57370, 35262, 16569, 160415, 37706, 78086, 32041, 49691, 137143, 9782, 172080, 50148, 77917, 6323, 10110, 69172, 17711, 21795, 59511, 76184, 135114, 31046, 132319, 59105, 157578, 20549, 80778, 57649, 158421, 65143, 4575, 72235, 21899, 10797, 92745, 34035, 106079, 80159, 4508, 78304, 25350, 75457, 46458, 32937, 25623, 47, 8531, 104751, 84953, 8138, 36508, 187199, 66310, 115274, 13253, 32461, 38536, 1916, 42007, 187160, 35055, 26325, 84394, 35963, 94216, 45590, 97782];
        vr();
        var Hle = w(Jy(), 1), $le = w($o(), 1);
        var pv = 15, mv = class {
          constructor(e) {
            let { peerRouting: r, routingTable: n, refreshInterval: i2, refreshQueryTimeout: o, lan: s } = e;
            this.log = C(`libp2p:kad-dht:${s ? "lan" : "wan"}:routing-table:refresh`), this.peerRouting = r, this.routingTable = n, this.refreshInterval = i2 ?? Ile, this.refreshQueryTimeout = o ?? Cle, this.commonPrefixLengthRefreshedAt = [], this.refreshTable = this.refreshTable.bind(this);
          }
          init(e) {
          }
          async start() {
            this.log(`refreshing routing table every ${this.refreshInterval}ms`), this.refreshTable(true);
          }
          async stop() {
            this.refreshTimeoutId != null && clearTimeout(this.refreshTimeoutId);
          }
          refreshTable(e = false) {
            this.log("refreshing routing table");
            let r = this._maxCommonPrefix(), n = this._getTrackedCommonPrefixLengthsForRefresh(r);
            this.log(`max common prefix length ${r}`), this.log(`tracked CPLs [ ${n.map((i2) => i2.toISOString()).join(", ")} ]`), Promise.all(n.map(async (i2, o) => {
              try {
                if (await this._refreshCommonPrefixLength(o, i2, e), this._numPeersForCpl(r) === 0) {
                  let s = Math.min(2 * (o + 1), n.length - 1);
                  for (let a = o + 1; a < s + 1; a++)
                    try {
                      await this._refreshCommonPrefixLength(a, i2, e);
                    } catch (u) {
                      this.log.error(u);
                    }
                }
              } catch (s) {
                this.log.error(s);
              }
            })).catch((i2) => {
              this.log.error(i2);
            }).then(() => {
              this.refreshTimeoutId = setTimeout(this.refreshTable, this.refreshInterval), this.refreshTimeoutId.unref != null && this.refreshTimeoutId.unref();
            }).catch((i2) => {
              this.log.error(i2);
            });
          }
          async _refreshCommonPrefixLength(e, r, n) {
            if (!n && r.getTime() > Date.now() - this.refreshInterval) {
              this.log("not running refresh for cpl %s as time since last refresh not above interval", e);
              return;
            }
            let i2 = await this._generateRandomPeerId(e);
            this.log("starting refreshing cpl %s with key %p (routing table size was %s)", e, i2, this.routingTable.size);
            let o = new $le.TimeoutController(this.refreshQueryTimeout);
            try {
              let s = await (0, Hle.default)(this.peerRouting.getClosestPeers(i2.toBytes(), { signal: o.signal }));
              this.log(`found ${s} peers that were close to imaginary peer %p`, i2), this.log("finished refreshing cpl %s with key %p (routing table size is now %s)", e, i2, this.routingTable.size);
            } finally {
              o.clear();
            }
          }
          _getTrackedCommonPrefixLengthsForRefresh(e) {
            e > pv && (e = pv);
            let r = [];
            for (let n = 0; n <= e; n++)
              r[n] = this.commonPrefixLengthRefreshedAt[n] ?? new Date();
            return r;
          }
          async _generateRandomPeerId(e) {
            if (this.routingTable.kb == null)
              throw new Error("Routing table not started");
            let r = Fs(2), n = (r[1] << 8) + r[0], i2 = await this._makePeerId(this.routingTable.kb.localNodeId, n, e);
            return Ir(i2);
          }
          async _makePeerId(e, r, n) {
            if (n > pv)
              throw new Error(`Cannot generate peer ID for common prefix length greater than ${pv}`);
            let s = new DataView(e.buffer, e.byteOffset, e.byteLength).getUint16(0, false) ^ 32768 >> n, a = 65535 << 16 - (n + 1), u = s & a | r & ~a, l = zle[u], f = new ArrayBuffer(34), h = new DataView(f, 0, f.byteLength);
            return h.setUint8(0, xe.code), h.setUint8(1, 32), h.setUint32(2, l, false), new Uint8Array(h.buffer, h.byteOffset, h.byteLength);
          }
          _maxCommonPrefix() {
            let e = 0;
            for (let r of this._prefixLengths())
              r > e && (e = r);
            return e;
          }
          _numPeersForCpl(e) {
            let r = 0;
            for (let n of this._prefixLengths())
              n === e && r++;
            return r;
          }
          *_prefixLengths() {
            if (this.routingTable.kb != null)
              for (let { id: e } of this.routingTable.kb.toIterable()) {
                let r = Pc(this.routingTable.kb.localNodeId, e), n = 0;
                for (let i2 of r)
                  if (i2 === 0)
                    n++;
                  else
                    break;
                yield n;
              }
          }
        };
        c();
        var Qle = w(K(), 1);
        var Xle = w(Ci(), 1), Zle = w(Gc(), 1);
        c();
        c();
        var Gle;
        (function(t) {
          t.codec = () => Xe({ 1: { name: "key", codec: ye, optional: true }, 2: { name: "value", codec: ye, optional: true }, 3: { name: "author", codec: ye, optional: true }, 4: { name: "signature", codec: ye, optional: true }, 5: { name: "timeReceived", codec: pn, optional: true } }), t.encode = (e) => Qe(e, t.codec()), t.decode = (e) => Ye(e, t.codec());
        })(Gle || (Gle = {}));
        var xf;
        (function(t) {
          let e;
          (function(s) {
            s.PUT_VALUE = "PUT_VALUE", s.GET_VALUE = "GET_VALUE", s.ADD_PROVIDER = "ADD_PROVIDER", s.GET_PROVIDERS = "GET_PROVIDERS", s.FIND_NODE = "FIND_NODE", s.PING = "PING";
          })(e = t.MessageType || (t.MessageType = {}));
          let r;
          (function(s) {
            s[s.PUT_VALUE = 0] = "PUT_VALUE", s[s.GET_VALUE = 1] = "GET_VALUE", s[s.ADD_PROVIDER = 2] = "ADD_PROVIDER", s[s.GET_PROVIDERS = 3] = "GET_PROVIDERS", s[s.FIND_NODE = 4] = "FIND_NODE", s[s.PING = 5] = "PING";
          })(r || (r = {})), function(s) {
            s.codec = () => xi(r);
          }(e = t.MessageType || (t.MessageType = {}));
          let n;
          (function(s) {
            s.NOT_CONNECTED = "NOT_CONNECTED", s.CONNECTED = "CONNECTED", s.CAN_CONNECT = "CAN_CONNECT", s.CANNOT_CONNECT = "CANNOT_CONNECT";
          })(n = t.ConnectionType || (t.ConnectionType = {}));
          let i2;
          (function(s) {
            s[s.NOT_CONNECTED = 0] = "NOT_CONNECTED", s[s.CONNECTED = 1] = "CONNECTED", s[s.CAN_CONNECT = 2] = "CAN_CONNECT", s[s.CANNOT_CONNECT = 3] = "CANNOT_CONNECT";
          })(i2 || (i2 = {})), function(s) {
            s.codec = () => xi(i2);
          }(n = t.ConnectionType || (t.ConnectionType = {}));
          let o;
          (function(s) {
            s.codec = () => Xe({ 1: { name: "id", codec: ye, optional: true }, 2: { name: "addrs", codec: ye, repeats: true }, 3: { name: "connection", codec: t.ConnectionType.codec(), optional: true } }), s.encode = (a) => Qe(a, s.codec()), s.decode = (a) => Ye(a, s.codec());
          })(o = t.Peer || (t.Peer = {})), t.codec = () => Xe({ 1: { name: "type", codec: t.MessageType.codec(), optional: true }, 10: { name: "clusterLevelRaw", codec: cx, optional: true }, 2: { name: "key", codec: ye, optional: true }, 3: { name: "record", codec: ye, optional: true }, 8: { name: "closerPeers", codec: t.Peer.codec(), repeats: true }, 9: { name: "providerPeers", codec: t.Peer.codec(), repeats: true } }), t.encode = (s) => Qe(s, t.codec()), t.decode = (s) => Ye(s, t.codec());
        })(xf || (xf = {}));
        var fn = xf.MessageType, uNe = xf.ConnectionType, Yle = Object.keys(fn), Mr = class {
          constructor(e, r, n) {
            if (!(r instanceof Uint8Array))
              throw new Error("Key must be a Uint8Array");
            this.type = e, this.key = r, this.clusterLevelRaw = n, this.closerPeers = [], this.providerPeers = [], this.record = void 0;
          }
          get clusterLevel() {
            let e = this.clusterLevelRaw - 1;
            return e < 0 ? 0 : e;
          }
          set clusterLevel(e) {
            this.clusterLevelRaw = e;
          }
          serialize() {
            return xf.encode({ key: this.key, type: this.type, clusterLevelRaw: this.clusterLevelRaw, closerPeers: this.closerPeers.map(Wle), providerPeers: this.providerPeers.map(Wle), record: this.record == null ? void 0 : this.record.serialize() });
          }
          static deserialize(e) {
            let r = xf.decode(e), n = new Mr(r.type ?? xf.MessageType.PUT_VALUE, r.key ?? Uint8Array.from([]), r.clusterLevelRaw ?? 0);
            return n.closerPeers = r.closerPeers.map(jle), n.providerPeers = r.providerPeers.map(jle), r.record?.length != null && (n.record = Vr.deserialize(r.record)), n;
          }
        };
        function Wle(t) {
          return { id: t.id.toBytes(), addrs: (t.multiaddrs ?? []).map((r) => r.bytes), connection: uNe.CONNECTED };
        }
        function jle(t) {
          if (t.id == null)
            throw new Error("Invalid peer in message");
          return { id: Ir(t.id), multiaddrs: (t.addrs ?? []).map((e) => new j(e)), protocols: [] };
        }
        c();
        function Rk(t) {
          return { ...t, name: "SENDING_QUERY", type: 0, messageName: t.type, messageType: Yle.indexOf(t.type.toString()) };
        }
        function Q3(t) {
          return { ...t, name: "PEER_RESPONSE", type: 1, messageName: t.messageType, closer: t.closer != null ? t.closer : [], providers: t.providers != null ? t.providers : [] };
        }
        function X3(t) {
          return { ...t, name: "FINAL_PEER", type: 2 };
        }
        function Li(t) {
          return { ...t, name: "QUERY_ERROR", type: 3 };
        }
        function Ak(t) {
          return { ...t, name: "PROVIDER", type: 4 };
        }
        function Z3(t) {
          return { ...t, name: "VALUE", type: 5 };
        }
        function Tk(t) {
          return { ...t, name: "DIALING_PEER", type: 7 };
        }
        var yv = class extends Ue {
          constructor(e) {
            super(), this.components = new He();
            let { protocol: r, lan: n } = e;
            this.log = C(`libp2p:kad-dht:${n ? "lan" : "wan"}:network`), this.running = false, this.protocol = r;
          }
          init(e) {
            this.components = e;
          }
          async start() {
            this.running || (this.running = true);
          }
          async stop() {
            this.running = false;
          }
          isStarted() {
            return this.running;
          }
          async *sendRequest(e, r, n = {}) {
            if (!this.running)
              return;
            this.log("sending %s to %p", r.type, e), yield Tk({ peer: e }), yield Rk({ to: e, type: r.type });
            let i2;
            try {
              i2 = (await (await this.components.getConnectionManager().openConnection(e, n)).newStream(this.protocol, n)).stream;
              let a = await this._writeReadMessage(i2, r.serialize(), n);
              yield Q3({ from: e, messageType: a.type, closer: a.closerPeers, providers: a.providerPeers, record: a.record });
            } catch (o) {
              yield Li({ from: e, error: o });
            } finally {
              i2?.close();
            }
          }
          async *sendMessage(e, r, n = {}) {
            if (!this.running)
              return;
            this.log("sending %s to %p", r.type, e), yield Tk({ peer: e }), yield Rk({ to: e, type: r.type });
            let i2;
            try {
              i2 = (await (await this.components.getConnectionManager().openConnection(e, n)).newStream(this.protocol, n)).stream, await this._writeMessage(i2, r.serialize(), n), yield Q3({ from: e, messageType: r.type });
            } catch (o) {
              yield Li({ from: e, error: o });
            } finally {
              i2?.close();
            }
          }
          async _writeMessage(e, r, n) {
            n.signal != null && (e = as(e, n.signal)), await Te([r], kr(), e, Xle.default);
          }
          async _writeReadMessage(e, r, n) {
            n.signal != null && (e = as(e, n.signal));
            let i2 = await Te([r], kr(), e, Er(), async (s) => {
              let a = await (0, Zle.default)(s);
              if (a != null)
                return a;
              throw (0, Qle.default)(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
            }), o = Mr.deserialize(i2);
            return o.closerPeers.forEach((s) => {
              this.dispatchEvent(new ee("peer", { detail: s }));
            }), o.providerPeers.forEach((s) => {
              this.dispatchEvent(new ee("peer", { detail: s }));
            }), o;
          }
        };
        c();
        var wv = w(K(), 1);
        yr();
        c();
        var bm = w(K(), 1);
        me();
        vr();
        yr();
        function _m(t, e) {
          let r = e.key, i2 = M(r).split("/");
          if (i2.length < 3)
            return;
          let o = t[i2[1].toString()];
          if (o == null) {
            let s = "Invalid record keytype";
            throw (0, bm.default)(new Error(s), "ERR_INVALID_RECORD_KEY_TYPE");
          }
          return o(r, e.value);
        }
        var lNe = async (t, e) => {
          if (!(t instanceof Uint8Array))
            throw (0, bm.default)(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
          if (t.byteLength < 5)
            throw (0, bm.default)(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
          if (M(t.subarray(0, 4)) !== "/pk/")
            throw (0, bm.default)(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
          let n = t.slice(4), i2 = await xe.digest(e);
          if (!Ce(n, i2.bytes))
            throw (0, bm.default)(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
        }, Jle = { pk: lNe };
        c();
        var gv = w(K(), 1);
        me();
        function efe(t, e, r) {
          if (r.length === 0) {
            let s = "No records given";
            throw (0, gv.default)(new Error(s), "ERR_NO_RECORDS_RECEIVED");
          }
          let i2 = M(e).split("/");
          if (i2.length < 3) {
            let s = "Record key does not have a selector function";
            throw (0, gv.default)(new Error(s), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
          }
          let o = t[i2[1].toString()];
          if (o == null) {
            let s = `Unrecognized key prefix: ${i2[1]}`;
            throw (0, gv.default)(new Error(s), "ERR_UNRECOGNIZED_KEY_PREFIX");
          }
          return r.length === 1 ? 0 : o(e, r);
        }
        function fNe(t, e) {
          return 0;
        }
        var tfe = { pk: fNe };
        var rfe = w(n5(), 1), nfe = w(ei(), 1);
        var Ev = class {
          constructor(e) {
            this.components = new He();
            let { validators: r, selectors: n, peerRouting: i2, queryManager: o, routingTable: s, network: a, lan: u } = e;
            this.log = C(`libp2p:kad-dht:${u ? "lan" : "wan"}:content-fetching`), this.validators = r, this.selectors = n, this.peerRouting = i2, this.queryManager = o, this.routingTable = s, this.network = a;
          }
          init(e) {
            this.components = e;
          }
          async putLocal(e, r) {
            let n = xu(e);
            await this.components.getDatastore().put(n, r);
          }
          async getLocal(e) {
            this.log("getLocal %b", e);
            let r = xu(e);
            this.log("fetching record for key %k", r);
            let n = await this.components.getDatastore().get(r);
            this.log("found %k in local datastore", r);
            let i2 = Vr.deserialize(n);
            return await _m(this.validators, i2), i2;
          }
          async *sendCorrectionRecord(e, r, n, i2 = {}) {
            this.log("sendCorrection for %b", e);
            let o = await wk(e, n);
            for (let { value: s, from: a } of r) {
              if (Ce(s, n)) {
                this.log("record was ok");
                continue;
              }
              if (this.components.getPeerId().equals(a)) {
                try {
                  let f = xu(e);
                  this.log(`Storing corrected record for key ${f.toString()}`), await this.components.getDatastore().put(f, o);
                } catch (f) {
                  this.log.error("Failed error correcting self", f);
                }
                continue;
              }
              let u = false, l = new Mr(fn.PUT_VALUE, e, 0);
              l.record = Vr.deserialize(o);
              for await (let f of this.network.sendRequest(a, l, i2))
                f.name === "PEER_RESPONSE" && f.record != null && Ce(f.record.value, Vr.deserialize(o).value) && (u = true), yield f;
              u || (yield Li({ from: a, error: (0, wv.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") })), this.log.error("Failed error correcting entry");
            }
          }
          async *put(e, r, n = {}) {
            this.log("put key %b value %b", e, r);
            let i2 = await wk(e, r), o = xu(e);
            this.log(`storing record for key ${o.toString()}`), await this.components.getDatastore().put(o, i2), yield* Te(this.peerRouting.getClosestPeers(e, { signal: n.signal }), (s) => (0, nfe.default)(s, (a) => async () => {
              if (a.name !== "FINAL_PEER")
                return [a];
              let u = [], l = new Mr(fn.PUT_VALUE, e, 0);
              l.record = Vr.deserialize(i2), this.log("send put to %p", a.peer.id);
              for await (let f of this.network.sendRequest(a.peer.id, l, n))
                u.push(f), f.name === "PEER_RESPONSE" && (f.record != null && Ce(f.record.value, Vr.deserialize(i2).value) || u.push(Li({ from: a.peer.id, error: (0, wv.default)(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID") })));
              return u;
            }), (s) => (0, rfe.default)(s, { ordered: false, concurrency: 3 }), async function* (s) {
              for await (let a of s)
                yield* a;
            });
          }
          async *get(e, r = {}) {
            this.log("get %b", e);
            let n = [];
            for await (let a of this.getMany(e, r))
              a.name === "VALUE" && n.push(a), yield a;
            if (n.length === 0)
              return;
            let i2 = n.map((a) => a.value), o = 0;
            try {
              o = efe(this.selectors, e, i2);
            } catch (a) {
              if (a.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")
                throw a;
            }
            let s = i2[o];
            if (this.log("GetValue %b %b", e, s), s == null)
              throw (0, wv.default)(new Error("best value was not found"), "ERR_NOT_FOUND");
            yield* this.sendCorrectionRecord(e, n, s, r), yield n[o];
          }
          async *getMany(e, r = {}) {
            this.log("getMany values for %b", e);
            try {
              let a = await this.getLocal(e);
              yield Z3({ value: a.value, from: this.components.getPeerId() });
            } catch (a) {
              this.log("error getting local value for %b", e, a);
            }
            let n = await uc(e), i2 = this.routingTable.closestPeers(n);
            this.log("found %d peers in routing table", i2.length);
            let o = this, s = async function* ({ peer: a, signal: u }) {
              for await (let l of o.peerRouting.getValueOrPeers(a, e, { signal: u }))
                yield l, l.name === "PEER_RESPONSE" && l.record != null && (yield Z3({ from: a, value: l.record.value }));
            };
            yield* this.queryManager.run(e, i2, s, r);
          }
        };
        c();
        var ife = w(n5(), 1), ofe = w(ei(), 1);
        var bv = class {
          constructor(e) {
            this.components = new He();
            let { network: r, peerRouting: n, queryManager: i2, routingTable: o, providers: s, lan: a } = e;
            this.log = C(`libp2p:kad-dht:${a ? "lan" : "wan"}:content-routing`), this.network = r, this.peerRouting = n, this.queryManager = i2, this.routingTable = o, this.providers = s;
          }
          init(e) {
            this.components = e;
          }
          async *provide(e, r, n = {}) {
            this.log("provide %s", e), await this.providers.addProvider(e, this.components.getPeerId());
            let i2 = new Mr(fn.ADD_PROVIDER, e.bytes, 0);
            i2.providerPeers = [{ id: this.components.getPeerId(), multiaddrs: r, protocols: [] }];
            let o = 0, s = (a) => async () => {
              if (a.name !== "FINAL_PEER")
                return [a];
              let u = [];
              this.log("putProvider %s to %p", e, a.peer.id);
              try {
                this.log("sending provider record for %s to %p", e, a.peer.id);
                for await (let l of this.network.sendMessage(a.peer.id, i2, n))
                  l.name === "PEER_RESPONSE" && (this.log("sent provider record for %s to %p", e, a.peer.id), o++), u.push(l);
              } catch (l) {
                this.log.error("error sending provide record to peer %p", a.peer.id, l), u.push(Li({ from: a.peer.id, error: l }));
              }
              return u;
            };
            yield* Te(this.peerRouting.getClosestPeers(e.multihash.bytes, n), (a) => (0, ofe.default)(a, (u) => s(u)), (a) => (0, ife.default)(a, { ordered: false, concurrency: 3 }), async function* (a) {
              for await (let u of a)
                yield* u;
            }), this.log("sent provider records to %d peers", o);
          }
          async *findProviders(e, r) {
            let n = this.routingTable.kBucketSize, i2 = e.multihash.bytes, o = await uc(i2), s = this;
            this.log("findProviders %c", e);
            let a = await this.providers.getProviders(e);
            if (a.length > 0) {
              let f = [];
              for (let h of a.slice(0, n))
                f.push({ id: h, multiaddrs: (await this.components.getPeerStore().addressBook.get(h) ?? []).map((p) => p.multiaddr), protocols: [] });
              yield Q3({ from: this.components.getPeerId(), messageType: fn.GET_PROVIDERS, providers: f }), yield Ak({ from: this.components.getPeerId(), providers: f });
            }
            if (a.length >= n)
              return;
            let u = async function* ({ peer: f, signal: h }) {
              let p = new Mr(fn.GET_PROVIDERS, i2, 0);
              yield* s.network.sendRequest(f, p, { signal: h });
            }, l = new Set(a.map((f) => f.toString()));
            for await (let f of this.queryManager.run(i2, this.routingTable.closestPeers(o), u, r))
              if (yield f, f.name === "PEER_RESPONSE") {
                this.log("Found %d provider entries for %c and %d closer peers", f.providers.length, e, f.closer.length);
                let h = [];
                for (let p of f.providers)
                  l.has(p.id.toString()) || (l.add(p.id.toString()), h.push(p));
                if (h.length > 0 && (yield Ak({ from: f.from, providers: h })), l.size === n)
                  return;
              }
          }
        };
        c();
        var $d = w(K(), 1);
        me();
        c();
        var _v = class {
          constructor(e, r) {
            this.originDhtKey = e, this.capacity = r, this.peerDistances = [];
          }
          get length() {
            return this.peerDistances.length;
          }
          get peers() {
            return this.peerDistances.map((e) => e.peerId);
          }
          async add(e) {
            if (this.peerDistances.find((i2) => i2.peerId.equals(e)) != null)
              return;
            let r = await ko(e), n = { peerId: e, distance: Pc(this.originDhtKey, r) };
            this.peerDistances.push(n), this.peerDistances.sort((i2, o) => eh(i2.distance, o.distance)), this.peerDistances = this.peerDistances.slice(0, this.capacity);
          }
          async anyCloser(e) {
            if (e.length === 0)
              return false;
            if (this.length === 0)
              return true;
            let r = await Promise.all(e.map(ko)), n = this.peerDistances[this.peerDistances.length - 1].distance;
            for (let i2 of r) {
              let o = Pc(this.originDhtKey, i2);
              if (eh(o, n) < 0)
                return true;
            }
            return false;
          }
        };
        var vv = class {
          constructor(e) {
            this.components = new He();
            let { routingTable: r, network: n, validators: i2, queryManager: o, lan: s } = e;
            this.routingTable = r, this.network = n, this.validators = i2, this.queryManager = o, this.log = C(`libp2p:kad-dht:${s ? "lan" : "wan"}:peer-routing`);
          }
          init(e) {
            this.components = e;
          }
          async findPeerLocal(e) {
            let r, n = await this.routingTable.find(e);
            if (n != null) {
              this.log("findPeerLocal found %p in routing table", e);
              try {
                r = await this.components.getPeerStore().get(n);
              } catch (i2) {
                if (i2.code !== "ERR_NOT_FOUND")
                  throw i2;
              }
            }
            if (r == null)
              try {
                r = await this.components.getPeerStore().get(e);
              } catch (i2) {
                if (i2.code !== "ERR_NOT_FOUND")
                  throw i2;
              }
            if (r != null)
              return this.log("findPeerLocal found %p in peer store", e), { id: r.id, multiaddrs: r.addresses.map((i2) => i2.multiaddr), protocols: [] };
          }
          async *_getValueSingle(e, r, n = {}) {
            let i2 = new Mr(fn.GET_VALUE, r, 0);
            yield* this.network.sendRequest(e, i2, n);
          }
          async *getPublicKeyFromNode(e, r = {}) {
            let n = Dle(e);
            for await (let i2 of this._getValueSingle(e, n, r))
              if (yield i2, i2.name === "PEER_RESPONSE" && i2.record != null) {
                let o = await sn(v6.marshalPublicKey({ bytes: i2.record.value }));
                if (!o.equals(e))
                  throw (0, $d.default)(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
                if (o.publicKey == null)
                  throw (0, $d.default)(new Error("public key missing"), "ERR_PUBLIC_KEY_MISSING");
                yield Z3({ from: e, value: o.publicKey });
              }
            throw (0, $d.default)(new Error(`Node not responding with its public key: ${e.toString()}`), "ERR_INVALID_RECORD");
          }
          async *findPeer(e, r = {}) {
            this.log("findPeer %p", e);
            let n = await this.findPeerLocal(e);
            if (n != null) {
              this.log("found local"), yield X3({ from: this.components.getPeerId(), peer: n });
              return;
            }
            let i2 = await ko(e), o = this.routingTable.closestPeers(i2);
            if (o.find((f) => f.equals(e)) != null)
              try {
                let f = await this.components.getPeerStore().get(e);
                this.log("found in peerStore"), yield X3({ from: this.components.getPeerId(), peer: { id: f.id, multiaddrs: f.addresses.map((h) => h.multiaddr), protocols: [] } });
                return;
              } catch (f) {
                if (f.code !== "ERR_NOT_FOUND")
                  throw f;
              }
            let a = this, u = async function* ({ peer: f, signal: h }) {
              let p = new Mr(fn.FIND_NODE, e.toBytes(), 0);
              for await (let d of a.network.sendRequest(f, p, { signal: h }))
                if (yield d, d.name === "PEER_RESPONSE") {
                  let m = d.closer.find((y) => y.id.equals(e));
                  m != null && (yield X3({ from: d.from, peer: m }));
                }
            }, l = false;
            for await (let f of this.queryManager.run(e.toBytes(), o, u, r))
              f.name === "FINAL_PEER" && (l = true), yield f;
            l || (yield Li({ from: this.components.getPeerId(), error: (0, $d.default)(new Error("Not found"), "ERR_NOT_FOUND") }));
          }
          async *getClosestPeers(e, r = {}) {
            this.log("getClosestPeers to %b", e);
            let n = await uc(e), i2 = this.routingTable.closestPeers(n), o = this, s = new _v(n, this.routingTable.kBucketSize);
            await Promise.all(i2.map(async (u) => await s.add(u)));
            let a = async function* ({ peer: u, signal: l }) {
              o.log("closerPeersSingle %s from %p", M(e, "base32"), u);
              let f = new Mr(fn.FIND_NODE, e, 0);
              yield* o.network.sendRequest(u, f, { signal: l });
            };
            for await (let u of this.queryManager.run(e, i2, a, r))
              yield u, u.name === "PEER_RESPONSE" && await Promise.all(u.closer.map(async (l) => await s.add(l.id)));
            this.log("found %d peers close to %b", s.length, e);
            for (let u of s.peers)
              yield X3({ from: this.components.getPeerId(), peer: { id: u, multiaddrs: (await this.components.getPeerStore().addressBook.get(u) ?? []).map((l) => l.multiaddr), protocols: [] } });
          }
          async *getValueOrPeers(e, r, n = {}) {
            for await (let i2 of this._getValueSingle(e, r, n)) {
              if (i2.name === "PEER_RESPONSE" && i2.record != null)
                try {
                  await this._verifyRecordOnline(i2.record);
                } catch {
                  let s = "invalid record received, discarded";
                  this.log(s), yield Li({ from: i2.from, error: (0, $d.default)(new Error(s), "ERR_INVALID_RECORD") });
                  continue;
                }
              yield i2;
            }
          }
          async _verifyRecordOnline(e) {
            if (e.timeReceived == null)
              throw (0, $d.default)(new Error("invalid record received"), "ERR_INVALID_RECORD");
            await _m(this.validators, new Vr(e.key, e.value, e.timeReceived));
          }
          async getCloserPeersOffline(e, r) {
            let n = await uc(e), i2 = this.routingTable.closestPeers(n), o = [];
            for (let s of i2)
              if (!s.equals(r))
                try {
                  let a = await this.components.getPeerStore().addressBook.get(s), u = await this.components.getPeerStore().protoBook.get(s);
                  o.push({ id: s, multiaddrs: a.map((l) => l.multiaddr), protocols: u });
                } catch (a) {
                  if (a.code !== "ERR_NOT_FOUND")
                    throw a;
                }
            return o.length > 0 ? this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p", o.length, e, r) : this.log("getCloserPeersOffline could not find peer closer to %b than %p", e, r), o;
          }
        };
        c();
        var sfe = w(Mp(), 1), Ik = w(ai(), 1);
        me();
        var Tu = C("libp2p:kad-dht:providers"), Sv = class {
          constructor(e = {}) {
            this.components = new He();
            let { cacheSize: r, cleanupInterval: n, provideValidity: i2 } = e;
            this.cleanupInterval = n ?? 36e5, this.provideValidity = i2 ?? 864e5, this.cache = (0, sfe.default)(r ?? 256), this.syncQueue = new Au({ concurrency: 1 }), this.started = false;
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.started;
          }
          async start() {
            this.started || (this.started = true, this.cleaner = setInterval(() => {
              this._cleanup().catch((e) => {
                Tu.error(e);
              });
            }, this.cleanupInterval));
          }
          async stop() {
            this.started = false, this.cleaner != null && (clearInterval(this.cleaner), this.cleaner = void 0);
          }
          async _cleanup() {
            return await this.syncQueue.add(async () => {
              let e = Date.now(), r = 0, n = 0, i2 = /* @__PURE__ */ new Map(), o = this.components.getDatastore().batch(), s = this.components.getDatastore().query({ prefix: yk });
              for await (let a of s)
                try {
                  let { cid: u, peerId: l } = afe(a.key), f = cfe(a.value).getTime(), h = Date.now(), p = h - f, d = p > this.provideValidity;
                  if (Tu("comparing: %d - %d = %d > %d %s", h, f, p, this.provideValidity, d ? "(expired)" : ""), d) {
                    n++, o.delete(a.key);
                    let m = i2.get(u) ?? /* @__PURE__ */ new Set();
                    m.add(l), i2.set(u, m);
                  }
                  r++;
                } catch (u) {
                  Tu.error(u.message);
                }
              i2.size > 0 ? (Tu("deleting %d / %d entries", n, r), await o.commit()) : Tu("nothing to delete");
              for (let [a, u] of i2) {
                let l = J3(a), f = this.cache.get(l);
                if (f != null) {
                  for (let h of u)
                    f.delete(h);
                  f.size === 0 ? this.cache.remove(l) : this.cache.set(l, f);
                }
              }
              Tu("Cleanup successful (%dms)", Date.now() - e);
            });
          }
          async _getProvidersMap(e) {
            let r = J3(e), n = this.cache.get(r);
            return n == null && (n = await yNe(this.components.getDatastore(), e), this.cache.set(r, n)), n;
          }
          async addProvider(e, r) {
            return await this.syncQueue.add(async () => {
              Tu("%p provides %s", r, e);
              let n = await this._getProvidersMap(e);
              Tu("loaded %s provs", n.size);
              let i2 = new Date();
              n.set(r.toString(), i2);
              let o = J3(e);
              this.cache.set(o, n), await mNe(this.components.getDatastore(), e, r, i2);
            });
          }
          async getProviders(e) {
            return await this.syncQueue.add(async () => (Tu("get providers for %s", e), [...(await this._getProvidersMap(e)).keys()].map((n) => ue(n))));
          }
        };
        function J3(t) {
          let e = typeof t == "string" ? t : M(t.multihash.bytes, "base32");
          return `${yk}/${e}`;
        }
        async function mNe(t, e, r, n) {
          let i2 = [J3(e), "/", r.toString()].join(""), o = new ae(i2), s = Uint8Array.from(Ik.default.encode(n.getTime()));
          return await t.put(o, s);
        }
        function afe(t) {
          let e = t.toString().split("/");
          if (e.length !== 5)
            throw new Error(`incorrectly formatted provider entry key in datastore: ${t.toString()}`);
          return { cid: e[3], peerId: e[4] };
        }
        async function yNe(t, e) {
          let r = /* @__PURE__ */ new Map(), n = t.query({ prefix: J3(e) });
          for await (let i2 of n) {
            let { peerId: o } = afe(i2.key);
            r.set(o, cfe(i2.value));
          }
          return r;
        }
        function cfe(t) {
          return new Date(Ik.default.decode(t));
        }
        c();
        var pfe = w($o(), 1), mfe = w(Vi(), 1);
        me();
        c();
        me();
        var ufe = w(K(), 1);
        var lfe = w($o(), 1), ffe = w(Vi(), 1);
        var gNe = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
        async function* hfe(t) {
          let { key: e, startingPeer: r, ourPeerId: n, signal: i2, query: o, alpha: s, pathIndex: a, numPaths: u, cleanUp: l, queryFuncTimeout: f, log: h } = t, p = new Au({ concurrency: s }), d = await uc(e), m = /* @__PURE__ */ new Set();
          function y(g, E) {
            if (g == null)
              return;
            m.add(g.toString());
            let b = BigInt("0x" + M(Pc(E, d), "base16"));
            p.add(async () => {
              let v, S = [i2];
              f != null && (v = new lfe.TimeoutController(f), S.push(v.signal));
              let x = (0, ffe.anySignal)(S);
              try {
                for await (let T of o({ key: e, peer: g, signal: x, pathIndex: a, numPaths: u })) {
                  if (x.aborted)
                    return;
                  if (T.name === "PEER_RESPONSE")
                    for (let R of T.closer) {
                      if (m.has(R.id.toString())) {
                        h("already seen %p in query", R.id);
                        continue;
                      }
                      if (n.equals(R.id)) {
                        h("not querying ourselves");
                        continue;
                      }
                      let O = await ko(R.id);
                      if (BigInt("0x" + M(Pc(O, d), "base16")) > b) {
                        h("skipping %p as they are not closer to %b than %p", R.id, e, g);
                        continue;
                      }
                      h("querying closer peer %p", R.id), y(R.id, O);
                    }
                  p.emit("completed", T);
                }
                v?.clear();
              } catch (T) {
                i2.aborted ? p.emit("error", T) : p.emit("completed", Li({ from: g, error: T }));
              } finally {
                v?.clear();
              }
            }, { priority: gNe - b }).catch((v) => {
              h.error(v);
            });
          }
          y(r, await ko(r)), yield* wNe(p, i2, l, h);
        }
        async function* wNe(t, e, r, n) {
          let i2 = Ar(), o = true, s = [], a = () => {
            !o || (n("clean up queue, results %d, queue size %d, pending tasks %d", s.length, t.size, t.pending), o = false, t.clear(), s.splice(0, s.length));
          };
          for (t.on("completed", (u) => {
            s.push(u), i2.resolve();
          }), t.on("error", (u) => {
            n("queue error", u), a(), i2.reject(u);
          }), t.on("idle", () => {
            n("queue idle"), o = false, i2.resolve();
          }), e.addEventListener("abort", () => {
            n("abort queue");
            let u = o;
            a(), u && i2.reject((0, ufe.default)(new Error("Query aborted"), "ERR_QUERY_ABORTED"));
          }), r.addEventListener("cleanup", () => {
            a(), i2.resolve();
          }); o; )
            for (await i2.promise, i2 = Ar(); s.length > 0; ) {
              let u = s.shift();
              u != null && (yield u);
            }
          yield* s;
        }
        var yfe = w(Fc(), 1), e4 = w(In(), 1);
        var dfe = "running-queries", Rv = class {
          constructor(e) {
            this.components = new He();
            let { lan: r = false, disjointPaths: n = 20, alpha: i2 = 3 } = e;
            this.disjointPaths = n ?? 20, this.controllers = /* @__PURE__ */ new Set(), this.running = false, this.alpha = i2 ?? 3, this.lan = r, this.queries = 0;
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.running;
          }
          async start() {
            this.running = true;
          }
          async stop() {
            this.running = false;
            for (let e of this.controllers)
              e.abort();
            this.controllers.clear();
          }
          async *run(e, r, n, i2 = {}) {
            if (!this.running)
              throw new Error("QueryManager not started");
            let o;
            if (i2.signal == null) {
              o = new pfe.TimeoutController(Ple), i2.signal = o.signal;
              try {
                e4.setMaxListeners != null && (0, e4.setMaxListeners)(1 / 0, o.signal);
              } catch {
              }
            }
            let s = new AbortController();
            this.controllers.add(s);
            let a = [s.signal];
            i2.signal != null && a.push(i2.signal);
            let u = (0, mfe.anySignal)(a);
            try {
              e4.setMaxListeners != null && (0, e4.setMaxListeners)(1 / 0, u);
            } catch {
            }
            let l = C(`libp2p:kad-dht:${this.lan ? "lan" : "wan"}:query:` + M(e, "base58btc")), f = r.slice(0, Math.min(this.disjointPaths, r.length)), h = Date.now(), p = new Ue();
            try {
              if (l("query:start"), this.queries++, this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: dfe, value: this.queries }), r.length === 0) {
                l.error("Running query with no peers");
                return;
              }
              let d = f.map((m, y) => hfe({ key: e, startingPeer: m, ourPeerId: this.components.getPeerId(), signal: u, query: n, pathIndex: y, numPaths: f.length, alpha: this.alpha, cleanUp: p, queryFuncTimeout: i2.queryFuncTimeout, log: l }));
              for await (let m of (0, yfe.default)(...d))
                yield m, m.name === "QUERY_ERROR" && l("error", m.error);
            } catch (d) {
              if (!(!this.running && d.code === "ERR_QUERY_ABORTED"))
                throw d;
            } finally {
              this.controllers.delete(s), o?.clear(), this.queries--, this.components.getMetrics()?.updateComponentMetric({ system: "libp2p", component: `kad-dht-${this.lan ? "lan" : "wan"}`, metric: dfe, value: this.queries }), p.dispatchEvent(new ee("cleanup")), l("query:done in %dms", Date.now() - h);
            }
          }
        };
        c();
        c();
        te();
        var Ck = w(K(), 1);
        var t4 = C("libp2p:kad-dht:rpc:handlers:add-provider"), Av = class {
          constructor(e) {
            let { providers: r } = e;
            this.providers = r;
          }
          init() {
          }
          async handle(e, r) {
            if (t4("start"), r.key == null || r.key.length === 0)
              throw (0, Ck.default)(new Error("Missing key"), "ERR_MISSING_KEY");
            let n;
            try {
              n = I.decode(r.key);
            } catch {
              throw (0, Ck.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
            }
            (r.providerPeers == null || r.providerPeers.length === 0) && t4.error("no providers found in message"), await Promise.all(r.providerPeers.map(async (i2) => {
              if (!i2.id.equals(e)) {
                t4("invalid provider peer %p from %p", i2.id, e);
                return;
              }
              if (i2.multiaddrs.length < 1) {
                t4("no valid addresses for provider %p. Ignore", e);
                return;
              }
              t4("received provider %p for %s (addrs %s)", e, n, i2.multiaddrs.map((o) => o.toString())), await this.providers.addProvider(n, i2.id);
            }));
          }
        };
        c();
        var gfe = C("libp2p:kad-dht:rpc:handlers:find-node"), Tv = class {
          constructor(e) {
            this.components = new He();
            let { peerRouting: r, lan: n } = e;
            this.peerRouting = r, this.lan = Boolean(n);
          }
          init(e) {
            this.components = e;
          }
          async handle(e, r) {
            gfe("incoming request from %p for peers closer to %b", e, r.key);
            let n = [];
            Ce(this.components.getPeerId().toBytes(), r.key) ? n = [{ id: this.components.getPeerId(), multiaddrs: this.components.getAddressManager().getAddresses().map((o) => o.decapsulateCode(Tn("p2p").code)), protocols: [] }] : n = await this.peerRouting.getCloserPeersOffline(r.key, e), n = n.map(this.lan ? gm : ym).filter(({ multiaddrs: o }) => o.length);
            let i2 = new Mr(r.type, new Uint8Array(0), r.clusterLevel);
            return n.length > 0 ? i2.closerPeers = n : gfe("could not find any peers closer to %b than %p", r.key, e), i2;
          }
        };
        c();
        te();
        var Efe = w(K(), 1);
        var wfe = C("libp2p:kad-dht:rpc:handlers:get-providers"), Iv = class {
          constructor(e) {
            this.components = new He();
            let { peerRouting: r, providers: n, lan: i2 } = e;
            this.peerRouting = r, this.providers = n, this.lan = Boolean(i2);
          }
          init(e) {
            this.components = e;
          }
          async handle(e, r) {
            let n;
            try {
              n = I.decode(r.key);
            } catch {
              throw (0, Efe.default)(new Error("Invalid CID"), "ERR_INVALID_CID");
            }
            wfe("%p asking for providers for %s", e, n);
            let [i2, o] = await Promise.all([this.providers.getProviders(n), this.peerRouting.getCloserPeersOffline(r.key, e)]), s = await this._getPeers(i2), a = await this._getPeers(o.map(({ id: l }) => l)), u = new Mr(r.type, r.key, r.clusterLevel);
            return s.length > 0 && (u.providerPeers = s), a.length > 0 && (u.closerPeers = a), wfe("got %s providers %s closerPeers", s.length, a.length), u;
          }
          async _getAddresses(e) {
            return (await this.components.getPeerStore().addressBook.get(e)).map((n) => n.multiaddr);
          }
          async _getPeers(e) {
            let r = [], n = this.lan ? gm : ym;
            for (let i2 of e) {
              let o = n({ id: i2, multiaddrs: await this._getAddresses(i2), protocols: [] });
              o.multiaddrs.length > 0 && r.push(o);
            }
            return r;
          }
        };
        c();
        var Cv = w(K(), 1);
        var Sm = C("libp2p:kad-dht:rpc:handlers:get-value"), Pv = class {
          constructor(e) {
            this.components = new He();
            let { peerRouting: r } = e;
            this.peerRouting = r;
          }
          init(e) {
            this.components = e;
          }
          async handle(e, r) {
            let n = r.key;
            if (Sm("%p asked for key %b", e, n), n == null || n.length === 0)
              throw (0, Cv.default)(new Error("Invalid key"), "ERR_INVALID_KEY");
            let i2 = new Mr(fn.GET_VALUE, n, r.clusterLevel);
            if (kle(n)) {
              Sm("is public key");
              let a = Nle(n), u;
              try {
                let l = await this.components.getPeerStore().keyBook.get(a);
                if (l == null)
                  throw (0, Cv.default)(new Error("No public key found in key book"), "ERR_NOT_FOUND");
                u = l;
              } catch (l) {
                if (l.code !== "ERR_NOT_FOUND")
                  throw l;
              }
              if (u != null)
                return Sm("returning found public key"), i2.record = new Vr(n, u, new Date()), i2;
            }
            let [o, s] = await Promise.all([this._checkLocalDatastore(n), this.peerRouting.getCloserPeersOffline(r.key, e)]);
            return o != null && (Sm("had record for %b in local datastore", n), i2.record = o), s.length > 0 && (Sm("had %s closer peers in routing table", s.length), i2.closerPeers = s), i2;
          }
          async _checkLocalDatastore(e) {
            Sm("checkLocalDatastore looking for %b", e);
            let r = xu(e), n;
            try {
              n = await this.components.getDatastore().get(r);
            } catch (o) {
              if (o.code === "ERR_NOT_FOUND")
                return;
              throw o;
            }
            let i2 = Vr.deserialize(n);
            if (i2 == null)
              throw (0, Cv.default)(new Error("Invalid record"), "ERR_INVALID_RECORD");
            if (i2.timeReceived == null || Date.now() - i2.timeReceived.getTime() > 1296e5) {
              await this.components.getDatastore().delete(r);
              return;
            }
            return i2;
          }
        };
        c();
        var bNe = C("libp2p:kad-dht:rpc:handlers:ping"), Dv = class {
          async handle(e, r) {
            return bNe("ping from %p", e), r;
          }
          init() {
          }
        };
        c();
        var bfe = w(K(), 1);
        var kv = class {
          constructor(e) {
            this.components = new He();
            let { validators: r } = e;
            this.log = C("libp2p:kad-dht:rpc:handlers:put-value"), this.validators = r;
          }
          init(e) {
            this.components = e;
          }
          async handle(e, r) {
            let n = r.key;
            this.log("%p asked us to store value for key %b", e, n);
            let i2 = r.record;
            if (i2 == null) {
              let o = `Empty record from: ${e.toString()}`;
              throw this.log.error(o), (0, bfe.default)(new Error(o), "ERR_EMPTY_RECORD");
            }
            try {
              await _m(this.validators, i2), i2.timeReceived = new Date();
              let o = xu(i2.key);
              await this.components.getDatastore().put(o, i2.serialize()), this.log("put record for %b into datastore under key %k", n, o);
            } catch (o) {
              this.log("did not put record for key %b into datastore %o", n, o);
            }
            return r;
          }
        };
        var Nv = class {
          constructor(e) {
            let { providers: r, peerRouting: n, validators: i2, lan: o } = e;
            this.log = C("libp2p:kad-dht:rpc"), this.routingTable = e.routingTable, this.handlers = { [fn.GET_VALUE]: new Pv({ peerRouting: n }), [fn.PUT_VALUE]: new kv({ validators: i2 }), [fn.FIND_NODE]: new Tv({ peerRouting: n, lan: o }), [fn.ADD_PROVIDER]: new Av({ providers: r }), [fn.GET_PROVIDERS]: new Iv({ peerRouting: n, providers: r, lan: o }), [fn.PING]: new Dv() };
          }
          init(e) {
            for (let r of Object.values(this.handlers))
              r.init(e);
          }
          async handleMessage(e, r) {
            try {
              await this.routingTable.add(e);
            } catch (i2) {
              this.log.error("Failed to update the kbucket store", i2);
            }
            let n = this.handlers[r.type];
            if (n == null) {
              this.log.error(`no handler found for message type: ${r.type}`);
              return;
            }
            return await n.handle(e, r);
          }
          onIncomingStream(e) {
            Promise.resolve().then(async () => {
              let { stream: r, connection: n } = e, i2 = n.remotePeer;
              try {
                await this.routingTable.add(i2);
              } catch (s) {
                this.log.error(s);
              }
              let o = this;
              await Te(r, Er(), async function* (s) {
                for await (let a of s) {
                  let u = Mr.deserialize(a);
                  o.log("incoming %s from %p", u.type, i2);
                  let l = await o.handleMessage(i2, u);
                  l != null && (yield l.serialize());
                }
              }, kr(), r);
            }).catch((r) => {
              this.log.error(r);
            });
          }
        };
        c();
        var Ov = class extends Ue {
          constructor(e) {
            super(), this.components = new He();
            let { protocol: r, lan: n } = e;
            this.log = C(`libp2p:kad-dht:topology-listener:${n ? "lan" : "wan"}`), this.running = false, this.protocol = r;
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.running;
          }
          async start() {
            if (this.running)
              return;
            this.running = true;
            let e = g1({ onConnect: (r) => {
              this.log("observed peer %p with protocol %s", r, this.protocol), this.dispatchEvent(new ee("peer", { detail: r }));
            } });
            this.registrarId = await this.components.getRegistrar().register(this.protocol, e);
          }
          stop() {
            this.running = false, this.registrarId != null && (this.components.getRegistrar().unregister(this.registrarId), this.registrarId = void 0);
          }
        };
        c();
        var Pk = w(In(), 1), _fe = w(h0(), 1), vfe = w(Jy(), 1);
        var Sfe = w($o(), 1), xfe = w(Vi(), 1);
        var Lv = class {
          constructor(e) {
            this.components = new He();
            let { peerRouting: r, lan: n, count: i2, interval: o, queryTimeout: s } = e;
            this.log = C(`libp2p:kad-dht:${n ? "lan" : "wan"}:query-self`), this.running = false, this.peerRouting = r, this.count = i2 ?? 20, this.interval = o ?? Ale, this.queryTimeout = s ?? Tle;
          }
          init(e) {
            this.components = e;
          }
          isStarted() {
            return this.running;
          }
          async start() {
            this.running || (this.running = true, this._querySelf());
          }
          async stop() {
            this.running = false, this.timeoutId != null && clearTimeout(this.timeoutId), this.controller != null && this.controller.abort();
          }
          _querySelf() {
            Promise.resolve().then(async () => {
              let e = new Sfe.TimeoutController(this.queryTimeout);
              try {
                this.controller = new AbortController();
                let r = (0, xfe.anySignal)([this.controller.signal, e.signal]);
                try {
                  Pk.setMaxListeners != null && (0, Pk.setMaxListeners)(1 / 0, r);
                } catch {
                }
                let n = await Te(this.peerRouting.getClosestPeers(this.components.getPeerId().toBytes(), { signal: r }), (i2) => (0, _fe.default)(i2, this.count), async (i2) => await (0, vfe.default)(i2));
                this.log("query ran successfully - found %d peers", n);
              } catch (r) {
                this.log("query error", r);
              } finally {
                this.timeoutId = setTimeout(this._querySelf.bind(this), this.interval), e.clear();
              }
            }).catch((e) => {
              this.log("query error", e);
            });
          }
        };
        var r4 = class extends Ue {
          constructor(e) {
            super(), this.components = new He();
            let { kBucketSize: r, clientMode: n, validators: i2, selectors: o, querySelfInterval: s, lan: a, protocolPrefix: u, pingTimeout: l, pingConcurrency: f } = e;
            this.running = false, this.lan = Boolean(a), this.log = C(`libp2p:kad-dht:${a === true ? "lan" : "wan"}`), this.protocol = `${u ?? Sle}${a === true ? vle : ""}${xle}`, this.kBucketSize = r ?? 20, this.clientMode = n ?? true, this.routingTable = new dv({ kBucketSize: r, lan: this.lan, pingTimeout: l, pingConcurrency: f, protocol: this.protocol }), this.providers = new Sv(), this.validators = { ...Jle, ...i2 }, this.selectors = { ...tfe, ...o }, this.network = new yv({ protocol: this.protocol, lan: this.lan }), this.queryManager = new Rv({ disjointPaths: Math.ceil(this.kBucketSize / 2), lan: a }), this.peerRouting = new vv({ routingTable: this.routingTable, network: this.network, validators: this.validators, queryManager: this.queryManager, lan: this.lan }), this.contentFetching = new Ev({ validators: this.validators, selectors: this.selectors, peerRouting: this.peerRouting, queryManager: this.queryManager, routingTable: this.routingTable, network: this.network, lan: this.lan }), this.contentRouting = new bv({ network: this.network, peerRouting: this.peerRouting, queryManager: this.queryManager, routingTable: this.routingTable, providers: this.providers, lan: this.lan }), this.routingTableRefresh = new mv({ peerRouting: this.peerRouting, routingTable: this.routingTable, lan: this.lan }), this.rpc = new Nv({ routingTable: this.routingTable, providers: this.providers, peerRouting: this.peerRouting, validators: this.validators, lan: this.lan }), this.topologyListener = new Ov({ protocol: this.protocol, lan: this.lan }), this.querySelf = new Lv({ peerRouting: this.peerRouting, interval: s, lan: this.lan }), this.network.addEventListener("peer", (h) => {
              let p = h.detail;
              this.onPeerConnect(p).catch((d) => {
                this.log.error("could not add %p to routing table", p.id, d);
              }), this.dispatchEvent(new ee("peer", { detail: p }));
            }), this.topologyListener.addEventListener("peer", (h) => {
              let p = h.detail;
              Promise.resolve().then(async () => {
                let d = await this.components.getPeerStore().addressBook.get(p), m = { id: p, multiaddrs: d.map((y) => y.multiaddr), protocols: [] };
                await this.onPeerConnect(m);
              }).catch((d) => {
                this.log.error("could not add %p to routing table", p, d);
              });
            });
          }
          get [rc]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/kad-dht";
          }
          init(e) {
            this.components = e, this.routingTable.init(e), this.providers.init(e), this.network.init(e), this.queryManager.init(e), this.peerRouting.init(e), this.contentFetching.init(e), this.contentRouting.init(e), this.routingTableRefresh.init(e), this.rpc.init(e), this.topologyListener.init(e), this.querySelf.init(e);
          }
          async onPeerConnect(e) {
            if (this.log("peer %p connected with protocols %s", e.id, e.protocols), this.lan ? e = gm(e) : e = ym(e), e.multiaddrs.length === 0) {
              this.log("ignoring %p as they do not have any %s addresses in %s", e.id, this.lan ? "private" : "public", e.multiaddrs.map((r) => r.toString()));
              return;
            }
            try {
              await this.routingTable.add(e.id);
            } catch (r) {
              this.log.error("could not add %p to routing table", e.id, r);
            }
          }
          isStarted() {
            return this.running;
          }
          async getMode() {
            return this.clientMode ? "client" : "server";
          }
          async setMode(e) {
            await this.components.getRegistrar().unhandle(this.protocol), e === "client" ? (this.log("enabling client mode"), this.clientMode = true) : (this.log("enabling server mode"), this.clientMode = false, await this.components.getRegistrar().handle(this.protocol, this.rpc.onIncomingStream.bind(this.rpc)));
          }
          async start() {
            this.running = true, await this.setMode(this.clientMode ? "client" : "server"), await Promise.all([this.providers.start(), this.queryManager.start(), this.network.start(), this.routingTable.start(), this.topologyListener.start(), this.querySelf.start()]), await this.routingTableRefresh.start();
          }
          async stop() {
            this.running = false, await Promise.all([this.providers.stop(), this.queryManager.stop(), this.network.stop(), this.routingTable.stop(), this.routingTableRefresh.stop(), this.topologyListener.stop(), this.querySelf.stop()]);
          }
          async *put(e, r, n = {}) {
            yield* this.contentFetching.put(e, r, n);
          }
          async *get(e, r = {}) {
            yield* this.contentFetching.get(e, r);
          }
          async *provide(e, r = {}) {
            yield* this.contentRouting.provide(e, this.components.getAddressManager().getAddresses(), r);
          }
          async *findProviders(e, r = {}) {
            yield* this.contentRouting.findProviders(e, r);
          }
          async *findPeer(e, r = {}) {
            yield* this.peerRouting.findPeer(e, r);
          }
          async *getClosestPeers(e, r = {}) {
            yield* this.peerRouting.getClosestPeers(e, r);
          }
          async refreshRoutingTable() {
            await this.routingTableRefresh.refreshTable(true);
          }
        };
        c();
        var xm = w(K(), 1), Gd = w(Fc(), 1);
        var _Ne = C("libp2p:kad-dht"), Bv = class extends Ue {
          constructor(e, r) {
            super(), this.components = new He(), this.wan = e, this.lan = r, this.wan.addEventListener("peer", (n) => {
              this.dispatchEvent(new ee("peer", { detail: n.detail }));
            }), this.lan.addEventListener("peer", (n) => {
              this.dispatchEvent(new ee("peer", { detail: n.detail }));
            });
          }
          get [rc]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/dual-kad-dht";
          }
          init(e) {
            this.components = e, this.wan.init(e), this.lan.init(e);
          }
          isStarted() {
            return this.wan.isStarted() && this.lan.isStarted();
          }
          async getMode() {
            return await this.wan.getMode();
          }
          async setMode(e) {
            await this.wan.setMode(e);
          }
          async start() {
            await Promise.all([this.lan.start(), this.wan.start()]);
          }
          async stop() {
            await Promise.all([this.lan.stop(), this.wan.stop()]);
          }
          async *put(e, r, n = {}) {
            for await (let i2 of (0, Gd.default)(this.lan.put(e, r, n), this.wan.put(e, r, n)))
              yield i2;
          }
          async *get(e, r = {}) {
            let n = false, i2 = false;
            for await (let o of (0, Gd.default)(this.lan.get(e, r), this.wan.get(e, r)))
              yield o, o.name === "DIALING_PEER" && (n = true), o.name === "VALUE" && (n = true, o.value != null && (i2 = true)), o.name === "SENDING_QUERY" && (n = true);
            if (!n)
              throw (0, xm.default)(new Error("No peers found in routing table!"), "ERR_NO_PEERS_IN_ROUTING_TABLE");
            i2 || (yield Li({ from: this.components.getPeerId(), error: (0, xm.default)(new Error("Not found"), "ERR_NOT_FOUND") }));
          }
          async *provide(e, r = {}) {
            let n = 0, i2 = 0, o = [], s = [this.lan];
            await this.wan.getMode() === "server" && s.push(this.wan);
            for await (let a of (0, Gd.default)(...s.map((u) => u.provide(e, r))))
              yield a, a.name === "SENDING_QUERY" && n++, a.name === "QUERY_ERROR" && o.push(a.error), a.name === "PEER_RESPONSE" && a.messageName === "ADD_PROVIDER" && (_Ne("sent provider record for %s to %p", e, a.from), i2++);
            if (i2 === 0)
              throw o.length > 0 ? (0, xm.default)(new Error(`Failed to provide to ${o.length} of ${n} peers`), "ERR_PROVIDES_FAILED", { errors: o }) : (0, xm.default)(new Error("Failed to provide - no peers found"), "ERR_PROVIDES_FAILED");
          }
          async *findProviders(e, r = {}) {
            yield* (0, Gd.default)(this.lan.findProviders(e, r), this.wan.findProviders(e, r));
          }
          async *findPeer(e, r = {}) {
            let n = false;
            for await (let i2 of (0, Gd.default)(this.lan.findPeer(e, r), this.wan.findPeer(e, r)))
              yield i2, (i2.name === "SENDING_QUERY" || i2.name === "FINAL_PEER") && (n = true);
            if (!n)
              throw (0, xm.default)(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
          }
          async *getClosestPeers(e, r = {}) {
            yield* (0, Gd.default)(this.lan.getClosestPeers(e, r), this.wan.getClosestPeers(e, r));
          }
          async refreshRoutingTable() {
            await Promise.all([this.lan.refreshRoutingTable(), this.wan.refreshRoutingTable()]);
          }
        };
        var Mv = class extends Bv {
          constructor(e) {
            super(new r4({ protocolPrefix: "/ipfs", ...e, lan: false }), new r4({ protocolPrefix: "/ipfs", ...e, clientMode: false, lan: true }));
          }
        };
        c();
        var Dk = C("libp2p:bootstrap"), n4 = class extends Ue {
          constructor(e = { list: [] }) {
            if (e.list == null || e.list.length === 0)
              throw new Error("Bootstrap requires a list of peer addresses");
            super(), this.interval = e.interval ?? 1e4, this.list = [];
            for (let r of e.list) {
              if (!qR.matches(r)) {
                Dk.error("Invalid multiaddr");
                continue;
              }
              let n = new j(r), i2 = n.getPeerId();
              if (i2 == null) {
                Dk.error("Invalid bootstrap multiaddr without peer id");
                continue;
              }
              let o = { id: ue(i2), multiaddrs: [n], protocols: [] };
              this.list.push(o);
            }
          }
          get [rc]() {
            return true;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/bootstrap";
          }
          isStarted() {
            return Boolean(this.timer);
          }
          start() {
            this.timer == null && (this.timer = setInterval(() => this._discoverBootstrapPeers(), this.interval), Dk("Starting bootstrap node discovery"), this._discoverBootstrapPeers());
          }
          _discoverBootstrapPeers() {
            this.timer != null && this.list.forEach((e) => {
              this.dispatchEvent(new ee("peer", { detail: e }));
            });
          }
          stop() {
            this.timer != null && clearInterval(this.timer), this.timer = void 0;
          }
        };
        n4.tag = "bootstrap";
        c();
        c();
        c();
        var Rfe = WebSocket;
        c();
        c();
        var Cfe = w(Tfe(), 1);
        Re();
        function Ife(t) {
          return t instanceof ArrayBuffer || t?.constructor?.name === "ArrayBuffer" && typeof t?.byteLength == "number";
        }
        var Pfe = (t) => {
          t.binaryType = "arraybuffer";
          let e = async () => await new Promise((o, s) => {
            if (n)
              return o();
            if (i2 != null)
              return s(i2);
            let a = (f) => {
              t.removeEventListener("open", u), t.removeEventListener("error", l), f();
            }, u = () => a(o), l = (f) => {
              a(() => s(f.error ?? new Error(`connect ECONNREFUSED ${t.url}`)));
            };
            t.addEventListener("open", u), t.addEventListener("error", l);
          }), r = async function* () {
            let o = new Cfe.EventIterator(({ push: s, stop: a, fail: u }) => {
              let l = (h) => {
                let p = null;
                typeof h.data == "string" && (p = U(h.data)), Ife(h.data) && (p = new Uint8Array(h.data)), h.data instanceof Uint8Array && (p = h.data), p != null && s(p);
              }, f = (h) => u(h.error ?? new Error("Socket error"));
              return t.addEventListener("message", l), t.addEventListener("error", f), t.addEventListener("close", a), () => {
                t.removeEventListener("message", l), t.removeEventListener("error", f), t.removeEventListener("close", a);
              };
            }, { highWaterMark: 1 / 0 });
            await e();
            for await (let s of o)
              yield Ife(s) ? new Uint8Array(s) : s;
          }(), n = t.readyState === 1, i2;
          return t.addEventListener("open", () => {
            n = true, i2 = null;
          }), t.addEventListener("close", () => {
            n = false, i2 = null;
          }), t.addEventListener("error", (o) => {
            n || (i2 = o.error ?? new Error(`connect ECONNREFUSED ${t.url}`));
          }), Object.assign(r, { connected: e });
        };
        c();
        c();
        var Dfe = (t) => {
          if (t.readyState >= 2)
            throw new Error("socket closed");
          if (t.readyState !== 1)
            return new Promise((e, r) => {
              function n() {
                t.removeEventListener("open", i2), t.removeEventListener("error", o);
              }
              function i2() {
                n(), e();
              }
              function o(s) {
                n(), r(s.error ?? new Error(`connect ECONNREFUSED ${t.url}`));
              }
              t.addEventListener("open", i2), t.addEventListener("error", o);
            });
        };
        var kfe = (t, e) => (e = e ?? {}, e.closeOnEnd = e.closeOnEnd !== false, async (n) => {
          for await (let i2 of n) {
            try {
              await Dfe(t);
            } catch (o) {
              if (o.message === "socket closed")
                break;
              throw o;
            }
            t.send(i2);
          }
          if (e.closeOnEnd != null && t.readyState <= 1)
            return await new Promise((i2, o) => {
              t.addEventListener("close", (s) => {
                if (s.wasClean || s.code === 1006)
                  i2();
                else {
                  let a = Object.assign(new Error("ws error"), { event: s });
                  o(a);
                }
              }), setTimeout(() => t.close());
            });
        });
        var Nfe = (t, e) => {
          e = e ?? {};
          let r = Pfe(t), n = e.remoteAddress, i2 = e.remotePort;
          if (t.url != null)
            try {
              let s = new URL(t.url);
              n = s.hostname, i2 = parseInt(s.port, 10);
            } catch {
            }
          if (n == null || i2 == null)
            throw new Error("Remote connection did not have address and/or port");
          return { sink: kfe(t, e), source: r, connected: async () => await r.connected(), close: async () => {
            (t.readyState === t.CONNECTING || t.readyState === t.OPEN) && await new Promise((s) => {
              t.addEventListener("close", () => {
                s();
              }), t.close();
            });
          }, destroy: () => {
            t.terminate != null ? t.terminate() : t.close();
          }, remoteAddress: n, remotePort: i2, socket: t };
        };
        c();
        var Ofe = w(ww(), 1), SNe = { http: "ws", https: "wss" }, xNe = "ws", Lfe = (t, e) => (0, Ofe.relative)(t, e, SNe, xNe);
        function Bfe(t, e) {
          let r = typeof window > "u" ? "" : window.location;
          e = e ?? {};
          let n = Lfe(t, r.toString()), i2 = new Rfe(n, e.websocket);
          return Nfe(i2, e);
        }
        var Ok = w(xD(), 1);
        c();
        function Mfe() {
          throw new Error("WebSocket Servers can not be created in the browser!");
        }
        c();
        c();
        var Ufe = C("libp2p:websockets:socket");
        function Ffe(t, e, r) {
          r = r ?? {};
          let n = { async sink(i2) {
            r?.signal != null && (i2 = Pn(i2, r.signal));
            try {
              await t.sink(i2);
            } catch (o) {
              o.type !== "aborted" && Ufe.error(o);
            }
          }, source: r.signal != null ? Pn(t.source, r.signal) : t.source, remoteAddr: e, timeline: { open: Date.now() }, async close() {
            let i2 = Date.now();
            try {
              await nn(t.close(), 2e3);
            } catch {
              let { host: s, port: a } = n.remoteAddr.toOptions();
              Ufe("timeout closing stream to %s:%s after %dms, destroying it manually", s, a, Date.now() - i2), t.destroy();
            } finally {
              n.timeline.close = Date.now();
            }
          } };
          return t.socket.once != null && t.socket.once("close", () => {
            n.timeline.close == null && (n.timeline.close = Date.now());
          }), n;
        }
        c();
        function qfe(t) {
          return t.filter((e) => {
            if (e.protoCodes().includes(290))
              return false;
            let r = e.decapsulateCode(421);
            return vh.matches(r) || yl.matches(r);
          });
        }
        function zfe(t) {
          return t.filter((e) => {
            if (e.protoCodes().includes(290))
              return false;
            let r = e.decapsulateCode(421);
            return yl.matches(r) && gl.matches(r.decapsulateCode(6).decapsulateCode(478));
          });
        }
        var Rf = C("libp2p:websockets"), Kv = class {
          constructor(e) {
            this.init = e;
          }
          get [Symbol.toStringTag]() {
            return "@libp2p/websockets";
          }
          get [H1]() {
            return true;
          }
          async dial(e, r) {
            Rf("dialing %s", e), r = r ?? {};
            let n = await this._connect(e, r), i2 = Ffe(n, e);
            Rf("new outbound connection %s", i2.remoteAddr);
            let o = await r.upgrader.upgradeOutbound(i2);
            return Rf("outbound connection %s upgraded", i2.remoteAddr), o;
          }
          async _connect(e, r) {
            if (r?.signal?.aborted === true)
              throw new nc();
            let n = e.toOptions();
            Rf("dialing %s:%s", n.host, n.port);
            let i2 = Ar(), o = (l) => {
              Rf.error("connection error:", l), i2.reject(l);
            }, s = Bfe(L0(e), this.init);
            if (s.socket.on != null ? s.socket.on("error", o) : s.socket.onerror = o, r.signal == null)
              return await Promise.race([s.connected(), i2.promise]), Rf("connected %s", e), s;
            let a, u = new Promise((l, f) => {
              if (a = () => {
                f(new nc()), setTimeout(() => {
                  s.close().catch((h) => {
                    Rf.error("error closing raw socket", h);
                  });
                });
              }, r?.signal?.aborted === true)
                return a();
              r?.signal?.addEventListener("abort", a);
            });
            try {
              await Promise.race([u, i2.promise, s.connected()]);
            } finally {
              a != null && r?.signal?.removeEventListener("abort", a);
            }
            return Rf("connected %s", e), s;
          }
          createListener(e) {
            return Mfe({ ...this.init, ...e });
          }
          filter(e) {
            return e = Array.isArray(e) ? e : [e], this.init?.filter != null ? this.init?.filter(e) : Ok.default.isBrowser || Ok.default.isWebWorker ? zfe(e) : qfe(e);
          }
        };
        c();
        c();
        c();
        c();
        var Vv = class {
          constructor(e) {
            if (!(e > 0) || (e - 1 & e) !== 0)
              throw new Error("Max size for a FixedFIFO should be a power of two");
            this.buffer = new Array(e), this.mask = e - 1, this.top = 0, this.btm = 0, this.next = null;
          }
          push(e) {
            return this.buffer[this.top] !== void 0 ? false : (this.buffer[this.top] = e, this.top = this.top + 1 & this.mask, true);
          }
          shift() {
            let e = this.buffer[this.btm];
            if (e !== void 0)
              return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, e;
          }
          isEmpty() {
            return this.buffer[this.btm] === void 0;
          }
        }, Rm = class {
          constructor(e = {}) {
            this.hwm = e.splitLimit ?? 16, this.head = new Vv(this.hwm), this.tail = this.head, this.size = 0, this.objectMode = Boolean(e.objectMode);
          }
          push(e) {
            if (e?.value != null)
              if (this.objectMode)
                e.value != null && this.size++;
              else if (e.value instanceof Uint8Array)
                this.size += e.value.byteLength;
              else
                throw new Error("objectMode was false but tried to push non-Uint8Array value");
            if (!this.head.push(e)) {
              let r = this.head;
              this.head = r.next = new Vv(2 * this.head.buffer.length), this.head.push(e);
            }
          }
          shift() {
            let e = this.tail.shift();
            if (e === void 0 && this.tail.next != null) {
              let r = this.tail.next;
              this.tail.next = null, this.tail = r, e = this.tail.shift();
            }
            if (e?.value != null)
              if (this.objectMode)
                this.size--;
              else if (e.value instanceof Uint8Array)
                this.size -= e.value.byteLength;
              else
                throw new Error("objectMode was false but tried to shift non-Uint8Array value");
            return e;
          }
          isEmpty() {
            return this.head.isEmpty();
          }
        };
        function Hfe(t = {}) {
          return Gfe((r) => {
            let n = r.shift();
            if (n == null)
              return { done: true };
            if (n.error != null)
              throw n.error;
            return { done: n.done === true, value: n.value };
          }, t);
        }
        function $fe(t = {}) {
          return Gfe((r) => {
            let n, i2 = [];
            for (; !r.isEmpty() && (n = r.shift(), n != null); ) {
              if (n.error != null)
                throw n.error;
              n.done === false && i2.push(n.value);
            }
            return n == null ? { done: true } : { done: n.done === true, value: i2 };
          }, t);
        }
        function Gfe(t, e) {
          e = e ?? {};
          let r = e.onEnd, n = new Rm(e), i2, o, s, a = async () => n.isEmpty() ? s ? { done: true } : await new Promise((y, g) => {
            o = (E) => {
              o = null, n.push(E);
              try {
                y(t(n));
              } catch (b) {
                g(b);
              }
              return i2;
            };
          }) : t(n), u = (y) => o != null ? o(y) : (n.push(y), i2), l = (y) => (n = new Rm(), o != null ? o({ error: y }) : (n.push({ error: y }), i2)), f = (y) => s ? i2 : u({ done: false, value: y }), h = (y) => s ? i2 : (s = true, y != null ? l(y) : u({ done: true })), p = () => (n = new Rm(), h(), { done: true }), d = (y) => (h(y), { done: true });
          if (i2 = { [Symbol.asyncIterator]() {
            return this;
          }, next: a, return: p, throw: d, push: f, end: h, get readableLength() {
            return n.size;
          } }, r == null)
            return i2;
          let m = i2;
          return i2 = { [Symbol.asyncIterator]() {
            return this;
          }, next() {
            return m.next();
          }, throw(y) {
            return m.throw(y), r != null && (r(y), r = void 0), { done: true };
          }, return() {
            return m.return(), r != null && (r(), r = void 0), { done: true };
          }, push: f, end(y) {
            return m.end(y), r != null && (r(y), r = void 0), i2;
          }, get readableLength() {
            return m.readableLength;
          } }, i2;
        }
        c();
        var Am = w(ai(), 1);
        c();
        var lt;
        (function(t) {
          t[t.NEW_STREAM = 0] = "NEW_STREAM", t[t.MESSAGE_RECEIVER = 1] = "MESSAGE_RECEIVER", t[t.MESSAGE_INITIATOR = 2] = "MESSAGE_INITIATOR", t[t.CLOSE_RECEIVER = 3] = "CLOSE_RECEIVER", t[t.CLOSE_INITIATOR = 4] = "CLOSE_INITIATOR", t[t.RESET_RECEIVER = 5] = "RESET_RECEIVER", t[t.RESET_INITIATOR = 6] = "RESET_INITIATOR";
        })(lt || (lt = {}));
        var qv = Object.freeze({ 0: "NEW_STREAM", 1: "MESSAGE_RECEIVER", 2: "MESSAGE_INITIATOR", 3: "CLOSE_RECEIVER", 4: "CLOSE_INITIATOR", 5: "RESET_RECEIVER", 6: "RESET_INITIATOR" }), Lk = Object.freeze({ NEW_STREAM: lt.NEW_STREAM, MESSAGE: lt.MESSAGE_INITIATOR, CLOSE: lt.CLOSE_INITIATOR, RESET: lt.RESET_INITIATOR }), Wfe = Object.freeze({ MESSAGE: lt.MESSAGE_RECEIVER, CLOSE: lt.CLOSE_RECEIVER, RESET: lt.RESET_RECEIVER });
        var Bk = 10 * 1024;
        function jfe(t) {
          return globalThis.Buffer != null ? Buffer.allocUnsafe(t) : new Uint8Array(t);
        }
        var Mk = class {
          constructor() {
            this._pool = jfe(Bk), this._poolOffset = 0;
          }
          write(e) {
            let r = this._pool, n = this._poolOffset;
            Am.default.encode(e.id << 3 | e.type, r, n), n += Am.default.encode.bytes, (e.type === lt.NEW_STREAM || e.type === lt.MESSAGE_INITIATOR || e.type === lt.MESSAGE_RECEIVER) && e.data != null ? Am.default.encode(e.data.length, r, n) : Am.default.encode(0, r, n), n += Am.default.encode.bytes;
            let i2 = r.slice(this._poolOffset, n);
            return Bk - n < 100 ? (this._pool = jfe(Bk), this._poolOffset = 0) : this._poolOffset = n, (e.type === lt.NEW_STREAM || e.type === lt.MESSAGE_INITIATOR || e.type === lt.MESSAGE_RECEIVER) && e.data != null ? [i2, e.data instanceof Uint8Array ? e.data : e.data.slice()] : [i2];
          }
        }, Yfe = new Mk();
        async function* Qfe(t) {
          for await (let e of t)
            if (Array.isArray(e))
              for (let r of e)
                yield* Yfe.write(r);
            else
              yield* Yfe.write(e);
        }
        c();
        var Uk = class {
          constructor() {
            this._buffer = new qe(), this._headerInfo = null;
          }
          write(e) {
            if (e == null || e.length === 0)
              return [];
            this._buffer.append(e);
            let r = [];
            for (; this._buffer.length !== 0; ) {
              if (this._headerInfo == null)
                try {
                  this._headerInfo = this._decodeHeader(this._buffer);
                } catch {
                  break;
                }
              let { id: n, type: i2, length: o, offset: s } = this._headerInfo;
              if (this._buffer.length - s < o)
                break;
              let u = { id: n, type: i2 };
              (i2 === lt.NEW_STREAM || i2 === lt.MESSAGE_INITIATOR || i2 === lt.MESSAGE_RECEIVER) && (u.data = this._buffer.slice(s, s + o)), r.push(u), this._buffer.consume(s + o), this._headerInfo = null;
            }
            return r;
          }
          _decodeHeader(e) {
            let { value: r, offset: n } = Zfe(e), { value: i2, offset: o } = Zfe(e, n), s = r & 7;
            if (qv[s] == null)
              throw new Error(`Invalid type received: ${s}`);
            return { id: r >> 3, type: s, offset: n + o, length: i2 };
          }
        }, CNe = 128, Xfe = 127;
        function Zfe(t, e = 0) {
          let r = 0, n = 0, i2 = e, o, s = t.length;
          do {
            if (i2 >= s || n > 49)
              throw e = 0, new RangeError("Could not decode varint");
            o = t.get(i2++), r += n < 28 ? (o & Xfe) << n : (o & Xfe) * Math.pow(2, n), n += 7;
          } while (o >= CNe);
          return e = i2 - e, { value: r, offset: e };
        }
        async function* Jfe(t) {
          let e = new Uk();
          for await (let r of t) {
            let n = e.write(r);
            n.length > 0 && (yield n);
          }
        }
        c();
        var Fk = 1 << 20;
        function ehe(t) {
          let e = t ?? Fk, r = (n) => {
            if (!(n.type !== lt.NEW_STREAM && n.type !== lt.MESSAGE_INITIATOR && n.type !== lt.MESSAGE_RECEIVER) && n.data.byteLength > e)
              throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
          };
          return (n) => async function* () {
            for await (let o of n)
              Array.isArray(o) ? (o.forEach(r), yield* o) : (r(o), yield o);
          }();
        }
        c();
        var Vk = w(K(), 1);
        var the = w(Vi(), 1);
        Re();
        var aa = C("libp2p:mplex:stream"), Kk = "ERR_MPLEX_STREAM_RESET", PNe = "ERR_MPLEX_STREAM_ABORT", DNe = "ERR_MPLEX_SINK_ENDED";
        function rhe(t) {
          let { id: e, name: r, send: n, onEnd: i2, type: o = "initiator", maxMsgSize: s = Fk } = t, a = new AbortController(), u = new AbortController(), l = new AbortController(), f = o === "initiator" ? Lk : Wfe, h = o === "initiator" ? `i${e}` : `r${e}`, p = `${r ?? e}`, d = false, m = false, y, g = { open: Date.now() }, E = (S) => {
            d || (d = true, aa.trace("%s stream %s source end - err: %o", o, p, S), S != null && y == null && (y = S), m && (v.timeline.close = Date.now(), i2?.(y)));
          }, b = (S) => {
            m || (m = true, aa.trace("%s stream %s sink end - err: %o", o, p, S), S != null && y == null && (y = S), d && (g.close = Date.now(), i2?.(y)));
          }, v = { close: () => {
            aa.trace("%s stream %s close", o, p), v.closeRead(), v.closeWrite();
          }, closeRead: () => {
            aa.trace("%s stream %s closeRead", o, p), !d && v.source.end();
          }, closeWrite: () => {
            if (aa.trace("%s stream %s closeWrite", o, p), !m) {
              l.abort();
              try {
                n({ id: e, type: f.CLOSE });
              } catch (S) {
                aa.trace("%s stream %s error sending close", o, r, S);
              }
              b();
            }
          }, abort: (S) => {
            aa.trace("%s stream %s abort", o, p, S), v.source.end(S), a.abort(), b(S);
          }, reset: () => {
            let S = (0, Vk.default)(new Error("stream reset"), Kk);
            u.abort(), v.source.end(S), b(S);
          }, sink: async (S) => {
            if (m)
              throw (0, Vk.default)(new Error("stream closed for writing"), DNe);
            S = Pn(S, (0, the.anySignal)([a.signal, u.signal, l.signal]));
            try {
              o === "initiator" && n({ id: e, type: Lk.NEW_STREAM, data: U(p) });
              let x = new qe();
              for await (let T of S)
                for (x.append(T); x.length !== 0; ) {
                  if (x.length <= s) {
                    n({ id: e, type: f.MESSAGE, data: x.subarray() }), x.consume(x.length);
                    break;
                  }
                  let R = x.length - s;
                  n({ id: e, type: f.MESSAGE, data: x.subarray(0, R) }), x.consume(R);
                }
            } catch (x) {
              if (x.type === "aborted" && x.message === "The operation was aborted") {
                if (l.signal.aborted)
                  return;
                u.signal.aborted && (x.message = "stream reset", x.code = Kk), a.signal.aborted && (x.message = "stream aborted", x.code = PNe);
              }
              if (x.code === Kk)
                aa.trace("%s stream %s reset", o, r);
              else {
                aa.trace("%s stream %s error", o, r, x);
                try {
                  n({ id: e, type: f.RESET });
                } catch (T) {
                  aa.trace("%s stream %s error sending reset", o, r, T);
                }
              }
              v.source.end(x), b(x);
              return;
            }
            try {
              n({ id: e, type: f.CLOSE });
            } catch (x) {
              aa.trace("%s stream %s error sending close", o, r, x);
            }
            b();
          }, source: Hfe({ onEnd: E }), timeline: g, id: h };
          return v;
        }
        var zv = w(K(), 1), Iu = C("libp2p:mplex"), kNe = 1024, NNe = 1024 * 1024 * 4;
        function nhe(t) {
          let e = { ...t, type: `${qv[t.type]} (${t.type})` };
          return t.type === lt.NEW_STREAM && (e.data = M(t.data instanceof Uint8Array ? t.data : t.data.slice())), (t.type === lt.MESSAGE_INITIATOR || t.type === lt.MESSAGE_RECEIVER) && (e.data = M(t.data instanceof Uint8Array ? t.data : t.data.slice(), "base16")), e;
        }
        var Hv = class {
          constructor(e, r) {
            this.protocol = "/mplex/6.7.0", r = r ?? {}, this._streamId = 0, this._streams = { initiators: Dn({ metrics: e.getMetrics(), component: "mplex", metric: "initiatorStreams" }), receivers: Dn({ metrics: e.getMetrics(), component: "mplex", metric: "receiverStreams" }) }, this._init = r, this.sink = this._createSink();
            let n = this._createSource();
            this._source = n, this.source = n;
          }
          init(e) {
          }
          get streams() {
            let e = [];
            return this._streams.initiators.forEach((r) => {
              e.push(r);
            }), this._streams.receivers.forEach((r) => {
              e.push(r);
            }), e;
          }
          newStream(e) {
            let r = this._streamId++;
            e = e == null ? r.toString() : e.toString();
            let n = this._streams.initiators;
            return this._newStream({ id: r, name: e, type: "initiator", registry: n });
          }
          _newReceiverStream(e) {
            let { id: r, name: n } = e, i2 = this._streams.receivers;
            return this._newStream({ id: r, name: n, type: "receiver", registry: i2 });
          }
          _newStream(e) {
            let r = this._init.maxStreamsPerConnection ?? kNe;
            if (this._streams.initiators.size + this._streams.receivers.size === r)
              throw (0, zv.default)(new Error("Too many streams open"), "ERR_TOO_MANY_STREAMS");
            let { id: n, name: i2, type: o, registry: s } = e;
            if (Iu("new %s stream %s %s", o, n, i2), s.has(n))
              throw new Error(`${o} stream ${n} already exists!`);
            let l = rhe({ id: n, name: i2, send: (f) => {
              if (!s.has(n))
                throw (0, zv.default)(new Error("the stream is not in the muxer registry, it may have already been closed"), "ERR_STREAM_DOESNT_EXIST");
              Iu.enabled && Iu.trace("%s stream %s send", o, n, nhe(f)), (f.type === lt.NEW_STREAM || f.type === lt.MESSAGE_INITIATOR || f.type === lt.MESSAGE_RECEIVER) && (f.data = f.data instanceof Uint8Array ? f.data : f.data.slice()), this._source.push(f);
            }, type: o, onEnd: () => {
              Iu("%s stream %s %s ended", o, n, i2), s.delete(n), this._init.onStreamEnd != null && this._init.onStreamEnd(l);
            }, maxMsgSize: this._init.maxMsgSize });
            return s.set(n, l), l;
          }
          _createSink() {
            return async (r) => {
              this._init.signal != null && (r = Pn(r, this._init.signal));
              try {
                await Te(r, Jfe, ehe(this._init.maxMsgSize), async (n) => {
                  for await (let i2 of n)
                    this._handleIncoming(i2);
                }), this._source.end();
              } catch (n) {
                Iu("error in sink", n), this._source.end(n);
              }
            };
          }
          _createSource() {
            let r = $fe({ objectMode: true, onEnd: (n) => {
              let { initiators: i2, receivers: o } = this._streams;
              for (let s of i2.values())
                n != null ? s.abort(n) : s.close();
              for (let s of o.values())
                n != null ? s.abort(n) : s.close();
            } });
            return Object.assign(Qfe(r), { push: r.push, end: r.end, return: r.return });
          }
          _handleIncoming(e) {
            let { id: r, type: n } = e;
            if (Iu.enabled && Iu.trace("incoming message", nhe(e)), e.type === lt.NEW_STREAM) {
              let a = this._newReceiverStream({ id: r, name: M(e.data instanceof Uint8Array ? e.data : e.data.slice()) });
              this._init.onIncomingStream != null && this._init.onIncomingStream(a);
              return;
            }
            let o = ((n & 1) === 1 ? this._streams.initiators : this._streams.receivers).get(r);
            if (o == null) {
              Iu("missing stream %s", r);
              return;
            }
            let s = this._init.maxStreamBufferSize ?? NNe;
            switch (n) {
              case lt.MESSAGE_INITIATOR:
              case lt.MESSAGE_RECEIVER:
                if (o.source.readableLength > s) {
                  this._source.push({ id: e.id, type: n === lt.MESSAGE_INITIATOR ? lt.RESET_RECEIVER : lt.RESET_INITIATOR });
                  let a = (0, zv.default)(new Error("Input buffer full - increase Mplex maxBufferSize to accomodate slow consumers"), "ERR_STREAM_INPUT_BUFFER_FULL");
                  o.abort(a);
                  return;
                }
                o.source.push(e.data.slice());
                break;
              case lt.CLOSE_INITIATOR:
              case lt.CLOSE_RECEIVER:
                o.closeRead();
                break;
              case lt.RESET_INITIATOR:
              case lt.RESET_RECEIVER:
                o.reset();
                break;
              default:
                Iu("unknown message type %s", n);
            }
          }
        };
        var $v = class {
          constructor(e = {}) {
            this.protocol = "/mplex/6.7.0", this.init = e;
          }
          createStreamMuxer(e, r = {}) {
            return new Hv(e, { ...r, ...this.init });
          }
        };
        c();
        c();
        c();
        function qk(t, e = {}) {
          let r = Io(t), n = Er.fromReader(r.reader, e), i2 = { read: async (o) => {
            let { value: s } = await r.reader.next(o);
            if (s == null)
              throw new Error("Value is null");
            return s;
          }, readLP: async () => {
            let { value: o } = await n.next();
            if (o == null)
              throw new Error("Value is null");
            return o;
          }, readPB: async (o) => {
            let s = await i2.readLP();
            if (s == null)
              throw new Error("Value is null");
            let a = s instanceof Uint8Array ? s : s.slice();
            return o.decode(a);
          }, write: (o) => {
            o instanceof Uint8Array ? r.writer.push(o) : r.writer.push(o.slice());
          }, writeLP: (o) => {
            i2.write(kr.single(o, e));
          }, writePB: (o, s) => {
            i2.writeLP(s.encode(o));
          }, pb: (o) => ({ read: async () => await i2.readPB(o), write: (s) => i2.writePB(s, o) }), unwrap: () => (r.rest(), r.stream) };
          return i2;
        }
        c();
        c();
        function zk() {
          let t = Ar(), e = false;
          return { sink: async (r) => {
            if (e)
              throw new Error("already piped");
            e = true, t.resolve(r);
          }, source: async function* () {
            yield* await t.promise;
          }() };
        }
        function ihe() {
          let t = zk(), e = zk();
          return [{ source: t.source, sink: e.sink }, { source: e.source, sink: t.sink }];
        }
        c();
        var ohe = Boolean(globalThis.process?.env?.DUMP_SESSION_KEYS);
        c();
        var Khe = w(hhe(), 1), Im = w(Phe(), 1), r7 = w(khe(), 1), oN = w(Fhe(), 1), Vhe = { hashSHA256(t) {
          return (0, r7.hash)(t);
        }, getHKDF(t, e) {
          let i2 = new Khe.HKDF(r7.SHA256, e, t).expand(96), o = i2.slice(0, 32), s = i2.slice(32, 64), a = i2.slice(64, 96);
          return [o, s, a];
        }, generateX25519KeyPair() {
          let t = Im.generateKeyPair();
          return { publicKey: t.publicKey, privateKey: t.secretKey };
        }, generateX25519KeyPairFromSeed(t) {
          let e = Im.generateKeyPairFromSeed(t);
          return { publicKey: e.publicKey, privateKey: e.secretKey };
        }, generateX25519SharedKey(t, e) {
          return Im.sharedKey(t, e);
        }, chaCha20Poly1305Encrypt(t, e, r, n) {
          return new oN.ChaCha20Poly1305(n).seal(e, t, r);
        }, chaCha20Poly1305Decrypt(t, e, r, n) {
          return new oN.ChaCha20Poly1305(n).open(e, t, r);
        } };
        c();
        function zhe(t) {
          return async function* (e) {
            for await (let r of e)
              for (let n = 0; n < r.length; n += 65519) {
                let i2 = n + 65519;
                i2 > r.length && (i2 = r.length), yield t.encrypt(r.slice(n, i2), t.session);
              }
          };
        }
        function Hhe(t) {
          return async function* (e) {
            for await (let r of e)
              for (let n = 0; n < r.length; n += 65535) {
                let i2 = n + 65535;
                i2 > r.length && (i2 = r.length);
                let { plaintext: o, valid: s } = await t.decrypt(r.slice(n, i2), t.session);
                if (!s)
                  throw new Error("Failed to validate decrypted chunk");
                yield o;
              }
          };
        }
        c();
        ur();
        var $Oe = (t) => globalThis.Buffer ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t), f4 = (t, e, r) => (e = e ?? $Oe(2), new DataView(e.buffer, e.byteOffset, e.byteLength).setUint16(r ?? 0, t, false), e);
        f4.bytes = 2;
        var h4 = (t) => {
          if (t.length < 2)
            throw RangeError("Could not decode int16BE");
          return t instanceof Uint8Array ? new DataView(t.buffer, t.byteOffset, t.byteLength).getUint16(0, false) : t.getUint16(0);
        };
        h4.bytes = 2;
        function n7(t) {
          return Ae([t.ne, t.ciphertext], t.ne.length + t.ciphertext.length);
        }
        function i7(t) {
          return Ae([t.ne, t.ns, t.ciphertext], t.ne.length + t.ns.length + t.ciphertext.length);
        }
        function $he(t) {
          return Ae([t.ns, t.ciphertext], t.ns.length + t.ciphertext.length);
        }
        function Cm(t) {
          if (t.length < 32)
            throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
          return { ne: t.slice(0, 32), ciphertext: t.slice(32, t.length), ns: new Uint8Array(0) };
        }
        function Pm(t) {
          if (t.length < 80)
            throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
          return { ne: t.slice(0, 32), ns: t.slice(32, 80), ciphertext: t.slice(80, t.length) };
        }
        function Ghe(t) {
          if (t.length < 48)
            throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
          return { ne: new Uint8Array(0), ns: t.slice(0, 48), ciphertext: t.slice(48, t.length) };
        }
        c();
        c();
        c();
        ur();
        Re();
        c();
        var o7;
        (function(t) {
          let e;
          (function(r) {
            r.codec = () => Xe({ 1: { name: "identityKey", codec: ye }, 2: { name: "identitySig", codec: ye }, 3: { name: "data", codec: ye } }), r.encode = (n) => Qe(n, r.codec()), r.decode = (n) => Ye(n, r.codec());
          })(e = t.NoiseHandshakePayload || (t.NoiseHandshakePayload = {}));
        })(o7 || (o7 = {}));
        var Whe = o7.NoiseHandshakePayload;
        async function jhe(t, e, r) {
          let n = await WOe(t, Yhe(e)), i2 = r ?? new Uint8Array(0);
          if (t.publicKey == null)
            throw new Error("PublicKey was missing from local PeerId");
          return GOe(t.publicKey, n, i2);
        }
        function GOe(t, e, r) {
          return Whe.encode({ identityKey: t, identitySig: e, data: r ?? new Uint8Array(0) });
        }
        async function WOe(t, e) {
          if (t.privateKey == null)
            throw new Error("PrivateKey was missing from PeerId");
          return await (await Jn(t.privateKey)).sign(e);
        }
        async function Tf(t) {
          return await sn(t.identityKey);
        }
        function If(t) {
          return Whe.decode(t);
        }
        function Yhe(t) {
          let e = U("noise-libp2p-static-key:");
          return Ae([e, t], e.length + t.length);
        }
        async function jOe(t, e) {
          return (await sn(e)).equals(t);
        }
        async function Cf(t, e, r) {
          let n = e.identityKey;
          if (!await jOe(r, n))
            throw new Error("Peer ID doesn't match libp2p public key.");
          let i2 = Yhe(t), o = await sn(n);
          if (o.publicKey == null)
            throw new Error("PublicKey was missing from PeerId");
          if (e.identitySig == null)
            throw new Error("Signature was missing from message");
          if (!await ho(o.publicKey).verify(i2, e.identitySig))
            throw new Error("Static key doesn't match to peer that signed payload!");
          return o;
        }
        function ku(t) {
          return !(!(t instanceof Uint8Array) || t.length !== 32);
        }
        c();
        yr();
        ur();
        c();
        me();
        var at = C("libp2p:noise");
        var ws;
        ohe ? ws = at : ws = Object.assign(() => {
        }, { enabled: false, trace: () => {
        }, error: () => {
        } });
        function s7(t) {
          ws(`LOCAL_STATIC_PUBLIC_KEY ${M(t.publicKey, "hex")}`), ws(`LOCAL_STATIC_PRIVATE_KEY ${M(t.privateKey, "hex")}`);
        }
        function Pf(t) {
          t ? (ws(`LOCAL_PUBLIC_EPHEMERAL_KEY ${M(t.publicKey, "hex")}`), ws(`LOCAL_PRIVATE_EPHEMERAL_KEY ${M(t.privateKey, "hex")}`)) : ws("Missing local ephemeral keys.");
        }
        function Dm(t) {
          ws(`REMOTE_STATIC_PUBLIC_KEY ${M(t, "hex")}`);
        }
        function Nu(t) {
          ws(`REMOTE_EPHEMERAL_PUBLIC_KEY ${M(t, "hex")}`);
        }
        function a7(t) {
          t.cs1 && t.cs2 ? (ws(`CIPHER_STATE_1 ${t.cs1.n} ${M(t.cs1.k, "hex")}`), ws(`CIPHER_STATE_2 ${t.cs2.n} ${M(t.cs2.k, "hex")}`)) : ws("Missing cipher state.");
        }
        var YOe = 0, Qhe = Number.MAX_SAFE_INTEGER, Xhe = "Cipherstate has reached maximum n, a new handshake must be performed", km = class {
          constructor(e) {
            this.crypto = e;
          }
          encryptWithAd(e, r, n) {
            let i2 = this.encrypt(e.k, e.n, r, n);
            return this.setNonce(e, this.incrementNonce(e.n)), i2;
          }
          decryptWithAd(e, r, n) {
            let { plaintext: i2, valid: o } = this.decrypt(e.k, e.n, r, n);
            return this.setNonce(e, this.incrementNonce(e.n)), { plaintext: i2, valid: o };
          }
          hasKey(e) {
            return !this.isEmptyKey(e.k);
          }
          setNonce(e, r) {
            e.n = r;
          }
          createEmptyKey() {
            return new Uint8Array(32);
          }
          isEmptyKey(e) {
            let r = this.createEmptyKey();
            return Ce(r, e);
          }
          incrementNonce(e) {
            return e + 1;
          }
          nonceToBytes(e) {
            let r = new Uint8Array(12);
            return new DataView(r.buffer, r.byteOffset, r.byteLength).setUint32(4, e, true), r;
          }
          encrypt(e, r, n, i2) {
            if (r > Qhe)
              throw new Error(Xhe);
            let o = this.nonceToBytes(r);
            return this.crypto.chaCha20Poly1305Encrypt(i2, o, n, e);
          }
          encryptAndHash(e, r) {
            let n;
            return this.hasKey(e.cs) ? n = this.encryptWithAd(e.cs, e.h, r) : n = r, this.mixHash(e, n), n;
          }
          decrypt(e, r, n, i2) {
            if (r > Qhe)
              throw new Error(Xhe);
            let o = this.nonceToBytes(r), s = this.crypto.chaCha20Poly1305Decrypt(i2, o, n, e);
            return s ? { plaintext: s, valid: true } : { plaintext: new Uint8Array(0), valid: false };
          }
          decryptAndHash(e, r) {
            let n, i2 = true;
            return this.hasKey(e.cs) ? { plaintext: n, valid: i2 } = this.decryptWithAd(e.cs, e.h, r) : n = r, this.mixHash(e, r), { plaintext: n, valid: i2 };
          }
          dh(e, r) {
            try {
              let n = this.crypto.generateX25519SharedKey(e, r);
              return n.length === 32 ? n : n.slice(0, 32);
            } catch (n) {
              return at(n.message), new Uint8Array(32);
            }
          }
          mixHash(e, r) {
            e.h = this.getHash(e.h, r);
          }
          getHash(e, r) {
            return this.crypto.hashSHA256(Ae([e, r], e.length + r.length));
          }
          mixKey(e, r) {
            let [n, i2] = this.crypto.getHKDF(e.ck, r);
            e.cs = this.initializeKey(i2), e.ck = n;
          }
          initializeKey(e) {
            return { k: e, n: YOe };
          }
          initializeSymmetric(e) {
            let r = U(e, "utf-8"), n = this.hashProtocolName(r), i2 = n, o = this.createEmptyKey();
            return { cs: this.initializeKey(o), ck: i2, h: n };
          }
          hashProtocolName(e) {
            if (e.length <= 32) {
              let r = new Uint8Array(32);
              return r.set(e), r;
            } else
              return this.getHash(e, new Uint8Array(0));
          }
          split(e) {
            let [r, n] = this.crypto.getHKDF(e.ck, new Uint8Array(0)), i2 = this.initializeKey(r), o = this.initializeKey(n);
            return { cs1: i2, cs2: o };
          }
          writeMessageRegular(e, r) {
            let n = this.encryptWithAd(e, new Uint8Array(0), r), i2 = this.createEmptyKey(), o = new Uint8Array(0);
            return { ne: i2, ns: o, ciphertext: n };
          }
          readMessageRegular(e, r) {
            return this.decryptWithAd(e, new Uint8Array(0), r.ciphertext);
          }
        };
        var c7 = class extends km {
          initSession(e, r, n, i2) {
            let o = this.createEmptyKey(), s;
            return e ? s = this.initializeInitiator(r, n, i2, o) : s = this.initializeResponder(r, n, i2, o), { hs: s, i: e, mc: 0 };
          }
          sendMessage(e, r) {
            let n;
            if (e.mc === 0)
              n = this.writeMessageA(e.hs, r);
            else if (e.mc === 1) {
              let { messageBuffer: i2, h: o, cs1: s, cs2: a } = this.writeMessageB(e.hs, r);
              n = i2, e.h = o, e.cs1 = s, e.cs2 = a;
            } else if (e.mc > 1)
              if (e.i) {
                if (!e.cs1)
                  throw new Error("CS1 (cipher state) is not defined");
                n = this.writeMessageRegular(e.cs1, r);
              } else {
                if (!e.cs2)
                  throw new Error("CS2 (cipher state) is not defined");
                n = this.writeMessageRegular(e.cs2, r);
              }
            else
              throw new Error("Session invalid.");
            return e.mc++, n;
          }
          recvMessage(e, r) {
            let n = new Uint8Array(0), i2 = false;
            if (e.mc === 0 && ({ plaintext: n, valid: i2 } = this.readMessageA(e.hs, r)), e.mc === 1) {
              let { plaintext: o, valid: s, h: a, cs1: u, cs2: l } = this.readMessageB(e.hs, r);
              n = o, i2 = s, e.h = a, e.cs1 = u, e.cs2 = l;
            }
            return e.mc++, { plaintext: n, valid: i2 };
          }
          writeMessageA(e, r) {
            e.e = this.crypto.generateX25519KeyPair();
            let n = e.e.publicKey;
            this.mixHash(e.ss, n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let i2 = e.s.publicKey, o = this.encryptAndHash(e.ss, i2);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.rs));
            let s = this.encryptAndHash(e.ss, r);
            return { ne: n, ns: o, ciphertext: s };
          }
          writeMessageB(e, r) {
            e.e = this.crypto.generateX25519KeyPair();
            let n = e.e.publicKey;
            this.mixHash(e.ss, n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.re)), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let i2 = this.encryptAndHash(e.ss, r), o = this.createEmptyKey(), s = { ne: n, ns: o, ciphertext: i2 }, { cs1: a, cs2: u } = this.split(e.ss);
            return { messageBuffer: s, cs1: a, cs2: u, h: e.ss.h };
          }
          readMessageA(e, r) {
            ku(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let { plaintext: n, valid: i2 } = this.decryptAndHash(e.ss, r.ns);
            i2 && n.length === 32 && ku(n) && (e.rs = n), this.mixKey(e.ss, this.dh(e.s.privateKey, e.rs));
            let { plaintext: o, valid: s } = this.decryptAndHash(e.ss, r.ciphertext);
            return { plaintext: o, valid: i2 && s };
          }
          readMessageB(e, r) {
            if (ku(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), !e.e)
              throw new Error("Handshake state should contain ephemeral key by now.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.re)), this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let { plaintext: n, valid: i2 } = this.decryptAndHash(e.ss, r.ciphertext), { cs1: o, cs2: s } = this.split(e.ss);
            return { h: e.ss.h, valid: i2, plaintext: n, cs1: o, cs2: s };
          }
          initializeInitiator(e, r, n, i2) {
            let o = "Noise_IK_25519_ChaChaPoly_SHA256", s = this.initializeSymmetric(o);
            this.mixHash(s, e), this.mixHash(s, n);
            let a = new Uint8Array(32);
            return { ss: s, s: r, rs: n, re: a, psk: i2 };
          }
          initializeResponder(e, r, n, i2) {
            let o = "Noise_IK_25519_ChaChaPoly_SHA256", s = this.initializeSymmetric(o);
            this.mixHash(s, e), this.mixHash(s, r.publicKey);
            let a = new Uint8Array(32);
            return { ss: s, s: r, rs: n, re: a, psk: i2 };
          }
        };
        c();
        var d4 = class extends Error {
          constructor(e, r) {
            super(r), this.initialMsg = e, this.name = "FailedIKhandshake";
          }
        };
        var u7 = class {
          constructor(e, r, n, i2, o, s, a, u, l) {
            this.isInitiator = e, this.payload = r, this.prologue = n, this.staticKeypair = o, this.connection = s, u && (this.remotePeer = u), this.ik = l ?? new c7(i2), this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, a), this.remoteEarlyData = new Uint8Array();
          }
          async stage0() {
            if (s7(this.session.hs.s), Dm(this.session.hs.rs), this.isInitiator) {
              at("IK Stage 0 - Initiator sending message...");
              let e = this.ik.sendMessage(this.session, this.payload);
              this.connection.writeLP(i7(e)), at("IK Stage 0 - Initiator sent message."), Pf(this.session.hs.e);
            } else {
              at("IK Stage 0 - Responder receiving message...");
              let e = await this.connection.readLP();
              try {
                let r = Pm(e.slice()), { plaintext: n, valid: i2 } = this.ik.recvMessage(this.session, r);
                if (!i2)
                  throw new Error("ik handshake stage 0 decryption validation fail");
                at("IK Stage 0 - Responder got message, going to verify payload.");
                let o = await If(n);
                this.remotePeer = this.remotePeer || await Tf(o), await Cf(this.session.hs.rs, o, this.remotePeer), this.setRemoteEarlyData(o.data), at("IK Stage 0 - Responder successfully verified payload!"), Nu(this.session.hs.re);
              } catch (r) {
                let n = r;
                throw at("Responder breaking up with IK handshake in stage 0."), new d4(e, `Error occurred while verifying initiator's signed payload: ${n.message}`);
              }
            }
          }
          async stage1() {
            if (this.isInitiator) {
              at("IK Stage 1 - Initiator receiving message...");
              let e = (await this.connection.readLP()).slice(), r = Cm(e), { plaintext: n, valid: i2 } = this.ik.recvMessage(this.session, r);
              at("IK Stage 1 - Initiator got message, going to verify payload.");
              try {
                if (!i2)
                  throw new Error("ik stage 1 decryption validation fail");
                let o = await If(n);
                this.remotePeer = this.remotePeer || await Tf(o), await Cf(r.ns.slice(0, 32), o, this.remotePeer), this.setRemoteEarlyData(o.data), at("IK Stage 1 - Initiator successfully verified payload!"), Nu(this.session.hs.re);
              } catch (o) {
                let s = o;
                throw at("Initiator breaking up with IK handshake in stage 1."), new d4(e, `Error occurred while verifying responder's signed payload: ${s.message}`);
              }
            } else {
              at("IK Stage 1 - Responder sending message...");
              let e = this.ik.sendMessage(this.session, this.payload);
              this.connection.writeLP(n7(e)), at("IK Stage 1 - Responder sent message..."), Pf(this.session.hs.e);
            }
            a7(this.session);
          }
          decrypt(e, r) {
            let n = this.getCS(r, false);
            return this.ik.decryptWithAd(n, new Uint8Array(0), e);
          }
          encrypt(e, r) {
            let n = this.getCS(r);
            return this.ik.encryptWithAd(n, new Uint8Array(0), e);
          }
          getLocalEphemeralKeys() {
            if (!this.session.hs.e)
              throw new Error("Ephemeral keys do not exist.");
            return this.session.hs.e;
          }
          getCS(e, r = true) {
            if (!e.cs1 || !e.cs2)
              throw new Error("Handshake not completed properly, cipher state does not exist.");
            return this.isInitiator ? r ? e.cs1 : e.cs2 : r ? e.cs2 : e.cs1;
          }
          setRemoteEarlyData(e) {
            e && (this.remoteEarlyData = e);
          }
        };
        c();
        c();
        var Wd = class extends Error {
          constructor(e = "Unexpected Peer") {
            super(e), this.code = Wd.code;
          }
          static get code() {
            return "ERR_UNEXPECTED_PEER";
          }
        }, Ou = class extends Error {
          constructor(e = "Invalid crypto exchange") {
            super(e), this.code = Ou.code;
          }
          static get code() {
            return "ERR_INVALID_CRYPTO_EXCHANGE";
          }
        };
        c();
        var l7 = class extends km {
          initializeInitiator(e, r, n, i2) {
            let o = "Noise_XX_25519_ChaChaPoly_SHA256", s = this.initializeSymmetric(o);
            this.mixHash(s, e);
            let a = new Uint8Array(32);
            return { ss: s, s: r, rs: n, psk: i2, re: a };
          }
          initializeResponder(e, r, n, i2) {
            let o = "Noise_XX_25519_ChaChaPoly_SHA256", s = this.initializeSymmetric(o);
            this.mixHash(s, e);
            let a = new Uint8Array(32);
            return { ss: s, s: r, rs: n, psk: i2, re: a };
          }
          writeMessageA(e, r, n) {
            let i2 = new Uint8Array(0);
            n !== void 0 ? e.e = n : e.e = this.crypto.generateX25519KeyPair();
            let o = e.e.publicKey;
            this.mixHash(e.ss, o);
            let s = this.encryptAndHash(e.ss, r);
            return { ne: o, ns: i2, ciphertext: s };
          }
          writeMessageB(e, r) {
            e.e = this.crypto.generateX25519KeyPair();
            let n = e.e.publicKey;
            this.mixHash(e.ss, n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
            let i2 = e.s.publicKey, o = this.encryptAndHash(e.ss, i2);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let s = this.encryptAndHash(e.ss, r);
            return { ne: n, ns: o, ciphertext: s };
          }
          writeMessageC(e, r) {
            let n = e.s.publicKey, i2 = this.encryptAndHash(e.ss, n);
            this.mixKey(e.ss, this.dh(e.s.privateKey, e.re));
            let o = this.encryptAndHash(e.ss, r), a = { ne: this.createEmptyKey(), ns: i2, ciphertext: o }, { cs1: u, cs2: l } = this.split(e.ss);
            return { h: e.ss.h, messageBuffer: a, cs1: u, cs2: l };
          }
          readMessageA(e, r) {
            return ku(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), this.decryptAndHash(e.ss, r.ciphertext);
          }
          readMessageB(e, r) {
            if (ku(r.ne) && (e.re = r.ne), this.mixHash(e.ss, e.re), !e.e)
              throw new Error("Handshake state `e` param is missing.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.re));
            let { plaintext: n, valid: i2 } = this.decryptAndHash(e.ss, r.ns);
            i2 && n.length === 32 && ku(n) && (e.rs = n), this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let { plaintext: o, valid: s } = this.decryptAndHash(e.ss, r.ciphertext);
            return { plaintext: o, valid: i2 && s };
          }
          readMessageC(e, r) {
            let { plaintext: n, valid: i2 } = this.decryptAndHash(e.ss, r.ns);
            if (i2 && n.length === 32 && ku(n) && (e.rs = n), !e.e)
              throw new Error("Handshake state `e` param is missing.");
            this.mixKey(e.ss, this.dh(e.e.privateKey, e.rs));
            let { plaintext: o, valid: s } = this.decryptAndHash(e.ss, r.ciphertext), { cs1: a, cs2: u } = this.split(e.ss);
            return { h: e.ss.h, plaintext: o, valid: i2 && s, cs1: a, cs2: u };
          }
          initSession(e, r, n) {
            let i2 = this.createEmptyKey(), o = new Uint8Array(32), s;
            return e ? s = this.initializeInitiator(r, n, o, i2) : s = this.initializeResponder(r, n, o, i2), { hs: s, i: e, mc: 0 };
          }
          sendMessage(e, r, n) {
            let i2;
            if (e.mc === 0)
              i2 = this.writeMessageA(e.hs, r, n);
            else if (e.mc === 1)
              i2 = this.writeMessageB(e.hs, r);
            else if (e.mc === 2) {
              let { h: o, messageBuffer: s, cs1: a, cs2: u } = this.writeMessageC(e.hs, r);
              i2 = s, e.h = o, e.cs1 = a, e.cs2 = u;
            } else if (e.mc > 2)
              if (e.i) {
                if (!e.cs1)
                  throw new Error("CS1 (cipher state) is not defined");
                i2 = this.writeMessageRegular(e.cs1, r);
              } else {
                if (!e.cs2)
                  throw new Error("CS2 (cipher state) is not defined");
                i2 = this.writeMessageRegular(e.cs2, r);
              }
            else
              throw new Error("Session invalid.");
            return e.mc++, i2;
          }
          recvMessage(e, r) {
            let n = new Uint8Array(0), i2 = false;
            if (e.mc === 0)
              ({ plaintext: n, valid: i2 } = this.readMessageA(e.hs, r));
            else if (e.mc === 1)
              ({ plaintext: n, valid: i2 } = this.readMessageB(e.hs, r));
            else if (e.mc === 2) {
              let { h: o, plaintext: s, valid: a, cs1: u, cs2: l } = this.readMessageC(e.hs, r);
              n = s, i2 = a, e.h = o, e.cs1 = u, e.cs2 = l;
            }
            return e.mc++, { plaintext: n, valid: i2 };
          }
        };
        var Nm = class {
          constructor(e, r, n, i2, o, s, a, u) {
            this.isInitiator = e, this.payload = r, this.prologue = n, this.staticKeypair = o, this.connection = s, a && (this.remotePeer = a), this.xx = u ?? new l7(i2), this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair), this.remoteEarlyData = new Uint8Array(0);
          }
          async propose() {
            if (s7(this.session.hs.s), this.isInitiator) {
              at("Stage 0 - Initiator starting to send first message.");
              let e = this.xx.sendMessage(this.session, new Uint8Array(0));
              this.connection.writeLP(n7(e)), at("Stage 0 - Initiator finished sending first message."), Pf(this.session.hs.e);
            } else {
              at("Stage 0 - Responder waiting to receive first message...");
              let e = Cm((await this.connection.readLP()).slice()), { valid: r } = this.xx.recvMessage(this.session, e);
              if (!r)
                throw new Ou("xx handshake stage 0 validation fail");
              at("Stage 0 - Responder received first message."), Nu(this.session.hs.re);
            }
          }
          async exchange() {
            if (this.isInitiator) {
              at("Stage 1 - Initiator waiting to receive first message from responder...");
              let e = Pm((await this.connection.readLP()).slice()), { plaintext: r, valid: n } = this.xx.recvMessage(this.session, e);
              if (!n)
                throw new Ou("xx handshake stage 1 validation fail");
              at("Stage 1 - Initiator received the message."), Nu(this.session.hs.re), Dm(this.session.hs.rs), at("Initiator going to check remote's signature...");
              try {
                let i2 = await If(r);
                this.remotePeer = this.remotePeer || await Tf(i2), this.remotePeer = await Cf(this.session.hs.rs, i2, this.remotePeer), this.setRemoteEarlyData(i2.data);
              } catch (i2) {
                let o = i2;
                throw new Wd(`Error occurred while verifying signed payload: ${o.message}`);
              }
              at("All good with the signature!");
            } else {
              at("Stage 1 - Responder sending out first message with signed payload and static key.");
              let e = this.xx.sendMessage(this.session, this.payload);
              this.connection.writeLP(i7(e)), at("Stage 1 - Responder sent the second handshake message with signed payload."), Pf(this.session.hs.e);
            }
          }
          async finish() {
            if (this.isInitiator) {
              at("Stage 2 - Initiator sending third handshake message.");
              let e = this.xx.sendMessage(this.session, this.payload);
              this.connection.writeLP($he(e)), at("Stage 2 - Initiator sent message with signed payload.");
            } else {
              at("Stage 2 - Responder waiting for third handshake message...");
              let e = Ghe((await this.connection.readLP()).slice()), { plaintext: r, valid: n } = this.xx.recvMessage(this.session, e);
              if (!n)
                throw new Ou("xx handshake stage 2 validation fail");
              at("Stage 2 - Responder received the message, finished handshake.");
              try {
                let i2 = await If(r);
                this.remotePeer = this.remotePeer || await Tf(i2), await Cf(this.session.hs.rs, i2, this.remotePeer), this.setRemoteEarlyData(i2.data);
              } catch (i2) {
                let o = i2;
                throw new Wd(`Error occurred while verifying signed payload: ${o.message}`);
              }
            }
            a7(this.session);
          }
          encrypt(e, r) {
            let n = this.getCS(r);
            return this.xx.encryptWithAd(n, new Uint8Array(0), e);
          }
          decrypt(e, r) {
            let n = this.getCS(r, false);
            return this.xx.decryptWithAd(n, new Uint8Array(0), e);
          }
          getRemoteStaticKey() {
            return this.session.hs.rs;
          }
          getCS(e, r = true) {
            if (!e.cs1 || !e.cs2)
              throw new Ou("Handshake not completed properly, cipher state does not exist.");
            return this.isInitiator ? r ? e.cs1 : e.cs2 : r ? e.cs2 : e.cs1;
          }
          setRemoteEarlyData(e) {
            e && (this.remoteEarlyData = e);
          }
        };
        c();
        var f7 = class extends Nm {
          constructor(e, r, n, i2, o, s, a, u, l, f) {
            super(e, r, n, i2, o, s, u, f), l && (this.ephemeralKeys = l), this.initialMsg = a;
          }
          async propose() {
            if (this.isInitiator)
              this.xx.sendMessage(this.session, new Uint8Array(0), this.ephemeralKeys), at("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator."), Pf(this.session.hs.e);
            else {
              at("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
              let e = Cm(this.initialMsg), { valid: r } = this.xx.recvMessage(this.session, { ne: e.ne, ns: new Uint8Array(0), ciphertext: new Uint8Array(0) });
              if (!r)
                throw new Error("xx fallback stage 0 decryption validation fail");
              at("XX Fallback Stage 0 - Responder used received message from IK."), Nu(this.session.hs.re);
            }
          }
          async exchange() {
            if (this.isInitiator) {
              let e = Pm(this.initialMsg), { plaintext: r, valid: n } = this.xx.recvMessage(this.session, e);
              if (!n)
                throw new Error("xx fallback stage 1 decryption validation fail");
              at("XX Fallback Stage 1 - Initiator used received message from IK."), Nu(this.session.hs.re), Dm(this.session.hs.rs), at("Initiator going to check remote's signature...");
              try {
                let i2 = await If(r);
                this.remotePeer = this.remotePeer || await Tf(i2), await Cf(this.session.hs.rs, i2, this.remotePeer), this.setRemoteEarlyData(i2.data);
              } catch (i2) {
                let o = i2;
                throw new Error(`Error occurred while verifying signed payload from responder: ${o.message}`);
              }
              at("All good with the signature!");
            } else
              at("XX Fallback Stage 1 - Responder start"), await super.exchange(), at("XX Fallback Stage 1 - Responder end");
          }
        };
        c();
        var sN = class {
          constructor() {
            this.storage = new K3();
          }
          store(e, r) {
            this.storage.set(e, r);
          }
          load(e) {
            return e ? this.storage.get(e) ?? null : null;
          }
          resetStorage() {
            this.storage.clear();
          }
        }, h7 = new sN();
        var d7 = class {
          constructor(e, r, n = Vhe) {
            this.protocol = "/noise", this.prologue = new Uint8Array(0), this.earlyData = r ?? new Uint8Array(0), this.useNoisePipes = false, this.crypto = n, e ? this.staticKeys = this.crypto.generateX25519KeyPairFromSeed(e) : this.staticKeys = this.crypto.generateX25519KeyPair();
          }
          async secureOutbound(e, r, n) {
            let i2 = qk(r, { lengthEncoder: f4, lengthDecoder: h4, maxDataLength: 65535 }), o = await this.performHandshake({ connection: i2, isInitiator: true, localPeer: e, remotePeer: n });
            return { conn: await this.createSecureConnection(i2, o), remoteEarlyData: o.remoteEarlyData, remotePeer: o.remotePeer };
          }
          async secureInbound(e, r, n) {
            let i2 = qk(r, { lengthEncoder: f4, lengthDecoder: h4, maxDataLength: 65535 }), o = await this.performHandshake({ connection: i2, isInitiator: false, localPeer: e, remotePeer: n });
            return { conn: await this.createSecureConnection(i2, o), remoteEarlyData: o.remoteEarlyData, remotePeer: o.remotePeer };
          }
          async performHandshake(e) {
            let r = await jhe(e.localPeer, this.staticKeys.publicKey, this.earlyData), n = this.useNoisePipes;
            if (e.isInitiator && h7.load(e.remotePeer) === null && (n = false), n) {
              let { remotePeer: i2, connection: o, isInitiator: s } = e, a = new u7(s, r, this.prologue, this.crypto, this.staticKeys, o, h7.load(e.remotePeer) ?? new Uint8Array(32), i2);
              try {
                return await this.performIKHandshake(a);
              } catch (u) {
                let l = u, f;
                return e.isInitiator && (f = a.getLocalEphemeralKeys()), await this.performXXFallbackHandshake(e, r, l.initialMsg, f);
              }
            } else
              return await this.performXXHandshake(e, r);
          }
          async performXXFallbackHandshake(e, r, n, i2) {
            let { isInitiator: o, remotePeer: s, connection: a } = e, u = new f7(o, r, this.prologue, this.crypto, this.staticKeys, a, n, s, i2);
            try {
              await u.propose(), await u.exchange(), await u.finish();
            } catch (l) {
              let f = l;
              throw f.message = `Error occurred during XX Fallback handshake: ${f.message}`, at(f), f;
            }
            return u;
          }
          async performXXHandshake(e, r) {
            let { isInitiator: n, remotePeer: i2, connection: o } = e, s = new Nm(n, r, this.prologue, this.crypto, this.staticKeys, o, i2);
            try {
              await s.propose(), await s.exchange(), await s.finish(), this.useNoisePipes && s.remotePeer && h7.store(s.remotePeer, s.getRemoteStaticKey());
            } catch (a) {
              if (a instanceof Error)
                throw a.message = `Error occurred during XX handshake: ${a.message}`, a;
            }
            return s;
          }
          async performIKHandshake(e) {
            return await e.stage0(), await e.stage1(), e;
          }
          async createSecureConnection(e, r) {
            let [n, i2] = ihe(), o = e.unwrap();
            return await Te(n, zhe(r), kr({ lengthEncoder: f4 }), o, Er({ lengthDecoder: h4 }), Hhe(r), n), i2;
          }
        };
        c();
        var Zhe = new d7();
        var QOe = Ze.bind({ ignoreUndefined: true, concatArrays: true });
        function p4({ options: t = {}, peerId: e, multiaddrs: r = [], repo: n, keychainConfig: i2 = {}, config: o = {} }) {
          let { datastore: s } = n, a = XOe({ options: t, config: o, datastore: s, keychainConfig: i2, peerId: e, multiaddrs: r });
          return typeof t.libp2p == "function" ? t.libp2p({ libp2pOptions: a, options: t, config: o, datastore: s, peerId: e }) : ple(a);
        }
        function XOe({ options: t, config: e, datastore: r, keychainConfig: n, peerId: i2, multiaddrs: o }) {
          let s = () => {
            let d = (0, Qt.default)(e, "Pubsub.Router") || "gossipsub", m = Ere();
            if (!m[d])
              throw (0, Jhe.default)(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${d} router.`), "ERR_NOT_SUPPORTED");
            return m[d];
          }, a = { datastore: r, peerId: i2 }, u = { addresses: { listen: o.map((d) => d.toString()), announce: (0, Qt.default)(t, "addresses.announce", (0, Qt.default)(e, "Addresses.Announce", [])), noAnnounce: (0, Qt.default)(t, "addresses.noAnnounce", (0, Qt.default)(e, "Addresses.NoAnnounce", [])) }, connectionManager: (0, Qt.default)(t, "connectionManager", { maxConnections: (0, Qt.default)(t, "config.Swarm.ConnMgr.HighWater", (0, Qt.default)(e, "Swarm.ConnMgr.HighWater")), minConnections: (0, Qt.default)(t, "config.Swarm.ConnMgr.LowWater", (0, Qt.default)(e, "Swarm.ConnMgr.LowWater")) }), keychain: n, identify: { host: { agentVersion: `js-ipfs/${Nh}` } }, contentRouters: [], peerRouters: [], peerDiscovery: [], transports: [], streamMuxers: [new $v({ maxStreamsPerConnection: 1 / 0 })], connectionEncryption: [Zhe], relay: { enabled: (0, Qt.default)(t, "relay.enabled", (0, Qt.default)(e, "relay.enabled", true)), hop: { enabled: (0, Qt.default)(t, "relay.hop.enabled", (0, Qt.default)(e, "relay.hop.enabled", false)), active: (0, Qt.default)(t, "relay.hop.active", (0, Qt.default)(e, "relay.hop.active", false)) } }, nat: { enabled: !(0, Qt.default)(e, "Swarm.DisableNatPortMap", false) } };
          (0, Qt.default)(t, "config.Pubsub.Enabled", (0, Qt.default)(e, "Pubsub.Enabled", true)) && (u.pubsub = s()), (0, Qt.default)(e, "Routing.Type", "dhtclient") !== "none" && (u.dht = new Mv({ clientMode: (0, Qt.default)(e, "Routing.Type", "dht") !== "dhtserver", kBucketSize: (0, Qt.default)(t, "dht.kBucketSize", 20), validators: { ipns: l0 }, selectors: { ipns: k6 } }));
          let l = (0, Qt.default)(t, "config.Bootstrap", (0, Qt.default)(e, "Bootstrap", []));
          l.length > 0 && u.peerDiscovery?.push(new n4({ list: l }));
          let f = (0, Qt.default)(t, "libp2p", void 0);
          typeof f == "function" && (f = void 0);
          let h = QOe(a, Ase(), u, f), p = (0, Qt.default)(t, "config.Addresses.Delegates", (0, Qt.default)(e, "Addresses.Delegates", []));
          if (p.length > 0) {
            let d = p[Math.floor(Math.random() * p.length)], m = new j(d).toOptions(), y = { host: m.host, protocol: parseInt(m.port) === 443 ? "https" : "http", port: m.port }, g = Moe(y);
            h.contentRouters?.push(new hb(g)), h.peerRouters?.push(new nb(g));
          }
          return (0, Qt.default)(t, "config.Discovery.MDNS.Enabled", (0, Qt.default)(e, "Discovery.MDNS.Enabled", true)) || (h.peerDiscovery = h.peerDiscovery?.filter((d) => d != null && d[Symbol.toStringTag] !== "@libp2p/mdns")), h.transports == null && (h.transports = []), h.transports.find((d) => d[Symbol.toStringTag] === "@libp2p/websockets") == null && h.transports.push(new Kv()), h;
        }
        var aN = w(K(), 1);
        var tde = Ze.bind({ ignoreUndefined: true }), m4 = C("ipfs:components:peer:storage"), Om = class {
          constructor(e, r, n, i2, o) {
            this.print = i2, this.peerId = e, this.keychain = r, this.repo = n, this.print = i2, this.isNew = o;
          }
          static async start(e, r, n) {
            let { repoAutoMigrate: i2, repo: o, onMigrationProgress: s } = n, a = typeof o == "string" || o == null ? Vee(e, r, { path: o, autoMigrate: i2, onMigrationProgress: s }) : o, { peerId: u, keychain: l, isNew: f } = await ZOe(e, a, n);
            return new Om(u, l, a, e, f);
          }
        }, ZOe = async (t, e, r) => {
          if (!e.closed)
            return { ...await ede(e, r), isNew: false };
          try {
            return await e.open(), { ...await ede(e, r), isNew: false };
          } catch (n) {
            if (n.code !== Yh)
              throw n;
            if (r.init && r.init.allowNew === false)
              throw new Is("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
            return { ...await JOe(t, e, r), isNew: true };
          }
        }, JOe = async (t, e, r) => {
          let n = r.init || {}, i2 = await e.exists();
          if (m4("repo exists?", i2), i2 === true)
            throw new Error("repo already exists");
          let o = n.privateKey ? await eLe(n.privateKey) : await tLe(t, n), s = rLe(o);
          m4("peer identity: %s", s.PeerID);
          let a = { ...tde(rde(Kc(), n.profiles), r.config), Identity: s };
          await e.init(a), await e.open(), m4("repo opened");
          let u = { pass: r.pass };
          try {
            u.dek = await e.config.get("Keychain.DEK");
          } catch (f) {
            if (f.code !== "ERR_NOT_FOUND")
              throw f;
          }
          let l = await p4({ options: void 0, multiaddrs: void 0, peerId: o, repo: e, config: a, keychainConfig: u });
          return l.keychain && (await l.loadKeychain(), await e.config.set("Keychain", { DEK: l.keychain.init.dek })), { peerId: o, keychain: l.keychain };
        }, eLe = async (t) => {
          if (m4("using user-supplied private-key"), Go(t))
            return t;
          let e = U(t, "base64pad"), r = await Jn(e);
          return await sn(r.public.bytes, r.bytes);
        }, tLe = (t, { algorithm: e = "Ed25519", bits: r = 2048 }) => {
          if (t("generating %s keypair...", e), e === "Ed25519")
            return tv();
          if (e === "RSA")
            return fle({ bits: r });
          throw (0, aN.default)(new Error("Unknown PeerId algorithm"), "ERR_UNKNOWN_PEER_ID_ALGORITHM");
        }, rLe = (t) => {
          if (t.privateKey == null)
            throw (0, aN.default)(new Error("Private key missing"), "ERR_MISSING_PRIVATE_KEY");
          return { PeerID: t.toString(), PrivKey: M(t.privateKey, "base64pad") };
        }, ede = async (t, e) => {
          let r = e.config, n = e.init && e.init.profiles || [], i2 = e.pass, o = await t.config.getAll(), s = nLe(rde(o, n), r);
          if (o !== s && await t.config.replace(s), !s.Identity || !s.Identity.PrivKey)
            throw new Sc("No private key was found in the config, please intialize the repo");
          let a = U(s.Identity.PrivKey, "base64pad"), u = await Jn(a), l = await sn(u.public.bytes, u.bytes), f = await p4({ options: void 0, multiaddrs: void 0, peerId: l, repo: t, config: s, keychainConfig: { pass: i2, ...s.Keychain } });
          return f.keychain && await f.loadKeychain(), { peerId: l, keychain: f.keychain };
        }, nLe = (t, e) => e ? tde(t, e) : t, rde = (t, e) => (e || []).reduce((r, n) => {
          let i2 = k0[n];
          if (!i2)
            throw new Error(`Could not find profile with name '${n}'`);
          return m4("applying profile %s", n), i2.transform(r);
        }, t);
        c();
        c();
        c();
        c();
        c();
        te();
        vr();
        Hr();
        var Ede = w(yde(), 1);
        c();
        var y4 = w(ai(), 1);
        function gLe(t) {
          let e = new Uint8Array(t.reduce((n, i2) => n + y4.default.encodingLength(i2), 0)), r = 0;
          for (let n of t)
            e = y4.encode(n, e, r), r += y4.default.encodingLength(n);
          return e;
        }
        var gde = gLe;
        c();
        var uN = w(Mi(), 1);
        yr();
        c();
        c();
        c();
        Hr();
        var g4 = class {
          constructor(e, r, n) {
            this._refCounter = 1, this.cid = e, this.priority = r || 1, this.wantType = n;
          }
          inc() {
            this._refCounter += 1;
          }
          dec() {
            this._refCounter = Math.max(0, this._refCounter - 1);
          }
          hasRefs() {
            return this._refCounter > 0;
          }
          get [Symbol.toStringTag]() {
            return `WantlistEntry <key: ${this.cid.toString(Ne)}, priority: ${this.priority}, refs: ${this._refCounter}>`;
          }
          equals(e) {
            return this._refCounter === e._refCounter && this.cid.equals(e.cid) && this.priority === e.priority && this.wantType === e.wantType;
          }
        };
        Hr();
        c();
        var ua = w(Ea(), 1), dc = ua.default.Reader, w4 = ua.default.Writer, Ht = ua.default.util, Bt = ua.default.roots["ipfs-bitswap"] || (ua.default.roots["ipfs-bitswap"] = {}), Bo = Bt.Message = (() => {
          function t(e) {
            if (this.blocks = [], this.payload = [], this.blockPresences = [], e)
              for (var r = Object.keys(e), n = 0; n < r.length; ++n)
                e[r[n]] != null && (this[r[n]] = e[r[n]]);
          }
          return t.prototype.wantlist = null, t.prototype.blocks = Ht.emptyArray, t.prototype.payload = Ht.emptyArray, t.prototype.blockPresences = Ht.emptyArray, t.prototype.pendingBytes = 0, t.encode = function(r, n) {
            if (n || (n = w4.create()), r.wantlist != null && Object.hasOwnProperty.call(r, "wantlist") && Bt.Message.Wantlist.encode(r.wantlist, n.uint32(10).fork()).ldelim(), r.blocks != null && r.blocks.length)
              for (var i2 = 0; i2 < r.blocks.length; ++i2)
                n.uint32(18).bytes(r.blocks[i2]);
            if (r.payload != null && r.payload.length)
              for (var i2 = 0; i2 < r.payload.length; ++i2)
                Bt.Message.Block.encode(r.payload[i2], n.uint32(26).fork()).ldelim();
            if (r.blockPresences != null && r.blockPresences.length)
              for (var i2 = 0; i2 < r.blockPresences.length; ++i2)
                Bt.Message.BlockPresence.encode(r.blockPresences[i2], n.uint32(34).fork()).ldelim();
            return r.pendingBytes != null && Object.hasOwnProperty.call(r, "pendingBytes") && n.uint32(40).int32(r.pendingBytes), n;
          }, t.decode = function(r, n) {
            r instanceof dc || (r = dc.create(r));
            for (var i2 = n === void 0 ? r.len : r.pos + n, o = new Bt.Message(); r.pos < i2; ) {
              var s = r.uint32();
              switch (s >>> 3) {
                case 1:
                  o.wantlist = Bt.Message.Wantlist.decode(r, r.uint32());
                  break;
                case 2:
                  o.blocks && o.blocks.length || (o.blocks = []), o.blocks.push(r.bytes());
                  break;
                case 3:
                  o.payload && o.payload.length || (o.payload = []), o.payload.push(Bt.Message.Block.decode(r, r.uint32()));
                  break;
                case 4:
                  o.blockPresences && o.blockPresences.length || (o.blockPresences = []), o.blockPresences.push(Bt.Message.BlockPresence.decode(r, r.uint32()));
                  break;
                case 5:
                  o.pendingBytes = r.int32();
                  break;
                default:
                  r.skipType(s & 7);
                  break;
              }
            }
            return o;
          }, t.fromObject = function(r) {
            if (r instanceof Bt.Message)
              return r;
            var n = new Bt.Message();
            if (r.wantlist != null) {
              if (typeof r.wantlist != "object")
                throw TypeError(".Message.wantlist: object expected");
              n.wantlist = Bt.Message.Wantlist.fromObject(r.wantlist);
            }
            if (r.blocks) {
              if (!Array.isArray(r.blocks))
                throw TypeError(".Message.blocks: array expected");
              n.blocks = [];
              for (var i2 = 0; i2 < r.blocks.length; ++i2)
                typeof r.blocks[i2] == "string" ? Ht.base64.decode(r.blocks[i2], n.blocks[i2] = Ht.newBuffer(Ht.base64.length(r.blocks[i2])), 0) : r.blocks[i2].length && (n.blocks[i2] = r.blocks[i2]);
            }
            if (r.payload) {
              if (!Array.isArray(r.payload))
                throw TypeError(".Message.payload: array expected");
              n.payload = [];
              for (var i2 = 0; i2 < r.payload.length; ++i2) {
                if (typeof r.payload[i2] != "object")
                  throw TypeError(".Message.payload: object expected");
                n.payload[i2] = Bt.Message.Block.fromObject(r.payload[i2]);
              }
            }
            if (r.blockPresences) {
              if (!Array.isArray(r.blockPresences))
                throw TypeError(".Message.blockPresences: array expected");
              n.blockPresences = [];
              for (var i2 = 0; i2 < r.blockPresences.length; ++i2) {
                if (typeof r.blockPresences[i2] != "object")
                  throw TypeError(".Message.blockPresences: object expected");
                n.blockPresences[i2] = Bt.Message.BlockPresence.fromObject(r.blockPresences[i2]);
              }
            }
            return r.pendingBytes != null && (n.pendingBytes = r.pendingBytes | 0), n;
          }, t.toObject = function(r, n) {
            n || (n = {});
            var i2 = {};
            if ((n.arrays || n.defaults) && (i2.blocks = [], i2.payload = [], i2.blockPresences = []), n.defaults && (i2.wantlist = null, i2.pendingBytes = 0), r.wantlist != null && r.hasOwnProperty("wantlist") && (i2.wantlist = Bt.Message.Wantlist.toObject(r.wantlist, n)), r.blocks && r.blocks.length) {
              i2.blocks = [];
              for (var o = 0; o < r.blocks.length; ++o)
                i2.blocks[o] = n.bytes === String ? Ht.base64.encode(r.blocks[o], 0, r.blocks[o].length) : n.bytes === Array ? Array.prototype.slice.call(r.blocks[o]) : r.blocks[o];
            }
            if (r.payload && r.payload.length) {
              i2.payload = [];
              for (var o = 0; o < r.payload.length; ++o)
                i2.payload[o] = Bt.Message.Block.toObject(r.payload[o], n);
            }
            if (r.blockPresences && r.blockPresences.length) {
              i2.blockPresences = [];
              for (var o = 0; o < r.blockPresences.length; ++o)
                i2.blockPresences[o] = Bt.Message.BlockPresence.toObject(r.blockPresences[o], n);
            }
            return r.pendingBytes != null && r.hasOwnProperty("pendingBytes") && (i2.pendingBytes = r.pendingBytes), i2;
          }, t.prototype.toJSON = function() {
            return this.constructor.toObject(this, ua.default.util.toJSONOptions);
          }, t.Wantlist = function() {
            function e(r) {
              if (this.entries = [], r)
                for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                  r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
            }
            return e.prototype.entries = Ht.emptyArray, e.prototype.full = false, e.encode = function(n, i2) {
              if (i2 || (i2 = w4.create()), n.entries != null && n.entries.length)
                for (var o = 0; o < n.entries.length; ++o)
                  Bt.Message.Wantlist.Entry.encode(n.entries[o], i2.uint32(10).fork()).ldelim();
              return n.full != null && Object.hasOwnProperty.call(n, "full") && i2.uint32(16).bool(n.full), i2;
            }, e.decode = function(n, i2) {
              n instanceof dc || (n = dc.create(n));
              for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new Bt.Message.Wantlist(); n.pos < o; ) {
                var a = n.uint32();
                switch (a >>> 3) {
                  case 1:
                    s.entries && s.entries.length || (s.entries = []), s.entries.push(Bt.Message.Wantlist.Entry.decode(n, n.uint32()));
                    break;
                  case 2:
                    s.full = n.bool();
                    break;
                  default:
                    n.skipType(a & 7);
                    break;
                }
              }
              return s;
            }, e.fromObject = function(n) {
              if (n instanceof Bt.Message.Wantlist)
                return n;
              var i2 = new Bt.Message.Wantlist();
              if (n.entries) {
                if (!Array.isArray(n.entries))
                  throw TypeError(".Message.Wantlist.entries: array expected");
                i2.entries = [];
                for (var o = 0; o < n.entries.length; ++o) {
                  if (typeof n.entries[o] != "object")
                    throw TypeError(".Message.Wantlist.entries: object expected");
                  i2.entries[o] = Bt.Message.Wantlist.Entry.fromObject(n.entries[o]);
                }
              }
              return n.full != null && (i2.full = Boolean(n.full)), i2;
            }, e.toObject = function(n, i2) {
              i2 || (i2 = {});
              var o = {};
              if ((i2.arrays || i2.defaults) && (o.entries = []), i2.defaults && (o.full = false), n.entries && n.entries.length) {
                o.entries = [];
                for (var s = 0; s < n.entries.length; ++s)
                  o.entries[s] = Bt.Message.Wantlist.Entry.toObject(n.entries[s], i2);
              }
              return n.full != null && n.hasOwnProperty("full") && (o.full = n.full), o;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, ua.default.util.toJSONOptions);
            }, e.WantType = function() {
              let r = {}, n = Object.create(r);
              return n[r[0] = "Block"] = 0, n[r[1] = "Have"] = 1, n;
            }(), e.Entry = function() {
              function r(n) {
                if (n)
                  for (var i2 = Object.keys(n), o = 0; o < i2.length; ++o)
                    n[i2[o]] != null && (this[i2[o]] = n[i2[o]]);
              }
              return r.prototype.block = Ht.newBuffer([]), r.prototype.priority = 0, r.prototype.cancel = false, r.prototype.wantType = 0, r.prototype.sendDontHave = false, r.encode = function(i2, o) {
                return o || (o = w4.create()), i2.block != null && Object.hasOwnProperty.call(i2, "block") && o.uint32(10).bytes(i2.block), i2.priority != null && Object.hasOwnProperty.call(i2, "priority") && o.uint32(16).int32(i2.priority), i2.cancel != null && Object.hasOwnProperty.call(i2, "cancel") && o.uint32(24).bool(i2.cancel), i2.wantType != null && Object.hasOwnProperty.call(i2, "wantType") && o.uint32(32).int32(i2.wantType), i2.sendDontHave != null && Object.hasOwnProperty.call(i2, "sendDontHave") && o.uint32(40).bool(i2.sendDontHave), o;
              }, r.decode = function(i2, o) {
                i2 instanceof dc || (i2 = dc.create(i2));
                for (var s = o === void 0 ? i2.len : i2.pos + o, a = new Bt.Message.Wantlist.Entry(); i2.pos < s; ) {
                  var u = i2.uint32();
                  switch (u >>> 3) {
                    case 1:
                      a.block = i2.bytes();
                      break;
                    case 2:
                      a.priority = i2.int32();
                      break;
                    case 3:
                      a.cancel = i2.bool();
                      break;
                    case 4:
                      a.wantType = i2.int32();
                      break;
                    case 5:
                      a.sendDontHave = i2.bool();
                      break;
                    default:
                      i2.skipType(u & 7);
                      break;
                  }
                }
                return a;
              }, r.fromObject = function(i2) {
                if (i2 instanceof Bt.Message.Wantlist.Entry)
                  return i2;
                var o = new Bt.Message.Wantlist.Entry();
                switch (i2.block != null && (typeof i2.block == "string" ? Ht.base64.decode(i2.block, o.block = Ht.newBuffer(Ht.base64.length(i2.block)), 0) : i2.block.length && (o.block = i2.block)), i2.priority != null && (o.priority = i2.priority | 0), i2.cancel != null && (o.cancel = Boolean(i2.cancel)), i2.wantType) {
                  case "Block":
                  case 0:
                    o.wantType = 0;
                    break;
                  case "Have":
                  case 1:
                    o.wantType = 1;
                    break;
                }
                return i2.sendDontHave != null && (o.sendDontHave = Boolean(i2.sendDontHave)), o;
              }, r.toObject = function(i2, o) {
                o || (o = {});
                var s = {};
                return o.defaults && (o.bytes === String ? s.block = "" : (s.block = [], o.bytes !== Array && (s.block = Ht.newBuffer(s.block))), s.priority = 0, s.cancel = false, s.wantType = o.enums === String ? "Block" : 0, s.sendDontHave = false), i2.block != null && i2.hasOwnProperty("block") && (s.block = o.bytes === String ? Ht.base64.encode(i2.block, 0, i2.block.length) : o.bytes === Array ? Array.prototype.slice.call(i2.block) : i2.block), i2.priority != null && i2.hasOwnProperty("priority") && (s.priority = i2.priority), i2.cancel != null && i2.hasOwnProperty("cancel") && (s.cancel = i2.cancel), i2.wantType != null && i2.hasOwnProperty("wantType") && (s.wantType = o.enums === String ? Bt.Message.Wantlist.WantType[i2.wantType] : i2.wantType), i2.sendDontHave != null && i2.hasOwnProperty("sendDontHave") && (s.sendDontHave = i2.sendDontHave), s;
              }, r.prototype.toJSON = function() {
                return this.constructor.toObject(this, ua.default.util.toJSONOptions);
              }, r;
            }(), e;
          }(), t.Block = function() {
            function e(r) {
              if (r)
                for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                  r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
            }
            return e.prototype.prefix = Ht.newBuffer([]), e.prototype.data = Ht.newBuffer([]), e.encode = function(n, i2) {
              return i2 || (i2 = w4.create()), n.prefix != null && Object.hasOwnProperty.call(n, "prefix") && i2.uint32(10).bytes(n.prefix), n.data != null && Object.hasOwnProperty.call(n, "data") && i2.uint32(18).bytes(n.data), i2;
            }, e.decode = function(n, i2) {
              n instanceof dc || (n = dc.create(n));
              for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new Bt.Message.Block(); n.pos < o; ) {
                var a = n.uint32();
                switch (a >>> 3) {
                  case 1:
                    s.prefix = n.bytes();
                    break;
                  case 2:
                    s.data = n.bytes();
                    break;
                  default:
                    n.skipType(a & 7);
                    break;
                }
              }
              return s;
            }, e.fromObject = function(n) {
              if (n instanceof Bt.Message.Block)
                return n;
              var i2 = new Bt.Message.Block();
              return n.prefix != null && (typeof n.prefix == "string" ? Ht.base64.decode(n.prefix, i2.prefix = Ht.newBuffer(Ht.base64.length(n.prefix)), 0) : n.prefix.length && (i2.prefix = n.prefix)), n.data != null && (typeof n.data == "string" ? Ht.base64.decode(n.data, i2.data = Ht.newBuffer(Ht.base64.length(n.data)), 0) : n.data.length && (i2.data = n.data)), i2;
            }, e.toObject = function(n, i2) {
              i2 || (i2 = {});
              var o = {};
              return i2.defaults && (i2.bytes === String ? o.prefix = "" : (o.prefix = [], i2.bytes !== Array && (o.prefix = Ht.newBuffer(o.prefix))), i2.bytes === String ? o.data = "" : (o.data = [], i2.bytes !== Array && (o.data = Ht.newBuffer(o.data)))), n.prefix != null && n.hasOwnProperty("prefix") && (o.prefix = i2.bytes === String ? Ht.base64.encode(n.prefix, 0, n.prefix.length) : i2.bytes === Array ? Array.prototype.slice.call(n.prefix) : n.prefix), n.data != null && n.hasOwnProperty("data") && (o.data = i2.bytes === String ? Ht.base64.encode(n.data, 0, n.data.length) : i2.bytes === Array ? Array.prototype.slice.call(n.data) : n.data), o;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, ua.default.util.toJSONOptions);
            }, e;
          }(), t.BlockPresenceType = function() {
            let e = {}, r = Object.create(e);
            return r[e[0] = "Have"] = 0, r[e[1] = "DontHave"] = 1, r;
          }(), t.BlockPresence = function() {
            function e(r) {
              if (r)
                for (var n = Object.keys(r), i2 = 0; i2 < n.length; ++i2)
                  r[n[i2]] != null && (this[n[i2]] = r[n[i2]]);
            }
            return e.prototype.cid = Ht.newBuffer([]), e.prototype.type = 0, e.encode = function(n, i2) {
              return i2 || (i2 = w4.create()), n.cid != null && Object.hasOwnProperty.call(n, "cid") && i2.uint32(10).bytes(n.cid), n.type != null && Object.hasOwnProperty.call(n, "type") && i2.uint32(16).int32(n.type), i2;
            }, e.decode = function(n, i2) {
              n instanceof dc || (n = dc.create(n));
              for (var o = i2 === void 0 ? n.len : n.pos + i2, s = new Bt.Message.BlockPresence(); n.pos < o; ) {
                var a = n.uint32();
                switch (a >>> 3) {
                  case 1:
                    s.cid = n.bytes();
                    break;
                  case 2:
                    s.type = n.int32();
                    break;
                  default:
                    n.skipType(a & 7);
                    break;
                }
              }
              return s;
            }, e.fromObject = function(n) {
              if (n instanceof Bt.Message.BlockPresence)
                return n;
              var i2 = new Bt.Message.BlockPresence();
              switch (n.cid != null && (typeof n.cid == "string" ? Ht.base64.decode(n.cid, i2.cid = Ht.newBuffer(Ht.base64.length(n.cid)), 0) : n.cid.length && (i2.cid = n.cid)), n.type) {
                case "Have":
                case 0:
                  i2.type = 0;
                  break;
                case "DontHave":
                case 1:
                  i2.type = 1;
                  break;
              }
              return i2;
            }, e.toObject = function(n, i2) {
              i2 || (i2 = {});
              var o = {};
              return i2.defaults && (i2.bytes === String ? o.cid = "" : (o.cid = [], i2.bytes !== Array && (o.cid = Ht.newBuffer(o.cid))), o.type = i2.enums === String ? "Have" : 0), n.cid != null && n.hasOwnProperty("cid") && (o.cid = i2.bytes === String ? Ht.base64.encode(n.cid, 0, n.cid.length) : i2.bytes === Array ? Array.prototype.slice.call(n.cid) : n.cid), n.type != null && n.hasOwnProperty("type") && (o.type = i2.enums === String ? Bt.Message.BlockPresenceType[n.type] : n.type), o;
            }, e.prototype.toJSON = function() {
              return this.constructor.toObject(this, ua.default.util.toJSONOptions);
            }, e;
          }(), t;
        })();
        var wde = { Block: Bo.Wantlist.WantType.Block, Have: Bo.Wantlist.WantType.Have }, wLe = (t, e) => Array.prototype.slice.call(e, 0).sort((r, n) => {
          let i2 = t(r), o = t(n);
          return i2 < o ? -1 : i2 > o ? 1 : 0;
        }), la = class {
          constructor(e, r) {
            this.set = r ? Dn({ system: "ipfs", component: "bitswap", metric: "wantlist", metrics: r.metrics }) : /* @__PURE__ */ new Map(), this._stats = e;
          }
          get length() {
            return this.set.size;
          }
          add(e, r, n) {
            let i2 = e.toString(Ne), o = this.set.get(i2);
            o ? (o.inc(), o.priority = r, o.wantType === wde.Have && n === wde.Block && (o.wantType = n)) : (this.set.set(i2, new g4(e, r, n)), this._stats && this._stats.push(null, "wantListSize", 1));
          }
          remove(e) {
            let r = e.toString(Ne), n = this.set.get(r);
            !n || (n.dec(), !n.hasRefs() && (this.set.delete(r), this._stats && this._stats.push(null, "wantListSize", -1)));
          }
          removeForce(e) {
            this.set.has(e) && this.set.delete(e);
          }
          forEach(e) {
            return this.set.forEach(e);
          }
          entries() {
            return this.set.entries();
          }
          sortedEntries() {
            return new Map(wLe((e) => e[1].key, Array.from(this.set.entries())));
          }
          contains(e) {
            let r = e.toString(Ne);
            return this.set.has(r);
          }
          get(e) {
            let r = e.toString(Ne);
            return this.set.get(r);
          }
        };
        la.Entry = g4;
        Hr();
        var ELe = la.Entry, Df = class {
          constructor(e, r, n, i2, o) {
            this.entry = new ELe(e, r, n), this.cancel = Boolean(i2), this.sendDontHave = Boolean(o);
          }
          get cid() {
            return this.entry.cid;
          }
          set cid(e) {
            this.entry.cid = e;
          }
          get priority() {
            return this.entry.priority;
          }
          set priority(e) {
            this.entry.priority = e;
          }
          get wantType() {
            return this.entry.wantType;
          }
          set wantType(e) {
            this.entry.wantType = e;
          }
          get [Symbol.toStringTag]() {
            return `BitswapMessageEntry ${this.cid.toString(Ne)} <cancel: ${this.cancel}, priority: ${this.priority}>`;
          }
          equals(e) {
            return this.cancel === e.cancel && this.sendDontHave === e.sendDontHave && this.wantType === e.wantType && this.entry.equals(e.entry);
          }
        };
        var Es = (t, e) => {
          let r = ["bitswap"];
          return e && r.push(e), t && r.push(`${t.toString().slice(0, 8)}`), Object.assign((0, uN.default)(r.join(":")), { error: (0, uN.default)(r.concat(["error"]).join(":")) });
        };
        var p7 = (t, e) => {
          if (t.size !== e.size)
            return false;
          for (let [r, n] of t) {
            let i2 = e.get(r);
            if (i2 === void 0 || n instanceof Uint8Array && i2 instanceof Uint8Array && !Ce(n, i2) || n instanceof Df && i2 instanceof Df && !n.equals(i2))
              return false;
          }
          return true;
        };
        var bde = w(K(), 1), Xt = class {
          constructor(e) {
            this.full = e, this.wantlist = /* @__PURE__ */ new Map(), this.blocks = /* @__PURE__ */ new Map(), this.blockPresences = /* @__PURE__ */ new Map(), this.pendingBytes = 0;
          }
          get empty() {
            return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
          }
          addEntry(e, r, n, i2, o) {
            n == null && (n = Xt.WantType.Block);
            let s = e.toString(Ne), a = this.wantlist.get(s);
            a ? (a.wantType === n && (a.priority = r), i2 && (a.cancel = Boolean(i2)), o && (a.sendDontHave = Boolean(o)), n === Xt.WantType.Block && a.wantType === Xt.WantType.Have && (a.wantType = n)) : this.wantlist.set(s, new Df(e, r, n, i2, o));
          }
          addBlock(e, r) {
            let n = e.toString(Ne);
            this.blocks.set(n, r);
          }
          addHave(e) {
            let r = e.toString(Ne);
            this.blockPresences.has(r) || this.blockPresences.set(r, Xt.BlockPresenceType.Have);
          }
          addDontHave(e) {
            let r = e.toString(Ne);
            this.blockPresences.has(r) || this.blockPresences.set(r, Xt.BlockPresenceType.DontHave);
          }
          cancel(e) {
            let r = e.toString(Ne);
            this.wantlist.delete(r), this.addEntry(e, 0, Xt.WantType.Block, true, false);
          }
          setPendingBytes(e) {
            this.pendingBytes = e;
          }
          serializeToBitswap100() {
            let e = { wantlist: { entries: Array.from(this.wantlist.values()).map((r) => ({ block: r.cid.bytes, priority: Number(r.priority), cancel: Boolean(r.cancel) })), full: this.full ? true : void 0 }, blocks: Array.from(this.blocks.values()) };
            return Bo.encode(e).finish();
          }
          serializeToBitswap110() {
            let e = { wantlist: { entries: Array.from(this.wantlist.values()).map((r) => ({ block: r.cid.bytes, priority: Number(r.priority), wantType: r.wantType, cancel: Boolean(r.cancel), sendDontHave: Boolean(r.sendDontHave) })), full: this.full ? true : void 0 }, blockPresences: [], payload: [], pendingBytes: this.pendingBytes };
            for (let [r, n] of this.blocks.entries()) {
              let i2 = I.parse(r), o = i2.version, s = i2.code, a = i2.multihash.code, u = i2.multihash.digest.length, l = gde([o, s, a, u]);
              e.payload.push(new Bo.Block({ prefix: l, data: n }));
            }
            for (let [r, n] of this.blockPresences)
              e.blockPresences.push(new Bo.BlockPresence({ cid: I.parse(r).bytes, type: n }));
            return this.pendingBytes > 0 && (e.pendingBytes = this.pendingBytes), Bo.encode(e).finish();
          }
          equals(e) {
            return !(this.full !== e.full || this.pendingBytes !== e.pendingBytes || !p7(this.wantlist, e.wantlist) || !p7(this.blocks, e.blocks) || !p7(this.blockPresences, e.blockPresences));
          }
          get [Symbol.toStringTag]() {
            let e = Array.from(this.wantlist.keys()), r = Array.from(this.blocks.keys());
            return `BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${r}>`;
          }
        };
        Xt.deserialize = async (t, e) => {
          let r = Bo.decode(t), n = r.wantlist && r.wantlist.full || false, i2 = new Xt(n);
          return r.wantlist && r.wantlist.entries && r.wantlist.entries.forEach((o) => {
            if (!o.block)
              return;
            let s = I.decode(o.block);
            i2.addEntry(s, o.priority || 0, o.wantType, Boolean(o.cancel), Boolean(o.sendDontHave));
          }), r.blockPresences && r.blockPresences.forEach((o) => {
            if (!o.cid)
              return;
            let s = I.decode(o.cid);
            o.type === Xt.BlockPresenceType.Have ? i2.addHave(s) : i2.addDontHave(s);
          }), r.blocks.length > 0 ? (await Promise.all(r.blocks.map(async (o) => {
            let s = await xe.digest(o), a = I.createV0(s);
            i2.addBlock(a, o);
          })), i2) : (r.payload.length > 0 && (await Promise.all(r.payload.map(async (o) => {
            if (!o.prefix || !o.data)
              return;
            let s = (0, Ede.default)(o.prefix), a = s[0], u = s[1], l = s[2], f = l === xe.code ? xe : e && await e.getHasher(l);
            if (!f)
              throw (0, bde.default)(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
            let h = await f.digest(o.data), p = I.create(a, u, h);
            i2.addBlock(p, o.data);
          })), i2.setPendingBytes(r.pendingBytes)), i2);
        };
        Xt.blockPresenceSize = (t) => t.bytes.length + 1;
        Xt.Entry = Df;
        Xt.WantType = { Block: Bo.Wantlist.WantType.Block, Have: Bo.Wantlist.WantType.Have };
        Xt.BlockPresenceType = { Have: Bo.BlockPresenceType.Have, DontHave: Bo.BlockPresenceType.DontHave };
        c();
        var _de = Math.pow(2, 31) - 1, vde = 1e3, Sde = 1;
        c();
        c();
        var xde = bLe;
        function bLe(t, e, r) {
          var n = null, i2 = null, o = function() {
            n && (clearTimeout(n), i2 = null, n = null);
          }, s = function() {
            var u = i2;
            o(), u && u();
          }, a = function() {
            if (!e)
              return t.apply(this, arguments);
            var u = this, l = arguments, f = r && !n;
            if (o(), i2 = function() {
              t.apply(u, l);
            }, n = setTimeout(function() {
              if (n = null, !f) {
                var h = i2;
                return i2 = null, h();
              }
            }, e), f)
              return i2();
          };
          return a.cancel = o, a.flush = s, a;
        }
        var m7 = class {
          constructor(e, r, n) {
            this.peerId = r, this.network = n, this.refcnt = 1, this._entries = [], this._log = Es(e, "msgqueue"), this.sendEntries = xde(this._sendEntries.bind(this), Sde);
          }
          addMessage(e) {
            e.empty || this.send(e);
          }
          addEntries(e) {
            this._entries = this._entries.concat(e), this.sendEntries();
          }
          _sendEntries() {
            if (!this._entries.length)
              return;
            let e = new Xt(false);
            this._entries.forEach((r) => {
              r.cancel ? e.cancel(r.cid) : e.addEntry(r.cid, r.priority);
            }), this._entries = [], this.addMessage(e);
          }
          async send(e) {
            try {
              await this.network.connectTo(this.peerId);
            } catch (r) {
              this._log.error("cant connect to peer %s: %s", this.peerId.toString(), r.message);
              return;
            }
            this._log("sending message to peer %s", this.peerId.toString()), this.network.sendMessage(this.peerId, e).catch((r) => {
              this._log.error("send error: %s", r.message);
            });
          }
        };
        Hr();
        var y7 = class {
          constructor(e, r, n, i2) {
            this.peers = Dn({ system: "ipfs", component: "bitswap", metric: "want-manager-peers", metrics: i2.metrics }), this.wantlist = new la(n, i2), this.network = r, this._stats = n, this._peerId = e, this._log = Es(e, "want");
          }
          _addEntries(e, r, n) {
            let i2 = e.map((o, s) => new Xt.Entry(o, _de - s, Xt.WantType.Block, r));
            i2.forEach((o) => {
              o.cancel ? n ? this.wantlist.removeForce(o.cid.toString(Ne)) : this.wantlist.remove(o.cid) : (this._log("adding to wl"), this.wantlist.add(o.cid, o.priority));
            });
            for (let o of this.peers.values())
              o.addEntries(i2);
          }
          _startPeerHandler(e) {
            let r = this.peers.get(e.toString());
            if (r) {
              r.refcnt++;
              return;
            }
            r = new m7(this._peerId, e, this.network);
            let n = new Xt(true);
            for (let i2 of this.wantlist.entries())
              n.addEntry(i2[1].cid, i2[1].priority);
            return r.addMessage(n), this.peers.set(e.toString(), r), r;
          }
          _stopPeerHandler(e) {
            let r = this.peers.get(e.toString());
            !r || (r.refcnt--, !(r.refcnt > 0) && this.peers.delete(e.toString()));
          }
          wantBlocks(e, r = {}) {
            this._addEntries(e, false), r && r.signal && r.signal.addEventListener("abort", () => {
              this.cancelWants(e);
            });
          }
          unwantBlocks(e) {
            this._log("unwant blocks: %s", e.length), this._addEntries(e, true, true);
          }
          cancelWants(e) {
            this._log("cancel wants: %s", e.length), this._addEntries(e, true);
          }
          connectedPeers() {
            return Array.from(this.peers.keys());
          }
          connected(e) {
            this._startPeerHandler(e);
          }
          disconnected(e) {
            this._stopPeerHandler(e);
          }
          start() {
          }
          stop() {
            this.peers.forEach((e) => this.disconnected(e.peerId));
          }
        };
        c();
        var fN = "/ipfs/bitswap/1.0.0", hN = "/ipfs/bitswap/1.1.0", dN = "/ipfs/bitswap/1.2.0", g7 = class {
          constructor(e, r, n, i2 = {}) {
            this._log = Es(e.peerId, "network"), this._libp2p = e, this._bitswap = r, this._protocols = [fN], i2.b100Only || (this._protocols.unshift(hN), this._protocols.unshift(dN)), this._stats = n, this._running = false, this._onPeerConnect = this._onPeerConnect.bind(this), this._onPeerDisconnect = this._onPeerDisconnect.bind(this), this._onConnection = this._onConnection.bind(this), this._hashLoader = i2.hashLoader;
          }
          async start() {
            this._running = true, await this._libp2p.handle(this._protocols, this._onConnection);
            let e = g1({ onConnect: this._onPeerConnect, onDisconnect: this._onPeerDisconnect });
            this._registrarId = await this._libp2p.registrar.register(this._protocols, e), this._libp2p.getConnections().forEach((r) => {
              this._onPeerConnect(r.remotePeer);
            });
          }
          async stop() {
            this._running = false, await this._libp2p.unhandle(this._protocols), this._registrarId != null && this._libp2p.registrar.unregister(this._registrarId);
          }
          _onConnection({ protocol: e, stream: r, connection: n }) {
            !this._running || Promise.resolve().then(async () => {
              this._log("incoming new bitswap %s connection from %p", e, n.remotePeer), await Te(r, Er(), async (i2) => {
                for await (let o of i2)
                  try {
                    let s = await Xt.deserialize(o.slice(), this._hashLoader);
                    await this._bitswap._receiveMessage(n.remotePeer, s);
                  } catch (s) {
                    this._bitswap._receiveError(s);
                    break;
                  }
              });
            }).catch((i2) => {
              this._log(i2);
            });
          }
          _onPeerConnect(e) {
            this._bitswap._onPeerConnected(e);
          }
          _onPeerDisconnect(e) {
            this._bitswap._onPeerDisconnected(e);
          }
          findProviders(e, r = {}) {
            return this._libp2p.contentRouting.findProviders(e, r);
          }
          async findAndConnect(e, r) {
            let n = [], i2 = 0;
            for await (let o of this.findProviders(e, r))
              if (this._log(`connecting to provider ${o.id}`), n.push(this.connectTo(o.id, r).catch((s) => {
                this._log.error(s);
              })), i2++, i2 === 3)
                break;
            await Promise.all(n);
          }
          async provide(e, r) {
            await this._libp2p.contentRouting.provide(e, r);
          }
          async sendMessage(e, r) {
            if (!this._running)
              throw new Error("network isn't running");
            let n = e.toString();
            this._log("sendMessage to %s", n, r);
            let i2 = await this._libp2p.dial(e), { stream: o, protocol: s } = await i2.newStream([dN, hN, fN]), a;
            switch (s) {
              case fN:
                a = r.serializeToBitswap100();
                break;
              case hN:
              case dN:
                a = r.serializeToBitswap110();
                break;
              default:
                throw new Error("Unknown protocol: " + s);
            }
            vLe(o, a, this._log), this._updateSentStats(e, r.blocks);
          }
          async connectTo(e, r) {
            if (!this._running)
              throw new Error("network isn't running");
            return this._libp2p.dial(e, r);
          }
          _updateSentStats(e, r) {
            let n = e.toString();
            if (this._stats) {
              for (let i2 of r.values())
                this._stats.push(n, "dataSent", i2.length);
              this._stats.push(n, "blocksSent", r.size);
            }
          }
        };
        async function vLe(t, e, r) {
          try {
            await Te([e], kr(), t);
          } catch (n) {
            r(n);
          }
        }
        c();
        te();
        Hr();
        c();
        var w7 = class {
          constructor(e) {
            this.partner = e, this.wantlist = new la(), this.exchangeCount = 0, this.sentToPeer = /* @__PURE__ */ new Map(), this.accounting = { bytesSent: 0, bytesRecv: 0 };
          }
          sentBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesSent += e;
          }
          receivedBytes(e) {
            this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesRecv += e;
          }
          wants(e, r, n) {
            this.wantlist.add(e, r, n);
          }
          cancelWant(e) {
            this.wantlist.remove(e);
          }
          wantlistContains(e) {
            return this.wantlist.get(e);
          }
          debtRatio() {
            return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
          }
        };
        c();
        c();
        var E4 = class extends Map {
          constructor(e, r) {
            super(), this._cmp = r || this._defaultSort, this._keys = [];
            for (let [n, i2] of e || [])
              this.set(n, i2);
          }
          update(e) {
            if (e < 0 || e >= this._keys.length)
              return;
            let r = this._keys[e];
            this._keys.splice(e, 1);
            let n = this._find(r);
            this._keys.splice(n, 0, r);
          }
          set(e, r) {
            if (this.has(e)) {
              let i2 = this.indexOf(e);
              this._keys.splice(i2, 1);
            }
            super.set(e, r);
            let n = this._find(e);
            return this._keys.splice(n, 0, e), this;
          }
          clear() {
            super.clear(), this._keys = [];
          }
          delete(e) {
            if (!this.has(e))
              return false;
            let r = this.indexOf(e);
            return this._keys.splice(r, 1), super.delete(e);
          }
          indexOf(e) {
            if (!this.has(e))
              return -1;
            let r = this._find(e);
            if (this._keys[r] === e)
              return r;
            for (let n = 1; n < this._keys.length; n++) {
              if (this._keys[r + n] === e)
                return r + n;
              if (this._keys[r - n] === e)
                return r - n;
            }
            return -1;
          }
          _find(e) {
            let r = 0, n = this._keys.length;
            for (; r < n; ) {
              let i2 = r + n >>> 1, o = this._kCmp(this._keys[i2], e);
              if (o < 0)
                r = i2 + 1;
              else if (o > 0)
                n = i2;
              else
                return i2;
            }
            return r;
          }
          *keys() {
            for (let e of this._keys)
              yield e;
          }
          *values() {
            for (let e of this._keys)
              yield this.get(e);
          }
          *entries() {
            for (let e of this._keys)
              yield [e, this.get(e)];
          }
          *[Symbol.iterator]() {
            yield* this.entries();
          }
          forEach(e, r) {
            if (!!e)
              for (let n of this._keys)
                e.apply(r, [[n, this.get(n)]]);
          }
          _defaultSort(e, r) {
            return e[0] < r[0] ? -1 : r[0] < e[0] ? 1 : 0;
          }
          _kCmp(e, r) {
            return this._cmp([e, this.get(e)], [r, this.get(r)]);
          }
        };
        var SLe = { hasNewInfo() {
          return false;
        }, merge() {
        } }, E7 = class {
          constructor(e = SLe) {
            this._taskMerger = e, this._byPeer = new E4([], b7.compare);
          }
          pushTasks(e, r) {
            let n = this._byPeer.get(e.toString());
            n || (n = new b7(e, this._taskMerger)), n.pushTasks(r), this._byPeer.set(e.toString(), n);
          }
          popTasks(e) {
            let r = this._head();
            if (r === void 0)
              return { tasks: [], pendingSize: 0 };
            let { tasks: n, pendingSize: i2 } = r.popTasks(e);
            if (n.length === 0)
              return { tasks: n, pendingSize: i2 };
            let o = r.peerId;
            return r.isIdle() ? this._byPeer.delete(o.toString()) : this._byPeer.update(0), { peerId: o, tasks: n, pendingSize: i2 };
          }
          _head() {
            if (this._byPeer.size !== 0)
              for (let [, e] of this._byPeer)
                return e;
          }
          remove(e, r) {
            let n = this._byPeer.get(r.toString());
            n && n.remove(e);
          }
          tasksDone(e, r) {
            let n = this._byPeer.get(e.toString());
            if (!n)
              return;
            let i2 = this._byPeer.indexOf(e.toString());
            for (let o of r)
              n.taskDone(o);
            this._byPeer.update(i2);
          }
        }, b7 = class {
          constructor(e, r) {
            this.peerId = e, this._taskMerger = r, this._activeTotalSize = 0, this._pending = new pN(), this._active = /* @__PURE__ */ new Set();
          }
          pushTasks(e) {
            for (let r of e)
              this._pushTask(r);
          }
          _pushTask(e) {
            if (!this._taskHasMoreInfoThanActiveTasks(e))
              return;
            let r = this._pending.get(e.topic);
            if (r) {
              e.priority > r.priority && this._pending.updatePriority(e.topic, e.priority), this._taskMerger.merge(e, r);
              return;
            }
            this._pending.add(e);
          }
          _taskHasMoreInfoThanActiveTasks(e) {
            let r = [];
            for (let n of this._active)
              n.topic === e.topic && r.push(n);
            return r.length === 0 ? true : this._taskMerger.hasNewInfo(e, r);
          }
          popTasks(e) {
            let r = 0, n = [], i2 = this._pending.tasks();
            for (let o = 0; o < i2.length && r < e; o++) {
              let s = i2[o];
              n.push(s), r += s.size, this._pending.delete(s.topic), this._activeTotalSize += s.size, this._active.add(s);
            }
            return { tasks: n, pendingSize: this._pending.totalSize };
          }
          taskDone(e) {
            this._active.has(e) && (this._activeTotalSize -= e.size, this._active.delete(e));
          }
          remove(e) {
            this._pending.delete(e);
          }
          isIdle() {
            return this._pending.length === 0 && this._active.size === 0;
          }
          static compare(e, r) {
            return e[1]._pending.length === 0 ? 1 : r[1]._pending.length === 0 ? -1 : e[1]._activeTotalSize === r[1]._activeTotalSize ? r[1]._pending.length - e[1]._pending.length : e[1]._activeTotalSize - r[1]._activeTotalSize;
          }
        }, pN = class {
          constructor() {
            this._tasks = new E4([], this._compare);
          }
          get length() {
            return this._tasks.size;
          }
          get totalSize() {
            return [...this._tasks.values()].reduce((e, r) => e + r.task.size, 0);
          }
          get(e) {
            return (this._tasks.get(e) || {}).task;
          }
          add(e) {
            this._tasks.set(e.topic, { created: Date.now(), task: e });
          }
          delete(e) {
            this._tasks.delete(e);
          }
          tasks() {
            return [...this._tasks.values()].map((e) => e.task);
          }
          updatePriority(e, r) {
            let n = this._tasks.get(e);
            if (!n)
              return;
            let i2 = this._tasks.indexOf(e);
            n.task.priority = r, this._tasks.update(i2);
          }
          _compare(e, r) {
            return e[1].task.priority === r[1].task.priority ? e[1].created - r[1].created : r[1].task.priority - e[1].task.priority;
          }
        };
        c();
        var Rde = { hasNewInfo(t, e) {
          let r = false, n = false;
          for (let i2 of e)
            i2.data.haveBlock && (r = true), i2.data.isWantBlock && (n = true);
          return !!(!n && t.data.isWantBlock || !r && t.data.haveBlock);
        }, merge(t, e) {
          let r = t.data, n = e.data;
          !n.haveBlock && r.haveBlock && (n.haveBlock = r.haveBlock, n.blockSize = r.blockSize), !n.isWantBlock && r.isWantBlock && (n.isWantBlock = true, (!n.haveBlock || r.haveBlock) && (n.haveBlock = r.haveBlock, e.size = t.size)), n.isWantBlock && n.haveBlock && (e.size = n.blockSize);
        } };
        var Ade = Xt.WantType, xLe = 16 * 1024, RLe = 1024, _7 = class {
          constructor(e, r, n, i2, o, s = {}) {
            this._log = Es(e, "engine"), this.blockstore = r, this.network = n, this._stats = i2, this._opts = this._processOpts(s), this.ledgerMap = Dn({ system: "ipfs", component: "bitswap", metric: "ledger-map", metrics: o.metrics }), this._running = false, this._requestQueue = new E7(Rde);
          }
          _processOpts(e) {
            return { maxSizeReplaceHasWithBlock: RLe, targetMessageSize: xLe, ...e };
          }
          _scheduleProcessTasks() {
            setTimeout(() => {
              this._processTasks();
            });
          }
          async _processTasks() {
            if (!this._running)
              return;
            let { peerId: e, tasks: r, pendingSize: n } = this._requestQueue.popTasks(this._opts.targetMessageSize);
            if (r.length === 0)
              return;
            let i2 = new Xt(false);
            i2.setPendingBytes(n);
            let o = [], s = /* @__PURE__ */ new Map();
            for (let u of r) {
              let l = I.parse(u.topic);
              u.data.haveBlock ? u.data.isWantBlock ? (o.push(l), s.set(u.topic, u.data)) : i2.addHave(l) : i2.addDontHave(l);
            }
            let a = await this._getBlocks(o);
            for (let [u, l] of s) {
              let f = I.parse(u), h = a.get(u);
              h ? i2.addBlock(f, h) : l.sendDontHave && i2.addDontHave(f);
            }
            if (i2.empty) {
              e && this._requestQueue.tasksDone(e, r), this._scheduleProcessTasks();
              return;
            }
            try {
              e && await this.network.sendMessage(e, i2);
              for (let [u, l] of a.entries())
                e && this.messageSent(e, I.parse(u), l);
            } catch (u) {
              this._log.error(u);
            }
            e && this._requestQueue.tasksDone(e, r), this._scheduleProcessTasks();
          }
          wantlistForPeer(e) {
            let r = e.toString(), n = this.ledgerMap.get(r);
            return n ? n.wantlist.sortedEntries() : /* @__PURE__ */ new Map();
          }
          ledgerForPeer(e) {
            let r = e.toString(), n = this.ledgerMap.get(r);
            return n ? { peer: n.partner, value: n.debtRatio(), sent: n.accounting.bytesSent, recv: n.accounting.bytesRecv, exchanged: n.exchangeCount } : null;
          }
          peers() {
            return Array.from(this.ledgerMap.values()).map((e) => e.partner);
          }
          receivedBlocks(e) {
            if (!!e.length) {
              for (let r of this.ledgerMap.values())
                for (let n of e) {
                  let i2 = r.wantlistContains(n.cid);
                  if (!i2)
                    continue;
                  let o = n.data.length, s = this._sendAsBlock(i2.wantType, o), a = o;
                  s || (a = Xt.blockPresenceSize(i2.cid)), this._requestQueue.pushTasks(r.partner, [{ topic: i2.cid.toString(Ne), priority: i2.priority, size: a, data: { blockSize: o, isWantBlock: s, haveBlock: true, sendDontHave: false } }]);
                }
              this._scheduleProcessTasks();
            }
          }
          async messageReceived(e, r) {
            let n = this._findOrCreate(e);
            if (r.empty)
              return;
            if (r.full && (n.wantlist = new la()), this._updateBlockAccounting(r.blocks, n), r.wantlist.size === 0) {
              this._scheduleProcessTasks();
              return;
            }
            let i2 = [], o = [];
            r.wantlist.forEach((s) => {
              s.cancel ? (n.cancelWant(s.cid), i2.push(s.cid)) : (n.wants(s.cid, s.priority, s.wantType), o.push(s));
            }), this._cancelWants(e, i2), await this._addWants(e, o), this._scheduleProcessTasks();
          }
          _cancelWants(e, r) {
            for (let n of r)
              this._requestQueue.remove(n.toString(Ne), e);
          }
          async _addWants(e, r) {
            let n = await this._getBlockSizes(r.map((o) => o.cid)), i2 = [];
            for (let o of r) {
              let s = o.cid.toString(Ne), a = n.get(s);
              if (a == null)
                o.sendDontHave && i2.push({ topic: s, priority: o.priority, size: Xt.blockPresenceSize(o.cid), data: { isWantBlock: o.wantType === Ade.Block, blockSize: 0, haveBlock: false, sendDontHave: o.sendDontHave } });
              else {
                let u = this._sendAsBlock(o.wantType, a), l = a;
                u || (l = Xt.blockPresenceSize(o.cid)), i2.push({ topic: s, priority: o.priority, size: l, data: { isWantBlock: u, blockSize: a, haveBlock: true, sendDontHave: o.sendDontHave } });
              }
              this._requestQueue.pushTasks(e, i2);
            }
          }
          _sendAsBlock(e, r) {
            return e === Ade.Block || r <= this._opts.maxSizeReplaceHasWithBlock;
          }
          async _getBlockSizes(e) {
            let r = await this._getBlocks(e);
            return new Map([...r].map(([n, i2]) => [n, i2.length]));
          }
          async _getBlocks(e) {
            let r = /* @__PURE__ */ new Map();
            return await Promise.all(e.map(async (n) => {
              try {
                let i2 = await this.blockstore.get(n);
                r.set(n.toString(Ne), i2);
              } catch (i2) {
                i2.code !== "ERR_NOT_FOUND" && this._log.error("failed to query blockstore for %s: %s", n, i2);
              }
            })), r;
          }
          _updateBlockAccounting(e, r) {
            for (let n of e.values())
              this._log("got block (%s bytes)", n.length), r.receivedBytes(n.length);
          }
          messageSent(e, r, n) {
            let i2 = this._findOrCreate(e);
            i2.sentBytes(n.length), i2.wantlist.remove(r);
          }
          numBytesSentTo(e) {
            return this._findOrCreate(e).accounting.bytesSent;
          }
          numBytesReceivedFrom(e) {
            return this._findOrCreate(e).accounting.bytesRecv;
          }
          peerDisconnected(e) {
            this.ledgerMap.delete(e.toString());
          }
          _findOrCreate(e) {
            let r = e.toString(), n = this.ledgerMap.get(r);
            if (n)
              return n;
            let i2 = new w7(e);
            return this.ledgerMap.set(r, i2), this._stats && this._stats.push(r, "peerCount", 1), i2;
          }
          start() {
            this._running = true;
          }
          stop() {
            this._running = false;
          }
        };
        c();
        var Cde = w(In(), 1);
        me();
        var Tde = (t) => `unwant:${M(t.multihash.bytes, "base64")}`, Ide = (t) => `block:${M(t.multihash.bytes, "base64")}`, v7 = class extends Cde.EventEmitter {
          constructor(e) {
            super(), this.setMaxListeners(vde), this._log = Es(e, "notif");
          }
          hasBlock(e, r) {
            let n = Ide(e);
            this._log(n), this.emit(n, r);
          }
          wantBlock(e, r = {}) {
            if (!e)
              throw new Error("Not a valid cid");
            let n = Ide(e), i2 = Tde(e);
            return this._log(`wantBlock:${e}`), new Promise((o, s) => {
              let a = () => {
                this.removeListener(n, u), s(new Error(`Block for ${e} unwanted`));
              }, u = (l) => {
                this.removeListener(i2, a), o(l);
              };
              this.once(i2, a), this.once(n, u), r && r.signal && r.signal.addEventListener("abort", () => {
                this.removeListener(n, u), this.removeListener(i2, a), s(new Error(`Want for ${e} aborted`));
              });
            });
          }
          unwantBlock(e) {
            let r = Tde(e);
            this._log(r), this.emit(r);
          }
        };
        c();
        var Lde = w(In(), 1);
        c();
        var Nde = w(In(), 1), mN = w(kde(), 1), b4 = class extends Nde.EventEmitter {
          constructor(e, r) {
            super(), this._options = r, this._queue = [], this._stats = {}, this._frequencyLastTime = Date.now(), this._frequencyAccumulators = {}, this._movingAverages = {}, this._update = this._update.bind(this), e.forEach((n) => {
              this._stats[n] = BigInt(0), this._movingAverages[n] = {}, this._options.movingAverageIntervals.forEach((i2) => {
                (this._movingAverages[n][i2] = (0, mN.default)(i2)).push(this._frequencyLastTime, 0);
              });
            }), this._enabled = this._options.enabled;
          }
          enable() {
            this._enabled = true;
          }
          disable() {
            this._disabled = true;
          }
          stop() {
            this._timeout && clearTimeout(this._timeout);
          }
          get snapshot() {
            return Object.assign({}, this._stats);
          }
          get movingAverages() {
            return Object.assign({}, this._movingAverages);
          }
          push(e, r) {
            this._enabled && (this._queue.push([e, r, Date.now()]), this._resetComputeTimeout());
          }
          _resetComputeTimeout() {
            this._timeout && clearTimeout(this._timeout), this._timeout = setTimeout(this._update, this._nextTimeout());
          }
          _nextTimeout() {
            let e = this._queue.length / this._options.computeThrottleMaxQueueSize;
            return Math.max(this._options.computeThrottleTimeout * (1 - e), 0);
          }
          _update() {
            if (this._timeout = null, this._queue.length) {
              let e;
              for (; this._queue.length; ) {
                let r = e = this._queue.shift();
                r && this._applyOp(r);
              }
              e && this._updateFrequency(e[2]), this.emit("update", this._stats);
            }
          }
          _updateFrequency(e) {
            let r = e - this._frequencyLastTime;
            r && Object.keys(this._stats).forEach((n) => {
              this._updateFrequencyFor(n, r, e);
            }), this._frequencyLastTime = e;
          }
          _updateFrequencyFor(e, r, n) {
            let i2 = this._frequencyAccumulators[e] || 0;
            this._frequencyAccumulators[e] = 0;
            let o = i2 / r * 1e3, s = this._movingAverages[e];
            s || (s = this._movingAverages[e] = {}), this._options.movingAverageIntervals.forEach((a) => {
              let u = s[a];
              u || (u = s[a] = (0, mN.default)(a)), u.push(n, o);
            });
          }
          _applyOp(e) {
            let r = e[0], n = e[1];
            if (typeof n != "number")
              throw new Error(`invalid increment number: ${n}`);
            Object.prototype.hasOwnProperty.call(this._stats, r) || (this._stats[r] = BigInt(0)), this._stats[r] = BigInt(this._stats[r]) + BigInt(n), this._frequencyAccumulators[r] || (this._frequencyAccumulators[r] = 0), this._frequencyAccumulators[r] += n;
          }
        };
        var Ode = { enabled: false, computeThrottleTimeout: 1e3, computeThrottleMaxQueueSize: 1e3, movingAverageIntervals: [60 * 1e3, 5 * 60 * 1e3, 15 * 60 * 1e3] }, S7 = class extends Lde.EventEmitter {
          constructor(e, r = [], n = Ode) {
            super();
            let i2 = Object.assign({}, Ode, n);
            if (typeof i2.computeThrottleTimeout != "number")
              throw new Error("need computeThrottleTimeout");
            if (typeof i2.computeThrottleMaxQueueSize != "number")
              throw new Error("need computeThrottleMaxQueueSize");
            this._initialCounters = r, this._options = i2, this._enabled = this._options.enabled, this._global = new b4(r, i2), this._global.on("update", (o) => this.emit("update", o)), this._peers = Dn({ system: "ipfs", component: "bitswap", metric: "stats-peers", metrics: e.metrics });
          }
          enable() {
            this._enabled = true, this._options.enabled = true, this._global.enable();
          }
          disable() {
            this._enabled = false, this._options.enabled = false, this._global.disable();
          }
          stop() {
            this._enabled = false, this._global.stop();
            for (let e of this._peers)
              e[1].stop();
          }
          get snapshot() {
            return this._global.snapshot;
          }
          get movingAverages() {
            return this._global.movingAverages;
          }
          forPeer(e) {
            let r = typeof e != "string" && e.toString ? e.toString() : `${e}`;
            return this._peers.get(r);
          }
          push(e, r, n) {
            if (this._enabled && (this._global.push(r, n), e)) {
              let i2 = this._peers.get(e);
              i2 || (i2 = new b4(this._initialCounters, this._options), this._peers.set(e, i2)), i2.push(r, n);
            }
          }
          disconnected(e) {
            let r = e.toString(), n = this._peers.get(r);
            n && (n.stop(), this._peers.delete(r));
          }
        };
        var Bde = w(Vi(), 1);
        te();
        var TLe = { statsEnabled: false, statsComputeThrottleTimeout: 1e3, statsComputeThrottleMaxQueueSize: 1e3 }, ILe = ["blocksReceived", "dataReceived", "dupBlksReceived", "dupDataReceived", "blocksSent", "dataSent", "providesBufferLength", "wantListLength", "peerCount"], x7 = class extends ja {
          constructor(e, r, n = {}) {
            super(), this._libp2p = e, this._log = Es(this.peerId), this._options = Object.assign({}, TLe, n), this._stats = new S7(e, ILe, { enabled: this._options.statsEnabled, computeThrottleTimeout: this._options.statsComputeThrottleTimeout, computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize }), this.network = new g7(e, this, this._stats, { hashLoader: n.hashLoader }), this.blockstore = r, this.engine = new _7(this.peerId, r, this.network, this._stats, e), this.wm = new y7(this.peerId, this.network, this._stats, e), this.notifications = new v7(this.peerId), this.started = false;
          }
          isStarted() {
            return this.started;
          }
          get peerId() {
            return this._libp2p.peerId;
          }
          async _receiveMessage(e, r) {
            try {
              await this.engine.messageReceived(e, r);
            } catch {
              this._log("failed to receive message", r);
            }
            if (r.blocks.size === 0)
              return;
            let n = [];
            for (let [i2, o] of r.blocks.entries()) {
              let s = I.parse(i2);
              n.push({ wasWanted: this.wm.wantlist.contains(s), cid: s, data: o });
            }
            this.wm.cancelWants(n.filter(({ wasWanted: i2 }) => i2).map(({ cid: i2 }) => i2)), await Promise.all(n.map(({ cid: i2, wasWanted: o, data: s }) => this._handleReceivedBlock(e, i2, s, o)));
          }
          async _handleReceivedBlock(e, r, n, i2) {
            this._log("received block");
            let o = await this.blockstore.has(r);
            this._updateReceiveCounters(e.toString(), r, n, o), i2 && await this.put(r, n);
          }
          _updateReceiveCounters(e, r, n, i2) {
            this._stats.push(e, "blocksReceived", 1), this._stats.push(e, "dataReceived", n.length), i2 && (this._stats.push(e, "dupBlksReceived", 1), this._stats.push(e, "dupDataReceived", n.length));
          }
          _receiveError(e) {
            this._log.error("ReceiveError: %s", e.message);
          }
          _onPeerConnected(e) {
            this.wm.connected(e);
          }
          _onPeerDisconnected(e) {
            this.wm.disconnected(e), this.engine.peerDisconnected(e), this._stats.disconnected(e);
          }
          enableStats() {
            this._stats.enable();
          }
          disableStats() {
            this._stats.disable();
          }
          wantlistForPeer(e, r) {
            return this.engine.wantlistForPeer(e);
          }
          ledgerForPeer(e) {
            return this.engine.ledgerForPeer(e);
          }
          async get(e, r = {}) {
            let n = (u, l) => (this.wm.wantBlocks([u], l), this.notifications.wantBlock(u, l)), i2 = false, o = async (u, l) => {
              try {
                return await this.blockstore.get(u, l);
              } catch (f) {
                if (f.code !== "ERR_NOT_FOUND")
                  throw f;
                return i2 || (i2 = true, this.network.findAndConnect(u, l).catch((h) => this._log.error(h))), n(u, l);
              }
            }, s = new AbortController(), a = r.signal ? (0, Bde.anySignal)([r.signal, s.signal]) : s.signal;
            try {
              return await Promise.race([this.notifications.wantBlock(e, { signal: a }), o(e, { signal: a })]);
            } finally {
              s.abort();
            }
          }
          async *getMany(e, r = {}) {
            for await (let n of e)
              yield this.get(n, r);
          }
          unwant(e) {
            let r = Array.isArray(e) ? e : [e];
            this.wm.unwantBlocks(r), r.forEach((n) => this.notifications.unwantBlock(n));
          }
          cancelWants(e) {
            this.wm.cancelWants(Array.isArray(e) ? e : [e]);
          }
          async put(e, r, n) {
            await this.blockstore.put(e, r), this._sendHaveBlockNotifications(e, r);
          }
          async *putMany(e, r) {
            for await (let { key: n, value: i2 } of this.blockstore.putMany(e, r))
              this._sendHaveBlockNotifications(n, i2), yield { key: n, value: i2 };
          }
          _sendHaveBlockNotifications(e, r) {
            this.notifications.hasBlock(e, r), this.engine.receivedBlocks([{ cid: e, data: r }]), this.network.provide(e).catch((n) => {
              this._log.error("Failed to provide: %s", n.message);
            });
          }
          getWantlist() {
            return this.wm.wantlist.entries();
          }
          peers() {
            return this.engine.peers();
          }
          stat() {
            return this._stats;
          }
          async start() {
            this.wm.start(), await this.network.start(), this.engine.start(), this.started = true;
          }
          async stop() {
            this._stats.stop(), this.wm.stop(), await this.network.stop(), this.engine.stop(), this.started = false;
          }
          unwrap() {
            return this.blockstore;
          }
        };
        var Mde = (t, e, r = {}) => new x7(t, e, r);
        var Vde = w(K(), 1);
        c();
        c();
        var R7 = {};
        ct(R7, { abortedError: () => CLe, notFoundError: () => Ude });
        c();
        var yN = w(K(), 1);
        function Ude(t) {
          return t = t || new Error("Not Found"), (0, yN.default)(t, "ERR_NOT_FOUND");
        }
        function CLe(t) {
          return t = t || new Error("Aborted"), (0, yN.default)(t, "ERR_ABORTED");
        }
        c();
        si();
        zo();
        te();
        On();
        var mMt = { ...R7 };
        var Fde = w(Fc(), 1);
        var Kde = w(Gi(), 1), A7 = class extends ja {
          constructor(e, r) {
            super(), this.child = e, this.bitswap = r;
          }
          open() {
            return this.child.open();
          }
          close() {
            return this.child.close();
          }
          unwrap() {
            return this.child;
          }
          async put(e, r, n = {}) {
            await this.has(e) || (this.bitswap.isStarted() ? await this.bitswap.put(e, r, n) : await this.child.put(e, r, n));
          }
          async *putMany(e, r = {}) {
            let n = (0, Kde.default)(e, async ({ key: i2 }) => !await this.has(i2));
            this.bitswap.isStarted() ? yield* this.bitswap.putMany(n, r) : yield* this.child.putMany(n, r);
          }
          async get(e, r = {}) {
            return !await this.has(e) && this.bitswap.isStarted() ? this.bitswap.get(e, r) : this.child.get(e, r);
          }
          async *getMany(e, r = {}) {
            let n = zs(), i2 = zs();
            Promise.resolve().then(async () => {
              for await (let o of e)
                !await this.has(o) && this.bitswap.isStarted() ? n.push(o) : i2.push(o);
              n.end(), i2.end();
            }), yield* (0, Fde.default)(this.bitswap.getMany(n, r), this.child.getMany(i2, r));
          }
          async delete(e, r) {
            await this.child.delete(e, r);
          }
          async *deleteMany(e, r) {
            yield* this.child.deleteMany(e, r);
          }
          async has(e, r = {}) {
            return this.child.has(e, r);
          }
          async *query(e, r = {}) {
            yield* this.child.query(e, r);
          }
          async *queryKeys(e, r = {}) {
            yield* this.child.queryKeys(e, r);
          }
        };
        var Lm = class {
          constructor(e, r, n, i2, o) {
            this.peerId = e, this.libp2p = r, this.bitswap = n, this.repo = i2, this.blockstore = o;
          }
          static async start({ peerId: e, repo: r, print: n, hashers: i2, options: o }) {
            r.closed && await r.open();
            let s = await r.config.getAll(), a = await p4({ options: o, repo: r, peerId: e, multiaddrs: PLe(e, s), config: s, keychainConfig: void 0 });
            a.keychain && await a.loadKeychain(), await a.start();
            for (let f of a.getMultiaddrs())
              n(`Swarm listening on ${f.toString()}`);
            let u = Mde(a, r.blocks, { statsEnabled: true, hashLoader: i2 });
            await u.start();
            let l = new A7(r.blocks, u);
            return r.blocks = l, r.pins.blockstore = l, new Lm(e, a, u, r, l);
          }
          static async stop(e) {
            e.repo.blocks = e.blockstore.unwrap(), e.repo.pins.blockstore = e.blockstore.unwrap(), await e.bitswap.stop(), await e.libp2p.stop();
          }
        }, PLe = (t, e) => {
          let r = t.toString(), n = [], i2 = e.Addresses && e.Addresses.Swarm || [];
          for (let o of i2) {
            let s = new j(o);
            if (s.protoCodes().includes(DLe))
              throw (0, Vde.default)(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
            let a = s.getPeerId();
            a && a !== r && (s = s.encapsulate(`/p2p/${r}`)), n.push(s);
          }
          return n;
        }, DLe = 479;
        c();
        c();
        function qde({ network: t }) {
          async function e(r = {}) {
            let n = [], { libp2p: i2 } = await t.use(r);
            return await i2.peerStore.forEach((o) => {
              n.push({ id: o.id, addrs: o.addresses.map((s) => s.multiaddr) });
            }), n;
          }
          return B(e);
        }
        c();
        function zde({ network: t }) {
          async function e(r, n = {}) {
            let { libp2p: i2 } = await t.use(n);
            await i2.dial(r, n);
          }
          return B(e);
        }
        c();
        function Hde({ network: t }) {
          async function e(r, n = {}) {
            let { libp2p: i2 } = await t.use(n);
            await i2.hangUp(r);
          }
          return B(e);
        }
        c();
        function $de({ network: t }) {
          async function e(r = {}) {
            let { libp2p: n } = await t.use(r);
            return n.getMultiaddrs();
          }
          return B(e);
        }
        c();
        function Gde({ network: t }) {
          async function e(r = {}) {
            let { libp2p: n } = await t.use(r);
            if (r.verbose) {
              let o = [];
              for (let s of n.getConnections()) {
                let a = { addr: s.remoteAddr, peer: s.remotePeer };
                (r.verbose || r.direction) && (a.direction = s.stat.direction), r.verbose && (a.muxer = s.stat.multiplexer, a.latency = "n/a", a.streams = []), o.push(a);
              }
              return o;
            }
            let i2 = /* @__PURE__ */ new Map();
            for (let o of n.getConnections()) {
              let s = { addr: o.remoteAddr, peer: o.remotePeer };
              i2.set(o.remotePeer.toString(), s);
            }
            return Array.from(i2.values());
          }
          return B(e);
        }
        var T7 = class {
          constructor({ network: e }) {
            this.addrs = qde({ network: e }), this.connect = zde({ network: e }), this.disconnect = Hde({ network: e }), this.localAddrs = $de({ network: e }), this.peers = Gde({ network: e });
          }
        };
        c();
        var _4 = { success: true, time: 0, text: "" };
        function Wde({ network: t }) {
          async function* e(r, n = {}) {
            let { libp2p: i2 } = await t.use();
            n.count = n.count || 10;
            let o = await i2.peerStore.get(r), s = o && o.id;
            if (!s) {
              yield { ..._4, text: `Looking up peer ${r}` };
              let l = await i2.peerRouting.findPeer(r);
              s = l && l.id;
            }
            if (!s)
              throw new Error("Peer was not found");
            yield { ..._4, text: `PING ${s.toString()}` };
            let a = 0, u = 0;
            for (let l = 0; l < n.count; l++)
              try {
                let f = await i2.ping(s);
                u += f, a++, yield { ..._4, time: f };
              } catch (f) {
                yield { ..._4, success: false, text: f.toString() };
              }
            if (a) {
              let l = u / a;
              yield { ..._4, text: `Average latency: ${l}ms` };
            }
          }
          return B(e);
        }
        c();
        var Lu = w(K(), 1);
        te();
        Hr();
        nw();
        ur();
        Re();
        var gN = "/ipns/";
        function jde(t) {
          t.startsWith(gN) && (t = t.substring(gN.length));
          let e;
          if ((t[0] === "1" || t[0] === "Q") && (t = `z${t}`), t[0] === "z" && (e = Ne.decode(t)), t[0] === "k" && (e = xp.decode(t)), !e)
            throw new Error("Could not parse string");
          if (e[0] !== 1 && e[1] !== 114 && (e = Ae([[1, 114], e])), e.length !== 40)
            throw new Error("Incorrect length " + e.length);
          return Ae([U(gN), e.subarray(2)]);
        }
        function Yde({ network: t, repo: e, peerId: r }) {
          let { get: n, put: i2, findProvs: o, findPeer: s, provide: a, query: u } = { async *get(l, f = {}) {
            let { libp2p: h } = await Bm(t, r, f), p = l instanceof Uint8Array ? l : jde(l);
            if (h.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* h.dht.get(p, f);
          }, async *put(l, f, h) {
            let { libp2p: p } = await Bm(t, r, h), d = l instanceof Uint8Array ? l : jde(l);
            if (p.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* p.dht.put(d, f);
          }, async *findProvs(l, f = {}) {
            let { libp2p: h } = await Bm(t, r, f);
            if (h.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* h.dht.findProviders(l, { signal: f.signal });
          }, async *findPeer(l, f = {}) {
            let { libp2p: h } = await Bm(t, r, f);
            if (h.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* h.dht.findPeer(l, { signal: f.signal });
          }, async *provide(l, f = { recursive: false }) {
            let { libp2p: h } = await Bm(t, r, f);
            if (!await e.blocks.has(l))
              throw (0, Lu.default)(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
            if (f.recursive)
              throw (0, Lu.default)(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
            if (h.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* h.dht.provide(l);
          }, async *query(l, f = {}) {
            let { libp2p: h } = await Bm(t, r, f), p, d = I.asCID(l);
            if (d != null ? p = d.multihash.bytes : p = ue(l.toString()).toBytes(), h.dht == null)
              throw (0, Lu.default)(new Error("dht not configured"), "ERR_DHT_NOT_CONFIGURED");
            yield* h.dht.getClosestPeers(p, f);
          } };
          return { get: B(n), put: B(i2), findProvs: B(o), findPeer: B(s), provide: B(a), query: B(u) };
        }
        var Bm = async (t, e, r) => {
          let n = await t.use(r);
          if (n.libp2p.dht != null)
            return n;
          {
            let i2 = async function* () {
              yield { from: e, name: "QUERY_ERROR", type: 3, error: new Is("dht not enabled") };
            };
            return { libp2p: { dht: { get: i2, put: i2, findProviders: i2, findPeer: i2, provide: i2, getClosestPeers: i2 } } };
          }
        };
        c();
        var Qde = w(K(), 1);
        var Xde = w(D6(), 1);
        function Zde({ network: t, config: e }) {
          let r = (0, Xde.default)(e || {}, "Pubsub.Enabled", true), n = {}, i2;
          return { subscribe: r ? B(o) : v4, unsubscribe: r ? B(s) : v4, publish: r ? B(a) : v4, ls: r ? B(u) : v4, peers: r ? B(l) : v4 };
          async function o(f, h, p = {}) {
            let { libp2p: d } = await t.use(p);
            d.pubsub.subscribe(f), i2 == null && (i2 = (m) => {
              let y = m.detail;
              n[y.topic] && n[y.topic].forEach((g) => {
                if (typeof g == "function") {
                  g(y);
                  return;
                }
                g != null && g.handleEvent != null && g.handleEvent(y);
              });
            }, d.pubsub.addEventListener("message", i2)), h != null && (n[f] == null && (n[f] = []), n[f].push(h));
          }
          async function s(f, h, p = {}) {
            let { libp2p: d } = await t.use(p);
            h != null && n[f] != null && (n[f] = n[f].filter((m) => m !== h), n[f].length === 0 && delete n[f]), typeof h != "function" && delete n[f], n[f] == null && d.pubsub.unsubscribe(f), Object.keys(n).length === 0 && (d.pubsub.removeEventListener("message", i2), i2 = void 0);
          }
          async function a(f, h, p = {}) {
            let { libp2p: d } = await t.use(p);
            if (!h)
              throw (0, Qde.default)(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
            await d.pubsub.publish(f, h);
          }
          async function u(f = {}) {
            let { libp2p: h } = await t.use(f);
            return h.pubsub.getTopics();
          }
          async function l(f, h = {}) {
            let { libp2p: p } = await t.use(h);
            return p.pubsub.getSubscribers(f);
          }
        }
        var v4 = async () => {
          throw new Is("pubsub not enabled");
        };
        var NLe = Ze.bind({ ignoreUndefined: true }), kf = C("ipfs"), wN = class {
          constructor({ print: e, storage: r, codecs: n, options: i2 }) {
            let { peerId: o, repo: s, keychain: a } = r, u = li.create(Lm), l = Dj(i2.preload), f = SF(), h = xF({ network: u }), p = new U6(i2), d = Object.values(ow);
            (i2.ipld && i2.ipld.hashers ? i2.ipld.hashers : []).forEach((Ge) => d.push(Ge)), this.hashers = new M1({ hashers: d, loadHasher: i2.ipld && i2.ipld.loadHasher });
            let m = Object.values(Sa);
            (i2.ipld && i2.ipld.bases ? i2.ipld.bases : []).forEach((Ge) => m.push(Ge)), this.bases = new L1({ bases: m, loadBase: i2.ipld && i2.ipld.loadBase });
            let y = new Ow({ repo: s, codecs: n }), g = new s5({ codecs: n, hashers: this.hashers, preload: l, repo: s }), E = new V6({ dns: f, ipns: p, repo: s, codecs: n, peerId: o, isOnline: h, keychain: a, options: i2 }), b = CF({ repo: s, codecs: n, bases: this.bases, name: E }), v = new X5({ repo: s, codecs: n, hashers: this.hashers, preload: l }), S = Object.assign(kz({ repo: s, codecs: n, resolve: b, preload: l }), { local: Nz({ repo: r.repo }) }), { add: x, addAll: T, cat: R, get: O, ls: F } = new q5({ preload: l, repo: s, options: i2.EXPERIMENTAL, hashers: this.hashers }), z = xY({ repo: s, preload: l, hashers: this.hashers, options: i2 }), W = kj({ files: z, preload: l, options: i2.preload });
            this.preload = l, this.name = E, this.ipns = p, this.pin = y, this.resolve = b, this.block = g, this.refs = S, this.start = WU({ network: u, peerId: o, repo: s, preload: l, ipns: p, mfsPreload: W, print: e, keychain: a, hashers: this.hashers, options: i2 }), this.stop = jU({ network: u, preload: l, mfsPreload: W, ipns: p, repo: s }), this.dht = Yde({ network: u, repo: s, peerId: o }), this.pubsub = Zde({ network: u, config: i2.config }), this.dns = f, this.isOnline = h, this.id = ej({ network: u, peerId: o }), this.version = JW({ repo: s }), this.bitswap = new z6({ network: u }), this.bootstrap = new J6({ repo: s }), this.config = rj({ repo: s }), this.ping = Wde({ network: u }), this.add = x, this.addAll = T, this.cat = R, this.get = O, this.ls = F, this.dag = v, this.files = z, this.key = new p8({ keychain: a }), this.object = new y8({ preload: l, codecs: n, repo: s }), this.repo = new w8({ repo: s, hashers: this.hashers }), this.stats = new E8({ repo: s, network: u }), this.swarm = new T7({ network: u }), Object.defineProperty(this, "libp2p", { get() {
              let Ge = u.try();
              return Ge ? Ge.libp2p : void 0;
            } });
            let se = () => Promise.reject((0, I7.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED")), re2 = async function* () {
              throw (0, I7.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
            };
            this.commands = se, this.diag = { cmds: se, net: se, sys: se }, this.log = { level: se, ls: se, tail: re2 }, this.mount = se, this.codecs = n;
          }
          async init() {
            throw new Ts();
          }
        }, OLe = async (t) => {
          let e = je({ Data: new Je({ type: "directory" }).marshal(), Links: [] }), r = await t.block.put(e, { mhtype: "sha2-256", format: "dag-pb" });
          return await t.pin.add(r), r;
        }, LLe = () => ({ start: true, EXPERIMENTAL: {}, preload: { enabled: !Jde.isTest, addresses: ["/dns4/node0.preload.ipfs.io/https", "/dns4/node1.preload.ipfs.io/https", "/dns4/node2.preload.ipfs.io/https", "/dns4/node3.preload.ipfs.io/https"] } });
        async function epe(t = {}) {
          t = NLe(LLe(), t);
          let e = t.init || {}, r = { name: $r.name, code: $r.code, encode: (l) => l, decode: (l) => l }, n = Object.values(sw);
          [At, vc, vp, kLe, r].concat(t.ipld && t.ipld.codecs || []).forEach((l) => n.push(l));
          let i2 = new B1({ codecs: n, loadCodec: t.ipld && t.ipld.loadCodec }), o = t.silent ? kf : console.log;
          kf("creating repo");
          let s = await Om.start(o, i2, t);
          kf("getting repo config");
          let a = await s.repo.config.getAll(), u = new wN({ storage: s, print: o, codecs: i2, options: { ...t, config: a } });
          if (kf("starting preload"), await u.preload.start(), kf("starting storage"), u.ipns.startOffline(s), s.isNew && !e.emptyRepo) {
            let l = await OLe(u);
            if (kf("adding default assets"), await (u.addAll, void 0), kf("initializing IPNS keyspace"), s.peerId.publicKey == null)
              throw (0, I7.default)(new Error("Public key missing"), "ERR_MISSING_PUBLIC_KEY");
            await u.ipns.initializeKeyspace(s.peerId, U(`/ipfs/${l}`));
          }
          return t.start !== false && (kf("starting node"), await u.start()), u;
        }
        var tpe = w(hP(), 1), rpe = w(dP(), 1), BLe = epe, MLe = tpe.default, ULe = rpe.default;
        return cr(FLe);
      })();
      return IpfsCore;
    });
  }
});

// js/ipfs.mjs
init_define_process();

// ../../node_modules/ipfs-message-port-server/src/index.js
init_define_process();

// ../../node_modules/ipfs-message-port-server/src/dag.js
init_define_process();

// ../../node_modules/ipfs-message-port-protocol/src/cid.js
init_define_process();

// ../../node_modules/multiformats/esm/src/cid.js
init_define_process();

// ../../node_modules/multiformats/esm/src/varint.js
init_define_process();

// ../../node_modules/multiformats/esm/vendor/varint.js
init_define_process();
var encode_1 = encode;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
var decode = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N12 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N32 = Math.pow(2, 21);
var N42 = Math.pow(2, 28);
var N52 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N92 = Math.pow(2, 63);
var length = function(value2) {
  return value2 < N12 ? 1 : value2 < N2 ? 2 : value2 < N32 ? 3 : value2 < N42 ? 4 : value2 < N52 ? 5 : value2 < N6 ? 6 : value2 < N7 ? 7 : value2 < N8 ? 8 : value2 < N92 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/multiformats/esm/src/varint.js
var decode2 = (data) => {
  const code2 = varint_default.decode(data);
  return [
    code2,
    varint_default.decode.bytes
  ];
};
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/multiformats/esm/src/hashes/digest.js
init_define_process();

// ../../node_modules/multiformats/esm/src/bytes.js
init_define_process();
var empty = new Uint8Array(0);
var equals = (aa2, bb2) => {
  if (aa2 === bb2)
    return true;
  if (aa2.byteLength !== bb2.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa2.byteLength; ii++) {
    if (aa2[ii] !== bb2[ii]) {
      return false;
    }
  }
  return true;
};
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
var fromString = (str) => new TextEncoder().encode(str);
var toString = (b) => new TextDecoder().decode(b);

// ../../node_modules/multiformats/esm/src/hashes/digest.js
var create = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes);
};
var decode3 = (multihash) => {
  const bytes = coerce(multihash);
  const [code2, sizeOffset] = decode2(bytes);
  const [size, digestOffset] = decode2(bytes.subarray(sizeOffset));
  const digest2 = bytes.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest2, bytes);
};
var equals2 = (a, b) => {
  if (a === b) {
    return true;
  } else {
    return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
  }
};
var Digest = class {
  constructor(code2, size, digest2, bytes) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes;
  }
};

// ../../node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
init_define_process();

// ../../node_modules/multiformats/esm/src/bases/base.js
init_define_process();

// ../../node_modules/multiformats/esm/vendor/base-x.js
init_define_process();
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j8 = 0; j8 < BASE_MAP.length; j8++) {
    BASE_MAP[j8] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x = ALPHABET.charAt(i2);
    var xc2 = x.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode7(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length3 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i4 = 0;
      for (var it1 = size - 1; (carry !== 0 || i4 < length3) && it1 !== -1; it1--, i4++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i4;
      pbegin++;
    }
    var it2 = size - length3;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length3 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i4 = 0;
      for (var it3 = size - 1; (carry !== 0 || i4 < length3) && it3 !== -1; it3--, i4++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length3 = i4;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length3;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j9 = zeroes;
    while (it4 !== size) {
      vch[j9++] = b256[it4++];
    }
    return vch;
  }
  function decode8(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode7,
    decodeUnsafe,
    decode: decode8
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;

// ../../node_modules/multiformats/esm/src/bases/base.js
var Encoder = class {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
var Codec = class {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name: name2, prefix, encode: encode7, decode: decode8 }) => new Codec(name2, prefix, encode7, decode8);
var baseX = ({ prefix, name: name2, alphabet: alphabet3 }) => {
  const { encode: encode7, decode: decode8 } = base_x_default(alphabet3, name2);
  return from({
    prefix,
    name: name2,
    encode: encode7,
    decode: (text) => coerce(decode8(text))
  });
};
var decode4 = (string2, alphabet3, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet3.length; ++i2) {
    codes2[alphabet3[i2]] = i2;
  }
  let end = string2.length;
  while (string2[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i2 = 0; i2 < end; ++i2) {
    const value2 = codes2[string2[i2]];
    if (value2 === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer = buffer << bitsPerChar | value2;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode2 = (data, alphabet3, bitsPerChar) => {
  const pad = alphabet3[alphabet3.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer = buffer << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet3[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet3[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet3 }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode2(input, alphabet3, bitsPerChar);
    },
    decode(input) {
      return decode4(input, alphabet3, bitsPerChar, name2);
    }
  });
};

// ../../node_modules/multiformats/esm/src/bases/base58.js
var base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
init_define_process();
var base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
var base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
var base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
var base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
var base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
var base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
var base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
var base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});

// ../../node_modules/multiformats/esm/src/cid.js
var CID = class {
  constructor(version2, code2, multihash, bytes) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes;
    this.byteOffset = bytes.byteOffset;
    this.byteLength = bytes.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
  }
  toString(base4) {
    const { bytes, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes, _baseCache, base4 || base58btc.encoder);
      default:
        return toStringV1(bytes, _baseCache, base4 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value2) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value2 && (value2[cidSymbol] || value2.asCID === value2));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value2) {
    if (value2 instanceof CID) {
      return value2;
    } else if (value2 != null && value2.asCID === value2) {
      const { version: version2, code: code2, multihash, bytes } = value2;
      return new CID(version2, code2, multihash, bytes || encodeCID(version2, code2, multihash.bytes));
    } else if (value2 != null && value2[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value2;
      const digest2 = decode3(multihash);
      return CID.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes = encodeCID(version2, code2, digest2.bytes);
        return new CID(version2, code2, digest2, bytes);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return CID.create(1, code2, digest2);
  }
  static decode(bytes) {
    const [cid, remainder] = CID.decodeFirst(bytes);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes) {
    const specs = CID.inspectBytes(bytes);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length3] = decode2(initialBytes.subarray(offset));
      offset += length3;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base4) {
    const [prefix, bytes] = parseCIDtoBytes(source, base4);
    const cid = CID.decode(bytes);
    cid._baseCache.set(prefix, source);
    return cid;
  }
};
var parseCIDtoBytes = (source, base4) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base4 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base4 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base4 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base4.decode(source)
      ];
    }
  }
};
var toStringV0 = (bytes, cache2, base4) => {
  const { prefix } = base4;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
  }
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes).slice(1);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var toStringV1 = (bytes, cache2, base4) => {
  const { prefix } = base4;
  const cid = cache2.get(prefix);
  if (cid == null) {
    const cid2 = base4.encode(bytes);
    cache2.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version2, code2, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes, 0);
  encodeTo(code2, bytes, codeOffset);
  bytes.set(multihash, hashOffset);
  return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
var readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
var hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
var version = "0.0.0-dev";
var deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;

// ../../node_modules/ipfs-message-port-protocol/src/cid.js
var encodeCID2 = (cid, transfer) => {
  if (transfer) {
    transfer.add(cid.multihash.bytes.buffer);
  }
  return cid;
};
var decodeCID = (encodedCID) => {
  const cid = encodedCID;
  if (!cid._baseCache) {
    Object.defineProperty(cid, "_baseCache", {
      value: /* @__PURE__ */ new Map()
    });
  }
  if (!cid.asCID) {
    Object.defineProperty(cid, "asCID", {
      get: () => cid
    });
  }
  Object.setPrototypeOf(cid.multihash.digest, Uint8Array.prototype);
  Object.setPrototypeOf(cid.multihash.bytes, Uint8Array.prototype);
  Object.setPrototypeOf(cid.bytes, Uint8Array.prototype);
  Object.setPrototypeOf(cid, CID.prototype);
  Object.defineProperty(cid, Symbol.for("@ipld/js-cid/CID"), { value: true });
  return cid;
};

// ../../node_modules/ipfs-message-port-protocol/src/dag.js
init_define_process();
var decodeNode = ({ dagNode, cids }) => {
  for (const cid of cids) {
    decodeCID(cid);
  }
  return dagNode;
};
var encodeNode = (dagNode, transfer) => {
  const cids = [];
  collectNode(dagNode, cids, transfer);
  return { dagNode, cids };
};
var collectNode = (value2, cids, transfer) => {
  if (value2 != null && typeof value2 === "object") {
    const cid = CID.asCID(value2);
    if (cid) {
      cids.push(cid);
      encodeCID2(cid, transfer);
    } else if (value2 instanceof ArrayBuffer) {
      if (transfer) {
        transfer.add(value2);
      }
    } else if (ArrayBuffer.isView(value2)) {
      if (transfer) {
        transfer.add(value2.buffer);
      }
    } else if (Array.isArray(value2)) {
      for (const member of value2) {
        collectNode(member, cids, transfer);
      }
    } else {
      for (const member of Object.values(value2)) {
        collectNode(member, cids, transfer);
      }
    }
  }
};

// ../../node_modules/ipfs-message-port-server/src/dag.js
var DAGService = class {
  constructor(ipfs) {
    this.ipfs = ipfs;
  }
  async put(query) {
    const dagNode = decodeNode(query.dagNode);
    const cid = await this.ipfs.dag.put(dagNode, query);
    return encodeCID2(cid);
  }
  async get(query) {
    const { cid, path, localResolve, timeout, signal } = query;
    const { value: value2, remainderPath } = await this.ipfs.dag.get(decodeCID(cid), {
      path,
      localResolve,
      timeout,
      signal
    });
    const transfer = /* @__PURE__ */ new Set();
    return { remainderPath, value: encodeNode(value2, transfer), transfer };
  }
  async resolve(query) {
    const { cid, remainderPath } = await this.ipfs.dag.resolve(decodePathOrCID(query.cid), query);
    return {
      cid: encodeCID2(cid),
      remainderPath
    };
  }
};
var decodePathOrCID = (input) => {
  if (typeof input === "string") {
    return input;
  } else {
    return decodeCID(input);
  }
};

// ../../node_modules/ipfs-message-port-server/src/core.js
init_define_process();

// ../../node_modules/ipfs-message-port-protocol/src/core.js
init_define_process();

// ../../node_modules/ipfs-message-port-protocol/src/error.js
init_define_process();
var encodeError = (error) => {
  const { name: name2, message, stack, code: code2, detail } = error;
  return { name: name2, message, stack, code: code2, detail };
};
var decodeError = (error) => {
  if (error instanceof Error) {
    return error;
  } else {
    const { name: name2, message, stack, code: code2 } = error;
    return Object.assign(createError(name2, message), { name: name2, stack, code: code2 });
  }
};
var createError = (name2, message) => {
  switch (name2) {
    case "RangeError": {
      return new RangeError(message);
    }
    case "ReferenceError": {
      return ReferenceError(message);
    }
    case "SyntaxError": {
      return new SyntaxError(message);
    }
    case "TypeError": {
      return new TypeError(message);
    }
    case "URIError": {
      return new URIError(message);
    }
    default: {
      return new Error(message);
    }
  }
};

// ../../node_modules/ipfs-message-port-protocol/src/core.js
var decodeIterable = async function* ({ port }, decode8) {
  let receive = (_data) => {
  };
  const wait = () => new Promise((resolve) => receive = resolve);
  const next = () => {
    port.postMessage({ method: "next" });
    return wait();
  };
  port.onmessage = (event) => receive(event.data);
  let isDone = false;
  try {
    while (!isDone) {
      const { done, value: value2, error } = await next();
      isDone = done;
      if (error != null) {
        throw decodeError(error);
      } else if (value2 != null) {
        yield decode8(value2);
      }
    }
  } finally {
    if (!isDone) {
      port.postMessage({ method: "return" });
    }
    port.close();
  }
};
var encodeIterable = (iterable, encode7, transfer) => {
  const { port1: port, port2: remote } = new MessageChannel();
  const iterator = toIterator(iterable);
  const itemTransfer = /* @__PURE__ */ new Set();
  port.onmessage = async ({ data: { method } }) => {
    switch (method) {
      case "next": {
        try {
          const { done, value: value2 } = await iterator.next();
          if (done) {
            port.postMessage({ type: "next", done: true });
            port.close();
          } else {
            itemTransfer.clear();
            const encodedValue = encode7(value2, itemTransfer);
            postMessage(port, {
              type: "next",
              done: false,
              value: encodedValue
            }, itemTransfer);
          }
        } catch (error) {
          port.postMessage({
            type: "throw",
            error: encodeError(error)
          });
          port.close();
        }
        break;
      }
      case "return": {
        port.close();
        if (iterator.return) {
          iterator.return();
        }
        break;
      }
      default: {
        break;
      }
    }
  };
  port.start();
  transfer.add(remote);
  return { type: "RemoteIterable", port: remote };
};
var toIterator = (iterable) => {
  if (iterable != null) {
    if (typeof iterable[Symbol.asyncIterator] === "function") {
      return iterable[Symbol.asyncIterator]();
    }
    if (typeof iterable[Symbol.iterator] === "function") {
      return iterable[Symbol.iterator]();
    }
  }
  throw TypeError("Value must be async or sync iterable");
};
var decodeCallback = ({ port }) => {
  const callback = (args, transfer) => {
    postMessage(port, args, transfer);
  };
  return callback;
};
var postMessage = (port, message, transfer) => port.postMessage(message, transfer);

// ../../node_modules/ipfs-message-port-server/src/core.js
var CoreService = class {
  constructor(ipfs) {
    this.ipfs = ipfs;
  }
  addAll(query) {
    const { input } = query;
    const {
      chunker,
      cidVersion,
      enableShardingExperiment,
      hashAlg,
      onlyHash,
      pin,
      progressCallback,
      rawLeaves,
      shardSplitThreshold,
      trickle,
      wrapWithDirectory,
      timeout,
      signal
    } = query;
    let progress;
    if (progressCallback) {
      const fn2 = decodeCallback(progressCallback);
      progress = (bytes, fileName) => {
        fn2([bytes, fileName]);
      };
    }
    const options = {
      chunker,
      cidVersion,
      enableShardingExperiment,
      hashAlg,
      onlyHash,
      pin,
      rawLeaves,
      shardSplitThreshold,
      trickle,
      wrapWithDirectory,
      timeout,
      progress,
      signal
    };
    const content = decodeAddAllInput(input);
    return encodeAddAllResult(this.ipfs.addAll(content, options));
  }
  async add(query) {
    const { input } = query;
    const {
      chunker,
      cidVersion,
      hashAlg,
      onlyHash,
      pin,
      progressCallback,
      rawLeaves,
      trickle,
      wrapWithDirectory,
      timeout,
      signal
    } = query;
    let progress;
    if (progressCallback) {
      const fn2 = decodeCallback(progressCallback);
      progress = (bytes, fileName) => {
        fn2([bytes, fileName]);
      };
    }
    const options = {
      chunker,
      cidVersion,
      hashAlg,
      onlyHash,
      pin,
      rawLeaves,
      trickle,
      wrapWithDirectory,
      timeout,
      progress,
      signal
    };
    const content = decodeAddInput(input);
    return encodeAddResult(await this.ipfs.add(content, options));
  }
  cat(query) {
    const { path, offset, length: length3, timeout, signal } = query;
    const location2 = typeof path === "string" ? path : decodeCID(path);
    const content = this.ipfs.cat(location2, { offset, length: length3, timeout, signal });
    return encodeCatResult(content);
  }
  ls(query) {
    const { path, recursive, preload, timeout, signal } = query;
    const location2 = typeof path === "string" ? path : decodeCID(path);
    const entries = this.ipfs.ls(location2, { recursive, preload, timeout, signal });
    return encodeLsResult(entries);
  }
};
var decodeAddAllInput = (input) => decodeIterable(input, decodeFileInput);
var decodeAddInput = (input) => matchInput(input, (data) => {
  if (data.type === "RemoteIterable") {
    return { content: decodeIterable(data, decodeFileInput) };
  } else {
    return decodeFileInput(data);
  }
});
var decodeFileInput = (input) => matchInput(input, (file) => ({
  ...file,
  content: file.content && decodeFileContent(file.content)
}));
var decodeFileContent = (content) => matchInput(content, (input) => decodeIterable(input, identity));
var matchInput = (input, decode8) => {
  if (typeof input === "string" || input instanceof ArrayBuffer || input instanceof Blob || ArrayBuffer.isView(input)) {
    return input;
  } else {
    return decode8(input);
  }
};
var encodeAddAllResult = (out) => {
  const transfer = /* @__PURE__ */ new Set();
  return {
    data: encodeIterable(out, encodeFileOutput, transfer),
    transfer
  };
};
var encodeAddResult = (out) => {
  const transfer = /* @__PURE__ */ new Set();
  return {
    data: encodeFileOutput(out, transfer),
    transfer
  };
};
var encodeCatResult = (content) => {
  const transfer = /* @__PURE__ */ new Set();
  return { data: encodeIterable(content, moveBuffer, transfer), transfer };
};
var encodeLsResult = (entries) => {
  const transfer = /* @__PURE__ */ new Set();
  return { data: encodeIterable(entries, encodeLsEntry, transfer), transfer };
};
var encodeLsEntry = ({ name: name2, path, size, cid, type, mode, mtime }) => ({
  cid: encodeCID2(cid),
  type,
  name: name2,
  path,
  mode,
  mtime,
  size
});
var moveBuffer = (buffer, transfer) => {
  transfer.add(buffer.buffer);
  return buffer;
};
var encodeFileOutput = (file, _transfer) => ({
  ...file,
  cid: encodeCID2(file.cid)
});
var identity = (v) => v;

// ../../node_modules/ipfs-message-port-server/src/files.js
init_define_process();
var FilesService = class {
  constructor(ipfs) {
    this.ipfs = ipfs;
  }
  async stat(input) {
    const stat = await this.ipfs.files.stat(input.path, input);
    const transfer = /* @__PURE__ */ new Set();
    return { stat: { ...stat, cid: encodeCID2(stat.cid, transfer) }, transfer };
  }
};

// ../../node_modules/ipfs-message-port-server/src/block.js
init_define_process();
var import_it_all = __toESM(require_it_all(), 1);

// ../../node_modules/ipfs-message-port-protocol/src/block.js
init_define_process();
var encodeBlock = (data, transfer) => {
  if (transfer) {
    transfer.add(data.buffer);
  }
  return data;
};

// ../../node_modules/ipfs-message-port-server/src/block.js
var BlockService = class {
  constructor(ipfs) {
    this.ipfs = ipfs;
  }
  async get(query) {
    const cid = decodeCID(query.cid);
    const block = await this.ipfs.block.get(cid, query);
    const transfer = /* @__PURE__ */ new Set();
    return { transfer, block: encodeBlock(block, transfer) };
  }
  async put(query) {
    const input = query.block;
    const result = await this.ipfs.block.put(input, query);
    const transfer = /* @__PURE__ */ new Set();
    return { transfer, cid: encodeCID2(result, transfer) };
  }
  async rm(query) {
    const transfer = /* @__PURE__ */ new Set();
    const result = await (0, import_it_all.default)(this.ipfs.block.rm(query.cids.map(decodeCID), query));
    return result.map((entry) => encodeRmEntry(entry, transfer));
  }
  async stat(query) {
    const cid = decodeCID(query.cid);
    const result = await this.ipfs.block.stat(cid, query);
    return { ...result, cid: encodeCID2(result.cid) };
  }
};
var encodeRmEntry = (entry, transfer) => {
  const cid = encodeCID2(entry.cid, transfer);
  if (entry.error) {
    return { cid, error: encodeError(entry.error) };
  } else {
    return { cid };
  }
};

// ../../node_modules/ipfs-message-port-server/src/service.js
init_define_process();
var IPFSService = class {
  constructor(ipfs) {
    this.dag = new DAGService(ipfs);
    this.core = new CoreService(ipfs);
    this.files = new FilesService(ipfs);
    this.block = new BlockService(ipfs);
  }
};

// ../../node_modules/ipfs-message-port-server/src/server.js
init_define_process();
var Query = class {
  constructor(namespace, method, input) {
    this.result = new Promise((resolve, reject) => {
      this.succeed = resolve;
      this.fail = reject;
      this.namespace = namespace;
      this.method = method;
      this.input = input;
      this.abortController = new AbortController();
      this.signal = this.abortController.signal;
    });
  }
  abort() {
    this.abortController.abort();
    this.fail(new AbortError());
  }
};
var Server = class {
  constructor(services) {
    this.services = services;
    this.queries = /* @__PURE__ */ Object.create(null);
  }
  connect(port) {
    port.addEventListener("message", this);
    port.start();
  }
  disconnect(port) {
    port.removeEventListener("message", this);
    port.close();
  }
  handleEvent(event) {
    const data = event.data;
    switch (data.type) {
      case "query": {
        this.handleQuery(data.id, new Query(data.namespace, data.method, data.input), event.target);
        return void 0;
      }
      case "abort": {
        return this.abort(data.id);
      }
      default: {
        throw new UnsupportedMessageError(event);
      }
    }
  }
  abort(id) {
    const query = this.queries[id];
    if (query) {
      delete this.queries[id];
      query.abort();
    }
  }
  async handleQuery(id, query, port) {
    this.queries[id] = query;
    await this.run(query);
    delete this.queries[id];
    if (!query.signal.aborted) {
      try {
        const value2 = await query.result;
        const transfer = value2.transfer;
        delete value2.transfer;
        port.postMessage({ type: "result", id, result: { ok: true, value: value2 } }, transfer);
      } catch (error) {
        port.postMessage({
          type: "result",
          id,
          result: { ok: false, error: encodeError(error) }
        });
      }
    }
  }
  run(query) {
    const { services } = this;
    const { namespace, method } = query;
    const service = services[namespace];
    if (service) {
      if (typeof service[method] === "function") {
        try {
          const result = service[method]({ ...query.input, signal: query.signal });
          Promise.resolve(result).then(query.succeed, query.fail);
        } catch (error) {
          query.fail(error);
        }
      } else {
        query.fail(new RangeError(`Method '${String(method)}' is not found`));
      }
    } else {
      query.fail(new RangeError(`Namespace '${String(namespace)}' is not found`));
    }
  }
  execute(data) {
    const query = new Query(data.namespace, data.method, data.input);
    this.run(query);
    return query.result;
  }
};
var UnsupportedMessageError = class extends RangeError {
  constructor(event) {
    super("Unexpected message was received by the server");
    this.event = event;
  }
  get name() {
    return this.constructor.name;
  }
};
var AbortError = class AbortError2 extends Error {
  get name() {
    return this.constructor.name;
  }
};

// ../../node_modules/ipfs-core-config/src/config.browser.js
init_define_process();
var config_browser_default = () => ({
  Addresses: {
    Swarm: [],
    Announce: [],
    NoAnnounce: [],
    API: "",
    Gateway: "",
    RPC: "",
    Delegates: [
      "/dns4/node0.delegate.ipfs.io/tcp/443/https",
      "/dns4/node1.delegate.ipfs.io/tcp/443/https",
      "/dns4/node2.delegate.ipfs.io/tcp/443/https",
      "/dns4/node3.delegate.ipfs.io/tcp/443/https"
    ]
  },
  Discovery: {
    MDNS: {
      Enabled: false,
      Interval: 10
    },
    webRTCStar: {
      Enabled: true
    }
  },
  Bootstrap: [
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
    "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
    "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
    "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
    "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
    "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
  ],
  Pubsub: {
    Enabled: true
  },
  Swarm: {
    ConnMgr: {
      LowWater: 5,
      HighWater: 20
    },
    DisableNatPortMap: true
  },
  Routing: {
    Type: "dhtclient"
  }
});

// ../../node_modules/ipfs-core-config/src/libp2p.browser.js
init_define_process();

// ../../node_modules/@libp2p/webrtc-star/dist/src/index.js
init_define_process();

// ../../node_modules/@libp2p/logger/dist/src/index.js
init_define_process();
var import_debug = __toESM(require_browser(), 1);

// ../../node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
init_define_process();
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/@libp2p/logger/dist/src/index.js
import_debug.default.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc.baseEncode(v);
};
import_debug.default.formatters.t = (v) => {
  return v == null ? "undefined" : base32.baseEncode(v);
};
import_debug.default.formatters.m = (v) => {
  return v == null ? "undefined" : base64.baseEncode(v);
};
import_debug.default.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
import_debug.default.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function logger(name2) {
  return Object.assign((0, import_debug.default)(name2), {
    error: (0, import_debug.default)(`${name2}:error`),
    trace: (0, import_debug.default)(`${name2}:trace`)
  });
}

// ../../node_modules/@libp2p/webrtc-star/dist/src/index.js
var import_err_code8 = __toESM(require_err_code(), 1);

// ../../node_modules/abortable-iterator/dist/src/index.js
init_define_process();

// ../../node_modules/abortable-iterator/dist/src/abort-error.js
init_define_process();
var AbortError3 = class extends Error {
  constructor(message, code2) {
    super(message ?? "The operation was aborted");
    this.type = "aborted";
    this.code = code2 ?? "ABORT_ERR";
  }
};

// ../../node_modules/abortable-iterator/node_modules/get-iterator/dist/src/index.js
init_define_process();
function getIterator(obj) {
  if (obj != null) {
    if (typeof obj[Symbol.iterator] === "function") {
      return obj[Symbol.iterator]();
    }
    if (typeof obj[Symbol.asyncIterator] === "function") {
      return obj[Symbol.asyncIterator]();
    }
    if (typeof obj.next === "function") {
      return obj;
    }
  }
  throw new Error("argument is not an iterator or iterable");
}

// ../../node_modules/abortable-iterator/dist/src/index.js
function abortableSource(source, signal, options) {
  const opts = options ?? {};
  const iterator = getIterator(source);
  async function* abortable() {
    let nextAbortHandler;
    const abortHandler = () => {
      if (nextAbortHandler != null)
        nextAbortHandler();
    };
    signal.addEventListener("abort", abortHandler);
    while (true) {
      let result;
      try {
        if (signal.aborted) {
          const { abortMessage, abortCode } = opts;
          throw new AbortError3(abortMessage, abortCode);
        }
        const abort = new Promise((resolve, reject) => {
          nextAbortHandler = () => {
            const { abortMessage, abortCode } = opts;
            reject(new AbortError3(abortMessage, abortCode));
          };
        });
        result = await Promise.race([abort, iterator.next()]);
        nextAbortHandler = null;
      } catch (err) {
        signal.removeEventListener("abort", abortHandler);
        const isKnownAborter = err.type === "aborted" && signal.aborted;
        if (isKnownAborter && opts.onAbort != null) {
          await opts.onAbort(source);
        }
        if (typeof iterator.return === "function") {
          try {
            const p = iterator.return();
            if (p instanceof Promise) {
              p.catch((err2) => {
                if (opts.onReturnError != null) {
                  opts.onReturnError(err2);
                }
              });
            }
          } catch (err2) {
            if (opts.onReturnError != null) {
              opts.onReturnError(err2);
            }
          }
        }
        if (isKnownAborter && opts.returnOnAbort === true) {
          return;
        }
        throw err;
      }
      if (result.done === true) {
        break;
      }
      yield result.value;
    }
    signal.removeEventListener("abort", abortHandler);
  }
  return abortable();
}

// ../../node_modules/@multiformats/multiaddr/dist/src/index.js
init_define_process();

// ../../node_modules/@multiformats/multiaddr/dist/src/codec.js
init_define_process();

// ../../node_modules/@multiformats/multiaddr/dist/src/convert.js
init_define_process();

// ../../node_modules/@multiformats/multiaddr/dist/src/ip.js
init_define_process();

// ../../node_modules/@multiformats/multiaddr/node_modules/is-ip/index.js
init_define_process();

// ../../node_modules/@multiformats/multiaddr/node_modules/ip-regex/index.js
init_define_process();
var word = "[a-fA-F\\d:]";
var boundry = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
var v42 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6segment = "[a-fA-F\\d]{1,4}";
var v62 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v42}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v42}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v42}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v42}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v42}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v42}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v42}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v42}$)|(?:^${v62}$)`);
var v4exact = new RegExp(`^${v42}$`);
var v6exact = new RegExp(`^${v62}$`);
var ipRegex = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${boundry(options)}${v42}${boundry(options)})|(?:${boundry(options)}${v62}${boundry(options)})`, "g");
ipRegex.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${boundry(options)}${v42}${boundry(options)}`, "g");
ipRegex.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${boundry(options)}${v62}${boundry(options)}`, "g");
var ip_regex_default = ipRegex;

// ../../node_modules/@multiformats/multiaddr/node_modules/is-ip/index.js
function isIP(string2) {
  return ip_regex_default({ exact: true }).test(string2);
}
function isIPv6(string2) {
  return ip_regex_default.v6({ exact: true }).test(string2);
}
function isIPv4(string2) {
  return ip_regex_default.v4({ exact: true }).test(string2);
}

// ../../node_modules/uint8arrays/esm/src/to-string.js
init_define_process();

// ../../node_modules/uint8arrays/esm/src/util/bases.js
init_define_process();

// ../../node_modules/multiformats/esm/src/basics.js
init_define_process();

// ../../node_modules/multiformats/esm/src/bases/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity2
});
init_define_process();
var identity2 = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString(buf),
  decode: (str) => fromString(str)
});

// ../../node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
init_define_process();
var base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});

// ../../node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
init_define_process();
var base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});

// ../../node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
init_define_process();
var base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});

// ../../node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
init_define_process();
var base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
var base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});

// ../../node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
init_define_process();
var base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
var base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});

// ../../node_modules/multiformats/esm/src/bases/base256emoji.js
var base256emoji_exports = {};
__export(base256emoji_exports, {
  base256emoji: () => base256emoji
});
init_define_process();
var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var alphabetBytesToChars = alphabet.reduce((p, c2, i2) => {
  p[i2] = c2;
  return p;
}, []);
var alphabetCharsToBytes = alphabet.reduce((p, c2, i2) => {
  p[c2.codePointAt(0)] = i2;
  return p;
}, []);
function encode3(data) {
  return data.reduce((p, c2) => {
    p += alphabetBytesToChars[c2];
    return p;
  }, "");
}
function decode5(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
var base256emoji = from({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode3,
  decode: decode5
});

// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
init_define_process();

// ../../node_modules/multiformats/esm/src/hashes/hasher.js
init_define_process();
var from2 = ({ name: name2, code: code2, encode: encode7 }) => new Hasher(name2, code2, encode7);
var Hasher = class {
  constructor(name2, code2, encode7) {
    this.name = name2;
    this.code = code2;
    this.encode = encode7;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});

// ../../node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity3
});
init_define_process();
var code = 0;
var name = "identity";
var encode4 = coerce;
var digest = (input) => create(code, encode4(input));
var identity3 = {
  code,
  name,
  encode: encode4,
  digest
};

// ../../node_modules/multiformats/esm/src/codecs/raw.js
init_define_process();

// ../../node_modules/multiformats/esm/src/codecs/json.js
init_define_process();
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

// ../../node_modules/multiformats/esm/src/index.js
init_define_process();

// ../../node_modules/multiformats/esm/src/basics.js
var bases = {
  ...identity_exports,
  ...base2_exports,
  ...base8_exports,
  ...base10_exports,
  ...base16_exports,
  ...base32_exports,
  ...base36_exports,
  ...base58_exports,
  ...base64_exports,
  ...base256emoji_exports
};
var hashes = {
  ...sha2_browser_exports,
  ...identity_exports2
};

// ../../node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name2, prefix, encode7, decode8) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode7
    },
    decoder: { decode: decode8 }
  };
}
var string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
var ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf.length; i2++) {
    string2 += String.fromCharCode(buf[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = new Uint8Array(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf[i2] = str.charCodeAt(i2);
  }
  return buf;
});
var BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
var bases_default = BASES;

// ../../node_modules/uint8arrays/esm/src/to-string.js
function toString2(array, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.encoder.encode(array).substring(1);
}

// ../../node_modules/@multiformats/multiaddr/dist/src/ip.js
var isV4 = isIPv4;
var isV6 = isIPv6;
var toBytes = function(ip) {
  let offset = 0;
  let result;
  if (isV4(ip)) {
    result = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      result[offset++] = parseInt(byte, 10) & 255;
    });
  } else if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isV4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i2]);
        sections[i2] = toString2(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString2(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
        ;
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    result = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      const word2 = parseInt(sections[i2], 16);
      result[offset++] = word2 >> 8 & 255;
      result[offset++] = word2 & 255;
    }
  }
  if (result == null) {
    throw Error("Invalid ip address: " + ip);
  }
  return result;
};
var toString3 = function(buf, offset, length3) {
  offset = ~~offset;
  length3 = length3 ?? buf.length - offset;
  const result = [];
  let string2 = "";
  const view = new DataView(buf.buffer);
  if (length3 === 4) {
    for (let i2 = 0; i2 < length3; i2++) {
      result.push(buf[offset + i2]);
    }
    string2 = result.join(".");
  } else if (length3 === 16) {
    for (let i2 = 0; i2 < length3; i2 += 2) {
      result.push(view.getUint16(offset + i2).toString(16));
    }
    string2 = result.join(":");
    string2 = string2.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
    string2 = string2.replace(/:{3,4}/, "::");
  }
  return string2;
};

// ../../node_modules/@multiformats/multiaddr/dist/src/protocols-table.js
init_define_process();
var V = -1;
var names = {};
var codes = {};
var table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  [421, V, "ipfs"],
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [460, 0, "quic"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code2, size, name2, resolvable, path) {
  return {
    code: code2,
    size,
    name: name2,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}

// ../../node_modules/@multiformats/multiaddr/dist/src/convert.js
var import_varint2 = __toESM(require_varint(), 1);

// ../../node_modules/uint8arrays/esm/src/from-string.js
init_define_process();
function fromString2(string2, encoding = "utf8") {
  const base4 = bases_default[encoding];
  if (!base4) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base4.decoder.decode(`${base4.prefix}${string2}`);
}

// ../../node_modules/uint8arrays/esm/src/concat.js
init_define_process();
function concat(arrays, length3) {
  if (!length3) {
    length3 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length3);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}

// ../../node_modules/@multiformats/multiaddr/dist/src/convert.js
function convertToString(proto, buf) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
    case 41:
      return bytes2ip(buf);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf);
    case 421:
      return bytes2mh(buf);
    case 444:
      return bytes2onion(buf);
    case 445:
      return bytes2onion(buf);
    default:
      return toString2(buf, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol4 = getProtocol(proto);
  switch (protocol4.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    default:
      return fromString2(str, "base16");
  }
}
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString3(ipBuff, 0, ipBuff.length);
  if (ipString == null || !isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf = new ArrayBuffer(2);
  const view = new DataView(buf);
  view.setUint16(0, port);
  return new Uint8Array(buf);
}
function bytes2port(buf) {
  const view = new DataView(buf.buffer);
  return view.getUint16(buf.byteOffset);
}
function str2bytes(str) {
  const buf = fromString2(str);
  const size = Uint8Array.from(import_varint2.default.encode(buf.length));
  return concat([size, buf], size.length + buf.length);
}
function bytes2str(buf) {
  const size = import_varint2.default.decode(buf);
  buf = buf.slice(import_varint2.default.decode.bytes);
  if (buf.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(buf);
}
function mh2bytes(hash) {
  let mh2;
  if (hash[0] === "Q" || hash[0] === "1") {
    mh2 = decode3(base58btc.decode(`z${hash}`)).bytes;
  } else {
    mh2 = CID.parse(hash).multihash.bytes;
  }
  const size = Uint8Array.from(import_varint2.default.encode(mh2.length));
  return concat([size, mh2], size.length + mh2.length);
}
function bytes2mh(buf) {
  const size = import_varint2.default.decode(buf);
  const address = buf.slice(import_varint2.default.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString2(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf = base32.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf = base32.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf, portBuf], buf.length + portBuf.length);
}
function bytes2onion(buf) {
  const addrBytes = buf.slice(0, buf.length - 2);
  const portBytes = buf.slice(buf.length - 2);
  const addr = toString2(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}

// ../../node_modules/@multiformats/multiaddr/dist/src/codec.js
var import_varint3 = __toESM(require_varint(), 1);
function stringToStringTuples(str) {
  const tuples = [];
  const parts2 = str.split("/").slice(1);
  if (parts2.length === 1 && parts2[0] === "") {
    return [];
  }
  for (let p = 0; p < parts2.length; p++) {
    const part = parts2[p];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p++;
    if (p >= parts2.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        cleanPath(parts2.slice(p).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts2[p]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts2 = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts2.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts2.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts2.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf = Uint8Array.from(import_varint3.default.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf = concat([buf, tup[1]]);
    }
    return buf;
  })));
}
function sizeForAddr(p, addr) {
  if (p.size > 0) {
    return p.size / 8;
  } else if (p.size === 0) {
    return 0;
  } else {
    const size = import_varint3.default.decode(addr);
    return size + import_varint3.default.decode.bytes;
  }
}
function bytesToTuples(buf) {
  const tuples = [];
  let i2 = 0;
  while (i2 < buf.length) {
    const code2 = import_varint3.default.decode(buf, i2);
    const n = import_varint3.default.decode.bytes;
    const p = getProtocol(code2);
    const size = sizeForAddr(p, buf.slice(i2 + n));
    if (size === 0) {
      tuples.push([code2]);
      i2 += n;
      continue;
    }
    const addr = buf.slice(i2 + n, i2 + n + size);
    i2 += size + n;
    if (i2 > buf.length) {
      throw ParseError("Invalid address Uint8Array: " + toString2(buf, "base16"));
    }
    tuples.push([code2, addr]);
  }
  return tuples;
}
function bytesToString(buf) {
  const a = bytesToTuples(buf);
  const b = tuplesToStringTuples(a);
  return stringTuplesToString(b);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a = stringToStringTuples(str);
  const b = stringTuplesToTuples(a);
  return tuplesToBytes(b);
}
function fromString3(str) {
  return stringToBytes(str);
}
function fromBytes(buf) {
  const err = validateBytes(buf);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf);
}
function validateBytes(buf) {
  try {
    bytesToTuples(buf);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a) => a).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}

// ../../node_modules/@multiformats/multiaddr/dist/src/index.js
var import_varint4 = __toESM(require_varint(), 1);
var import_err_code = __toESM(require_err_code(), 1);

// ../../node_modules/uint8arrays/esm/src/equals.js
init_define_process();
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a.byteLength; i2++) {
    if (a[i2] !== b[i2]) {
      return false;
    }
  }
  return true;
}

// ../../node_modules/@multiformats/multiaddr/dist/src/index.js
var inspect = Symbol.for("nodejs.util.inspect.custom");
var IP_CODES = [
  getProtocol("ip4").code,
  getProtocol("ip6").code
];
var DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
var P2P_CODES = [
  getProtocol("p2p").code,
  getProtocol("ipfs").code
];
var TCP_UDP_CODES = [
  getProtocol("tcp").code,
  getProtocol("udp").code
];
var resolvers = /* @__PURE__ */ new Map();
var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
var Multiaddr = class {
  constructor(addr) {
    if (addr == null) {
      addr = "";
    }
    Object.defineProperty(this, symbol, { value: true });
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString3(addr);
    } else if (Multiaddr.isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    return bytesToString(this.bytes);
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    const codes2 = this.protoCodes();
    const parts2 = this.toString().split("/").slice(1);
    let transport;
    let port;
    if (parts2.length > 2) {
      if (DNS_CODES.includes(codes2[0]) && P2P_CODES.includes(codes2[1])) {
        transport = getProtocol("tcp").name;
        port = 443;
      } else {
        transport = getProtocol(parts2[2]).name;
        port = parseInt(parts2[3]);
      }
    } else if (DNS_CODES.includes(codes2[0])) {
      transport = getProtocol("tcp").name;
      port = 443;
    } else {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family: codes2[0] === 41 || codes2[0] === 55 ? 6 : 4,
      host: parts2[1],
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code2) => Object.assign({}, getProtocol(code2)));
  }
  protoCodes() {
    const codes2 = [];
    const buf = this.bytes;
    let i2 = 0;
    while (i2 < buf.length) {
      const code2 = import_varint4.default.decode(buf, i2);
      const n = import_varint4.default.decode.bytes;
      const p = getProtocol(code2);
      const size = sizeForAddr(p, buf.slice(i2 + n));
      i2 += size + n;
      codes2.push(code2);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    return bytesToTuples(this.bytes);
  }
  stringTuples() {
    const t = bytesToTuples(this.bytes);
    return tuplesToStringTuples(t);
  }
  encapsulate(addr) {
    addr = new Multiaddr(addr);
    return new Multiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i2 = s.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new Multiaddr(s.slice(0, i2));
  }
  decapsulateCode(code2) {
    const tuples = this.tuples();
    for (let i2 = tuples.length - 1; i2 >= 0; i2--) {
      if (tuples[i2][0] === code2) {
        return new Multiaddr(tuplesToBytes(tuples.slice(0, i2)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if (tuple?.[1] != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString2(base58btc.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString2(CID.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path == null) {
        path = null;
      }
    } catch {
      path = null;
    }
    return path;
  }
  equals(addr) {
    return equals3(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw (0, import_err_code.default)(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a) => new Multiaddr(a));
  }
  nodeAddress() {
    const codes2 = this.protoCodes();
    const names2 = this.protoNames();
    const parts2 = this.toString().split("/").slice(1);
    let protocol4 = getProtocol(parts2[2]).code;
    let port = parseInt(parts2[3]);
    if (DNS_CODES.includes(codes2[0]) && P2P_CODES.includes(codes2[1])) {
      protocol4 = getProtocol("tcp").code;
      port = 443;
    }
    if (parts2.length < 4) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    } else if (!IP_CODES.includes(codes2[0]) && !DNS_CODES.includes(codes2[0])) {
      throw new Error(`no protocol with name: "'${names2[0]}'". Must have a valid family name: "{ip4, ip6, dns, dns4, dns6, dnsaddr}".`);
    } else if (!TCP_UDP_CODES.includes(protocol4)) {
      throw new Error(`no protocol with name: "'${names2[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
    }
    return {
      family: codes2[0] === 41 || codes2[0] === 55 ? 6 : 4,
      address: parts2[1],
      port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr ?? this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  static fromNodeAddress(addr, transport) {
    if (addr == null) {
      throw new Error("requires node address object");
    }
    if (transport == null) {
      throw new Error("requires transport protocol");
    }
    let ip;
    switch (addr.family) {
      case 4:
        ip = "ip4";
        break;
      case 6:
        ip = "ip6";
        break;
      default:
        throw Error("Invalid addr family, should be 4 or 6.");
    }
    return new Multiaddr("/" + [ip, addr.address, transport, addr.port].join("/"));
  }
  static isName(addr) {
    if (!Multiaddr.isMultiaddr(addr)) {
      return false;
    }
    return addr.protos().some((proto) => proto.resolvable);
  }
  static isMultiaddr(value2) {
    return Boolean(value2?.[symbol]);
  }
  [inspect]() {
    return "<Multiaddr " + toString2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
  }
  inspect() {
    return "<Multiaddr " + toString2(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
  }
};
Multiaddr.resolvers = resolvers;

// ../../node_modules/@multiformats/mafmt/dist/src/index.js
init_define_process();
var DNS4 = base3("dns4");
var DNS6 = base3("dns6");
var DNSADDR = base3("dnsaddr");
var DNS = or2(base3("dns"), DNSADDR, DNS4, DNS6);
var IP2 = or2(base3("ip4"), base3("ip6"));
var TCP = or2(and(IP2, base3("tcp")), and(DNS, base3("tcp")));
var UDP = and(IP2, base3("udp"));
var UTP = and(UDP, base3("utp"));
var QUIC = and(UDP, base3("quic"));
var WebSockets = or2(and(TCP, base3("ws")), and(DNS, base3("ws")));
var WebSocketsSecure = or2(and(TCP, base3("wss")), and(DNS, base3("wss")));
var HTTP = or2(and(TCP, base3("http")), and(IP2, base3("http")), and(DNS, base3("http")));
var HTTPS = or2(and(TCP, base3("https")), and(IP2, base3("https")), and(DNS, base3("https")));
var WebRTCStar = or2(and(WebSockets, base3("p2p-webrtc-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-webrtc-star"), base3("p2p")), and(WebSockets, base3("p2p-webrtc-star")), and(WebSocketsSecure, base3("p2p-webrtc-star")));
var WebSocketStar = or2(and(WebSockets, base3("p2p-websocket-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-websocket-star"), base3("p2p")), and(WebSockets, base3("p2p-websocket-star")), and(WebSocketsSecure, base3("p2p-websocket-star")));
var WebRTCDirect = or2(and(HTTP, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTPS, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTP, base3("p2p-webrtc-direct")), and(HTTPS, base3("p2p-webrtc-direct")));
var Reliable = or2(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS);
var Stardust = or2(and(Reliable, base3("p2p-stardust"), base3("p2p")), and(Reliable, base3("p2p-stardust")));
var _P2P = or2(and(Reliable, base3("p2p")), WebRTCStar, WebRTCDirect, base3("p2p"));
var _Circuit = or2(and(_P2P, base3("p2p-circuit"), _P2P), and(_P2P, base3("p2p-circuit")), and(base3("p2p-circuit"), _P2P), and(Reliable, base3("p2p-circuit")), and(base3("p2p-circuit"), Reliable), base3("p2p-circuit"));
var CircuitRecursive = () => or2(and(_Circuit, CircuitRecursive), _Circuit);
var Circuit = CircuitRecursive();
var P2P = or2(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
function makeMatchesFunction(partialMatch) {
  function matches(a) {
    let ma2;
    try {
      ma2 = new Multiaddr(a);
    } catch (err) {
      return false;
    }
    const out = partialMatch(ma2.protoNames());
    if (out === null) {
      return false;
    }
    if (out === true || out === false) {
      return out;
    }
    return out.length === 0;
  }
  return matches;
}
function and(...args) {
  function partialMatch(a) {
    if (a.length < args.length) {
      return null;
    }
    let out = a;
    args.some((arg) => {
      out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (Array.isArray(out)) {
        a = out;
      }
      if (out === null) {
        return true;
      }
      return false;
    });
    return out;
  }
  return {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
}
function or2(...args) {
  function partialMatch(a) {
    let out = null;
    args.some((arg) => {
      const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
      if (res != null) {
        out = res;
        return true;
      }
      return false;
    });
    return out;
  }
  const result = {
    toString: function() {
      return "{ " + args.join(" ") + " }";
    },
    input: args,
    matches: makeMatchesFunction(partialMatch),
    partialMatch
  };
  return result;
}
function base3(n) {
  const name2 = n;
  function matches(a) {
    let ma2;
    try {
      ma2 = new Multiaddr(a);
    } catch (err) {
      return false;
    }
    const pnames = ma2.protoNames();
    if (pnames.length === 1 && pnames[0] === name2) {
      return true;
    }
    return false;
  }
  function partialMatch(protos) {
    if (protos.length === 0) {
      return null;
    }
    if (protos[0] === name2) {
      return protos.slice(1);
    }
    return null;
  }
  return {
    toString: function() {
      return name2;
    },
    matches,
    partialMatch
  };
}

// ../../node_modules/@libp2p/webrtc-star/dist/src/constants.js
init_define_process();
var CODE_P2P = 421;
var CODE_CIRCUIT = 290;
var CLOSE_TIMEOUT = 2e3;

// ../../node_modules/@libp2p/webrtc-star/dist/src/listener.js
init_define_process();
var import_err_code5 = __toESM(require_err_code(), 1);

// ../../node_modules/socket.io-client/build/esm/index.js
init_define_process();

// ../../node_modules/socket.io-client/build/esm/url.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/index.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/socket.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/transports/index.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/transports/polling.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/transport.js
init_define_process();

// ../../node_modules/engine.io-parser/build/esm/index.js
init_define_process();

// ../../node_modules/engine.io-parser/build/esm/encodePacket.browser.js
init_define_process();

// ../../node_modules/engine.io-parser/build/esm/commons.js
init_define_process();
var PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = { type: "error", data: "parser error" };

// ../../node_modules/engine.io-parser/build/esm/encodePacket.browser.js
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function";
var isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
var encodePacket = ({ type, data }, supportsBinary, callback) => {
  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  }
  return callback(PACKET_TYPES[type] + (data || ""));
};
var encodeBlobAsBase64 = (data, callback) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback("b" + content);
  };
  return fileReader.readAsDataURL(data);
};
var encodePacket_browser_default = encodePacket;

// ../../node_modules/engine.io-parser/build/esm/decodePacket.browser.js
init_define_process();

// ../../node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js
init_define_process();
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i2 = 0; i2 < chars.length; i2++) {
  lookup[chars.charCodeAt(i2)] = i2;
}
var decode6 = (base642) => {
  let bufferLength = base642.length * 0.75, len = base642.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len; i2 += 4) {
    encoded1 = lookup[base642.charCodeAt(i2)];
    encoded2 = lookup[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup[base642.charCodeAt(i2 + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};

// ../../node_modules/engine.io-parser/build/esm/decodePacket.browser.js
var withNativeArrayBuffer2 = typeof ArrayBuffer === "function";
var decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
var decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer2) {
    const decoded = decode6(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
var mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;
    case "arraybuffer":
    default:
      return data;
  }
};
var decodePacket_browser_default = decodePacket;

// ../../node_modules/engine.io-parser/build/esm/index.js
var SEPARATOR = String.fromCharCode(30);
var encodePayload = (packets, callback) => {
  const length3 = packets.length;
  const encodedPackets = new Array(length3);
  let count = 0;
  packets.forEach((packet, i2) => {
    encodePacket_browser_default(packet, false, (encodedPacket) => {
      encodedPackets[i2] = encodedPacket;
      if (++count === length3) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
var decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i2 = 0; i2 < encodedPackets.length; i2++) {
    const decodedPacket = decodePacket_browser_default(encodedPackets[i2], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
var protocol = 4;

// ../../node_modules/@socket.io/component-emitter/index.mjs
init_define_process();
function Emitter(obj) {
  if (obj)
    return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn2) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn2);
  return this;
};
Emitter.prototype.once = function(event, fn2) {
  function on3() {
    this.off(event, on3);
    fn2.apply(this, arguments);
  }
  on3.fn = fn2;
  this.on(event, on3);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn2) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks)
    return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb2;
  for (var i2 = 0; i2 < callbacks.length; i2++) {
    cb2 = callbacks[i2];
    if (cb2 === fn2 || cb2.fn === fn2) {
      callbacks.splice(i2, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i2 = 1; i2 < arguments.length; i2++) {
    args[i2 - 1] = arguments[i2];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i2 = 0, len = callbacks.length; i2 < len; ++i2) {
      callbacks[i2].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};

// ../../node_modules/engine.io-client/build/esm/util.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/globalThis.browser.js
init_define_process();
var globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();

// ../../node_modules/engine.io-client/build/esm/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k2) => {
    if (obj.hasOwnProperty(k2)) {
      acc[k2] = obj[k2];
    }
    return acc;
  }, {});
}
var NATIVE_SET_TIMEOUT = setTimeout;
var NATIVE_CLEAR_TIMEOUT = clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = clearTimeout.bind(globalThisShim);
  }
}
var BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c2 = 0, length3 = 0;
  for (let i2 = 0, l = str.length; i2 < l; i2++) {
    c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      length3 += 1;
    } else if (c2 < 2048) {
      length3 += 2;
    } else if (c2 < 55296 || c2 >= 57344) {
      length3 += 3;
    } else {
      i2++;
      length3 += 4;
    }
  }
  return length3;
}

// ../../node_modules/engine.io-client/build/esm/transport.js
var TransportError = class extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
};
var Transport = class extends Emitter {
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.readyState = "";
    this.socket = opts.socket;
  }
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  open() {
    if ("closed" === this.readyState || "" === this.readyState) {
      this.readyState = "opening";
      this.doOpen();
    }
    return this;
  }
  close() {
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  send(packets) {
    if ("open" === this.readyState) {
      this.write(packets);
    } else {
    }
  }
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  onData(data) {
    const packet = decodePacket_browser_default(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
};

// ../../node_modules/engine.io-client/build/esm/contrib/yeast.js
init_define_process();
var alphabet2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
var length2 = 64;
var map = {};
var seed = 0;
var i = 0;
var prev;
function encode5(num) {
  let encoded = "";
  do {
    encoded = alphabet2[num % length2] + encoded;
    num = Math.floor(num / length2);
  } while (num > 0);
  return encoded;
}
function yeast() {
  const now = encode5(+new Date());
  if (now !== prev)
    return seed = 0, prev = now;
  return now + "." + encode5(seed++);
}
for (; i < length2; i++)
  map[alphabet2[i]] = i;

// ../../node_modules/engine.io-client/build/esm/contrib/parseqs.js
init_define_process();
function encode6(obj) {
  let str = "";
  for (let i2 in obj) {
    if (obj.hasOwnProperty(i2)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i2) + "=" + encodeURIComponent(obj[i2]);
    }
  }
  return str;
}
function decode7(qs2) {
  let qry = {};
  let pairs = qs2.split("&");
  for (let i2 = 0, l = pairs.length; i2 < l; i2++) {
    let pair = pairs[i2].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}

// ../../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/contrib/has-cors.js
init_define_process();
var value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
var hasCORS = value;

// ../../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js
function XHR(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}

// ../../node_modules/engine.io-client/build/esm/transports/polling.js
function empty2() {
}
var hasXHR2 = function() {
  const xhr = new XHR({
    xdomain: false
  });
  return null != xhr.responseType;
}();
var Polling = class extends Transport {
  constructor(opts) {
    super(opts);
    this.polling = false;
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
      this.xs = opts.secure !== isSSL;
    }
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this.polling || !this.writable) {
      let total = 0;
      if (this.polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  poll() {
    this.polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  onData(data) {
    const callback = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback);
    if ("closed" !== this.readyState) {
      this.polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this.poll();
      } else {
      }
    }
  }
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "https" : "http";
    let port = "";
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    if (this.opts.port && ("https" === schema && Number(this.opts.port) !== 443 || "http" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    const encodedQuery = encode6(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
    return new Request(this.uri(), opts);
  }
  doWrite(data, fn2) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn2);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
};
var Request = class extends Emitter {
  constructor(uri, opts) {
    super();
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.method = opts.method || "GET";
    this.uri = uri;
    this.async = false !== opts.async;
    this.data = void 0 !== opts.data ? opts.data : null;
    this.create();
  }
  create() {
    const opts = pick(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this.opts.xd;
    opts.xscheme = !!this.opts.xs;
    const xhr = this.xhr = new XHR(opts);
    try {
      xhr.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i2 in this.opts.extraHeaders) {
            if (this.opts.extraHeaders.hasOwnProperty(i2)) {
              xhr.setRequestHeader(i2, this.opts.extraHeaders[i2]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this.method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this.opts.withCredentials;
      }
      if (this.opts.requestTimeout) {
        xhr.timeout = this.opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this.onLoad();
        } else {
          this.setTimeoutFn(() => {
            this.onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this.data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this.onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this.index = Request.requestsCount++;
      Request.requests[this.index] = this;
    }
  }
  onError(err) {
    this.emitReserved("error", err, this.xhr);
    this.cleanup(true);
  }
  cleanup(fromError) {
    if ("undefined" === typeof this.xhr || null === this.xhr) {
      return;
    }
    this.xhr.onreadystatechange = empty2;
    if (fromError) {
      try {
        this.xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this.index];
    }
    this.xhr = null;
  }
  onLoad() {
    const data = this.xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this.cleanup();
    }
  }
  abort() {
    this.cleanup();
  }
};
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i2 in Request.requests) {
    if (Request.requests.hasOwnProperty(i2)) {
      Request.requests[i2].abort();
    }
  }
}

// ../../node_modules/engine.io-client/build/esm/transports/websocket.js
init_define_process();

// ../../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js
init_define_process();
var nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb2) => Promise.resolve().then(cb2);
  } else {
    return (cb2, setTimeoutFn) => setTimeoutFn(cb2, 0);
  }
})();
var WebSocket2 = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
var usingBrowserWebSocket = true;
var defaultBinaryType = "arraybuffer";

// ../../node_modules/engine.io-client/build/esm/transports/websocket.js
var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
var WS2 = class extends Transport {
  constructor(opts) {
    super(opts);
    this.supportsBinary = !opts.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check()) {
      return;
    }
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
    this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev2) => this.onData(ev2.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i2 = 0; i2 < packets.length; i2++) {
      const packet = packets[i2];
      const lastPacket = i2 === packets.length - 1;
      encodePacket_browser_default(packet, this.supportsBinary, (data) => {
        const opts = {};
        if (!usingBrowserWebSocket) {
          if (packet.options) {
            opts.compress = packet.options.compress;
          }
          if (this.opts.perMessageDeflate) {
            const len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
            if (len < this.opts.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }
        try {
          if (usingBrowserWebSocket) {
            this.ws.send(data);
          } else {
            this.ws.send(data, opts);
          }
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.close();
      this.ws = null;
    }
  }
  uri() {
    let query = this.query || {};
    const schema = this.opts.secure ? "wss" : "ws";
    let port = "";
    if (this.opts.port && ("wss" === schema && Number(this.opts.port) !== 443 || "ws" === schema && Number(this.opts.port) !== 80)) {
      port = ":" + this.opts.port;
    }
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = yeast();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    const encodedQuery = encode6(query);
    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
    return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
  }
  check() {
    return !!WebSocket2;
  }
};

// ../../node_modules/engine.io-client/build/esm/transports/index.js
var transports = {
  websocket: WS2,
  polling: Polling
};

// ../../node_modules/engine.io-client/build/esm/contrib/parseuri.js
init_define_process();
var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
var parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse(str) {
  const src2 = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i2 = 14;
  while (i2--) {
    uri[parts[i2]] = m[i2] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src2;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names2 = path.replace(regx, "/").split("/");
  if (path.substr(0, 1) == "/" || path.length === 0) {
    names2.splice(0, 1);
  }
  if (path.substr(path.length - 1, 1) == "/") {
    names2.splice(names2.length - 1, 1);
  }
  return names2;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($02, $1, $22) {
    if ($1) {
      data[$1] = $22;
    }
  });
  return data;
}

// ../../node_modules/engine.io-client/build/esm/socket.js
var Socket = class extends Emitter {
  constructor(uri, opts = {}) {
    super();
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      uri = parse(uri);
      opts.hostname = uri.host;
      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
      opts.port = uri.port;
      if (uri.query)
        opts.query = uri.query;
    } else if (opts.host) {
      opts.hostname = parse(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = opts.transports || ["polling", "websocket"];
    this.readyState = "";
    this.writeBuffer = [];
    this.prevBufferLen = 0;
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: true
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
    if (typeof this.opts.query === "string") {
      this.opts.query = decode7(this.opts.query);
    }
    this.id = null;
    this.upgrades = null;
    this.pingInterval = null;
    this.pingTimeout = null;
    this.pingTimeoutTimer = null;
    if (typeof addEventListener === "function") {
      if (this.opts.closeOnBeforeunload) {
        addEventListener("beforeunload", () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        }, false);
      }
      if (this.hostname !== "localhost") {
        this.offlineEventListener = () => {
          this.onClose("transport close", {
            description: "network connection lost"
          });
        };
        addEventListener("offline", this.offlineEventListener, false);
      }
    }
    this.open();
  }
  createTransport(name2) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol;
    query.transport = name2;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts.transportOptions[name2], this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new transports[name2](opts);
  }
  open() {
    let transport;
    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
      transport = "websocket";
    } else if (0 === this.transports.length) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else {
      transport = this.transports[0];
    }
    this.readyState = "opening";
    try {
      transport = this.createTransport(transport);
    } catch (e) {
      this.transports.shift();
      this.open();
      return;
    }
    transport.open();
    this.setTransport(transport);
  }
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (reason) => this.onClose("transport close", reason));
  }
  probe(name2) {
    let transport = this.createTransport(name2);
    let failed = false;
    Socket.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          Socket.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to2) {
      if (transport && to2.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    transport.open();
  }
  onOpen() {
    this.readyState = "open";
    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
    if ("open" === this.readyState && this.opts.upgrade && this.transport.pause) {
      let i2 = 0;
      const l = this.upgrades.length;
      for (; i2 < l; i2++) {
        this.probe(this.upgrades[i2]);
      }
    }
  }
  onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this.resetPingTimeout();
          this.sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this.onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this.upgrades = this.filterUpgrades(data.upgrades);
    this.pingInterval = data.pingInterval;
    this.pingTimeout = data.pingTimeout;
    this.maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer);
    this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout);
    if (this.opts.autoUnref) {
      this.pingTimeoutTimer.unref();
    }
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen);
    this.prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this.getWritablePackets();
      this.transport.send(packets);
      this.prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    const shouldCheckPayloadSize = this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i2 = 0; i2 < this.writeBuffer.length; i2++) {
      const data = this.writeBuffer[i2].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i2 > 0 && payloadSize > this.maxPayload) {
        return this.writeBuffer.slice(0, i2);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  write(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  send(msg, options, fn2) {
    this.sendPacket("message", msg, options, fn2);
    return this;
  }
  sendPacket(type, data, options, fn2) {
    if ("function" === typeof data) {
      fn2 = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn2 = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn2)
      this.once("flush", fn2);
    this.flush();
  }
  close() {
    const close = () => {
      this.onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  onError(err) {
    Socket.priorWebsocketSuccess = false;
    this.emitReserved("error", err);
    this.onClose("transport error", err);
  }
  onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this.pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (typeof removeEventListener === "function") {
        removeEventListener("offline", this.offlineEventListener, false);
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this.prevBufferLen = 0;
    }
  }
  filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    let i2 = 0;
    const j8 = upgrades.length;
    for (; i2 < j8; i2++) {
      if (~this.transports.indexOf(upgrades[i2]))
        filteredUpgrades.push(upgrades[i2]);
    }
    return filteredUpgrades;
  }
};
Socket.protocol = protocol;

// ../../node_modules/engine.io-client/build/esm/index.js
var protocol2 = Socket.protocol;

// ../../node_modules/socket.io-client/build/esm/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}

// ../../node_modules/socket.io-client/build/esm/manager.js
init_define_process();

// ../../node_modules/socket.io-client/build/esm/socket.js
init_define_process();

// ../../node_modules/socket.io-parser/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Decoder: () => Decoder2,
  Encoder: () => Encoder2,
  PacketType: () => PacketType,
  protocol: () => protocol3
});
init_define_process();

// ../../node_modules/socket.io-parser/build/esm/binary.js
init_define_process();

// ../../node_modules/socket.io-parser/build/esm/is-binary.js
init_define_process();
var withNativeArrayBuffer3 = typeof ArrayBuffer === "function";
var isView2 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
var toString4 = Object.prototype.toString;
var withNativeBlob2 = typeof Blob === "function" || typeof Blob !== "undefined" && toString4.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString4.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer3 && (obj instanceof ArrayBuffer || isView2(obj)) || withNativeBlob2 && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i2 = 0, l = obj.length; i2 < l; i2++) {
      if (hasBinary(obj[i2])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}

// ../../node_modules/socket.io-parser/build/esm/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i2 = 0; i2 < data.length; i2++) {
      newData[i2] = _deconstructPacket(data[i2], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = void 0;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i2 = 0; i2 < data.length; i2++) {
      data[i2] = _reconstructPacket(data[i2], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}

// ../../node_modules/socket.io-parser/build/esm/index.js
var protocol3 = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
var Encoder2 = class {
  constructor(replacer) {
    this.replacer = replacer;
  }
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
        return this.encodeAsBinary(obj);
      }
    }
    return [this.encodeAsString(obj)];
  }
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
};
var Decoder2 = class extends Emitter {
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  decodeString(str) {
    let i2 = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start = i2 + 1;
      while (str.charAt(++i2) !== "-" && i2 != str.length) {
      }
      const buf = str.substring(start, i2);
      if (buf != Number(buf) || str.charAt(i2) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i2 + 1)) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if ("," === c2)
          break;
        if (i2 === str.length)
          break;
      }
      p.nsp = str.substring(start, i2);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i2 + 1);
    if ("" !== next && Number(next) == next) {
      const start = i2 + 1;
      while (++i2) {
        const c2 = str.charAt(i2);
        if (null == c2 || Number(c2) != c2) {
          --i2;
          break;
        }
        if (i2 === str.length)
          break;
      }
      p.id = Number(str.substring(start, i2 + 1));
    }
    if (str.charAt(++i2)) {
      const payload = this.tryParse(str.substr(i2));
      if (Decoder2.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return typeof payload === "object";
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || typeof payload === "object";
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && payload.length > 0;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  }
};
var BinaryReconstructor = class {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
};

// ../../node_modules/socket.io-client/build/esm/on.js
init_define_process();
function on2(obj, ev2, fn2) {
  obj.on(ev2, fn2);
  return function subDestroy() {
    obj.off(ev2, fn2);
  };
}

// ../../node_modules/socket.io-client/build/esm/socket.js
var RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
var Socket2 = class extends Emitter {
  constructor(io2, nsp, opts) {
    super();
    this.connected = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io2;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    if (this.io._autoConnect)
      this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const io2 = this.io;
    this.subs = [
      on2(io2, "open", this.onopen.bind(this)),
      on2(io2, "packet", this.onpacket.bind(this)),
      on2(io2, "error", this.onerror.bind(this)),
      on2(io2, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  open() {
    return this.connect();
  }
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  emit(ev2, ...args) {
    if (RESERVED_EVENTS.hasOwnProperty(ev2)) {
      throw new Error('"' + ev2 + '" is a reserved event name');
    }
    args.unshift(ev2);
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
    if (discardPacket) {
    } else if (this.connected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  _registerAckCallback(id, ack) {
    const timeout = this.flags.timeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i2 = 0; i2 < this.sendBuffer.length; i2++) {
        if (this.sendBuffer[i2].id === id) {
          this.sendBuffer.splice(i2, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    this.acks[id] = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, [null, ...args]);
    };
  }
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this.packet({ type: PacketType.CONNECT, data });
      });
    } else {
      this.packet({ type: PacketType.CONNECT, data: this.auth });
    }
  }
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
  }
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          const id = packet.data.sid;
          this.onconnect(id);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
  }
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  onack(packet) {
    const ack = this.acks[packet.id];
    if ("function" === typeof ack) {
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
    }
  }
  onconnect(id) {
    this.id = id;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  close() {
    return this.disconnect();
  }
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i2 = 0; i2 < listeners.length; i2++) {
        if (listener === listeners[i2]) {
          listeners.splice(i2, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
};

// ../../node_modules/socket.io-client/build/esm/contrib/backo2.js
init_define_process();
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max) {
  this.max = max;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};

// ../../node_modules/socket.io-client/build/esm/manager.js
var Manager = class extends Emitter {
  constructor(uri, opts) {
    var _a2;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || esm_exports;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a2;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a2;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  open(fn2) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on2(socket, "open", function() {
      self2.onopen();
      fn2 && fn2();
    });
    const errorSub = on2(socket, "error", (err) => {
      self2.cleanup();
      self2._readyState = "closed";
      this.emitReserved("error", err);
      if (fn2) {
        fn2(err);
      } else {
        self2.maybeReconnectOnOpen();
      }
    });
    if (false !== this._timeout) {
      const timeout = this._timeout;
      if (timeout === 0) {
        openSubDestroy();
      }
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        socket.close();
        socket.emit("error", new Error("timeout"));
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  connect(fn2) {
    return this.open(fn2);
  }
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(on2(socket, "ping", this.onping.bind(this)), on2(socket, "data", this.ondata.bind(this)), on2(socket, "error", this.onerror.bind(this)), on2(socket, "close", this.onclose.bind(this)), on2(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(data) {
    this.decoder.add(data);
  }
  ondecoded(packet) {
    this.emitReserved("packet", packet);
  }
  onerror(err) {
    this.emitReserved("error", err);
  }
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    }
    return socket;
  }
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i2 = 0; i2 < encodedPackets.length; i2++) {
      this.engine.write(encodedPackets[i2], packet.options);
    }
  }
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
    if (this.engine)
      this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(reason, description) {
    this.cleanup();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay3 = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay3);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(function subDestroy() {
        clearTimeout(timer);
      });
    }
  }
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
};

// ../../node_modules/socket.io-client/build/esm/index.js
var cache = {};
function lookup2(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io2;
  if (newConnection) {
    io2 = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io2 = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io2.socket(parsed.path, opts);
}
Object.assign(lookup2, {
  Manager,
  Socket: Socket2,
  io: lookup2,
  connect: lookup2
});

// ../../node_modules/p-defer/index.js
init_define_process();
function pDefer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// ../../node_modules/@libp2p/webrtc-peer/dist/src/index.js
init_define_process();

// ../../node_modules/@libp2p/webrtc-peer/dist/src/receiver.js
init_define_process();

// ../../node_modules/@libp2p/webrtc-peer/dist/src/peer.js
init_define_process();

// ../../node_modules/@libp2p/interfaces/dist/src/events.js
init_define_process();
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EventEmitter_listeners;
var EventEmitter = class extends EventTarget {
  constructor() {
    super(...arguments);
    _EventEmitter_listeners.set(this, /* @__PURE__ */ new Map());
  }
  listenerCount(type) {
    const listeners = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (listeners == null) {
      return 0;
    }
    return listeners.length;
  }
  addEventListener(type, listener, options) {
    super.addEventListener(type, listener, options);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      list = [];
      __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
    }
    list.push({
      callback: listener,
      once: (options !== true && options !== false && options?.once) ?? false
    });
  }
  removeEventListener(type, listener, options) {
    super.removeEventListener(type.toString(), listener ?? null, options);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(type);
    if (list == null) {
      return;
    }
    list = list.filter(({ callback }) => callback !== listener);
    __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(type, list);
  }
  dispatchEvent(event) {
    const result = super.dispatchEvent(event);
    let list = __classPrivateFieldGet(this, _EventEmitter_listeners, "f").get(event.type);
    if (list == null) {
      return result;
    }
    list = list.filter(({ once }) => !once);
    __classPrivateFieldGet(this, _EventEmitter_listeners, "f").set(event.type, list);
    return result;
  }
};
_EventEmitter_listeners = /* @__PURE__ */ new WeakMap();
var CustomEventPolyfill = class extends Event {
  constructor(message, data) {
    super(message, data);
    this.detail = data?.detail;
  }
};
var CustomEvent = globalThis.CustomEvent ?? CustomEventPolyfill;

// ../../node_modules/@libp2p/webrtc-peer/dist/src/peer.js
var import_err_code3 = __toESM(require_err_code(), 1);
var import_random = __toESM(require_random_browser(), 1);

// ../../node_modules/it-pushable/dist/src/index.js
init_define_process();

// ../../node_modules/it-pushable/dist/src/fifo.js
init_define_process();
var FixedFIFO = class {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
var FIFO = class {
  constructor(hwm) {
    this.hwm = hwm ?? 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
  }
  push(val) {
    if (!this.head.push(val)) {
      const prev2 = this.head;
      this.head = prev2.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    const val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      return this.tail.shift();
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};

// ../../node_modules/it-pushable/dist/src/index.js
function pushable(options) {
  const getNext = (buffer) => {
    const next = buffer.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options ?? {};
  let onEnd = options.onEnd;
  let buffer = new FIFO();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer.isEmpty()) {
      return getNext(buffer);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer.push(next);
        try {
          resolve(getNext(buffer));
        } catch (err) {
          reject(err);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer = new FIFO();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer.push({ error: err });
    return pushable2;
  };
  const push = (value2) => {
    if (ended) {
      return pushable2;
    }
    return bufferNext({ done: false, value: value2 });
  };
  const end = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer = new FIFO();
    end();
    return { done: true };
  };
  const _throw = (err) => {
    end(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push,
    end
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    }
  };
  return pushable2;
}

// ../../node_modules/@libp2p/webrtc-peer/dist/src/channel.js
init_define_process();
var import_err_code2 = __toESM(require_err_code(), 1);
var MAX_BUFFERED_AMOUNT = 64 * 1024;
var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
var WebRTCDataChannel = class {
  constructor(channel, opts) {
    this.label = channel.label;
    this.open = pDefer();
    this.channel = channel;
    this.channel.binaryType = "arraybuffer";
    this.log = opts.log;
    if (typeof this.channel.bufferedAmountLowThreshold === "number") {
      this.channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    channel.addEventListener("message", (event) => {
      opts.onMessage(event);
    });
    channel.addEventListener("bufferedamountlow", () => {
      this.log("stop backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open.resolve();
    });
    channel.addEventListener("open", () => {
      this.open.resolve();
      opts.onOpen();
    });
    channel.addEventListener("close", () => {
      opts.onClose();
    });
    channel.addEventListener("error", (event) => {
      if (event.error?.message === "Transport channel closed") {
        return this.close();
      }
      opts.log.error('channel encounter an error in state "%s" message: "%s" detail: "%s', channel.readyState, event.error?.message, event.error?.errorDetail);
      const err = event.error instanceof Error ? event.error : new Error(`datachannel error: ${event.error?.message} ${event.error?.errorDetail}`);
      opts.onError((0, import_err_code2.default)(err, "ERR_DATA_CHANNEL"));
    });
    let isClosing = false;
    this.closingInterval = setInterval(() => {
      if (channel.readyState === "closing") {
        if (isClosing) {
          opts.onClose();
        }
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  async send(data) {
    await this.open.promise;
    this.channel.send(data);
    if (this.channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      this.log("start backpressure: bufferedAmount %d", this.channel.bufferedAmount);
      this.open = pDefer();
    }
  }
  close() {
    clearInterval(this.closingInterval);
    this.channel.close();
  }
  get bufferedAmount() {
    return this.channel.bufferedAmount;
  }
};

// ../../node_modules/@libp2p/webrtc-peer/dist/src/peer.js
var import_delay = __toESM(require_delay(), 1);
var DEFAULT_PEER_CONNECTION_CONFIG = {
  iceServers: [{
    urls: [
      "stun:stun.l.google.com:19302",
      "stun:global.stun.twilio.com:3478"
    ]
  }]
};
function getBrowserRTC() {
  if (typeof globalThis === "undefined") {
    throw (0, import_err_code3.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  const wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection ?? globalThis.mozRTCPeerConnection ?? globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription ?? globalThis.mozRTCSessionDescription ?? globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate ?? globalThis.mozRTCIceCandidate ?? globalThis.webkitRTCIceCandidate
  };
  if (wrtc.RTCPeerConnection == null) {
    throw (0, import_err_code3.default)(new Error("No WebRTC support detected"), "ERR_WEBRTC_SUPPORT");
  }
  return wrtc;
}
var WebRTCPeer = class extends EventEmitter {
  constructor(opts) {
    super();
    this.id = opts.id ?? toString2((0, import_random.default)(4), "hex").slice(0, 7);
    this.log = logger(`libp2p:webrtc-peer:${opts.logPrefix}:${this.id}`);
    this.wrtc = opts.wrtc ?? getBrowserRTC();
    this.peerConnection = new this.wrtc.RTCPeerConnection(Object.assign({}, DEFAULT_PEER_CONNECTION_CONFIG, opts.peerConnectionConfig));
    this.closed = false;
    this.connected = pDefer();
    this.source = pushable();
    this.sink = async (source) => {
      await this.connected.promise;
      if (this.channel == null) {
        throw (0, import_err_code3.default)(new Error("Connected but no channel?!"), "ERR_DATA_CHANNEL");
      }
      for await (const buf of source) {
        await this.channel.send(buf);
      }
      await this.close();
    };
  }
  handleDataChannelEvent(event) {
    const dataChannel = event.channel;
    if (dataChannel == null) {
      this.close((0, import_err_code3.default)(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")).catch((err) => {
        this.log("Error closing after event channel was found to be null", err);
      });
      return;
    }
    this.channel = new WebRTCDataChannel(dataChannel, {
      log: this.log,
      onMessage: (event2) => {
        this.source.push(new Uint8Array(event2.data));
      },
      onOpen: () => {
        this.connected.resolve();
        this.dispatchEvent(new CustomEvent("ready"));
      },
      onClose: () => {
        this.close().catch((err) => {
          this.log("error closing connection after channel close", err);
        });
      },
      onError: (err) => {
        this.close(err).catch((err2) => {
          this.log("error closing connection after channel error", err2);
        });
      }
    });
  }
  async close(err) {
    this.closed = true;
    if (err == null && this.channel != null) {
      while (this.channel.bufferedAmount > 0) {
        await (0, import_delay.default)(100);
      }
    }
    this.channel?.close();
    this.peerConnection.close();
    this.source.end(err);
    this.dispatchEvent(new CustomEvent("close"));
  }
};

// ../../node_modules/@libp2p/webrtc-peer/dist/src/handshake.js
init_define_process();
var import_err_code4 = __toESM(require_err_code(), 1);
var WebRTCHandshake = class extends EventEmitter {
  constructor(options) {
    super();
    this.log = options.log;
    this.peerConnection = options.peerConnection;
    this.wrtc = options.wrtc;
    this.status = "idle";
    this.peerConnection.addEventListener("negotiationneeded", () => {
      this.log("peer connection negotiation needed");
      this.handleRenegotiate({ type: "renegotiate" }).catch((err) => {
        this.log.error("could not renegotiate %o", err);
      });
    });
  }
  async handleSignal(signal) {
    this.log('incoming signal "%s"', signal.type);
    if (signal.type === "offer") {
      return await this.handleOffer(signal);
    } else if (signal.type === "answer") {
      return await this.handleAnswer(signal);
    } else if (signal.type === "candidate") {
      return await this.handleCandidate(signal);
    } else if (signal.type === "renegotiate") {
      return await this.handleRenegotiate(signal);
    } else if (signal.type === "goodbye") {
      return await this.handleGoodye(signal);
    } else {
      this.log(`Unknown signal type ${signal.type}`);
    }
  }
  async handleOffer(signal) {
  }
  async handleAnswer(signal) {
  }
  async handleRenegotiate(signal) {
  }
  async handleGoodye(signal) {
    this.peerConnection.close();
  }
  async handleCandidate(signal) {
    const iceCandidate = new this.wrtc.RTCIceCandidate(signal.candidate);
    try {
      await this.peerConnection.addIceCandidate(iceCandidate);
    } catch (err) {
      if (iceCandidate.address == null || iceCandidate.address.endsWith(".local")) {
        this.log("ignoring unsupported ICE candidate.");
      } else {
        throw (0, import_err_code4.default)(err, "ERR_ADD_ICE_CANDIDATE");
      }
    }
  }
};

// ../../node_modules/@libp2p/webrtc-peer/dist/src/receiver.js
var log = logger("libp2p:webrtc-peer:receiver");
var WebRTCReceiver = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "receiver"
    });
    this.handshake = new WebRTCReceiverHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      answerOptions: opts.answerOptions
    });
    this.handshake.addEventListener("signal", (event) => this.dispatchEvent(new CustomEvent("signal", {
      detail: event.detail
    })));
    this.peerConnection.addEventListener("datachannel", (event) => {
      this.handleDataChannelEvent(event);
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err) => {
      this.log("error handling signal %o %o", signal, err);
    });
  }
};
var WebRTCReceiverHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.iceCandidates = [];
  }
  async handleRenegotiate() {
    log.trace("renegotiate");
    this.dispatchEvent(new CustomEvent("signal", {
      detail: {
        type: "renegotiate"
      }
    }));
  }
  async handleOffer(signal) {
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    for (const candidate of this.iceCandidates) {
      await this.handleCandidate(candidate);
    }
    this.iceCandidates = [];
    const answer = await this.peerConnection.createAnswer(this.options.answerOptions);
    await this.peerConnection.setLocalDescription(answer);
    log.trace("handle offer", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? answer
    }));
  }
  async handleCandidate(signal) {
    if (this.peerConnection.remoteDescription == null || this.peerConnection.remoteDescription.type == null) {
      this.iceCandidates.push(signal);
      return;
    }
    await super.handleCandidate(signal);
  }
};

// ../../node_modules/@libp2p/webrtc-peer/dist/src/initiator.js
init_define_process();
var import_random2 = __toESM(require_random_browser(), 1);

// ../../node_modules/p-event/index.js
init_define_process();

// ../../node_modules/p-timeout/index.js
init_define_process();
var TimeoutError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
};
var AbortError4 = class extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
};
var getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError4(errorMessage) : new DOMException(errorMessage);
var getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}

// ../../node_modules/p-event/index.js
var normalizeEmitter = (emitter) => {
  const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
  const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
  if (!addListener || !removeListener) {
    throw new TypeError("Emitter is not compatible");
  }
  return {
    addListener: addListener.bind(emitter),
    removeListener: removeListener.bind(emitter)
  };
};
function pEventMultiple(emitter, event, options) {
  let cancel;
  const returnValue = new Promise((resolve, reject) => {
    options = {
      rejectionEvents: ["error"],
      multiArgs: false,
      resolveImmediately: false,
      ...options
    };
    if (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {
      throw new TypeError("The `count` option should be at least 0 or more");
    }
    const events = [event].flat();
    const items = [];
    const { addListener, removeListener } = normalizeEmitter(emitter);
    const onItem = (...arguments_) => {
      const value2 = options.multiArgs ? arguments_ : arguments_[0];
      if (options.filter && !options.filter(value2)) {
        return;
      }
      items.push(value2);
      if (options.count === items.length) {
        cancel();
        resolve(items);
      }
    };
    const rejectHandler = (error) => {
      cancel();
      reject(error);
    };
    cancel = () => {
      for (const event2 of events) {
        removeListener(event2, onItem);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        removeListener(rejectionEvent, rejectHandler);
      }
    };
    for (const event2 of events) {
      addListener(event2, onItem);
    }
    for (const rejectionEvent of options.rejectionEvents) {
      addListener(rejectionEvent, rejectHandler);
    }
    if (options.resolveImmediately) {
      resolve(items);
    }
  });
  returnValue.cancel = cancel;
  if (typeof options.timeout === "number") {
    const timeout = pTimeout(returnValue, options.timeout);
    timeout.cancel = cancel;
    return timeout;
  }
  return returnValue;
}
function pEvent(emitter, event, options) {
  if (typeof options === "function") {
    options = { filter: options };
  }
  options = {
    ...options,
    count: 1,
    resolveImmediately: false
  };
  const arrayPromise = pEventMultiple(emitter, event, options);
  const promise = arrayPromise.then((array) => array[0]);
  promise.cancel = arrayPromise.cancel;
  return promise;
}

// ../../node_modules/@libp2p/webrtc-peer/dist/src/initiator.js
var import_delay2 = __toESM(require_delay(), 1);
var log2 = logger("libp2p:webrtc-peer:initator");
var ICECOMPLETE_TIMEOUT = 1e3;
var WebRTCInitiator = class extends WebRTCPeer {
  constructor(opts = {}) {
    super({
      ...opts,
      logPrefix: "initiator"
    });
    this.handleDataChannelEvent({
      channel: this.peerConnection.createDataChannel(opts.dataChannelLabel ?? toString2((0, import_random2.default)(20), "hex").slice(0, 7), opts.dataChannelInit)
    });
    this.handshake = new WebRTCInitiatorHandshake({
      log: this.log,
      peerConnection: this.peerConnection,
      wrtc: this.wrtc,
      offerOptions: opts.offerOptions
    });
    this.handshake.addEventListener("signal", (event) => {
      this.dispatchEvent(new CustomEvent("signal", { detail: event.detail }));
    });
  }
  handleSignal(signal) {
    this.handshake.handleSignal(signal).catch((err) => {
      this.log("error handling signal %o %o", signal, err);
    });
  }
};
var WebRTCInitiatorHandshake = class extends WebRTCHandshake {
  constructor(options) {
    super(options);
    this.options = options;
    this.status = "idle";
    this.peerConnection.addEventListener("icecandidate", (event) => {
      if (event.candidate == null) {
        return;
      }
      const signal = {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      };
      log2.trace("create candidate", signal);
      this.dispatchEvent(new CustomEvent("signal", {
        detail: signal
      }));
      this.dispatchEvent(new CustomEvent("ice-candidate"));
    });
  }
  async handleRenegotiate() {
    if (this.status === "negotiating") {
      this.log("already negotiating, queueing");
      return;
    }
    this.status = "negotiating";
    const offer = await this.peerConnection.createOffer(this.options.offerOptions);
    await this.peerConnection.setLocalDescription(offer);
    await pEvent(this, "ice-candidate");
    await (0, import_delay2.default)(ICECOMPLETE_TIMEOUT);
    log2.trace("renegotiate", this.peerConnection.localDescription);
    this.dispatchEvent(new CustomEvent("signal", {
      detail: this.peerConnection.localDescription ?? offer
    }));
  }
  async handleAnswer(signal) {
    log2.trace("handle answer", signal);
    await this.peerConnection.setRemoteDescription(new this.wrtc.RTCSessionDescription(signal));
    this.status = "idle";
  }
};

// ../../node_modules/@libp2p/webrtc-star/dist/src/socket-to-conn.js
init_define_process();
var log3 = logger("libp2p:webrtc-star:socket");
function toMultiaddrConnection(socket, options) {
  const { sink, source } = socket;
  const maConn = {
    remoteAddr: options.remoteAddr,
    async sink(source2) {
      if (options.signal != null) {
        source2 = abortableSource(source2, options.signal);
      }
      try {
        await sink(source2);
      } catch (err) {
        if (err.type !== "aborted") {
          log3.error(err);
        }
      }
    },
    source: options.signal != null ? abortableSource(source, options.signal) : source,
    timeline: { open: Date.now() },
    async close() {
      if (socket.closed) {
        return;
      }
      const start = Date.now();
      const timeout = setTimeout(() => {
        if (maConn.remoteAddr != null) {
          const { host, port } = maConn.remoteAddr.toOptions();
          log3("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
        }
        if (!socket.closed) {
          socket.close().catch((err) => {
            log3.error("could not close socket", err);
          });
        }
      }, CLOSE_TIMEOUT);
      try {
        await socket.close();
      } finally {
        clearTimeout(timeout);
      }
    }
  };
  socket.addEventListener("close", () => {
    if (maConn.timeline.close == null) {
      maConn.timeline.close = Date.now();
    }
  }, {
    once: true
  });
  return maConn;
}

// ../../node_modules/@libp2p/webrtc-star/dist/src/utils.js
init_define_process();
function cleanUrlSIO(ma2) {
  const maStrSplit = ma2.toString().split("/");
  const tcpProto = ma2.protos()[1].name;
  const wsProto = ma2.protos()[2].name;
  const tcpPort = ma2.stringTuples()[1][1];
  if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
    throw new Error(`invalid multiaddr: ${ma2.toString()}`);
  }
  if (!Multiaddr.isName(ma2)) {
    return `http://${maStrSplit[2]}:${maStrSplit[4]}`;
  }
  if (wsProto === "ws") {
    return `http://${maStrSplit[2]}${tcpPort == null || tcpPort === "80" ? "" : `:${tcpPort}`}`;
  }
  if (wsProto === "wss") {
    return `https://${maStrSplit[2]}${tcpPort == null || tcpPort === "443" ? "" : `:${tcpPort}`}`;
  }
  throw new Error("invalid multiaddr: " + ma2.toString());
}
function cleanMultiaddr(maStr) {
  const legacy = "/libp2p-webrtc-star";
  if (maStr.startsWith(legacy)) {
    maStr = maStr.substring(legacy.length, maStr.length);
    let ma2 = new Multiaddr(maStr);
    const tuppleIPFS = ma2.stringTuples().filter((tupple) => {
      return tupple[0] === 421;
    })[0];
    if (tuppleIPFS[1] == null) {
      throw new Error("invalid multiaddr: " + maStr);
    }
    ma2 = ma2.decapsulate("p2p");
    ma2 = ma2.encapsulate("/p2p-webrtc-star");
    ma2 = ma2.encapsulate(`/p2p/${tuppleIPFS[1]}`);
    maStr = ma2.toString();
  }
  return maStr;
}

// ../../node_modules/@libp2p/webrtc-star/dist/src/listener.js
var log4 = logger("libp2p:webrtc-star:listener");
var sioOptions = {
  transports: ["websocket"],
  "force new connection": true,
  path: "/socket.io-next/"
};
var SigServer = class extends EventEmitter {
  constructor(signallingUrl, signallingAddr, upgrader, handler, channelOptions) {
    super();
    this.signallingAddr = signallingAddr;
    this.socket = lookup2(signallingUrl, sioOptions);
    this.connections = [];
    this.channels = /* @__PURE__ */ new Map();
    this.pendingSignals = /* @__PURE__ */ new Map();
    this.upgrader = upgrader;
    this.handler = handler;
    this.channelOptions = channelOptions;
    this.handleWsHandshake = this.handleWsHandshake.bind(this);
    this.socket.once("connect_error", (err) => {
      this.dispatchEvent(new CustomEvent("error", {
        detail: err
      }));
    });
    this.socket.once("error", (err) => {
      this.dispatchEvent(new CustomEvent("error", {
        detail: err
      }));
    });
    this.socket.on("ws-handshake", this.handleWsHandshake);
    this.socket.on("ws-peer", (maStr) => {
      this.dispatchEvent(new CustomEvent("peer", {
        detail: maStr
      }));
    });
    this.socket.on("connect", () => this.socket.emit("ss-join", signallingAddr.toString()));
    this.socket.once("connect", () => {
      this.dispatchEvent(new CustomEvent("listening"));
    });
  }
  _createChannel(intentId, srcMultiaddr, dstMultiaddr) {
    const channelOptions = {
      ...this.channelOptions
    };
    const channel = new WebRTCReceiver(channelOptions);
    const onError = (evt) => {
      const err = evt.detail;
      log4.error("incoming connection errored", err);
    };
    channel.addEventListener("error", onError);
    channel.addEventListener("close", () => {
      channel.removeEventListener("error", onError);
    }, {
      once: true
    });
    channel.addEventListener("signal", (evt) => {
      const signal = evt.detail;
      this.socket.emit("ss-handshake", {
        intentId,
        srcMultiaddr,
        dstMultiaddr,
        answer: true,
        signal
      });
    });
    channel.addEventListener("ready", () => {
      const maConn = toMultiaddrConnection(channel, { remoteAddr: this.signallingAddr });
      log4("new inbound connection %s", maConn.remoteAddr);
      try {
        this.upgrader.upgradeInbound(maConn).then((conn) => {
          log4("inbound connection %s upgraded", maConn.remoteAddr);
          this.connections.push(maConn);
          const untrackConn = () => {
            this.connections = this.connections.filter((c2) => c2 !== maConn);
            this.channels.delete(intentId);
            this.pendingSignals.delete(intentId);
          };
          channel.addEventListener("close", untrackConn, {
            once: true
          });
          this.dispatchEvent(new CustomEvent("connection", {
            detail: conn
          }));
          this.handler(conn);
        }).catch((err) => {
          log4.error("inbound connection failed to upgrade", err);
          maConn.close().catch((err2) => {
            log4.error("inbound connection failed to close after failing to upgrade", err2);
          });
        });
      } catch (err) {
        log4.error("inbound connection failed to upgrade", err);
        maConn.close().catch((err2) => {
          log4.error("inbound connection failed to close after failing to upgrade", err2);
        });
      }
    }, {
      once: true
    });
    return channel;
  }
  handleWsHandshake(offer) {
    log4('incoming handshake. signal type "%s" is answer %s', offer.signal.type, offer.answer);
    if (offer.answer === true || offer.err != null || offer.intentId == null) {
      return;
    }
    const intentId = offer.intentId;
    let pendingSignals = this.pendingSignals.get(intentId);
    if (pendingSignals == null) {
      pendingSignals = [];
      this.pendingSignals.set(intentId, pendingSignals);
    }
    pendingSignals.push(offer);
    let channel = this.channels.get(intentId);
    if (channel == null) {
      if (offer.signal.type !== "offer") {
        log4("handshake is not an offer and channel does not exist, buffering until we receive an offer");
        return;
      }
      log4("creating new channel to handle offer handshake");
      channel = this._createChannel(offer.intentId, offer.srcMultiaddr, offer.dstMultiaddr);
      this.channels.set(intentId, channel);
    } else {
      log4("channel already exists, using it to handle handshake");
    }
    while (pendingSignals.length > 0) {
      const handshake = pendingSignals.shift();
      if (handshake?.signal != null) {
        channel.handleSignal(handshake.signal);
      }
    }
  }
  async close() {
    this.socket.emit("ss-leave", this.signallingAddr.toString());
    this.socket.removeAllListeners();
    this.socket.close();
    await Promise.all([
      ...this.connections.map(async (maConn) => await maConn.close()),
      ...Array.from(this.channels.values()).map(async (channel) => await channel.close())
    ]);
    this.dispatchEvent(new CustomEvent("close"));
  }
};
var WebRTCListener = class extends EventEmitter {
  constructor(upgrader, handler, peerId, transport, options) {
    super();
    this.upgrader = upgrader;
    this.handler = handler;
    this.peerId = peerId;
    this.transport = transport;
    this.options = options;
  }
  async listen(ma2) {
    if (this.listeningAddr != null) {
      throw (0, import_err_code5.default)(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
    }
    const defer = pDefer();
    this.listeningAddr = ma2;
    let signallingAddr;
    if (!ma2.protoCodes().includes(CODE_P2P)) {
      signallingAddr = ma2.encapsulate(`/p2p/${this.peerId.toString()}`);
    } else {
      signallingAddr = ma2;
    }
    this.signallingUrl = cleanUrlSIO(ma2);
    log4("connecting to signalling server on: %s", this.signallingUrl);
    const server = new SigServer(this.signallingUrl, signallingAddr, this.upgrader, this.handler, this.options.channelOptions);
    server.addEventListener("error", (evt) => {
      const err = evt.detail;
      log4("error connecting to signalling server %o", err);
      server.close().catch((err2) => {
        log4.error("error closing server after error", err2);
      });
      defer.reject(err);
    });
    server.addEventListener("listening", () => {
      log4("connected to signalling server");
      this.dispatchEvent(new CustomEvent("listening"));
      defer.resolve();
    });
    server.addEventListener("peer", (evt) => {
      this.transport.peerDiscovered(evt.detail);
    });
    server.addEventListener("connection", (evt) => {
      const conn = evt.detail;
      if (conn.remoteAddr == null) {
        try {
          conn.remoteAddr = ma2.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toString()}`);
        } catch (err) {
          log4.error("could not determine remote address", err);
        }
      }
      this.dispatchEvent(new CustomEvent("connection", {
        detail: conn
      }));
    });
    this.transport.sigServers.set(this.signallingUrl, server);
    return await defer.promise;
  }
  async close() {
    if (this.signallingUrl != null) {
      const server = this.transport.sigServers.get(this.signallingUrl);
      if (server != null) {
        await server.close();
        this.transport.sigServers.delete(this.signallingUrl);
      }
    }
    this.dispatchEvent(new CustomEvent("close"));
    this.listeningAddr = void 0;
  }
  getAddrs() {
    if (this.listeningAddr != null) {
      return [
        this.listeningAddr
      ];
    }
    return [];
  }
};
function createListener(upgrader, handler, peerId, transport, options) {
  return new WebRTCListener(upgrader, handler, peerId, transport, options);
}

// ../../node_modules/@libp2p/webrtc-star/dist/src/index.js
var import_random3 = __toESM(require_random_browser(), 1);

// ../../node_modules/uint8arrays/esm/src/index.js
init_define_process();

// ../../node_modules/uint8arrays/esm/src/compare.js
init_define_process();

// ../../node_modules/uint8arrays/esm/src/xor.js
init_define_process();

// ../../node_modules/@libp2p/peer-id/dist/src/index.js
init_define_process();
var import_err_code6 = __toESM(require_err_code(), 1);

// ../../node_modules/@libp2p/interface-peer-id/dist/src/index.js
init_define_process();
var symbol2 = Symbol.for("@libp2p/peer-id");

// ../../node_modules/@libp2p/peer-id/dist/src/index.js
var baseDecoder = Object.values(bases).map((codec) => codec.decoder).reduce((acc, curr) => acc.or(curr), bases.identity.decoder);
var LIBP2P_KEY_CODE = 114;
var MARSHALLED_ED225519_PUBLIC_KEY_LENGTH = 36;
var MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH = 37;
var PeerIdImpl = class {
  constructor(init) {
    this.type = init.type;
    this.multihash = init.multihash;
    this.privateKey = init.privateKey;
    Object.defineProperty(this, "string", {
      enumerable: false,
      writable: true
    });
  }
  get [Symbol.toStringTag]() {
    return `PeerId(${this.toString()})`;
  }
  get [symbol2]() {
    return true;
  }
  toString() {
    if (this.string == null) {
      this.string = base58btc.encode(this.multihash.bytes).slice(1);
    }
    return this.string;
  }
  toCID() {
    return CID.createV1(LIBP2P_KEY_CODE, this.multihash);
  }
  toBytes() {
    return this.multihash.bytes;
  }
  toJSON() {
    return this.toString();
  }
  equals(id) {
    if (id instanceof Uint8Array) {
      return equals3(this.multihash.bytes, id);
    } else if (typeof id === "string") {
      return peerIdFromString(id).equals(this);
    } else if (id?.multihash?.bytes != null) {
      return equals3(this.multihash.bytes, id.multihash.bytes);
    } else {
      throw new Error("not valid Id");
    }
  }
};
var RSAPeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "RSA" });
    this.type = "RSA";
    this.publicKey = init.publicKey;
  }
};
var Ed25519PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "Ed25519" });
    this.type = "Ed25519";
    this.publicKey = init.multihash.digest;
  }
};
var Secp256k1PeerIdImpl = class extends PeerIdImpl {
  constructor(init) {
    super({ ...init, type: "secp256k1" });
    this.type = "secp256k1";
    this.publicKey = init.multihash.digest;
  }
};
function peerIdFromString(str, decoder) {
  decoder = decoder ?? baseDecoder;
  if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
    const multihash = decode3(base58btc.decode(`z${str}`));
    if (str.startsWith("12D")) {
      return new Ed25519PeerIdImpl({ multihash });
    } else if (str.startsWith("16U")) {
      return new Secp256k1PeerIdImpl({ multihash });
    } else {
      return new RSAPeerIdImpl({ multihash });
    }
  }
  return peerIdFromBytes(baseDecoder.decode(str));
}
function peerIdFromBytes(buf) {
  try {
    const multihash = decode3(buf);
    if (multihash.code === identity3.code) {
      if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
        return new Ed25519PeerIdImpl({ multihash });
      } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
        return new Secp256k1PeerIdImpl({ multihash });
      }
    }
    if (multihash.code === sha256.code) {
      return new RSAPeerIdImpl({ multihash });
    }
  } catch {
    return peerIdFromCID(CID.decode(buf));
  }
  throw new Error("Supplied PeerID CID is invalid");
}
function peerIdFromCID(cid) {
  if (cid == null || cid.multihash == null || cid.version == null || cid.version === 1 && cid.code !== LIBP2P_KEY_CODE) {
    throw new Error("Supplied PeerID CID is invalid");
  }
  const multihash = cid.multihash;
  if (multihash.code === sha256.code) {
    return new RSAPeerIdImpl({ multihash: cid.multihash });
  } else if (multihash.code === identity3.code) {
    if (multihash.digest.length === MARSHALLED_ED225519_PUBLIC_KEY_LENGTH) {
      return new Ed25519PeerIdImpl({ multihash: cid.multihash });
    } else if (multihash.digest.length === MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH) {
      return new Secp256k1PeerIdImpl({ multihash: cid.multihash });
    }
  }
  throw new Error("Supplied PeerID CID is invalid");
}

// ../../node_modules/@libp2p/interfaces/dist/src/transport/index.js
init_define_process();
var symbol3 = Symbol.for("@libp2p/transport");

// ../../node_modules/@libp2p/interfaces/dist/src/components.js
init_define_process();
var import_err_code7 = __toESM(require_err_code(), 1);

// ../../node_modules/@libp2p/interfaces/dist/src/startable.js
init_define_process();
function isStartable(obj) {
  return obj != null && typeof obj.start === "function" && typeof obj.stop === "function";
}

// ../../node_modules/@libp2p/interfaces/dist/src/components.js
function isInitializable(obj) {
  return obj != null && typeof obj.init === "function";
}
var Components = class {
  constructor(init = {}) {
    this.started = false;
    if (init.peerId != null) {
      this.setPeerId(init.peerId);
    }
    if (init.addressManager != null) {
      this.setAddressManager(init.addressManager);
    }
    if (init.peerStore != null) {
      this.setPeerStore(init.peerStore);
    }
    if (init.upgrader != null) {
      this.setUpgrader(init.upgrader);
    }
    if (init.metrics != null) {
      this.setMetrics(init.metrics);
    }
    if (init.registrar != null) {
      this.setRegistrar(init.registrar);
    }
    if (init.connectionManager != null) {
      this.setConnectionManager(init.connectionManager);
    }
    if (init.transportManager != null) {
      this.setTransportManager(init.transportManager);
    }
    if (init.connectionGater != null) {
      this.setConnectionGater(init.connectionGater);
    }
    if (init.contentRouting != null) {
      this.setContentRouting(init.contentRouting);
    }
    if (init.peerRouting != null) {
      this.setPeerRouting(init.peerRouting);
    }
    if (init.datastore != null) {
      this.setDatastore(init.datastore);
    }
    if (init.connectionProtector != null) {
      this.setConnectionProtector(init.connectionProtector);
    }
    if (init.dht != null) {
      this.setDHT(init.dht);
    }
    if (init.pubsub != null) {
      this.setPubSub(init.pubsub);
    }
  }
  isStarted() {
    return this.started;
  }
  async beforeStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStart != null) {
        await startable.beforeStart();
      }
    }));
  }
  async start() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.start();
    }));
    this.started = true;
  }
  async afterStart() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStart != null) {
        await startable.afterStart();
      }
    }));
  }
  async beforeStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.beforeStop != null) {
        await startable.beforeStop();
      }
    }));
  }
  async stop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      await startable.stop();
    }));
    this.started = false;
  }
  async afterStop() {
    await Promise.all(Object.values(this).filter((obj) => isStartable(obj)).map(async (startable) => {
      if (startable.afterStop != null) {
        await startable.afterStop();
      }
    }));
  }
  setPeerId(peerId) {
    this.peerId = peerId;
    return peerId;
  }
  getPeerId() {
    if (this.peerId == null) {
      throw (0, import_err_code7.default)(new Error("peerId not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerId;
  }
  setMetrics(metrics) {
    this.metrics = metrics;
    if (isInitializable(metrics)) {
      metrics.init(this);
    }
    return metrics;
  }
  getMetrics() {
    return this.metrics;
  }
  setAddressManager(addressManager) {
    this.addressManager = addressManager;
    if (isInitializable(addressManager)) {
      addressManager.init(this);
    }
    return addressManager;
  }
  getAddressManager() {
    if (this.addressManager == null) {
      throw (0, import_err_code7.default)(new Error("addressManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.addressManager;
  }
  setPeerStore(peerStore) {
    this.peerStore = peerStore;
    if (isInitializable(peerStore)) {
      peerStore.init(this);
    }
    return peerStore;
  }
  getPeerStore() {
    if (this.peerStore == null) {
      throw (0, import_err_code7.default)(new Error("peerStore not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerStore;
  }
  setUpgrader(upgrader) {
    this.upgrader = upgrader;
    if (isInitializable(upgrader)) {
      upgrader.init(this);
    }
    return upgrader;
  }
  getUpgrader() {
    if (this.upgrader == null) {
      throw (0, import_err_code7.default)(new Error("upgrader not set"), "ERR_SERVICE_MISSING");
    }
    return this.upgrader;
  }
  setRegistrar(registrar) {
    this.registrar = registrar;
    if (isInitializable(registrar)) {
      registrar.init(this);
    }
    return registrar;
  }
  getRegistrar() {
    if (this.registrar == null) {
      throw (0, import_err_code7.default)(new Error("registrar not set"), "ERR_SERVICE_MISSING");
    }
    return this.registrar;
  }
  setConnectionManager(connectionManager) {
    this.connectionManager = connectionManager;
    if (isInitializable(connectionManager)) {
      connectionManager.init(this);
    }
    return connectionManager;
  }
  getConnectionManager() {
    if (this.connectionManager == null) {
      throw (0, import_err_code7.default)(new Error("connectionManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionManager;
  }
  setTransportManager(transportManager) {
    this.transportManager = transportManager;
    if (isInitializable(transportManager)) {
      transportManager.init(this);
    }
    return transportManager;
  }
  getTransportManager() {
    if (this.transportManager == null) {
      throw (0, import_err_code7.default)(new Error("transportManager not set"), "ERR_SERVICE_MISSING");
    }
    return this.transportManager;
  }
  setConnectionGater(connectionGater) {
    this.connectionGater = connectionGater;
    if (isInitializable(connectionGater)) {
      connectionGater.init(this);
    }
    return connectionGater;
  }
  getConnectionGater() {
    if (this.connectionGater == null) {
      throw (0, import_err_code7.default)(new Error("connectionGater not set"), "ERR_SERVICE_MISSING");
    }
    return this.connectionGater;
  }
  setContentRouting(contentRouting) {
    this.contentRouting = contentRouting;
    if (isInitializable(contentRouting)) {
      contentRouting.init(this);
    }
    return contentRouting;
  }
  getContentRouting() {
    if (this.contentRouting == null) {
      throw (0, import_err_code7.default)(new Error("contentRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.contentRouting;
  }
  setPeerRouting(peerRouting) {
    this.peerRouting = peerRouting;
    if (isInitializable(peerRouting)) {
      peerRouting.init(this);
    }
    return peerRouting;
  }
  getPeerRouting() {
    if (this.peerRouting == null) {
      throw (0, import_err_code7.default)(new Error("peerRouting not set"), "ERR_SERVICE_MISSING");
    }
    return this.peerRouting;
  }
  setDatastore(datastore) {
    this.datastore = datastore;
    if (isInitializable(datastore)) {
      datastore.init(this);
    }
    return datastore;
  }
  getDatastore() {
    if (this.datastore == null) {
      throw (0, import_err_code7.default)(new Error("datastore not set"), "ERR_SERVICE_MISSING");
    }
    return this.datastore;
  }
  setConnectionProtector(connectionProtector) {
    this.connectionProtector = connectionProtector;
    if (isInitializable(connectionProtector)) {
      connectionProtector.init(this);
    }
    return connectionProtector;
  }
  getConnectionProtector() {
    return this.connectionProtector;
  }
  setDHT(dht) {
    this.dht = dht;
    if (isInitializable(dht)) {
      dht.init(this);
    }
    return dht;
  }
  getDHT() {
    if (this.dht == null) {
      throw (0, import_err_code7.default)(new Error("dht not set"), "ERR_SERVICE_MISSING");
    }
    return this.dht;
  }
  setPubSub(pubsub) {
    this.pubsub = pubsub;
    if (isInitializable(pubsub)) {
      pubsub.init(this);
    }
    return pubsub;
  }
  getPubSub() {
    if (this.pubsub == null) {
      throw (0, import_err_code7.default)(new Error("pubsub not set"), "ERR_SERVICE_MISSING");
    }
    return this.pubsub;
  }
};

// ../../node_modules/@libp2p/interfaces/dist/src/peer-discovery/index.js
init_define_process();
var symbol4 = Symbol.for("@libp2p/peer-discovery");

// ../../node_modules/@libp2p/webrtc-star/dist/src/index.js
var webrtcSupport = "RTCPeerConnection" in globalThis;
var log5 = logger("libp2p:webrtc-star");
var noop = () => {
};
var WebRTCStarDiscovery = class extends EventEmitter {
  constructor() {
    super(...arguments);
    this.started = false;
  }
  get [symbol4]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star-discovery";
  }
  isStarted() {
    return this.started;
  }
  async start() {
    this.started = true;
  }
  async stop() {
    this.started = false;
  }
  dispatchEvent(event) {
    if (!this.isStarted()) {
      return false;
    }
    return super.dispatchEvent(event);
  }
};
var WebRTCStar2 = class {
  constructor(options) {
    this.components = new Components();
    if (options?.wrtc != null) {
      this.wrtc = options.wrtc;
    }
    this.sigServers = /* @__PURE__ */ new Map();
    this.discovery = new WebRTCStarDiscovery();
    this.peerDiscovered = this.peerDiscovered.bind(this);
  }
  get [symbol3]() {
    return true;
  }
  get [Symbol.toStringTag]() {
    return "@libp2p/webrtc-star";
  }
  init(components) {
    this.components = components;
  }
  async dial(ma2, options) {
    const rawConn = await this._connect(ma2, options);
    const maConn = toMultiaddrConnection(rawConn, { remoteAddr: ma2, signal: options.signal });
    log5("new outbound connection %s", maConn.remoteAddr);
    const conn = await options.upgrader.upgradeOutbound(maConn);
    log5("outbound connection %s upgraded", maConn.remoteAddr);
    return conn;
  }
  async _connect(ma2, options) {
    if (options.signal?.aborted === true) {
      throw new AbortError3();
    }
    const channelOptions = {
      ...options.channelOptions ?? {}
    };
    if (this.wrtc != null) {
      channelOptions.wrtc = this.wrtc;
    }
    const cOpts = ma2.toOptions();
    const intentId = toString2((0, import_random3.default)(36), "hex");
    return await new Promise((resolve, reject) => {
      const sio = this.sigServers.get(cleanUrlSIO(ma2));
      if (sio?.socket == null) {
        return reject((0, import_err_code8.default)(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
      }
      let connected = false;
      log5("dialing %s:%s", cOpts.host, cOpts.port);
      const channel = new WebRTCInitiator(channelOptions);
      const onError = (evt) => {
        const err = evt.detail;
        if (!connected) {
          const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;
          log5.error(msg);
          done(err);
        }
      };
      const onReady = () => {
        connected = true;
        log5("connection opened %s:%s", cOpts.host, cOpts.port);
        done();
      };
      const onAbort = () => {
        log5.error("connection aborted %s:%s", cOpts.host, cOpts.port);
        channel.close().finally(() => {
          done(new AbortError3());
        });
      };
      const done = (err) => {
        channel.removeEventListener("ready", onReady);
        options.signal?.removeEventListener("abort", onAbort);
        if (err == null) {
          resolve(channel);
        } else {
          reject(err);
        }
      };
      channel.addEventListener("ready", onReady, {
        once: true
      });
      channel.addEventListener("close", () => {
        channel.removeEventListener("error", onError);
      });
      options.signal?.addEventListener("abort", onAbort);
      channel.addEventListener("signal", (evt) => {
        const signal = evt.detail;
        sio.socket.emit("ss-handshake", {
          intentId,
          srcMultiaddr: sio.signallingAddr.toString(),
          dstMultiaddr: ma2.toString(),
          signal
        });
      });
      sio.socket.on("ws-handshake", (offer) => {
        if (offer.intentId === intentId && offer.err != null) {
          channel.close().finally(() => {
            reject((0, import_err_code8.default)(new Error(offer.err), "ERR_SIGNALLING_FAILED"));
          });
        }
        if (offer.intentId !== intentId || offer.answer == null || channel.closed) {
          return;
        }
        channel.handleSignal(offer.signal);
      });
    });
  }
  createListener(options) {
    if (!webrtcSupport && this.wrtc == null) {
      throw (0, import_err_code8.default)(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
    }
    options.channelOptions = options.channelOptions ?? {};
    if (this.wrtc != null) {
      options.channelOptions.wrtc = this.wrtc;
    }
    return createListener(options.upgrader, options.handler ?? noop, this.components.getPeerId(), this, options);
  }
  filter(multiaddrs) {
    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
    return multiaddrs.filter((ma2) => {
      if (ma2.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      return WebRTCStar.matches(ma2);
    });
  }
  peerDiscovered(maStr) {
    log5("peer discovered: %s", maStr);
    maStr = cleanMultiaddr(maStr);
    const ma2 = new Multiaddr(maStr);
    const peerIdStr = ma2.getPeerId();
    if (peerIdStr == null) {
      return;
    }
    const peerId = peerIdFromString(peerIdStr);
    this.discovery.dispatchEvent(new CustomEvent("peer", {
      detail: {
        id: peerId,
        multiaddrs: [ma2],
        protocols: []
      }
    }));
  }
};

// ../../node_modules/ipfs-core-config/src/libp2p.browser.js
function libp2pConfig() {
  const webRtcStar = new WebRTCStar2();
  const options = {
    transports: [
      webRtcStar
    ],
    peerDiscovery: [
      webRtcStar.discovery
    ],
    connectionManager: {
      maxParallelDials: 150,
      maxDialsPerPeer: 4,
      dialTimeout: 1e4,
      autoDial: true
    },
    nat: {
      enabled: false
    },
    metrics: {
      enabled: true
    }
  };
  return options;
}

// js/ipfs.mjs
init_index_min();
var { IpfsCore: IpfsCore2 } = self;
var orbitDbs = {};
self.orbitDbs = orbitDbs;
var ipfsServer = null;
var connect = async (channel) => {
  ipfsServer = ipfsServer || new Server(new IPFSService(await IpfsCore2.create({
    start: true,
    preload: {
      enabled: false
    },
    config: {
      ...config_browser_default(),
      ...libp2pConfig()
    }
  })));
  return ipfsServer.connect(channel.port1);
};
export {
  connect
};
