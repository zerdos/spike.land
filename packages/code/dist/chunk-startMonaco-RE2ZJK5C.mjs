import "./chunk-chunk-G5LCIQBK.mjs";
import "./chunk-chunk-F77G2MUT.mjs";
import {
  $,
  Action,
  Action2,
  ActionBar,
  ActionViewItem,
  AsyncIterableObject,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CSSIcon,
  CancellationError,
  CancellationToken,
  CancellationTokenSource,
  CaseSensitiveToggle,
  CharacterSet,
  CodeEditorWidget,
  Codicon,
  Color,
  Command,
  CommandsRegistry,
  CompletionItemInsertTextRule,
  CompletionItemKinds,
  ContextKeyExpr,
  CopyOptions,
  CoreEditingCommands,
  CountBadge,
  CursorColumns,
  CursorMoveCommands,
  CursorState,
  DataTransfers,
  DataUri,
  Delayer,
  DenseKeyProvider,
  Dimension,
  Disposable,
  DisposableStore,
  DocumentHighlightKind,
  DomEmitter,
  DomScrollableElement,
  DynamicCssRules,
  EDITOR_FONT_DEFAULTS,
  EditOperation,
  EditorAction,
  EditorAction2,
  EditorCommand,
  EditorContextKeys,
  EditorFontLigatures,
  EditorOptions,
  EditorState,
  EditorStateCancellationTokenSource,
  EditorZoom,
  Emitter,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  FindInput,
  FoldingRangeKind,
  FormattingEdit,
  FuzzyScore,
  FuzzyScoreOptions,
  Gesture,
  GlobalPointerMoveMonitor,
  HSVA,
  HighlightedLabel,
  HistoryInputBox,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IDialogService,
  IEditorProgressService,
  IEditorWorkerService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  ILanguageFeatureDebounceService,
  ILanguageFeaturesService,
  ILanguageService,
  IListService,
  ILogService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModelService,
  INotificationService,
  IOpenerService,
  IProgressService,
  IQuickInputService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUndoRedoService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  IconLabel,
  IdGenerator,
  IdleValue,
  InMemoryClipboardMetadataManager,
  IndentAction,
  InjectedTextCursorStops,
  InlayHintKind,
  InlineCompletionTriggerKind,
  InvisibleCharacters,
  IsWindowsContext,
  Iterable,
  KeyChord,
  KeybindingLabel,
  KeybindingsRegistry,
  LRUCache,
  LanguageAgnosticBracketTokens,
  Lazy,
  LcsDiff,
  LineDecoration,
  LineTokens,
  LinkedList,
  List,
  MarkdownString,
  MarkerSeverity,
  MenuEntryActionViewItem,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  Mimes,
  MinimapPosition,
  ModelDecorationInjectedTextOptions,
  ModelDecorationOptions,
  ModifierKeyEmitter,
  MoveOperations,
  MultiCommand,
  MultiEditorAction,
  MutableDisposable,
  OS,
  OrthogonalEdge,
  OverviewRulerLane,
  PLAINTEXT_LANGUAGE_ID,
  PauseableEmitter,
  PixelRatio,
  Position,
  Progress,
  RGBA,
  Range,
  RawContextKey,
  RefCountedDisposable,
  RegexToggle,
  Registry,
  RenderLineInput,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ReplaceCommandThatSelectsText,
  ResourceMap,
  ResourceTextEdit,
  RunOnceScheduler,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  Sash,
  Schemas,
  ScrollableElement,
  SearchParams,
  Selection,
  Separator,
  Severity,
  ShiftCommand,
  SignatureHelpTriggerKind,
  SimpleKeybinding,
  Sizing,
  SplitView,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  StringBuilder,
  SubmenuAction,
  SubmenuItemAction,
  TabFocus,
  TernarySearchTree,
  TextBufferTokenizer,
  TextModel,
  TextModelCancellationTokenSource,
  ThemeIcon,
  TimeoutTimer,
  Toggle,
  TokenizationRegistry,
  TypeOperations,
  URI,
  UnicodeTextModelHighlighter,
  Uri,
  WORKSPACE_EXTENSION,
  WholeWordsToggle,
  Widget,
  WillSaveStateReason,
  WordOperations,
  WordPartOperations,
  WorkbenchAsyncDataTree,
  WorkbenchListFocusContextKey,
  WorkbenchTreeElementCanCollapse,
  WorkbenchTreeElementCanExpand,
  activeContrastBorder,
  addDisposableListener,
  addStandardDisposableGenericMouseDownListener,
  addStandardDisposableListener,
  alert,
  alertFormattingEdits,
  anyScore,
  append,
  applyFontInfo,
  asArray,
  asCssValue,
  assertIsDefined,
  assertNever,
  assertType,
  attachBadgeStyler,
  attachListStyler,
  basename,
  basename2,
  basenameOrAuthority,
  binarySearch,
  clamp,
  clearNode,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  compareBy,
  compareIgnoreCase,
  computeIndentLevel,
  containsRTL,
  containsUppercaseCharacter,
  contrastBorder,
  countEOL,
  createActionViewItem,
  createAndFillInActionBarActions,
  createCSSRule,
  createCancelableAsyncIterable,
  createCancelablePromise,
  createDecorator,
  createMatches,
  deepClone,
  defaultGenerator,
  defaultInputBoxStyles,
  defaultToggleStyles,
  dirname,
  dirname2,
  disposableTimeout,
  dispose,
  distinct,
  editor,
  editorActiveLinkForeground,
  editorBackground,
  editorConfigurationBaseNode,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatch,
  editorFindMatchBorder,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlight,
  editorFindRangeHighlightBorder,
  editorForeground,
  editorHoverBackground,
  editorHoverBorder,
  editorInfoBorder,
  editorInfoForeground,
  editorInlayHintBackground,
  editorInlayHintForeground,
  editorInlayHintParameterBackground,
  editorInlayHintParameterForeground,
  editorInlayHintTypeBackground,
  editorInlayHintTypeForeground,
  editorSelectionBackground,
  editorSelectionHighlight,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  editorWidgetResizeBorder,
  editor_api_exports,
  equals,
  errorForeground,
  escapeRegExpCharacters,
  extUri,
  extname,
  extractSelection,
  findFirstInSorted,
  findMaxBy,
  first,
  firstNonWhitespaceIndex,
  focusBorder,
  foreground,
  format,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  getClientArea,
  getComputedStyle,
  getDocumentRangeSemanticTokens,
  getDomNodePagePosition,
  getEnterAction,
  getGoodIndentForLine,
  getIndentMetadata,
  getLeadingWhitespace,
  getMapForWordSeparators,
  getOnTypeFormattingEdits,
  getShadowRoot,
  getTopLeftOffset,
  getTotalWidth,
  groupBy,
  hasDocumentRangeSemanticTokensProvider,
  hasDriveLetter,
  hash,
  hide,
  iconForeground,
  illegalArgument,
  inUntrustedWorkspace,
  init_actions,
  init_actions2,
  init_aria,
  init_arrays,
  init_assert,
  init_async,
  init_brackets,
  init_browser,
  init_cancellation,
  init_characterClassifier,
  init_codeEditorService,
  init_codicons,
  init_color,
  init_colorRegistry,
  init_commands,
  init_configuration,
  init_configurationRegistry,
  init_contextkey,
  init_cursorColumns,
  init_dom,
  init_editOperation,
  init_editorBrowser,
  init_editorContextKeys,
  init_editorExtensions,
  init_editorState,
  init_editorWorker,
  init_eolCounter,
  init_errors,
  init_event,
  init_extensions,
  init_extpath,
  init_format,
  init_formattingEdit,
  init_functional,
  init_getSemanticTokens,
  init_hash,
  init_indentation,
  init_instantiation,
  init_iterator,
  init_keyCodes,
  init_keybindings,
  init_keybindingsRegistry,
  init_keyboardEvent,
  init_language,
  init_languageConfiguration,
  init_languageConfigurationRegistry,
  init_languageFeatureDebounce,
  init_languageFeatures,
  init_languages,
  init_lazy,
  init_length,
  init_lifecycle,
  init_lineTokens,
  init_linkedList,
  init_log,
  init_map,
  init_mime,
  init_model,
  init_model2,
  init_modelService,
  init_modesRegistry,
  init_mouseEvent,
  init_network,
  init_nls,
  init_numbers,
  init_objects,
  init_opener,
  init_parser,
  init_path,
  init_platform,
  init_platform2,
  init_position,
  init_progress,
  init_range,
  init_resolverService,
  init_resources,
  init_selection,
  init_semanticTokensProviderStyling,
  init_smallImmutableSet,
  init_stopwatch,
  init_stringBuilder,
  init_strings,
  init_telemetry,
  init_textModel,
  init_textModelSearch,
  init_textResourceConfiguration,
  init_theme,
  init_themeService,
  init_tokenizer,
  init_types,
  init_undoRedo,
  init_uri,
  init_utils,
  init_wordCharacterClassifier,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  isBasicASCII,
  isCancellationError,
  isCodeEditor,
  isDisposable,
  isEmptyMarkdownString,
  isEqual,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isHighContrast,
  isHighSurrogate,
  isIMenuItem,
  isIOS,
  isInDOM,
  isLinux,
  isLocationLink,
  isLowSurrogate,
  isLowerAsciiLetter,
  isMacintosh,
  isModelDecorationInComment,
  isModelDecorationInString,
  isModelDecorationVisible,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isSemanticColoringEnabled,
  isSingleFolderWorkspaceIdentifier,
  isStandalone,
  isString,
  isUndefined,
  isUpperAsciiLetter,
  isWeb,
  isWindows,
  joinPath,
  language,
  languages,
  lastNonWhitespaceIndex,
  lengthAdd,
  lengthGetColumnCountIfZeroLineCount,
  lengthZero,
  listFocusHighlightForeground,
  listHighlightForeground,
  localize,
  matchesSubString,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  mixin,
  noBreakWhitespace,
  normalizeIndentation,
  numberComparator,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  oneOf,
  originalFSPath,
  overviewRulerFindMatchForeground,
  overviewRulerSelectionHighlightForeground,
  parse,
  parseDocument,
  problemsErrorIconForeground,
  problemsInfoIconForeground,
  problemsWarningIconForeground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickSelect,
  raceCancellation,
  registerAction2,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerIcon,
  registerInstantiatedEditorAction,
  registerModelAndPositionCommand,
  registerMultiEditorAction,
  registerSingleton,
  registerThemingParticipant,
  relativePath,
  removeCSSRulesContainingSelector,
  renderLabelWithIcons,
  renderMarkdown,
  renderViewLine,
  reset,
  runAtThisOrScheduleAtNextAnimationFrame,
  runWhenIdle,
  severity_default,
  show,
  size,
  splitLines,
  status,
  themeColorFromId,
  timeout,
  toDisposable,
  toMultilineTokens2,
  toWorkspaceIdentifier,
  tokenizeToString,
  toolbarHoverBackground,
  trackFocus,
  transparent,
  unicodeHighlightConfigKeys,
  widgetClose,
  widgetShadow,
  withNullAsUndefined
} from "./chunk-chunk-NIBVHMFI.mjs";
import {
  __commonJS,
  __esm,
  __name,
  __toESM,
  init_define_process
} from "./chunk-chunk-A3E5PINE.mjs";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js
var require_formatActions = __commonJS({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/formatActions.js"(exports) {
    init_define_process();
    init_arrays();
    init_cancellation();
    init_errors();
    init_keyCodes();
    init_lifecycle();
    init_editorExtensions();
    init_codeEditorService();
    init_characterClassifier();
    init_range();
    init_editorContextKeys();
    init_editorWorker();
    init_languageFeatures();
    init_format();
    init_formattingEdit();
    init_nls();
    init_commands();
    init_contextkey();
    init_instantiation();
    init_progress();
    var __decorate74 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param74 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var __awaiter55 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var FormatOnType = /* @__PURE__ */ __name(class FormatOnType {
      constructor(_editor, _languageFeaturesService, _workerService) {
        this._editor = _editor;
        this._languageFeaturesService = _languageFeaturesService;
        this._workerService = _workerService;
        this._disposables = new DisposableStore();
        this._sessionDisposables = new DisposableStore();
        this._disposables.add(_languageFeaturesService.onTypeFormattingEditProvider.onDidChange(this._update, this));
        this._disposables.add(_editor.onDidChangeModel(() => this._update()));
        this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
        this._disposables.add(_editor.onDidChangeConfiguration((e) => {
          if (e.hasChanged(51)) {
            this._update();
          }
        }));
      }
      dispose() {
        this._disposables.dispose();
        this._sessionDisposables.dispose();
      }
      _update() {
        this._sessionDisposables.clear();
        if (!this._editor.getOption(51)) {
          return;
        }
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        const [support] = this._languageFeaturesService.onTypeFormattingEditProvider.ordered(model);
        if (!support || !support.autoFormatTriggerCharacters) {
          return;
        }
        const triggerChars = new CharacterSet();
        for (const ch of support.autoFormatTriggerCharacters) {
          triggerChars.add(ch.charCodeAt(0));
        }
        this._sessionDisposables.add(this._editor.onDidType((text) => {
          const lastCharCode = text.charCodeAt(text.length - 1);
          if (triggerChars.has(lastCharCode)) {
            this._trigger(String.fromCharCode(lastCharCode));
          }
        }));
      }
      _trigger(ch) {
        if (!this._editor.hasModel()) {
          return;
        }
        if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
          return;
        }
        const model = this._editor.getModel();
        const position = this._editor.getPosition();
        const cts = new CancellationTokenSource();
        const unbind = this._editor.onDidChangeModelContent((e) => {
          if (e.isFlush) {
            cts.cancel();
            unbind.dispose();
            return;
          }
          for (let i = 0, len = e.changes.length; i < len; i++) {
            const change = e.changes[i];
            if (change.range.endLineNumber <= position.lineNumber) {
              cts.cancel();
              unbind.dispose();
              return;
            }
          }
        });
        getOnTypeFormattingEdits(this._workerService, this._languageFeaturesService, model, position, ch, model.getFormattingOptions(), cts.token).then((edits) => {
          if (cts.token.isCancellationRequested) {
            return;
          }
          if (isNonEmptyArray(edits)) {
            FormattingEdit.execute(this._editor, edits, true);
            alertFormattingEdits(edits);
          }
        }).finally(() => {
          unbind.dispose();
        });
      }
    }, "FormatOnType");
    FormatOnType.ID = "editor.contrib.autoFormat";
    FormatOnType = __decorate74([
      __param74(1, ILanguageFeaturesService),
      __param74(2, IEditorWorkerService)
    ], FormatOnType);
    var FormatOnPaste = /* @__PURE__ */ __name(class FormatOnPaste {
      constructor(editor2, _languageFeaturesService, _instantiationService) {
        this.editor = editor2;
        this._languageFeaturesService = _languageFeaturesService;
        this._instantiationService = _instantiationService;
        this._callOnDispose = new DisposableStore();
        this._callOnModel = new DisposableStore();
        this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
        this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
        this._callOnDispose.add(_languageFeaturesService.documentRangeFormattingEditProvider.onDidChange(this._update, this));
      }
      dispose() {
        this._callOnDispose.dispose();
        this._callOnModel.dispose();
      }
      _update() {
        this._callOnModel.clear();
        if (!this.editor.getOption(50)) {
          return;
        }
        if (!this.editor.hasModel()) {
          return;
        }
        if (!this._languageFeaturesService.documentRangeFormattingEditProvider.has(this.editor.getModel())) {
          return;
        }
        this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
      }
      _trigger(range) {
        if (!this.editor.hasModel()) {
          return;
        }
        if (this.editor.getSelections().length > 1) {
          return;
        }
        this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
      }
    }, "FormatOnPaste");
    FormatOnPaste.ID = "editor.contrib.formatOnPaste";
    FormatOnPaste = __decorate74([
      __param74(1, ILanguageFeaturesService),
      __param74(2, IInstantiationService)
    ], FormatOnPaste);
    var FormatDocumentAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatDocument",
          label: localize("formatDocument.label", "Format Document"),
          alias: "Format Document",
          precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 1024 | 512 | 36,
            linux: { primary: 2048 | 1024 | 39 },
            weight: 100
          },
          contextMenuOpts: {
            group: "1_modification",
            order: 1.3
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter55(this, void 0, void 0, function* () {
          if (editor2.hasModel()) {
            const instaService = accessor.get(IInstantiationService);
            const progressService = accessor.get(IEditorProgressService);
            yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None), 250);
          }
        });
      }
    };
    __name(FormatDocumentAction, "FormatDocumentAction");
    var FormatSelectionAction = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.formatSelection",
          label: localize("formatSelection.label", "Format Selection"),
          alias: "Format Selection",
          precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: KeyChord(2048 | 41, 2048 | 36),
            weight: 100
          },
          contextMenuOpts: {
            when: EditorContextKeys.hasNonEmptySelection,
            group: "1_modification",
            order: 1.31
          }
        });
      }
      run(accessor, editor2) {
        return __awaiter55(this, void 0, void 0, function* () {
          if (!editor2.hasModel()) {
            return;
          }
          const instaService = accessor.get(IInstantiationService);
          const model = editor2.getModel();
          const ranges = editor2.getSelections().map((range) => {
            return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
          });
          const progressService = accessor.get(IEditorProgressService);
          yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None), 250);
        });
      }
    };
    __name(FormatSelectionAction, "FormatSelectionAction");
    registerEditorContribution(FormatOnType.ID, FormatOnType, 2);
    registerEditorContribution(FormatOnPaste.ID, FormatOnPaste, 2);
    registerEditorAction(FormatDocumentAction);
    registerEditorAction(FormatSelectionAction);
    CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter55(void 0, void 0, void 0, function* () {
      const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
      if (!editor2 || !editor2.hasModel()) {
        return;
      }
      const commandService = accessor.get(ICommandService);
      if (editor2.getSelection().isEmpty()) {
        yield commandService.executeCommand("editor.action.formatDocument");
      } else {
        yield commandService.executeCommand("editor.action.formatSelection");
      }
    }));
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js
var __decorate34, __param34, __awaiter28, TreeElement, OutlineElement, OutlineGroup, OutlineModel, IOutlineModelService, OutlineModelService;
var init_outlineModel = __esm({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/outlineModel.js"() {
    init_define_process();
    init_arrays();
    init_cancellation();
    init_errors();
    init_iterator();
    init_map();
    init_position();
    init_range();
    init_languageFeatureDebounce();
    init_instantiation();
    init_extensions();
    init_model();
    init_lifecycle();
    init_languageFeatures();
    __decorate34 = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param34 = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __awaiter28 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    TreeElement = class {
      remove() {
        var _a6;
        (_a6 = this.parent) === null || _a6 === void 0 ? void 0 : _a6.children.delete(this.id);
      }
      static findId(candidate, container) {
        let candidateId;
        if (typeof candidate === "string") {
          candidateId = `${container.id}/${candidate}`;
        } else {
          candidateId = `${container.id}/${candidate.name}`;
          if (container.children.get(candidateId) !== void 0) {
            candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
          }
        }
        let id = candidateId;
        for (let i = 0; container.children.get(id) !== void 0; i++) {
          id = `${candidateId}_${i}`;
        }
        return id;
      }
      static empty(element) {
        return element.children.size === 0;
      }
    };
    __name(TreeElement, "TreeElement");
    OutlineElement = class extends TreeElement {
      constructor(id, parent, symbol) {
        super();
        this.id = id;
        this.parent = parent;
        this.symbol = symbol;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    __name(OutlineElement, "OutlineElement");
    OutlineGroup = class extends TreeElement {
      constructor(id, parent, label, order) {
        super();
        this.id = id;
        this.parent = parent;
        this.label = label;
        this.order = order;
        this.children = /* @__PURE__ */ new Map();
      }
    };
    __name(OutlineGroup, "OutlineGroup");
    OutlineModel = class extends TreeElement {
      static create(registry, textModel, token) {
        const cts = new CancellationTokenSource(token);
        const result = new OutlineModel(textModel.uri);
        const provider = registry.ordered(textModel);
        const promises = provider.map((provider2, index) => {
          var _a6;
          const id = TreeElement.findId(`provider_${index}`, result);
          const group = new OutlineGroup(id, result, (_a6 = provider2.displayName) !== null && _a6 !== void 0 ? _a6 : "Unknown Outline Provider", index);
          return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
            for (const info of result2 || []) {
              OutlineModel._makeOutlineElement(info, group);
            }
            return group;
          }, (err) => {
            onUnexpectedExternalError(err);
            return group;
          }).then((group2) => {
            if (!TreeElement.empty(group2)) {
              result._groups.set(id, group2);
            } else {
              group2.remove();
            }
          });
        });
        const listener = registry.onDidChange(() => {
          const newProvider = registry.ordered(textModel);
          if (!equals(newProvider, provider)) {
            cts.cancel();
          }
        });
        return Promise.all(promises).then(() => {
          if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
            return OutlineModel.create(registry, textModel, token);
          } else {
            return result._compact();
          }
        }).finally(() => {
          listener.dispose();
        });
      }
      static _makeOutlineElement(info, container) {
        const id = TreeElement.findId(info, container);
        const res = new OutlineElement(id, container, info);
        if (info.children) {
          for (const childInfo of info.children) {
            OutlineModel._makeOutlineElement(childInfo, res);
          }
        }
        container.children.set(res.id, res);
      }
      constructor(uri) {
        super();
        this.uri = uri;
        this.id = "root";
        this.parent = void 0;
        this._groups = /* @__PURE__ */ new Map();
        this.children = /* @__PURE__ */ new Map();
        this.id = "root";
        this.parent = void 0;
      }
      _compact() {
        let count = 0;
        for (const [key, group] of this._groups) {
          if (group.children.size === 0) {
            this._groups.delete(key);
          } else {
            count += 1;
          }
        }
        if (count !== 1) {
          this.children = this._groups;
        } else {
          const group = Iterable.first(this._groups.values());
          for (const [, child] of group.children) {
            child.parent = this;
            this.children.set(child.id, child);
          }
        }
        return this;
      }
      getTopLevelSymbols() {
        const roots = [];
        for (const child of this.children.values()) {
          if (child instanceof OutlineElement) {
            roots.push(child.symbol);
          } else {
            roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
          }
        }
        return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
      }
      asListOfDocumentSymbols() {
        const roots = this.getTopLevelSymbols();
        const bucket = [];
        OutlineModel._flattenDocumentSymbols(bucket, roots, "");
        return bucket.sort((a, b) => Position.compare(Range.getStartPosition(a.range), Range.getStartPosition(b.range)) || Position.compare(Range.getEndPosition(b.range), Range.getEndPosition(a.range)));
      }
      static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
        for (const entry of entries) {
          bucket.push({
            kind: entry.kind,
            tags: entry.tags,
            name: entry.name,
            detail: entry.detail,
            containerName: entry.containerName || overrideContainerLabel,
            range: entry.range,
            selectionRange: entry.selectionRange,
            children: void 0
          });
          if (entry.children) {
            OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
          }
        }
      }
    };
    __name(OutlineModel, "OutlineModel");
    IOutlineModelService = createDecorator("IOutlineModelService");
    OutlineModelService = /* @__PURE__ */ __name(class OutlineModelService2 {
      constructor(_languageFeaturesService, debounces, modelService) {
        this._languageFeaturesService = _languageFeaturesService;
        this._disposables = new DisposableStore();
        this._cache = new LRUCache(10, 0.7);
        this._debounceInformation = debounces.for(_languageFeaturesService.documentSymbolProvider, "DocumentSymbols", { min: 350 });
        this._disposables.add(modelService.onModelRemoved((textModel) => {
          this._cache.delete(textModel.id);
        }));
      }
      dispose() {
        this._disposables.dispose();
      }
      getOrCreate(textModel, token) {
        return __awaiter28(this, void 0, void 0, function* () {
          const registry = this._languageFeaturesService.documentSymbolProvider;
          const provider = registry.ordered(textModel);
          let data = this._cache.get(textModel.id);
          if (!data || data.versionId !== textModel.getVersionId() || !equals(data.provider, provider)) {
            const source = new CancellationTokenSource();
            data = {
              versionId: textModel.getVersionId(),
              provider,
              promiseCnt: 0,
              source,
              promise: OutlineModel.create(registry, textModel, source.token),
              model: void 0
            };
            this._cache.set(textModel.id, data);
            const now = Date.now();
            data.promise.then((outlineModel) => {
              data.model = outlineModel;
              this._debounceInformation.update(textModel, Date.now() - now);
            }).catch((_err) => {
              this._cache.delete(textModel.id);
            });
          }
          if (data.model) {
            return data.model;
          }
          data.promiseCnt += 1;
          const listener = token.onCancellationRequested(() => {
            if (--data.promiseCnt === 0) {
              data.source.cancel();
              this._cache.delete(textModel.id);
            }
          });
          try {
            return yield data.promise;
          } finally {
            listener.dispose();
          }
        });
      }
    }, "OutlineModelService");
    OutlineModelService = __decorate34([
      __param34(0, ILanguageFeaturesService),
      __param34(1, ILanguageFeatureDebounceService),
      __param34(2, IModelService)
    ], OutlineModelService);
    registerSingleton(IOutlineModelService, OutlineModelService, 1);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js
var require_documentSymbols = __commonJS({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/browser/documentSymbols.js"(exports) {
    init_define_process();
    init_cancellation();
    init_types();
    init_uri();
    init_resolverService();
    init_outlineModel();
    init_commands();
    var __awaiter55 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      __name(adopt, "adopt");
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        __name(fulfilled, "fulfilled");
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        __name(rejected, "rejected");
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        __name(step, "step");
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
      return __awaiter55(this, void 0, void 0, function* () {
        const [resource] = args;
        assertType(URI.isUri(resource));
        const outlineService = accessor.get(IOutlineModelService);
        const modelService = accessor.get(ITextModelService);
        const reference = yield modelService.createModelReference(resource);
        try {
          return (yield outlineService.getOrCreate(reference.object.textEditorModel, CancellationToken.None)).getTopLevelSymbols();
        } finally {
          reference.dispose();
        }
      });
    });
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js
var InPlaceReplaceCommand;
var init_inPlaceReplaceCommand = __esm({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplaceCommand.js"() {
    init_define_process();
    init_selection();
    InPlaceReplaceCommand = class {
      constructor(editRange, originalSelection, text) {
        this._editRange = editRange;
        this._originalSelection = originalSelection;
        this._text = text;
      }
      getEditOperations(model, builder) {
        builder.addTrackedEditOperation(this._editRange, this._text);
      }
      computeCursorState(model, helper) {
        const inverseEditOperations = helper.getInverseEditOperations();
        const srcRange = inverseEditOperations[0].range;
        if (!this._originalSelection.isEmpty()) {
          return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
        }
        return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
      }
    };
    __name(InPlaceReplaceCommand, "InPlaceReplaceCommand");
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.css
var init_ = __esm({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.css"() {
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js
var require_inPlaceReplace = __commonJS({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace.js"(exports) {
    init_define_process();
    init_async();
    init_errors();
    init_editorState();
    init_editorExtensions();
    init_range();
    init_selection();
    init_editorContextKeys();
    init_textModel();
    init_editorWorker();
    init_nls();
    init_inPlaceReplaceCommand();
    init_();
    var __decorate74 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param74 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var InPlaceReplaceController = /* @__PURE__ */ __name(class InPlaceReplaceController2 {
      static get(editor2) {
        return editor2.getContribution(InPlaceReplaceController2.ID);
      }
      constructor(editor2, editorWorkerService) {
        this.editor = editor2;
        this.editorWorkerService = editorWorkerService;
        this.decorations = this.editor.createDecorationsCollection();
      }
      dispose() {
      }
      run(source, up) {
        var _a6;
        (_a6 = this.currentRequest) === null || _a6 === void 0 ? void 0 : _a6.cancel();
        const editorSelection = this.editor.getSelection();
        const model = this.editor.getModel();
        if (!model || !editorSelection) {
          return void 0;
        }
        let selection = editorSelection;
        if (selection.startLineNumber !== selection.endLineNumber) {
          return void 0;
        }
        const state = new EditorState(this.editor, 1 | 4);
        const modelURI = model.uri;
        if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
          return Promise.resolve(void 0);
        }
        this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
        return this.currentRequest.then((result) => {
          var _a7;
          if (!result || !result.range || !result.value) {
            return;
          }
          if (!state.validate(this.editor)) {
            return;
          }
          const editRange = Range.lift(result.range);
          let highlightRange = result.range;
          const diff = result.value.length - (selection.endColumn - selection.startColumn);
          highlightRange = {
            startLineNumber: highlightRange.startLineNumber,
            startColumn: highlightRange.startColumn,
            endLineNumber: highlightRange.endLineNumber,
            endColumn: highlightRange.startColumn + result.value.length
          };
          if (diff > 1) {
            selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
          }
          const command = new InPlaceReplaceCommand(editRange, selection, result.value);
          this.editor.pushUndoStop();
          this.editor.executeCommand(source, command);
          this.editor.pushUndoStop();
          this.decorations.set([{
            range: highlightRange,
            options: InPlaceReplaceController2.DECORATION
          }]);
          (_a7 = this.decorationRemover) === null || _a7 === void 0 ? void 0 : _a7.cancel();
          this.decorationRemover = timeout(350);
          this.decorationRemover.then(() => this.decorations.clear()).catch(onUnexpectedError);
        }).catch(onUnexpectedError);
      }
    }, "InPlaceReplaceController");
    InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
    InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
      description: "in-place-replace",
      className: "valueSetReplacement"
    });
    InPlaceReplaceController = __decorate74([
      __param74(1, IEditorWorkerService)
    ], InPlaceReplaceController);
    var InPlaceReplaceUp = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.up",
          label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
          alias: "Replace with Previous Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 82,
            weight: 100
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, true);
      }
    };
    __name(InPlaceReplaceUp, "InPlaceReplaceUp");
    var InPlaceReplaceDown = class extends EditorAction {
      constructor() {
        super({
          id: "editor.action.inPlaceReplace.down",
          label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
          alias: "Replace with Next Value",
          precondition: EditorContextKeys.writable,
          kbOpts: {
            kbExpr: EditorContextKeys.editorTextFocus,
            primary: 2048 | 1024 | 84,
            weight: 100
          }
        });
      }
      run(accessor, editor2) {
        const controller = InPlaceReplaceController.get(editor2);
        if (!controller) {
          return Promise.resolve(void 0);
        }
        return controller.run(this.id, false);
      }
    };
    __name(InPlaceReplaceDown, "InPlaceReplaceDown");
    registerEditorContribution(InPlaceReplaceController.ID, InPlaceReplaceController, 4);
    registerEditorAction(InPlaceReplaceUp);
    registerEditorAction(InPlaceReplaceDown);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/browser/viewportSemanticTokens.js
var require_viewportSemanticTokens = __commonJS({
  "../../node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/browser/viewportSemanticTokens.js"(exports) {
    init_define_process();
    init_async();
    init_lifecycle();
    init_editorExtensions();
    init_getSemanticTokens();
    init_model();
    init_modelService();
    init_semanticTokensProviderStyling();
    init_configuration();
    init_themeService();
    init_languageFeatureDebounce();
    init_stopwatch();
    init_languageFeatures();
    var __decorate74 = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __param74 = exports && exports.__param || function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    var ViewportSemanticTokensContribution = /* @__PURE__ */ __name(class ViewportSemanticTokensContribution extends Disposable {
      constructor(editor2, _modelService, _themeService, _configurationService, languageFeatureDebounceService, languageFeaturesService) {
        super();
        this._modelService = _modelService;
        this._themeService = _themeService;
        this._configurationService = _configurationService;
        this._editor = editor2;
        this._provider = languageFeaturesService.documentRangeSemanticTokensProvider;
        this._debounceInformation = languageFeatureDebounceService.for(this._provider, "DocumentRangeSemanticTokens", { min: 100, max: 500 });
        this._tokenizeViewport = this._register(new RunOnceScheduler(() => this._tokenizeViewportNow(), 100));
        this._outstandingRequests = [];
        const scheduleTokenizeViewport = /* @__PURE__ */ __name(() => {
          if (this._editor.hasModel()) {
            this._tokenizeViewport.schedule(this._debounceInformation.get(this._editor.getModel()));
          }
        }, "scheduleTokenizeViewport");
        this._register(this._editor.onDidScrollChange(() => {
          scheduleTokenizeViewport();
        }));
        this._register(this._editor.onDidChangeModel(() => {
          this._cancelAll();
          scheduleTokenizeViewport();
        }));
        this._register(this._editor.onDidChangeModelContent((e) => {
          this._cancelAll();
          scheduleTokenizeViewport();
        }));
        this._register(this._provider.onDidChange(() => {
          this._cancelAll();
          scheduleTokenizeViewport();
        }));
        this._register(this._configurationService.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
            this._cancelAll();
            scheduleTokenizeViewport();
          }
        }));
        this._register(this._themeService.onDidColorThemeChange(() => {
          this._cancelAll();
          scheduleTokenizeViewport();
        }));
        scheduleTokenizeViewport();
      }
      _cancelAll() {
        for (const request of this._outstandingRequests) {
          request.cancel();
        }
        this._outstandingRequests = [];
      }
      _removeOutstandingRequest(req) {
        for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
          if (this._outstandingRequests[i] === req) {
            this._outstandingRequests.splice(i, 1);
            return;
          }
        }
      }
      _tokenizeViewportNow() {
        if (!this._editor.hasModel()) {
          return;
        }
        const model = this._editor.getModel();
        if (model.tokenization.hasCompleteSemanticTokens()) {
          return;
        }
        if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
          if (model.tokenization.hasSomeSemanticTokens()) {
            model.tokenization.setSemanticTokens(null, false);
          }
          return;
        }
        if (!hasDocumentRangeSemanticTokensProvider(this._provider, model)) {
          if (model.tokenization.hasSomeSemanticTokens()) {
            model.tokenization.setSemanticTokens(null, false);
          }
          return;
        }
        const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
        this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
      }
      _requestRange(model, range) {
        const requestVersionId = model.getVersionId();
        const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(this._provider, model, range, token)));
        const sw = new StopWatch(false);
        request.then((r) => {
          this._debounceInformation.update(model, sw.elapsed());
          if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) {
            return;
          }
          const { provider, tokens: result } = r;
          const styling = this._modelService.getSemanticTokensProviderStyling(provider);
          model.tokenization.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
        }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
        return request;
      }
    }, "ViewportSemanticTokensContribution");
    ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
    ViewportSemanticTokensContribution = __decorate74([
      __param74(1, IModelService),
      __param74(2, IThemeService),
      __param74(3, IConfigurationService),
      __param74(4, ILanguageFeatureDebounceService),
      __param74(5, ILanguageFeaturesService)
    ], ViewportSemanticTokensContribution);
    registerEditorContribution(ViewportSemanticTokensContribution.ID, ViewportSemanticTokensContribution, 1);
  }
});

// ../../node_modules/core-js/internals/global.js
var require_global = __commonJS({
  "../../node_modules/core-js/internals/global.js"(exports, module) {
    init_define_process();
    var check = /* @__PURE__ */ __name(function(it) {
      return it && it.Math == Math && it;
    }, "check");
    module.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof globalThis == "object" && globalThis) || function() {
      return this;
    }() || Function("return this")();
  }
});

// ../../node_modules/core-js/internals/fails.js
var require_fails = __commonJS({
  "../../node_modules/core-js/internals/fails.js"(exports, module) {
    init_define_process();
    module.exports = function(exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
  }
});

// ../../node_modules/core-js/internals/descriptors.js
var require_descriptors = __commonJS({
  "../../node_modules/core-js/internals/descriptors.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    module.exports = !fails(function() {
      return Object.defineProperty({}, 1, { get: function() {
        return 7;
      } })[1] != 7;
    });
  }
});

// ../../node_modules/core-js/internals/function-bind-native.js
var require_function_bind_native = __commonJS({
  "../../node_modules/core-js/internals/function-bind-native.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    module.exports = !fails(function() {
      var test = function() {
      }.bind();
      return typeof test != "function" || test.hasOwnProperty("prototype");
    });
  }
});

// ../../node_modules/core-js/internals/function-call.js
var require_function_call = __commonJS({
  "../../node_modules/core-js/internals/function-call.js"(exports, module) {
    init_define_process();
    var NATIVE_BIND = require_function_bind_native();
    var call = Function.prototype.call;
    module.exports = NATIVE_BIND ? call.bind(call) : function() {
      return call.apply(call, arguments);
    };
  }
});

// ../../node_modules/core-js/internals/object-property-is-enumerable.js
var require_object_property_is_enumerable = __commonJS({
  "../../node_modules/core-js/internals/object-property-is-enumerable.js"(exports) {
    "use strict";
    init_define_process();
    var $propertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
    exports.f = NASHORN_BUG ? /* @__PURE__ */ __name(function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    }, "propertyIsEnumerable") : $propertyIsEnumerable;
  }
});

// ../../node_modules/core-js/internals/create-property-descriptor.js
var require_create_property_descriptor = __commonJS({
  "../../node_modules/core-js/internals/create-property-descriptor.js"(exports, module) {
    init_define_process();
    module.exports = function(bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value
      };
    };
  }
});

// ../../node_modules/core-js/internals/function-uncurry-this.js
var require_function_uncurry_this = __commonJS({
  "../../node_modules/core-js/internals/function-uncurry-this.js"(exports, module) {
    init_define_process();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var call = FunctionPrototype.call;
    var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
    module.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
      return function() {
        return call.apply(fn, arguments);
      };
    };
  }
});

// ../../node_modules/core-js/internals/classof-raw.js
var require_classof_raw = __commonJS({
  "../../node_modules/core-js/internals/classof-raw.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var toString = uncurryThis({}.toString);
    var stringSlice = uncurryThis("".slice);
    module.exports = function(it) {
      return stringSlice(toString(it), 8, -1);
    };
  }
});

// ../../node_modules/core-js/internals/indexed-object.js
var require_indexed_object = __commonJS({
  "../../node_modules/core-js/internals/indexed-object.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var fails = require_fails();
    var classof = require_classof_raw();
    var $Object = Object;
    var split = uncurryThis("".split);
    module.exports = fails(function() {
      return !$Object("z").propertyIsEnumerable(0);
    }) ? function(it) {
      return classof(it) == "String" ? split(it, "") : $Object(it);
    } : $Object;
  }
});

// ../../node_modules/core-js/internals/is-null-or-undefined.js
var require_is_null_or_undefined = __commonJS({
  "../../node_modules/core-js/internals/is-null-or-undefined.js"(exports, module) {
    init_define_process();
    module.exports = function(it) {
      return it === null || it === void 0;
    };
  }
});

// ../../node_modules/core-js/internals/require-object-coercible.js
var require_require_object_coercible = __commonJS({
  "../../node_modules/core-js/internals/require-object-coercible.js"(exports, module) {
    init_define_process();
    var isNullOrUndefined = require_is_null_or_undefined();
    var $TypeError = TypeError;
    module.exports = function(it) {
      if (isNullOrUndefined(it))
        throw $TypeError("Can't call method on " + it);
      return it;
    };
  }
});

// ../../node_modules/core-js/internals/to-indexed-object.js
var require_to_indexed_object = __commonJS({
  "../../node_modules/core-js/internals/to-indexed-object.js"(exports, module) {
    init_define_process();
    var IndexedObject = require_indexed_object();
    var requireObjectCoercible = require_require_object_coercible();
    module.exports = function(it) {
      return IndexedObject(requireObjectCoercible(it));
    };
  }
});

// ../../node_modules/core-js/internals/document-all.js
var require_document_all = __commonJS({
  "../../node_modules/core-js/internals/document-all.js"(exports, module) {
    init_define_process();
    var documentAll = typeof document == "object" && document.all;
    var IS_HTMLDDA = typeof documentAll == "undefined" && documentAll !== void 0;
    module.exports = {
      all: documentAll,
      IS_HTMLDDA
    };
  }
});

// ../../node_modules/core-js/internals/is-callable.js
var require_is_callable = __commonJS({
  "../../node_modules/core-js/internals/is-callable.js"(exports, module) {
    init_define_process();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(argument) {
      return typeof argument == "function" || argument === documentAll;
    } : function(argument) {
      return typeof argument == "function";
    };
  }
});

// ../../node_modules/core-js/internals/is-object.js
var require_is_object = __commonJS({
  "../../node_modules/core-js/internals/is-object.js"(exports, module) {
    init_define_process();
    var isCallable = require_is_callable();
    var $documentAll = require_document_all();
    var documentAll = $documentAll.all;
    module.exports = $documentAll.IS_HTMLDDA ? function(it) {
      return typeof it == "object" ? it !== null : isCallable(it) || it === documentAll;
    } : function(it) {
      return typeof it == "object" ? it !== null : isCallable(it);
    };
  }
});

// ../../node_modules/core-js/internals/get-built-in.js
var require_get_built_in = __commonJS({
  "../../node_modules/core-js/internals/get-built-in.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var aFunction = /* @__PURE__ */ __name(function(argument) {
      return isCallable(argument) ? argument : void 0;
    }, "aFunction");
    module.exports = function(namespace, method) {
      return arguments.length < 2 ? aFunction(global2[namespace]) : global2[namespace] && global2[namespace][method];
    };
  }
});

// ../../node_modules/core-js/internals/object-is-prototype-of.js
var require_object_is_prototype_of = __commonJS({
  "../../node_modules/core-js/internals/object-is-prototype-of.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    module.exports = uncurryThis({}.isPrototypeOf);
  }
});

// ../../node_modules/core-js/internals/engine-user-agent.js
var require_engine_user_agent = __commonJS({
  "../../node_modules/core-js/internals/engine-user-agent.js"(exports, module) {
    init_define_process();
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("navigator", "userAgent") || "";
  }
});

// ../../node_modules/core-js/internals/engine-v8-version.js
var require_engine_v8_version = __commonJS({
  "../../node_modules/core-js/internals/engine-v8-version.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var userAgent = require_engine_user_agent();
    var process = global2.process;
    var Deno = global2.Deno;
    var versions = process && process.versions || Deno && Deno.version;
    var v8 = versions && versions.v8;
    var match;
    var version;
    if (v8) {
      match = v8.split(".");
      version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
    }
    if (!version && userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);
      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match)
          version = +match[1];
      }
    }
    module.exports = version;
  }
});

// ../../node_modules/core-js/internals/symbol-constructor-detection.js
var require_symbol_constructor_detection = __commonJS({
  "../../node_modules/core-js/internals/symbol-constructor-detection.js"(exports, module) {
    init_define_process();
    var V8_VERSION = require_engine_v8_version();
    var fails = require_fails();
    module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
      var symbol = Symbol();
      return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
    });
  }
});

// ../../node_modules/core-js/internals/use-symbol-as-uid.js
var require_use_symbol_as_uid = __commonJS({
  "../../node_modules/core-js/internals/use-symbol-as-uid.js"(exports, module) {
    init_define_process();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
  }
});

// ../../node_modules/core-js/internals/is-symbol.js
var require_is_symbol = __commonJS({
  "../../node_modules/core-js/internals/is-symbol.js"(exports, module) {
    init_define_process();
    var getBuiltIn = require_get_built_in();
    var isCallable = require_is_callable();
    var isPrototypeOf = require_object_is_prototype_of();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var $Object = Object;
    module.exports = USE_SYMBOL_AS_UID ? function(it) {
      return typeof it == "symbol";
    } : function(it) {
      var $Symbol = getBuiltIn("Symbol");
      return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
    };
  }
});

// ../../node_modules/core-js/internals/try-to-string.js
var require_try_to_string = __commonJS({
  "../../node_modules/core-js/internals/try-to-string.js"(exports, module) {
    init_define_process();
    var $String = String;
    module.exports = function(argument) {
      try {
        return $String(argument);
      } catch (error) {
        return "Object";
      }
    };
  }
});

// ../../node_modules/core-js/internals/a-callable.js
var require_a_callable = __commonJS({
  "../../node_modules/core-js/internals/a-callable.js"(exports, module) {
    init_define_process();
    var isCallable = require_is_callable();
    var tryToString = require_try_to_string();
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isCallable(argument))
        return argument;
      throw $TypeError(tryToString(argument) + " is not a function");
    };
  }
});

// ../../node_modules/core-js/internals/get-method.js
var require_get_method = __commonJS({
  "../../node_modules/core-js/internals/get-method.js"(exports, module) {
    init_define_process();
    var aCallable = require_a_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    module.exports = function(V, P) {
      var func = V[P];
      return isNullOrUndefined(func) ? void 0 : aCallable(func);
    };
  }
});

// ../../node_modules/core-js/internals/ordinary-to-primitive.js
var require_ordinary_to_primitive = __commonJS({
  "../../node_modules/core-js/internals/ordinary-to-primitive.js"(exports, module) {
    init_define_process();
    var call = require_function_call();
    var isCallable = require_is_callable();
    var isObject2 = require_is_object();
    var $TypeError = TypeError;
    module.exports = function(input, pref) {
      var fn, val;
      if (pref === "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
        return val;
      if (isCallable(fn = input.valueOf) && !isObject2(val = call(fn, input)))
        return val;
      if (pref !== "string" && isCallable(fn = input.toString) && !isObject2(val = call(fn, input)))
        return val;
      throw $TypeError("Can't convert object to primitive value");
    };
  }
});

// ../../node_modules/core-js/internals/is-pure.js
var require_is_pure = __commonJS({
  "../../node_modules/core-js/internals/is-pure.js"(exports, module) {
    init_define_process();
    module.exports = false;
  }
});

// ../../node_modules/core-js/internals/define-global-property.js
var require_define_global_property = __commonJS({
  "../../node_modules/core-js/internals/define-global-property.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var defineProperty = Object.defineProperty;
    module.exports = function(key, value) {
      try {
        defineProperty(global2, key, { value, configurable: true, writable: true });
      } catch (error) {
        global2[key] = value;
      }
      return value;
    };
  }
});

// ../../node_modules/core-js/internals/shared-store.js
var require_shared_store = __commonJS({
  "../../node_modules/core-js/internals/shared-store.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var defineGlobalProperty = require_define_global_property();
    var SHARED = "__core-js_shared__";
    var store = global2[SHARED] || defineGlobalProperty(SHARED, {});
    module.exports = store;
  }
});

// ../../node_modules/core-js/internals/shared.js
var require_shared = __commonJS({
  "../../node_modules/core-js/internals/shared.js"(exports, module) {
    init_define_process();
    var IS_PURE = require_is_pure();
    var store = require_shared_store();
    (module.exports = function(key, value) {
      return store[key] || (store[key] = value !== void 0 ? value : {});
    })("versions", []).push({
      version: "3.26.1",
      mode: IS_PURE ? "pure" : "global",
      copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",
      source: "https://github.com/zloirock/core-js"
    });
  }
});

// ../../node_modules/core-js/internals/to-object.js
var require_to_object = __commonJS({
  "../../node_modules/core-js/internals/to-object.js"(exports, module) {
    init_define_process();
    var requireObjectCoercible = require_require_object_coercible();
    var $Object = Object;
    module.exports = function(argument) {
      return $Object(requireObjectCoercible(argument));
    };
  }
});

// ../../node_modules/core-js/internals/has-own-property.js
var require_has_own_property = __commonJS({
  "../../node_modules/core-js/internals/has-own-property.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var hasOwnProperty = uncurryThis({}.hasOwnProperty);
    module.exports = Object.hasOwn || /* @__PURE__ */ __name(function hasOwn(it, key) {
      return hasOwnProperty(toObject(it), key);
    }, "hasOwn");
  }
});

// ../../node_modules/core-js/internals/uid.js
var require_uid = __commonJS({
  "../../node_modules/core-js/internals/uid.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var id = 0;
    var postfix = Math.random();
    var toString = uncurryThis(1 .toString);
    module.exports = function(key) {
      return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
    };
  }
});

// ../../node_modules/core-js/internals/well-known-symbol.js
var require_well_known_symbol = __commonJS({
  "../../node_modules/core-js/internals/well-known-symbol.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var shared = require_shared();
    var hasOwn = require_has_own_property();
    var uid = require_uid();
    var NATIVE_SYMBOL = require_symbol_constructor_detection();
    var USE_SYMBOL_AS_UID = require_use_symbol_as_uid();
    var WellKnownSymbolsStore = shared("wks");
    var Symbol2 = global2.Symbol;
    var symbolFor = Symbol2 && Symbol2["for"];
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
    module.exports = function(name) {
      if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
        var description = "Symbol." + name;
        if (NATIVE_SYMBOL && hasOwn(Symbol2, name)) {
          WellKnownSymbolsStore[name] = Symbol2[name];
        } else if (USE_SYMBOL_AS_UID && symbolFor) {
          WellKnownSymbolsStore[name] = symbolFor(description);
        } else {
          WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
        }
      }
      return WellKnownSymbolsStore[name];
    };
  }
});

// ../../node_modules/core-js/internals/to-primitive.js
var require_to_primitive = __commonJS({
  "../../node_modules/core-js/internals/to-primitive.js"(exports, module) {
    init_define_process();
    var call = require_function_call();
    var isObject2 = require_is_object();
    var isSymbol = require_is_symbol();
    var getMethod = require_get_method();
    var ordinaryToPrimitive = require_ordinary_to_primitive();
    var wellKnownSymbol = require_well_known_symbol();
    var $TypeError = TypeError;
    var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
    module.exports = function(input, pref) {
      if (!isObject2(input) || isSymbol(input))
        return input;
      var exoticToPrim = getMethod(input, TO_PRIMITIVE);
      var result;
      if (exoticToPrim) {
        if (pref === void 0)
          pref = "default";
        result = call(exoticToPrim, input, pref);
        if (!isObject2(result) || isSymbol(result))
          return result;
        throw $TypeError("Can't convert object to primitive value");
      }
      if (pref === void 0)
        pref = "number";
      return ordinaryToPrimitive(input, pref);
    };
  }
});

// ../../node_modules/core-js/internals/to-property-key.js
var require_to_property_key = __commonJS({
  "../../node_modules/core-js/internals/to-property-key.js"(exports, module) {
    init_define_process();
    var toPrimitive = require_to_primitive();
    var isSymbol = require_is_symbol();
    module.exports = function(argument) {
      var key = toPrimitive(argument, "string");
      return isSymbol(key) ? key : key + "";
    };
  }
});

// ../../node_modules/core-js/internals/document-create-element.js
var require_document_create_element = __commonJS({
  "../../node_modules/core-js/internals/document-create-element.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var isObject2 = require_is_object();
    var document2 = global2.document;
    var EXISTS = isObject2(document2) && isObject2(document2.createElement);
    module.exports = function(it) {
      return EXISTS ? document2.createElement(it) : {};
    };
  }
});

// ../../node_modules/core-js/internals/ie8-dom-define.js
var require_ie8_dom_define = __commonJS({
  "../../node_modules/core-js/internals/ie8-dom-define.js"(exports, module) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    var createElement = require_document_create_element();
    module.exports = !DESCRIPTORS && !fails(function() {
      return Object.defineProperty(createElement("div"), "a", {
        get: function() {
          return 7;
        }
      }).a != 7;
    });
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-descriptor.js
var require_object_get_own_property_descriptor = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-descriptor.js"(exports) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var call = require_function_call();
    var propertyIsEnumerableModule = require_object_property_is_enumerable();
    var createPropertyDescriptor = require_create_property_descriptor();
    var toIndexedObject = require_to_indexed_object();
    var toPropertyKey = require_to_property_key();
    var hasOwn = require_has_own_property();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : /* @__PURE__ */ __name(function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPropertyKey(P);
      if (IE8_DOM_DEFINE)
        try {
          return $getOwnPropertyDescriptor(O, P);
        } catch (error) {
        }
      if (hasOwn(O, P))
        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
    }, "getOwnPropertyDescriptor");
  }
});

// ../../node_modules/core-js/internals/v8-prototype-define-bug.js
var require_v8_prototype_define_bug = __commonJS({
  "../../node_modules/core-js/internals/v8-prototype-define-bug.js"(exports, module) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var fails = require_fails();
    module.exports = DESCRIPTORS && fails(function() {
      return Object.defineProperty(function() {
      }, "prototype", {
        value: 42,
        writable: false
      }).prototype != 42;
    });
  }
});

// ../../node_modules/core-js/internals/an-object.js
var require_an_object = __commonJS({
  "../../node_modules/core-js/internals/an-object.js"(exports, module) {
    init_define_process();
    var isObject2 = require_is_object();
    var $String = String;
    var $TypeError = TypeError;
    module.exports = function(argument) {
      if (isObject2(argument))
        return argument;
      throw $TypeError($String(argument) + " is not an object");
    };
  }
});

// ../../node_modules/core-js/internals/object-define-property.js
var require_object_define_property = __commonJS({
  "../../node_modules/core-js/internals/object-define-property.js"(exports) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var IE8_DOM_DEFINE = require_ie8_dom_define();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var anObject = require_an_object();
    var toPropertyKey = require_to_property_key();
    var $TypeError = TypeError;
    var $defineProperty = Object.defineProperty;
    var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ENUMERABLE = "enumerable";
    var CONFIGURABLE = "configurable";
    var WRITABLE = "writable";
    exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
        var current = $getOwnPropertyDescriptor(O, P);
        if (current && current[WRITABLE]) {
          O[P] = Attributes.value;
          Attributes = {
            configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
            enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
            writable: false
          };
        }
      }
      return $defineProperty(O, P, Attributes);
    }, "defineProperty") : $defineProperty : /* @__PURE__ */ __name(function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPropertyKey(P);
      anObject(Attributes);
      if (IE8_DOM_DEFINE)
        try {
          return $defineProperty(O, P, Attributes);
        } catch (error) {
        }
      if ("get" in Attributes || "set" in Attributes)
        throw $TypeError("Accessors not supported");
      if ("value" in Attributes)
        O[P] = Attributes.value;
      return O;
    }, "defineProperty");
  }
});

// ../../node_modules/core-js/internals/create-non-enumerable-property.js
var require_create_non_enumerable_property = __commonJS({
  "../../node_modules/core-js/internals/create-non-enumerable-property.js"(exports, module) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var definePropertyModule = require_object_define_property();
    var createPropertyDescriptor = require_create_property_descriptor();
    module.exports = DESCRIPTORS ? function(object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function(object, key, value) {
      object[key] = value;
      return object;
    };
  }
});

// ../../node_modules/core-js/internals/function-name.js
var require_function_name = __commonJS({
  "../../node_modules/core-js/internals/function-name.js"(exports, module) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var hasOwn = require_has_own_property();
    var FunctionPrototype = Function.prototype;
    var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
    var EXISTS = hasOwn(FunctionPrototype, "name");
    var PROPER = EXISTS && (/* @__PURE__ */ __name(function something() {
    }, "something")).name === "something";
    var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
    module.exports = {
      EXISTS,
      PROPER,
      CONFIGURABLE
    };
  }
});

// ../../node_modules/core-js/internals/inspect-source.js
var require_inspect_source = __commonJS({
  "../../node_modules/core-js/internals/inspect-source.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var isCallable = require_is_callable();
    var store = require_shared_store();
    var functionToString = uncurryThis(Function.toString);
    if (!isCallable(store.inspectSource)) {
      store.inspectSource = function(it) {
        return functionToString(it);
      };
    }
    module.exports = store.inspectSource;
  }
});

// ../../node_modules/core-js/internals/weak-map-basic-detection.js
var require_weak_map_basic_detection = __commonJS({
  "../../node_modules/core-js/internals/weak-map-basic-detection.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var isCallable = require_is_callable();
    var WeakMap2 = global2.WeakMap;
    module.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
  }
});

// ../../node_modules/core-js/internals/shared-key.js
var require_shared_key = __commonJS({
  "../../node_modules/core-js/internals/shared-key.js"(exports, module) {
    init_define_process();
    var shared = require_shared();
    var uid = require_uid();
    var keys = shared("keys");
    module.exports = function(key) {
      return keys[key] || (keys[key] = uid(key));
    };
  }
});

// ../../node_modules/core-js/internals/hidden-keys.js
var require_hidden_keys = __commonJS({
  "../../node_modules/core-js/internals/hidden-keys.js"(exports, module) {
    init_define_process();
    module.exports = {};
  }
});

// ../../node_modules/core-js/internals/internal-state.js
var require_internal_state = __commonJS({
  "../../node_modules/core-js/internals/internal-state.js"(exports, module) {
    init_define_process();
    var NATIVE_WEAK_MAP = require_weak_map_basic_detection();
    var global2 = require_global();
    var isObject2 = require_is_object();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var hasOwn = require_has_own_property();
    var shared = require_shared_store();
    var sharedKey = require_shared_key();
    var hiddenKeys = require_hidden_keys();
    var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
    var TypeError2 = global2.TypeError;
    var WeakMap2 = global2.WeakMap;
    var set;
    var get;
    var has;
    var enforce = /* @__PURE__ */ __name(function(it) {
      return has(it) ? get(it) : set(it, {});
    }, "enforce");
    var getterFor = /* @__PURE__ */ __name(function(TYPE) {
      return function(it) {
        var state;
        if (!isObject2(it) || (state = get(it)).type !== TYPE) {
          throw TypeError2("Incompatible receiver, " + TYPE + " required");
        }
        return state;
      };
    }, "getterFor");
    if (NATIVE_WEAK_MAP || shared.state) {
      store = shared.state || (shared.state = new WeakMap2());
      store.get = store.get;
      store.has = store.has;
      store.set = store.set;
      set = /* @__PURE__ */ __name(function(it, metadata) {
        if (store.has(it))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        store.set(it, metadata);
        return metadata;
      }, "set");
      get = /* @__PURE__ */ __name(function(it) {
        return store.get(it) || {};
      }, "get");
      has = /* @__PURE__ */ __name(function(it) {
        return store.has(it);
      }, "has");
    } else {
      STATE = sharedKey("state");
      hiddenKeys[STATE] = true;
      set = /* @__PURE__ */ __name(function(it, metadata) {
        if (hasOwn(it, STATE))
          throw TypeError2(OBJECT_ALREADY_INITIALIZED);
        metadata.facade = it;
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      }, "set");
      get = /* @__PURE__ */ __name(function(it) {
        return hasOwn(it, STATE) ? it[STATE] : {};
      }, "get");
      has = /* @__PURE__ */ __name(function(it) {
        return hasOwn(it, STATE);
      }, "has");
    }
    var store;
    var STATE;
    module.exports = {
      set,
      get,
      has,
      enforce,
      getterFor
    };
  }
});

// ../../node_modules/core-js/internals/make-built-in.js
var require_make_built_in = __commonJS({
  "../../node_modules/core-js/internals/make-built-in.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var hasOwn = require_has_own_property();
    var DESCRIPTORS = require_descriptors();
    var CONFIGURABLE_FUNCTION_NAME = require_function_name().CONFIGURABLE;
    var inspectSource = require_inspect_source();
    var InternalStateModule = require_internal_state();
    var enforceInternalState = InternalStateModule.enforce;
    var getInternalState = InternalStateModule.get;
    var defineProperty = Object.defineProperty;
    var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
      return defineProperty(function() {
      }, "length", { value: 8 }).length !== 8;
    });
    var TEMPLATE = String(String).split("String");
    var makeBuiltIn = module.exports = function(value, name, options) {
      if (String(name).slice(0, 7) === "Symbol(") {
        name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
      }
      if (options && options.getter)
        name = "get " + name;
      if (options && options.setter)
        name = "set " + name;
      if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
        if (DESCRIPTORS)
          defineProperty(value, "name", { value: name, configurable: true });
        else
          value.name = name;
      }
      if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
        defineProperty(value, "length", { value: options.arity });
      }
      try {
        if (options && hasOwn(options, "constructor") && options.constructor) {
          if (DESCRIPTORS)
            defineProperty(value, "prototype", { writable: false });
        } else if (value.prototype)
          value.prototype = void 0;
      } catch (error) {
      }
      var state = enforceInternalState(value);
      if (!hasOwn(state, "source")) {
        state.source = TEMPLATE.join(typeof name == "string" ? name : "");
      }
      return value;
    };
    Function.prototype.toString = makeBuiltIn(/* @__PURE__ */ __name(function toString() {
      return isCallable(this) && getInternalState(this).source || inspectSource(this);
    }, "toString"), "toString");
  }
});

// ../../node_modules/core-js/internals/define-built-in.js
var require_define_built_in = __commonJS({
  "../../node_modules/core-js/internals/define-built-in.js"(exports, module) {
    init_define_process();
    var isCallable = require_is_callable();
    var definePropertyModule = require_object_define_property();
    var makeBuiltIn = require_make_built_in();
    var defineGlobalProperty = require_define_global_property();
    module.exports = function(O, key, value, options) {
      if (!options)
        options = {};
      var simple = options.enumerable;
      var name = options.name !== void 0 ? options.name : key;
      if (isCallable(value))
        makeBuiltIn(value, name, options);
      if (options.global) {
        if (simple)
          O[key] = value;
        else
          defineGlobalProperty(key, value);
      } else {
        try {
          if (!options.unsafe)
            delete O[key];
          else if (O[key])
            simple = true;
        } catch (error) {
        }
        if (simple)
          O[key] = value;
        else
          definePropertyModule.f(O, key, {
            value,
            enumerable: false,
            configurable: !options.nonConfigurable,
            writable: !options.nonWritable
          });
      }
      return O;
    };
  }
});

// ../../node_modules/core-js/internals/math-trunc.js
var require_math_trunc = __commonJS({
  "../../node_modules/core-js/internals/math-trunc.js"(exports, module) {
    init_define_process();
    var ceil = Math.ceil;
    var floor = Math.floor;
    module.exports = Math.trunc || /* @__PURE__ */ __name(function trunc(x) {
      var n = +x;
      return (n > 0 ? floor : ceil)(n);
    }, "trunc");
  }
});

// ../../node_modules/core-js/internals/to-integer-or-infinity.js
var require_to_integer_or_infinity = __commonJS({
  "../../node_modules/core-js/internals/to-integer-or-infinity.js"(exports, module) {
    init_define_process();
    var trunc = require_math_trunc();
    module.exports = function(argument) {
      var number = +argument;
      return number !== number || number === 0 ? 0 : trunc(number);
    };
  }
});

// ../../node_modules/core-js/internals/to-absolute-index.js
var require_to_absolute_index = __commonJS({
  "../../node_modules/core-js/internals/to-absolute-index.js"(exports, module) {
    init_define_process();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var max = Math.max;
    var min = Math.min;
    module.exports = function(index, length) {
      var integer = toIntegerOrInfinity(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
  }
});

// ../../node_modules/core-js/internals/to-length.js
var require_to_length = __commonJS({
  "../../node_modules/core-js/internals/to-length.js"(exports, module) {
    init_define_process();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var min = Math.min;
    module.exports = function(argument) {
      return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
    };
  }
});

// ../../node_modules/core-js/internals/length-of-array-like.js
var require_length_of_array_like = __commonJS({
  "../../node_modules/core-js/internals/length-of-array-like.js"(exports, module) {
    init_define_process();
    var toLength = require_to_length();
    module.exports = function(obj) {
      return toLength(obj.length);
    };
  }
});

// ../../node_modules/core-js/internals/array-includes.js
var require_array_includes = __commonJS({
  "../../node_modules/core-js/internals/array-includes.js"(exports, module) {
    init_define_process();
    var toIndexedObject = require_to_indexed_object();
    var toAbsoluteIndex = require_to_absolute_index();
    var lengthOfArrayLike = require_length_of_array_like();
    var createMethod = /* @__PURE__ */ __name(function(IS_INCLUDES) {
      return function($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = lengthOfArrayLike(O);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        if (IS_INCLUDES && el != el)
          while (length > index) {
            value = O[index++];
            if (value != value)
              return true;
          }
        else
          for (; length > index; index++) {
            if ((IS_INCLUDES || index in O) && O[index] === el)
              return IS_INCLUDES || index || 0;
          }
        return !IS_INCLUDES && -1;
      };
    }, "createMethod");
    module.exports = {
      includes: createMethod(true),
      indexOf: createMethod(false)
    };
  }
});

// ../../node_modules/core-js/internals/object-keys-internal.js
var require_object_keys_internal = __commonJS({
  "../../node_modules/core-js/internals/object-keys-internal.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var hasOwn = require_has_own_property();
    var toIndexedObject = require_to_indexed_object();
    var indexOf = require_array_includes().indexOf;
    var hiddenKeys = require_hidden_keys();
    var push = uncurryThis([].push);
    module.exports = function(object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;
      for (key in O)
        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
      while (names.length > i)
        if (hasOwn(O, key = names[i++])) {
          ~indexOf(result, key) || push(result, key);
        }
      return result;
    };
  }
});

// ../../node_modules/core-js/internals/enum-bug-keys.js
var require_enum_bug_keys = __commonJS({
  "../../node_modules/core-js/internals/enum-bug-keys.js"(exports, module) {
    init_define_process();
    module.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ];
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-names.js
var require_object_get_own_property_names = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-names.js"(exports) {
    init_define_process();
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = enumBugKeys.concat("length", "prototype");
    exports.f = Object.getOwnPropertyNames || /* @__PURE__ */ __name(function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    }, "getOwnPropertyNames");
  }
});

// ../../node_modules/core-js/internals/object-get-own-property-symbols.js
var require_object_get_own_property_symbols = __commonJS({
  "../../node_modules/core-js/internals/object-get-own-property-symbols.js"(exports) {
    init_define_process();
    exports.f = Object.getOwnPropertySymbols;
  }
});

// ../../node_modules/core-js/internals/own-keys.js
var require_own_keys = __commonJS({
  "../../node_modules/core-js/internals/own-keys.js"(exports, module) {
    init_define_process();
    var getBuiltIn = require_get_built_in();
    var uncurryThis = require_function_uncurry_this();
    var getOwnPropertyNamesModule = require_object_get_own_property_names();
    var getOwnPropertySymbolsModule = require_object_get_own_property_symbols();
    var anObject = require_an_object();
    var concat = uncurryThis([].concat);
    module.exports = getBuiltIn("Reflect", "ownKeys") || /* @__PURE__ */ __name(function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
    }, "ownKeys");
  }
});

// ../../node_modules/core-js/internals/copy-constructor-properties.js
var require_copy_constructor_properties = __commonJS({
  "../../node_modules/core-js/internals/copy-constructor-properties.js"(exports, module) {
    init_define_process();
    var hasOwn = require_has_own_property();
    var ownKeys = require_own_keys();
    var getOwnPropertyDescriptorModule = require_object_get_own_property_descriptor();
    var definePropertyModule = require_object_define_property();
    module.exports = function(target, source, exceptions) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
          defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      }
    };
  }
});

// ../../node_modules/core-js/internals/is-forced.js
var require_is_forced = __commonJS({
  "../../node_modules/core-js/internals/is-forced.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    var isCallable = require_is_callable();
    var replacement = /#|\.prototype\./;
    var isForced = /* @__PURE__ */ __name(function(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
    }, "isForced");
    var normalize = isForced.normalize = function(string) {
      return String(string).replace(replacement, ".").toLowerCase();
    };
    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = "N";
    var POLYFILL = isForced.POLYFILL = "P";
    module.exports = isForced;
  }
});

// ../../node_modules/core-js/internals/export.js
var require_export = __commonJS({
  "../../node_modules/core-js/internals/export.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var getOwnPropertyDescriptor = require_object_get_own_property_descriptor().f;
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var defineBuiltIn = require_define_built_in();
    var defineGlobalProperty = require_define_global_property();
    var copyConstructorProperties = require_copy_constructor_properties();
    var isForced = require_is_forced();
    module.exports = function(options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;
      if (GLOBAL) {
        target = global2;
      } else if (STATIC) {
        target = global2[TARGET] || defineGlobalProperty(TARGET, {});
      } else {
        target = (global2[TARGET] || {}).prototype;
      }
      if (target)
        for (key in source) {
          sourceProperty = source[key];
          if (options.dontCallGetSet) {
            descriptor = getOwnPropertyDescriptor(target, key);
            targetProperty = descriptor && descriptor.value;
          } else
            targetProperty = target[key];
          FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
          if (!FORCED && targetProperty !== void 0) {
            if (typeof sourceProperty == typeof targetProperty)
              continue;
            copyConstructorProperties(sourceProperty, targetProperty);
          }
          if (options.sham || targetProperty && targetProperty.sham) {
            createNonEnumerableProperty(sourceProperty, "sham", true);
          }
          defineBuiltIn(target, key, sourceProperty, options);
        }
    };
  }
});

// ../../node_modules/core-js/internals/to-string-tag-support.js
var require_to_string_tag_support = __commonJS({
  "../../node_modules/core-js/internals/to-string-tag-support.js"(exports, module) {
    init_define_process();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var test = {};
    test[TO_STRING_TAG] = "z";
    module.exports = String(test) === "[object z]";
  }
});

// ../../node_modules/core-js/internals/classof.js
var require_classof = __commonJS({
  "../../node_modules/core-js/internals/classof.js"(exports, module) {
    init_define_process();
    var TO_STRING_TAG_SUPPORT = require_to_string_tag_support();
    var isCallable = require_is_callable();
    var classofRaw = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var TO_STRING_TAG = wellKnownSymbol("toStringTag");
    var $Object = Object;
    var CORRECT_ARGUMENTS = classofRaw(function() {
      return arguments;
    }()) == "Arguments";
    var tryGet = /* @__PURE__ */ __name(function(it, key) {
      try {
        return it[key];
      } catch (error) {
      }
    }, "tryGet");
    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
      var O, tag, result;
      return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable(O.callee) ? "Arguments" : result;
    };
  }
});

// ../../node_modules/core-js/internals/to-string.js
var require_to_string = __commonJS({
  "../../node_modules/core-js/internals/to-string.js"(exports, module) {
    init_define_process();
    var classof = require_classof();
    var $String = String;
    module.exports = function(argument) {
      if (classof(argument) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return $String(argument);
    };
  }
});

// ../../node_modules/core-js/internals/regexp-flags.js
var require_regexp_flags = __commonJS({
  "../../node_modules/core-js/internals/regexp-flags.js"(exports, module) {
    "use strict";
    init_define_process();
    var anObject = require_an_object();
    module.exports = function() {
      var that = anObject(this);
      var result = "";
      if (that.hasIndices)
        result += "d";
      if (that.global)
        result += "g";
      if (that.ignoreCase)
        result += "i";
      if (that.multiline)
        result += "m";
      if (that.dotAll)
        result += "s";
      if (that.unicode)
        result += "u";
      if (that.unicodeSets)
        result += "v";
      if (that.sticky)
        result += "y";
      return result;
    };
  }
});

// ../../node_modules/core-js/internals/regexp-sticky-helpers.js
var require_regexp_sticky_helpers = __commonJS({
  "../../node_modules/core-js/internals/regexp-sticky-helpers.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    var UNSUPPORTED_Y = fails(function() {
      var re = $RegExp("a", "y");
      re.lastIndex = 2;
      return re.exec("abcd") != null;
    });
    var MISSED_STICKY = UNSUPPORTED_Y || fails(function() {
      return !$RegExp("a", "y").sticky;
    });
    var BROKEN_CARET = UNSUPPORTED_Y || fails(function() {
      var re = $RegExp("^r", "gy");
      re.lastIndex = 2;
      return re.exec("str") != null;
    });
    module.exports = {
      BROKEN_CARET,
      MISSED_STICKY,
      UNSUPPORTED_Y
    };
  }
});

// ../../node_modules/core-js/internals/object-keys.js
var require_object_keys = __commonJS({
  "../../node_modules/core-js/internals/object-keys.js"(exports, module) {
    init_define_process();
    var internalObjectKeys = require_object_keys_internal();
    var enumBugKeys = require_enum_bug_keys();
    module.exports = Object.keys || /* @__PURE__ */ __name(function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    }, "keys");
  }
});

// ../../node_modules/core-js/internals/object-define-properties.js
var require_object_define_properties = __commonJS({
  "../../node_modules/core-js/internals/object-define-properties.js"(exports) {
    init_define_process();
    var DESCRIPTORS = require_descriptors();
    var V8_PROTOTYPE_DEFINE_BUG = require_v8_prototype_define_bug();
    var definePropertyModule = require_object_define_property();
    var anObject = require_an_object();
    var toIndexedObject = require_to_indexed_object();
    var objectKeys = require_object_keys();
    exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : /* @__PURE__ */ __name(function defineProperties(O, Properties) {
      anObject(O);
      var props = toIndexedObject(Properties);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;
      while (length > index)
        definePropertyModule.f(O, key = keys[index++], props[key]);
      return O;
    }, "defineProperties");
  }
});

// ../../node_modules/core-js/internals/html.js
var require_html = __commonJS({
  "../../node_modules/core-js/internals/html.js"(exports, module) {
    init_define_process();
    var getBuiltIn = require_get_built_in();
    module.exports = getBuiltIn("document", "documentElement");
  }
});

// ../../node_modules/core-js/internals/object-create.js
var require_object_create = __commonJS({
  "../../node_modules/core-js/internals/object-create.js"(exports, module) {
    init_define_process();
    var anObject = require_an_object();
    var definePropertiesModule = require_object_define_properties();
    var enumBugKeys = require_enum_bug_keys();
    var hiddenKeys = require_hidden_keys();
    var html = require_html();
    var documentCreateElement = require_document_create_element();
    var sharedKey = require_shared_key();
    var GT = ">";
    var LT = "<";
    var PROTOTYPE = "prototype";
    var SCRIPT = "script";
    var IE_PROTO = sharedKey("IE_PROTO");
    var EmptyConstructor = /* @__PURE__ */ __name(function() {
    }, "EmptyConstructor");
    var scriptTag = /* @__PURE__ */ __name(function(content) {
      return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
    }, "scriptTag");
    var NullProtoObjectViaActiveX = /* @__PURE__ */ __name(function(activeXDocument2) {
      activeXDocument2.write(scriptTag(""));
      activeXDocument2.close();
      var temp = activeXDocument2.parentWindow.Object;
      activeXDocument2 = null;
      return temp;
    }, "NullProtoObjectViaActiveX");
    var NullProtoObjectViaIFrame = /* @__PURE__ */ __name(function() {
      var iframe = documentCreateElement("iframe");
      var JS = "java" + SCRIPT + ":";
      var iframeDocument;
      iframe.style.display = "none";
      html.appendChild(iframe);
      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag("document.F=Object"));
      iframeDocument.close();
      return iframeDocument.F;
    }, "NullProtoObjectViaIFrame");
    var activeXDocument;
    var NullProtoObject = /* @__PURE__ */ __name(function() {
      try {
        activeXDocument = new ActiveXObject("htmlfile");
      } catch (error) {
      }
      NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
      var length = enumBugKeys.length;
      while (length--)
        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
      return NullProtoObject();
    }, "NullProtoObject");
    hiddenKeys[IE_PROTO] = true;
    module.exports = Object.create || /* @__PURE__ */ __name(function create2(O, Properties) {
      var result;
      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null;
        result[IE_PROTO] = O;
      } else
        result = NullProtoObject();
      return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
    }, "create");
  }
});

// ../../node_modules/core-js/internals/regexp-unsupported-dot-all.js
var require_regexp_unsupported_dot_all = __commonJS({
  "../../node_modules/core-js/internals/regexp-unsupported-dot-all.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp(".", "s");
      return !(re.dotAll && re.exec("\n") && re.flags === "s");
    });
  }
});

// ../../node_modules/core-js/internals/regexp-unsupported-ncg.js
var require_regexp_unsupported_ncg = __commonJS({
  "../../node_modules/core-js/internals/regexp-unsupported-ncg.js"(exports, module) {
    init_define_process();
    var fails = require_fails();
    var global2 = require_global();
    var $RegExp = global2.RegExp;
    module.exports = fails(function() {
      var re = $RegExp("(?<a>b)", "g");
      return re.exec("b").groups.a !== "b" || "b".replace(re, "$<a>c") !== "bc";
    });
  }
});

// ../../node_modules/core-js/internals/regexp-exec.js
var require_regexp_exec = __commonJS({
  "../../node_modules/core-js/internals/regexp-exec.js"(exports, module) {
    "use strict";
    init_define_process();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var toString = require_to_string();
    var regexpFlags = require_regexp_flags();
    var stickyHelpers = require_regexp_sticky_helpers();
    var shared = require_shared();
    var create2 = require_object_create();
    var getInternalState = require_internal_state().get;
    var UNSUPPORTED_DOT_ALL = require_regexp_unsupported_dot_all();
    var UNSUPPORTED_NCG = require_regexp_unsupported_ncg();
    var nativeReplace = shared("native-string-replace", String.prototype.replace);
    var nativeExec = RegExp.prototype.exec;
    var patchedExec = nativeExec;
    var charAt = uncurryThis("".charAt);
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var UPDATES_LAST_INDEX_WRONG = function() {
      var re1 = /a/;
      var re2 = /b*/g;
      call(nativeExec, re1, "a");
      call(nativeExec, re2, "a");
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();
    var UNSUPPORTED_Y = stickyHelpers.BROKEN_CARET;
    var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;
    if (PATCH) {
      patchedExec = /* @__PURE__ */ __name(function exec(string) {
        var re = this;
        var state = getInternalState(re);
        var str = toString(string);
        var raw = state.raw;
        var result, reCopy, lastIndex, match, i, object, group;
        if (raw) {
          raw.lastIndex = re.lastIndex;
          result = call(patchedExec, raw, str);
          re.lastIndex = raw.lastIndex;
          return result;
        }
        var groups = state.groups;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = call(regexpFlags, re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;
        if (sticky) {
          flags = replace(flags, "y", "");
          if (indexOf(flags, "g") === -1) {
            flags += "g";
          }
          strCopy = stringSlice(str, re.lastIndex);
          if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt(str, re.lastIndex - 1) !== "\n")) {
            source = "(?: " + source + ")";
            strCopy = " " + strCopy;
            charsAdded++;
          }
          reCopy = new RegExp("^(?:" + source + ")", flags);
        }
        if (NPCG_INCLUDED) {
          reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
        }
        if (UPDATES_LAST_INDEX_WRONG)
          lastIndex = re.lastIndex;
        match = call(nativeExec, sticky ? reCopy : re, strCopy);
        if (sticky) {
          if (match) {
            match.input = stringSlice(match.input, charsAdded);
            match[0] = stringSlice(match[0], charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else
            re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }
        if (NPCG_INCLUDED && match && match.length > 1) {
          call(nativeReplace, match[0], reCopy, function() {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === void 0)
                match[i] = void 0;
            }
          });
        }
        if (match && groups) {
          match.groups = object = create2(null);
          for (i = 0; i < groups.length; i++) {
            group = groups[i];
            object[group[0]] = match[group[1]];
          }
        }
        return match;
      }, "exec");
    }
    module.exports = patchedExec;
  }
});

// ../../node_modules/core-js/modules/es.regexp.exec.js
var require_es_regexp_exec = __commonJS({
  "../../node_modules/core-js/modules/es.regexp.exec.js"() {
    "use strict";
    init_define_process();
    var $9 = require_export();
    var exec = require_regexp_exec();
    $9({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
      exec
    });
  }
});

// ../../node_modules/core-js/internals/function-apply.js
var require_function_apply = __commonJS({
  "../../node_modules/core-js/internals/function-apply.js"(exports, module) {
    init_define_process();
    var NATIVE_BIND = require_function_bind_native();
    var FunctionPrototype = Function.prototype;
    var apply = FunctionPrototype.apply;
    var call = FunctionPrototype.call;
    module.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
      return call.apply(apply, arguments);
    });
  }
});

// ../../node_modules/core-js/internals/function-uncurry-this-clause.js
var require_function_uncurry_this_clause = __commonJS({
  "../../node_modules/core-js/internals/function-uncurry-this-clause.js"(exports, module) {
    init_define_process();
    var classofRaw = require_classof_raw();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(fn) {
      if (classofRaw(fn) === "Function")
        return uncurryThis(fn);
    };
  }
});

// ../../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js
var require_fix_regexp_well_known_symbol_logic = __commonJS({
  "../../node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js"(exports, module) {
    "use strict";
    init_define_process();
    require_es_regexp_exec();
    var uncurryThis = require_function_uncurry_this_clause();
    var defineBuiltIn = require_define_built_in();
    var regexpExec = require_regexp_exec();
    var fails = require_fails();
    var wellKnownSymbol = require_well_known_symbol();
    var createNonEnumerableProperty = require_create_non_enumerable_property();
    var SPECIES = wellKnownSymbol("species");
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(KEY, exec, FORCED, SHAM) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function() {
        var O = {};
        O[SYMBOL] = function() {
          return 7;
        };
        return ""[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
        var execCalled = false;
        var re = /a/;
        if (KEY === "split") {
          re = {};
          re.constructor = {};
          re.constructor[SPECIES] = function() {
            return re;
          };
          re.flags = "";
          re[SYMBOL] = /./[SYMBOL];
        }
        re.exec = function() {
          execCalled = true;
          return null;
        };
        re[SYMBOL]("");
        return !execCalled;
      });
      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || FORCED) {
        var uncurriedNativeRegExpMethod = uncurryThis(/./[SYMBOL]);
        var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
          var uncurriedNativeMethod = uncurryThis(nativeMethod);
          var $exec = regexp.exec;
          if ($exec === regexpExec || $exec === RegExpPrototype.exec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };
            }
            return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };
          }
          return { done: false };
        });
        defineBuiltIn(String.prototype, KEY, methods[0]);
        defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);
      }
      if (SHAM)
        createNonEnumerableProperty(RegExpPrototype[SYMBOL], "sham", true);
    };
  }
});

// ../../node_modules/core-js/internals/string-multibyte.js
var require_string_multibyte = __commonJS({
  "../../node_modules/core-js/internals/string-multibyte.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var charAt = uncurryThis("".charAt);
    var charCodeAt = uncurryThis("".charCodeAt);
    var stringSlice = uncurryThis("".slice);
    var createMethod = /* @__PURE__ */ __name(function(CONVERT_TO_STRING) {
      return function($this, pos) {
        var S = toString(requireObjectCoercible($this));
        var position = toIntegerOrInfinity(pos);
        var size2 = S.length;
        var first2, second;
        if (position < 0 || position >= size2)
          return CONVERT_TO_STRING ? "" : void 0;
        first2 = charCodeAt(S, position);
        return first2 < 55296 || first2 > 56319 || position + 1 === size2 || (second = charCodeAt(S, position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? charAt(S, position) : first2 : CONVERT_TO_STRING ? stringSlice(S, position, position + 2) : (first2 - 55296 << 10) + (second - 56320) + 65536;
      };
    }, "createMethod");
    module.exports = {
      codeAt: createMethod(false),
      charAt: createMethod(true)
    };
  }
});

// ../../node_modules/core-js/internals/advance-string-index.js
var require_advance_string_index = __commonJS({
  "../../node_modules/core-js/internals/advance-string-index.js"(exports, module) {
    "use strict";
    init_define_process();
    var charAt = require_string_multibyte().charAt;
    module.exports = function(S, index, unicode) {
      return index + (unicode ? charAt(S, index).length : 1);
    };
  }
});

// ../../node_modules/core-js/internals/get-substitution.js
var require_get_substitution = __commonJS({
  "../../node_modules/core-js/internals/get-substitution.js"(exports, module) {
    init_define_process();
    var uncurryThis = require_function_uncurry_this();
    var toObject = require_to_object();
    var floor = Math.floor;
    var charAt = uncurryThis("".charAt);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
    module.exports = function(matched, str, position, captures, namedCaptures, replacement) {
      var tailPos = position + matched.length;
      var m = captures.length;
      var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
      if (namedCaptures !== void 0) {
        namedCaptures = toObject(namedCaptures);
        symbols = SUBSTITUTION_SYMBOLS;
      }
      return replace(replacement, symbols, function(match, ch) {
        var capture;
        switch (charAt(ch, 0)) {
          case "$":
            return "$";
          case "&":
            return matched;
          case "`":
            return stringSlice(str, 0, position);
          case "'":
            return stringSlice(str, tailPos);
          case "<":
            capture = namedCaptures[stringSlice(ch, 1, -1)];
            break;
          default:
            var n = +ch;
            if (n === 0)
              return match;
            if (n > m) {
              var f = floor(n / 10);
              if (f === 0)
                return match;
              if (f <= m)
                return captures[f - 1] === void 0 ? charAt(ch, 1) : captures[f - 1] + charAt(ch, 1);
              return match;
            }
            capture = captures[n - 1];
        }
        return capture === void 0 ? "" : capture;
      });
    };
  }
});

// ../../node_modules/core-js/internals/regexp-exec-abstract.js
var require_regexp_exec_abstract = __commonJS({
  "../../node_modules/core-js/internals/regexp-exec-abstract.js"(exports, module) {
    init_define_process();
    var call = require_function_call();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var classof = require_classof_raw();
    var regexpExec = require_regexp_exec();
    var $TypeError = TypeError;
    module.exports = function(R, S) {
      var exec = R.exec;
      if (isCallable(exec)) {
        var result = call(exec, R, S);
        if (result !== null)
          anObject(result);
        return result;
      }
      if (classof(R) === "RegExp")
        return call(regexpExec, R, S);
      throw $TypeError("RegExp#exec called on incompatible receiver");
    };
  }
});

// ../../node_modules/core-js/modules/es.string.replace.js
var require_es_string_replace = __commonJS({
  "../../node_modules/core-js/modules/es.string.replace.js"() {
    "use strict";
    init_define_process();
    var apply = require_function_apply();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var fixRegExpWellKnownSymbolLogic = require_fix_regexp_well_known_symbol_logic();
    var fails = require_fails();
    var anObject = require_an_object();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var toIntegerOrInfinity = require_to_integer_or_infinity();
    var toLength = require_to_length();
    var toString = require_to_string();
    var requireObjectCoercible = require_require_object_coercible();
    var advanceStringIndex = require_advance_string_index();
    var getMethod = require_get_method();
    var getSubstitution = require_get_substitution();
    var regExpExec = require_regexp_exec_abstract();
    var wellKnownSymbol = require_well_known_symbol();
    var REPLACE = wellKnownSymbol("replace");
    var max = Math.max;
    var min = Math.min;
    var concat = uncurryThis([].concat);
    var push = uncurryThis([].push);
    var stringIndexOf = uncurryThis("".indexOf);
    var stringSlice = uncurryThis("".slice);
    var maybeToString = /* @__PURE__ */ __name(function(it) {
      return it === void 0 ? it : String(it);
    }, "maybeToString");
    var REPLACE_KEEPS_$0 = function() {
      return "a".replace(/./, "$0") === "$0";
    }();
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
      if (/./[REPLACE]) {
        return /./[REPLACE]("a", "$0") === "";
      }
      return false;
    }();
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
      var re = /./;
      re.exec = function() {
        var result = [];
        result.groups = { a: "7" };
        return result;
      };
      return "".replace(re, "$<a>") !== "7";
    });
    fixRegExpWellKnownSymbolLogic("replace", function(_, nativeReplace, maybeCallNative) {
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
      return [
        /* @__PURE__ */ __name(function replace(searchValue, replaceValue) {
          var O = requireObjectCoercible(this);
          var replacer = isNullOrUndefined(searchValue) ? void 0 : getMethod(searchValue, REPLACE);
          return replacer ? call(replacer, searchValue, O, replaceValue) : call(nativeReplace, toString(O), searchValue, replaceValue);
        }, "replace"),
        function(string, replaceValue) {
          var rx = anObject(this);
          var S = toString(string);
          if (typeof replaceValue == "string" && stringIndexOf(replaceValue, UNSAFE_SUBSTITUTE) === -1 && stringIndexOf(replaceValue, "$<") === -1) {
            var res = maybeCallNative(nativeReplace, rx, S, replaceValue);
            if (res.done)
              return res.value;
          }
          var functionalReplace = isCallable(replaceValue);
          if (!functionalReplace)
            replaceValue = toString(replaceValue);
          var global2 = rx.global;
          if (global2) {
            var fullUnicode = rx.unicode;
            rx.lastIndex = 0;
          }
          var results = [];
          while (true) {
            var result = regExpExec(rx, S);
            if (result === null)
              break;
            push(results, result);
            if (!global2)
              break;
            var matchStr = toString(result[0]);
            if (matchStr === "")
              rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          }
          var accumulatedResult = "";
          var nextSourcePosition = 0;
          for (var i = 0; i < results.length; i++) {
            result = results[i];
            var matched = toString(result[0]);
            var position = max(min(toIntegerOrInfinity(result.index), S.length), 0);
            var captures = [];
            for (var j = 1; j < result.length; j++)
              push(captures, maybeToString(result[j]));
            var namedCaptures = result.groups;
            if (functionalReplace) {
              var replacerArgs = concat([matched], captures, position, S);
              if (namedCaptures !== void 0)
                push(replacerArgs, namedCaptures);
              var replacement = toString(apply(replaceValue, void 0, replacerArgs));
            } else {
              replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
            }
            if (position >= nextSourcePosition) {
              accumulatedResult += stringSlice(S, nextSourcePosition, position) + replacement;
              nextSourcePosition = position + matched.length;
            }
          }
          return accumulatedResult + stringSlice(S, nextSourcePosition);
        }
      ];
    }, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);
  }
});

// ../../node_modules/core-js/internals/is-regexp.js
var require_is_regexp = __commonJS({
  "../../node_modules/core-js/internals/is-regexp.js"(exports, module) {
    init_define_process();
    var isObject2 = require_is_object();
    var classof = require_classof_raw();
    var wellKnownSymbol = require_well_known_symbol();
    var MATCH = wellKnownSymbol("match");
    module.exports = function(it) {
      var isRegExp;
      return isObject2(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
    };
  }
});

// ../../node_modules/core-js/internals/regexp-get-flags.js
var require_regexp_get_flags = __commonJS({
  "../../node_modules/core-js/internals/regexp-get-flags.js"(exports, module) {
    init_define_process();
    var call = require_function_call();
    var hasOwn = require_has_own_property();
    var isPrototypeOf = require_object_is_prototype_of();
    var regExpFlags = require_regexp_flags();
    var RegExpPrototype = RegExp.prototype;
    module.exports = function(R) {
      var flags = R.flags;
      return flags === void 0 && !("flags" in RegExpPrototype) && !hasOwn(R, "flags") && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;
    };
  }
});

// ../../node_modules/core-js/modules/es.string.replace-all.js
var require_es_string_replace_all = __commonJS({
  "../../node_modules/core-js/modules/es.string.replace-all.js"() {
    "use strict";
    init_define_process();
    var $9 = require_export();
    var call = require_function_call();
    var uncurryThis = require_function_uncurry_this();
    var requireObjectCoercible = require_require_object_coercible();
    var isCallable = require_is_callable();
    var isNullOrUndefined = require_is_null_or_undefined();
    var isRegExp = require_is_regexp();
    var toString = require_to_string();
    var getMethod = require_get_method();
    var getRegExpFlags = require_regexp_get_flags();
    var getSubstitution = require_get_substitution();
    var wellKnownSymbol = require_well_known_symbol();
    var IS_PURE = require_is_pure();
    var REPLACE = wellKnownSymbol("replace");
    var $TypeError = TypeError;
    var indexOf = uncurryThis("".indexOf);
    var replace = uncurryThis("".replace);
    var stringSlice = uncurryThis("".slice);
    var max = Math.max;
    var stringIndexOf = /* @__PURE__ */ __name(function(string, searchValue, fromIndex) {
      if (fromIndex > string.length)
        return -1;
      if (searchValue === "")
        return fromIndex;
      return indexOf(string, searchValue, fromIndex);
    }, "stringIndexOf");
    $9({ target: "String", proto: true }, {
      replaceAll: /* @__PURE__ */ __name(function replaceAll2(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
        var position = 0;
        var endOfLastMatch = 0;
        var result = "";
        if (!isNullOrUndefined(searchValue)) {
          IS_REG_EXP = isRegExp(searchValue);
          if (IS_REG_EXP) {
            flags = toString(requireObjectCoercible(getRegExpFlags(searchValue)));
            if (!~indexOf(flags, "g"))
              throw $TypeError("`.replaceAll` does not allow non-global regexes");
          }
          replacer = getMethod(searchValue, REPLACE);
          if (replacer) {
            return call(replacer, searchValue, O, replaceValue);
          } else if (IS_PURE && IS_REG_EXP) {
            return replace(toString(O), searchValue, replaceValue);
          }
        }
        string = toString(O);
        searchString = toString(searchValue);
        functionalReplace = isCallable(replaceValue);
        if (!functionalReplace)
          replaceValue = toString(replaceValue);
        searchLength = searchString.length;
        advanceBy = max(1, searchLength);
        position = stringIndexOf(string, searchString, 0);
        while (position !== -1) {
          replacement = functionalReplace ? toString(replaceValue(searchString, position, string)) : getSubstitution(searchString, string, position, [], void 0, replaceValue);
          result += stringSlice(string, endOfLastMatch, position) + replacement;
          endOfLastMatch = position + searchLength;
          position = stringIndexOf(string, searchString, position + advanceBy);
        }
        if (endOfLastMatch < string.length) {
          result += stringSlice(string, endOfLastMatch);
        }
        return result;
      }, "replaceAll")
    });
  }
});

// ../../node_modules/core-js/internals/entry-unbind.js
var require_entry_unbind = __commonJS({
  "../../node_modules/core-js/internals/entry-unbind.js"(exports, module) {
    init_define_process();
    var global2 = require_global();
    var uncurryThis = require_function_uncurry_this();
    module.exports = function(CONSTRUCTOR, METHOD) {
      return uncurryThis(global2[CONSTRUCTOR].prototype[METHOD]);
    };
  }
});

// ../../node_modules/core-js/es/string/replace-all.js
var require_replace_all = __commonJS({
  "../../node_modules/core-js/es/string/replace-all.js"(exports, module) {
    init_define_process();
    require_es_regexp_exec();
    require_es_string_replace();
    require_es_string_replace_all();
    var entryUnbind = require_entry_unbind();
    module.exports = entryUnbind("String", "replaceAll");
  }
});

// ../../node_modules/core-js/stable/string/replace-all.js
var require_replace_all2 = __commonJS({
  "../../node_modules/core-js/stable/string/replace-all.js"(exports, module) {
    init_define_process();
    var parent = require_replace_all();
    module.exports = parent;
  }
});

// js/startMonaco.ts
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/editor/editor.all.js
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/browser/anchorSelect.js
init_define_process();
init_aria();
init_keyCodes();
init_editorExtensions();
init_selection();
init_editorContextKeys();
init_nls();
init_contextkey();
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var SelectionAnchorController = /* @__PURE__ */ __name(class SelectionAnchorController2 {
  static get(editor2) {
    return editor2.getContribution(SelectionAnchorController2.ID);
  }
  constructor(editor2, contextKeyService) {
    this.editor = editor2;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      this.editor.changeDecorations((accessor) => {
        if (this.decorationId) {
          accessor.removeDecoration(this.decorationId);
        }
        this.decorationId = accessor.addDecoration(Selection.fromPositions(position, position), {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        });
      });
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      const decorationId = this.decorationId;
      this.editor.changeDecorations((accessor) => {
        accessor.removeDecoration(decorationId);
        this.decorationId = void 0;
      });
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
}, "SelectionAnchorController");
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = __decorate([
  __param(1, IContextKeyService)
], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 32),
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    var _a6;
    return __awaiter(this, void 0, void 0, function* () {
      (_a6 = SelectionAnchorController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.setSelectionAnchor();
    });
  }
};
__name(SetSelectionAnchor, "SetSelectionAnchor");
var GoToSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: SelectionAnchorSet
    });
  }
  run(_accessor, editor2) {
    var _a6;
    return __awaiter(this, void 0, void 0, function* () {
      (_a6 = SelectionAnchorController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.goToSelectionAnchor();
    });
  }
};
__name(GoToSelectionAnchor, "GoToSelectionAnchor");
var SelectFromAnchorToCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 41),
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    var _a6;
    return __awaiter(this, void 0, void 0, function* () {
      (_a6 = SelectionAnchorController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.selectFromAnchorToCursor();
    });
  }
};
__name(SelectFromAnchorToCursor, "SelectFromAnchorToCursor");
var CancelSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    var _a6;
    return __awaiter(this, void 0, void 0, function* () {
      (_a6 = SelectionAnchorController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.cancelSelectionAnchor();
    });
  }
};
__name(CancelSelectionAnchor, "CancelSelectionAnchor");
registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController, 4);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/browser/bracketMatching.js
init_define_process();
init_async();
init_lifecycle();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_model2();
init_textModel();
init_nls();
init_actions2();
init_colorRegistry();
init_themeService();
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hcDark: "#A0A0A0", hcLight: "#A0A0A0" }, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 88,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    var _a6;
    (_a6 = BracketMatchingController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.jumpToBracket();
  }
};
__name(JumpToBracketAction, "JumpToBracketAction");
var SelectToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      description: {
        description: `Select to Bracket`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "selectBrackets": {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor2, args) {
    var _a6;
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    (_a6 = BracketMatchingController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.selectToBracket(selectBrackets);
  }
};
__name(SelectToBracketAction, "SelectToBracketAction");
var BracketsData = class {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
};
__name(BracketsData, "BracketsData");
var BracketMatchingController = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(BracketMatchingController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = this._editor.createDecorationsCollection();
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(66);
    this._updateBracketsSoon.schedule();
    this._register(editor2.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(66)) {
        this._matchBrackets = this._editor.getOption(66);
        this._decorations.clear();
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
    this._register(editor2.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.bracketPairs.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position) && !brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[1].getStartPosition();
        } else {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
        if (close.containsPosition(position)) {
          const tmp = selectFrom;
          selectFrom = selectTo;
          selectTo = tmp;
        }
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    const newDecorations = [];
    let newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      const brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
        newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
      }
    }
    this._decorations.set(newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    const positions = [];
    let positionsLen = 0;
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position.compare);
    }
    const newData = [];
    let newDataLen = 0;
    let previousIndex = 0;
    const previousLen = previousData.length;
    for (let i = 0, len = positions.length; i < len; i++) {
      const position = positions[i];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.bracketPairs.matchBracket(position, 20);
        let options = BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.bracketPairs.findEnclosingBrackets(position, 20);
          options = BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
};
__name(BracketMatchingController, "BracketMatchingController");
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
registerEditorContribution(BracketMatchingController.ID, BracketMatchingController, 1);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_define_process();
init_editorExtensions();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/moveCaretCommand.js
init_define_process();
init_range();
init_selection();
var MoveCaretCommand = class {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
};
__name(MoveCaretCommand, "MoveCaretCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/caretOperations.js
init_nls();
var MoveCaretAction = class extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new MoveCaretCommand(selection, this.left));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(MoveCaretAction, "MoveCaretAction");
var MoveCaretLeftAction = class extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(MoveCaretLeftAction, "MoveCaretLeftAction");
var MoveCaretRightAction = class extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(MoveCaretRightAction, "MoveCaretRightAction");
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/browser/transpose.js
init_define_process();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_nls();
var TransposeLettersAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
        },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      const lineNumber = selection.startLineNumber;
      const column = selection.startColumn;
      const lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      const endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      const middlePosition = MoveOperations.leftPosition(model, endPosition);
      const beginPosition = MoveOperations.leftPosition(model, middlePosition);
      const leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
      const rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
      const replaceRange = Range.fromPositions(beginPosition, endPosition);
      commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands.length > 0) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, commands);
      editor2.pushUndoStop();
    }
  }
};
__name(TransposeLettersAction, "TransposeLettersAction");
registerEditorAction(TransposeLettersAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/browser/clipboard.js
init_define_process();
init_browser();
init_platform();
init_editorExtensions();
init_codeEditorService();
init_editorContextKeys();
init_nls();
init_actions2();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
__name(registerCommand, "registerCommand");
var CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 54,
    win: { primary: 2048 | 54, secondary: [1024 | 20] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }]
})) : void 0;
var CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 33,
    win: { primary: 2048 | 33, secondary: [2048 | 19] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextShare, title: { value: localize("share", "Share"), original: "Share" }, group: "11_share", order: -1 });
var PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 52,
    win: { primary: 2048 | 52, secondary: [1024 | 19] },
    linux: { primary: 2048 | 52, secondary: [1024 | 19] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor2.getOption(33);
    if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor2.focus();
    document.execCommand("copy");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
};
__name(ExecCommandCopyWithSyntaxHighlightingAction, "ExecCommandCopyWithSyntaxHighlightingAction");
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(33);
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
__name(registerExecCommandImpl, "registerExecCommandImpl");
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const result = document.execCommand("paste");
      if (!result && isWeb) {
        return (() => __awaiter2(void 0, void 0, void 0, function* () {
          const clipboardText = yield clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(33) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        }))();
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand("paste");
    return true;
  });
}
if (supportsCopy) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_define_process();
init_editorExtensions();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
init_define_process();
init_lazy();
init_lifecycle();
init_strings();
init_editorExtensions();
init_editorContextKeys();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js
init_define_process();
init_arrays();
init_cancellation();
init_errors();
init_lifecycle();
init_uri();
init_range();
init_selection();
init_languageFeatures();
init_model();
init_editorState();
init_nls();
init_commands();
init_progress();
init_telemetry();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/common/types.js
init_define_process();
init_errors();
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeActionKind = class {
  constructor(value) {
    this.value = value;
  }
  equals(other) {
    return this.value === other.value;
  }
  contains(other) {
    return this.equals(other) || this.value === "" || other.value.startsWith(this.value + CodeActionKind.sep);
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  append(part) {
    return new CodeActionKind(this.value + CodeActionKind.sep + part);
  }
};
__name(CodeActionKind, "CodeActionKind");
CodeActionKind.sep = ".";
CodeActionKind.None = new CodeActionKind("@@none@@");
CodeActionKind.Empty = new CodeActionKind("");
CodeActionKind.QuickFix = new CodeActionKind("quickfix");
CodeActionKind.Refactor = new CodeActionKind("refactor");
CodeActionKind.RefactorExtract = CodeActionKind.Refactor.append("extract");
CodeActionKind.RefactorInline = CodeActionKind.Refactor.append("inline");
CodeActionKind.RefactorMove = CodeActionKind.Refactor.append("move");
CodeActionKind.RefactorRewrite = CodeActionKind.Refactor.append("rewrite");
CodeActionKind.Source = new CodeActionKind("source");
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
CodeActionKind.SurroundWith = CodeActionKind.Refactor.append("surround");
var CodeActionTriggerSource;
(function(CodeActionTriggerSource2) {
  CodeActionTriggerSource2["Refactor"] = "refactor";
  CodeActionTriggerSource2["RefactorPreview"] = "refactor preview";
  CodeActionTriggerSource2["Lightbulb"] = "lightbulb";
  CodeActionTriggerSource2["Default"] = "other (default)";
  CodeActionTriggerSource2["SourceAction"] = "source action";
  CodeActionTriggerSource2["QuickFix"] = "quick fix action";
  CodeActionTriggerSource2["FixAll"] = "fix all";
  CodeActionTriggerSource2["OrganizeImports"] = "organize imports";
  CodeActionTriggerSource2["AutoFix"] = "auto fix";
  CodeActionTriggerSource2["QuickFixHover"] = "quick fix hover window";
  CodeActionTriggerSource2["OnSave"] = "save participants";
  CodeActionTriggerSource2["ProblemsView"] = "problems view";
})(CodeActionTriggerSource || (CodeActionTriggerSource = {}));
function mayIncludeActionsOfKind(filter, providedKind) {
  if (filter.include && !filter.include.intersects(providedKind)) {
    return false;
  }
  if (filter.excludes) {
    if (filter.excludes.some((exclude) => excludesAction(providedKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {
    return false;
  }
  return true;
}
__name(mayIncludeActionsOfKind, "mayIncludeActionsOfKind");
function filtersAction(filter, action) {
  const actionKind = action.kind ? new CodeActionKind(action.kind) : void 0;
  if (filter.include) {
    if (!actionKind || !filter.include.contains(actionKind)) {
      return false;
    }
  }
  if (filter.excludes) {
    if (actionKind && filter.excludes.some((exclude) => excludesAction(actionKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions) {
    if (actionKind && CodeActionKind.Source.contains(actionKind)) {
      return false;
    }
  }
  if (filter.onlyIncludePreferredActions) {
    if (!action.isPreferred) {
      return false;
    }
  }
  return true;
}
__name(filtersAction, "filtersAction");
function excludesAction(providedKind, exclude, include) {
  if (!exclude.contains(providedKind)) {
    return false;
  }
  if (include && exclude.contains(include)) {
    return false;
  }
  return true;
}
__name(excludesAction, "excludesAction");
var CodeActionCommandArgs = class {
  static fromUser(arg, defaults) {
    if (!arg || typeof arg !== "object") {
      return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);
    }
    return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));
  }
  static getApplyFromUser(arg, defaultAutoApply) {
    switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return defaultAutoApply;
    }
  }
  static getKindFromUser(arg, defaultKind) {
    return typeof arg.kind === "string" ? new CodeActionKind(arg.kind) : defaultKind;
  }
  static getPreferredUser(arg) {
    return typeof arg.preferred === "boolean" ? arg.preferred : false;
  }
  constructor(kind, apply, preferred) {
    this.kind = kind;
    this.apply = apply;
    this.preferred = preferred;
  }
};
__name(CodeActionCommandArgs, "CodeActionCommandArgs");
var CodeActionItem = class {
  constructor(action, provider) {
    this.action = action;
    this.provider = provider;
  }
  resolve(token) {
    var _a6;
    return __awaiter3(this, void 0, void 0, function* () {
      if (((_a6 = this.provider) === null || _a6 === void 0 ? void 0 : _a6.resolveCodeAction) && !this.action.edit) {
        let action;
        try {
          action = yield this.provider.resolveCodeAction(this.action, token);
        } catch (err) {
          onUnexpectedExternalError(err);
        }
        if (action) {
          this.action.edit = action.edit;
        }
      }
      return this;
    });
  }
};
__name(CodeActionItem, "CodeActionItem");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var codeActionCommandId = "editor.action.codeAction";
var refactorCommandId = "editor.action.refactor";
var refactorPreviewCommandId = "editor.action.refactor.preview";
var sourceActionCommandId = "editor.action.sourceAction";
var organizeImportsCommandId = "editor.action.organizeImports";
var fixAllCommandId = "editor.action.fixAll";
var ManagedCodeActionSet = class extends Disposable {
  static codeActionsPreferredComparator(a, b) {
    if (a.isPreferred && !b.isPreferred) {
      return -1;
    } else if (!a.isPreferred && b.isPreferred) {
      return 1;
    } else {
      return 0;
    }
  }
  static codeActionsComparator({ action: a }, { action: b }) {
    if (isNonEmptyArray(a.diagnostics)) {
      return isNonEmptyArray(b.diagnostics) ? ManagedCodeActionSet.codeActionsPreferredComparator(a, b) : -1;
    } else if (isNonEmptyArray(b.diagnostics)) {
      return 1;
    } else {
      return ManagedCodeActionSet.codeActionsPreferredComparator(a, b);
    }
  }
  constructor(actions, documentation, disposables) {
    super();
    this.documentation = documentation;
    this._register(disposables);
    this.allActions = [...actions].sort(ManagedCodeActionSet.codeActionsComparator);
    this.validActions = this.allActions.filter(({ action }) => !action.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);
  }
};
__name(ManagedCodeActionSet, "ManagedCodeActionSet");
var emptyCodeActionsResponse = { actions: [], documentation: void 0 };
function getCodeActions(registry, model, rangeOrSelection, trigger, progress, token) {
  var _a6;
  return __awaiter4(this, void 0, void 0, function* () {
    const filter = trigger.filter || {};
    const codeActionContext = {
      only: (_a6 = filter.include) === null || _a6 === void 0 ? void 0 : _a6.value,
      trigger: trigger.type
    };
    const cts = new TextModelCancellationTokenSource(model, token);
    const providers = getCodeActionProviders(registry, model, filter);
    const disposables = new DisposableStore();
    const promises = providers.map((provider) => __awaiter4(this, void 0, void 0, function* () {
      try {
        progress.report(provider);
        const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
        if (providedCodeActions) {
          disposables.add(providedCodeActions);
        }
        if (cts.token.isCancellationRequested) {
          return emptyCodeActionsResponse;
        }
        const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter((action) => action && filtersAction(filter, action));
        const documentation = getDocumentationFromProvider(provider, filteredActions, filter.include);
        return {
          actions: filteredActions.map((action) => new CodeActionItem(action, provider)),
          documentation
        };
      } catch (err) {
        if (isCancellationError(err)) {
          throw err;
        }
        onUnexpectedExternalError(err);
        return emptyCodeActionsResponse;
      }
    }));
    const listener = registry.onDidChange(() => {
      const newProviders = registry.all(model);
      if (!equals(newProviders, providers)) {
        cts.cancel();
      }
    });
    try {
      const actions = yield Promise.all(promises);
      const allActions = actions.map((x) => x.actions).flat();
      const allDocumentation = [
        ...coalesce(actions.map((x) => x.documentation)),
        ...getAdditionalDocumentationForShowingActions(registry, model, trigger, allActions)
      ];
      return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
    } finally {
      listener.dispose();
      cts.dispose();
    }
  });
}
__name(getCodeActions, "getCodeActions");
function getCodeActionProviders(registry, model, filter) {
  return registry.all(model).filter((provider) => {
    if (!provider.providedCodeActionKinds) {
      return true;
    }
    return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter, new CodeActionKind(kind)));
  });
}
__name(getCodeActionProviders, "getCodeActionProviders");
function* getAdditionalDocumentationForShowingActions(registry, model, trigger, actionsToShow) {
  var _a6, _b2, _c2;
  if (model && actionsToShow.length) {
    for (const provider of registry.all(model)) {
      if (provider._getAdditionalMenuItems) {
        yield* (_a6 = provider._getAdditionalMenuItems) === null || _a6 === void 0 ? void 0 : _a6.call(provider, { trigger: trigger.type, only: (_c2 = (_b2 = trigger.filter) === null || _b2 === void 0 ? void 0 : _b2.include) === null || _c2 === void 0 ? void 0 : _c2.value }, actionsToShow.map((item) => item.action));
      }
    }
  }
}
__name(getAdditionalDocumentationForShowingActions, "getAdditionalDocumentationForShowingActions");
function getDocumentationFromProvider(provider, providedCodeActions, only) {
  if (!provider.documentation) {
    return void 0;
  }
  const documentation = provider.documentation.map((entry) => ({ kind: new CodeActionKind(entry.kind), command: entry.command }));
  if (only) {
    let currentBest;
    for (const entry of documentation) {
      if (entry.kind.contains(only)) {
        if (!currentBest) {
          currentBest = entry;
        } else {
          if (currentBest.kind.contains(entry.kind)) {
            currentBest = entry;
          }
        }
      }
    }
    if (currentBest) {
      return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
    }
  }
  for (const action of providedCodeActions) {
    if (!action.kind) {
      continue;
    }
    for (const entry of documentation) {
      if (entry.kind.contains(new CodeActionKind(action.kind))) {
        return entry.command;
      }
    }
  }
  return void 0;
}
__name(getDocumentationFromProvider, "getDocumentationFromProvider");
var ApplyCodeActionReason;
(function(ApplyCodeActionReason2) {
  ApplyCodeActionReason2["OnSave"] = "onSave";
  ApplyCodeActionReason2["FromProblemsView"] = "fromProblemsView";
  ApplyCodeActionReason2["FromCodeActions"] = "fromCodeActions";
})(ApplyCodeActionReason || (ApplyCodeActionReason = {}));
function applyCodeAction(accessor, item, codeActionReason, options) {
  return __awaiter4(this, void 0, void 0, function* () {
    const bulkEditService = accessor.get(IBulkEditService);
    const commandService = accessor.get(ICommandService);
    const telemetryService = accessor.get(ITelemetryService);
    const notificationService = accessor.get(INotificationService);
    telemetryService.publicLog2("codeAction.applyCodeAction", {
      codeActionTitle: item.action.title,
      codeActionKind: item.action.kind,
      codeActionIsPreferred: !!item.action.isPreferred,
      reason: codeActionReason
    });
    yield item.resolve(CancellationToken.None);
    if (item.action.edit) {
      yield bulkEditService.apply(item.action.edit, {
        editor: options === null || options === void 0 ? void 0 : options.editor,
        label: item.action.title,
        quotableLabel: item.action.title,
        code: "undoredo.codeAction",
        respectAutoSaveConfig: codeActionReason !== ApplyCodeActionReason.OnSave,
        showPreview: options === null || options === void 0 ? void 0 : options.preview
      });
    }
    if (item.action.command) {
      try {
        yield commandService.executeCommand(item.action.command.id, ...item.action.command.arguments || []);
      } catch (err) {
        const message = asMessage(err);
        notificationService.error(typeof message === "string" ? message : localize("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
      }
    }
  });
}
__name(applyCodeAction, "applyCodeAction");
function asMessage(err) {
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error && typeof err.message === "string") {
    return err.message;
  } else {
    return void 0;
  }
}
__name(asMessage, "asMessage");
CommandsRegistry.registerCommand("_executeCodeActionProvider", function(accessor, resource, rangeOrSelection, kind, itemResolveCount) {
  return __awaiter4(this, void 0, void 0, function* () {
    if (!(resource instanceof URI)) {
      throw illegalArgument();
    }
    const { codeActionProvider } = accessor.get(ILanguageFeaturesService);
    const model = accessor.get(IModelService).getModel(resource);
    if (!model) {
      throw illegalArgument();
    }
    const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection) ? Selection.liftSelection(rangeOrSelection) : Range.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
    if (!validatedRangeOrSelection) {
      throw illegalArgument();
    }
    const include = typeof kind === "string" ? new CodeActionKind(kind) : void 0;
    const codeActionSet = yield getCodeActions(codeActionProvider, model, validatedRangeOrSelection, { type: 1, triggerAction: CodeActionTriggerSource.Default, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
    const resolving = [];
    const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === "number" ? itemResolveCount : 0);
    for (let i = 0; i < resolveCount; i++) {
      resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
    }
    try {
      yield Promise.all(resolving);
      return codeActionSet.validActions.map((item) => item.action);
    } finally {
      setTimeout(() => codeActionSet.dispose(), 100);
    }
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js
init_define_process();
init_dom();
init_errors();
init_lazy();
init_lifecycle();
init_position();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionKeybindingResolver.js
init_define_process();
init_lazy();
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CodeActionKeybindingResolver = /* @__PURE__ */ __name(class CodeActionKeybindingResolver2 {
  constructor(keybindingService) {
    this.keybindingService = keybindingService;
  }
  getResolver() {
    const allCodeActionBindings = new Lazy(() => this.keybindingService.getKeybindings().filter((item) => CodeActionKeybindingResolver2.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
      let commandArgs = item.commandArgs;
      if (item.command === organizeImportsCommandId) {
        commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };
      } else if (item.command === fixAllCommandId) {
        commandArgs = { kind: CodeActionKind.SourceFixAll.value };
      }
      return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {
        kind: CodeActionKind.None,
        apply: "never"
      }));
    }));
    return (action) => {
      if (action.kind) {
        const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());
        return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
      }
      return void 0;
    };
  }
  bestKeybindingForCodeAction(action, candidates) {
    if (!action.kind) {
      return void 0;
    }
    const kind = new CodeActionKind(action.kind);
    return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
      if (candidate.preferred) {
        return action.isPreferred;
      }
      return true;
    }).reduceRight((currentBest, candidate) => {
      if (!currentBest) {
        return candidate;
      }
      return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
    }, void 0);
  }
}, "CodeActionKeybindingResolver");
CodeActionKeybindingResolver.codeActionCommands = [
  refactorCommandId,
  codeActionCommandId,
  sourceActionCommandId,
  organizeImportsCommandId,
  fixAllCommandId
];
CodeActionKeybindingResolver = __decorate2([
  __param2(0, IKeybindingService)
], CodeActionKeybindingResolver);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionMenu.js
init_define_process();
init_codicons();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/browser/symbolIcons.js
init_define_process();
init_nls();
init_colorRegistry();
var SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, localize("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, localize("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", {
  dark: foreground,
  light: foreground,
  hcDark: foreground,
  hcLight: foreground
}, localize("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, localize("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionMenu.js
init_nls();
var uncategorizedCodeActionGroup = Object.freeze({ kind: CodeActionKind.Empty, title: localize("codeAction.widget.id.more", "More Actions...") });
var codeActionGroups = Object.freeze([
  { kind: CodeActionKind.QuickFix, title: localize("codeAction.widget.id.quickfix", "Quick Fix...") },
  { kind: CodeActionKind.RefactorExtract, title: localize("codeAction.widget.id.extract", "Extract..."), icon: { codicon: Codicon.wrench } },
  { kind: CodeActionKind.RefactorInline, title: localize("codeAction.widget.id.inline", "Inline..."), icon: { codicon: Codicon.wrench } },
  { kind: CodeActionKind.RefactorRewrite, title: localize("codeAction.widget.id.convert", "Rewrite..."), icon: { codicon: Codicon.wrench } },
  { kind: CodeActionKind.RefactorMove, title: localize("codeAction.widget.id.move", "Move..."), icon: { codicon: Codicon.wrench } },
  { kind: CodeActionKind.SurroundWith, title: localize("codeAction.widget.id.surround", "Surround With..."), icon: { codicon: Codicon.symbolSnippet } },
  { kind: CodeActionKind.Source, title: localize("codeAction.widget.id.source", "Source Action..."), icon: { codicon: Codicon.symbolFile } },
  uncategorizedCodeActionGroup
]);
function toMenuItems(inputCodeActions, showHeaders, keybindingResolver) {
  if (!showHeaders) {
    return inputCodeActions.map((action) => {
      return {
        kind: "action",
        item: action,
        group: uncategorizedCodeActionGroup,
        disabled: !!action.action.disabled,
        label: action.action.disabled || action.action.title
      };
    });
  }
  const menuEntries = codeActionGroups.map((group) => ({ group, actions: [] }));
  for (const action of inputCodeActions) {
    const kind = action.action.kind ? new CodeActionKind(action.action.kind) : CodeActionKind.None;
    for (const menuEntry of menuEntries) {
      if (menuEntry.group.kind.contains(kind)) {
        menuEntry.actions.push(action);
        break;
      }
    }
  }
  const allMenuItems = [];
  for (const menuEntry of menuEntries) {
    if (menuEntry.actions.length) {
      allMenuItems.push({ kind: "header", group: menuEntry.group });
      for (const action of menuEntry.actions) {
        allMenuItems.push({
          kind: "action",
          item: action,
          group: menuEntry.group,
          label: action.action.title,
          disabled: !!action.action.disabled,
          keybinding: keybindingResolver(action.action)
        });
      }
    }
  }
  return allMenuItems;
}
__name(toMenuItems, "toMenuItems");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/message/browser/messageController.js
init_define_process();
init_aria();
init_async();
init_lifecycle();
init_editorExtensions();
init_range();
init_nls();
init_contextkey();
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageController = /* @__PURE__ */ __name(class MessageController2 {
  static get(editor2) {
    return editor2.getContribution(MessageController2.ID);
  }
  constructor(editor2, contextKeyService) {
    this._messageWidget = new MutableDisposable();
    this._messageListeners = new DisposableStore();
    this._editor = editor2;
    this._visible = MessageController2.MESSAGE_VISIBLE.bindTo(contextKeyService);
  }
  dispose() {
    this._messageListeners.dispose();
    this._messageWidget.dispose();
    this._visible.reset();
  }
  showMessage(message, position) {
    alert(message);
    this._visible.set(true);
    this._messageWidget.clear();
    this._messageListeners.clear();
    this._messageWidget.value = new MessageWidget(this._editor, position, message);
    this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
    this._messageListeners.add(new TimeoutTimer(() => this.closeMessage(), 3e3));
    let bounds;
    this._messageListeners.add(this._editor.onMouseMove((e) => {
      if (!e.target.position) {
        return;
      }
      if (!bounds) {
        bounds = new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
      } else if (!bounds.containsPosition(e.target.position)) {
        this.closeMessage();
      }
    }));
  }
  closeMessage() {
    this._visible.reset();
    this._messageListeners.clear();
    if (this._messageWidget.value) {
      this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
    }
  }
}, "MessageController");
MessageController.ID = "editor.contrib.messageController";
MessageController.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false, localize("messageVisible", "Whether the editor is currently showing an inline message"));
MessageController = __decorate3([
  __param3(1, IContextKeyService)
], MessageController);
var MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(new MessageCommand({
  id: "leaveEditorMessage",
  precondition: MessageController.MESSAGE_VISIBLE,
  handler: (c) => c.closeMessage(),
  kbOpts: {
    weight: 100 + 30,
    primary: 9
  }
}));
var MessageWidget = class {
  static fadeOut(messageWidget) {
    const dispose2 = /* @__PURE__ */ __name(() => {
      messageWidget.dispose();
      clearTimeout(handle);
      messageWidget.getDomNode().removeEventListener("animationend", dispose2);
    }, "dispose");
    const handle = setTimeout(dispose2, 110);
    messageWidget.getDomNode().addEventListener("animationend", dispose2);
    messageWidget.getDomNode().classList.add("fadeOut");
    return { dispose: dispose2 };
  }
  constructor(editor2, { lineNumber, column }, text) {
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._editor = editor2;
    this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0);
    this._position = { lineNumber, column };
    this._domNode = document.createElement("div");
    this._domNode.classList.add("monaco-editor-overlaymessage");
    this._domNode.style.marginLeft = "-6px";
    const anchorTop = document.createElement("div");
    anchorTop.classList.add("anchor", "top");
    this._domNode.appendChild(anchorTop);
    const message = document.createElement("div");
    message.classList.add("message");
    message.textContent = text;
    this._domNode.appendChild(message);
    const anchorBottom = document.createElement("div");
    anchorBottom.classList.add("anchor", "below");
    this._domNode.appendChild(anchorBottom);
    this._editor.addContentWidget(this);
    this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(position) {
    this._domNode.classList.toggle("below", position === 2);
  }
};
__name(MessageWidget, "MessageWidget");
registerEditorContribution(MessageController.ID, MessageController, 4);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js
init_nls();

// ../../node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.js
init_define_process();
init_dom();
init_lifecycle();
init_nls();
init_actions2();

// ../../node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionList.js
init_define_process();
init_dom();
init_codicons();
init_lifecycle();
init_platform();
init_nls();
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var acceptSelectedActionCommand = "acceptSelectedCodeAction";
var previewSelectedActionCommand = "previewSelectedCodeAction";
var HeaderRenderer = class {
  get templateId() {
    return "header";
  }
  renderTemplate(container) {
    container.classList.add("group-header");
    const text = document.createElement("span");
    container.append(text);
    return { container, text };
  }
  renderElement(element, _index, templateData) {
    var _a6, _b2;
    templateData.text.textContent = (_b2 = (_a6 = element.group) === null || _a6 === void 0 ? void 0 : _a6.title) !== null && _b2 !== void 0 ? _b2 : "";
  }
  disposeTemplate(_templateData) {
  }
};
__name(HeaderRenderer, "HeaderRenderer");
var ActionItemRenderer = /* @__PURE__ */ __name(class ActionItemRenderer2 {
  get templateId() {
    return "action";
  }
  constructor(_supportsPreview, _keybindingService) {
    this._supportsPreview = _supportsPreview;
    this._keybindingService = _keybindingService;
  }
  renderTemplate(container) {
    container.classList.add(this.templateId);
    const icon = document.createElement("div");
    icon.className = "icon";
    container.append(icon);
    const text = document.createElement("span");
    text.className = "title";
    container.append(text);
    const keybinding = new KeybindingLabel(container, OS);
    return { container, icon, text, keybinding };
  }
  renderElement(element, _index, data) {
    var _a6, _b2, _c2, _d2;
    if ((_a6 = element.group) === null || _a6 === void 0 ? void 0 : _a6.icon) {
      data.icon.className = element.group.icon.codicon.classNames;
      data.icon.style.color = (_b2 = element.group.icon.color) !== null && _b2 !== void 0 ? _b2 : "";
    } else {
      data.icon.className = Codicon.lightBulb.classNames;
      data.icon.style.color = "var(--vscode-editorLightBulb-foreground)";
    }
    if (!element.item || !element.label) {
      return;
    }
    data.text.textContent = stripNewlines(element.label);
    if (!element.keybinding) {
      hide(data.keybinding.element);
    } else {
      data.keybinding.set(element.keybinding);
      show(data.keybinding.element);
    }
    const actionTitle = (_c2 = this._keybindingService.lookupKeybinding(acceptSelectedActionCommand)) === null || _c2 === void 0 ? void 0 : _c2.getLabel();
    const previewTitle = (_d2 = this._keybindingService.lookupKeybinding(previewSelectedActionCommand)) === null || _d2 === void 0 ? void 0 : _d2.getLabel();
    data.container.classList.toggle("option-disabled", element.disabled);
    if (element.disabled) {
      data.container.title = element.label;
    } else if (actionTitle && previewTitle) {
      if (this._supportsPreview) {
        data.container.title = localize({ key: "label-preview", comment: ['placeholders are keybindings, e.g "F2 to apply, Shift+F2 to preview"'] }, "{0} to apply, {1} to preview", actionTitle, previewTitle);
      } else {
        data.container.title = localize({ key: "label", comment: ['placeholder is a keybinding, e.g "F2 to apply"'] }, "{0} to apply", actionTitle);
      }
    } else {
      data.container.title = "";
    }
    if (element.description) {
      const label = new HighlightedLabel(append(data.container, $("span.label-description")));
      label.element.classList.add("action-list-description");
      label.set(element.description);
    }
  }
  disposeTemplate(_templateData) {
  }
}, "ActionItemRenderer");
ActionItemRenderer = __decorate4([
  __param4(1, IKeybindingService)
], ActionItemRenderer);
var ActionList = /* @__PURE__ */ __name(class ActionList2 extends Disposable {
  constructor(user, preview, items, _delegate, _contextViewService, _keybindingService) {
    super();
    this._delegate = _delegate;
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._actionLineHeight = 24;
    this._headerLineHeight = 26;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("actionList");
    const virtualDelegate = {
      getHeight: (element) => element.kind === "header" ? this._headerLineHeight : this._actionLineHeight,
      getTemplateId: (element) => element.kind
    };
    this._list = this._register(new List(user, this.domNode, virtualDelegate, [new ActionItemRenderer(preview, this._keybindingService), new HeaderRenderer()], {
      keyboardSupport: false,
      accessibilityProvider: {
        getAriaLabel: (element) => {
          if (element.kind === "action") {
            let label = element.label ? stripNewlines(element === null || element === void 0 ? void 0 : element.label) : "";
            if (element.disabled) {
              label = localize({ key: "customQuickFixWidget.labels", comment: [`Action widget labels for accessibility.`] }, "{0}, Disabled Reason: {1}", label, element.disabled);
            }
            return label;
          }
          return null;
        },
        getWidgetAriaLabel: () => localize({ key: "customQuickFixWidget", comment: [`An action widget option`] }, "Action Widget"),
        getRole: () => "option",
        getWidgetRole: () => user
      }
    }));
    this._register(this._list.onMouseClick((e) => this.onListClick(e)));
    this._register(this._list.onMouseOver((e) => this.onListHover(e)));
    this._register(this._list.onDidChangeFocus(() => this._list.domFocus()));
    this._register(this._list.onDidChangeSelection((e) => this.onListSelection(e)));
    this._allMenuItems = items;
    this._list.splice(0, this._list.length, this._allMenuItems);
    this.focusNext();
  }
  focusCondition(element) {
    return !element.disabled && element.kind === "action";
  }
  hide(didCancel) {
    this._delegate.onHide(didCancel);
    this._contextViewService.hideContextView();
  }
  layout(minWidth) {
    const numHeaders = this._allMenuItems.filter((item) => item.kind === "header").length;
    const height = this._allMenuItems.length * this._actionLineHeight;
    const heightWithHeaders = height + numHeaders * this._headerLineHeight - numHeaders * this._actionLineHeight;
    this._list.layout(heightWithHeaders);
    const itemWidths = this._allMenuItems.map((_, index) => {
      const element = document.getElementById(this._list.getElementID(index));
      if (element) {
        element.style.width = "auto";
        const width2 = element.getBoundingClientRect().width;
        element.style.width = "";
        return width2;
      }
      return 0;
    });
    const width = Math.max(...itemWidths, minWidth);
    this._list.layout(heightWithHeaders, width);
    this.domNode.style.height = `${heightWithHeaders}px`;
    this._list.domFocus();
    return width;
  }
  focusPrevious() {
    this._list.focusPrevious(1, true, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, true, void 0, this.focusCondition);
  }
  acceptSelected(preview) {
    const focused = this._list.getFocus();
    if (focused.length === 0) {
      return;
    }
    const focusIndex = focused[0];
    const element = this._list.element(focusIndex);
    if (!this.focusCondition(element)) {
      return;
    }
    const event = new UIEvent(preview ? "previewSelectedCodeAction" : "acceptSelectedCodeAction");
    this._list.setSelection([focusIndex], event);
  }
  onListSelection(e) {
    var _a6;
    if (!e.elements.length) {
      return;
    }
    const element = e.elements[0];
    if (element.item && this.focusCondition(element)) {
      this._delegate.onSelect(element.item, ((_a6 = e.browserEvent) === null || _a6 === void 0 ? void 0 : _a6.type) === "previewSelectedEventType");
    } else {
      this._list.setSelection([]);
    }
  }
  onListHover(e) {
    this._list.setFocus(typeof e.index === "number" ? [e.index] : []);
  }
  onListClick(e) {
    if (e.element && this.focusCondition(e.element)) {
      this._list.setFocus([]);
    }
  }
}, "ActionList");
ActionList = __decorate4([
  __param4(4, IContextViewService),
  __param4(5, IKeybindingService)
], ActionList);
function stripNewlines(str) {
  return str.replace(/\r\n|\r|\n/g, " ");
}
__name(stripNewlines, "stripNewlines");

// ../../node_modules/monaco-editor/esm/vs/platform/actionWidget/browser/actionWidget.js
init_contextkey();
init_extensions();
init_instantiation();
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ActionWidgetContextKeys = {
  Visible: new RawContextKey("actionWidgetVisible", false, localize("actionWidgetVisible", "Whether the action widget list is visible"))
};
var IActionWidgetService = createDecorator("actionWidgetService");
var ActionWidgetService = /* @__PURE__ */ __name(class ActionWidgetService2 extends Disposable {
  get isVisible() {
    return ActionWidgetContextKeys.Visible.getValue(this._contextKeyService) || false;
  }
  constructor(contextViewService, _contextKeyService, _instantiationService) {
    super();
    this.contextViewService = contextViewService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._list = this._register(new MutableDisposable());
  }
  show(user, supportsPreview, items, delegate, anchor, container, actionBarActions) {
    return __awaiter5(this, void 0, void 0, function* () {
      const visibleContext = ActionWidgetContextKeys.Visible.bindTo(this._contextKeyService);
      const list = this._instantiationService.createInstance(ActionList, user, supportsPreview, items, delegate);
      this.contextViewService.showContextView({
        getAnchor: () => anchor,
        render: (container2) => {
          visibleContext.set(true);
          return this._renderWidget(container2, list, actionBarActions !== null && actionBarActions !== void 0 ? actionBarActions : []);
        },
        onHide: (didCancel) => {
          visibleContext.reset();
          return this._onWidgetClosed(didCancel);
        }
      }, container, false);
    });
  }
  acceptSelected(preview) {
    var _a6;
    (_a6 = this._list.value) === null || _a6 === void 0 ? void 0 : _a6.acceptSelected(preview);
  }
  focusPrevious() {
    var _a6, _b2;
    (_b2 = (_a6 = this._list) === null || _a6 === void 0 ? void 0 : _a6.value) === null || _b2 === void 0 ? void 0 : _b2.focusPrevious();
  }
  focusNext() {
    var _a6, _b2;
    (_b2 = (_a6 = this._list) === null || _a6 === void 0 ? void 0 : _a6.value) === null || _b2 === void 0 ? void 0 : _b2.focusNext();
  }
  hide() {
    var _a6;
    (_a6 = this._list.value) === null || _a6 === void 0 ? void 0 : _a6.hide();
    this._list.clear();
  }
  _renderWidget(element, list, actionBarActions) {
    var _a6;
    const widget = document.createElement("div");
    widget.classList.add("action-widget");
    element.appendChild(widget);
    this._list.value = list;
    if (this._list.value) {
      widget.appendChild(this._list.value.domNode);
    } else {
      throw new Error("List has no value");
    }
    const renderDisposables = new DisposableStore();
    const menuBlock = document.createElement("div");
    const block = element.appendChild(menuBlock);
    block.classList.add("context-view-block");
    renderDisposables.add(addDisposableListener(block, EventType.MOUSE_DOWN, (e) => e.stopPropagation()));
    const pointerBlockDiv = document.createElement("div");
    const pointerBlock = element.appendChild(pointerBlockDiv);
    pointerBlock.classList.add("context-view-pointerBlock");
    renderDisposables.add(addDisposableListener(pointerBlock, EventType.POINTER_MOVE, () => pointerBlock.remove()));
    renderDisposables.add(addDisposableListener(pointerBlock, EventType.MOUSE_DOWN, () => pointerBlock.remove()));
    let actionBarWidth = 0;
    if (actionBarActions.length) {
      const actionBar = this._createActionBar(".action-widget-action-bar", actionBarActions);
      if (actionBar) {
        widget.appendChild(actionBar.getContainer().parentElement);
        renderDisposables.add(actionBar);
        actionBarWidth = actionBar.getContainer().offsetWidth;
      }
    }
    const width = (_a6 = this._list.value) === null || _a6 === void 0 ? void 0 : _a6.layout(actionBarWidth);
    widget.style.width = `${width}px`;
    const focusTracker = renderDisposables.add(trackFocus(element));
    renderDisposables.add(focusTracker.onDidBlur(() => this.hide()));
    return renderDisposables;
  }
  _createActionBar(className, actions) {
    if (!actions.length) {
      return void 0;
    }
    const container = $(className);
    const actionBar = new ActionBar(container);
    actionBar.push(actions, { icon: false, label: true });
    return actionBar;
  }
  _onWidgetClosed(didCancel) {
    var _a6;
    (_a6 = this._list.value) === null || _a6 === void 0 ? void 0 : _a6.hide(didCancel);
  }
}, "ActionWidgetService");
ActionWidgetService = __decorate5([
  __param5(0, IContextViewService),
  __param5(1, IContextKeyService),
  __param5(2, IInstantiationService)
], ActionWidgetService);
registerSingleton(IActionWidgetService, ActionWidgetService, 1);
var weight = 100 + 1e3;
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: {
        value: localize("hideCodeActionWidget.title", "Hide action widget"),
        original: "Hide action widget"
      },
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 9,
        secondary: [1024 | 9]
      }
    });
  }
  run(accessor) {
    accessor.get(IActionWidgetService).hide();
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: {
        value: localize("selectPrevCodeAction.title", "Select previous action"),
        original: "Select previous action"
      },
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 16,
        secondary: [2048 | 16],
        mac: { primary: 16, secondary: [2048 | 16, 256 | 46] }
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.focusPrevious();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: {
        value: localize("selectNextCodeAction.title", "Select next action"),
        original: "Select next action"
      },
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 18,
        secondary: [2048 | 18],
        mac: { primary: 18, secondary: [2048 | 18, 256 | 44] }
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.focusNext();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: acceptSelectedActionCommand,
      title: {
        value: localize("acceptSelected.title", "Accept selected action"),
        original: "Accept selected action"
      },
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 3,
        secondary: [2048 | 84]
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.acceptSelected();
    }
  }
});
registerAction2(class extends Action2 {
  constructor() {
    super({
      id: previewSelectedActionCommand,
      title: {
        value: localize("previewSelected.title", "Preview selected action"),
        original: "Preview selected action"
      },
      precondition: ActionWidgetContextKeys.Visible,
      keybinding: {
        weight,
        primary: 2048 | 3
      }
    });
  }
  run(accessor) {
    const widgetService = accessor.get(IActionWidgetService);
    if (widgetService instanceof ActionWidgetService) {
      widgetService.acceptSelected(true);
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js
init_commands();
init_configuration();
init_instantiation();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/lightBulbWidget.js
init_define_process();
init_dom();
init_codicons();
init_event();
init_lifecycle();
init_types();
init_utils();
init_nls();
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LightBulbState;
(function(LightBulbState2) {
  LightBulbState2.Hidden = { type: 0 };
  class Showing {
    constructor(actions, trigger, editorPosition, widgetPosition) {
      this.actions = actions;
      this.trigger = trigger;
      this.editorPosition = editorPosition;
      this.widgetPosition = widgetPosition;
      this.type = 1;
    }
  }
  __name(Showing, "Showing");
  LightBulbState2.Showing = Showing;
})(LightBulbState || (LightBulbState = {}));
var LightBulbWidget = /* @__PURE__ */ __name(class LightBulbWidget2 extends Disposable {
  constructor(_editor, quickFixActionId, preferredFixActionId, keybindingService) {
    super();
    this._editor = _editor;
    this._onClick = this._register(new Emitter());
    this.onClick = this._onClick.event;
    this._state = LightBulbState.Hidden;
    this._domNode = $("div.lightBulbWidget");
    this._register(Gesture.ignoreTarget(this._domNode));
    this._editor.addContentWidget(this);
    this._register(this._editor.onDidChangeModelContent((_) => {
      const editorModel = this._editor.getModel();
      if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {
        this.hide();
      }
    }));
    this._register(addStandardDisposableGenericMouseDownListener(this._domNode, (e) => {
      if (this.state.type !== 1) {
        return;
      }
      this._editor.focus();
      e.preventDefault();
      const { top, height } = getDomNodePagePosition(this._domNode);
      const lineHeight = this._editor.getOption(61);
      let pad = Math.floor(lineHeight / 3);
      if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {
        pad += lineHeight;
      }
      this._onClick.fire({
        x: e.posx,
        y: top + height + pad,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    }));
    this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
      if ((e.buttons & 1) !== 1) {
        return;
      }
      this.hide();
    }));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(59) && !this._editor.getOption(59).enabled) {
        this.hide();
      }
    }));
    this._register(Event.runAndSubscribe(keybindingService.onDidUpdateKeybindings, () => {
      var _a6, _b2;
      this._preferredKbLabel = withNullAsUndefined((_a6 = keybindingService.lookupKeybinding(preferredFixActionId)) === null || _a6 === void 0 ? void 0 : _a6.getLabel());
      this._quickFixKbLabel = withNullAsUndefined((_b2 = keybindingService.lookupKeybinding(quickFixActionId)) === null || _b2 === void 0 ? void 0 : _b2.getLabel());
      this._updateLightBulbTitleAndIcon();
    }));
  }
  dispose() {
    super.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(actions, trigger, atPosition) {
    if (actions.validActions.length <= 0) {
      return this.hide();
    }
    const options = this._editor.getOptions();
    if (!options.get(59).enabled) {
      return this.hide();
    }
    const model = this._editor.getModel();
    if (!model) {
      return this.hide();
    }
    const { lineNumber, column } = model.validatePosition(atPosition);
    const tabSize = model.getOptions().tabSize;
    const fontInfo = options.get(45);
    const lineContent = model.getLineContent(lineNumber);
    const indent = computeIndentLevel(lineContent, tabSize);
    const lineHasSpace = fontInfo.spaceWidth * indent > 22;
    const isFolded = /* @__PURE__ */ __name((lineNumber2) => {
      return lineNumber2 > 2 && this._editor.getTopForLineNumber(lineNumber2) === this._editor.getTopForLineNumber(lineNumber2 - 1);
    }, "isFolded");
    let effectiveLineNumber = lineNumber;
    if (!lineHasSpace) {
      if (lineNumber > 1 && !isFolded(lineNumber - 1)) {
        effectiveLineNumber -= 1;
      } else if (!isFolded(lineNumber + 1)) {
        effectiveLineNumber += 1;
      } else if (column * fontInfo.spaceWidth < 22) {
        return this.hide();
      }
    }
    this.state = new LightBulbState.Showing(actions, trigger, atPosition, {
      position: { lineNumber: effectiveLineNumber, column: 1 },
      preference: LightBulbWidget2._posPref
    });
    this._editor.layoutContentWidget(this);
  }
  hide() {
    if (this.state === LightBulbState.Hidden) {
      return;
    }
    this.state = LightBulbState.Hidden;
    this._editor.layoutContentWidget(this);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
    this._updateLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this.state.type === 1 && this.state.actions.hasAutoFix) {
      this._domNode.classList.remove(...Codicon.lightBulb.classNamesArray);
      this._domNode.classList.add(...Codicon.lightbulbAutofix.classNamesArray);
      if (this._preferredKbLabel) {
        this.title = localize("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel);
        return;
      }
    }
    this._domNode.classList.remove(...Codicon.lightbulbAutofix.classNamesArray);
    this._domNode.classList.add(...Codicon.lightBulb.classNamesArray);
    if (this._quickFixKbLabel) {
      this.title = localize("codeActionWithKb", "Show Code Actions ({0})", this._quickFixKbLabel);
    } else {
      this.title = localize("codeAction", "Show Code Actions");
    }
  }
  set title(value) {
    this._domNode.title = value;
  }
}, "LightBulbWidget");
LightBulbWidget._posPref = [0];
LightBulbWidget = __decorate6([
  __param6(3, IKeybindingService)
], LightBulbWidget);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionUi.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CodeActionUi_disposed;
var CodeActionUi = /* @__PURE__ */ __name(class CodeActionUi2 extends Disposable {
  constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService, _configurationService, _actionWidgetService, _commandService) {
    super();
    this._editor = _editor;
    this.delegate = delegate;
    this._configurationService = _configurationService;
    this._actionWidgetService = _actionWidgetService;
    this._commandService = _commandService;
    this._activeCodeActions = this._register(new MutableDisposable());
    _CodeActionUi_disposed.set(this, false);
    this._showDisabled = false;
    this._lightBulbWidget = new Lazy(() => {
      const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));
      this._register(widget.onClick((e) => this.showCodeActionList(e.actions, e, { includeDisabledActions: false, fromLightbulb: true })));
      return widget;
    });
    this._resolver = instantiationService.createInstance(CodeActionKeybindingResolver);
    this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    __classPrivateFieldSet(this, _CodeActionUi_disposed, true, "f");
    super.dispose();
  }
  update(newState) {
    var _a6, _b2, _c2, _d2, _e2;
    return __awaiter6(this, void 0, void 0, function* () {
      if (newState.type !== 1) {
        (_a6 = this._lightBulbWidget.rawValue) === null || _a6 === void 0 ? void 0 : _a6.hide();
        return;
      }
      let actions;
      try {
        actions = yield newState.actions;
      } catch (e) {
        onUnexpectedError(e);
        return;
      }
      if (__classPrivateFieldGet(this, _CodeActionUi_disposed, "f")) {
        return;
      }
      this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);
      if (newState.trigger.type === 1) {
        if ((_b2 = newState.trigger.filter) === null || _b2 === void 0 ? void 0 : _b2.include) {
          const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
          if (validActionToApply) {
            try {
              this._lightBulbWidget.getValue().hide();
              yield this.delegate.applyCodeAction(validActionToApply, false, false);
            } finally {
              actions.dispose();
            }
            return;
          }
          if (newState.trigger.context) {
            const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
            if (invalidAction && invalidAction.action.disabled) {
              (_c2 = MessageController.get(this._editor)) === null || _c2 === void 0 ? void 0 : _c2.showMessage(invalidAction.action.disabled, newState.trigger.context.position);
              actions.dispose();
              return;
            }
          }
        }
        const includeDisabledActions = !!((_d2 = newState.trigger.filter) === null || _d2 === void 0 ? void 0 : _d2.include);
        if (newState.trigger.context) {
          if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
            (_e2 = MessageController.get(this._editor)) === null || _e2 === void 0 ? void 0 : _e2.showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
            this._activeCodeActions.value = actions;
            actions.dispose();
            return;
          }
        }
        this._activeCodeActions.value = actions;
        this.showCodeActionList(actions, this.toCoords(newState.position), { includeDisabledActions, fromLightbulb: false });
      } else {
        if (this._actionWidgetService.isVisible) {
          actions.dispose();
        } else {
          this._activeCodeActions.value = actions;
        }
      }
    });
  }
  getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
    if (!actions.allActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) {
      return actions.allActions.find(({ action }) => action.disabled);
    }
    return void 0;
  }
  tryGetValidActionToApply(trigger, actions) {
    if (!actions.validActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) {
      return actions.validActions[0];
    }
    return void 0;
  }
  showCodeActionList(actions, at, options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const editorDom = this._editor.getDomNode();
      if (!editorDom) {
        return;
      }
      const actionsToShow = options.includeDisabledActions && (this._showDisabled || actions.validActions.length === 0) ? actions.allActions : actions.validActions;
      if (!actionsToShow.length) {
        return;
      }
      const anchor = Position.isIPosition(at) ? this.toCoords(at) : at;
      const delegate = {
        onSelect: (action, preview) => __awaiter6(this, void 0, void 0, function* () {
          this.delegate.applyCodeAction(action, true, !!preview ? preview : false);
          this._actionWidgetService.hide();
        }),
        onHide: () => {
          var _a6;
          (_a6 = this._editor) === null || _a6 === void 0 ? void 0 : _a6.focus();
        }
      };
      this._actionWidgetService.show("codeActionWidget", true, toMenuItems(actionsToShow, this._shouldShowHeaders(), this._resolver.getResolver()), delegate, anchor, editorDom, this._getActionBarActions(actions, at, options));
    });
  }
  toCoords(position) {
    if (!this._editor.hasModel()) {
      return { x: 0, y: 0 };
    }
    this._editor.revealPosition(position, 1);
    this._editor.render();
    const cursorCoords = this._editor.getScrolledVisiblePosition(position);
    const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
    const x = editorCoords.left + cursorCoords.left;
    const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
    return { x, y };
  }
  _shouldShowHeaders() {
    var _a6;
    const model = (_a6 = this._editor) === null || _a6 === void 0 ? void 0 : _a6.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: model === null || model === void 0 ? void 0 : model.uri });
  }
  _getActionBarActions(actions, at, options) {
    if (options.fromLightbulb) {
      return [];
    }
    const resultActions = actions.documentation.map((command) => {
      var _a6;
      return {
        id: command.id,
        label: command.title,
        tooltip: (_a6 = command.tooltip) !== null && _a6 !== void 0 ? _a6 : "",
        class: void 0,
        enabled: true,
        run: () => {
          var _a7;
          return this._commandService.executeCommand(command.id, ...(_a7 = command.commandArguments) !== null && _a7 !== void 0 ? _a7 : []);
        }
      };
    });
    if (options.includeDisabledActions && actions.validActions.length > 0 && actions.allActions.length !== actions.validActions.length) {
      resultActions.push(this._showDisabled ? {
        id: "hideMoreActions",
        label: localize("hideMoreActions", "Hide Disabled"),
        enabled: true,
        tooltip: "",
        class: void 0,
        run: () => {
          this._showDisabled = false;
          return this.showCodeActionList(actions, at, options);
        }
      } : {
        id: "showMoreActions",
        label: localize("showMoreActions", "Show Disabled"),
        enabled: true,
        tooltip: "",
        class: void 0,
        run: () => {
          this._showDisabled = true;
          return this.showCodeActionList(actions, at, options);
        }
      });
    }
    return resultActions;
  }
}, "CodeActionUi");
_CodeActionUi_disposed = /* @__PURE__ */ new WeakMap();
CodeActionUi = __decorate7([
  __param7(4, IInstantiationService),
  __param7(5, IConfigurationService),
  __param7(6, IActionWidgetService),
  __param7(7, ICommandService)
], CodeActionUi);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
init_nls();
init_contextkey();
init_instantiation();
init_progress();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionModel.js
init_define_process();
init_async();
init_errors();
init_event();
init_lifecycle();
init_resources();
init_contextkey();
init_progress();
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _CodeActionModel_isDisposed;
var SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
var CodeActionOracle = class extends Disposable {
  constructor(_editor, _markerService, _signalChange, _delay = 250) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._signalChange = _signalChange;
    this._delay = _delay;
    this._autoTriggerTimer = this._register(new TimeoutTimer());
    this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
    this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
  }
  trigger(trigger) {
    const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
    return this._createEventAndSignalChange(trigger, selection);
  }
  _onMarkerChanges(resources) {
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (resources.some((resource) => isEqual(resource, model.uri))) {
      this._autoTriggerTimer.cancelAndSet(() => {
        this.trigger({ type: 2, triggerAction: CodeActionTriggerSource.Default });
      }, this._delay);
    }
  }
  _onCursorChange() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: CodeActionTriggerSource.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
    if (!this._editor.hasModel()) {
      return void 0;
    }
    const model = this._editor.getModel();
    const selection = this._editor.getSelection();
    if (selection.isEmpty() && trigger.type === 2) {
      const { lineNumber, column } = selection.getPosition();
      const line = model.getLineContent(lineNumber);
      if (line.length === 0) {
        return void 0;
      } else if (column === 1) {
        if (/\s/.test(line[0])) {
          return void 0;
        }
      } else if (column === model.getLineMaxColumn(lineNumber)) {
        if (/\s/.test(line[line.length - 1])) {
          return void 0;
        }
      } else {
        if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
          return void 0;
        }
      }
    }
    return selection;
  }
  _createEventAndSignalChange(trigger, selection) {
    const model = this._editor.getModel();
    if (!selection || !model) {
      this._signalChange(void 0);
      return void 0;
    }
    const e = {
      trigger,
      selection,
      position: selection.getStartPosition()
    };
    this._signalChange(e);
    return e;
  }
};
__name(CodeActionOracle, "CodeActionOracle");
var CodeActionsState;
(function(CodeActionsState2) {
  CodeActionsState2.Empty = { type: 0 };
  class Triggered {
    constructor(trigger, rangeOrSelection, position, _cancellablePromise) {
      this.trigger = trigger;
      this.rangeOrSelection = rangeOrSelection;
      this.position = position;
      this._cancellablePromise = _cancellablePromise;
      this.type = 1;
      this.actions = _cancellablePromise.catch((e) => {
        if (isCancellationError(e)) {
          return emptyCodeActionSet;
        }
        throw e;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  __name(Triggered, "Triggered");
  CodeActionsState2.Triggered = Triggered;
})(CodeActionsState || (CodeActionsState = {}));
var emptyCodeActionSet = {
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: false
};
var CodeActionModel = class extends Disposable {
  constructor(_editor, _registry, _markerService, contextKeyService, _progressService) {
    super();
    this._editor = _editor;
    this._registry = _registry;
    this._markerService = _markerService;
    this._progressService = _progressService;
    this._codeActionOracle = this._register(new MutableDisposable());
    this._state = CodeActionsState.Empty;
    this._onDidChangeState = this._register(new Emitter());
    this.onDidChangeState = this._onDidChangeState.event;
    _CodeActionModel_isDisposed.set(this, false);
    this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeModel(() => this._update()));
    this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
    this._register(this._registry.onDidChange(() => this._update()));
    this._update();
  }
  dispose() {
    if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      return;
    }
    __classPrivateFieldSet2(this, _CodeActionModel_isDisposed, true, "f");
    super.dispose();
    this.setState(CodeActionsState.Empty, true);
  }
  _update() {
    if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      return;
    }
    this._codeActionOracle.value = void 0;
    this.setState(CodeActionsState.Empty);
    const model = this._editor.getModel();
    if (model && this._registry.has(model) && !this._editor.getOption(84)) {
      const supportedActions = [];
      for (const provider of this._registry.all(model)) {
        if (Array.isArray(provider.providedCodeActionKinds)) {
          supportedActions.push(...provider.providedCodeActionKinds);
        }
      }
      this._supportedCodeActions.set(supportedActions.join(" "));
      this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
        var _a6;
        if (!trigger) {
          this.setState(CodeActionsState.Empty);
          return;
        }
        const actions = createCancelablePromise((token) => getCodeActions(this._registry, model, trigger.selection, trigger.trigger, Progress.None, token));
        if (trigger.trigger.type === 1) {
          (_a6 = this._progressService) === null || _a6 === void 0 ? void 0 : _a6.showWhile(actions, 250);
        }
        this.setState(new CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions));
      }, void 0);
      this._codeActionOracle.value.trigger({ type: 2, triggerAction: CodeActionTriggerSource.Default });
    } else {
      this._supportedCodeActions.reset();
    }
  }
  trigger(trigger) {
    var _a6;
    (_a6 = this._codeActionOracle.value) === null || _a6 === void 0 ? void 0 : _a6.trigger(trigger);
  }
  setState(newState, skipNotify) {
    if (newState === this._state) {
      return;
    }
    if (this._state.type === 1) {
      this._state.cancel();
    }
    this._state = newState;
    if (!skipNotify && !__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      this._onDidChangeState.fire(newState);
    }
  }
};
__name(CodeActionModel, "CodeActionModel");
_CodeActionModel_isDisposed = /* @__PURE__ */ new WeakMap();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionCommands.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
__name(contextKeyForSupportedActions, "contextKeyForSupportedActions");
function refactorTrigger(editor2, userArgs, preview, codeActionFrom) {
  const args = CodeActionCommandArgs.fromUser(userArgs, {
    kind: CodeActionKind.Refactor,
    apply: "never"
  });
  return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
    include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
    onlyIncludePreferredActions: args.preferred
  }, args.apply, preview, codeActionFrom);
}
__name(refactorTrigger, "refactorTrigger");
var argsSchema = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    "kind": {
      type: "string",
      description: localize("args.schema.kind", "Kind of the code action to run.")
    },
    "apply": {
      type: "string",
      description: localize("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: ["first", "ifSingle", "never"],
      enumDescriptions: [
        localize("args.schema.apply.first", "Always apply the first returned code action."),
        localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        localize("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    "preferred": {
      type: "boolean",
      default: false,
      description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
var CodeActionController = /* @__PURE__ */ __name(class CodeActionController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CodeActionController2.ID);
  }
  constructor(editor2, markerService, contextKeyService, progressService, _instantiationService, languageFeaturesService) {
    super();
    this._instantiationService = _instantiationService;
    this._editor = editor2;
    this._model = this._register(new CodeActionModel(this._editor, languageFeaturesService.codeActionProvider, markerService, contextKeyService, progressService));
    this._register(this._model.onDidChangeState((newState) => this.update(newState)));
    this._ui = new Lazy(() => this._register(_instantiationService.createInstance(CodeActionUi, editor2, QuickFixAction.Id, AutoFixAction.Id, {
      applyCodeAction: (action, retrigger, preview) => __awaiter7(this, void 0, void 0, function* () {
        try {
          yield this._applyCodeAction(action, preview);
        } finally {
          if (retrigger) {
            this._trigger({ type: 2, triggerAction: CodeActionTriggerSource.QuickFix, filter: {} });
          }
        }
      })
    })));
  }
  update(newState) {
    this._ui.getValue().update(newState);
  }
  showCodeActions(_trigger, actions, at) {
    return this._ui.getValue().showCodeActionList(actions, at, { includeDisabledActions: false, fromLightbulb: false });
  }
  manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply, preview) {
    var _a6;
    if (!this._editor.hasModel()) {
      return;
    }
    (_a6 = MessageController.get(this._editor)) === null || _a6 === void 0 ? void 0 : _a6.closeMessage();
    const triggerPosition = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction, filter, autoApply, context: { notAvailableMessage, position: triggerPosition }, preview });
  }
  _trigger(trigger) {
    return this._model.trigger(trigger);
  }
  _applyCodeAction(action, preview) {
    return this._instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.FromCodeActions, { preview, editor: this._editor });
  }
}, "CodeActionController");
CodeActionController.ID = "editor.contrib.codeActionController";
CodeActionController = __decorate8([
  __param8(1, IMarkerService),
  __param8(2, IContextKeyService),
  __param8(3, IEditorProgressService),
  __param8(4, IInstantiationService),
  __param8(5, ILanguageFeaturesService)
], CodeActionController);
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply, preview = false, triggerAction = CodeActionTriggerSource.Default) {
  if (editor2.hasModel()) {
    const controller = CodeActionController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.manualTriggerAtCurrentPosition(notAvailableMessage, triggerAction, filter, autoApply, preview);
  }
}
__name(triggerCodeActionsForEditorSelection, "triggerCodeActionsForEditorSelection");
var QuickFixAction = class extends EditorAction {
  constructor() {
    super({
      id: QuickFixAction.Id,
      label: localize("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 84,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0, false, CodeActionTriggerSource.QuickFix);
  }
};
__name(QuickFixAction, "QuickFixAction");
QuickFixAction.Id = "editor.action.quickFix";
var CodeActionCommand = class extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  runEditorCommand(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
__name(CodeActionCommand, "CodeActionCommand");
var RefactorAction = class extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
        },
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
      },
      description: {
        description: "Refactor...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    return refactorTrigger(editor2, userArgs, false, CodeActionTriggerSource.Refactor);
  }
};
__name(RefactorAction, "RefactorAction");
var RefactorPreview = class extends EditorAction {
  constructor() {
    super({
      id: refactorPreviewCommandId,
      label: localize("refactor.preview.label", "Refactor with Preview..."),
      alias: "Refactor Preview...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Refactor Preview...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    return refactorTrigger(editor2, userArgs, true, CodeActionTriggerSource.RefactorPreview);
  }
};
__name(RefactorPreview, "RefactorPreview");
var SourceAction = class extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
      },
      description: {
        description: "Source Action...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Source,
      apply: "never"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
      include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply, void 0, CodeActionTriggerSource.SourceAction);
  }
};
__name(SourceAction, "SourceAction");
var OrganizeImportsAction = class extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 45,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.organize.noneMessage", "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle", void 0, CodeActionTriggerSource.OrganizeImports);
  }
};
__name(OrganizeImportsAction, "OrganizeImportsAction");
var FixAllAction = class extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("fixAll.noneMessage", "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle", void 0, CodeActionTriggerSource.FixAll);
  }
};
__name(FixAllAction, "FixAllAction");
var AutoFixAction = class extends EditorAction {
  constructor() {
    super({
      id: AutoFixAction.Id,
      label: localize("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 84,
        mac: {
          primary: 2048 | 512 | 84
        },
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: CodeActionKind.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle", void 0, CodeActionTriggerSource.AutoFix);
  }
};
__name(AutoFixAction, "AutoFixAction");
AutoFixAction.Id = "editor.action.autoFix";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeActionContributions.js
init_nls();
init_configurationRegistry();
init_platform2();
registerEditorContribution(CodeActionController.ID, CodeActionController, 3);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(RefactorPreview);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());
Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
  "editor.codeActionWidget.showHeaders": {
    type: "boolean",
    scope: 5,
    description: localize("showCodeActionHeaders", "Enable/disable showing group headers in the Code Action menu."),
    default: true
  }
} }));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_define_process();
init_async();
init_errors();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelens.js
init_define_process();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_model();
init_commands();
init_languageFeatures();
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensModel = class {
  constructor() {
    this.lenses = [];
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  get isDisposed() {
    return this._disposables.isDisposed;
  }
  add(list, provider) {
    this._disposables.add(list);
    for (const symbol of list.lenses) {
      this.lenses.push({ symbol, provider });
    }
  }
};
__name(CodeLensModel, "CodeLensModel");
function getCodeLensModel(registry, model, token) {
  return __awaiter8(this, void 0, void 0, function* () {
    const provider = registry.ordered(model);
    const providerRanks = /* @__PURE__ */ new Map();
    const result = new CodeLensModel();
    const promises = provider.map((provider2, i) => __awaiter8(this, void 0, void 0, function* () {
      providerRanks.set(provider2, i);
      try {
        const list = yield Promise.resolve(provider2.provideCodeLenses(model, token));
        if (list) {
          result.add(list, provider2);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    yield Promise.all(promises);
    result.lenses = result.lenses.sort((a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
__name(getCodeLensModel, "getCodeLensModel");
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
  let [uri, itemResolveCount] = args;
  assertType(URI.isUri(uri));
  assertType(typeof itemResolveCount === "number" || !itemResolveCount);
  const { codeLensProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensModel(codeLensProvider, model, CancellationToken.None).then((value) => {
    disposables.add(value);
    const resolve = [];
    for (const item of value.lenses) {
      if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codeLensCache.js
init_define_process();
init_async();
init_functional();
init_map();
init_range();
init_extensions();
init_instantiation();
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
};
__name(CacheItem, "CacheItem");
var CodeLensCache = /* @__PURE__ */ __name(class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenIdle(() => storageService.remove(oldkey, 1));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    once(storageService.onWillSaveState)((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        storageService.store(key, this._serialize(), 1, 1);
      }
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      var _a6;
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && { id: "", title: (_a6 = item2.symbol.command) === null || _a6 === void 0 ? void 0 : _a6.title }
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({ lenses: copyItems, dispose: () => {
    } }, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  _serialize() {
    const data = /* @__PURE__ */ Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = /* @__PURE__ */ new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({ range: new Range(line, 1, line, 11) });
        }
        const model = new CodeLensModel();
        model.add({ lenses, dispose() {
        } }, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch (_a6) {
    }
  }
}, "CodeLensCache");
CodeLensCache = __decorate9([
  __param9(0, IStorageService)
], CodeLensCache);
registerSingleton(ICodeLensCache, CodeLensCache, 1);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensWidget.js
init_define_process();
init_dom();
init_range();
init_textModel();
var CodeLensViewZone = class {
  constructor(afterLineNumber, heightInPx, onHeight) {
    this.afterColumn = 1073741824;
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = heightInPx;
    this._onHeight = onHeight;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
};
__name(CodeLensViewZone, "CodeLensViewZone");
var CodeLensContentWidget = class {
  constructor(editor2, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = /* @__PURE__ */ new Map();
    this._isEmpty = true;
    this._editor = editor2;
    this._id = `codelens.widget-${CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    const children = [];
    let hasSymbol = false;
    for (let i = 0; i < lenses.length; i++) {
      const lens = lenses[i];
      if (!lens) {
        continue;
      }
      hasSymbol = true;
      if (lens.command) {
        const title = renderLabelWithIcons(lens.command.title.trim());
        if (lens.command.id) {
          children.push($("a", { id: String(i), title: lens.command.tooltip, role: "button" }, ...title));
          this._commands.set(String(i), lens.command);
        } else {
          children.push($("span", { title: lens.command.tooltip }, ...title));
        }
        if (i + 1 < lenses.length) {
          children.push($("span", void 0, "\xA0|\xA0"));
        }
      }
    }
    if (!hasSymbol) {
      reset(this._domNode, $("span", void 0, "no commands"));
    } else {
      reset(this._domNode, ...children);
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: { lineNumber: line, column },
      preference: [1]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
};
__name(CodeLensContentWidget, "CodeLensContentWidget");
CodeLensContentWidget._idPool = 0;
var CodeLensHelper = class {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration2, callback) {
    this._addDecorations.push(decoration2);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    const resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, len = resultingDecorations.length; i < len; i++) {
      this._addDecorationsCallbacks[i](resultingDecorations[i]);
    }
  }
};
__name(CodeLensHelper, "CodeLensHelper");
var CodeLensWidget = class {
  constructor(data, editor2, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
    this._isDisposed = false;
    this._editor = editor2;
    this._data = data;
    this._decorationIds = [];
    let range;
    const lenses = [];
    this._data.forEach((codeLensData, i) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
      if (!range) {
        range = Range.lift(codeLensData.symbol.range);
      } else {
        range = Range.plusRange(range, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    } else {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    viewZoneChangeAccessor === null || viewZoneChangeAccessor === void 0 ? void 0 : viewZoneChangeAccessor.removeZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i) => {
      const range = this._editor.getModel().getDecorationRange(id);
      const symbol = this._data[i].symbol;
      return !!(range && Range.isEmpty(symbol.range) === range.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
    });
  }
  updateHeight(height, viewZoneChangeAccessor) {
    this._viewZone.heightInPx = height;
    viewZoneChangeAccessor.layoutZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  computeIfNecessary(model) {
    if (!this._viewZone.isVisible()) {
      return null;
    }
    for (let i = 0; i < this._decorationIds.length; i++) {
      const range = model.getDecorationRange(this._decorationIds[i]);
      if (range) {
        this._data[i].symbol.range = range;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i = 0; i < this._data.length; i++) {
      const resolved = symbols[i];
      if (resolved) {
        const { symbol } = this._data[i];
        symbol.command = resolved.command || symbol.command;
      }
    }
  }
  getCommand(link) {
    var _a6;
    return (_a6 = this._contentWidget) === null || _a6 === void 0 ? void 0 : _a6.getCommand(link);
  }
  getLineNumber() {
    const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range) {
      return range.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range) {
        this._viewZone.afterLineNumber = range.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
};
__name(CodeLensWidget, "CodeLensWidget");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/codelens/browser/codelensController.js
init_nls();
init_commands();
init_languageFeatureDebounce();
init_languageFeatures();
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensContribution = /* @__PURE__ */ __name(class CodeLensContribution2 {
  constructor(_editor, _languageFeaturesService, debounceService, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._disposables = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._oldCodeLensModels = new DisposableStore();
    this._provideCodeLensDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensProvide", { min: 250 });
    this._resolveCodeLensesDebounce = debounceService.for(_languageFeaturesService.codeLensProvider, "CodeLensResolve", { min: 250, salt: "resolve" });
    this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDebounce.default());
    this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45) || e.hasChanged(16) || e.hasChanged(15)) {
        this._updateLensStyle();
      }
      if (e.hasChanged(14)) {
        this._onModelChange();
      }
    }));
    this._disposables.add(_languageFeaturesService.codeLensProvider.onDidChange(this._onModelChange, this));
    this._onModelChange();
    this._updateLensStyle();
  }
  dispose() {
    var _a6;
    this._localDispose();
    this._disposables.dispose();
    this._oldCodeLensModels.dispose();
    (_a6 = this._currentCodeLensModel) === null || _a6 === void 0 ? void 0 : _a6.dispose();
  }
  _getLayoutInfo() {
    const lineHeightFactor = Math.max(1.3, this._editor.getOption(61) / this._editor.getOption(47));
    let fontSize = this._editor.getOption(16);
    if (!fontSize || fontSize < 5) {
      fontSize = this._editor.getOption(47) * 0.9 | 0;
    }
    return {
      fontSize,
      codeLensHeight: fontSize * lineHeightFactor | 0
    };
  }
  _updateLensStyle() {
    const { codeLensHeight, fontSize } = this._getLayoutInfo();
    const fontFamily = this._editor.getOption(15);
    const editorFontInfo = this._editor.getOption(45);
    const { style } = this._editor.getContainerDomNode();
    style.setProperty("--vscode-editorCodeLens-lineHeight", `${codeLensHeight}px`);
    style.setProperty("--vscode-editorCodeLens-fontSize", `${fontSize}px`);
    style.setProperty("--vscode-editorCodeLens-fontFeatureSettings", editorFontInfo.fontFeatureSettings);
    if (fontFamily) {
      style.setProperty("--vscode-editorCodeLens-fontFamily", fontFamily);
      style.setProperty("--vscode-editorCodeLens-fontFamilyDefault", EDITOR_FONT_DEFAULTS.fontFamily);
    }
    this._editor.changeViewZones((accessor) => {
      for (const lens of this._lenses) {
        lens.updateHeight(codeLensHeight, accessor);
      }
    });
  }
  _localDispose() {
    var _a6, _b2, _c2;
    (_a6 = this._getCodeLensModelPromise) === null || _a6 === void 0 ? void 0 : _a6.cancel();
    this._getCodeLensModelPromise = void 0;
    (_b2 = this._resolveCodeLensesPromise) === null || _b2 === void 0 ? void 0 : _b2.cancel();
    this._resolveCodeLensesPromise = void 0;
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    (_c2 = this._currentCodeLensModel) === null || _c2 === void 0 ? void 0 : _c2.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._editor.getOption(14)) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!this._languageFeaturesService.codeLensProvider.has(model)) {
      if (cachedLenses) {
        this._localToDispose.add(disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3));
      }
      return;
    }
    for (const provider of this._languageFeaturesService.codeLensProvider.all(model)) {
      if (typeof provider.onDidChange === "function") {
        const registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const scheduler = new RunOnceScheduler(() => {
      var _a6;
      const t1 = Date.now();
      (_a6 = this._getCodeLensModelPromise) === null || _a6 === void 0 ? void 0 : _a6.cancel();
      this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(this._languageFeaturesService.codeLensProvider, model, token));
      this._getCodeLensModelPromise.then((result) => {
        if (this._currentCodeLensModel) {
          this._oldCodeLensModels.add(this._currentCodeLensModel);
        }
        this._currentCodeLensModel = result;
        this._codeLensCache.put(model, result);
        const newDelay = this._provideCodeLensDebounce.update(model, Date.now() - t1);
        scheduler.delay = newDelay;
        this._renderCodeLensSymbols(result);
        this._resolveCodeLensesInViewportSoon();
      }, onUnexpectedError);
    }, this._provideCodeLensDebounce.get(model));
    this._localToDispose.add(scheduler);
    this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          const toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          const helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        this._resolveCodeLensesInViewportSoon();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseDown((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
        target = target.parentElement;
      }
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
        for (const lens of this._lenses) {
          const command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses.length = 0;
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    const maxLineNumber = this._editor.getModel().getLineCount();
    const groups = [];
    let lastGroup;
    for (const symbol of symbols.lenses) {
      const line = symbol.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol);
      } else {
        lastGroup = [symbol];
        groups.push(lastGroup);
      }
    }
    if (!groups.length && !this._lenses.length) {
      return;
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    const layoutInfo = this._getLayoutInfo();
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          const symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          const codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    const model = this._editor.getModel();
    if (model) {
      this._resolveCodeLensesScheduler.schedule();
    }
  }
  _resolveCodeLensesInViewport() {
    var _a6;
    (_a6 = this._resolveCodeLensesPromise) === null || _a6 === void 0 ? void 0 : _a6.cancel();
    this._resolveCodeLensesPromise = void 0;
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      return;
    }
    const t1 = Date.now();
    const resolvePromise = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i2) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
              resolvedSymbols[i2] = symbol;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i2] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
            lenses[i].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._resolveCodeLensesPromise = resolvePromise;
    this._resolveCodeLensesPromise.then(() => {
      const newDelay = this._resolveCodeLensesDebounce.update(model, Date.now() - t1);
      this._resolveCodeLensesScheduler.delay = newDelay;
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    });
  }
  getModel() {
    return this._currentCodeLensModel;
  }
}, "CodeLensContribution");
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate10([
  __param10(1, ILanguageFeaturesService),
  __param10(2, ILanguageFeatureDebounceService),
  __param10(3, ICommandService),
  __param10(4, INotificationService),
  __param10(5, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(CodeLensContribution.ID, CodeLensContribution, 1);
registerEditorAction(/* @__PURE__ */ __name(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  run(accessor, editor2) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const quickInputService = accessor.get(IQuickInputService);
      const commandService = accessor.get(ICommandService);
      const notificationService = accessor.get(INotificationService);
      const lineNumber = editor2.getSelection().positionLineNumber;
      const codelensController = editor2.getContribution(CodeLensContribution.ID);
      if (!codelensController) {
        return;
      }
      const model = codelensController.getModel();
      if (!model) {
        return;
      }
      const items = [];
      for (const lens of model.lenses) {
        if (lens.symbol.command && lens.symbol.range.startLineNumber === lineNumber) {
          items.push({
            label: lens.symbol.command.title,
            command: lens.symbol.command
          });
        }
      }
      if (items.length === 0) {
        return;
      }
      const item = yield quickInputService.pick(items, { canPickMany: false });
      if (!item) {
        return;
      }
      if (model.isDisposed) {
        return yield commandService.executeCommand(this.id);
      }
      try {
        yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
      } catch (err) {
        notificationService.error(err);
      }
    });
  }
}, "ShowLensesInCurrentLine"));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorContributions.js
init_define_process();
init_lifecycle();
init_editorExtensions();
init_range();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
init_define_process();
init_async();
init_color();
init_errors();
init_lifecycle();
init_stopwatch();
init_strings();
init_editorExtensions();
init_range();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/color.js
init_define_process();
init_cancellation();
init_errors();
init_uri();
init_range();
init_model();
init_commands();
init_languageFeatures();
function getColors(registry, model, token) {
  const colors = [];
  const providers = registry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, token)).then((result) => {
    if (Array.isArray(result)) {
      for (const colorInfo of result) {
        colors.push({ colorInfo, provider });
      }
    }
  }));
  return Promise.all(promises).then(() => colors);
}
__name(getColors, "getColors");
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
__name(getColorPresentations, "getColorPresentations");
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const rawCIs = [];
  const providers = colorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      for (const ci of result) {
        rawCIs.push({ range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha] });
      }
    }
  }));
  return Promise.all(promises).then(() => rawCIs);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
  const [color, context] = args;
  const { uri, range } = context;
  if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
    throw illegalArgument();
  }
  const [red, green, blue, alpha] = color;
  const { colorProvider: colorProviderRegistry } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const colorInfo = {
    range,
    color: { red, green, blue, alpha }
  };
  const presentations = [];
  const providers = colorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideColorPresentations(model, colorInfo, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      presentations.push(...result);
    }
  }));
  return Promise.all(promises).then(() => presentations);
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorDetector.js
init_configuration();
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ColorDecorationInjectedTextMarker = /* @__PURE__ */ Object.create({});
var MAX_DECORATORS = 500;
var ColorDetector = /* @__PURE__ */ __name(class ColorDetector2 extends Disposable {
  constructor(_editor, _configurationService, _languageFeaturesService, languageFeatureDebounceService) {
    super();
    this._editor = _editor;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = /* @__PURE__ */ new Map();
    this._colorDecoratorIds = this._editor.createDecorationsCollection();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._colorDecorationClassRefs = this._register(new DisposableStore());
    this._debounceInformation = languageFeatureDebounceService.for(_languageFeaturesService.colorProvider, "Document Colors", { min: ColorDetector2.RECOMPUTE_TIME });
    this._register(_editor.onDidChangeModel(() => {
      this._isEnabled = this.isEnabled();
      this.onModelChanged();
    }));
    this._register(_editor.onDidChangeModelLanguage(() => this.onModelChanged()));
    this._register(_languageFeaturesService.colorProvider.onDidChange(() => this.onModelChanged()));
    this._register(_editor.onDidChangeConfiguration(() => {
      const prevIsEnabled = this._isEnabled;
      this._isEnabled = this.isEnabled();
      if (prevIsEnabled !== this._isEnabled) {
        if (this._isEnabled) {
          this.onModelChanged();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isEnabled = this.isEnabled();
    this.onModelChanged();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageId();
    const deprecatedConfig = this._configurationService.getValue(languageId);
    if (deprecatedConfig && typeof deprecatedConfig === "object") {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(17);
  }
  static get(editor2) {
    return editor2.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  onModelChanged() {
    this.stop();
    if (!this._isEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.colorProvider.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, this._debounceInformation.get(model));
      }
    }));
    this.beginCompute();
  }
  beginCompute() {
    this._computePromise = createCancelablePromise((token) => __awaiter10(this, void 0, void 0, function* () {
      const model = this._editor.getModel();
      if (!model) {
        return Promise.resolve([]);
      }
      const sw = new StopWatch(false);
      const colors = yield getColors(this._languageFeaturesService.colorProvider, model, token);
      this._debounceInformation.update(model, sw.elapsed());
      return colors;
    }));
    this._computePromise.then((colorInfos) => {
      this.updateDecorations(colorInfos);
      this.updateColorDecorators(colorInfos);
      this._computePromise = null;
    }, onUnexpectedError);
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._editor.changeDecorations((changeAccessor) => {
      this._decorationsIds = changeAccessor.deltaDecorations(this._decorationsIds, decorations);
      this._colorDatas = /* @__PURE__ */ new Map();
      this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
    });
  }
  updateColorDecorators(colorData) {
    this._colorDecorationClassRefs.clear();
    const decorations = [];
    for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
      const { red, green, blue, alpha } = colorData[i].colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: color
      }));
      decorations.push({
        range: {
          startLineNumber: colorData[i].colorInfo.range.startLineNumber,
          startColumn: colorData[i].colorInfo.range.startColumn,
          endLineNumber: colorData[i].colorInfo.range.endLineNumber,
          endColumn: colorData[i].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: noBreakWhitespace,
            inlineClassName: `${ref.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: true,
            attachedData: ColorDecorationInjectedTextMarker
          }
        }
      });
    }
    this._colorDecoratorIds.set(decorations);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds);
    this._decorationsIds = [];
    this._colorDecoratorIds.clear();
    this._colorDecorationClassRefs.clear();
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
  isColorDecoration(decoration2) {
    return this._colorDecoratorIds.has(decoration2);
  }
}, "ColorDetector");
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = __decorate11([
  __param11(1, IConfigurationService),
  __param11(2, ILanguageFeaturesService),
  __param11(3, ILanguageFeatureDebounceService)
], ColorDetector);
registerEditorContribution(ColorDetector.ID, ColorDetector, 1);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
init_define_process();
init_async();
init_cancellation();
init_color();
init_lifecycle();
init_range();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerModel.js
init_define_process();
init_event();
var ColorPickerModel = class {
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    for (let i = 0; i < this.colorPresentations.length; i++) {
      if (originalText.toLowerCase() === this.colorPresentations[i].label) {
        this.presentationIndex = i;
        this._onDidChangePresentation.fire(this.presentation);
        break;
      }
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
};
__name(ColorPickerModel, "ColorPickerModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorPickerWidget.js
init_define_process();
init_browser();
init_dom();
init_color();
init_event();
init_lifecycle();
init_nls();
init_colorRegistry();
var $2 = $;
var ColorPickerHeader = class extends Disposable {
  constructor(container, model, themeService) {
    super();
    this.model = model;
    this.domNode = $2(".colorpicker-header");
    append(container, this.domNode);
    this.pickedColorNode = append(this.domNode, $2(".picked-color"));
    const tooltip = localize("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this.pickedColorNode.setAttribute("title", tooltip);
    const colorBox = append(this.domNode, $2(".original-color"));
    colorBox.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
    this._register(themeService.onDidColorThemeChange((theme) => {
      this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
    }));
    this._register(addDisposableListener(this.pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(colorBox, EventType.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
    this.pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
    this.pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "";
    this.pickedColorNode.prepend($2(".codicon.codicon-color-mode"));
  }
};
__name(ColorPickerHeader, "ColorPickerHeader");
var ColorPickerBody = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this.domNode = $2(".colorpicker-body");
    append(container, this.domNode);
    this.saturationBox = new SaturationBox(this.domNode, this.model, this.pixelRatio);
    this._register(this.saturationBox);
    this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this.saturationBox.onColorFlushed(this.flushColor, this));
    this.opacityStrip = new OpacityStrip(this.domNode, this.model);
    this._register(this.opacityStrip);
    this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));
    this.hueStrip = new HueStrip(this.domNode, this.model);
    this._register(this.hueStrip);
    this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s, v }) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h = (1 - value) * 360;
    this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
  }
  layout() {
    this.saturationBox.layout();
    this.opacityStrip.layout();
    this.hueStrip.layout();
  }
};
__name(ColorPickerBody, "ColorPickerBody");
var SaturationBox = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = $2(".saturation-wrap");
    append(container, this.domNode);
    this.canvas = document.createElement("canvas");
    this.canvas.className = "saturation-box";
    append(this.domNode, this.canvas);
    this.selection = $2(".saturation-selection");
    append(this.domNode, this.selection);
    this.layout();
    this._register(addDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    this.monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangePosition(event.pageX - origin.left, event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({ s, v });
  }
  layout() {
    this.width = this.domNode.offsetWidth;
    this.height = this.domNode.offsetHeight;
    this.canvas.width = this.width * this.pixelRatio;
    this.canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this.canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this.canvas.width, this.canvas.height);
    ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor() {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
  }
};
__name(SaturationBox, "SaturationBox");
var Strip = class extends Disposable {
  constructor(container, model) {
    super();
    this.model = model;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = append(container, $2(".strip"));
    this.overlay = append(this.domNode, $2(".overlay"));
    this.slider = append(this.domNode, $2(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableListener(this.domNode, EventType.POINTER_DOWN, (e) => this.onPointerDown(e)));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element)) {
      return;
    }
    const monitor = this._register(new GlobalPointerMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    this.domNode.classList.add("grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.pointerId, e.buttons, (event) => this.onDidChangeTop(event.pageY - origin.top), () => null);
    const pointerUpListener = addDisposableListener(document, EventType.POINTER_UP, () => {
      this._onColorFlushed.fire();
      pointerUpListener.dispose();
      monitor.stopMonitoring(true);
      this.domNode.classList.remove("grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
};
__name(Strip, "Strip");
var OpacityStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    this.domNode.classList.add("opacity-strip");
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    const { r, g, b } = color.rgba;
    const opaque = new Color(new RGBA(r, g, b, 1));
    const transparent2 = new Color(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
};
__name(OpacityStrip, "OpacityStrip");
var HueStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    this.domNode.classList.add("hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
};
__name(HueStrip, "HueStrip");
var ColorPickerWidget = class extends Widget {
  constructor(container, model, pixelRatio, themeService) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(PixelRatio.onDidChange(() => this.layout()));
    const element = $2(".colorpicker-widget");
    container.appendChild(element);
    const header = new ColorPickerHeader(element, this.model, themeService);
    this.body = new ColorPickerBody(element, this.model, this.pixelRatio);
    this._register(header);
    this._register(this.body);
  }
  layout() {
    this.body.layout();
  }
};
__name(ColorPickerWidget, "ColorPickerWidget");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorHoverParticipant.js
init_themeService();
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ColorHover = class {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
    this.forceShowAtRange = true;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
__name(ColorHover, "ColorHover");
var ColorHoverParticipant = /* @__PURE__ */ __name(class ColorHoverParticipant2 {
  constructor(_editor, _themeService) {
    this._editor = _editor;
    this._themeService = _themeService;
    this.hoverOrdinal = 1;
  }
  computeSync(anchor, lineDecorations) {
    return [];
  }
  computeAsync(anchor, lineDecorations, token) {
    return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
  }
  _computeAsync(anchor, lineDecorations, token) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return [];
      }
      const colorDetector = ColorDetector.get(this._editor);
      if (!colorDetector) {
        return [];
      }
      for (const d of lineDecorations) {
        if (!colorDetector.isColorDecoration(d)) {
          continue;
        }
        const colorData = colorDetector.getColorData(d.range.getStartPosition());
        if (colorData) {
          const colorHover = yield this._createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider);
          return [colorHover];
        }
      }
      return [];
    });
  }
  _createColorHover(editorModel, colorInfo, provider) {
    return __awaiter11(this, void 0, void 0, function* () {
      const originalText = editorModel.getValueInRange(colorInfo.range);
      const { red, green, blue, alpha } = colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = new Color(rgba);
      const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
      const model = new ColorPickerModel(color, [], 0);
      model.colorPresentations = colorPresentations || [];
      model.guessColorPresentation(color, originalText);
      return new ColorHover(this, Range.lift(colorInfo.range), model, provider);
    });
  }
  renderHoverParts(context, hoverParts) {
    if (hoverParts.length === 0 || !this._editor.hasModel()) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    const colorHover = hoverParts[0];
    const editorModel = this._editor.getModel();
    const model = colorHover.model;
    const widget = disposables.add(new ColorPickerWidget(context.fragment, model, this._editor.getOption(134), this._themeService));
    context.setColorPicker(widget);
    let range = new Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
    const updateEditorModel = /* @__PURE__ */ __name(() => {
      let textEdits;
      let newRange;
      if (model.presentation.textEdit) {
        textEdits = [model.presentation.textEdit];
        newRange = new Range(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
        const trackedRange = this._editor.getModel()._setTrackedRange(null, newRange, 3);
        this._editor.pushUndoStop();
        this._editor.executeEdits("colorpicker", textEdits);
        newRange = this._editor.getModel()._getTrackedRange(trackedRange) || newRange;
      } else {
        textEdits = [{ range, text: model.presentation.label, forceMoveMarkers: false }];
        newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
        this._editor.pushUndoStop();
        this._editor.executeEdits("colorpicker", textEdits);
      }
      if (model.presentation.additionalTextEdits) {
        textEdits = [...model.presentation.additionalTextEdits];
        this._editor.executeEdits("colorpicker", textEdits);
        context.hide();
      }
      this._editor.pushUndoStop();
      range = newRange;
    }, "updateEditorModel");
    const updateColorPresentations = /* @__PURE__ */ __name((color) => {
      return getColorPresentations(editorModel, {
        range,
        color: {
          red: color.rgba.r / 255,
          green: color.rgba.g / 255,
          blue: color.rgba.b / 255,
          alpha: color.rgba.a
        }
      }, colorHover.provider, CancellationToken.None).then((colorPresentations) => {
        model.colorPresentations = colorPresentations || [];
      });
    }, "updateColorPresentations");
    disposables.add(model.onColorFlushed((color) => {
      updateColorPresentations(color).then(updateEditorModel);
    }));
    disposables.add(model.onDidChangeColor(updateColorPresentations));
    return disposables;
  }
}, "ColorHoverParticipant");
ColorHoverParticipant = __decorate12([
  __param12(1, IThemeService)
], ColorHoverParticipant);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
init_define_process();
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_language();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
init_define_process();
init_async();
init_errors();
init_lifecycle();
init_types();
init_editorState();
init_editorExtensions();
init_range();
init_language();
init_resolverService();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/clickLinkGesture.js
init_define_process();
init_event();
init_lifecycle();
init_platform();
function hasModifier(e, modifier) {
  return !!e[modifier];
}
__name(hasModifier, "hasModifier");
var ClickLinkMouseEvent = class {
  constructor(source, opts) {
    this.target = source.target;
    this.isLeftClick = source.event.leftButton;
    this.isMiddleClick = source.event.middleButton;
    this.isRightClick = source.event.rightButton;
    this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
    this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
    this.isNoneOrSingleMouseDown = source.event.detail <= 1;
  }
};
__name(ClickLinkMouseEvent, "ClickLinkMouseEvent");
var ClickLinkKeyboardEvent = class {
  constructor(source, opts) {
    this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
    this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
    this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
  }
};
__name(ClickLinkKeyboardEvent, "ClickLinkKeyboardEvent");
var ClickLinkOptions = class {
  constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
    this.triggerKey = triggerKey;
    this.triggerModifier = triggerModifier;
    this.triggerSideBySideKey = triggerSideBySideKey;
    this.triggerSideBySideModifier = triggerSideBySideModifier;
  }
  equals(other) {
    return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
  }
};
__name(ClickLinkOptions, "ClickLinkOptions");
function createOptions(multiCursorModifier) {
  if (multiCursorModifier === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey");
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey");
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
__name(createOptions, "createOptions");
var ClickLinkGesture = class extends Disposable {
  constructor(editor2, alwaysFireOnMouseUp) {
    super();
    this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
    this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
    this._onExecute = this._register(new Emitter());
    this.onExecute = this._onExecute.event;
    this._onCancel = this._register(new Emitter());
    this.onCancel = this._onCancel.event;
    this._editor = editor2;
    this._alwaysFireExecuteOnMouseUp = alwaysFireOnMouseUp;
    this._opts = createOptions(this._editor.getOption(72));
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._lineNumberOnMouseDown = 0;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(72)) {
        const newOpts = createOptions(this._editor.getOption(72));
        if (this._opts.equals(newOpts)) {
          return;
        }
        this._opts = newOpts;
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._onCancel.fire();
      }
    }));
    this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onMouseDrag(() => this._resetHandler()));
    this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
    this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
    this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || e.scrollLeftChanged) {
        this._resetHandler();
      }
    }));
  }
  _onDidChangeCursorSelection(e) {
    if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
      this._resetHandler();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    this._lastMouseMoveEvent = mouseEvent;
    this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
  }
  _onEditorMouseDown(mouseEvent) {
    this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
  }
  _onEditorMouseUp(mouseEvent) {
    const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
    if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber || this._alwaysFireExecuteOnMouseUp) {
      this._onExecute.fire(mouseEvent);
    }
  }
  _onEditorKeyDown(e) {
    if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
      this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
    } else if (e.hasTriggerModifier) {
      this._onCancel.fire();
    }
  }
  _onEditorKeyUp(e) {
    if (e.keyCodeIsTriggerKey) {
      this._onCancel.fire();
    }
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._onCancel.fire();
  }
};
__name(ClickLinkGesture, "ClickLinkGesture");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js
init_define_process();
init_dom();
init_actions();
init_codicons();
init_color();
init_event();
init_objects();
init_editorExtensions();
init_codeEditorService();

// ../../node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js
init_define_process();
init_objects();
init_codeEditorService();
init_commands();
init_contextkey();
init_instantiation();
init_themeService();
init_languageConfigurationRegistry();
init_languageFeatures();
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EmbeddedCodeEditorWidget = /* @__PURE__ */ __name(class EmbeddedCodeEditorWidget2 extends CodeEditorWidget {
  constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService) {
    super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService, languageConfigurationService, languageFeaturesService);
    this._parentEditor = parentEditor;
    this._overwriteOptions = options;
    super.updateOptions(this._overwriteOptions);
    this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions());
    super.updateOptions(this._overwriteOptions);
  }
  updateOptions(newOptions) {
    mixin(this._overwriteOptions, newOptions, true);
    super.updateOptions(this._overwriteOptions);
  }
}, "EmbeddedCodeEditorWidget");
EmbeddedCodeEditorWidget = __decorate13([
  __param13(3, IInstantiationService),
  __param13(4, ICodeEditorService),
  __param13(5, ICommandService),
  __param13(6, IContextKeyService),
  __param13(7, IThemeService),
  __param13(8, INotificationService),
  __param13(9, IAccessibilityService),
  __param13(10, ILanguageConfigurationService),
  __param13(11, ILanguageFeaturesService)
], EmbeddedCodeEditorWidget);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/browser/zoneWidget.js
init_define_process();
init_dom();
init_color();
init_lifecycle();
init_objects();
init_range();
init_textModel();
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions = {
  showArrow: true,
  showFrame: true,
  className: "",
  frameColor: defaultColor,
  arrowColor: defaultColor,
  keepEditorSelection: false
};
var WIDGET_ID = "vs.editor.contrib.zoneWidget";
var ViewZoneDelegate = class {
  constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
    this.id = "";
    this.domNode = domNode;
    this.afterLineNumber = afterLineNumber;
    this.afterColumn = afterColumn;
    this.heightInLines = heightInLines;
    this._onDomNodeTop = onDomNodeTop;
    this._onComputedHeight = onComputedHeight;
  }
  onDomNodeTop(top) {
    this._onDomNodeTop(top);
  }
  onComputedHeight(height) {
    this._onComputedHeight(height);
  }
};
__name(ViewZoneDelegate, "ViewZoneDelegate");
var OverlayWidgetDelegate = class {
  constructor(id, domNode) {
    this._id = id;
    this._domNode = domNode;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
};
__name(OverlayWidgetDelegate, "OverlayWidgetDelegate");
var Arrow = class {
  constructor(_editor) {
    this._editor = _editor;
    this._ruleName = Arrow._IdGenerator.nextId();
    this._decorations = this._editor.createDecorationsCollection();
    this._color = null;
    this._height = -1;
  }
  dispose() {
    this.hide();
    removeCSSRulesContainingSelector(this._ruleName);
  }
  set color(value) {
    if (this._color !== value) {
      this._color = value;
      this._updateStyle();
    }
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this._updateStyle();
    }
  }
  _updateStyle() {
    removeCSSRulesContainingSelector(this._ruleName);
    createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
  }
  show(where) {
    if (where.column === 1) {
      where = { lineNumber: where.lineNumber, column: 2 };
    }
    this._decorations.set([{
      range: Range.fromPositions(where),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
};
__name(Arrow, "Arrow");
Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
var ZoneWidget = class {
  constructor(editor2, options = {}) {
    this._arrow = null;
    this._overlayWidget = null;
    this._resizeSash = null;
    this._viewZone = null;
    this._disposables = new DisposableStore();
    this.container = null;
    this._isShowing = false;
    this.editor = editor2;
    this._positionMarkerId = this.editor.createDecorationsCollection();
    this.options = deepClone(options);
    mixin(this.options, defaultOptions, false);
    this.domNode = document.createElement("div");
    if (!this.options.isAccessible) {
      this.domNode.setAttribute("aria-hidden", "true");
      this.domNode.setAttribute("role", "presentation");
    }
    this._disposables.add(this.editor.onDidLayoutChange((info) => {
      const width = this._getWidth(info);
      this.domNode.style.width = width + "px";
      this.domNode.style.left = this._getLeft(info) + "px";
      this._onWidth(width);
    }));
  }
  dispose() {
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
        this._viewZone = null;
      });
    }
    this._positionMarkerId.clear();
    this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget");
    if (this.options.className) {
      this.domNode.classList.add(this.options.className);
    }
    this.container = document.createElement("div");
    this.container.classList.add("zone-widget-container");
    this.domNode.appendChild(this.container);
    if (this.options.showArrow) {
      this._arrow = new Arrow(this.editor);
      this._disposables.add(this._arrow);
    }
    this._fillContainer(this.container);
    this._initSash();
    this._applyStyles();
  }
  style(styles) {
    if (styles.frameColor) {
      this.options.frameColor = styles.frameColor;
    }
    if (styles.arrowColor) {
      this.options.arrowColor = styles.arrowColor;
    }
    this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const frameColor = this.options.frameColor.toString();
      this.container.style.borderTopColor = frameColor;
      this.container.style.borderBottomColor = frameColor;
    }
    if (this._arrow && this.options.arrowColor) {
      const arrowColor = this.options.arrowColor.toString();
      this._arrow.color = arrowColor;
    }
  }
  _getWidth(info) {
    return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
  }
  _getLeft(info) {
    if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
      return info.minimap.minimapWidth;
    }
    return 0;
  }
  _onViewZoneTop(top) {
    this.domNode.style.top = top + "px";
  }
  _onViewZoneHeight(height) {
    var _a6;
    this.domNode.style.height = `${height}px`;
    if (this.container) {
      const containerHeight = height - this._decoratingElementsHeight();
      this.container.style.height = `${containerHeight}px`;
      const layoutInfo = this.editor.getLayoutInfo();
      this._doLayout(containerHeight, this._getWidth(layoutInfo));
    }
    (_a6 = this._resizeSash) === null || _a6 === void 0 ? void 0 : _a6.layout();
  }
  get position() {
    const range = this._positionMarkerId.getRange(0);
    if (!range) {
      return void 0;
    }
    return range.getStartPosition();
  }
  show(rangeOrPos, heightInLines) {
    const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
    this._isShowing = true;
    this._showImpl(range, heightInLines);
    this._isShowing = false;
    this._positionMarkerId.set([{ range, options: ModelDecorationOptions.EMPTY }]);
  }
  hide() {
    var _a6;
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
      });
      this._viewZone = null;
    }
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    (_a6 = this._arrow) === null || _a6 === void 0 ? void 0 : _a6.hide();
  }
  _decoratingElementsHeight() {
    const lineHeight = this.editor.getOption(61);
    let result = 0;
    if (this.options.showArrow) {
      const arrowHeight = Math.round(lineHeight / 3);
      result += 2 * arrowHeight;
    }
    if (this.options.showFrame) {
      const frameThickness = Math.round(lineHeight / 9);
      result += 2 * frameThickness;
    }
    return result;
  }
  _showImpl(where, heightInLines) {
    const position = where.getStartPosition();
    const layoutInfo = this.editor.getLayoutInfo();
    const width = this._getWidth(layoutInfo);
    this.domNode.style.width = `${width}px`;
    this.domNode.style.left = this._getLeft(layoutInfo) + "px";
    const viewZoneDomNode = document.createElement("div");
    viewZoneDomNode.style.overflow = "hidden";
    const lineHeight = this.editor.getOption(61);
    const maxHeightInLines = Math.max(12, this.editor.getLayoutInfo().height / lineHeight * 0.8);
    heightInLines = Math.min(heightInLines, maxHeightInLines);
    let arrowHeight = 0;
    let frameThickness = 0;
    if (this._arrow && this.options.showArrow) {
      arrowHeight = Math.round(lineHeight / 3);
      this._arrow.height = arrowHeight;
      this._arrow.show(position);
    }
    if (this.options.showFrame) {
      frameThickness = Math.round(lineHeight / 9);
    }
    this.editor.changeViewZones((accessor) => {
      if (this._viewZone) {
        accessor.removeZone(this._viewZone.id);
      }
      if (this._overlayWidget) {
        this.editor.removeOverlayWidget(this._overlayWidget);
        this._overlayWidget = null;
      }
      this.domNode.style.top = "-1000px";
      this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));
      this._viewZone.id = accessor.addZone(this._viewZone);
      this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
      this.editor.addOverlayWidget(this._overlayWidget);
    });
    if (this.container && this.options.showFrame) {
      const width2 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
      this.container.style.borderTopWidth = width2 + "px";
      this.container.style.borderBottomWidth = width2 + "px";
    }
    const containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
    if (this.container) {
      this.container.style.top = arrowHeight + "px";
      this.container.style.height = containerHeight + "px";
      this.container.style.overflow = "hidden";
    }
    this._doLayout(containerHeight, width);
    if (!this.options.keepEditorSelection) {
      this.editor.setSelection(where);
    }
    const model = this.editor.getModel();
    if (model) {
      const revealLine = where.endLineNumber + 1;
      if (revealLine <= model.getLineCount()) {
        this.revealLine(revealLine, false);
      } else {
        this.revealLine(model.getLineCount(), true);
      }
    }
  }
  revealLine(lineNumber, isLastLine) {
    if (isLastLine) {
      this.editor.revealLineInCenter(lineNumber, 0);
    } else {
      this.editor.revealLine(lineNumber, 0);
    }
  }
  setCssClass(className, classToReplace) {
    if (!this.container) {
      return;
    }
    if (classToReplace) {
      this.container.classList.remove(classToReplace);
    }
    this.container.classList.add(className);
  }
  _onWidth(widthInPixel) {
  }
  _doLayout(heightInPixel, widthInPixel) {
  }
  _relayout(newHeightInLines) {
    if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          this._viewZone.heightInLines = newHeightInLines;
          accessor.layoutZone(this._viewZone.id);
        }
      });
    }
  }
  _initSash() {
    if (this._resizeSash) {
      return;
    }
    this._resizeSash = this._disposables.add(new Sash(this.domNode, this, { orientation: 1 }));
    if (!this.options.isResizeable) {
      this._resizeSash.state = 0;
    }
    let data;
    this._disposables.add(this._resizeSash.onDidStart((e) => {
      if (this._viewZone) {
        data = {
          startY: e.startY,
          heightInLines: this._viewZone.heightInLines
        };
      }
    }));
    this._disposables.add(this._resizeSash.onDidEnd(() => {
      data = void 0;
    }));
    this._disposables.add(this._resizeSash.onDidChange((evt) => {
      if (data) {
        const lineDelta = (evt.currentY - data.startY) / this.editor.getOption(61);
        const roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
        const newHeightInLines = data.heightInLines + roundedLineDelta;
        if (newHeightInLines > 5 && newHeightInLines < 35) {
          this._relayout(newHeightInLines);
        }
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const layoutInfo = this.editor.getLayoutInfo();
    return layoutInfo.width - layoutInfo.minimap.minimapWidth;
  }
};
__name(ZoneWidget, "ZoneWidget");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/peekView/browser/peekView.js
init_nls();
init_contextkey();
init_extensions();
init_instantiation();
init_colorRegistry();
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IPeekViewService = createDecorator("IPeekViewService");
registerSingleton(IPeekViewService, class {
  constructor() {
    this._widgets = /* @__PURE__ */ new Map();
  }
  addExclusiveWidget(editor2, widget) {
    const existing = this._widgets.get(editor2);
    if (existing) {
      existing.listener.dispose();
      existing.widget.dispose();
    }
    const remove = /* @__PURE__ */ __name(() => {
      const data = this._widgets.get(editor2);
      if (data && data.widget === widget) {
        data.listener.dispose();
        this._widgets.delete(editor2);
      }
    }, "remove");
    this._widgets.set(editor2, { widget, listener: widget.onDidClose(remove) });
  }
}, 1);
var PeekContext;
(function(PeekContext2) {
  PeekContext2.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true, localize("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek"));
  PeekContext2.notInPeekEditor = PeekContext2.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
var PeekContextController = /* @__PURE__ */ __name(class PeekContextController2 {
  constructor(editor2, contextKeyService) {
    if (editor2 instanceof EmbeddedCodeEditorWidget) {
      PeekContext.inPeekEditor.bindTo(contextKeyService);
    }
  }
  dispose() {
  }
}, "PeekContextController");
PeekContextController.ID = "editor.contrib.referenceController";
PeekContextController = __decorate14([
  __param14(1, IContextKeyService)
], PeekContextController);
registerEditorContribution(PeekContextController.ID, PeekContextController, 0);
function getOuterEditor(accessor) {
  const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (editor2 instanceof EmbeddedCodeEditorWidget) {
    return editor2.getParentEditor();
  }
  return editor2;
}
__name(getOuterEditor, "getOuterEditor");
var defaultOptions2 = {
  headerBackgroundColor: Color.white,
  primaryHeadingColor: Color.fromHex("#333333"),
  secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
};
var PeekViewWidget = /* @__PURE__ */ __name(class PeekViewWidget2 extends ZoneWidget {
  constructor(editor2, options, instantiationService) {
    super(editor2, options);
    this.instantiationService = instantiationService;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    mixin(this.options, defaultOptions2, false);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      super.dispose();
      this._onDidClose.fire(this);
    }
  }
  style(styles) {
    const options = this.options;
    if (styles.headerBackgroundColor) {
      options.headerBackgroundColor = styles.headerBackgroundColor;
    }
    if (styles.primaryHeadingColor) {
      options.primaryHeadingColor = styles.primaryHeadingColor;
    }
    if (styles.secondaryHeadingColor) {
      options.secondaryHeadingColor = styles.secondaryHeadingColor;
    }
    super.style(styles);
  }
  _applyStyles() {
    super._applyStyles();
    const options = this.options;
    if (this._headElement && options.headerBackgroundColor) {
      this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
    }
    if (this._primaryHeading && options.primaryHeadingColor) {
      this._primaryHeading.style.color = options.primaryHeadingColor.toString();
    }
    if (this._secondaryHeading && options.secondaryHeadingColor) {
      this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
    }
    if (this._bodyElement && options.frameColor) {
      this._bodyElement.style.borderColor = options.frameColor.toString();
    }
  }
  _fillContainer(container) {
    this.setCssClass("peekview-widget");
    this._headElement = $(".head");
    this._bodyElement = $(".body");
    this._fillHead(this._headElement);
    this._fillBody(this._bodyElement);
    container.appendChild(this._headElement);
    container.appendChild(this._bodyElement);
  }
  _fillHead(container, noCloseAction) {
    const titleElement = $(".peekview-title");
    if (this.options.supportOnTitleClick) {
      titleElement.classList.add("clickable");
      addStandardDisposableListener(titleElement, "click", (event) => this._onTitleClick(event));
    }
    append(this._headElement, titleElement);
    this._fillTitleIcon(titleElement);
    this._primaryHeading = $("span.filename");
    this._secondaryHeading = $("span.dirname");
    this._metaHeading = $("span.meta");
    append(titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const actionsContainer = $(".peekview-actions");
    append(this._headElement, actionsContainer);
    const actionBarOptions = this._getActionBarOptions();
    this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
    this._disposables.add(this._actionbarWidget);
    if (!noCloseAction) {
      this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), Codicon.close.classNames, true, () => {
        this.dispose();
        return Promise.resolve();
      }), { label: false, icon: true });
    }
  }
  _fillTitleIcon(container) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService),
      orientation: 0
    };
  }
  _onTitleClick(event) {
  }
  setTitle(primaryHeading, secondaryHeading) {
    if (this._primaryHeading && this._secondaryHeading) {
      this._primaryHeading.innerText = primaryHeading;
      this._primaryHeading.setAttribute("title", primaryHeading);
      if (secondaryHeading) {
        this._secondaryHeading.innerText = secondaryHeading;
      } else {
        clearNode(this._secondaryHeading);
      }
    }
  }
  setMetaTitle(value) {
    if (this._metaHeading) {
      if (value) {
        this._metaHeading.innerText = value;
        show(this._metaHeading);
      } else {
        hide(this._metaHeading);
      }
    }
  }
  _doLayout(heightInPixel, widthInPixel) {
    if (!this._isShowing && heightInPixel < 0) {
      this.dispose();
      return;
    }
    const headHeight = Math.ceil(this.editor.getOption(61) * 1.2);
    const bodyHeight = Math.round(heightInPixel - (headHeight + 2));
    this._doLayoutHead(headHeight, widthInPixel);
    this._doLayoutBody(bodyHeight, widthInPixel);
  }
  _doLayoutHead(heightInPixel, widthInPixel) {
    if (this._headElement) {
      this._headElement.style.height = `${heightInPixel}px`;
      this._headElement.style.lineHeight = this._headElement.style.height;
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    if (this._bodyElement) {
      this._bodyElement.style.height = `${heightInPixel}px`;
    }
  }
}, "PeekViewWidget");
PeekViewWidget = __decorate14([
  __param14(2, IInstantiationService)
], PeekViewWidget);
var peekViewTitleBackground = registerColor("peekViewTitle.background", { dark: transparent(editorInfoForeground, 0.1), light: transparent(editorInfoForeground, 0.1), hcDark: null, hcLight: null }, localize("peekViewTitleBackground", "Background color of the peek view title area."));
var peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", { dark: Color.white, light: Color.black, hcDark: Color.white, hcLight: editorForeground }, localize("peekViewTitleForeground", "Color of the peek view title."));
var peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, localize("peekViewTitleInfoForeground", "Color of the peek view title info."));
var peekViewBorder = registerColor("peekView.border", { dark: editorInfoForeground, light: editorInfoForeground, hcDark: contrastBorder, hcLight: contrastBorder }, localize("peekViewBorder", "Color of the peek view borders and arrow."));
var peekViewResultsBackground = registerColor("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: Color.black, hcLight: Color.white }, localize("peekViewResultsBackground", "Background color of the peek view result list."));
var peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: Color.white, hcLight: editorForeground }, localize("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
var peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", { dark: Color.white, light: "#1E1E1E", hcDark: Color.white, hcLight: editorForeground }, localize("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
var peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, localize("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
var peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", { dark: Color.white, light: "#6C6C6C", hcDark: Color.white, hcLight: editorForeground }, localize("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
var peekViewEditorBackground = registerColor("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: Color.black, hcLight: Color.white }, localize("peekViewEditorBackground", "Background color of the peek view editor."));
var peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", { dark: peekViewEditorBackground, light: peekViewEditorBackground, hcDark: peekViewEditorBackground, hcLight: peekViewEditorBackground }, localize("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
var peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, localize("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
var peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, localize("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
var peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
init_nls();
init_contextkey();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_define_process();
init_browser();
init_aria();
init_async();
init_keyCodes();
init_platform();
init_types();
init_uri();
init_editorState();
init_editorBrowser();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_languages();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
init_define_process();
init_async();
init_errors();
init_keyCodes();
init_lifecycle();
init_codeEditorService();
init_position();
init_range();
init_nls();
init_commands();
init_configuration();
init_contextkey();
init_instantiation();
init_keybindingsRegistry();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/referencesModel.js
init_define_process();
init_errors();
init_event();
init_lifecycle();
init_map();
init_resources();
init_strings();
init_range();
init_nls();
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OneReference = class {
  constructor(isProviderFirst, parent, link, _rangeCallback) {
    this.isProviderFirst = isProviderFirst;
    this.parent = parent;
    this.link = link;
    this._rangeCallback = _rangeCallback;
    this.id = defaultGenerator.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    var _a6, _b2;
    return (_b2 = (_a6 = this._range) !== null && _a6 !== void 0 ? _a6 : this.link.targetSelectionRange) !== null && _b2 !== void 0 ? _b2 : this.link.range;
  }
  set range(value) {
    this._range = value;
    this._rangeCallback(this);
  }
  get ariaMessage() {
    var _a6;
    const preview = (_a6 = this.parent.getPreview(this)) === null || _a6 === void 0 ? void 0 : _a6.preview(this.range);
    if (!preview) {
      return localize("aria.oneReference", "symbol in {0} on line {1} at column {2}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn);
    } else {
      return localize({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "symbol in {0} on line {1} at column {2}, {3}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn, preview.value);
    }
  }
};
__name(OneReference, "OneReference");
var FilePreview = class {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(range, n = 8) {
    const model = this._modelReference.object.textEditorModel;
    if (!model) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
    const beforeRange = new Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
    const afterRange = new Range(endLineNumber, endColumn, endLineNumber, 1073741824);
    const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
    const inside = model.getValueInRange(range);
    const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
    return {
      value: before + inside + after,
      highlight: { start: before.length, end: before.length + inside.length }
    };
  }
};
__name(FilePreview, "FilePreview");
var FileReferences = class {
  constructor(parent, uri) {
    this.parent = parent;
    this.uri = uri;
    this.children = [];
    this._previews = new ResourceMap();
  }
  dispose() {
    dispose(this._previews.values());
    this._previews.clear();
  }
  getPreview(child) {
    return this._previews.get(child.uri);
  }
  get ariaMessage() {
    const len = this.children.length;
    if (len === 1) {
      return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename2(this.uri), this.uri.fsPath);
    } else {
      return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename2(this.uri), this.uri.fsPath);
    }
  }
  resolve(textModelResolverService) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (this._previews.size !== 0) {
        return this;
      }
      for (const child of this.children) {
        if (this._previews.has(child.uri)) {
          continue;
        }
        try {
          const ref = yield textModelResolverService.createModelReference(child.uri);
          this._previews.set(child.uri, new FilePreview(ref));
        } catch (err) {
          onUnexpectedError(err);
        }
      }
      return this;
    });
  }
};
__name(FileReferences, "FileReferences");
var ReferencesModel = class {
  constructor(links, title) {
    this.groups = [];
    this.references = [];
    this._onDidChangeReferenceRange = new Emitter();
    this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
    this._links = links;
    this._title = title;
    const [providersFirst] = links;
    links.sort(ReferencesModel._compareReferences);
    let current;
    for (const link of links) {
      if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
        current = new FileReferences(this, link.uri);
        this.groups.push(current);
      }
      if (current.children.length === 0 || ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
        const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
        this.references.push(oneRef);
        current.children.push(oneRef);
      }
    }
  }
  dispose() {
    dispose(this.groups);
    this._onDidChangeReferenceRange.dispose();
    this.groups.length = 0;
  }
  clone() {
    return new ReferencesModel(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    if (this.isEmpty) {
      return localize("aria.result.0", "No results found");
    } else if (this.references.length === 1) {
      return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
    } else if (this.groups.length === 1) {
      return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
    } else {
      return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
  }
  nextOrPreviousReference(reference, next) {
    const { parent } = reference;
    let idx = parent.children.indexOf(reference);
    const childCount = parent.children.length;
    const groupCount = parent.parent.groups.length;
    if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
      if (next) {
        idx = (idx + 1) % childCount;
      } else {
        idx = (idx + childCount - 1) % childCount;
      }
      return parent.children[idx];
    }
    idx = parent.parent.groups.indexOf(parent);
    if (next) {
      idx = (idx + 1) % groupCount;
      return parent.parent.groups[idx].children[0];
    } else {
      idx = (idx + groupCount - 1) % groupCount;
      return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
    }
  }
  nearestReference(resource, position) {
    const nearest = this.references.map((ref, idx) => {
      return {
        idx,
        prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
        offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
      };
    }).sort((a, b) => {
      if (a.prefixLen > b.prefixLen) {
        return -1;
      } else if (a.prefixLen < b.prefixLen) {
        return 1;
      } else if (a.offsetDist < b.offsetDist) {
        return -1;
      } else if (a.offsetDist > b.offsetDist) {
        return 1;
      } else {
        return 0;
      }
    })[0];
    if (nearest) {
      return this.references[nearest.idx];
    }
    return void 0;
  }
  referenceAt(resource, position) {
    for (const ref of this.references) {
      if (ref.uri.toString() === resource.toString()) {
        if (Range.containsPosition(ref.range, position)) {
          return ref;
        }
      }
    }
    return void 0;
  }
  firstReference() {
    for (const ref of this.references) {
      if (ref.isProviderFirst) {
        return ref;
      }
    }
    return this.references[0];
  }
  static _compareReferences(a, b) {
    return extUri.compare(a.uri, b.uri) || Range.compareRangesUsingStarts(a.range, b.range);
  }
};
__name(ReferencesModel, "ReferencesModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
init_define_process();
init_dom();
init_color();
init_event();
init_lifecycle();
init_network();
init_resources();
init_range();
init_textModel();
init_languageConfigurationRegistry();
init_modesRegistry();
init_language();
init_resolverService();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesTree.js
init_define_process();
init_dom();
init_lifecycle();
init_resources();
init_resolverService();
init_nls();
init_instantiation();
init_themeService();
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DataSource = /* @__PURE__ */ __name(class DataSource2 {
  constructor(_resolverService) {
    this._resolverService = _resolverService;
  }
  hasChildren(element) {
    if (element instanceof ReferencesModel) {
      return true;
    }
    if (element instanceof FileReferences) {
      return true;
    }
    return false;
  }
  getChildren(element) {
    if (element instanceof ReferencesModel) {
      return element.groups;
    }
    if (element instanceof FileReferences) {
      return element.resolve(this._resolverService).then((val) => {
        return val.children;
      });
    }
    throw new Error("bad tree");
  }
}, "DataSource");
DataSource = __decorate15([
  __param15(0, ITextModelService)
], DataSource);
var Delegate = class {
  getHeight() {
    return 23;
  }
  getTemplateId(element) {
    if (element instanceof FileReferences) {
      return FileReferencesRenderer.id;
    } else {
      return OneReferenceRenderer.id;
    }
  }
};
__name(Delegate, "Delegate");
var StringRepresentationProvider = /* @__PURE__ */ __name(class StringRepresentationProvider2 {
  constructor(_keybindingService) {
    this._keybindingService = _keybindingService;
  }
  getKeyboardNavigationLabel(element) {
    var _a6;
    if (element instanceof OneReference) {
      const parts = (_a6 = element.parent.getPreview(element)) === null || _a6 === void 0 ? void 0 : _a6.preview(element.range);
      if (parts) {
        return parts.value;
      }
    }
    return basename2(element.uri);
  }
}, "StringRepresentationProvider");
StringRepresentationProvider = __decorate15([
  __param15(0, IKeybindingService)
], StringRepresentationProvider);
var IdentityProvider = class {
  getId(element) {
    return element instanceof OneReference ? element.id : element.uri;
  }
};
__name(IdentityProvider, "IdentityProvider");
var FileReferencesTemplate = /* @__PURE__ */ __name(class FileReferencesTemplate2 extends Disposable {
  constructor(container, _labelService, themeService) {
    super();
    this._labelService = _labelService;
    const parent = document.createElement("div");
    parent.classList.add("reference-file");
    this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
    this.badge = new CountBadge(append(parent, $(".count")));
    this._register(attachBadgeStyler(this.badge, themeService));
    container.appendChild(parent);
  }
  set(element, matches) {
    const parent = dirname2(element.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(element.uri), this._labelService.getUriLabel(parent, { relative: true }), { title: this._labelService.getUriLabel(element.uri), matches });
    const len = element.children.length;
    this.badge.setCount(len);
    if (len > 1) {
      this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
    } else {
      this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
    }
  }
}, "FileReferencesTemplate");
FileReferencesTemplate = __decorate15([
  __param15(1, ILabelService),
  __param15(2, IThemeService)
], FileReferencesTemplate);
var FileReferencesRenderer = /* @__PURE__ */ __name(class FileReferencesRenderer2 {
  constructor(_instantiationService) {
    this._instantiationService = _instantiationService;
    this.templateId = FileReferencesRenderer2.id;
  }
  renderTemplate(container) {
    return this._instantiationService.createInstance(FileReferencesTemplate, container);
  }
  renderElement(node, index, template) {
    template.set(node.element, createMatches(node.filterData));
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
}, "FileReferencesRenderer");
FileReferencesRenderer.id = "FileReferencesRenderer";
FileReferencesRenderer = __decorate15([
  __param15(0, IInstantiationService)
], FileReferencesRenderer);
var OneReferenceTemplate = class {
  constructor(container) {
    this.label = new HighlightedLabel(container);
  }
  set(element, score) {
    var _a6;
    const preview = (_a6 = element.parent.getPreview(element)) === null || _a6 === void 0 ? void 0 : _a6.preview(element.range);
    if (!preview || !preview.value) {
      this.label.set(`${basename2(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
    } else {
      const { value, highlight } = preview;
      if (score && !FuzzyScore.isDefault(score)) {
        this.label.element.classList.toggle("referenceMatch", false);
        this.label.set(value, createMatches(score));
      } else {
        this.label.element.classList.toggle("referenceMatch", true);
        this.label.set(value, [highlight]);
      }
    }
  }
};
__name(OneReferenceTemplate, "OneReferenceTemplate");
var OneReferenceRenderer = class {
  constructor() {
    this.templateId = OneReferenceRenderer.id;
  }
  renderTemplate(container) {
    return new OneReferenceTemplate(container);
  }
  renderElement(node, index, templateData) {
    templateData.set(node.element, node.filterData);
  }
  disposeTemplate() {
  }
};
__name(OneReferenceRenderer, "OneReferenceRenderer");
OneReferenceRenderer.id = "OneReferenceRenderer";
var AccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("treeAriaLabel", "References");
  }
  getAriaLabel(element) {
    return element.ariaMessage;
  }
};
__name(AccessibilityProvider, "AccessibilityProvider");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesWidget.js
init_nls();
init_instantiation();
init_themeService();
init_undoRedo();
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DecorationsManager = class {
  constructor(_editor, _model) {
    this._editor = _editor;
    this._model = _model;
    this._decorations = /* @__PURE__ */ new Map();
    this._decorationIgnoreSet = /* @__PURE__ */ new Set();
    this._callOnDispose = new DisposableStore();
    this._callOnModelChange = new DisposableStore();
    this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
    this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose();
    this._callOnDispose.dispose();
    this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const ref of this._model.references) {
      if (ref.uri.toString() === model.uri.toString()) {
        this._addDecorations(ref.parent);
        return;
      }
    }
  }
  _addDecorations(reference) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const newDecorations = [];
    const newDecorationsActualIndex = [];
    for (let i = 0, len = reference.children.length; i < len; i++) {
      const oneReference = reference.children[i];
      if (this._decorationIgnoreSet.has(oneReference.id)) {
        continue;
      }
      if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
        continue;
      }
      newDecorations.push({
        range: oneReference.range,
        options: DecorationsManager.DecorationOptions
      });
      newDecorationsActualIndex.push(i);
    }
    this._editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations([], newDecorations);
      for (let i = 0; i < decorations.length; i++) {
        this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
      }
    });
  }
  _onDecorationChanged() {
    const toRemove = [];
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (const [decorationId, reference] of this._decorations) {
      const newRange = model.getDecorationRange(decorationId);
      if (!newRange) {
        continue;
      }
      let ignore = false;
      if (Range.equalsRange(newRange, reference.range)) {
        continue;
      }
      if (Range.spansMultipleLines(newRange)) {
        ignore = true;
      } else {
        const lineLength = reference.range.endColumn - reference.range.startColumn;
        const newLineLength = newRange.endColumn - newRange.startColumn;
        if (lineLength !== newLineLength) {
          ignore = true;
        }
      }
      if (ignore) {
        this._decorationIgnoreSet.add(reference.id);
        toRemove.push(decorationId);
      } else {
        reference.range = newRange;
      }
    }
    for (let i = 0, len = toRemove.length; i < len; i++) {
      this._decorations.delete(toRemove[i]);
    }
    this._editor.removeDecorations(toRemove);
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]);
    this._decorations.clear();
  }
};
__name(DecorationsManager, "DecorationsManager");
DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
var LayoutData = class {
  constructor() {
    this.ratio = 0.7;
    this.heightInLines = 18;
  }
  static fromJSON(raw) {
    let ratio;
    let heightInLines;
    try {
      const data = JSON.parse(raw);
      ratio = data.ratio;
      heightInLines = data.heightInLines;
    } catch (_a6) {
    }
    return {
      ratio: ratio || 0.7,
      heightInLines: heightInLines || 18
    };
  }
};
__name(LayoutData, "LayoutData");
var ReferencesTree = class extends WorkbenchAsyncDataTree {
};
__name(ReferencesTree, "ReferencesTree");
var ReferenceWidget = /* @__PURE__ */ __name(class ReferenceWidget2 extends PeekViewWidget {
  constructor(editor2, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService, _languageService, _languageConfigurationService) {
    super(editor2, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this.layoutData = layoutData;
    this._textModelResolverService = _textModelResolverService;
    this._instantiationService = _instantiationService;
    this._peekViewService = _peekViewService;
    this._uriLabel = _uriLabel;
    this._undoRedoService = _undoRedoService;
    this._keybindingService = _keybindingService;
    this._languageService = _languageService;
    this._languageConfigurationService = _languageConfigurationService;
    this._disposeOnNewModel = new DisposableStore();
    this._callOnDispose = new DisposableStore();
    this._onDidSelectReference = new Emitter();
    this.onDidSelectReference = this._onDidSelectReference.event;
    this._dim = new Dimension(0, 0);
    this._applyTheme(themeService.getColorTheme());
    this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._peekViewService.addExclusiveWidget(editor2, this);
    this.create();
  }
  dispose() {
    this.setModel(void 0);
    this._callOnDispose.dispose();
    this._disposeOnNewModel.dispose();
    dispose(this._preview);
    dispose(this._previewNotAvailableMessage);
    dispose(this._tree);
    dispose(this._previewModelReference);
    this._splitView.dispose();
    super.dispose();
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  show(where) {
    super.show(where, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    if (this._preview && this._preview.getModel()) {
      this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
  }
  _fillBody(containerElement) {
    this.setCssClass("reference-zone-widget");
    this._messageContainer = append(containerElement, $("div.messages"));
    hide(this._messageContainer);
    this._splitView = new SplitView(containerElement, { orientation: 1 });
    this._previewContainer = append(containerElement, $("div.preview.inline"));
    const options = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, this.editor);
    hide(this._previewContainer);
    this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), PLAINTEXT_LANGUAGE_ID, TextModel.DEFAULT_CREATION_OPTIONS, null, this._undoRedoService, this._languageService, this._languageConfigurationService);
    this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
    const treeOptions = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new AccessibilityProvider(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
      identityProvider: new IdentityProvider(),
      openOnSingleClick: true,
      selectionNavigation: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    if (this._defaultTreeKeyboardSupport) {
      this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
        if (e.equals(9)) {
          this._keybindingService.dispatchEvent(e, e.target);
          e.stopPropagation();
        }
      }, true));
    }
    this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
      this._instantiationService.createInstance(FileReferencesRenderer),
      this._instantiationService.createInstance(OneReferenceRenderer)
    ], this._instantiationService.createInstance(DataSource), treeOptions);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._preview.layout({ height: this._dim.height, width });
      }
    }, Sizing.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._treeContainer.style.height = `${this._dim.height}px`;
        this._treeContainer.style.width = `${width}px`;
        this._tree.layout(this._dim.height, width);
      }
    }, Sizing.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }, void 0));
    const onEvent = /* @__PURE__ */ __name((element, kind) => {
      if (element instanceof OneReference) {
        if (kind === "show") {
          this._revealReference(element, false);
        }
        this._onDidSelectReference.fire({ element, kind, source: "tree" });
      }
    }, "onEvent");
    this._tree.onDidOpen((e) => {
      if (e.sideBySide) {
        onEvent(e.element, "side");
      } else if (e.editorOptions.pinned) {
        onEvent(e.element, "goto");
      } else {
        onEvent(e.element, "show");
      }
    });
    hide(this._treeContainer);
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._dim = new Dimension(widthInPixel, heightInPixel);
    this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
    this._splitView.layout(widthInPixel);
    this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
  }
  setSelection(selection) {
    return this._revealReference(selection, true).then(() => {
      if (!this._model) {
        return;
      }
      this._tree.setSelection([selection]);
      this._tree.setFocus([selection]);
    });
  }
  setModel(newModel) {
    this._disposeOnNewModel.clear();
    this._model = newModel;
    if (this._model) {
      return this._onNewModel();
    }
    return Promise.resolve();
  }
  _onNewModel() {
    if (!this._model) {
      return Promise.resolve(void 0);
    }
    if (this._model.isEmpty) {
      this.setTitle("");
      this._messageContainer.innerText = localize("noResults", "No results");
      show(this._messageContainer);
      return Promise.resolve(void 0);
    }
    hide(this._messageContainer);
    this._decorationsManager = new DecorationsManager(this._preview, this._model);
    this._disposeOnNewModel.add(this._decorationsManager);
    this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
    this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const element = this._getFocusedReference();
      if (!element) {
        return;
      }
      this._onDidSelectReference.fire({
        element: { uri: element.uri, range: target.range },
        kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
        source: "editor"
      });
    }));
    this.container.classList.add("results-loaded");
    show(this._treeContainer);
    show(this._previewContainer);
    this._splitView.layout(this._dim.width);
    this.focusOnReferenceTree();
    return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
  }
  _getFocusedReference() {
    const [element] = this._tree.getFocus();
    if (element instanceof OneReference) {
      return element;
    } else if (element instanceof FileReferences) {
      if (element.children.length > 0) {
        return element.children[0];
      }
    }
    return void 0;
  }
  revealReference(reference) {
    return __awaiter13(this, void 0, void 0, function* () {
      yield this._revealReference(reference, false);
      this._onDidSelectReference.fire({ element: reference, kind: "goto", source: "tree" });
    });
  }
  _revealReference(reference, revealParent) {
    return __awaiter13(this, void 0, void 0, function* () {
      if (this._revealedReference === reference) {
        return;
      }
      this._revealedReference = reference;
      if (reference.uri.scheme !== Schemas.inMemory) {
        this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname2(reference.uri)));
      } else {
        this.setTitle(localize("peekView.alternateTitle", "References"));
      }
      const promise = this._textModelResolverService.createModelReference(reference.uri);
      if (this._tree.getInput() === reference.parent) {
        this._tree.reveal(reference);
      } else {
        if (revealParent) {
          this._tree.reveal(reference.parent);
        }
        yield this._tree.expand(reference.parent);
        this._tree.reveal(reference);
      }
      const ref = yield promise;
      if (!this._model) {
        ref.dispose();
        return;
      }
      dispose(this._previewModelReference);
      const model = ref.object;
      if (model) {
        const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
        const sel = Range.lift(reference.range).collapseToStart();
        this._previewModelReference = ref;
        this._preview.setModel(model.textEditorModel);
        this._preview.setSelection(sel);
        this._preview.revealRangeInCenter(sel, scrollType);
      } else {
        this._preview.setModel(this._previewNotAvailableMessage);
        ref.dispose();
      }
    });
  }
}, "ReferenceWidget");
ReferenceWidget = __decorate16([
  __param16(3, IThemeService),
  __param16(4, ITextModelService),
  __param16(5, IInstantiationService),
  __param16(6, IPeekViewService),
  __param16(7, ILabelService),
  __param16(8, IUndoRedoService),
  __param16(9, IKeybindingService),
  __param16(10, ILanguageService),
  __param16(11, ILanguageConfigurationService)
], ReferenceWidget);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/peek/referencesController.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var ReferencesController = /* @__PURE__ */ __name(class ReferencesController2 {
  static get(editor2) {
    return editor2.getContribution(ReferencesController2.ID);
  }
  constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this._editor = _editor;
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._requestIdPool = 0;
    this._ignoreModelChangeEvent = false;
    this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
  }
  dispose() {
    var _a6, _b2;
    this._referenceSearchVisible.reset();
    this._disposables.dispose();
    (_a6 = this._widget) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._widget = void 0;
    this._model = void 0;
  }
  toggleWidget(range, modelPromise, peekMode) {
    let widgetPosition;
    if (this._widget) {
      widgetPosition = this._widget.position;
    }
    this.closeWidget();
    if (!!widgetPosition && range.containsPosition(widgetPosition)) {
      return;
    }
    this._peekMode = peekMode;
    this._referenceSearchVisible.set(true);
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    }));
    this._disposables.add(this._editor.onDidChangeModel(() => {
      if (!this._ignoreModelChangeEvent) {
        this.closeWidget();
      }
    }));
    const storageKey = "peekViewLayout";
    const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
    this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
    this._widget.setTitle(localize("labelLoading", "Loading..."));
    this._widget.show(range);
    this._disposables.add(this._widget.onDidClose(() => {
      modelPromise.cancel();
      if (this._widget) {
        this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), 0, 1);
        this._widget = void 0;
      }
      this.closeWidget();
    }));
    this._disposables.add(this._widget.onDidSelectReference((event) => {
      const { element, kind } = event;
      if (!element) {
        return;
      }
      switch (kind) {
        case "open":
          if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
            this.openReference(element, false, false);
          }
          break;
        case "side":
          this.openReference(element, true, false);
          break;
        case "goto":
          if (peekMode) {
            this._gotoReference(element);
          } else {
            this.openReference(element, false, true);
          }
          break;
      }
    }));
    const requestId = ++this._requestIdPool;
    modelPromise.then((model) => {
      var _a6;
      if (requestId !== this._requestIdPool || !this._widget) {
        model.dispose();
        return void 0;
      }
      (_a6 = this._model) === null || _a6 === void 0 ? void 0 : _a6.dispose();
      this._model = model;
      return this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          if (!this._model.isEmpty) {
            this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          } else {
            this._widget.setMetaTitle("");
          }
          const uri = this._editor.getModel().uri;
          const pos = new Position(range.startLineNumber, range.startColumn);
          const selection = this._model.nearestReference(uri, pos);
          if (selection) {
            return this._widget.setSelection(selection).then(() => {
              if (this._widget && this._editor.getOption(80) === "editor") {
                this._widget.focusOnPreviewEditor();
              }
            });
          }
        }
        return void 0;
      });
    }, (error) => {
      this._notificationService.error(error);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    if (!this._widget) {
      return;
    }
    if (this._widget.isPreviewEditorFocused()) {
      this._widget.focusOnReferenceTree();
    } else {
      this._widget.focusOnPreviewEditor();
    }
  }
  goToNextOrPreviousReference(fwd) {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      const currentPosition = this._widget.position;
      if (!currentPosition) {
        return;
      }
      const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
      if (!source) {
        return;
      }
      const target = this._model.nextOrPreviousReference(source, fwd);
      const editorFocus = this._editor.hasTextFocus();
      const previewEditorFocus = this._widget.isPreviewEditorFocused();
      yield this._widget.setSelection(target);
      yield this._gotoReference(target);
      if (editorFocus) {
        this._editor.focus();
      } else if (this._widget && previewEditorFocus) {
        this._widget.focusOnPreviewEditor();
      }
    });
  }
  revealReference(reference) {
    return __awaiter14(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      yield this._widget.revealReference(reference);
    });
  }
  closeWidget(focusEditor = true) {
    var _a6, _b2;
    (_a6 = this._widget) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._referenceSearchVisible.reset();
    this._disposables.clear();
    this._widget = void 0;
    this._model = void 0;
    if (focusEditor) {
      this._editor.focus();
    }
    this._requestIdPool += 1;
  }
  _gotoReference(ref) {
    var _a6;
    (_a6 = this._widget) === null || _a6 === void 0 ? void 0 : _a6.hide();
    this._ignoreModelChangeEvent = true;
    const range = Range.lift(ref.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: ref.uri,
      options: { selection: range, selectionSource: "code.jump" }
    }, this._editor).then((openedEditor) => {
      var _a7;
      this._ignoreModelChangeEvent = false;
      if (!openedEditor || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === openedEditor) {
        this._widget.show(range);
        this._widget.focusOnReferenceTree();
      } else {
        const other = ReferencesController2.get(openedEditor);
        const model = this._model.clone();
        this.closeWidget();
        openedEditor.focus();
        other === null || other === void 0 ? void 0 : other.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), (_a7 = this._peekMode) !== null && _a7 !== void 0 ? _a7 : false);
      }
    }, (err) => {
      this._ignoreModelChangeEvent = false;
      onUnexpectedError(err);
    });
  }
  openReference(ref, sideBySide, pinned) {
    if (!sideBySide) {
      this.closeWidget();
    }
    const { uri, range } = ref;
    this._editorService.openCodeEditor({
      resource: uri,
      options: { selection: range, selectionSource: "code.jump", pinned }
    }, this._editor, sideBySide);
  }
}, "ReferencesController");
ReferencesController.ID = "editor.contrib.referencesController";
ReferencesController = __decorate17([
  __param17(2, IContextKeyService),
  __param17(3, ICodeEditorService),
  __param17(4, INotificationService),
  __param17(5, IInstantiationService),
  __param17(6, IStorageService),
  __param17(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  const controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
__name(withController, "withController");
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: KeyChord(2048 | 41, 60),
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.changeFocusBetweenPreviewAndReferences();
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 100 - 10,
  primary: 62,
  secondary: [70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(true);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 100 - 10,
  primary: 1024 | 62,
  secondary: [1024 | 70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(false);
    });
  }
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 100 - 101,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 200 + 50,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [2048 | 18]
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    var _a6;
    const listService = accessor.get(IListService);
    const focus = (_a6 = listService.lastFocusedList) === null || _a6 === void 0 ? void 0 : _a6.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.revealReference(focus[0]));
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey, WorkbenchTreeElementCanCollapse.negate(), WorkbenchTreeElementCanExpand.negate()),
  handler(accessor) {
    var _a6;
    const listService = accessor.get(IListService);
    const focus = (_a6 = listService.lastFocusedList) === null || _a6 === void 0 ? void 0 : _a6.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.openReference(focus[0], true, true));
    }
  }
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
  var _a6;
  const listService = accessor.get(IListService);
  const focus = (_a6 = listService.lastFocusedList) === null || _a6 === void 0 ? void 0 : _a6.getFocus();
  if (Array.isArray(focus) && focus[0] instanceof OneReference) {
    withController(accessor, (controller) => controller.openReference(focus[0], false, true));
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/symbolNavigation.js
init_define_process();
init_event();
init_lifecycle();
init_resources();
init_editorExtensions();
init_codeEditorService();
init_range();
init_nls();
init_contextkey();
init_extensions();
init_instantiation();
init_keybindingsRegistry();
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ctxHasSymbols = new RawContextKey("hasSymbols", false, localize("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only."));
var ISymbolNavigationService = createDecorator("ISymbolNavigationService");
var SymbolNavigationService = /* @__PURE__ */ __name(class SymbolNavigationService2 {
  constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._currentModel = void 0;
    this._currentIdx = -1;
    this._ignoreEditorChange = false;
    this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
  }
  reset() {
    var _a6, _b2;
    this._ctxHasSymbols.reset();
    (_a6 = this._currentState) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    (_b2 = this._currentMessage) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._currentModel = void 0;
    this._currentIdx = -1;
  }
  put(anchor) {
    const refModel = anchor.parent.parent;
    if (refModel.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = refModel;
    this._currentIdx = refModel.references.indexOf(anchor);
    this._ctxHasSymbols.set(true);
    this._showMessage();
    const editorState = new EditorState2(this._editorService);
    const listener = editorState.onDidChange((_) => {
      if (this._ignoreEditorChange) {
        return;
      }
      const editor2 = this._editorService.getActiveCodeEditor();
      if (!editor2) {
        return;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!model || !position) {
        return;
      }
      let seenUri = false;
      let seenPosition = false;
      for (const reference of refModel.references) {
        if (isEqual(reference.uri, model.uri)) {
          seenUri = true;
          seenPosition = seenPosition || Range.containsPosition(reference.range, position);
        } else if (seenUri) {
          break;
        }
      }
      if (!seenUri || !seenPosition) {
        this.reset();
      }
    });
    this._currentState = combinedDisposable(editorState, listener);
  }
  revealNext(source) {
    if (!this._currentModel) {
      return Promise.resolve();
    }
    this._currentIdx += 1;
    this._currentIdx %= this._currentModel.references.length;
    const reference = this._currentModel.references[this._currentIdx];
    this._showMessage();
    this._ignoreEditorChange = true;
    return this._editorService.openCodeEditor({
      resource: reference.uri,
      options: {
        selection: Range.collapseToStart(reference.range),
        selectionRevealType: 3
      }
    }, source).finally(() => {
      this._ignoreEditorChange = false;
    });
  }
  _showMessage() {
    var _a6;
    (_a6 = this._currentMessage) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
    const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(message);
  }
}, "SymbolNavigationService");
SymbolNavigationService = __decorate18([
  __param18(0, IContextKeyService),
  __param18(1, ICodeEditorService),
  __param18(2, INotificationService),
  __param18(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(ISymbolNavigationService, SymbolNavigationService, 1);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: ctxHasSymbols,
      kbOpts: {
        weight: 100,
        primary: 70
      }
    });
  }
  runEditorCommand(accessor, editor2) {
    return accessor.get(ISymbolNavigationService).revealNext(editor2);
  }
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: ctxHasSymbols,
  primary: 9,
  handler(accessor) {
    accessor.get(ISymbolNavigationService).reset();
  }
});
var EditorState2 = /* @__PURE__ */ __name(class EditorState3 {
  constructor(editorService) {
    this._listener = /* @__PURE__ */ new Map();
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
    this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
    editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
    dispose(this._listener.values());
  }
  _onDidAddEditor(editor2) {
    this._listener.set(editor2, combinedDisposable(editor2.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor2 })), editor2.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor2 }))));
  }
  _onDidRemoveEditor(editor2) {
    var _a6;
    (_a6 = this._listener.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._listener.delete(editor2);
  }
}, "EditorState");
EditorState2 = __decorate18([
  __param18(0, ICodeEditorService)
], EditorState2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_instantiation();
init_progress();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToSymbol.js
init_define_process();
init_arrays();
init_cancellation();
init_errors();
init_editorExtensions();
init_languageFeatures();
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getLocationLinks(model, position, registry, provide) {
  return __awaiter15(this, void 0, void 0, function* () {
    const provider = registry.ordered(model);
    const promises = provider.map((provider2) => {
      return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
        onUnexpectedExternalError(err);
        return void 0;
      });
    });
    const values = yield Promise.all(promises);
    return coalesce(values.flat());
  });
}
__name(getLocationLinks, "getLocationLinks");
function getDefinitionsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
__name(getDefinitionsAtPosition, "getDefinitionsAtPosition");
function getDeclarationsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
__name(getDeclarationsAtPosition, "getDeclarationsAtPosition");
function getImplementationsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
__name(getImplementationsAtPosition, "getImplementationsAtPosition");
function getTypeDefinitionsAtPosition(registry, model, position, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
__name(getTypeDefinitionsAtPosition, "getTypeDefinitionsAtPosition");
function getReferencesAtPosition(registry, model, position, compact, token) {
  return getLocationLinks(model, position, registry, (provider, model2, position2) => __awaiter15(this, void 0, void 0, function* () {
    const result = yield provider.provideReferences(model2, position2, { includeDeclaration: true }, token);
    if (!compact || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = yield provider.provideReferences(model2, position2, { includeDeclaration: false }, token);
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  }));
}
__name(getReferencesAtPosition, "getReferencesAtPosition");
function _sortedAndDeduped(callback) {
  return __awaiter15(this, void 0, void 0, function* () {
    const rawLinks = yield callback();
    const model = new ReferencesModel(rawLinks, "");
    const modelLinks = model.references.map((ref) => ref.link);
    model.dispose();
    return modelLinks;
  });
}
__name(_sortedAndDeduped, "_sortedAndDeduped");
registerModelAndPositionCommand("_executeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeDeclarationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeReferenceProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});
registerModelAndPositionCommand("_executeImplementationProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const promise = getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, CancellationToken.None);
  return _sortedAndDeduped(() => promise);
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/goToCommands.js
init_languageFeatures();
init_iterator();
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  submenu: MenuId.EditorContextPeek,
  title: localize("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
var SymbolNavigationAnchor = class {
  static is(thing) {
    if (!thing || typeof thing !== "object") {
      return false;
    }
    if (thing instanceof SymbolNavigationAnchor) {
      return true;
    }
    if (Position.isIPosition(thing.position) && thing.model) {
      return true;
    }
    return false;
  }
  constructor(model, position) {
    this.model = model;
    this.position = position;
  }
};
__name(SymbolNavigationAnchor, "SymbolNavigationAnchor");
var SymbolNavigationAction = class extends EditorAction2 {
  static all() {
    return SymbolNavigationAction._allSymbolNavigationCommands.values();
  }
  static _patchConfig(opts) {
    const result = Object.assign(Object.assign({}, opts), { f1: true });
    if (result.menu) {
      for (const item of Iterable.wrap(result.menu)) {
        if (item.id === MenuId.EditorContext || item.id === MenuId.EditorContextPeek) {
          item.when = ContextKeyExpr.and(opts.precondition, item.when);
        }
      }
    }
    return result;
  }
  constructor(configuration, opts) {
    super(SymbolNavigationAction._patchConfig(opts));
    this.configuration = configuration;
    SymbolNavigationAction._allSymbolNavigationCommands.set(opts.id, this);
  }
  runEditorCommand(accessor, editor2, arg, range) {
    if (!editor2.hasModel()) {
      return Promise.resolve(void 0);
    }
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(ICodeEditorService);
    const progressService = accessor.get(IEditorProgressService);
    const symbolNavService = accessor.get(ISymbolNavigationService);
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const instaService = accessor.get(IInstantiationService);
    const model = editor2.getModel();
    const position = editor2.getPosition();
    const anchor = SymbolNavigationAnchor.is(arg) ? arg : new SymbolNavigationAnchor(model, position);
    const cts = new EditorStateCancellationTokenSource(editor2, 1 | 4);
    const promise = raceCancellation(this._getLocationModel(languageFeaturesService, anchor.model, anchor.position, cts.token), cts.token).then((references) => __awaiter16(this, void 0, void 0, function* () {
      var _a6;
      if (!references || cts.token.isCancellationRequested) {
        return;
      }
      alert(references.ariaMessage);
      let altAction;
      if (references.referenceAt(model.uri, position)) {
        const altActionId = this._getAlternativeCommand(editor2);
        if (!SymbolNavigationAction._activeAlternativeCommands.has(altActionId) && SymbolNavigationAction._allSymbolNavigationCommands.has(altActionId)) {
          altAction = SymbolNavigationAction._allSymbolNavigationCommands.get(altActionId);
        }
      }
      const referenceCount = references.references.length;
      if (referenceCount === 0) {
        if (!this.configuration.muteMessage) {
          const info = model.getWordAtPosition(position);
          (_a6 = MessageController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.showMessage(this._getNoResultFoundMessage(info), position);
        }
      } else if (referenceCount === 1 && altAction) {
        SymbolNavigationAction._activeAlternativeCommands.add(this.desc.id);
        instaService.invokeFunction((accessor2) => altAction.runEditorCommand(accessor2, editor2, arg, range).finally(() => {
          SymbolNavigationAction._activeAlternativeCommands.delete(this.desc.id);
        }));
      } else {
        return this._onResult(editorService, symbolNavService, editor2, references, range);
      }
    }), (err) => {
      notificationService.error(err);
    }).finally(() => {
      cts.dispose();
    });
    progressService.showWhile(promise, 250);
    return promise;
  }
  _onResult(editorService, symbolNavService, editor2, model, range) {
    return __awaiter16(this, void 0, void 0, function* () {
      const gotoLocation = this._getGoToPreference(editor2);
      if (!(editor2 instanceof EmbeddedCodeEditorWidget) && (this.configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
        this._openInPeek(editor2, model, range);
      } else {
        const next = model.firstReference();
        const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
        const targetEditor = yield this._openReference(editor2, editorService, next, this.configuration.openToSide, !peek);
        if (peek && targetEditor) {
          this._openInPeek(targetEditor, model, range);
        } else {
          model.dispose();
        }
        if (gotoLocation === "goto") {
          symbolNavService.put(next);
        }
      }
    });
  }
  _openReference(editor2, editorService, reference, sideBySide, highlight) {
    return __awaiter16(this, void 0, void 0, function* () {
      let range = void 0;
      if (isLocationLink(reference)) {
        range = reference.targetSelectionRange;
      }
      if (!range) {
        range = reference.range;
      }
      if (!range) {
        return void 0;
      }
      const targetEditor = yield editorService.openCodeEditor({
        resource: reference.uri,
        options: {
          selection: Range.collapseToStart(range),
          selectionRevealType: 3,
          selectionSource: "code.jump"
        }
      }, editor2, sideBySide);
      if (!targetEditor) {
        return void 0;
      }
      if (highlight) {
        const modelNow = targetEditor.getModel();
        const decorations = targetEditor.createDecorationsCollection([{ range, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          if (targetEditor.getModel() === modelNow) {
            decorations.clear();
          }
        }, 350);
      }
      return targetEditor;
    });
  }
  _openInPeek(target, model, range) {
    const controller = ReferencesController.get(target);
    if (controller && target.hasModel()) {
      controller.toggleWidget(range !== null && range !== void 0 ? range : target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this.configuration.openInPeek);
    } else {
      model.dispose();
    }
  }
};
__name(SymbolNavigationAction, "SymbolNavigationAction");
SymbolNavigationAction._allSymbolNavigationCommands = /* @__PURE__ */ new Map();
SymbolNavigationAction._activeAlternativeCommands = /* @__PURE__ */ new Set();
var DefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDefinitionsAtPosition(languageFeaturesService.definitionProvider, model, position, token), localize("def.title", "Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(53).alternativeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(53).multipleDefinitions;
  }
};
__name(DefinitionAction, "DefinitionAction");
var goToDefinitionKb = isWeb && !isStandalone() ? 2048 | 70 : 70;
registerAction2((_a = /* @__PURE__ */ __name(class GoToDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDefinitionAction.id,
      title: {
        value: localize("actions.goToDecl.label", "Go to Definition"),
        original: "Go to Definition",
        mnemonicTitle: localize({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: goToDefinitionKb,
        weight: 100
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 2
      }]
    });
    CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
  }
}, "GoToDefinitionAction"), _a.id = "editor.action.revealDefinition", _a));
registerAction2((_b = /* @__PURE__ */ __name(class OpenDefinitionToSideAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: true,
      openInPeek: false,
      muteMessage: false
    }, {
      id: OpenDefinitionToSideAction.id,
      title: {
        value: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
        original: "Open Definition to the Side"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, goToDefinitionKb),
        weight: 100
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
  }
}, "OpenDefinitionToSideAction"), _b.id = "editor.action.revealDefinitionAside", _b));
registerAction2((_c = /* @__PURE__ */ __name(class PeekDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekDefinitionAction.id,
      title: {
        value: localize("actions.previewDecl.label", "Peek Definition"),
        original: "Peek Definition"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 512 | 70,
        linux: { primary: 2048 | 1024 | 68 },
        weight: 100
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 2
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
  }
}, "PeekDefinitionAction"), _c.id = "editor.action.peekDefinition", _c));
var DeclarationAction = class extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDeclarationsAtPosition(languageFeaturesService.declarationProvider, model, position, token), localize("decl.title", "Declarations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(53).alternativeDeclarationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(53).multipleDeclarations;
  }
};
__name(DeclarationAction, "DeclarationAction");
registerAction2((_d = /* @__PURE__ */ __name(class GoToDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDeclarationAction.id,
      title: {
        value: localize("actions.goToDeclaration.label", "Go to Declaration"),
        original: "Go to Declaration",
        mnemonicTitle: localize({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
}, "GoToDeclarationAction"), _d.id = "editor.action.revealDeclaration", _d));
registerAction2(/* @__PURE__ */ __name(class PeekDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.peekDeclaration",
      title: {
        value: localize("actions.peekDecl.label", "Peek Declaration"),
        original: "Peek Declaration"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
}, "PeekDeclarationAction"));
var TypeDefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getTypeDefinitionsAtPosition(languageFeaturesService.typeDefinitionProvider, model, position, token), localize("typedef.title", "Type Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(53).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(53).multipleTypeDefinitions;
  }
};
__name(TypeDefinitionAction, "TypeDefinitionAction");
registerAction2((_e = /* @__PURE__ */ __name(class GoToTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToTypeDefinitionAction.ID,
      title: {
        value: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
        original: "Go to Type Definition",
        mnemonicTitle: localize({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, "GoToTypeDefinitionAction"), _e.ID = "editor.action.goToTypeDefinition", _e));
registerAction2((_f = /* @__PURE__ */ __name(class PeekTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekTypeDefinitionAction.ID,
      title: {
        value: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
        original: "Peek Type Definition"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, "PeekTypeDefinitionAction"), _f.ID = "editor.action.peekTypeDefinition", _f));
var ImplementationAction = class extends SymbolNavigationAction {
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getImplementationsAtPosition(languageFeaturesService.implementationProvider, model, position, token), localize("impl.title", "Implementations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(53).alternativeImplementationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(53).multipleImplementations;
  }
};
__name(ImplementationAction, "ImplementationAction");
registerAction2((_g = /* @__PURE__ */ __name(class GoToImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToImplementationAction.ID,
      title: {
        value: localize("actions.goToImplementation.label", "Go to Implementations"),
        original: "Go to Implementations",
        mnemonicTitle: localize({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 70,
        weight: 100
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, "GoToImplementationAction"), _g.ID = "editor.action.goToImplementation", _g));
registerAction2((_h = /* @__PURE__ */ __name(class PeekImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekImplementationAction.ID,
      title: {
        value: localize("actions.peekImplementation.label", "Peek Implementations"),
        original: "Peek Implementations"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 70,
        weight: 100
      },
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, "PeekImplementationAction"), _h.ID = "editor.action.peekImplementation", _h));
var ReferencesAction = class extends SymbolNavigationAction {
  _getNoResultFoundMessage(info) {
    return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(53).alternativeReferenceCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(53).multipleReferences;
  }
};
__name(ReferencesAction, "ReferencesAction");
registerAction2(/* @__PURE__ */ __name(class GoToReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: "editor.action.goToReferences",
      title: {
        value: localize("goToReferences.label", "Go to References"),
        original: "Go to References",
        mnemonicTitle: localize({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      keybinding: {
        when: EditorContextKeys.editorTextFocus,
        primary: 1024 | 70,
        weight: 100
      },
      menu: [{
        id: MenuId.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: MenuId.MenubarGoMenu,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, true, token), localize("ref.title", "References"));
    });
  }
}, "GoToReferencesAction"));
registerAction2(/* @__PURE__ */ __name(class PeekReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: {
        value: localize("references.action.label", "Peek References"),
        original: "Peek References"
      },
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      menu: {
        id: MenuId.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  _getLocationModel(languageFeaturesService, model, position, token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(languageFeaturesService.referenceProvider, model, position, false, token), localize("ref.title", "References"));
    });
  }
}, "PeekReferencesAction"));
var GenericGoToLocationAction = class extends SymbolNavigationAction {
  constructor(config, _references, _gotoMultipleBehaviour) {
    super(config, {
      id: "editor.action.goToLocation",
      title: {
        value: localize("label.generic", "Go to Any Symbol"),
        original: "Go to Any Symbol"
      },
      precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
    });
    this._references = _references;
    this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
  }
  _getLocationModel(languageFeaturesService, _model, _position, _token) {
    return __awaiter16(this, void 0, void 0, function* () {
      return new ReferencesModel(this._references, localize("generic.title", "Locations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
  }
  _getGoToPreference(editor2) {
    var _a6;
    return (_a6 = this._gotoMultipleBehaviour) !== null && _a6 !== void 0 ? _a6 : editor2.getOption(53).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
};
__name(GenericGoToLocationAction, "GenericGoToLocationAction");
CommandsRegistry.registerCommand({
  id: "editor.action.goToLocations",
  description: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter16(void 0, void 0, void 0, function* () {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    assertType(Array.isArray(references));
    assertType(typeof multiple === "undefined" || typeof multiple === "string");
    assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
    const editorService = accessor.get(ICodeEditorService);
    const editor2 = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
    if (isCodeEditor(editor2)) {
      editor2.setPosition(position);
      editor2.revealPositionInCenterIfOutsideViewport(position, 0);
      return editor2.invokeWithinContext((accessor2) => {
        const command = new class extends GenericGoToLocationAction {
          _getNoResultFoundMessage(info) {
            return noResultsMessage || super._getNoResultFoundMessage(info);
          }
        }({
          muteMessage: !Boolean(noResultsMessage),
          openInPeek: Boolean(openInPeek),
          openToSide: false
        }, references, multiple);
        accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor2);
      });
    }
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.peekLocations",
  description: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" }
    ]
  },
  handler: (accessor, resource, position, references, multiple) => __awaiter16(void 0, void 0, void 0, function* () {
    accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.findReferences",
  handler: (accessor, resource, position) => {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const languageFeaturesService = accessor.get(ILanguageFeaturesService);
    const codeEditorService = accessor.get(ICodeEditorService);
    return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
      if (!isCodeEditor(control) || !control.hasModel()) {
        return void 0;
      }
      const controller = ReferencesController.get(control);
      if (!controller) {
        return void 0;
      }
      const references = createCancelablePromise((token) => getReferencesAtPosition(languageFeaturesService.referenceProvider, control.getModel(), Position.lift(position), false, token).then((references2) => new ReferencesModel(references2, localize("ref.title", "References"))));
      const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
      return Promise.resolve(controller.toggleWidget(range, references, false));
    });
  }
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/browser/link/goToDefinitionAtPosition.js
init_languageFeatures();
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GotoDefinitionAtPositionEditorContribution = /* @__PURE__ */ __name(class GotoDefinitionAtPositionEditorContribution2 {
  constructor(editor2, textModelResolverService, languageService, languageFeaturesService) {
    this.textModelResolverService = textModelResolverService;
    this.languageService = languageService;
    this.languageFeaturesService = languageFeaturesService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor2;
    this.linkDecorations = this.editor.createDecorationsCollection();
    const linkGesture = new ClickLinkGesture(editor2);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {
          this.removeLinkDecorations();
        }, (error) => {
          this.removeLinkDecorations();
          onUnexpectedError(error);
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor2) {
    return editor2.getContribution(GotoDefinitionAtPositionEditorContribution2.ID);
  }
  startFindDefinitionFromCursor(position) {
    return this.startFindDefinition(position).then(() => {
      this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }));
      this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
        if (e) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          this.toUnhookForKeyboard.clear();
        }
      }));
    });
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  startFindDefinition(position) {
    var _a6;
    this.toUnhookForKeyboard.clear();
    const word = position ? (_a6 = this.editor.getModel()) === null || _a6 === void 0 ? void 0 : _a6.getWordAtPosition(position) : null;
    if (!word) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return Promise.resolve(0);
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
      return Promise.resolve(0);
    }
    this.currentWordAtPosition = word;
    const state = new EditorState(this.editor, 4 | 1 | 2 | 8);
    if (this.previousPromise) {
      this.previousPromise.cancel();
      this.previousPromise = null;
    }
    this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
    return this.previousPromise.then((results) => {
      if (!results || !results.length || !state.validate(this.editor)) {
        this.removeLinkDecorations();
        return;
      }
      const linkRange = results[0].originSelectionRange ? Range.lift(results[0].originSelectionRange) : new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
      if (results.length > 1) {
        let combinedRange = linkRange;
        for (const { originSelectionRange } of results) {
          if (originSelectionRange) {
            combinedRange = Range.plusRange(combinedRange, originSelectionRange);
          }
        }
        this.addDecoration(combinedRange, new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
      } else {
        const result = results[0];
        if (!result.uri) {
          return;
        }
        this.textModelResolverService.createModelReference(result.uri).then((ref) => {
          if (!ref.object || !ref.object.textEditorModel) {
            ref.dispose();
            return;
          }
          const { object: { textEditorModel } } = ref;
          const { startLineNumber } = result.range;
          if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
            ref.dispose();
            return;
          }
          const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
          const languageId = this.languageService.guessLanguageIdByFilepathOrFirstLine(textEditorModel.uri);
          this.addDecoration(linkRange, previewValue ? new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue) : void 0);
          ref.dispose();
        });
      }
    }).then(void 0, onUnexpectedError);
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.range;
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range(startLineNumber, 1, endLineNumber + 1, 1);
  }
  addDecoration(range, hoverMessage) {
    const newDecorations = {
      range,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations.set([newDecorations]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(mouseEvent, withKey) {
    return this.editor.hasModel() && mouseEvent.isLeftClick && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(this.languageFeaturesService.definitionProvider, model, position, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(81) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor, this.editor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
  }
}, "GotoDefinitionAtPositionEditorContribution");
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = __decorate19([
  __param19(1, ITextModelService),
  __param19(2, ILanguageService),
  __param19(3, ILanguageFeaturesService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(GotoDefinitionAtPositionEditorContribution.ID, GotoDefinitionAtPositionEditorContribution, 2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_define_process();
init_dom();

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
init_define_process();
init_dom();
init_keyboardEvent();
init_lifecycle();
var $3 = $;
var HoverWidget = class extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this.scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
__name(HoverWidget, "HoverWidget");
var HoverAction = class extends Disposable {
  static render(parent, actionOptions, keybindingLabel) {
    return new HoverAction(parent, actionOptions, keybindingLabel);
  }
  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = append(parent, $3("div.action-container"));
    this.actionContainer.setAttribute("tabindex", "0");
    this.action = append(this.actionContainer, $3("a.action"));
    this.action.setAttribute("role", "button");
    if (actionOptions.iconClass) {
      append(this.action, $3(`span.icon.${actionOptions.iconClass}`));
    }
    const label = append(this.action, $3("span"));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
    this._register(addDisposableListener(this.actionContainer, EventType.CLICK, (e) => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));
    this._register(addDisposableListener(this.actionContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(3) || event.equals(10)) {
        e.stopPropagation();
        e.preventDefault();
        actionOptions.run(this.actionContainer);
      }
    }));
    this.setEnabled(true);
  }
  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove("disabled");
      this.actionContainer.removeAttribute("aria-disabled");
    } else {
      this.actionContainer.classList.add("disabled");
      this.actionContainer.setAttribute("aria-disabled", "true");
    }
  }
};
__name(HoverAction, "HoverAction");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_arrays();
init_lifecycle();
init_position();
init_range();
init_textModel();
init_languages();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverOperation.js
init_define_process();
init_async();
init_errors();
init_event();
init_lifecycle();
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
};
var HoverResult = class {
  constructor(value, isComplete, hasLoadingMessage) {
    this.value = value;
    this.isComplete = isComplete;
    this.hasLoadingMessage = hasLoadingMessage;
  }
};
__name(HoverResult, "HoverResult");
var HoverOperation = class extends Disposable {
  constructor(_editor, _computer) {
    super();
    this._editor = _editor;
    this._computer = _computer;
    this._onResult = this._register(new Emitter());
    this.onResult = this._onResult.event;
    this._firstWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerAsyncComputation(), 0));
    this._secondWaitScheduler = this._register(new RunOnceScheduler(() => this._triggerSyncComputation(), 0));
    this._loadingMessageScheduler = this._register(new RunOnceScheduler(() => this._triggerLoadingMessage(), 0));
    this._state = 0;
    this._asyncIterable = null;
    this._asyncIterableDone = false;
    this._result = [];
  }
  dispose() {
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(55).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(state, fireResult = true) {
    this._state = state;
    if (fireResult) {
      this._fireResult();
    }
  }
  _triggerAsyncComputation() {
    this._setState(2);
    this._secondWaitScheduler.schedule(this._secondWaitTime);
    if (this._computer.computeAsync) {
      this._asyncIterableDone = false;
      this._asyncIterable = createCancelableAsyncIterable((token) => this._computer.computeAsync(token));
      (() => __awaiter17(this, void 0, void 0, function* () {
        var _a6, e_1, _b2, _c2;
        try {
          try {
            for (var _d2 = true, _e2 = __asyncValues(this._asyncIterable), _f2; _f2 = yield _e2.next(), _a6 = _f2.done, !_a6; ) {
              _c2 = _f2.value;
              _d2 = false;
              try {
                const item = _c2;
                if (item) {
                  this._result.push(item);
                  this._fireResult();
                }
              } finally {
                _d2 = true;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d2 && !_a6 && (_b2 = _e2.return))
                yield _b2.call(_e2);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this._asyncIterableDone = true;
          if (this._state === 3 || this._state === 4) {
            this._setState(0);
          }
        } catch (e) {
          onUnexpectedError(e);
        }
      }))();
    } else {
      this._asyncIterableDone = true;
    }
  }
  _triggerSyncComputation() {
    if (this._computer.computeSync) {
      this._result = this._result.concat(this._computer.computeSync());
    }
    this._setState(this._asyncIterableDone ? 0 : 3);
  }
  _triggerLoadingMessage() {
    if (this._state === 3) {
      this._setState(4);
    }
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2) {
      return;
    }
    const isComplete = this._state === 0;
    const hasLoadingMessage = this._state === 4;
    this._onResult.fire(new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage));
  }
  start(mode) {
    if (mode === 0) {
      if (this._state === 0) {
        this._setState(1);
        this._firstWaitScheduler.schedule(this._firstWaitTime);
        this._loadingMessageScheduler.schedule(this._loadingMessageTime);
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation();
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
      }
    }
  }
  cancel() {
    this._firstWaitScheduler.cancel();
    this._secondWaitScheduler.cancel();
    this._loadingMessageScheduler.cancel();
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._result = [];
    this._setState(0, false);
  }
};
__name(HoverOperation, "HoverOperation");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hoverTypes.js
init_define_process();
var HoverRangeAnchor = class {
  constructor(priority, range, initialMousePosX, initialMousePosY) {
    this.priority = priority;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.type = 1;
  }
  equals(other) {
    return other.type === 1 && this.range.equalsRange(other.range);
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
  }
};
__name(HoverRangeAnchor, "HoverRangeAnchor");
var HoverForeignElementAnchor = class {
  constructor(priority, owner, range, initialMousePosX, initialMousePosY) {
    this.priority = priority;
    this.owner = owner;
    this.range = range;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.type = 2;
  }
  equals(other) {
    return other.type === 2 && this.owner === other.owner;
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
  }
};
__name(HoverForeignElementAnchor, "HoverForeignElementAnchor");
var HoverParticipantRegistry = new (/* @__PURE__ */ __name(class HoverParticipantRegistry2 {
  constructor() {
    this._participants = [];
  }
  register(ctor) {
    this._participants.push(ctor);
  }
  getAll() {
    return this._participants;
  }
}, "HoverParticipantRegistry"))();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_contextkey();
init_instantiation();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js
init_define_process();
init_cancellation();
init_errors();
init_lifecycle();
init_stopwatch();
init_types();
init_uri();
init_position();
init_range();
init_resolverService();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetParser.js
init_define_process();
var Scanner = class {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static isDigitCharacter(ch) {
    return ch >= 48 && ch <= 57;
  }
  static isVariableCharacter(ch) {
    return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14, pos: this.pos, len: 0 };
    }
    const pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type;
    type = Scanner._table[ch];
    if (typeof type === "number") {
      this.pos += 1;
      return { type, pos, len: 1 };
    }
    if (Scanner.isDigitCharacter(ch)) {
      type = 8;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    if (Scanner.isVariableCharacter(ch)) {
      type = 9;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    type = 10;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof Scanner._table[ch] === "undefined" && !Scanner.isDigitCharacter(ch) && !Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type, pos, len };
  }
};
__name(Scanner, "Scanner");
Scanner._table = {
  [36]: 0,
  [58]: 1,
  [44]: 2,
  [123]: 3,
  [125]: 4,
  [92]: 5,
  [47]: 6,
  [124]: 7,
  [43]: 11,
  [45]: 12,
  [63]: 13
};
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (/* @__PURE__ */ __name(function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    }, "_fixParent"))(others, parent);
  }
  get children() {
    return this._children;
  }
  get rightMostDescendant() {
    if (this._children.length > 0) {
      return this._children[this._children.length - 1].rightMostDescendant;
    }
    return this;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
__name(Marker, "Marker");
var Text = class extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new Text(this.value);
  }
};
__name(Text, "Text");
var TransformableMarker = class extends Marker {
};
__name(TransformableMarker, "TransformableMarker");
var Placeholder = class extends TransformableMarker {
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  constructor(index) {
    super();
    this.index = index;
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  clone() {
    const ret = new Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
__name(Placeholder, "Placeholder");
var Choice = class extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    const ret = new Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
__name(Choice, "Choice");
var Transform = class extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  clone() {
    const ret = new Transform();
    ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
__name(Transform, "Transform");
var FormatString = class extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1);
    }).join("");
  }
  _toCamelCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word, index) => {
      if (index === 0) {
        return word.charAt(0).toLowerCase() + word.substr(1);
      }
      return word.charAt(0).toUpperCase() + word.substr(1);
    }).join("");
  }
  clone() {
    const ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
__name(FormatString, "FormatString");
var Variable = class extends TransformableMarker {
  constructor(name) {
    super();
    this.name = name;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  clone() {
    const ret = new Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
__name(Variable, "Variable");
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
__name(walk, "walk");
var TextmateSnippet = class extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      const all = [];
      let last;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last = !last || last.index < candidate.index ? candidate : last;
        }
        return true;
      });
      this._placeholders = { all, last };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    const ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  clone() {
    const ret = new TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
__name(TextmateSnippet, "TextmateSnippet");
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    const snippet = new TextmateSnippet();
    this.parseFragment(value, snippet);
    this.ensureFinalTabstop(snippet, enforceFinalTabstop !== null && enforceFinalTabstop !== void 0 ? enforceFinalTabstop : false, insertFinalTabstop !== null && insertFinalTabstop !== void 0 ? insertFinalTabstop : false);
    return snippet;
  }
  parseFragment(value, snippet) {
    const offset = snippet.children.length;
    this._scanner.text(value);
    this._token = this._scanner.next();
    while (this._parse(snippet)) {
    }
    const placeholderDefaultValues = /* @__PURE__ */ new Map();
    const incompletePlaceholders = [];
    snippet.walk((marker) => {
      if (marker instanceof Placeholder) {
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone = new Placeholder(placeholder.index);
        clone.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone.appendChild(child.clone());
        }
        snippet.replace(placeholder, [clone]);
      }
    }
    return snippet.children.slice(offset);
  }
  ensureFinalTabstop(snippet, enforceFinalTabstop, insertFinalTabstop) {
    if (enforceFinalTabstop || insertFinalTabstop && snippet.placeholders.length > 0) {
      const finalTabstop = snippet.placeholders.find((p) => p.index === 0);
      if (!finalTabstop) {
        snippet.appendChild(new Placeholder(0));
      }
    }
  }
  _accept(type, value) {
    if (type === void 0 || this._token.type === type) {
      const ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type) {
    const start = this._token;
    while (this._token.type !== type) {
      if (this._token.type === 14) {
        return false;
      } else if (this._token.type === 5) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5, true)) {
      value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
    return true;
  }
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (index = this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2)) {
            continue;
          }
          if (this._accept(7)) {
            placeholder.appendChild(choice);
            if (this._accept(4)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values = [];
    while (true) {
      if (this._token.type === 2 || this._token.type === 7) {
        break;
      }
      let value;
      if (value = this._accept(5, true)) {
        value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values.push(value);
    }
    if (values.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text(values.join("")));
    return true;
  }
  _parseComplexVariable(parent) {
    let name;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (name = this._accept(9, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name);
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text("${" + name + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    const transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(5, true) || this._accept(6, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4)) {
        break;
      }
      if (this._token.type !== 14) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0)) {
      return false;
    }
    let complex = false;
    if (this._accept(3)) {
      complex = true;
    }
    const index = this._accept(8, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6)) {
      const shorthand = this._accept(9, true);
      if (!shorthand || !this._accept(4)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11)) {
      const ifValue = this._until(4);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12)) {
      const elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13)) {
      const ifValue = this._until(1);
      if (ifValue) {
        const elseValue = this._until(4);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      const elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14) {
      marker.appendChild(new Text(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};
__name(SnippetParser, "SnippetParser");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
init_define_process();
init_dom();
init_codicons();
init_event();
init_nls();
var NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
var NLS_PRESERVE_CASE_LABEL = localize("label.preserveCaseToggle", "Preserve Case");
var PreserveCaseToggle = class extends Toggle {
  constructor(opts) {
    super({
      icon: Codicon.preserveCase,
      title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
__name(PreserveCaseToggle, "PreserveCaseToggle");
var ReplaceInput = class extends Widget {
  constructor(parent, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this.cachedOptionsWidth = 0;
    this._onDidOptionChange = this._register(new Emitter());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter());
    this._onInput = this._register(new Emitter());
    this._onKeyUp = this._register(new Emitter());
    this._onPreserveCaseKeyDown = this._register(new Emitter());
    this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL;
    const appendPreserveCaseLabel = options.appendPreserveCaseLabel || "";
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      history,
      showHistoryHint: options.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight,
      inputBoxStyles: options.inputBoxStyles
    }));
    this.preserveCase = this._register(new PreserveCaseToggle(Object.assign({ appendTitle: appendPreserveCaseLabel, isChecked: false }, options.toggleStyles)));
    this._register(this.preserveCase.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.preserveCase.onKeyDown((e) => {
      this._onPreserveCaseKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.cachedOptionsWidth = this.preserveCase.width();
    } else {
      this.cachedOptionsWidth = 0;
    }
    const indexes = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(15) || event.equals(17) || event.equals(9)) {
        const index = indexes.indexOf(document.activeElement);
        if (index >= 0) {
          let newIndex = -1;
          if (event.equals(17)) {
            newIndex = (index + 1) % indexes.length;
          } else if (event.equals(15)) {
            if (index === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index - 1;
            }
          }
          if (event.equals(9)) {
            indexes[index].blur();
            this.inputBox.focus();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    const controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.preserveCase.domNode);
    this.domNode.appendChild(controls);
    parent === null || parent === void 0 ? void 0 : parent.appendChild(this.domNode);
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    this.domNode.classList.remove("disabled");
    this.inputBox.enable();
    this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled");
    this.inputBox.disable();
    this.preserveCase.disable();
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(value) {
    this.preserveCase.checked = value;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    var _a6;
    (_a6 = this.inputBox) === null || _a6 === void 0 ? void 0 : _a6.validate();
  }
  set width(newWidth) {
    this.inputBox.paddingRight = this.cachedOptionsWidth;
    this.domNode.style.width = newWidth + "px";
  }
  dispose() {
    super.dispose();
  }
};
__name(ReplaceInput, "ReplaceInput");

// ../../node_modules/monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js
init_contextkey();
init_keybindingsRegistry();
init_nls();
init_lifecycle();
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var historyNavigationVisible = new RawContextKey("suggestWidgetVisible", false, localize("suggestWidgetVisible", "Whether suggestion are visible"));
var HistoryNavigationWidgetFocusContext = "historyNavigationWidgetFocus";
var HistoryNavigationForwardsEnablementContext = "historyNavigationForwardsEnabled";
var HistoryNavigationBackwardsEnablementContext = "historyNavigationBackwardsEnabled";
var lastFocusedWidget = void 0;
var widgets = [];
function registerAndCreateHistoryNavigationContext(scopedContextKeyService, widget) {
  if (widgets.includes(widget)) {
    throw new Error("Cannot register the same widget multiple times");
  }
  widgets.push(widget);
  const disposableStore = new DisposableStore();
  const historyNavigationWidgetFocus = new RawContextKey(HistoryNavigationWidgetFocusContext, false).bindTo(scopedContextKeyService);
  const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const onDidFocus = /* @__PURE__ */ __name(() => {
    historyNavigationWidgetFocus.set(true);
    lastFocusedWidget = widget;
  }, "onDidFocus");
  const onDidBlur = /* @__PURE__ */ __name(() => {
    historyNavigationWidgetFocus.set(false);
    if (lastFocusedWidget === widget) {
      lastFocusedWidget = void 0;
    }
  }, "onDidBlur");
  if (widget.element === document.activeElement) {
    onDidFocus();
  }
  disposableStore.add(widget.onDidFocus(() => onDidFocus()));
  disposableStore.add(widget.onDidBlur(() => onDidBlur()));
  disposableStore.add(toDisposable(() => {
    widgets.splice(widgets.indexOf(widget), 1);
    onDidBlur();
  }));
  return {
    historyNavigationForwardsEnablement,
    historyNavigationBackwardsEnablement,
    dispose() {
      disposableStore.dispose();
    }
  };
}
__name(registerAndCreateHistoryNavigationContext, "registerAndCreateHistoryNavigationContext");
var ContextScopedFindInput = /* @__PURE__ */ __name(class ContextScopedFindInput2 extends FindInput {
  constructor(container, contextViewProvider, options, contextKeyService) {
    super(container, contextViewProvider, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
}, "ContextScopedFindInput");
ContextScopedFindInput = __decorate20([
  __param20(3, IContextKeyService)
], ContextScopedFindInput);
var ContextScopedReplaceInput = /* @__PURE__ */ __name(class ContextScopedReplaceInput2 extends ReplaceInput {
  constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
    super(container, contextViewProvider, showReplaceOptions, options);
    const scopedContextKeyService = this._register(contextKeyService.createScoped(this.inputBox.element));
    this._register(registerAndCreateHistoryNavigationContext(scopedContextKeyService, this.inputBox));
  }
}, "ContextScopedReplaceInput");
ContextScopedReplaceInput = __decorate20([
  __param20(3, IContextKeyService)
], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),
  primary: 16,
  secondary: [512 | 16],
  handler: (accessor) => {
    lastFocusedWidget === null || lastFocusedWidget === void 0 ? void 0 : lastFocusedWidget.showPreviousValue();
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetFocusContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), historyNavigationVisible.isEqualTo(false)),
  primary: 18,
  secondary: [512 | 18],
  handler: (accessor) => {
    lastFocusedWidget === null || lastFocusedWidget === void 0 ? void 0 : lastFocusedWidget.showNextValue();
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggest.js
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context = {
  Visible: historyNavigationVisible,
  HasFocusedSuggestion: new RawContextKey("suggestWidgetHasFocusedSuggestion", false, localize("suggestWidgetHasSelection", "Whether any suggestion is focused")),
  DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false, localize("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
  MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false, localize("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true, localize("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true, localize("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false, localize("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new RawContextKey("suggestionInsertMode", void 0, { type: "string", description: localize("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
  CanResolve: new RawContextKey("suggestionCanResolve", false, localize("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
};
var suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
var CompletionItem = class {
  constructor(position, completion, container, provider) {
    this.position = position;
    this.completion = completion;
    this.container = container;
    this.provider = provider;
    this.isInvalid = false;
    this.score = FuzzyScore.Default;
    this.distance = 0;
    this.textLabel = typeof completion.label === "string" ? completion.label : completion.label.label;
    this.labelLow = this.textLabel.toLowerCase();
    this.isInvalid = !this.textLabel;
    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
    this.extensionId = completion.extensionId;
    if (Range.isIRange(completion.range)) {
      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);
      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
    } else {
      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
    }
    if (typeof provider.resolveCompletionItem !== "function") {
      this._resolveCache = Promise.resolve();
      this._isResolved = true;
    }
  }
  get isResolved() {
    return !!this._isResolved;
  }
  resolve(token) {
    return __awaiter18(this, void 0, void 0, function* () {
      if (!this._resolveCache) {
        const sub = token.onCancellationRequested(() => {
          this._resolveCache = void 0;
          this._isResolved = false;
        });
        this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
          Object.assign(this.completion, value);
          this._isResolved = true;
          sub.dispose();
        }, (err) => {
          if (isCancellationError(err)) {
            this._resolveCache = void 0;
            this._isResolved = false;
          }
        });
      }
      return this._resolveCache;
    });
  }
};
__name(CompletionItem, "CompletionItem");
var CompletionOptions = class {
  constructor(snippetSortOrder = 2, kindFilter = /* @__PURE__ */ new Set(), providerFilter = /* @__PURE__ */ new Set(), providerItemsToReuse = /* @__PURE__ */ new Map(), showDeprecated = true) {
    this.snippetSortOrder = snippetSortOrder;
    this.kindFilter = kindFilter;
    this.providerFilter = providerFilter;
    this.providerItemsToReuse = providerItemsToReuse;
    this.showDeprecated = showDeprecated;
  }
};
__name(CompletionOptions, "CompletionOptions");
CompletionOptions.default = new CompletionOptions();
var _snippetSuggestSupport;
function getSnippetSuggestSupport() {
  return _snippetSuggestSupport;
}
__name(getSnippetSuggestSupport, "getSnippetSuggestSupport");
var CompletionItemModel = class {
  constructor(items, needsClipboard, durations, disposable) {
    this.items = items;
    this.needsClipboard = needsClipboard;
    this.durations = durations;
    this.disposable = disposable;
  }
};
__name(CompletionItemModel, "CompletionItemModel");
function provideSuggestionItems(registry, model, position, options = CompletionOptions.default, context = { triggerKind: 0 }, token = CancellationToken.None) {
  return __awaiter18(this, void 0, void 0, function* () {
    const sw = new StopWatch(true);
    position = position.clone();
    const word = model.getWordAtPosition(position);
    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
    const result = [];
    const disposables = new DisposableStore();
    const durations = [];
    let needsClipboard = false;
    const onCompletionList = /* @__PURE__ */ __name((provider, container, sw2) => {
      var _a6, _b2, _c2;
      let didAddResult = false;
      if (!container) {
        return didAddResult;
      }
      for (const suggestion of container.suggestions) {
        if (!options.kindFilter.has(suggestion.kind)) {
          if (!options.showDeprecated && ((_a6 = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a6 === void 0 ? void 0 : _a6.includes(1))) {
            continue;
          }
          if (!suggestion.range) {
            suggestion.range = defaultRange;
          }
          if (!suggestion.sortText) {
            suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.label;
          }
          if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) {
            needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
          }
          result.push(new CompletionItem(position, suggestion, container, provider));
          didAddResult = true;
        }
      }
      if (isDisposable(container)) {
        disposables.add(container);
      }
      durations.push({
        providerName: (_b2 = provider._debugDisplayName) !== null && _b2 !== void 0 ? _b2 : "unknown_provider",
        elapsedProvider: (_c2 = container.duration) !== null && _c2 !== void 0 ? _c2 : -1,
        elapsedOverall: sw2.elapsed()
      });
      return didAddResult;
    }, "onCompletionList");
    const snippetCompletions = (() => __awaiter18(this, void 0, void 0, function* () {
      if (!_snippetSuggestSupport || options.kindFilter.has(27)) {
        return;
      }
      if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
        return;
      }
      const sw2 = new StopWatch(true);
      const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
      onCompletionList(_snippetSuggestSupport, list, sw2);
    }))();
    for (const providerGroup of registry.orderedGroups(model)) {
      let didAddResult = false;
      yield Promise.all(providerGroup.map((provider) => __awaiter18(this, void 0, void 0, function* () {
        if (options.providerItemsToReuse.has(provider)) {
          const items = options.providerItemsToReuse.get(provider);
          items.forEach((item) => result.push(item));
          didAddResult = didAddResult || items.length > 0;
          return;
        }
        if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
          return;
        }
        try {
          const sw2 = new StopWatch(true);
          const list = yield provider.provideCompletionItems(model, position, context, token);
          didAddResult = onCompletionList(provider, list, sw2) || didAddResult;
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      if (didAddResult || token.isCancellationRequested) {
        break;
      }
    }
    yield snippetCompletions;
    if (token.isCancellationRequested) {
      disposables.dispose();
      return Promise.reject(new CancellationError());
    }
    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
  });
}
__name(provideSuggestionItems, "provideSuggestionItems");
function defaultComparator(a, b) {
  if (a.sortTextLow && b.sortTextLow) {
    if (a.sortTextLow < b.sortTextLow) {
      return -1;
    } else if (a.sortTextLow > b.sortTextLow) {
      return 1;
    }
  }
  if (a.textLabel < b.textLabel) {
    return -1;
  } else if (a.textLabel > b.textLabel) {
    return 1;
  }
  return a.completion.kind - b.completion.kind;
}
__name(defaultComparator, "defaultComparator");
function snippetUpComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return -1;
    } else if (b.completion.kind === 27) {
      return 1;
    }
  }
  return defaultComparator(a, b);
}
__name(snippetUpComparator, "snippetUpComparator");
function snippetDownComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return 1;
    } else if (b.completion.kind === 27) {
      return -1;
    }
  }
  return defaultComparator(a, b);
}
__name(snippetDownComparator, "snippetDownComparator");
var _snippetComparators = /* @__PURE__ */ new Map();
_snippetComparators.set(0, snippetUpComparator);
_snippetComparators.set(2, snippetDownComparator);
_snippetComparators.set(1, defaultComparator);
function getSuggestionComparator(snippetConfig) {
  return _snippetComparators.get(snippetConfig);
}
__name(getSuggestionComparator, "getSuggestionComparator");
CommandsRegistry.registerCommand("_executeCompletionItemProvider", (accessor, ...args) => __awaiter18(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter, maxItemsToResolve] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  assertType(typeof maxItemsToResolve === "number" || !maxItemsToResolve);
  const { completionProvider } = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = {
      incomplete: false,
      suggestions: []
    };
    const resolving = [];
    const completions = yield provideSuggestionItems(completionProvider, ref.object.textEditorModel, Position.lift(position), void 0, { triggerCharacter: triggerCharacter !== null && triggerCharacter !== void 0 ? triggerCharacter : void 0, triggerKind: triggerCharacter ? 1 : 0 });
    for (const item of completions.items) {
      if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {
        resolving.push(item.resolve(CancellationToken.None));
      }
      result.incomplete = result.incomplete || item.container.incomplete;
      result.suggestions.push(item.completion);
    }
    try {
      yield Promise.all(resolving);
      return result;
    } finally {
      setTimeout(() => completions.disposable.dispose(), 100);
    }
  } finally {
    ref.dispose();
  }
}));
function showSimpleSuggestions(editor2, provider) {
  var _a6;
  (_a6 = editor2.getContribution("editor.contrib.suggestController")) === null || _a6 === void 0 ? void 0 : _a6.triggerSuggest((/* @__PURE__ */ new Set()).add(provider), void 0, true);
}
__name(showSimpleSuggestions, "showSimpleSuggestions");
var QuickSuggestionsOptions = class {
  static isAllOff(config) {
    return config.other === "off" && config.comments === "off" && config.strings === "off";
  }
  static isAllOn(config) {
    return config.other === "on" && config.comments === "on" && config.strings === "on";
  }
  static valueFor(config, tokenType) {
    switch (tokenType) {
      case 1:
        return config.comments;
      case 2:
        return config.strings;
      default:
        return config.other;
    }
  }
};
__name(QuickSuggestionsOptions, "QuickSuggestionsOptions");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/contentHover.js
init_async();
init_editorContextKeys();
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $4 = $;
var ContentHoverController = /* @__PURE__ */ __name(class ContentHoverController2 extends Disposable {
  constructor(_editor, _instantiationService, _keybindingService) {
    super();
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._keybindingService = _keybindingService;
    this._widget = this._register(this._instantiationService.createInstance(ContentHoverWidget, this._editor));
    this._currentResult = null;
    this._participants = [];
    for (const participant of HoverParticipantRegistry.getAll()) {
      this._participants.push(this._instantiationService.createInstance(participant, this._editor));
    }
    this._participants.sort((p1, p2) => p1.hoverOrdinal - p2.hoverOrdinal);
    this._computer = new ContentHoverComputer(this._editor, this._participants);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      if (!this._computer.anchor) {
        return;
      }
      const messages = result.hasLoadingMessage ? this._addLoadingMessage(result.value) : result.value;
      this._withResult(new HoverResult2(this._computer.anchor, messages, result.isComplete));
    }));
    this._register(addStandardDisposableListener(this._widget.getDomNode(), "keydown", (e) => {
      if (e.equals(9)) {
        this.hide();
      }
    }));
    this._register(TokenizationRegistry.onDidChange(() => {
      if (this._widget.position && this._currentResult) {
        this._widget.clear();
        this._setCurrentResult(this._currentResult);
      }
    }));
  }
  maybeShowAt(mouseEvent) {
    const anchorCandidates = [];
    for (const participant of this._participants) {
      if (participant.suggestHoverAnchor) {
        const anchor = participant.suggestHoverAnchor(mouseEvent);
        if (anchor) {
          anchorCandidates.push(anchor);
        }
      }
    }
    const target = mouseEvent.target;
    if (target.type === 6) {
      anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
    }
    if (target.type === 7) {
      const epsilon = this._editor.getOption(45).typicalHalfwidthCharacterWidth / 2;
      if (!target.detail.isAfterLines && typeof target.detail.horizontalDistanceToText === "number" && target.detail.horizontalDistanceToText < epsilon) {
        anchorCandidates.push(new HoverRangeAnchor(0, target.range, mouseEvent.event.posx, mouseEvent.event.posy));
      }
    }
    if (anchorCandidates.length === 0) {
      return this._startShowingOrUpdateHover(null, 0, 0, false, mouseEvent);
    }
    anchorCandidates.sort((a, b) => b.priority - a.priority);
    return this._startShowingOrUpdateHover(anchorCandidates[0], 0, 0, false, mouseEvent);
  }
  startShowingAtRange(range, mode, source, focus) {
    this._startShowingOrUpdateHover(new HoverRangeAnchor(0, range, void 0, void 0), mode, source, focus, null);
  }
  _startShowingOrUpdateHover(anchor, mode, source, focus, mouseEvent) {
    if (!this._widget.position || !this._currentResult) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
        return true;
      }
      return false;
    }
    const hoverIsSticky = this._editor.getOption(55).sticky;
    const isGettingCloser = hoverIsSticky && mouseEvent && this._widget.isMouseGettingCloser(mouseEvent.event.posx, mouseEvent.event.posy);
    if (isGettingCloser) {
      if (anchor) {
        this._startHoverOperationIfNecessary(anchor, mode, source, focus, true);
      }
      return true;
    }
    if (!anchor) {
      this._setCurrentResult(null);
      return false;
    }
    if (anchor && this._currentResult.anchor.equals(anchor)) {
      return true;
    }
    if (!anchor.canAdoptVisibleHover(this._currentResult.anchor, this._widget.position)) {
      this._setCurrentResult(null);
      this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
      return true;
    }
    this._setCurrentResult(this._currentResult.filter(anchor));
    this._startHoverOperationIfNecessary(anchor, mode, source, focus, false);
    return true;
  }
  _startHoverOperationIfNecessary(anchor, mode, source, focus, insistOnKeepingHoverVisible) {
    if (this._computer.anchor && this._computer.anchor.equals(anchor)) {
      return;
    }
    this._hoverOperation.cancel();
    this._computer.anchor = anchor;
    this._computer.shouldFocus = focus;
    this._computer.source = source;
    this._computer.insistOnKeepingHoverVisible = insistOnKeepingHoverVisible;
    this._hoverOperation.start(mode);
  }
  _setCurrentResult(hoverResult) {
    if (this._currentResult === hoverResult) {
      return;
    }
    if (hoverResult && hoverResult.messages.length === 0) {
      hoverResult = null;
    }
    this._currentResult = hoverResult;
    if (this._currentResult) {
      this._renderMessages(this._currentResult.anchor, this._currentResult.messages);
    } else {
      this._widget.hide();
    }
  }
  hide() {
    this._computer.anchor = null;
    this._hoverOperation.cancel();
    this._setCurrentResult(null);
  }
  isColorPickerVisible() {
    return this._widget.isColorPickerVisible;
  }
  isVisibleFromKeyboard() {
    return this._widget.isVisibleFromKeyboard;
  }
  containsNode(node) {
    return this._widget.getDomNode().contains(node);
  }
  _addLoadingMessage(result) {
    if (this._computer.anchor) {
      for (const participant of this._participants) {
        if (participant.createLoadingMessage) {
          const loadingMessage = participant.createLoadingMessage(this._computer.anchor);
          if (loadingMessage) {
            return result.slice(0).concat([loadingMessage]);
          }
        }
      }
    }
    return result;
  }
  _withResult(hoverResult) {
    if (this._widget.position && this._currentResult && this._currentResult.isComplete) {
      if (!hoverResult.isComplete) {
        return;
      }
      if (this._computer.insistOnKeepingHoverVisible && hoverResult.messages.length === 0) {
        return;
      }
    }
    this._setCurrentResult(hoverResult);
  }
  _renderMessages(anchor, messages) {
    const { showAtPosition, showAtSecondaryPosition, highlightRange } = ContentHoverController2.computeHoverRanges(this._editor, anchor.range, messages);
    const disposables = new DisposableStore();
    const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
    const fragment = document.createDocumentFragment();
    let colorPicker = null;
    const context = {
      fragment,
      statusBar,
      setColorPicker: (widget) => colorPicker = widget,
      onContentsChanged: () => this._widget.onContentsChanged(),
      hide: () => this.hide()
    };
    for (const participant of this._participants) {
      const hoverParts = messages.filter((msg) => msg.owner === participant);
      if (hoverParts.length > 0) {
        disposables.add(participant.renderHoverParts(context, hoverParts));
      }
    }
    const isBeforeContent = messages.some((m) => m.isBeforeContent);
    if (statusBar.hasContent) {
      fragment.appendChild(statusBar.hoverElement);
    }
    if (fragment.hasChildNodes()) {
      if (highlightRange) {
        const highlightDecoration = this._editor.createDecorationsCollection();
        highlightDecoration.set([{
          range: highlightRange,
          options: ContentHoverController2._DECORATION_OPTIONS
        }]);
        disposables.add(toDisposable(() => {
          highlightDecoration.clear();
        }));
      }
      this._widget.showAt(fragment, new ContentHoverVisibleData(colorPicker, showAtPosition, showAtSecondaryPosition, this._editor.getOption(55).above, this._computer.shouldFocus, this._computer.source, isBeforeContent, anchor.initialMousePosX, anchor.initialMousePosY, disposables));
    } else {
      disposables.dispose();
    }
  }
  static computeHoverRanges(editor2, anchorRange, messages) {
    let startColumnBoundary = 1;
    if (editor2.hasModel()) {
      const viewModel = editor2._getViewModel();
      const coordinatesConverter = viewModel.coordinatesConverter;
      const anchorViewRange = coordinatesConverter.convertModelRangeToViewRange(anchorRange);
      const anchorViewRangeStart = new Position(anchorViewRange.startLineNumber, viewModel.getLineMinColumn(anchorViewRange.startLineNumber));
      startColumnBoundary = coordinatesConverter.convertViewPositionToModelPosition(anchorViewRangeStart).column;
    }
    const anchorLineNumber = anchorRange.startLineNumber;
    let renderStartColumn = anchorRange.startColumn;
    let highlightRange = messages[0].range;
    let forceShowAtRange = null;
    for (const msg of messages) {
      highlightRange = Range.plusRange(highlightRange, msg.range);
      if (msg.range.startLineNumber === anchorLineNumber && msg.range.endLineNumber === anchorLineNumber) {
        renderStartColumn = Math.max(Math.min(renderStartColumn, msg.range.startColumn), startColumnBoundary);
      }
      if (msg.forceShowAtRange) {
        forceShowAtRange = msg.range;
      }
    }
    return {
      showAtPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, anchorRange.startColumn),
      showAtSecondaryPosition: forceShowAtRange ? forceShowAtRange.getStartPosition() : new Position(anchorLineNumber, renderStartColumn),
      highlightRange
    };
  }
}, "ContentHoverController");
ContentHoverController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
ContentHoverController = __decorate21([
  __param21(1, IInstantiationService),
  __param21(2, IKeybindingService)
], ContentHoverController);
var HoverResult2 = class {
  constructor(anchor, messages, isComplete) {
    this.anchor = anchor;
    this.messages = messages;
    this.isComplete = isComplete;
  }
  filter(anchor) {
    const filteredMessages = this.messages.filter((m) => m.isValidForHoverAnchor(anchor));
    if (filteredMessages.length === this.messages.length) {
      return this;
    }
    return new FilteredHoverResult(this, this.anchor, filteredMessages, this.isComplete);
  }
};
__name(HoverResult2, "HoverResult");
var FilteredHoverResult = class extends HoverResult2 {
  constructor(original, anchor, messages, isComplete) {
    super(anchor, messages, isComplete);
    this.original = original;
  }
  filter(anchor) {
    return this.original.filter(anchor);
  }
};
__name(FilteredHoverResult, "FilteredHoverResult");
var ContentHoverVisibleData = class {
  constructor(colorPicker, showAtPosition, showAtSecondaryPosition, preferAbove, stoleFocus, source, isBeforeContent, initialMousePosX, initialMousePosY, disposables) {
    this.colorPicker = colorPicker;
    this.showAtPosition = showAtPosition;
    this.showAtSecondaryPosition = showAtSecondaryPosition;
    this.preferAbove = preferAbove;
    this.stoleFocus = stoleFocus;
    this.source = source;
    this.isBeforeContent = isBeforeContent;
    this.initialMousePosX = initialMousePosX;
    this.initialMousePosY = initialMousePosY;
    this.disposables = disposables;
    this.closestMouseDistance = void 0;
  }
};
__name(ContentHoverVisibleData, "ContentHoverVisibleData");
var ContentHoverWidget = /* @__PURE__ */ __name(class ContentHoverWidget2 extends Disposable {
  get position() {
    var _a6, _b2;
    return (_b2 = (_a6 = this._visibleData) === null || _a6 === void 0 ? void 0 : _a6.showAtPosition) !== null && _b2 !== void 0 ? _b2 : null;
  }
  get isColorPickerVisible() {
    var _a6;
    return Boolean((_a6 = this._visibleData) === null || _a6 === void 0 ? void 0 : _a6.colorPicker);
  }
  get isVisibleFromKeyboard() {
    var _a6;
    return ((_a6 = this._visibleData) === null || _a6 === void 0 ? void 0 : _a6.source) === 1;
  }
  constructor(_editor, _contextKeyService) {
    super();
    this._editor = _editor;
    this._contextKeyService = _contextKeyService;
    this.allowEditorOverflow = true;
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(this._contextKeyService);
    this._hover = this._register(new HoverWidget());
    this._visibleData = null;
    this._register(this._editor.onDidLayoutChange(() => this._layout()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45)) {
        this._updateFont();
      }
    }));
    this._setVisibleData(null);
    this._layout();
    this._editor.addContentWidget(this);
  }
  dispose() {
    this._editor.removeContentWidget(this);
    if (this._visibleData) {
      this._visibleData.disposables.dispose();
    }
    super.dispose();
  }
  getId() {
    return ContentHoverWidget2.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    if (!this._visibleData) {
      return null;
    }
    let preferAbove = this._visibleData.preferAbove;
    if (!preferAbove && this._contextKeyService.getContextKeyValue(Context.Visible.key)) {
      preferAbove = true;
    }
    const affinity = this._visibleData.isBeforeContent ? 3 : void 0;
    return {
      position: this._visibleData.showAtPosition,
      secondaryPosition: this._visibleData.showAtSecondaryPosition,
      preference: preferAbove ? [1, 2] : [2, 1],
      positionAffinity: affinity
    };
  }
  isMouseGettingCloser(posx, posy) {
    if (!this._visibleData) {
      return false;
    }
    if (typeof this._visibleData.initialMousePosX === "undefined" || typeof this._visibleData.initialMousePosY === "undefined") {
      this._visibleData.initialMousePosX = posx;
      this._visibleData.initialMousePosY = posy;
      return false;
    }
    const widgetRect = getDomNodePagePosition(this.getDomNode());
    if (typeof this._visibleData.closestMouseDistance === "undefined") {
      this._visibleData.closestMouseDistance = computeDistanceFromPointToRectangle(this._visibleData.initialMousePosX, this._visibleData.initialMousePosY, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    }
    const distance = computeDistanceFromPointToRectangle(posx, posy, widgetRect.left, widgetRect.top, widgetRect.width, widgetRect.height);
    if (distance > this._visibleData.closestMouseDistance + 4) {
      return false;
    }
    this._visibleData.closestMouseDistance = Math.min(this._visibleData.closestMouseDistance, distance);
    return true;
  }
  _setVisibleData(visibleData) {
    if (this._visibleData) {
      this._visibleData.disposables.dispose();
    }
    this._visibleData = visibleData;
    this._hoverVisibleKey.set(!!this._visibleData);
    this._hover.containerDomNode.classList.toggle("hidden", !this._visibleData);
  }
  _layout() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
    const { fontSize, lineHeight } = this._editor.getOption(45);
    this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;
    this._hover.contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
    this._hover.contentsDomNode.style.maxHeight = `${height}px`;
    this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  showAt(node, visibleData) {
    var _a6;
    this._setVisibleData(visibleData);
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._hover.contentsDomNode.style.paddingBottom = "";
    this._updateFont();
    this.onContentsChanged();
    this._editor.render();
    this.onContentsChanged();
    if (visibleData.stoleFocus) {
      this._hover.containerDomNode.focus();
    }
    (_a6 = visibleData.colorPicker) === null || _a6 === void 0 ? void 0 : _a6.layout();
  }
  hide() {
    if (this._visibleData) {
      const stoleFocus = this._visibleData.stoleFocus;
      this._setVisibleData(null);
      this._editor.layoutContentWidget(this);
      if (stoleFocus) {
        this._editor.focus();
      }
    }
  }
  onContentsChanged() {
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
    const scrollDimensions = this._hover.scrollbar.getScrollDimensions();
    const hasHorizontalScrollbar = scrollDimensions.scrollWidth > scrollDimensions.width;
    if (hasHorizontalScrollbar) {
      const extraBottomPadding = `${this._hover.scrollbar.options.horizontalScrollbarSize}px`;
      if (this._hover.contentsDomNode.style.paddingBottom !== extraBottomPadding) {
        this._hover.contentsDomNode.style.paddingBottom = extraBottomPadding;
        this._editor.layoutContentWidget(this);
        this._hover.onContentsChanged();
      }
    }
  }
  clear() {
    this._hover.contentsDomNode.textContent = "";
  }
}, "ContentHoverWidget");
ContentHoverWidget.ID = "editor.contrib.contentHoverWidget";
ContentHoverWidget = __decorate21([
  __param21(1, IContextKeyService)
], ContentHoverWidget);
var EditorHoverStatusBar = /* @__PURE__ */ __name(class EditorHoverStatusBar2 extends Disposable {
  get hasContent() {
    return this._hasContent;
  }
  constructor(_keybindingService) {
    super();
    this._keybindingService = _keybindingService;
    this._hasContent = false;
    this.hoverElement = $4("div.hover-row.status-bar");
    this.actionsElement = append(this.hoverElement, $4("div.actions"));
  }
  addAction(actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    this._hasContent = true;
    return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
  }
  append(element) {
    const result = append(this.actionsElement, element);
    this._hasContent = true;
    return result;
  }
}, "EditorHoverStatusBar");
EditorHoverStatusBar = __decorate21([
  __param21(0, IKeybindingService)
], EditorHoverStatusBar);
var ContentHoverComputer = class {
  get anchor() {
    return this._anchor;
  }
  set anchor(value) {
    this._anchor = value;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(value) {
    this._shouldFocus = value;
  }
  get source() {
    return this._source;
  }
  set source(value) {
    this._source = value;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(value) {
    this._insistOnKeepingHoverVisible = value;
  }
  constructor(_editor, _participants) {
    this._editor = _editor;
    this._participants = _participants;
    this._anchor = null;
    this._shouldFocus = false;
    this._source = 0;
    this._insistOnKeepingHoverVisible = false;
  }
  static _getLineDecorations(editor2, anchor) {
    if (anchor.type !== 1) {
      return [];
    }
    const model = editor2.getModel();
    const lineNumber = anchor.range.startLineNumber;
    if (lineNumber > model.getLineCount()) {
      return [];
    }
    const maxColumn = model.getLineMaxColumn(lineNumber);
    return editor2.getLineDecorations(lineNumber).filter((d) => {
      if (d.options.isWholeLine) {
        return true;
      }
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (d.options.showIfCollapsed) {
        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {
          return false;
        }
      } else {
        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
          return false;
        }
      }
      return true;
    });
  }
  computeAsync(token) {
    const anchor = this._anchor;
    if (!this._editor.hasModel() || !anchor) {
      return AsyncIterableObject.EMPTY;
    }
    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, anchor);
    return AsyncIterableObject.merge(this._participants.map((participant) => {
      if (!participant.computeAsync) {
        return AsyncIterableObject.EMPTY;
      }
      return participant.computeAsync(anchor, lineDecorations, token);
    }));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor) {
      return [];
    }
    const lineDecorations = ContentHoverComputer._getLineDecorations(this._editor, this._anchor);
    let result = [];
    for (const participant of this._participants) {
      result = result.concat(participant.computeSync(this._anchor, lineDecorations));
    }
    return coalesce(result);
  }
};
__name(ContentHoverComputer, "ContentHoverComputer");
function computeDistanceFromPointToRectangle(pointX, pointY, left, top, width, height) {
  const x = left + width / 2;
  const y = top + height / 2;
  const dx = Math.max(Math.abs(pointX - x) - width / 2, 0);
  const dy = Math.max(Math.abs(pointY - y) - height / 2, 0);
  return Math.sqrt(dx * dx + dy * dy);
}
__name(computeDistanceFromPointToRectangle, "computeDistanceFromPointToRectangle");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/marginHover.js
init_define_process();
init_dom();
init_arrays();
init_lifecycle();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/markdownRenderer/browser/markdownRenderer.js
init_define_process();
init_errors();
init_event();
init_lifecycle();
init_language();
init_modesRegistry();
init_opener();
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a2;
var MarkdownRenderer = /* @__PURE__ */ __name(class MarkdownRenderer2 {
  constructor(_options, _languageService, _openerService) {
    this._options = _options;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._onDidRenderAsync = new Emitter();
    this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(markdown, options, markedOptions) {
    if (!markdown) {
      const element = document.createElement("span");
      return { element, dispose: () => {
      } };
    }
    const disposables = new DisposableStore();
    const rendered = disposables.add(renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions));
    return {
      element: rendered.element,
      dispose: () => disposables.dispose()
    };
  }
  _getRenderOptions(markdown, disposables) {
    return {
      codeBlockRenderer: (languageAlias, value) => __awaiter19(this, void 0, void 0, function* () {
        var _a6, _b2, _c2;
        let languageId;
        if (languageAlias) {
          languageId = this._languageService.getLanguageIdByLanguageName(languageAlias);
        } else if (this._options.editor) {
          languageId = (_a6 = this._options.editor.getModel()) === null || _a6 === void 0 ? void 0 : _a6.getLanguageId();
        }
        if (!languageId) {
          languageId = PLAINTEXT_LANGUAGE_ID;
        }
        const html = yield tokenizeToString(this._languageService, value, languageId);
        const element = document.createElement("span");
        element.innerHTML = (_c2 = (_b2 = MarkdownRenderer2._ttpTokenizer) === null || _b2 === void 0 ? void 0 : _b2.createHTML(html)) !== null && _c2 !== void 0 ? _c2 : html;
        if (this._options.editor) {
          const fontInfo = this._options.editor.getOption(45);
          applyFontInfo(element, fontInfo);
        } else if (this._options.codeBlockFontFamily) {
          element.style.fontFamily = this._options.codeBlockFontFamily;
        }
        if (this._options.codeBlockFontSize !== void 0) {
          element.style.fontSize = this._options.codeBlockFontSize;
        }
        return element;
      }),
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (link) => openLinkFromMarkdown(this._openerService, link, markdown.isTrusted),
        disposables
      }
    };
  }
}, "MarkdownRenderer");
MarkdownRenderer._ttpTokenizer = (_a2 = window.trustedTypes) === null || _a2 === void 0 ? void 0 : _a2.createPolicy("tokenizeToString", {
  createHTML(html) {
    return html;
  }
});
MarkdownRenderer = __decorate22([
  __param22(1, ILanguageService),
  __param22(2, IOpenerService)
], MarkdownRenderer);
function openLinkFromMarkdown(openerService, link, isTrusted) {
  return __awaiter19(this, void 0, void 0, function* () {
    try {
      return yield openerService.open(link, {
        fromUserGesture: true,
        allowContributedOpeners: true,
        allowCommands: toAllowCommandsOption(isTrusted)
      });
    } catch (e) {
      onUnexpectedError(e);
      return false;
    }
  });
}
__name(openLinkFromMarkdown, "openLinkFromMarkdown");
function toAllowCommandsOption(isTrusted) {
  if (isTrusted === true) {
    return true;
  }
  if (isTrusted && Array.isArray(isTrusted.enabledCommands)) {
    return isTrusted.enabledCommands;
  }
  return false;
}
__name(toAllowCommandsOption, "toAllowCommandsOption");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/marginHover.js
var $5 = $;
var MarginHoverWidget = class extends Disposable {
  constructor(editor2, languageService, openerService) {
    super();
    this._renderDisposeables = this._register(new DisposableStore());
    this._editor = editor2;
    this._isVisible = false;
    this._messages = [];
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, languageService, openerService));
    this._computer = new MarginHoverComputer(this._editor);
    this._hoverOperation = this._register(new HoverOperation(this._editor, this._computer));
    this._register(this._hoverOperation.onResult((result) => {
      this._withResult(result.value);
    }));
    this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45)) {
        this._updateFont();
      }
    }));
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return MarginHoverWidget.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _onModelDecorationsChanged() {
    if (this._isVisible) {
      this._hoverOperation.cancel();
      this._hoverOperation.start(0);
    }
  }
  startShowingAt(lineNumber) {
    if (this._computer.lineNumber === lineNumber) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._computer.lineNumber = lineNumber;
    this._hoverOperation.start(0);
  }
  hide() {
    this._computer.lineNumber = -1;
    this._hoverOperation.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
  }
  _withResult(result) {
    this._messages = result;
    if (this._messages.length > 0) {
      this._renderMessages(this._computer.lineNumber, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, messages) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages) {
      const markdownHoverElement = $5("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $5("div.hover-contents"));
      const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
    this._updateContents(fragment);
    this._showAt(lineNumber);
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
  }
  _showAt(lineNumber) {
    if (!this._isVisible) {
      this._isVisible = true;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(61);
    const nodeHeight = this._hover.containerDomNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
    this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
  }
};
__name(MarginHoverWidget, "MarginHoverWidget");
MarginHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";
var MarginHoverComputer = class {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(value) {
    this._lineNumber = value;
  }
  constructor(_editor) {
    this._editor = _editor;
    this._lineNumber = -1;
  }
  computeSync() {
    const toHoverMessage = /* @__PURE__ */ __name((contents) => {
      return {
        value: contents
      };
    }, "toHoverMessage");
    const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
    const result = [];
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      if (!d.options.glyphMarginClassName) {
        continue;
      }
      const hoverMessage = d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
};
__name(MarginHoverComputer, "MarginHoverComputer");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
init_nls();
init_contextkey();
init_instantiation();
init_opener();
init_colorRegistry();
init_themeService();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_define_process();
init_dom();
init_arrays();
init_async();
init_lifecycle();
init_position();
init_range();
init_language();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/getHover.js
init_define_process();
init_async();
init_cancellation();
init_errors();
init_editorExtensions();
init_languageFeatures();
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HoverProviderResult = class {
  constructor(provider, hover, ordinal) {
    this.provider = provider;
    this.hover = hover;
    this.ordinal = ordinal;
  }
};
__name(HoverProviderResult, "HoverProviderResult");
function executeProvider(provider, ordinal, model, position, token) {
  return __awaiter20(this, void 0, void 0, function* () {
    try {
      const result = yield Promise.resolve(provider.provideHover(model, position, token));
      if (result && isValid(result)) {
        return new HoverProviderResult(provider, result, ordinal);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
    return void 0;
  });
}
__name(executeProvider, "executeProvider");
function getHover(registry, model, position, token) {
  const providers = registry.ordered(model);
  const promises = providers.map((provider, index) => executeProvider(provider, index, model, position, token));
  return AsyncIterableObject.fromPromises(promises).coalesce();
}
__name(getHover, "getHover");
function getHoverPromise(registry, model, position, token) {
  return getHover(registry, model, position, token).map((item) => item.hover).toPromise();
}
__name(getHoverPromise, "getHoverPromise");
registerModelAndPositionCommand("_executeHoverProvider", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getHoverPromise(languageFeaturesService.hoverProvider, model, position, CancellationToken.None);
});
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}
__name(isValid, "isValid");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markdownHoverParticipant.js
init_nls();
init_configuration();
init_opener();
init_languageFeatures();
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $6 = $;
var MarkdownHover = class {
  constructor(owner, range, contents, isBeforeContent, ordinal) {
    this.owner = owner;
    this.range = range;
    this.contents = contents;
    this.isBeforeContent = isBeforeContent;
    this.ordinal = ordinal;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
__name(MarkdownHover, "MarkdownHover");
var MarkdownHoverParticipant = /* @__PURE__ */ __name(class MarkdownHoverParticipant2 {
  constructor(_editor, _languageService, _openerService, _configurationService, _languageFeaturesService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 2;
  }
  createLoadingMessage(anchor) {
    return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))], false, 2e3);
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    let index = 1e3;
    const lineLength = model.getLineLength(lineNumber);
    const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
    const stopRenderingLineAfter = this._editor.getOption(109);
    const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: languageId
    });
    let stopRenderingMessage = false;
    if (stopRenderingLineAfter >= 0 && lineLength > stopRenderingLineAfter && anchor.range.startColumn >= stopRenderingLineAfter) {
      stopRenderingMessage = true;
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
      }], false, index++));
    }
    if (!stopRenderingMessage && typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], false, index++));
    }
    let isBeforeContent = false;
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const hoverMessage = d.options.hoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      if (d.options.beforeContentClassName) {
        isBeforeContent = true;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkdownHover(this, range, asArray(hoverMessage), isBeforeContent, index++));
    }
    return result;
  }
  computeAsync(anchor, lineDecorations, token) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return AsyncIterableObject.EMPTY;
    }
    const model = this._editor.getModel();
    if (!this._languageFeaturesService.hoverProvider.has(model)) {
      return AsyncIterableObject.EMPTY;
    }
    const position = new Position(anchor.range.startLineNumber, anchor.range.startColumn);
    return getHover(this._languageFeaturesService.hoverProvider, model, position, token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => {
      const rng = item.hover.range ? Range.lift(item.hover.range) : anchor.range;
      return new MarkdownHover(this, rng, item.hover.contents, false, item.ordinal);
    });
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
}, "MarkdownHoverParticipant");
MarkdownHoverParticipant = __decorate23([
  __param23(1, ILanguageService),
  __param23(2, IOpenerService),
  __param23(3, IConfigurationService),
  __param23(4, ILanguageFeaturesService)
], MarkdownHoverParticipant);
function renderMarkdownHovers(context, hoverParts, editor2, languageService, openerService) {
  hoverParts.sort((a, b) => a.ordinal - b.ordinal);
  const disposables = new DisposableStore();
  for (const hoverPart of hoverParts) {
    for (const contents of hoverPart.contents) {
      if (isEmptyMarkdownString(contents)) {
        continue;
      }
      const markdownHoverElement = $6("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $6("div.hover-contents"));
      const renderer = disposables.add(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
      disposables.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const renderedContents = disposables.add(renderer.render(contents));
      hoverContentsElement.appendChild(renderedContents.element);
      context.fragment.appendChild(markdownHoverElement);
    }
  }
  return disposables;
}
__name(renderMarkdownHovers, "renderMarkdownHovers");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
init_define_process();
init_dom();
init_arrays();
init_async();
init_errors();
init_lifecycle();
init_resources();
init_range();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_define_process();
init_codicons();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/markerNavigationService.js
init_define_process();
init_arrays();
init_event();
init_lifecycle();
init_linkedList();
init_strings();
init_uri();
init_range();
init_extensions();
init_instantiation();
init_configuration();
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerCoordinate = class {
  constructor(marker, index, total) {
    this.marker = marker;
    this.index = index;
    this.total = total;
  }
};
__name(MarkerCoordinate, "MarkerCoordinate");
var MarkerList = /* @__PURE__ */ __name(class MarkerList2 {
  constructor(resourceFilter, _markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const compareOrder = this._configService.getValue("problems.sortOrder");
    const compareMarker = /* @__PURE__ */ __name((a, b) => {
      let res = compare(a.resource.toString(), b.resource.toString());
      if (res === 0) {
        if (compareOrder === "position") {
          res = Range.compareRangesUsingStarts(a, b) || MarkerSeverity.compare(a.severity, b.severity);
        } else {
          res = MarkerSeverity.compare(a.severity, b.severity) || Range.compareRangesUsingStarts(a, b);
        }
      }
      return res;
    }, "compareMarker");
    const updateMarker = /* @__PURE__ */ __name(() => {
      this._markers = this._markerService.read({
        resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
      }
      this._markers.sort(compareMarker);
    }, "updateMarker");
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        updateMarker();
        this._nextIdx = -1;
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let found = false;
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
    if (idx < 0) {
      idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
    }
    for (let i = idx; i < this._markers.length; i++) {
      let range = Range.lift(this._markers[i]);
      if (range.isEmpty()) {
        const word = model.getWordAtPosition(range.getStartPosition());
        if (word) {
          range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
        }
      }
      if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
        this._nextIdx = i;
        found = true;
        break;
      }
      if (this._markers[i].resource.toString() !== model.uri.toString()) {
        break;
      }
    }
    if (!found) {
      this._nextIdx = fwd ? 0 : this._markers.length - 1;
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    const oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
}, "MarkerList");
MarkerList = __decorate24([
  __param24(1, IMarkerService),
  __param24(2, IConfigurationService)
], MarkerList);
var IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = /* @__PURE__ */ __name(class MarkerNavigationService2 {
  constructor(_markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._provider = new LinkedList();
  }
  getMarkerList(resource) {
    for (const provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService, this._configService);
  }
}, "MarkerNavigationService");
MarkerNavigationService = __decorate24([
  __param24(0, IMarkerService),
  __param24(1, IConfigurationService)
], MarkerNavigationService);
registerSingleton(IMarkerNavigationService, MarkerNavigationService, 1);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
init_nls();
init_actions2();
init_contextkey();
init_instantiation();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_define_process();
init_dom();
init_arrays();
init_color();
init_event();
init_lifecycle();
init_resources();
init_strings();
init_range();
init_nls();
init_actions2();
init_contextkey();
init_instantiation();
init_opener();

// ../../node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js
init_define_process();
init_codicons();
init_colorRegistry();
init_themeService();
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case severity_default.Ignore:
        return "severity-ignore " + Codicon.info.classNames;
      case severity_default.Info:
        return Codicon.info.classNames;
      case severity_default.Warning:
        return Codicon.warning.classNames;
      case severity_default.Error:
        return Codicon.error.classNames;
      default:
        return "";
    }
  }
  __name(className, "className");
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));
registerThemingParticipant((theme, collector) => {
  const errorIconForeground = theme.getColor(problemsErrorIconForeground);
  if (errorIconForeground) {
    const errorCodiconSelector = Codicon.error.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${errorCodiconSelector},
			.markers-panel .marker-icon${errorCodiconSelector},
			.text-search-provider-messages .providerMessage ${errorCodiconSelector},
			.extensions-viewlet > .extensions ${errorCodiconSelector} {
				color: ${errorIconForeground};
			}
		`);
  }
  const warningIconForeground = theme.getColor(problemsWarningIconForeground);
  if (warningIconForeground) {
    const warningCodiconSelector = Codicon.warning.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${warningCodiconSelector},
			.markers-panel .marker-icon${warningCodiconSelector},
			.extensions-viewlet > .extensions ${warningCodiconSelector},
			.extension-editor ${warningCodiconSelector},
			.text-search-provider-messages .providerMessage ${warningCodiconSelector},
			.preferences-editor ${warningCodiconSelector} {
				color: ${warningIconForeground};
			}
		`);
  }
  const infoIconForeground = theme.getColor(problemsInfoIconForeground);
  if (infoIconForeground) {
    const infoCodiconSelector = Codicon.info.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${infoCodiconSelector},
			.markers-panel .marker-icon${infoCodiconSelector},
			.extensions-viewlet > .extensions ${infoCodiconSelector},
			.text-search-provider-messages .providerMessage ${infoCodiconSelector},
			.extension-editor ${infoCodiconSelector} {
				color: ${infoIconForeground};
			}
		`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoErrorWidget.js
init_colorRegistry();
init_themeService();
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageWidget2 = class {
  constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
    this._openerService = _openerService;
    this._labelService = _labelService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = /* @__PURE__ */ new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor2;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    this._messageBlock.classList.add("message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    });
    parent.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const { source, message, relatedInformation, code } = marker;
    let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
    if (code) {
      if (typeof code === "string") {
        sourceAndCodeLength += code.length;
      } else {
        sourceAndCodeLength += code.value.length;
      }
    }
    const lines = splitLines(message);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code) {
      const detailsElement = document.createElement("span");
      detailsElement.classList.add("details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        sourceElement.classList.add("source");
        detailsElement.appendChild(sourceElement);
      }
      if (code) {
        if (typeof code === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code})`;
          codeElement.classList.add("code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $("a.code-link");
          this._codeLink.setAttribute("href", `${code.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code.target, { allowCommands: true });
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $("span"));
          codeElement.innerText = code.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(61) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        const container = document.createElement("div");
        const relatedResource = document.createElement("a");
        relatedResource.classList.add("filename");
        relatedResource.innerText = `${this._labelService.getUriBasenameLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = this._labelService.getUriLabel(related.resource);
        this._relatedDiagnostics.set(relatedResource, related);
        const relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(45);
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({ width, height });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize("Error", "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize("Warning", "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize("Info", "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize("Hint", "Hint");
        break;
    }
    let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
};
__name(MessageWidget2, "MessageWidget");
var MarkerNavigationWidget = /* @__PURE__ */ __name(class MarkerNavigationWidget2 extends PeekViewWidget {
  constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
    super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._labelService = _labelService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme) {
    this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    let headerBackground = editorMarkerNavigationErrorHeader;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
      headerBackground = editorMarkerNavigationWarningHeader;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
      headerBackground = editorMarkerNavigationInfoHeader;
    }
    const frameColor = theme.getColor(colorId);
    const headerBg = theme.getColor(headerBackground);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: headerBg,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((e) => this.editor.focus()));
    const actions = [];
    const menu = this._menuService.createMenu(MarkerNavigationWidget2.TitleMenu, this._contextKeyService);
    createAndFillInActionBarActions(menu, void 0, actions);
    this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
    menu.dispose();
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $(""));
  }
  _fillBody(container) {
    this._parentContainer = container;
    container.classList.add("marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget2(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    const range = Range.lift(marker);
    const editorPosition = this.editor.getPosition();
    const position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename2(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(position, 0);
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
}, "MarkerNavigationWidget");
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = __decorate25([
  __param25(1, IThemeService),
  __param25(2, IOpenerService),
  __param25(3, IMenuService),
  __param25(4, IInstantiationService),
  __param25(5, IContextKeyService),
  __param25(6, ILabelService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
var editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
var editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
var editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hcDark: "#0C141F", hcLight: transparent(editorMarkerNavigationWarning, 0.2) }, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
var editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hcDark: contrastBorder, hcLight: contrastBorder }, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
var editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hcDark: null, hcLight: null }, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
var editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", { dark: editorBackground, light: editorBackground, hcDark: editorBackground, hcLight: editorBackground }, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/browser/gotoError.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MarkerController = /* @__PURE__ */ __name(class MarkerController2 {
  static get(editor2) {
    return editor2.getContribution(MarkerController2.ID);
  }
  constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor2;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      var _a6, _b2, _c2;
      if (!((_a6 = this._model) === null || _a6 === void 0 ? void 0 : _a6.selected) || !Range.containsPosition((_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.selected.marker, e.position)) {
        (_c2 = this._model) === null || _c2 === void 0 ? void 0 : _c2.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (this._editor.hasModel()) {
      const model = this._getOrCreateModel(this._editor.getModel().uri);
      model.resetIndex();
      model.move(true, this._editor.getModel(), new Position(marker.startLineNumber, marker.startColumn));
      if (model.selected) {
        this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
      }
    }
  }
  nagivate(next, multiFile) {
    var _a6, _b2;
    return __awaiter21(this, void 0, void 0, function* () {
      if (this._editor.hasModel()) {
        const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
        model.move(next, this._editor.getModel(), this._editor.getPosition());
        if (!model.selected) {
          return;
        }
        if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
          this._cleanUp();
          const otherEditor = yield this._editorService.openCodeEditor({
            resource: model.selected.marker.resource,
            options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
          }, this._editor);
          if (otherEditor) {
            (_a6 = MarkerController2.get(otherEditor)) === null || _a6 === void 0 ? void 0 : _a6.close();
            (_b2 = MarkerController2.get(otherEditor)) === null || _b2 === void 0 ? void 0 : _b2.nagivate(next, multiFile);
          }
        } else {
          this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
        }
      }
    });
  }
}, "MarkerController");
MarkerController.ID = "editor.contrib.markerController";
MarkerController = __decorate26([
  __param26(1, IMarkerNavigationService),
  __param26(2, IContextKeyService),
  __param26(3, ICodeEditorService),
  __param26(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  run(_accessor, editor2) {
    var _a6;
    return __awaiter21(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        (_a6 = MarkerController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.nagivate(this._next, this._multiFile);
      }
    });
  }
};
__name(MarkerNavigationAction, "MarkerNavigationAction");
var NextMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: NextMarkerAction.ID,
      label: NextMarkerAction.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
__name(NextMarkerAction, "NextMarkerAction");
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
var PrevMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: PrevMarkerAction.ID,
      label: PrevMarkerAction.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: PrevMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
__name(PrevMarkerAction, "PrevMarkerAction");
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
};
__name(NextMarkerInFilesAction, "NextMarkerInFilesAction");
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
};
__name(PrevMarkerInFilesAction, "PrevMarkerInFilesAction");
registerEditorContribution(MarkerController.ID, MarkerController, 4);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/markerHoverParticipant.js
init_nls();
init_opener();
init_progress();
init_languageFeatures();
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $7 = $;
var MarkerHover = class {
  constructor(owner, range, marker) {
    this.owner = owner;
    this.range = range;
    this.marker = marker;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
__name(MarkerHover, "MarkerHover");
var markerCodeActionTrigger = {
  type: 1,
  filter: { include: CodeActionKind.QuickFix },
  triggerAction: CodeActionTriggerSource.QuickFixHover
};
var MarkerHoverParticipant = /* @__PURE__ */ __name(class MarkerHoverParticipant2 {
  constructor(_editor, _markerDecorationsService, _openerService, _languageFeaturesService) {
    this._editor = _editor;
    this._markerDecorationsService = _markerDecorationsService;
    this._openerService = _openerService;
    this._languageFeaturesService = _languageFeaturesService;
    this.hoverOrdinal = 5;
    this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const marker = this._markerDecorationsService.getMarker(model.uri, d);
      if (!marker) {
        continue;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkerHover(this, range, marker));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    if (!hoverParts.length) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    hoverParts.forEach((msg) => context.fragment.appendChild(this.renderMarkerHover(msg, disposables)));
    const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
    this.renderMarkerStatusbar(context, markerHoverForStatusbar, disposables);
    return disposables;
  }
  renderMarkerHover(markerHover, disposables) {
    const hoverElement = $7("div.hover-row");
    const markerElement = append(hoverElement, $7("div.marker.hover-contents"));
    const { source, message, code, relatedInformation } = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $7("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code) {
      if (code && typeof code !== "string") {
        const sourceAndCodeElement = $7("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $7("span"));
          sourceElement.innerText = source;
        }
        const codeLink = append(sourceAndCodeElement, $7("a.code-link"));
        codeLink.setAttribute("href", code.target.toString());
        disposables.add(addDisposableListener(codeLink, "click", (e) => {
          this._openerService.open(code.target, { allowCommands: true });
          e.preventDefault();
          e.stopPropagation();
        }));
        const codeElement = append(codeLink, $7("span"));
        codeElement.innerText = code.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $7("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $7("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $7("a"));
        a.innerText = `${basename2(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        disposables.add(addDisposableListener(a, "click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            this._openerService.open(resource, {
              fromUserGesture: true,
              editorOptions: { selection: { startLineNumber, startColumn } }
            }).catch(onUnexpectedError);
          }
        }));
        const messageElement2 = append(relatedInfoContainer, $7("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    return hoverElement;
  }
  renderMarkerStatusbar(context, markerHover, disposables) {
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      context.statusBar.addAction({
        label: localize("view problem", "View Problem"),
        commandId: NextMarkerAction.ID,
        run: () => {
          var _a6;
          context.hide();
          (_a6 = MarkerController.get(this._editor)) === null || _a6 === void 0 ? void 0 : _a6.showAtMarker(markerHover.marker);
          this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(84)) {
      const quickfixPlaceholderElement = context.statusBar.append($7("div"));
      if (this.recentMarkerCodeActionsInfo) {
        if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
          if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
            quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          }
        } else {
          this.recentMarkerCodeActionsInfo = void 0;
        }
      }
      const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
      if (!quickfixPlaceholderElement.textContent) {
        quickfixPlaceholderElement.textContent = String.fromCharCode(160);
      }
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions) => {
        updatePlaceholderDisposable.dispose();
        this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
        if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
          actions.dispose();
          quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.style.display = "none";
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions.dispose();
          }
        }));
        context.statusBar.addAction({
          label: localize("quick fixes", "Quick Fix..."),
          commandId: QuickFixAction.Id,
          run: (target) => {
            showing = true;
            const controller = CodeActionController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            context.hide();
            controller === null || controller === void 0 ? void 0 : controller.showCodeActions(markerCodeActionTrigger, actions, {
              x: elementPosition.left + 6,
              y: elementPosition.top + elementPosition.height + 6,
              width: elementPosition.width,
              height: elementPosition.height
            });
          }
        });
      }, onUnexpectedError);
    }
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
}, "MarkerHoverParticipant");
MarkerHoverParticipant = __decorate27([
  __param27(1, IMarkerDecorationsService),
  __param27(2, IOpenerService),
  __param27(3, ILanguageFeaturesService)
], MarkerHoverParticipant);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/hover/browser/hover.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModesHoverController = /* @__PURE__ */ __name(class ModesHoverController2 {
  static get(editor2) {
    return editor2.getContribution(ModesHoverController2.ID);
  }
  constructor(_editor, _instantiationService, _openerService, _languageService, _contextKeyService) {
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._openerService = _openerService;
    this._languageService = _languageService;
    this._toUnhook = new DisposableStore();
    this._isMouseDown = false;
    this._hoverClicked = false;
    this._contentWidget = null;
    this._glyphWidget = null;
    this._hookEvents();
    this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(55)) {
        this._unhookEvents();
        this._hookEvents();
      }
    });
  }
  _hookEvents() {
    const hideWidgetsEventHandler = /* @__PURE__ */ __name(() => this._hideWidgets(), "hideWidgetsEventHandler");
    const hoverOpts = this._editor.getOption(55);
    this._isHoverEnabled = hoverOpts.enabled;
    this._isHoverSticky = hoverOpts.sticky;
    if (this._isHoverEnabled) {
      this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    } else {
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._toUnhook.add(this._editor.onMouseLeave((e) => this._onEditorMouseLeave(e)));
    this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookEvents() {
    this._toUnhook.clear();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this._hideWidgets();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._isMouseDown = true;
    const target = mouseEvent.target;
    if (target.type === 9 && target.detail === ContentHoverWidget.ID) {
      this._hoverClicked = true;
      return;
    }
    if (target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (target.type !== 12) {
      this._hoverClicked = false;
    }
    this._hideWidgets();
  }
  _onEditorMouseUp(mouseEvent) {
    this._isMouseDown = false;
  }
  _onEditorMouseLeave(mouseEvent) {
    var _a6;
    const targetEm = mouseEvent.event.browserEvent.relatedTarget;
    if ((_a6 = this._contentWidget) === null || _a6 === void 0 ? void 0 : _a6.containsNode(targetEm)) {
      return;
    }
    this._hideWidgets();
  }
  _onEditorMouseMove(mouseEvent) {
    var _a6, _b2, _c2, _d2, _e2;
    const target = mouseEvent.target;
    if (this._isMouseDown && this._hoverClicked) {
      return;
    }
    if (this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && !((_b2 = (_a6 = mouseEvent.event.browserEvent.view) === null || _a6 === void 0 ? void 0 : _a6.getSelection()) === null || _b2 === void 0 ? void 0 : _b2.isCollapsed)) {
      return;
    }
    if (!this._isHoverSticky && target.type === 9 && target.detail === ContentHoverWidget.ID && ((_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.isColorPickerVisible())) {
      return;
    }
    if (this._isHoverSticky && target.type === 12 && target.detail === MarginHoverWidget.ID) {
      return;
    }
    if (!this._isHoverEnabled) {
      this._hideWidgets();
      return;
    }
    const contentWidget = this._getOrCreateContentWidget();
    if (this._isHoverSticky && contentWidget.isVisibleFromKeyboard()) {
      return;
    }
    if (contentWidget.maybeShowAt(mouseEvent)) {
      (_d2 = this._glyphWidget) === null || _d2 === void 0 ? void 0 : _d2.hide();
      return;
    }
    if (target.type === 2 && target.position) {
      (_e2 = this._contentWidget) === null || _e2 === void 0 ? void 0 : _e2.hide();
      if (!this._glyphWidget) {
        this._glyphWidget = new MarginHoverWidget(this._editor, this._languageService, this._openerService);
      }
      this._glyphWidget.startShowingAt(target.position.lineNumber);
      return;
    }
    this._hideWidgets();
  }
  _onKeyDown(e) {
    if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4) {
      this._hideWidgets();
    }
  }
  _hideWidgets() {
    var _a6, _b2, _c2;
    if (this._isMouseDown && this._hoverClicked && ((_a6 = this._contentWidget) === null || _a6 === void 0 ? void 0 : _a6.isColorPickerVisible())) {
      return;
    }
    this._hoverClicked = false;
    (_b2 = this._glyphWidget) === null || _b2 === void 0 ? void 0 : _b2.hide();
    (_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.hide();
  }
  _getOrCreateContentWidget() {
    if (!this._contentWidget) {
      this._contentWidget = this._instantiationService.createInstance(ContentHoverController, this._editor);
    }
    return this._contentWidget;
  }
  isColorPickerVisible() {
    var _a6;
    return ((_a6 = this._contentWidget) === null || _a6 === void 0 ? void 0 : _a6.isColorPickerVisible()) || false;
  }
  showContentHover(range, mode, source, focus) {
    this._getOrCreateContentWidget().startShowingAtRange(range, mode, source, focus);
  }
  dispose() {
    var _a6, _b2;
    this._unhookEvents();
    this._toUnhook.dispose();
    this._didChangeConfigurationHandler.dispose();
    (_a6 = this._glyphWidget) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    (_b2 = this._contentWidget) === null || _b2 === void 0 ? void 0 : _b2.dispose();
  }
}, "ModesHoverController");
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = __decorate28([
  __param28(1, IInstantiationService),
  __param28(2, IOpenerService),
  __param28(3, ILanguageService),
  __param28(4, IContextKeyService)
], ModesHoverController);
var ShowHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: localize({
        key: "showHover",
        comment: [
          "Label for action that will trigger the showing of a hover in the editor.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show Hover"),
      alias: "Show Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 39),
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const focus = editor2.getOption(2) === 2;
    controller.showContentHover(range, 1, 1, focus);
  }
};
__name(ShowHoverAction, "ShowHoverAction");
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: localize({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    if (!position) {
      return;
    }
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
    if (!goto) {
      return;
    }
    const promise = goto.startFindDefinitionFromCursor(position);
    promise.then(() => {
      controller.showContentHover(range, 1, 1, true);
    });
  }
};
__name(ShowDefinitionPreviewHoverAction, "ShowDefinitionPreviewHoverAction");
registerEditorContribution(ModesHoverController.ID, ModesHoverController, 2);
registerEditorAction(ShowHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
HoverParticipantRegistry.register(MarkdownHoverParticipant);
HoverParticipantRegistry.register(MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/browser/colorContributions.js
var ColorContribution = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(mouseEvent) {
    const target = mouseEvent.target;
    if (target.type !== 6) {
      return;
    }
    if (!target.detail.injectedText) {
      return;
    }
    if (target.detail.injectedText.options.attachedData !== ColorDecorationInjectedTextMarker) {
      return;
    }
    if (!target.range) {
      return;
    }
    const hoverController = this._editor.getContribution(ModesHoverController.ID);
    if (!hoverController) {
      return;
    }
    if (!hoverController.isColorPickerVisible()) {
      const range = new Range(target.range.startLineNumber, target.range.startColumn + 1, target.range.endLineNumber, target.range.endColumn + 1);
      hoverController.showContentHover(range, 1, 0, false);
    }
  }
};
__name(ColorContribution, "ColorContribution");
ColorContribution.ID = "editor.contrib.colorContribution";
registerEditorContribution(ColorContribution.ID, ColorContribution, 2);
HoverParticipantRegistry.register(ColorHoverParticipant);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteContribution.js
init_define_process();
init_editorExtensions();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteController.js
init_define_process();
init_dom();
init_async();

// ../../node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js
init_define_process();
init_arrays();

// ../../node_modules/monaco-editor/esm/vs/base/common/uuid.js
init_define_process();
var generateUuid = function() {
  if (typeof crypto === "object" && typeof crypto.randomUUID === "function") {
    return crypto.randomUUID.bind(crypto);
  }
  let getRandomValues;
  if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") {
    getRandomValues = crypto.getRandomValues.bind(crypto);
  } else {
    getRandomValues = /* @__PURE__ */ __name(function(bucket) {
      for (let i = 0; i < bucket.length; i++) {
        bucket[i] = Math.floor(Math.random() * 256);
      }
      return bucket;
    }, "getRandomValues");
  }
  const _data = new Uint8Array(16);
  const _hex = [];
  for (let i = 0; i < 256; i++) {
    _hex.push(i.toString(16).padStart(2, "0"));
  }
  return /* @__PURE__ */ __name(function generateUuid2() {
    getRandomValues(_data);
    _data[6] = _data[6] & 15 | 64;
    _data[8] = _data[8] & 63 | 128;
    let i = 0;
    let result = "";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += "-";
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    result += _hex[_data[i++]];
    return result;
  }, "generateUuid");
}();

// ../../node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createStringDataTransferItem(stringOrPromise) {
  return {
    id: generateUuid(),
    asString: () => __awaiter22(this, void 0, void 0, function* () {
      return stringOrPromise;
    }),
    asFile: () => void 0,
    value: typeof stringOrPromise === "string" ? stringOrPromise : void 0
  };
}
__name(createStringDataTransferItem, "createStringDataTransferItem");
function createFileDataTransferItem(fileName, uri, data) {
  return {
    id: generateUuid(),
    asString: () => __awaiter22(this, void 0, void 0, function* () {
      return "";
    }),
    asFile: () => ({ name: fileName, uri, data }),
    value: void 0
  };
}
__name(createFileDataTransferItem, "createFileDataTransferItem");
var VSDataTransfer = class {
  constructor() {
    this._entries = /* @__PURE__ */ new Map();
  }
  get size() {
    return this._entries.size;
  }
  has(mimeType) {
    return this._entries.has(this.toKey(mimeType));
  }
  get(mimeType) {
    var _a6;
    return (_a6 = this._entries.get(this.toKey(mimeType))) === null || _a6 === void 0 ? void 0 : _a6[0];
  }
  append(mimeType, value) {
    const existing = this._entries.get(mimeType);
    if (existing) {
      existing.push(value);
    } else {
      this._entries.set(this.toKey(mimeType), [value]);
    }
  }
  replace(mimeType, value) {
    this._entries.set(this.toKey(mimeType), [value]);
  }
  delete(mimeType) {
    this._entries.delete(this.toKey(mimeType));
  }
  *entries() {
    for (const [mine, items] of this._entries.entries()) {
      for (const item of items) {
        yield [mine, item];
      }
    }
  }
  values() {
    return Array.from(this._entries.values()).flat();
  }
  forEach(f) {
    for (const [mime, item] of this.entries()) {
      f(item, mime);
    }
  }
  toKey(mimeType) {
    return mimeType.toLowerCase();
  }
};
__name(VSDataTransfer, "VSDataTransfer");
var UriList = Object.freeze({
  create: (entries) => {
    return distinct(entries.map((x) => x.toString())).join("\r\n");
  },
  split: (str) => {
    return str.split("\r\n");
  },
  parse: (str) => {
    return UriList.split(str).filter((value) => !value.startsWith("#"));
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteController.js
init_lifecycle();
init_mime();
init_network();

// ../../node_modules/monaco-editor/esm/vs/editor/browser/dnd.js
init_define_process();
init_mime();
init_uri();

// ../../node_modules/monaco-editor/esm/vs/platform/dnd/browser/dnd.js
init_define_process();
init_map();
init_uri();
init_opener();
init_platform2();
var CodeDataTransfers = {
  EDITORS: "CodeEditors",
  FILES: "CodeFiles"
};
function extractEditorsDropData(e) {
  var _a6;
  const editors = [];
  if (e.dataTransfer && e.dataTransfer.types.length > 0) {
    const rawEditorsData = e.dataTransfer.getData(CodeDataTransfers.EDITORS);
    if (rawEditorsData) {
      try {
        editors.push(...parse(rawEditorsData));
      } catch (error) {
      }
    } else {
      try {
        const rawResourcesData = e.dataTransfer.getData(DataTransfers.RESOURCES);
        editors.push(...createDraggedEditorInputFromRawResourcesData(rawResourcesData));
      } catch (error) {
      }
    }
    if ((_a6 = e.dataTransfer) === null || _a6 === void 0 ? void 0 : _a6.files) {
      for (let i = 0; i < e.dataTransfer.files.length; i++) {
        const file = e.dataTransfer.files[i];
        if (file && file.path) {
          try {
            editors.push({ resource: URI.file(file.path), isExternal: true, allowWorkspaceOpen: true });
          } catch (error) {
          }
        }
      }
    }
    const rawCodeFiles = e.dataTransfer.getData(CodeDataTransfers.FILES);
    if (rawCodeFiles) {
      try {
        const codeFiles = JSON.parse(rawCodeFiles);
        for (const codeFile of codeFiles) {
          editors.push({ resource: URI.file(codeFile), isExternal: true, allowWorkspaceOpen: true });
        }
      } catch (error) {
      }
    }
    const contributions = Registry.as(Extensions2.DragAndDropContribution).getAll();
    for (const contribution of contributions) {
      const data = e.dataTransfer.getData(contribution.dataFormatKey);
      if (data) {
        try {
          editors.push(...contribution.getEditorInputs(data));
        } catch (error) {
        }
      }
    }
  }
  const coalescedEditors = [];
  const seen = new ResourceMap();
  for (const editor2 of editors) {
    if (!editor2.resource) {
      coalescedEditors.push(editor2);
    } else if (!seen.has(editor2.resource)) {
      coalescedEditors.push(editor2);
      seen.set(editor2.resource, true);
    }
  }
  return coalescedEditors;
}
__name(extractEditorsDropData, "extractEditorsDropData");
function createDraggedEditorInputFromRawResourcesData(rawResourcesData) {
  const editors = [];
  if (rawResourcesData) {
    const resourcesRaw = JSON.parse(rawResourcesData);
    for (const resourceRaw of resourcesRaw) {
      if (resourceRaw.indexOf(":") > 0) {
        const { selection, uri } = extractSelection(URI.parse(resourceRaw));
        editors.push({ resource: uri, options: { selection } });
      }
    }
  }
  return editors;
}
__name(createDraggedEditorInputFromRawResourcesData, "createDraggedEditorInputFromRawResourcesData");
var DragAndDropContributionRegistry = class {
  constructor() {
    this._contributions = /* @__PURE__ */ new Map();
  }
  getAll() {
    return this._contributions.values();
  }
};
__name(DragAndDropContributionRegistry, "DragAndDropContributionRegistry");
var Extensions2 = {
  DragAndDropContribution: "workbench.contributions.dragAndDrop"
};
Registry.add(Extensions2.DragAndDropContribution, new DragAndDropContributionRegistry());

// ../../node_modules/monaco-editor/esm/vs/editor/browser/dnd.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function toVSDataTransfer(dataTransfer) {
  const vsDataTransfer = new VSDataTransfer();
  for (const item of dataTransfer.items) {
    const type = item.type;
    if (item.kind === "string") {
      const asStringValue = new Promise((resolve) => item.getAsString(resolve));
      vsDataTransfer.append(type, createStringDataTransferItem(asStringValue));
    } else if (item.kind === "file") {
      const file = item.getAsFile();
      if (file) {
        vsDataTransfer.append(type, createFileDataTransferItemFromFile(file));
      }
    }
  }
  return vsDataTransfer;
}
__name(toVSDataTransfer, "toVSDataTransfer");
function createFileDataTransferItemFromFile(file) {
  const uri = file.path ? URI.parse(file.path) : void 0;
  return createFileDataTransferItem(file.name, uri, () => __awaiter23(this, void 0, void 0, function* () {
    return new Uint8Array(yield file.arrayBuffer());
  }));
}
__name(createFileDataTransferItemFromFile, "createFileDataTransferItemFromFile");
var INTERNAL_DND_MIME_TYPES = Object.freeze([
  CodeDataTransfers.EDITORS,
  CodeDataTransfers.FILES,
  DataTransfers.RESOURCES
]);
function addExternalEditorsDropData(dataTransfer, dragEvent, overwriteUriList = false) {
  var _a6;
  if (dragEvent.dataTransfer && (overwriteUriList || !dataTransfer.has(Mimes.uriList))) {
    const editorData = extractEditorsDropData(dragEvent).filter((input) => input.resource).map((input) => input.resource.toString());
    for (const item of (_a6 = dragEvent.dataTransfer) === null || _a6 === void 0 ? void 0 : _a6.items) {
      const file = item.getAsFile();
      if (file) {
        editorData.push(file.path ? URI.file(file.path).toString() : file.name);
      }
    }
    if (editorData.length) {
      dataTransfer.replace(Mimes.uriList, createStringDataTransferItem(UriList.create(editorData)));
    }
  }
  for (const internal of INTERNAL_DND_MIME_TYPES) {
    dataTransfer.delete(internal);
  }
}
__name(addExternalEditorsDropData, "addExternalEditorsDropData");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteController.js
init_range();
init_selection();
init_languageFeatures();
init_editorState();
init_nls();
init_configuration();
init_progress();
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var vscodeClipboardMime = "application/vnd.code.copyMetadata";
var CopyPasteController = /* @__PURE__ */ __name(class CopyPasteController2 extends Disposable {
  constructor(editor2, _bulkEditService, _clipboardService, _configurationService, _languageFeaturesService, _progressService) {
    super();
    this._bulkEditService = _bulkEditService;
    this._clipboardService = _clipboardService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._progressService = _progressService;
    this._editor = editor2;
    const container = editor2.getContainerDomNode();
    this._register(addDisposableListener(container, "copy", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "cut", (e) => this.handleCopy(e)));
    this._register(addDisposableListener(container, "paste", (e) => this.handlePaste(e), true));
  }
  arePasteActionsEnabled(model) {
    if (this._configurationService.getValue("editor.experimental.pasteActions.enabled", { resource: model.uri })) {
      return true;
    }
    return model.uri.scheme === Schemas.vscodeNotebookCell;
  }
  handleCopy(e) {
    var _a6;
    if (!e.clipboardData || !this._editor.hasTextFocus()) {
      return;
    }
    const model = this._editor.getModel();
    const selections = this._editor.getSelections();
    if (!model || !(selections === null || selections === void 0 ? void 0 : selections.length)) {
      return;
    }
    if (!this.arePasteActionsEnabled(model)) {
      return;
    }
    const ranges = [...selections];
    const primarySelection = selections[0];
    const wasFromEmptySelection = primarySelection.isEmpty();
    if (wasFromEmptySelection) {
      if (!this._editor.getOption(33)) {
        return;
      }
      ranges[0] = new Range(primarySelection.startLineNumber, 0, primarySelection.startLineNumber, model.getLineLength(primarySelection.startLineNumber));
    }
    const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model).filter((x) => !!x.prepareDocumentPaste);
    if (!providers.length) {
      this.setCopyMetadata(e.clipboardData, { wasFromEmptySelection });
      return;
    }
    const dataTransfer = toVSDataTransfer(e.clipboardData);
    const handle = generateUuid();
    this.setCopyMetadata(e.clipboardData, {
      id: handle,
      wasFromEmptySelection
    });
    const promise = createCancelablePromise((token) => __awaiter24(this, void 0, void 0, function* () {
      const results = yield Promise.all(providers.map((provider) => {
        return provider.prepareDocumentPaste(model, ranges, dataTransfer, token);
      }));
      for (const result of results) {
        result === null || result === void 0 ? void 0 : result.forEach((value, key) => {
          dataTransfer.replace(key, value);
        });
      }
      return dataTransfer;
    }));
    (_a6 = this._currentClipboardItem) === null || _a6 === void 0 ? void 0 : _a6.dataTransferPromise.cancel();
    this._currentClipboardItem = { handle, dataTransferPromise: promise };
  }
  setCopyMetadata(dataTransfer, metadata) {
    dataTransfer.setData(vscodeClipboardMime, JSON.stringify(metadata));
  }
  handlePaste(e) {
    var _a6, _b2, _c2, _d2;
    return __awaiter24(this, void 0, void 0, function* () {
      if (!e.clipboardData || !this._editor.hasTextFocus()) {
        return;
      }
      const selections = this._editor.getSelections();
      if (!(selections === null || selections === void 0 ? void 0 : selections.length) || !this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!this.arePasteActionsEnabled(model)) {
        return;
      }
      let metadata;
      const rawMetadata = (_a6 = e.clipboardData) === null || _a6 === void 0 ? void 0 : _a6.getData(vscodeClipboardMime);
      if (rawMetadata && typeof rawMetadata === "string") {
        metadata = JSON.parse(rawMetadata);
      }
      const providers = this._languageFeaturesService.documentPasteEditProvider.ordered(model);
      if (!providers.length) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
      const tokenSource = new EditorStateCancellationTokenSource(this._editor, 1 | 2);
      try {
        const dataTransfer = toVSDataTransfer(e.clipboardData);
        if ((metadata === null || metadata === void 0 ? void 0 : metadata.id) && ((_b2 = this._currentClipboardItem) === null || _b2 === void 0 ? void 0 : _b2.handle) === metadata.id) {
          const toMergeDataTransfer = yield this._currentClipboardItem.dataTransferPromise;
          if (tokenSource.token.isCancellationRequested) {
            return;
          }
          toMergeDataTransfer.forEach((value, key) => {
            dataTransfer.replace(key, value);
          });
        }
        if (!dataTransfer.has(Mimes.uriList)) {
          const resources = yield this._clipboardService.readResources();
          if (tokenSource.token.isCancellationRequested) {
            return;
          }
          if (resources.length) {
            dataTransfer.append(Mimes.uriList, createStringDataTransferItem(UriList.create(resources)));
          }
        }
        dataTransfer.delete(vscodeClipboardMime);
        const providerEdit = yield this._progressService.withProgress({
          location: 15,
          delay: 750,
          title: localize("pasteProgressTitle", "Running paste handlers..."),
          cancellable: true
        }, () => {
          return this.getProviderPasteEdit(providers, dataTransfer, model, selections, tokenSource.token);
        }, () => {
          return tokenSource.cancel();
        });
        if (tokenSource.token.isCancellationRequested) {
          return;
        }
        if (providerEdit) {
          const snippet = typeof providerEdit.insertText === "string" ? SnippetParser.escape(providerEdit.insertText) : providerEdit.insertText.snippet;
          const combinedWorkspaceEdit = {
            edits: [
              new ResourceTextEdit(model.uri, {
                range: Selection.liftSelection(this._editor.getSelection()),
                text: snippet,
                insertAsSnippet: true
              }),
              ...(_d2 = (_c2 = providerEdit.additionalEdit) === null || _c2 === void 0 ? void 0 : _c2.edits) !== null && _d2 !== void 0 ? _d2 : []
            ]
          };
          yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: this._editor });
          return;
        }
        yield this.applyDefaultPasteHandler(dataTransfer, metadata, tokenSource.token);
      } finally {
        tokenSource.dispose();
      }
    });
  }
  getProviderPasteEdit(providers, dataTransfer, model, selections, token) {
    return raceCancellation((() => __awaiter24(this, void 0, void 0, function* () {
      for (const provider of providers) {
        if (token.isCancellationRequested) {
          return;
        }
        if (!isSupportedProvider(provider, dataTransfer)) {
          continue;
        }
        const edit = yield provider.provideDocumentPasteEdits(model, selections, dataTransfer, token);
        if (edit) {
          return edit;
        }
      }
      return void 0;
    }))(), token);
  }
  applyDefaultPasteHandler(dataTransfer, metadata, token) {
    var _a6;
    return __awaiter24(this, void 0, void 0, function* () {
      const textDataTransfer = (_a6 = dataTransfer.get(Mimes.text)) !== null && _a6 !== void 0 ? _a6 : dataTransfer.get("text");
      if (!textDataTransfer) {
        return;
      }
      const text = yield textDataTransfer.asString();
      if (token.isCancellationRequested) {
        return;
      }
      this._editor.trigger("keyboard", "paste", {
        text,
        pasteOnNewLine: metadata === null || metadata === void 0 ? void 0 : metadata.wasFromEmptySelection,
        multicursorText: null
      });
    });
  }
}, "CopyPasteController");
CopyPasteController.ID = "editor.contrib.copyPasteActionController";
CopyPasteController = __decorate29([
  __param29(1, IBulkEditService),
  __param29(2, IClipboardService),
  __param29(3, IConfigurationService),
  __param29(4, ILanguageFeaturesService),
  __param29(5, IProgressService)
], CopyPasteController);
function isSupportedProvider(provider, dataTransfer) {
  return provider.pasteMimeTypes.some((type) => {
    if (type.toLowerCase() === DataTransfers.FILES.toLowerCase()) {
      return [...dataTransfer.values()].some((item) => item.asFile());
    }
    return dataTransfer.has(type);
  });
}
__name(isSupportedProvider, "isSupportedProvider");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/copyPaste/browser/copyPasteContribution.js
init_nls();
init_configurationRegistry();
init_platform2();
registerEditorContribution(CopyPasteController.ID, CopyPasteController, 0);
Registry.as(Extensions.Configuration).registerConfiguration(Object.assign(Object.assign({}, editorConfigurationBaseNode), { properties: {
  "editor.experimental.pasteActions.enabled": {
    type: "boolean",
    scope: 5,
    description: localize("pasteActions", "Enable/disable running edits from extensions on paste."),
    default: false
  }
} }));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_define_process();
init_keyCodes();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languageConfigurationRegistry();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/blockCommentCommand.js
init_define_process();
init_editOperation();
init_position();
init_range();
init_selection();
var BlockCommentCommand = class {
  constructor(selection, insertSpace, languageConfigurationService) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i = 0; i < needleLength; i++) {
      const codeA = haystack.charCodeAt(offset + i);
      const codeB = needle.charCodeAt(i);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    const res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
};
__name(BlockCommentCommand, "BlockCommentCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/lineCommentCommand.js
init_define_process();
init_strings();
init_editOperation();
init_position();
init_range();
init_selection();
var LineCommentCommand = class {
  constructor(languageConfigurationService, selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
    this.languageConfigurationService = languageConfigurationService;
    this._selection = selection;
    this._tabSize = tabSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
    this._ignoreFirstLine = ignoreFirstLine || false;
  }
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService) {
    model.tokenization.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = languageConfigurationService.getLanguageConfiguration(languageId).comments;
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    const lines = [];
    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
      lines[i] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    let onlyWhitespaceLines = true;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
      const lineData = lines[i];
      const lineNumber = startLineNumber + i;
      if (lineNumber === startLineNumber && ignoreFirstLine) {
        lineData.ignore = true;
        continue;
      }
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      lineData.ignore = false;
      lineData.commentStrOffset = lineContentStartOffset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1) {
        } else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
        lines[i].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService) {
    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber, languageConfigurationService);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine, languageConfigurationService);
  }
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
    for (let i = 0, len = ops.length; i < len; i++) {
      builder.addEditOperation(ops[i].range, ops[i].text);
      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    const startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  _executeBlockComment(model, builder, s) {
    model.tokenization.tokenizeIfCheap(s.startLineNumber);
    const languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    const config = this.languageConfigurationService.getLanguageConfiguration(languageId).comments;
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex2 === -1) {
          firstNonWhitespaceIndex2 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
      this._selectionId = builder.trackSelection(s);
      return;
    }
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  _createAddLineCommentsOperations(lines, startLineNumber) {
    const res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
    }
    return currentVisibleColumn + columnSize;
  }
  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i].commentStrOffset = j - 1;
      } else {
        lines[i].commentStrOffset = j;
      }
    }
  }
};
__name(LineCommentCommand, "LineCommentCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/comment/browser/comment.js
init_nls();
init_actions2();
var CommentLineAction = class extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const modelOptions = model.getOptions();
    const commentsOptions = editor2.getOption(19);
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignoreFirstLine: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignoreFirstLine = true;
        } else {
          prev.ignoreFirstLine = true;
          prev = curr;
        }
      }
    }
    for (const selection of selections) {
      commands.push(new LineCommentCommand(languageConfigurationService, selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(CommentLineAction, "CommentLineAction");
var ToggleCommentLineAction = class extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 85,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
};
__name(ToggleCommentLineAction, "ToggleCommentLineAction");
var AddLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 33),
        weight: 100
      }
    });
  }
};
__name(AddLineCommentAction, "AddLineCommentAction");
var RemoveLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 51),
        weight: 100
      }
    });
  }
};
__name(RemoveLineCommentAction, "RemoveLineCommentAction");
var BlockCommentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: { primary: 2048 | 1024 | 31 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const commentsOptions = editor2.getOption(19);
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(BlockCommentAction, "BlockCommentAction");
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/browser/contextmenu.js
init_define_process();
init_dom();
init_actions();
init_lifecycle();
init_platform();
init_editorExtensions();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_configuration();
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuController = /* @__PURE__ */ __name(class ContextMenuController2 {
  static get(editor2) {
    return editor2.getContribution(ContextMenuController2.ID);
  }
  constructor(editor2, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService, _configurationService) {
    this._contextMenuService = _contextMenuService;
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._menuService = _menuService;
    this._configurationService = _configurationService;
    this._toDispose = new DisposableStore();
    this._contextMenuIsBeingShownCount = 0;
    this._editor = editor2;
    this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
    this._toDispose.add(this._editor.onMouseWheel((e) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const view = this._contextViewService.getContextViewElement();
        const target = e.srcElement;
        if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) {
          this._contextViewService.hideContextView();
        }
      }
    }));
    this._toDispose.add(this._editor.onKeyDown((e) => {
      if (!this._editor.getOption(20)) {
        return;
      }
      if (e.keyCode === 58) {
        e.preventDefault();
        e.stopPropagation();
        this.showContextMenu();
      }
    }));
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._editor.getOption(20)) {
      this._editor.focus();
      if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
        this._editor.setPosition(e.target.position);
      }
      return;
    }
    if (e.target.type === 12) {
      return;
    }
    if (e.target.type === 6 && e.target.detail.injectedText) {
      return;
    }
    e.event.preventDefault();
    e.event.stopPropagation();
    if (e.target.type === 11) {
      return this._showScrollbarContextMenu({ x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2 });
    }
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) {
      return;
    }
    this._editor.focus();
    if (e.target.position) {
      let hasSelectionAtPosition = false;
      for (const selection of this._editor.getSelections()) {
        if (selection.containsPosition(e.target.position)) {
          hasSelectionAtPosition = true;
          break;
        }
      }
      if (!hasSelectionAtPosition) {
        this._editor.setPosition(e.target.position);
      }
    }
    let anchor = null;
    if (e.target.type !== 1) {
      anchor = { x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2 };
    }
    this.showContextMenu(anchor);
  }
  showContextMenu(anchor) {
    if (!this._editor.getOption(20)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const menuActions = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? MenuId.SimpleEditorContext : MenuId.EditorContext);
    if (menuActions.length > 0) {
      this._doShowContextMenu(menuActions, anchor);
    }
  }
  _getMenuActions(model, menuId) {
    const result = [];
    const menu = this._menuService.createMenu(menuId, this._contextKeyService);
    const groups = menu.getActions({ arg: model.uri });
    menu.dispose();
    for (const group of groups) {
      const [, actions] = group;
      let addedItems = 0;
      for (const action of actions) {
        if (action instanceof SubmenuItemAction) {
          const subActions = this._getMenuActions(model, action.item.submenu);
          if (subActions.length > 0) {
            result.push(new SubmenuAction(action.id, action.label, subActions));
            addedItems++;
          }
        } else {
          result.push(action);
          addedItems++;
        }
      }
      if (addedItems) {
        result.push(new Separator());
      }
    }
    if (result.length) {
      result.pop();
    }
    return result;
  }
  _doShowContextMenu(actions, anchor = null) {
    if (!this._editor.hasModel()) {
      return;
    }
    const oldHoverSetting = this._editor.getOption(55);
    this._editor.updateOptions({
      hover: {
        enabled: false
      }
    });
    if (!anchor) {
      this._editor.revealPosition(this._editor.getPosition(), 1);
      this._editor.render();
      const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
      const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
      const posx = editorCoords.left + cursorCoords.left;
      const posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
      anchor = { x: posx, y: posy };
    }
    const useShadowDOM = this._editor.getOption(119) && !isIOS;
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
      getAnchor: () => anchor,
      getActions: () => actions,
      getActionViewItem: (action) => {
        const keybinding = this._keybindingFor(action);
        if (keybinding) {
          return new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel(), isMenu: true });
        }
        const customActionViewItem = action;
        if (typeof customActionViewItem.getActionViewItem === "function") {
          return customActionViewItem.getActionViewItem();
        }
        return new ActionViewItem(action, action, { icon: true, label: true, isMenu: true });
      },
      getKeyBinding: (action) => {
        return this._keybindingFor(action);
      },
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
        this._editor.focus();
        this._editor.updateOptions({
          hover: oldHoverSetting
        });
      }
    });
  }
  _showScrollbarContextMenu(anchor) {
    if (!this._editor.hasModel()) {
      return;
    }
    const minimapOptions = this._editor.getOption(67);
    let lastId = 0;
    const createAction = /* @__PURE__ */ __name((opts) => {
      return {
        id: `menu-action-${++lastId}`,
        label: opts.label,
        tooltip: "",
        class: void 0,
        enabled: typeof opts.enabled === "undefined" ? true : opts.enabled,
        checked: opts.checked,
        run: opts.run
      };
    }, "createAction");
    const createSubmenuAction = /* @__PURE__ */ __name((label, actions2) => {
      return new SubmenuAction(`menu-action-${++lastId}`, label, actions2, void 0);
    }, "createSubmenuAction");
    const createEnumAction = /* @__PURE__ */ __name((label, enabled, configName, configuredValue, options) => {
      if (!enabled) {
        return createAction({ label, enabled, run: () => {
        } });
      }
      const createRunner = /* @__PURE__ */ __name((value) => {
        return () => {
          this._configurationService.updateValue(configName, value);
        };
      }, "createRunner");
      const actions2 = [];
      for (const option of options) {
        actions2.push(createAction({
          label: option.label,
          checked: configuredValue === option.value,
          run: createRunner(option.value)
        }));
      }
      return createSubmenuAction(label, actions2);
    }, "createEnumAction");
    const actions = [];
    actions.push(createAction({
      label: localize("context.minimap.minimap", "Minimap"),
      checked: minimapOptions.enabled,
      run: () => {
        this._configurationService.updateValue(`editor.minimap.enabled`, !minimapOptions.enabled);
      }
    }));
    actions.push(new Separator());
    actions.push(createAction({
      label: localize("context.minimap.renderCharacters", "Render Characters"),
      enabled: minimapOptions.enabled,
      checked: minimapOptions.renderCharacters,
      run: () => {
        this._configurationService.updateValue(`editor.minimap.renderCharacters`, !minimapOptions.renderCharacters);
      }
    }));
    actions.push(createEnumAction(localize("context.minimap.size", "Vertical size"), minimapOptions.enabled, "editor.minimap.size", minimapOptions.size, [{
      label: localize("context.minimap.size.proportional", "Proportional"),
      value: "proportional"
    }, {
      label: localize("context.minimap.size.fill", "Fill"),
      value: "fill"
    }, {
      label: localize("context.minimap.size.fit", "Fit"),
      value: "fit"
    }]));
    actions.push(createEnumAction(localize("context.minimap.slider", "Slider"), minimapOptions.enabled, "editor.minimap.showSlider", minimapOptions.showSlider, [{
      label: localize("context.minimap.slider.mouseover", "Mouse Over"),
      value: "mouseover"
    }, {
      label: localize("context.minimap.slider.always", "Always"),
      value: "always"
    }]));
    const useShadowDOM = this._editor.getOption(119) && !isIOS;
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
      getAnchor: () => anchor,
      getActions: () => actions,
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
        this._editor.focus();
      }
    });
  }
  _keybindingFor(action) {
    return this._keybindingService.lookupKeybinding(action.id);
  }
  dispose() {
    if (this._contextMenuIsBeingShownCount > 0) {
      this._contextViewService.hideContextView();
    }
    this._toDispose.dispose();
  }
}, "ContextMenuController");
ContextMenuController.ID = "editor.contrib.contextmenu";
ContextMenuController = __decorate30([
  __param30(1, IContextMenuService),
  __param30(2, IContextViewService),
  __param30(3, IContextKeyService),
  __param30(4, IKeybindingService),
  __param30(5, IMenuService),
  __param30(6, IConfigurationService)
], ContextMenuController);
var ShowContextMenu = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: localize("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 68,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    var _a6;
    (_a6 = ContextMenuController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.showContextMenu();
  }
};
__name(ShowContextMenu, "ShowContextMenu");
registerEditorContribution(ContextMenuController.ID, ContextMenuController, 2);
registerEditorAction(ShowContextMenu);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/browser/cursorUndo.js
init_define_process();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_nls();
var CursorState2 = class {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i = 0; i < thisLen; i++) {
      if (!this.selections[i].equalsSelection(other.selections[i])) {
        return false;
      }
    }
    return true;
  }
};
__name(CursorState2, "CursorState");
var StackElement = class {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
};
__name(StackElement, "StackElement");
var CursorUndoRedoController = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(CursorUndoRedoController.ID);
  }
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor2.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState2(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
};
__name(CursorUndoRedoController, "CursorUndoRedoController");
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
      }
    });
  }
  run(accessor, editor2, args) {
    var _a6;
    (_a6 = CursorUndoRedoController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.cursorUndo();
  }
};
__name(CursorUndo, "CursorUndo");
var CursorRedo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    var _a6;
    (_a6 = CursorUndoRedoController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.cursorRedo();
  }
};
__name(CursorRedo, "CursorRedo");
registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController, 0);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
init_define_process();
init_lifecycle();
init_platform();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_textModel();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dragAndDropCommand.js
init_define_process();
init_range();
init_selection();
var DragAndDropCommand = class {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    const text = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
};
__name(DragAndDropCommand, "DragAndDropCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dnd/browser/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
__name(hasTriggerModifier, "hasTriggerModifier");
var DragAndDropController = class extends Disposable {
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._dndDecorationIds = this._editor.createDecorationsCollection();
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(31) || this._editor.getOption(18)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(31) || this._editor.getOption(18)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    const target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      const possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      const newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          const primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(newSelections || [], "mouse", 3);
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    this._dndDecorationIds.set([{
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      options: DragAndDropController._DECORATION_OPTIONS
    }]);
    this._editor.revealPosition(position, 1);
  }
  _removeDecoration() {
    this._dndDecorationIds.clear();
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
};
__name(DragAndDropController, "DragAndDropController");
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "dnd-target",
  className: "dnd-target"
});
registerEditorContribution(DragAndDropController.ID, DragAndDropController, 2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/dropIntoEditor/browser/dropIntoEditorContribution.js
init_define_process();
init_async();
init_lifecycle();
init_mime();
init_resources();
init_uri();
init_editorExtensions();
init_range();
init_languageFeatures();
init_editorState();
init_nls();
init_progress();
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DropIntoEditorController = /* @__PURE__ */ __name(class DropIntoEditorController2 extends Disposable {
  constructor(editor2, _bulkEditService, _languageFeaturesService, _progressService, workspaceContextService) {
    super();
    this._bulkEditService = _bulkEditService;
    this._languageFeaturesService = _languageFeaturesService;
    this._progressService = _progressService;
    this._register(editor2.onDropIntoEditor((e) => this.onDropIntoEditor(editor2, e.position, e.event)));
    this._languageFeaturesService.documentOnDropEditProvider.register("*", new DefaultOnDropProvider(workspaceContextService));
  }
  onDropIntoEditor(editor2, position, dragEvent) {
    var _a6, _b2;
    return __awaiter25(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer || !editor2.hasModel()) {
        return;
      }
      const model = editor2.getModel();
      const initialModelVersion = model.getVersionId();
      const ourDataTransfer = yield this.extractDataTransferData(dragEvent);
      if (ourDataTransfer.size === 0) {
        return;
      }
      if (editor2.getModel().getVersionId() !== initialModelVersion) {
        return;
      }
      const tokenSource = new EditorStateCancellationTokenSource(editor2, 1);
      try {
        const providers = this._languageFeaturesService.documentOnDropEditProvider.ordered(model);
        const providerEdit = yield this._progressService.withProgress({
          location: 15,
          delay: 750,
          title: localize("dropProgressTitle", "Running drop handlers..."),
          cancellable: true
        }, () => {
          return raceCancellation((() => __awaiter25(this, void 0, void 0, function* () {
            for (const provider of providers) {
              const edit = yield provider.provideDocumentOnDropEdits(model, position, ourDataTransfer, tokenSource.token);
              if (tokenSource.token.isCancellationRequested) {
                return void 0;
              }
              if (edit) {
                return edit;
              }
            }
            return void 0;
          }))(), tokenSource.token);
        }, () => {
          tokenSource.cancel();
        });
        if (tokenSource.token.isCancellationRequested || editor2.getModel().getVersionId() !== initialModelVersion) {
          return;
        }
        if (providerEdit) {
          const snippet = typeof providerEdit.insertText === "string" ? SnippetParser.escape(providerEdit.insertText) : providerEdit.insertText.snippet;
          const combinedWorkspaceEdit = {
            edits: [
              new ResourceTextEdit(model.uri, {
                range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
                text: snippet,
                insertAsSnippet: true
              }),
              ...(_b2 = (_a6 = providerEdit.additionalEdit) === null || _a6 === void 0 ? void 0 : _a6.edits) !== null && _b2 !== void 0 ? _b2 : []
            ]
          };
          yield this._bulkEditService.apply(combinedWorkspaceEdit, { editor: editor2 });
          return;
        }
      } finally {
        tokenSource.dispose();
      }
    });
  }
  extractDataTransferData(dragEvent) {
    return __awaiter25(this, void 0, void 0, function* () {
      if (!dragEvent.dataTransfer) {
        return new VSDataTransfer();
      }
      const textEditorDataTransfer = toVSDataTransfer(dragEvent.dataTransfer);
      addExternalEditorsDropData(textEditorDataTransfer, dragEvent);
      return textEditorDataTransfer;
    });
  }
}, "DropIntoEditorController");
DropIntoEditorController.ID = "editor.contrib.dropIntoEditorController";
DropIntoEditorController = __decorate31([
  __param31(1, IBulkEditService),
  __param31(2, ILanguageFeaturesService),
  __param31(3, IProgressService),
  __param31(4, IWorkspaceContextService)
], DropIntoEditorController);
var DefaultOnDropProvider = /* @__PURE__ */ __name(class DefaultOnDropProvider2 {
  constructor(_workspaceContextService) {
    this._workspaceContextService = _workspaceContextService;
  }
  provideDocumentOnDropEdits(_model, _position, dataTransfer, _token) {
    var _a6;
    return __awaiter25(this, void 0, void 0, function* () {
      const urlListEntry = dataTransfer.get(Mimes.uriList);
      if (urlListEntry) {
        const urlList = yield urlListEntry.asString();
        const snippet = this.getUriListInsertText(urlList);
        if (snippet) {
          return { insertText: snippet };
        }
      }
      const textEntry = (_a6 = dataTransfer.get("text")) !== null && _a6 !== void 0 ? _a6 : dataTransfer.get(Mimes.text);
      if (textEntry) {
        const text = yield textEntry.asString();
        return { insertText: text };
      }
      return void 0;
    });
  }
  getUriListInsertText(strUriList) {
    const uris = [];
    for (const resource of UriList.parse(strUriList)) {
      try {
        uris.push(URI.parse(resource));
      } catch (_a6) {
      }
    }
    if (!uris.length) {
      return;
    }
    return uris.map((uri) => {
      const root = this._workspaceContextService.getWorkspaceFolder(uri);
      if (root) {
        const rel = relativePath(root.uri, uri);
        if (rel) {
          return rel;
        }
      }
      return uri.fsPath;
    }).join(" ");
  }
}, "DefaultOnDropProvider");
DefaultOnDropProvider = __decorate31([
  __param31(0, IWorkspaceContextService)
], DefaultOnDropProvider);
registerEditorContribution(DropIntoEditorController.ID, DropIntoEditorController, 2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_define_process();
init_async();
init_lifecycle();
init_strings();
init_editorExtensions();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_define_process();
init_arrays();
init_async();
init_lifecycle();
init_position();
init_range();
init_selection();
init_textModelSearch();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findDecorations.js
init_define_process();
init_range();
init_model2();
init_textModel();
init_colorRegistry();
init_themeService();
var FindDecorations = class {
  constructor(editor2) {
    this._editor = editor2;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations());
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index = this._decorations.indexOf(decorationId);
    if (index >= 0) {
      return index + 1;
    }
    return 1;
  }
  getCurrentMatchesPosition(desiredRange) {
    const candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i = 0, len = this._decorations.length; i < len; i++) {
        const range = this._editor.getModel().getDecorationRange(this._decorations[i]);
        if (nextMatch.equalsRange(range)) {
          newCurrentDecorationId = this._decorations[i];
          matchPosition = i + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            const lineBeforeEnd = rng.endLineNumber - 1;
            const lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
      const newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i = 1, len = findMatches.length; i < len; i++) {
          const range = findMatches[i].range;
          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
            if (range.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range.startLineNumber;
            prevEndLineNumber = range.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const newFindMatchesDecorations = new Array(findMatches.length);
      for (let i = 0, len = findMatches.length; i < len; i++) {
        newFindMatchesDecorations[i] = {
          range: findMatches[i].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = this._decorations.length - 1; i >= 0; i--) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = 0, len = this._decorations.length; i < len; i++) {
      const decorationId = this._decorations[i];
      const r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
};
__name(FindDecorations, "FindDecorations");
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: true
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replaceAllCommand.js
init_define_process();
init_range();
var ReplaceAllCommand = class {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      const ops = [];
      for (let i = 0; i < this._ranges.length; i++) {
        ops.push({
          range: this._ranges[i],
          text: this._replaceStrings[i]
        });
      }
      ops.sort((o1, o2) => {
        return Range.compareRangesUsingStarts(o1.range, o2.range);
      });
      const resultOps = [];
      let previousOp = ops[0];
      for (let i = 1; i < ops.length; i++) {
        if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i].range);
          previousOp.text = previousOp.text + ops[i].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
};
__name(ReplaceAllCommand, "ReplaceAllCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/base/common/search.js
init_define_process();
init_strings();
function buildReplaceStringWithCasePreserved(matches, pattern) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) {
      return pattern[0].toUpperCase() + pattern.substr(1);
    } else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) {
      return pattern[0].toLowerCase() + pattern.substr(1);
    } else {
      return pattern;
    }
  } else {
    return pattern;
  }
}
__name(buildReplaceStringWithCasePreserved, "buildReplaceStringWithCasePreserved");
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
__name(validateSpecificSpecialCharacter, "validateSpecificSpecialCharacter");
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}
__name(buildReplaceStringForSpecificSpecialCharacter, "buildReplaceStringForSpecificSpecialCharacter");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/replacePattern.js
var StaticValueReplacePattern = class {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
};
__name(StaticValueReplacePattern, "StaticValueReplacePattern");
var DynamicPiecesReplacePattern = class {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
};
__name(DynamicPiecesReplacePattern, "DynamicPiecesReplacePattern");
var ReplacePattern = class {
  static fromStaticValue(value) {
    return new ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i = 0, len = this._state.pieces.length; i < len; i++) {
      const piece = this._state.pieces[i];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match = ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        const repl = [];
        const lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match[idx].toUpperCase());
              break;
            case "u":
              repl.push(match[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match[idx].toLowerCase());
              break;
            case "l":
              repl.push(match[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match[idx]);
          }
        }
        match = repl.join("");
      }
      result += match;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        const match = matches[matchIndex] || "";
        return match + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
};
__name(ReplacePattern, "ReplacePattern");
var ReplacePiece = class {
  static staticValue(value) {
    return new ReplacePiece(value, -1, null);
  }
  static caseOps(index, caseOps) {
    return new ReplacePiece(null, index, caseOps);
  }
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
};
__name(ReplacePiece, "ReplacePiece");
var ReplacePieceBuilder = class {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
};
__name(ReplacePieceBuilder, "ReplacePieceBuilder");
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  const caseOps = [];
  const result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    const chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      const nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          const nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}
__name(parseReplaceString, "parseReplaceString");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findModel.js
init_contextkey();
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
var CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
var ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: { primary: 2048 | 512 | 33 }
};
var ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: { primary: 2048 | 512 | 53 }
};
var ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: { primary: 2048 | 512 | 48 }
};
var ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: { primary: 2048 | 512 | 42 }
};
var TogglePreserveCaseKeybinding = {
  primary: 512 | 46,
  mac: { primary: 2048 | 512 | 46 }
};
var FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class {
  constructor(editor2, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor2;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor2);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      const model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    const findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range) => Range.compareRangesUsingStarts(range, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(36).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0);
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match) {
    const matchesPosition = this._decorations.setCurrentFindMatch(match);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
    this._editor.setSelection(match);
    this._editor.revealRangeInCenterIfOutsideViewport(match, 0);
  }
  _prevSearchPosition(before) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = before;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    const { lineNumber, column } = before;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    const isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = after;
    const model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    const nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    const findScope = this._decorations.getFindScope();
    const searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    const { lineNumber, column } = after;
    const model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    const replacePattern = this._getReplacePattern();
    const selection = this._editor.getSelection();
    const nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        const replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        const command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(122) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod2 = "mu";
      if (searchRegex.ignoreCase) {
        mod2 += "i";
      }
      if (searchRegex.global) {
        mod2 += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod2);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(1);
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    const command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    const matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824);
    const replaceStrings = [];
    for (let i = 0, len = matches.length; i < len; i++) {
      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
    }
    const command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    const matches = this._findMatches(findScopes, false, 1073741824);
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    const editorSelection = this._editor.getSelection();
    for (let i = 0, len = selections.length; i < len; i++) {
      const sel = selections[i];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
};
__name(FindModelBoundToEditorModel, "FindModelBoundToEditorModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findOptionsWidget.js
init_define_process();
init_dom();
init_async();
init_colorRegistry();
var FindOptionsWidget = class extends Widget {
  constructor(editor2, state, keybindingService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor2;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.style.zIndex = "12";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const toggleStyles = {
      inputActiveOptionBorder: asCssValue(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssValue(inputActiveOptionForeground),
      inputActiveOptionBackground: asCssValue(inputActiveOptionBackground)
    };
    this.caseSensitive = this._register(new CaseSensitiveToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand), isChecked: this._state.matchCase }, toggleStyles)));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand), isChecked: this._state.wholeWord }, toggleStyles)));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexToggle(Object.assign({ appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand), isChecked: this._state.isRegex }, toggleStyles)));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableListener(this._domNode, EventType.MOUSE_LEAVE, (e) => this._onMouseLeave()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
  }
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
};
__name(FindOptionsWidget, "FindOptionsWidget");
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findState.js
init_define_process();
init_event();
init_lifecycle();
init_range();
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
__name(effectiveOptionValue, "effectiveOptionValue");
var FindReplaceState = class extends Disposable {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
    this._isSearching = false;
    this._filters = null;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    const changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    var _a6;
    const changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false,
      isSearching: false,
      filters: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!((_a6 = newState.searchScope) === null || _a6 === void 0 ? void 0 : _a6.every((newSearchScope) => {
        var _a7;
        return (_a7 = this._searchScope) === null || _a7 === void 0 ? void 0 : _a7.some((existingSearchScope) => {
          return !Range.equalsRange(existingSearchScope, newSearchScope);
        });
      }))) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isSearching !== "undefined") {
      if (this._isSearching !== newState.isSearching) {
        this._isSearching = newState.isSearching;
        changeEvent.isSearching = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.filters !== "undefined") {
      if (this._filters) {
        this._filters.update(newState.filters);
      } else {
        this._filters = newState.filters;
      }
      changeEvent.filters = true;
      somethingChanged = true;
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
};
__name(FindReplaceState, "FindReplaceState");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
init_define_process();
init_dom();
init_aria();
init_async();
init_codicons();
init_errors();
init_lifecycle();
init_platform();
init_strings();
init_range();
init_nls();

// ../../node_modules/monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js
init_define_process();
function showHistoryKeybindingHint(keybindingService) {
  var _a6, _b2;
  return ((_a6 = keybindingService.lookupKeybinding("history.showPrevious")) === null || _a6 === void 0 ? void 0 : _a6.getElectronAccelerator()) === "Up" && ((_b2 = keybindingService.lookupKeybinding("history.showNext")) === null || _b2 === void 0 ? void 0 : _b2.getElectronAccelerator()) === "Down";
}
__name(showHistoryKeybindingHint, "showHistoryKeybindingHint");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findWidget.js
init_colorRegistry();
init_themeService();
init_theme();
init_types();
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
var findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
var findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
var findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
var findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
var NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
var NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
var NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
var NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
var NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
var NLS_NO_RESULTS = localize("label.noResults", "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
};
__name(FindWidgetViewZone, "FindWidgetViewZone");
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
__name(stopPropagationForMultiLineUpwards, "stopPropagationForMultiLineUpwards");
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
__name(stopPropagationForMultiLineDownwards, "stopPropagationForMultiLineDownwards");
var FindWidget = class extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
    super();
    this._cachedHeight = null;
    this._revealTimeouts = [];
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._notificationService = notificationService;
    this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0);
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(84)) {
        if (this._codeEditor.getOption(84)) {
          this._state.change({ isReplaceRevealed: false }, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(136)) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(2)) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(36)) {
        const addExtraSpaceOnTop = this._codeEditor.getOption(36).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter26(this, void 0, void 0, function* () {
      if (this._isVisible) {
        const globalBufferTerm = yield this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({ searchString: globalBufferTerm }, false);
          this._findInput.select();
        }
      }
    })));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(36).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  getId() {
    return FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
      };
    }
    return null;
  }
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(84) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.preserveCase) {
      this._replaceInput.setPreserveCase(this._state.preserveCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      const showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    if (this._matchesCount.firstChild) {
      this._matchesCount.removeChild(this._matchesCount.firstChild);
    }
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
  }
  _updateToggleSelectionFindButton() {
    const selection = this._codeEditor.getSelection();
    const isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    const isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    const findInputIsNonEmpty = this._state.searchString.length > 0;
    const matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const canReplace = !this._codeEditor.getOption(84);
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(36).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        }
        default:
          break;
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0));
      this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200));
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(36).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      this._domNode.classList.remove("visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone(targetScrollTop) {
    const addExtraSpaceOnTop = this._codeEditor.getOption(36).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(36).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        const scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(78).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!isInDOM(this._domNode)) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else if (this._domNode.classList.contains("hiddenEditor")) {
      this._domNode.classList.remove("hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      const widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
    this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
    this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    if (this._resized) {
      this._findInput.inputBox.layout();
      const findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      const selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({ searchScope: selections }, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(2)) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
          this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
          this._ctrlEnterReplaceAllWarningPrompted = true;
          this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0, 0);
        }
        this._replaceInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(2)) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(1024 | 2)) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  getVerticalSashLeft(_sash) {
    return 0;
  }
  _keybindingLabelFor(actionId) {
    const kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return { content: e.message };
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showCommonFindToggles: true,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent) {
        return;
      }
      this._state.change({ searchString: this._findInput.getValue() }, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(1024 | 2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      icon: findPreviousMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      icon: findNextMatchIcon,
      onTrigger: () => {
        assertIsDefined(this._codeEditor.getAction(FIND_IDS.NextMatchFindAction)).run().then(void 0, onUnexpectedError);
      }
    }));
    const findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Toggle({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false,
      inputActiveOptionBackground: asCssValue(inputActiveOptionBackground),
      inputActiveOptionBorder: asCssValue(inputActiveOptionBorder),
      inputActiveOptionForeground: asCssValue(inputActiveOptionForeground)
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          const selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      } else {
        this._state.change({ searchScope: null }, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      icon: widgetClose,
      onTrigger: () => {
        this._state.change({ isRevealed: false, searchScope: null }, false);
      },
      onKeyDown: (e) => {
        if (e.equals(2)) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }));
    actionsContainer.appendChild(this._closeBtn.domNode);
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService),
      inputBoxStyles: defaultInputBoxStyles,
      toggleStyles: defaultToggleStyles
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(2)) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      icon: findReplaceIcon,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(1024 | 2)) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      icon: findReplaceAllIcon,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    const replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(replacePart);
    this._resizeSash = new Sash(this._domNode, this, { orientation: 0, size: 2 });
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      const width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      } else {
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(2);
    this._findInput.setFocusInputOnOptionClick(value !== 2);
  }
};
__name(FindWidget, "FindWidget");
FindWidget.ID = "editor.contrib.findWidget";
var SimpleButton = class extends Widget {
  constructor(opts) {
    super();
    this._opts = opts;
    let className = "button";
    if (this._opts.className) {
      className = className + " " + this._opts.className;
    }
    if (this._opts.icon) {
      className = className + " " + ThemeIcon.asClassName(this._opts.icon);
    }
    this._domNode = document.createElement("div");
    this._domNode.title = this._opts.label;
    this._domNode.tabIndex = 0;
    this._domNode.className = className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      var _a6, _b2;
      if (e.equals(10) || e.equals(3)) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      (_b2 = (_a6 = this._opts).onKeyDown) === null || _b2 === void 0 ? void 0 : _b2.call(_a6, e);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    this._domNode.classList.toggle("disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded));
    if (expanded) {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
    } else {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
    }
  }
};
__name(SimpleButton, "SimpleButton");
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = /* @__PURE__ */ __name((selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  }, "addBackgroundColorRule");
  addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
  addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
  addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
  const widgetBackground = theme.getColor(editorWidgetBackground);
  addBackgroundColorRule(".find-widget", widgetBackground);
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
  }
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${isHighContrast(theme.type) ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findMatchBorder = theme.getColor(editorFindMatchBorder);
  if (findMatchBorder) {
    collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${isHighContrast(theme.type) ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const foreground2 = theme.getColor(editorWidgetForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .find-widget { color: ${foreground2}; }`);
  }
  const error = theme.getColor(errorForeground);
  if (error) {
    collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
  }
  const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
  if (resizeBorderBackground) {
    collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
  } else {
    const border = theme.getColor(editorWidgetBorder);
    if (border) {
      collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
    }
  }
  const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
  if (toolbarHoverBackgroundColor) {
    collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
  }
  const focusOutline = theme.getColor(focusBorder);
  if (focusOutline) {
    collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/find/browser/findController.js
init_nls();
init_actions2();
init_contextkey();
init_themeService();
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && false === seedSearchStringFromNonEmptySelection) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
__name(getSelectionSearchString, "getSelectionSearchString");
var CommonFindController = /* @__PURE__ */ __name(class CommonFindController2 extends Disposable {
  get editor() {
    return this._editor;
  }
  static get(editor2) {
    return editor2.getContribution(CommonFindController2.ID);
  }
  constructor(editor2, contextKeyService, storageService, clipboardService) {
    super();
    this._editor = editor2;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      const shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(36).loop
        });
      }
    }));
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store("editor.isRegex", this._state.actualIsRegex, 1, 0);
    }
    if (e.wholeWord) {
      this._storageService.store("editor.wholeWord", this._state.actualWholeWord, 1, 0);
    }
    if (e.matchCase) {
      this._storageService.store("editor.matchCase", this._state.actualMatchCase, 1, 0);
    }
    if (e.preserveCase) {
      this._storageService.store("editor.preserveCase", this._state.actualPreserveCase, 1, 0);
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({ searchScope: null }, true);
    } else {
      if (this._editor.hasModel()) {
        const selections = this._editor.getSelections();
        selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({ searchScope: selections }, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({ searchString }, false);
  }
  highlightFindOptions(ignoreWhenVisible = false) {
  }
  _start(opts, newState) {
    return __awaiter27(this, void 0, void 0, function* () {
      this.disposeModel();
      if (!this._editor.hasModel()) {
        return;
      }
      const stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
      if (opts.seedSearchStringFromSelection === "single") {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
        if (selectionSearchString) {
          if (this._state.isRegex) {
            stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
          } else {
            stateChanges.searchString = selectionSearchString;
          }
        }
      } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
        const selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
        const selectionSearchString = yield this.getGlobalBufferTerm();
        if (!this._editor.hasModel()) {
          return;
        }
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
        stateChanges.isReplaceRevealed = true;
      } else if (!this._findWidgetVisible.get()) {
        stateChanges.isReplaceRevealed = false;
      }
      if (opts.updateSearchScope) {
        const currentSelections = this._editor.getSelections();
        if (currentSelections.some((selection) => !selection.isEmpty())) {
          stateChanges.searchScope = currentSelections;
        }
      }
      stateChanges.loop = opts.loop;
      this._state.change(stateChanges, false);
      if (!this._model) {
        this._model = new FindModelBoundToEditorModel(this._editor, this._state);
      }
    });
  }
  start(opts, newState) {
    return this._start(opts, newState);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  getGlobalBufferTerm() {
    return __awaiter27(this, void 0, void 0, function* () {
      if (this._editor.getOption(36).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
        return this._clipboardService.readFindText();
      }
      return "";
    });
  }
  setGlobalBufferTerm(text) {
    if (this._editor.getOption(36).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text);
    }
  }
}, "CommonFindController");
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = __decorate32([
  __param32(1, IContextKeyService),
  __param32(2, IStorageService),
  __param32(3, IClipboardService)
], CommonFindController);
var FindController = /* @__PURE__ */ __name(class FindController2 extends CommonFindController {
  constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
    super(editor2, _contextKeyService, _storageService, clipboardService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
    this._widget = null;
    this._findOptionsWidget = null;
  }
  _start(opts, newState) {
    const _super = Object.create(null, {
      _start: { get: () => super._start }
    });
    return __awaiter27(this, void 0, void 0, function* () {
      if (!this._widget) {
        this._createFindWidget();
      }
      const selection = this._editor.getSelection();
      let updateSearchScope = false;
      switch (this._editor.getOption(36).autoFindInSelection) {
        case "always":
          updateSearchScope = true;
          break;
        case "never":
          updateSearchScope = false;
          break;
        case "multiline": {
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          updateSearchScope = isSelectionMultipleLine;
          break;
        }
        default:
          break;
      }
      opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
      yield _super._start.call(this, opts, newState);
      if (this._widget) {
        if (opts.shouldFocus === 2) {
          this._widget.focusReplaceInput();
        } else if (opts.shouldFocus === 1) {
          this._widget.focusFindInput();
        }
      }
    });
  }
  highlightFindOptions(ignoreWhenVisible = false) {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed && !ignoreWhenVisible) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService));
  }
}, "FindController");
FindController = __decorate32([
  __param32(1, IContextViewService),
  __param32(2, IContextKeyService),
  __param32(3, IKeybindingService),
  __param32(4, IThemeService),
  __param32(5, INotificationService),
  __param32(6, IStorageService),
  __param32(7, IClipboardService)
], FindController);
var StartFindAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindAction,
  label: localize("startFindAction", "Find"),
  alias: "Find",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 36,
    weight: 100
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
StartFindAction.addImplementation(0, (accessor, editor2, args) => {
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  return controller.start({
    forceRevealReplace: false,
    seedSearchStringFromSelection: editor2.getOption(36).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(36).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(36).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(36).loop
  });
});
var findArgDescription = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        regex: { type: "boolean" },
        regexOverride: {
          type: "number",
          description: localize("actions.find.isRegexOverride", 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        wholeWord: { type: "boolean" },
        wholeWordOverride: {
          type: "number",
          description: localize("actions.find.wholeWordOverride", 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        matchCase: { type: "boolean" },
        matchCaseOverride: {
          type: "number",
          description: localize("actions.find.matchCaseOverride", 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        preserveCase: { type: "boolean" },
        preserveCaseOverride: {
          type: "number",
          description: localize("actions.find.preserveCaseOverride", 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
var StartFindWithArgsAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithArgs,
      label: localize("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
      },
      description: findArgDescription
    });
  }
  run(accessor, editor2, args) {
    return __awaiter27(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        const newState = args ? {
          searchString: args.searchString,
          replaceString: args.replaceString,
          isReplaceRevealed: args.replaceString !== void 0,
          isRegex: args.isRegex,
          wholeWord: args.matchWholeWord,
          matchCase: args.isCaseSensitive,
          preserveCase: args.preserveCase
        } : {};
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(36).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(36).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 1,
          shouldAnimate: true,
          updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
          loop: editor2.getOption(36).loop
        }, newState);
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
__name(StartFindWithArgsAction, "StartFindWithArgsAction");
var StartFindWithSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter27(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "multiple",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(36).loop
        });
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
__name(StartFindWithSelectionAction, "StartFindWithSelectionAction");
var MatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter27(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (controller && !this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(36).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(36).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(36).loop
        });
        this._run(controller);
      }
    });
  }
};
__name(MatchFindAction, "MatchFindAction");
var NextMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: { primary: 2048 | 37, secondary: [61] },
        weight: 100
      }, {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
      }]
    });
  }
  _run(controller) {
    const result = controller.moveToNextMatch();
    if (result) {
      controller.editor.pushUndoStop();
      return true;
    }
    return false;
  }
};
__name(NextMatchFindAction, "NextMatchFindAction");
var PreviousMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: EditorContextKeys.focus,
          primary: 1024 | 61,
          mac: { primary: 2048 | 1024 | 37, secondary: [1024 | 61] },
          weight: 100
        },
        {
          kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
          primary: 1024 | 3,
          weight: 100
        }
      ]
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
__name(PreviousMatchFindAction, "PreviousMatchFindAction");
var SelectionMatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter27(this, void 0, void 0, function* () {
      const controller = CommonFindController.get(editor2);
      if (!controller) {
        return;
      }
      const seedSearchStringFromNonEmptySelection = editor2.getOption(36).seedSearchStringFromSelection === "selection";
      let selectionSearchString = null;
      if (editor2.getOption(36).seedSearchStringFromSelection !== "never") {
        selectionSearchString = getSelectionSearchString(editor2, "single", seedSearchStringFromNonEmptySelection);
      }
      if (selectionSearchString) {
        controller.setSearchString(selectionSearchString);
      }
      if (!this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: editor2.getOption(36).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(36).loop
        });
        this._run(controller);
      }
    });
  }
};
__name(SelectionMatchFindAction, "SelectionMatchFindAction");
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
__name(NextSelectionMatchFindAction, "NextSelectionMatchFindAction");
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
__name(PreviousSelectionMatchFindAction, "PreviousSelectionMatchFindAction");
var StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindReplaceAction,
  label: localize("startReplace", "Replace"),
  alias: "Replace",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 38,
    mac: { primary: 2048 | 512 | 36 },
    weight: 100
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
  if (!editor2.hasModel() || editor2.getOption(84)) {
    return false;
  }
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  const currentSelection = editor2.getSelection();
  const findInputFocused = controller.isFindInputFocused();
  const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(36).seedSearchStringFromSelection !== "never" && !findInputFocused;
  const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
  return controller.start({
    forceRevealReplace: true,
    seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(36).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(36).seedSearchStringFromSelection !== "never",
    shouldFocus,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(36).loop
  });
});
registerEditorContribution(CommonFindController.ID, FindController, 0);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (x) => x.togglePreserveCase(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: TogglePreserveCaseKeybinding.primary,
    mac: TogglePreserveCaseKeybinding.mac,
    win: TogglePreserveCaseKeybinding.win,
    linux: TogglePreserveCaseKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_define_process();
init_async();
init_errors();
init_keyCodes();
init_lifecycle();
init_strings();
init_types();
init_editorExtensions();
init_editorContextKeys();
init_languages();
init_languageConfigurationRegistry();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js
init_define_process();
init_event();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingRanges.js
init_define_process();
var foldSourceAbbr = {
  [0]: " ",
  [1]: "u",
  [2]: "r"
};
var MAX_FOLDING_REGIONS = 65535;
var MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var BitField = class {
  constructor(size2) {
    const numWords = Math.ceil(size2 / 32);
    this._states = new Uint32Array(numWords);
  }
  get(index) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    return (this._states[arrayIndex] & 1 << bit) !== 0;
  }
  set(index, newState) {
    const arrayIndex = index / 32 | 0;
    const bit = index % 32;
    const value = this._states[arrayIndex];
    if (newState) {
      this._states[arrayIndex] = value | 1 << bit;
    } else {
      this._states[arrayIndex] = value & ~(1 << bit);
    }
  }
};
__name(BitField, "BitField");
var FoldingRegions = class {
  constructor(startIndexes, endIndexes, types) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new BitField(startIndexes.length);
    this._userDefinedStates = new BitField(startIndexes.length);
    this._recoveredStates = new BitField(startIndexes.length);
    this._types = types;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      const parentIndexes = [];
      const isInsideLast = /* @__PURE__ */ __name((startLineNumber, endLineNumber) => {
        const index = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
      }, "isInsideLast");
      for (let i = 0, len = this._startIndexes.length; i < len; i++) {
        const startLineNumber = this._startIndexes[i];
        const endLineNumber = this._endIndexes[i];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        const parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i);
        this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index) {
    return this._startIndexes[index] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index) {
    return this._endIndexes[index] & MAX_LINE_NUMBER;
  }
  getType(index) {
    return this._types ? this._types[index] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index) {
    return this._collapseStates.get(index);
  }
  setCollapsed(index, newState) {
    this._collapseStates.set(index, newState);
  }
  isUserDefined(index) {
    return this._userDefinedStates.get(index);
  }
  setUserDefined(index, newState) {
    return this._userDefinedStates.set(index, newState);
  }
  isRecovered(index) {
    return this._recoveredStates.get(index);
  }
  setRecovered(index, newState) {
    return this._recoveredStates.set(index, newState);
  }
  getSource(index) {
    if (this.isUserDefined(index)) {
      return 1;
    } else if (this.isRecovered(index)) {
      return 2;
    }
    return 0;
  }
  setSource(index, source) {
    if (source === 1) {
      this.setUserDefined(index, true);
      this.setRecovered(index, false);
    } else if (source === 2) {
      this.setUserDefined(index, false);
      this.setRecovered(index, true);
    } else {
      this.setUserDefined(index, false);
      this.setRecovered(index, false);
    }
  }
  setCollapsedAllOfType(type, newState) {
    let hasChanged = false;
    if (this._types) {
      for (let i = 0; i < this._types.length; i++) {
        if (this._types[i] === type) {
          this.setCollapsed(i, newState);
          hasChanged = true;
        }
      }
    }
    return hasChanged;
  }
  toRegion(index) {
    return new FoldingRegion(this, index);
  }
  getParentIndex(index) {
    this.ensureParentIndices();
    const parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
    if (parent === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent;
  }
  contains(index, line) {
    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index = this.findIndex(line);
    if (index >= 0) {
      const endLineNumber = this.getEndLineNumber(index);
      if (endLineNumber >= line) {
        return index;
      }
      index = this.getParentIndex(index);
      while (index !== -1) {
        if (this.contains(index, line)) {
          return index;
        }
        index = this.getParentIndex(index);
      }
    }
    return -1;
  }
  toString() {
    const res = [];
    for (let i = 0; i < this.length; i++) {
      res[i] = `[${foldSourceAbbr[this.getSource(i)]}${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
    }
    return res.join(", ");
  }
  toFoldRange(index) {
    return {
      startLineNumber: this._startIndexes[index] & MAX_LINE_NUMBER,
      endLineNumber: this._endIndexes[index] & MAX_LINE_NUMBER,
      type: this._types ? this._types[index] : void 0,
      isCollapsed: this.isCollapsed(index),
      source: this.getSource(index)
    };
  }
  static fromFoldRanges(ranges) {
    const rangesLength = ranges.length;
    const startIndexes = new Uint32Array(rangesLength);
    const endIndexes = new Uint32Array(rangesLength);
    let types = [];
    let gotTypes = false;
    for (let i = 0; i < rangesLength; i++) {
      const range = ranges[i];
      startIndexes[i] = range.startLineNumber;
      endIndexes[i] = range.endLineNumber;
      types.push(range.type);
      if (range.type) {
        gotTypes = true;
      }
    }
    if (!gotTypes) {
      types = void 0;
    }
    const regions = new FoldingRegions(startIndexes, endIndexes, types);
    for (let i = 0; i < rangesLength; i++) {
      if (ranges[i].isCollapsed) {
        regions.setCollapsed(i, true);
      }
      regions.setSource(i, ranges[i].source);
    }
    return regions;
  }
  static sanitizeAndMerge(rangesA, rangesB, maxLineNumber) {
    maxLineNumber = maxLineNumber !== null && maxLineNumber !== void 0 ? maxLineNumber : Number.MAX_VALUE;
    const getIndexedFunction = /* @__PURE__ */ __name((r, limit) => {
      return Array.isArray(r) ? (i) => {
        return i < limit ? r[i] : void 0;
      } : (i) => {
        return i < limit ? r.toFoldRange(i) : void 0;
      };
    }, "getIndexedFunction");
    const getA = getIndexedFunction(rangesA, rangesA.length);
    const getB = getIndexedFunction(rangesB, rangesB.length);
    let indexA = 0;
    let indexB = 0;
    let nextA = getA(0);
    let nextB = getB(0);
    const stackedRanges = [];
    let topStackedRange;
    let prevLineNumber = 0;
    const resultRanges = [];
    while (nextA || nextB) {
      let useRange = void 0;
      if (nextB && (!nextA || nextA.startLineNumber >= nextB.startLineNumber)) {
        if (nextA && nextA.startLineNumber === nextB.startLineNumber) {
          if (nextB.source === 1) {
            useRange = nextB;
          } else {
            useRange = nextA;
            useRange.isCollapsed = nextB.isCollapsed && nextA.endLineNumber === nextB.endLineNumber;
            useRange.source = 0;
          }
          nextA = getA(++indexA);
        } else {
          useRange = nextB;
          if (nextB.isCollapsed && nextB.source === 0) {
            useRange.source = 2;
          }
        }
        nextB = getB(++indexB);
      } else {
        let scanIndex = indexB;
        let prescanB = nextB;
        while (true) {
          if (!prescanB || prescanB.startLineNumber > nextA.endLineNumber) {
            useRange = nextA;
            break;
          }
          if (prescanB.source === 1 && prescanB.endLineNumber > nextA.endLineNumber) {
            break;
          }
          prescanB = getB(++scanIndex);
        }
        nextA = getA(++indexA);
      }
      if (useRange) {
        while (topStackedRange && topStackedRange.endLineNumber < useRange.startLineNumber) {
          topStackedRange = stackedRanges.pop();
        }
        if (useRange.endLineNumber > useRange.startLineNumber && useRange.startLineNumber > prevLineNumber && useRange.endLineNumber <= maxLineNumber && (!topStackedRange || topStackedRange.endLineNumber >= useRange.endLineNumber)) {
          resultRanges.push(useRange);
          prevLineNumber = useRange.startLineNumber;
          if (topStackedRange) {
            stackedRanges.push(topStackedRange);
          }
          topStackedRange = useRange;
        }
      }
    }
    return resultRanges;
  }
};
__name(FoldingRegions, "FoldingRegions");
var FoldingRegion = class {
  constructor(ranges, index) {
    this.ranges = ranges;
    this.index = index;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range) {
    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
};
__name(FoldingRegion, "FoldingRegion");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js
init_hash();
var FoldingModel = class {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  constructor(textModel, decorationProvider) {
    this._updateEventEmitter = new Emitter();
    this.onDidChange = this._updateEventEmitter.event;
    this._textModel = textModel;
    this._decorationProvider = decorationProvider;
    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
    this._editorDecorationIds = [];
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    const processed = {};
    this._decorationProvider.changeDecorations((accessor) => {
      let k = 0;
      let dirtyRegionEndLine = -1;
      let lastHiddenLine = -1;
      const updateDecorationsUntil = /* @__PURE__ */ __name((index) => {
        while (k < index) {
          const endLineNumber = this._regions.getEndLineNumber(k);
          const isCollapsed = this._regions.isCollapsed(k);
          if (endLineNumber <= dirtyRegionEndLine) {
            const isManual = this.regions.getSource(k) !== 0;
            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual));
          }
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
          k++;
        }
      }, "updateDecorationsUntil");
      for (const region of toggledRegions) {
        const index = region.regionIndex;
        const editorDecorationId = this._editorDecorationIds[index];
        if (editorDecorationId && !processed[editorDecorationId]) {
          processed[editorDecorationId] = true;
          updateDecorationsUntil(index);
          const newCollapseState = !this._regions.isCollapsed(index);
          this._regions.setCollapsed(index, newCollapseState);
          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));
        }
      }
      updateDecorationsUntil(this._regions.length);
    });
    this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });
  }
  removeManualRanges(ranges) {
    const newFoldingRanges = new Array();
    const intersects = /* @__PURE__ */ __name((foldRange) => {
      for (const range of ranges) {
        if (!(range.startLineNumber > foldRange.endLineNumber || foldRange.startLineNumber > range.endLineNumber)) {
          return true;
        }
      }
      return false;
    }, "intersects");
    for (let i = 0; i < this._regions.length; i++) {
      const foldRange = this._regions.toFoldRange(i);
      if (foldRange.source === 0 || !intersects(foldRange)) {
        newFoldingRanges.push(foldRange);
      }
    }
    this.updatePost(FoldingRegions.fromFoldRanges(newFoldingRanges));
  }
  update(newRegions, blockedLineNumers = []) {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges(blockedLineNumers);
    const newRanges = FoldingRegions.sanitizeAndMerge(newRegions, foldedOrManualRanges, this._textModel.getLineCount());
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  updatePost(newRegions) {
    const newEditorDecorations = [];
    let lastHiddenLine = -1;
    for (let index = 0, limit = newRegions.length; index < limit; index++) {
      const startLineNumber = newRegions.getStartLineNumber(index);
      const endLineNumber = newRegions.getEndLineNumber(index);
      const isCollapsed = newRegions.isCollapsed(index);
      const isManual = newRegions.getSource(index) !== 0;
      const decorationRange = {
        startLineNumber,
        startColumn: this._textModel.getLineMaxColumn(startLineNumber),
        endLineNumber,
        endColumn: this._textModel.getLineMaxColumn(endLineNumber) + 1
      };
      newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine, isManual) });
      if (isCollapsed && endLineNumber > lastHiddenLine) {
        lastHiddenLine = endLineNumber;
      }
    }
    this._decorationProvider.changeDecorations((accessor) => this._editorDecorationIds = accessor.deltaDecorations(this._editorDecorationIds, newEditorDecorations));
    this._regions = newRegions;
    this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(blockedLineNumers = []) {
    const isBlocked = /* @__PURE__ */ __name((startLineNumber, endLineNumber) => {
      for (const blockedLineNumber of blockedLineNumers) {
        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
          return true;
        }
      }
      return false;
    }, "isBlocked");
    const foldedRanges = [];
    for (let i = 0, limit = this._regions.length; i < limit; i++) {
      let isCollapsed = this.regions.isCollapsed(i);
      const source = this.regions.getSource(i);
      if (isCollapsed || source !== 0) {
        const foldRange = this._regions.toFoldRange(i);
        const decRange = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
        if (decRange) {
          if (isCollapsed && (isBlocked(decRange.startLineNumber, decRange.endLineNumber) || decRange.endLineNumber - decRange.startLineNumber !== foldRange.endLineNumber - foldRange.startLineNumber)) {
            isCollapsed = false;
          }
          foldedRanges.push({
            startLineNumber: decRange.startLineNumber,
            endLineNumber: decRange.endLineNumber,
            type: foldRange.type,
            isCollapsed,
            source
          });
        }
      }
    }
    return foldedRanges;
  }
  getMemento() {
    const foldedOrManualRanges = this._currentFoldedOrManualRanges();
    const result = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (let i = 0, limit = foldedOrManualRanges.length; i < limit; i++) {
      const range = foldedOrManualRanges[i];
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      result.push({
        startLineNumber: range.startLineNumber,
        endLineNumber: range.endLineNumber,
        isCollapsed: range.isCollapsed,
        source: range.source,
        checksum
      });
    }
    return result.length > 0 ? result : void 0;
  }
  applyMemento(state) {
    var _a6, _b2;
    if (!Array.isArray(state)) {
      return;
    }
    const rangesToRestore = [];
    const maxLineNumber = this._textModel.getLineCount();
    for (const range of state) {
      if (range.startLineNumber >= range.endLineNumber || range.startLineNumber < 1 || range.endLineNumber > maxLineNumber) {
        continue;
      }
      const checksum = this._getLinesChecksum(range.startLineNumber + 1, range.endLineNumber);
      if (!range.checksum || checksum === range.checksum) {
        rangesToRestore.push({
          startLineNumber: range.startLineNumber,
          endLineNumber: range.endLineNumber,
          type: void 0,
          isCollapsed: (_a6 = range.isCollapsed) !== null && _a6 !== void 0 ? _a6 : true,
          source: (_b2 = range.source) !== null && _b2 !== void 0 ? _b2 : 0
        });
      }
    }
    const newRanges = FoldingRegions.sanitizeAndMerge(this._regions, rangesToRestore, maxLineNumber);
    this.updatePost(FoldingRegions.fromFoldRanges(newRanges));
  }
  _getLinesChecksum(lineNumber1, lineNumber2) {
    const h = hash(this._textModel.getLineContent(lineNumber1) + this._textModel.getLineContent(lineNumber2));
    return h % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(lineNumber, filter) {
    const result = [];
    if (this._regions) {
      let index = this._regions.findRange(lineNumber);
      let level = 1;
      while (index >= 0) {
        const current = this._regions.toRegion(index);
        if (!filter || filter(current, level)) {
          result.push(current);
        }
        level++;
        index = current.parentIndex;
      }
    }
    return result;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      const index = this._regions.findRange(lineNumber);
      if (index >= 0) {
        return this._regions.toRegion(index);
      }
    }
    return null;
  }
  getRegionsInside(region, filter) {
    const result = [];
    const index = region ? region.regionIndex + 1 : 0;
    const endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter && filter.length === 2) {
      const levelStack = [];
      for (let i = index, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current);
          if (filter(current, levelStack.length)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i = index, len = this._regions.length; i < len; i++) {
        const current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          if (!filter || filter(current)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
};
__name(FoldingModel, "FoldingModel");
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(toggleCollapseState, "toggleCollapseState");
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  const toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (const lineNumber of lineNumbers) {
      const region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          const regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    const regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateLevelsDown, "setCollapseStateLevelsDown");
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateLevelsUp, "setCollapseStateLevelsUp");
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  const toToggle = [];
  for (const lineNumber of lineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateUp, "setCollapseStateUp");
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  const filter = /* @__PURE__ */ __name((region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line)), "filter");
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateAtLevel, "setCollapseStateAtLevel");
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
  const filteredRegions = [];
  for (const lineNumber of blockedLineNumbers) {
    const regions = foldingModel.getAllRegionsAtLine(lineNumber, void 0);
    if (regions.length > 0) {
      filteredRegions.push(regions[0]);
    }
  }
  const filter = /* @__PURE__ */ __name((region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse, "filter");
  const toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateForRest, "setCollapseStateForRest");
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  const editorModel = foldingModel.textModel;
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i)) {
      const startLineNumber = regions.getStartLineNumber(i);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateForMatchingLines, "setCollapseStateForMatchingLines");
function setCollapseStateForType(foldingModel, type, doCollapse) {
  const regions = foldingModel.regions;
  const toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
      toToggle.push(regions.toRegion(i));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
__name(setCollapseStateForType, "setCollapseStateForType");
function getParentFoldLine(lineNumber, foldingModel) {
  let startLineNumber = null;
  const foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null) {
    startLineNumber = foldingRegion.startLineNumber;
    if (lineNumber === startLineNumber) {
      const parentFoldingIdx = foldingRegion.parentIndex;
      if (parentFoldingIdx !== -1) {
        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
      } else {
        startLineNumber = null;
      }
    }
  }
  return startLineNumber;
}
__name(getParentFoldLine, "getParentFoldLine");
function getPreviousFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    if (lineNumber !== foldingRegion.startLineNumber) {
      return foldingRegion.startLineNumber;
    } else {
      const expectedParentIndex = foldingRegion.parentIndex;
      let minLineNumber = 0;
      if (expectedParentIndex !== -1) {
        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
      }
      while (foldingRegion !== null) {
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
          if (foldingRegion.startLineNumber <= minLineNumber) {
            return null;
          } else if (foldingRegion.parentIndex === expectedParentIndex) {
            return foldingRegion.startLineNumber;
          }
        } else {
          return null;
        }
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber < lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
__name(getPreviousFoldLine, "getPreviousFoldLine");
function getNextFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    const expectedParentIndex = foldingRegion.parentIndex;
    let maxLineNumber = 0;
    if (expectedParentIndex !== -1) {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
    } else if (foldingModel.regions.length === 0) {
      return null;
    } else {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
    }
    while (foldingRegion !== null) {
      if (foldingRegion.regionIndex < foldingModel.regions.length) {
        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        if (foldingRegion.startLineNumber >= maxLineNumber) {
          return null;
        } else if (foldingRegion.parentIndex === expectedParentIndex) {
          return foldingRegion.startLineNumber;
        }
      } else {
        return null;
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(0);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber > lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex < foldingModel.regions.length) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
__name(getNextFoldLine, "getNextFoldLine");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/hiddenRangeModel.js
init_define_process();
init_arrays();
init_event();
init_range();
init_eolCounter();
var HiddenRangeModel = class {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(model) {
    this._updateEventEmitter = new Emitter();
    this._hasLineChanges = false;
    this._foldingModel = model;
    this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
    this._hiddenRanges = [];
    if (model.regions.length) {
      this.updateHiddenRanges();
    }
  }
  notifyChangeModelContent(e) {
    if (this._hiddenRanges.length && !this._hasLineChanges) {
      this._hasLineChanges = e.changes.some((change) => {
        return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;
      });
    }
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    const newHiddenAreas = [];
    let i = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    const ranges = this._foldingModel.regions;
    for (; i < ranges.length; i++) {
      if (!ranges.isCollapsed(i)) {
        continue;
      }
      const startLineNumber = ranges.getStartLineNumber(i) + 1;
      const endLineNumber = ranges.getEndLineNumber(i);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hiddenRanges = newHiddenAreas;
    this._hasLineChanges = false;
    this._updateEventEmitter.fire(newHiddenAreas);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(line) {
    return findRange(this._hiddenRanges, line) !== null;
  }
  adjustSelections(selections) {
    let hasChanges = false;
    const editorModel = this._foldingModel.textModel;
    let lastRange = null;
    const adjustLine = /* @__PURE__ */ __name((line) => {
      if (!lastRange || !isInside(line, lastRange)) {
        lastRange = findRange(this._hiddenRanges, line);
      }
      if (lastRange) {
        return lastRange.startLineNumber - 1;
      }
      return null;
    }, "adjustLine");
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      const adjustedStartLine = adjustLine(selection.startLineNumber);
      if (adjustedStartLine) {
        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
        hasChanges = true;
      }
      const adjustedEndLine = adjustLine(selection.endLineNumber);
      if (adjustedEndLine) {
        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
        hasChanges = true;
      }
      selections[i] = selection;
    }
    return hasChanges;
  }
  dispose() {
    if (this.hiddenRanges.length > 0) {
      this._hiddenRanges = [];
      this._updateEventEmitter.fire(this._hiddenRanges);
    }
    if (this._foldingModelListener) {
      this._foldingModelListener.dispose();
      this._foldingModelListener = null;
    }
  }
};
__name(HiddenRangeModel, "HiddenRangeModel");
function isInside(line, range) {
  return line >= range.startLineNumber && line <= range.endLineNumber;
}
__name(isInside, "isInside");
function findRange(ranges, line) {
  const i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
  if (i >= 0 && ranges[i].endLineNumber >= line) {
    return ranges[i];
  }
  return null;
}
__name(findRange, "findRange");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/indentRangeProvider.js
init_define_process();
init_utils();
var MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT = 5e3;
var ID_INDENT_PROVIDER = "indent";
var IndentRangeProvider = class {
  constructor(editorModel, languageConfigurationService, foldingRangesLimit) {
    this.editorModel = editorModel;
    this.languageConfigurationService = languageConfigurationService;
    this.foldingRangesLimit = foldingRangesLimit;
    this.id = ID_INDENT_PROVIDER;
  }
  dispose() {
  }
  compute(cancelationToken) {
    const foldingRules = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules;
    const offSide = foldingRules && !!foldingRules.offSide;
    const markers = foldingRules && foldingRules.markers;
    return Promise.resolve(computeRanges(this.editorModel, offSide, markers, this.foldingRangesLimit));
  }
};
__name(IndentRangeProvider, "IndentRangeProvider");
var RangesCollector = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._indentOccurrences = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  insertFirst(startLineNumber, endLineNumber, indent) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._length++;
    if (indent < 1e3) {
      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
    }
  }
  toIndentRanges(model) {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.report({ limited: false, computed: this._length });
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
        startIndexes[k] = this._startIndexes[i];
        endIndexes[k] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes);
    } else {
      this._foldingRangesLimit.report({ limited: limit, computed: this._length });
      let entries = 0;
      let maxIndent = this._indentOccurrences.length;
      for (let i = 0; i < this._indentOccurrences.length; i++) {
        const n = this._indentOccurrences[i];
        if (n) {
          if (n + entries > limit) {
            maxIndent = i;
            break;
          }
          entries += n;
        }
      }
      const tabSize = model.getOptions().tabSize;
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      for (let i = this._length - 1, k = 0; i >= 0; i--) {
        const startIndex = this._startIndexes[i];
        const lineContent = model.getLineContent(startIndex);
        const indent = computeIndentLevel(lineContent, tabSize);
        if (indent < maxIndent || indent === maxIndent && entries++ < limit) {
          startIndexes[k] = startIndex;
          endIndexes[k] = this._endIndexes[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes);
    }
  }
};
__name(RangesCollector, "RangesCollector");
var foldingRangesLimitDefault = {
  limit: MAX_FOLDING_REGIONS_FOR_INDENT_DEFAULT,
  report: () => {
  }
};
function computeRanges(model, offSide, markers, foldingRangesLimit = foldingRangesLimitDefault) {
  const tabSize = model.getOptions().tabSize;
  const result = new RangesCollector(foldingRangesLimit);
  let pattern = void 0;
  if (markers) {
    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  const previousRegions = [];
  const line = model.getLineCount() + 1;
  previousRegions.push({ indent: -1, endAbove: line, line });
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    const lineContent = model.getLineContent(line2);
    const indent = computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern && (m = lineContent.match(pattern))) {
      if (m[1]) {
        let i = previousRegions.length - 1;
        while (i > 0 && previousRegions[i].indent !== -2) {
          i--;
        }
        if (i > 0) {
          previousRegions.length = i + 1;
          previous = previousRegions[i];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        } else {
        }
      } else {
        previousRegions.push({ indent: -2, endAbove: line2, line: line2 });
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      const endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({ indent, endAbove: line2, line: line2 });
    }
  }
  return result.toIndentRanges(model);
}
__name(computeRanges, "computeRanges");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_nls();
init_contextkey();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/foldingDecorations.js
init_define_process();
init_codicons();
init_model2();
init_textModel();
init_nls();
init_colorRegistry();
init_themeService();
var foldBackground = registerColor("editor.foldBackground", { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hcDark: null, hcLight: null }, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editorGutter.foldingControlForeground", { dark: iconForeground, light: iconForeground, hcDark: iconForeground, hcLight: iconForeground }, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
var foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin."));
var foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
var foldingManualCollapsedIcon = registerIcon("folding-manual-collapsed", foldingCollapsedIcon, localize("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin."));
var foldingManualExpandedIcon = registerIcon("folding-manual-expanded", foldingExpandedIcon, localize("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin."));
var foldedBackgroundMinimap = { color: themeColorFromId(foldBackground), position: MinimapPosition.Inline };
var FoldingDecorationProvider = class {
  constructor(editor2) {
    this.editor = editor2;
    this.showFoldingControls = "mouseover";
    this.showFoldingHighlights = true;
  }
  getDecorationOption(isCollapsed, isHidden, isManual) {
    if (isHidden) {
      return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
    }
    if (this.showFoldingControls === "never") {
      if (isCollapsed) {
        return this.showFoldingHighlights ? FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION;
      }
      return FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION;
    }
    if (isCollapsed) {
      return isManual ? this.showFoldingHighlights ? FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
    } else if (this.showFoldingControls === "mouseover") {
      return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
    } else {
      return isManual ? FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION : FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
    }
  }
  changeDecorations(callback) {
    return this.editor.changeDecorations(callback);
  }
  removeDecorations(decorationIds) {
    this.editor.removeDecorations(decorationIds);
  }
};
__name(FoldingDecorationProvider, "FoldingDecorationProvider");
FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
FoldingDecorationProvider.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualCollapsedIcon)
});
FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: true
});
FoldingDecorationProvider.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: foldedBackgroundMinimap,
  isWholeLine: true
});
FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingManualExpandedIcon)
});
FoldingDecorationProvider.NO_CONTROLS_EXPANDED_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: true
});
FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/syntaxRangeProvider.js
init_define_process();
init_errors();
init_lifecycle();
var foldingContext = {};
var ID_SYNTAX_PROVIDER = "syntax";
var SyntaxRangeProvider = class {
  constructor(editorModel, providers, handleFoldingRangesChange, foldingRangesLimit) {
    this.editorModel = editorModel;
    this.providers = providers;
    this.handleFoldingRangesChange = handleFoldingRangesChange;
    this.foldingRangesLimit = foldingRangesLimit;
    this.id = ID_SYNTAX_PROVIDER;
    for (const provider of providers) {
      if (typeof provider.onDidChange === "function") {
        if (!this.disposables) {
          this.disposables = new DisposableStore();
        }
        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
      }
    }
  }
  compute(cancellationToken) {
    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
      if (ranges) {
        const res = sanitizeRanges(ranges, this.foldingRangesLimit);
        return res;
      }
      return null;
    });
  }
  dispose() {
    var _a6;
    (_a6 = this.disposables) === null || _a6 === void 0 ? void 0 : _a6.dispose();
  }
};
__name(SyntaxRangeProvider, "SyntaxRangeProvider");
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  const promises = providers.map((provider, i) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        const nLines = model.getLineCount();
        for (const r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
__name(collectSyntaxRanges, "collectSyntaxRanges");
var RangesCollector2 = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._nestingLevels = [];
    this._nestingLevelCounts = [];
    this._types = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  add(startLineNumber, endLineNumber, type, nestingLevel) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    const index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._nestingLevels[index] = nestingLevel;
    this._types[index] = type;
    this._length++;
    if (nestingLevel < 30) {
      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
    }
  }
  toIndentRanges() {
    const limit = this._foldingRangesLimit.limit;
    if (this._length <= limit) {
      this._foldingRangesLimit.report({ limited: false, computed: this._length });
      const startIndexes = new Uint32Array(this._length);
      const endIndexes = new Uint32Array(this._length);
      for (let i = 0; i < this._length; i++) {
        startIndexes[i] = this._startIndexes[i];
        endIndexes[i] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes, this._types);
    } else {
      this._foldingRangesLimit.report({ limited: limit, computed: this._length });
      let entries = 0;
      let maxLevel = this._nestingLevelCounts.length;
      for (let i = 0; i < this._nestingLevelCounts.length; i++) {
        const n = this._nestingLevelCounts[i];
        if (n) {
          if (n + entries > limit) {
            maxLevel = i;
            break;
          }
          entries += n;
        }
      }
      const startIndexes = new Uint32Array(limit);
      const endIndexes = new Uint32Array(limit);
      const types = [];
      for (let i = 0, k = 0; i < this._length; i++) {
        const level = this._nestingLevels[i];
        if (level < maxLevel || level === maxLevel && entries++ < limit) {
          startIndexes[k] = this._startIndexes[i];
          endIndexes[k] = this._endIndexes[i];
          types[k] = this._types[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes, types);
    }
  }
};
__name(RangesCollector2, "RangesCollector");
function sanitizeRanges(rangeData, foldingRangesLimit) {
  const sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  const collector = new RangesCollector2(foldingRangesLimit);
  let top = void 0;
  const previous = [];
  for (const entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}
__name(sanitizeRanges, "sanitizeRanges");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js
init_languageFeatureDebounce();
init_stopwatch();
init_languageFeatures();
init_event();
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
var FoldingController = /* @__PURE__ */ __name(class FoldingController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(FoldingController2.ID);
  }
  constructor(editor2, contextKeyService, languageConfigurationService, notificationService, languageFeatureDebounceService, languageFeaturesService) {
    super();
    this.contextKeyService = contextKeyService;
    this.languageConfigurationService = languageConfigurationService;
    this.languageFeaturesService = languageFeaturesService;
    this.localToDispose = this._register(new DisposableStore());
    this._onDidChangeFoldingLimit = new Emitter();
    this.editor = editor2;
    const options = this.editor.getOptions();
    this._isEnabled = options.get(38);
    this._useFoldingProviders = options.get(39) !== "indentation";
    this._unfoldOnClickAfterEndOfLine = options.get(43);
    this._restoringViewState = false;
    this._currentModelHasFoldedImports = false;
    this._foldingImportsByDefault = options.get(41);
    this._foldingLimitReporter = {
      get limit() {
        return editor2.getOptions().get(42);
      },
      report: (info) => {
        if (!this._foldingLimitInfo || info.limited !== this._foldingLimitInfo.limited) {
          this._foldingLimitInfo = info;
          this._onDidChangeFoldingLimit.fire(info);
        }
      }
    };
    this.updateDebounceInfo = languageFeatureDebounceService.for(languageFeaturesService.foldingRangeProvider, "Folding", { min: 200 });
    this.foldingModel = null;
    this.hiddenRangeModel = null;
    this.rangeProvider = null;
    this.foldingRegionPromise = null;
    this.foldingModelPromise = null;
    this.updateScheduler = null;
    this.cursorChangedScheduler = null;
    this.mouseDownInfo = null;
    this.foldingDecorationProvider = new FoldingDecorationProvider(editor2);
    this.foldingDecorationProvider.showFoldingControls = options.get(102);
    this.foldingDecorationProvider.showFoldingHighlights = options.get(40);
    this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
    this.foldingEnabled.set(this._isEnabled);
    this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(38)) {
        this._isEnabled = this.editor.getOptions().get(38);
        this.foldingEnabled.set(this._isEnabled);
        this.onModelChanged();
      }
      if (e.hasChanged(42)) {
        this.onModelChanged();
      }
      if (e.hasChanged(102) || e.hasChanged(40)) {
        const options2 = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = options2.get(102);
        this.foldingDecorationProvider.showFoldingHighlights = options2.get(40);
        this.triggerFoldingModelChanged();
      }
      if (e.hasChanged(39)) {
        this._useFoldingProviders = this.editor.getOptions().get(39) !== "indentation";
        this.onFoldingStrategyChanged();
      }
      if (e.hasChanged(43)) {
        this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(43);
      }
      if (e.hasChanged(41)) {
        this._foldingImportsByDefault = this.editor.getOptions().get(41);
      }
    }));
    this.onModelChanged();
  }
  saveViewState() {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
      return {};
    }
    if (this.foldingModel) {
      const collapsedRegions = this.foldingModel.getMemento();
      const provider = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };
    }
    return void 0;
  }
  restoreViewState(state) {
    const model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
      return;
    }
    if (!state) {
      return;
    }
    this._currentModelHasFoldedImports = !!state.foldedImports;
    if (state.collapsedRegions && state.collapsedRegions.length > 0 && this.foldingModel) {
      this._restoringViewState = true;
      try {
        this.foldingModel.applyMemento(state.collapsedRegions);
      } finally {
        this._restoringViewState = false;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const model = this.editor.getModel();
    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
      return;
    }
    this._currentModelHasFoldedImports = false;
    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
    this.localToDispose.add(this.foldingModel);
    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
    this.localToDispose.add(this.hiddenRangeModel);
    this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
    this.updateScheduler = new Delayer(this.updateDebounceInfo.get(model));
    this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
    this.localToDispose.add(this.cursorChangedScheduler);
    this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelContent((e) => this.onDidChangeModelContent(e)));
    this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    this.localToDispose.add({
      dispose: () => {
        var _a6, _b2;
        if (this.foldingRegionPromise) {
          this.foldingRegionPromise.cancel();
          this.foldingRegionPromise = null;
        }
        (_a6 = this.updateScheduler) === null || _a6 === void 0 ? void 0 : _a6.cancel();
        this.updateScheduler = null;
        this.foldingModel = null;
        this.foldingModelPromise = null;
        this.hiddenRangeModel = null;
        this.cursorChangedScheduler = null;
        (_b2 = this.rangeProvider) === null || _b2 === void 0 ? void 0 : _b2.dispose();
        this.rangeProvider = null;
      }
    });
    this.triggerFoldingModelChanged();
  }
  onFoldingStrategyChanged() {
    var _a6;
    (_a6 = this.rangeProvider) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this.rangeProvider = null;
    this.triggerFoldingModelChanged();
  }
  getRangeProvider(editorModel) {
    var _a6, _b2;
    if (this.rangeProvider) {
      return this.rangeProvider;
    }
    this.rangeProvider = new IndentRangeProvider(editorModel, this.languageConfigurationService, this._foldingLimitReporter);
    if (this._useFoldingProviders && this.foldingModel) {
      const foldingProviders = this.languageFeaturesService.foldingRangeProvider.ordered(this.foldingModel.textModel);
      const selectedProviders = (_b2 = (_a6 = FoldingController2._foldingRangeSelector) === null || _a6 === void 0 ? void 0 : _a6.call(FoldingController2, foldingProviders, editorModel)) !== null && _b2 !== void 0 ? _b2 : foldingProviders;
      if (selectedProviders.length > 0) {
        this.rangeProvider = new SyntaxRangeProvider(editorModel, selectedProviders, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter);
      }
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    var _a6;
    (_a6 = this.hiddenRangeModel) === null || _a6 === void 0 ? void 0 : _a6.notifyChangeModelContent(e);
    this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    if (this.updateScheduler) {
      if (this.foldingRegionPromise) {
        this.foldingRegionPromise.cancel();
        this.foldingRegionPromise = null;
      }
      this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const foldingModel = this.foldingModel;
        if (!foldingModel) {
          return null;
        }
        const sw = new StopWatch(true);
        const provider = this.getRangeProvider(foldingModel.textModel);
        const foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token));
        return foldingRegionPromise.then((foldingRanges) => {
          if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
            let scrollState;
            if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
              const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);
              if (hasChanges) {
                scrollState = StableEditorScrollState.capture(this.editor);
                this._currentModelHasFoldedImports = hasChanges;
              }
            }
            const selections = this.editor.getSelections();
            const selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
            foldingModel.update(foldingRanges, selectionLineNumbers);
            scrollState === null || scrollState === void 0 ? void 0 : scrollState.restore(this.editor);
            const newValue = this.updateDebounceInfo.update(foldingModel.textModel, sw.elapsed());
            if (this.updateScheduler) {
              this.updateScheduler.defaultDelay = newValue;
            }
          }
          return foldingModel;
        });
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  onHiddenRangesChanges(hiddenRanges) {
    if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
      const selections = this.editor.getSelections();
      if (selections) {
        if (this.hiddenRangeModel.adjustSelections(selections)) {
          this.editor.setSelections(selections);
        }
      }
    }
    this.editor.setHiddenAreas(hiddenRanges, this);
  }
  onCursorPositionChanged() {
    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
      this.cursorChangedScheduler.schedule();
    }
  }
  revealCursor() {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel) {
      return;
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        const selections = this.editor.getSelections();
        if (selections && selections.length > 0) {
          const toToggle = [];
          for (const selection of selections) {
            const lineNumber = selection.selectionStartLineNumber;
            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
              toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
            }
          }
          if (toToggle.length) {
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal(selections[0].getPosition());
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    if (!this.hiddenRangeModel || !e.target || !e.target.range) {
      return;
    }
    if (!e.event.leftButton && !e.event.middleButton) {
      return;
    }
    const range = e.target.range;
    let iconClicked = false;
    switch (e.target.type) {
      case 4: {
        const data = e.target.detail;
        const offsetLeftInGutter = e.target.element.offsetLeft;
        const gutterOffsetX = data.offsetX - offsetLeftInGutter;
        if (gutterOffsetX < 5) {
          return;
        }
        iconClicked = true;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
          const data = e.target.detail;
          if (!data.isAfterLines) {
            break;
          }
        }
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const model = this.editor.getModel();
          if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
            break;
          }
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };
  }
  onEditorMouseUp(e) {
    const foldingModel = this.foldingModel;
    if (!foldingModel || !this.mouseDownInfo || !e.target) {
      return;
    }
    const lineNumber = this.mouseDownInfo.lineNumber;
    const iconClicked = this.mouseDownInfo.iconClicked;
    const range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (iconClicked) {
      if (e.target.type !== 4) {
        return;
      }
    } else {
      const model = this.editor.getModel();
      if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {
        return;
      }
    }
    const region = foldingModel.getRegionAtLine(lineNumber);
    if (region && region.startLineNumber === lineNumber) {
      const isCollapsed = region.isCollapsed;
      if (iconClicked || isCollapsed) {
        const surrounding = e.event.altKey;
        let toToggle = [];
        if (surrounding) {
          const filter = /* @__PURE__ */ __name((otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion), "filter");
          const toMaybeToggle = foldingModel.getRegionsInside(null, filter);
          for (const r of toMaybeToggle) {
            if (r.isCollapsed) {
              toToggle.push(r);
            }
          }
          if (toToggle.length === 0) {
            toToggle = toMaybeToggle;
          }
        } else {
          const recursive = e.event.middleButton || e.event.shiftKey;
          if (recursive) {
            for (const r of foldingModel.getRegionsInside(region)) {
              if (r.isCollapsed === isCollapsed) {
                toToggle.push(r);
              }
            }
          }
          if (isCollapsed || !recursive || toToggle.length === 0) {
            toToggle.push(region);
          }
        }
        foldingModel.toggleCollapseState(toToggle);
        this.reveal({ lineNumber, column: 1 });
      }
    }
  }
  reveal(position) {
    this.editor.revealPositionInCenterIfOutsideViewport(position, 0);
  }
}, "FoldingController");
FoldingController.ID = "editor.contrib.folding";
FoldingController = __decorate33([
  __param33(1, IContextKeyService),
  __param33(2, ILanguageConfigurationService),
  __param33(3, INotificationService),
  __param33(4, ILanguageFeatureDebounceService),
  __param33(5, ILanguageFeaturesService)
], FoldingController);
var FoldingAction = class extends EditorAction {
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const foldingController = FoldingController.get(editor2);
    if (!foldingController) {
      return;
    }
    const foldingModelPromise = foldingController.getFoldingModel();
    if (foldingModelPromise) {
      this.reportTelemetry(accessor, editor2);
      return foldingModelPromise.then((foldingModel) => {
        if (foldingModel) {
          this.invoke(foldingController, foldingModel, editor2, args, languageConfigurationService);
          const selection = editor2.getSelection();
          if (selection) {
            foldingController.reveal(selection.getStartPosition());
          }
        }
      });
    }
  }
  getSelectedLines(editor2) {
    const selections = editor2.getSelections();
    return selections ? selections.map((s) => s.startLineNumber) : [];
  }
  getLineNumbers(args, editor2) {
    if (args && args.selectionLines) {
      return args.selectionLines.map((l) => l + 1);
    }
    return this.getSelectedLines(editor2);
  }
  run(_accessor, _editor) {
  }
};
__name(FoldingAction, "FoldingAction");
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!Array.isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
__name(foldingArgumentsConstraint, "foldingArgumentsConstraint");
var UnfoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfold",
      label: localize("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
        },
        weight: 100
      },
      description: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number",
                  "default": 1
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"],
                  "default": "down"
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const levels = args && args.levels || 1;
    const lineNumbers = this.getLineNumbers(args, editor2);
    if (args && args.direction === "up") {
      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
    } else {
      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
    }
  }
};
__name(UnfoldAction, "UnfoldAction");
var UnFoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 89),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, _args) {
    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor2));
  }
};
__name(UnFoldRecursivelyAction, "UnFoldRecursivelyAction");
var FoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.fold",
      label: localize("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 87,
        mac: {
          primary: 2048 | 512 | 87
        },
        weight: 100
      },
      description: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number"
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"]
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    const lineNumbers = this.getLineNumbers(args, editor2);
    const levels = args && args.levels;
    const direction = args && args.direction;
    if (typeof levels !== "number" && typeof direction !== "string") {
      setCollapseStateUp(foldingModel, true, lineNumbers);
    } else {
      if (direction === "up") {
        setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
      } else {
        setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
      }
    }
  }
};
__name(FoldAction, "FoldAction");
var ToggleFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: localize("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 42),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    toggleCollapseState(foldingModel, 1, selectedLines);
  }
};
__name(ToggleFoldAction, "ToggleFoldAction");
var FoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: localize("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 87),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
  }
};
__name(FoldRecursivelyAction, "FoldRecursivelyAction");
var FoldAllBlockCommentsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 85),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const comments = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).comments;
      if (comments && comments.blockCommentStartToken) {
        const regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
__name(FoldAllBlockCommentsAction, "FoldAllBlockCommentsAction");
var FoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 29),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
__name(FoldAllRegionsAction, "FoldAllRegionsAction");
var UnfoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 30),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args, languageConfigurationService) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = languageConfigurationService.getLanguageConfiguration(editorModel.getLanguageId()).foldingRules;
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        const regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, false);
      }
    }
  }
};
__name(UnfoldAllRegionsAction, "UnfoldAllRegionsAction");
var FoldAllRegionsExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: localize("foldAllExcept.label", "Fold All Regions Except Selected"),
      alias: "Fold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 83),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, true, selectedLines);
  }
};
__name(FoldAllRegionsExceptAction, "FoldAllRegionsExceptAction");
var UnfoldAllRegionsExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: localize("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
      alias: "Unfold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 81),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, false, selectedLines);
  }
};
__name(UnfoldAllRegionsExceptAction, "UnfoldAllRegionsExceptAction");
var FoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAll",
      label: localize("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 21),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, true);
  }
};
__name(FoldAllAction, "FoldAllAction");
var UnfoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: localize("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 40),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, false);
  }
};
__name(UnfoldAllAction, "UnfoldAllAction");
var FoldLevelAction = class extends FoldingAction {
  getFoldingLevel() {
    return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
  }
  invoke(_foldingController, foldingModel, editor2) {
    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor2));
  }
};
__name(FoldLevelAction, "FoldLevelAction");
FoldLevelAction.ID_PREFIX = "editor.foldLevel";
FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
var GotoParentFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: localize("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
__name(GotoParentFoldAction, "GotoParentFoldAction");
var GotoPreviousFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: localize("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
__name(GotoPreviousFoldAction, "GotoPreviousFoldAction");
var GotoNextFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: localize("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    const selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      const startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
__name(GotoNextFoldAction, "GotoNextFoldAction");
var FoldRangeFromSelectionAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: localize("createManualFoldRange.label", "Create Manual Folding Range from Selection"),
      alias: "Create Manual Folding Range from Selection",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 82),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    var _a6;
    const collapseRanges = [];
    const selections = editor2.getSelections();
    if (selections) {
      for (const selection of selections) {
        let endLineNumber = selection.endLineNumber;
        if (selection.endColumn === 1) {
          --endLineNumber;
        }
        if (endLineNumber > selection.startLineNumber) {
          collapseRanges.push({
            startLineNumber: selection.startLineNumber,
            endLineNumber,
            type: void 0,
            isCollapsed: true,
            source: 1
          });
          editor2.setSelection({
            startLineNumber: selection.startLineNumber,
            startColumn: 1,
            endLineNumber: selection.startLineNumber,
            endColumn: 1
          });
        }
      }
      if (collapseRanges.length > 0) {
        collapseRanges.sort((a, b) => {
          return a.startLineNumber - b.startLineNumber;
        });
        const newRanges = FoldingRegions.sanitizeAndMerge(foldingModel.regions, collapseRanges, (_a6 = editor2.getModel()) === null || _a6 === void 0 ? void 0 : _a6.getLineCount());
        foldingModel.updatePost(FoldingRegions.fromFoldRanges(newRanges));
      }
    }
  }
};
__name(FoldRangeFromSelectionAction, "FoldRangeFromSelectionAction");
var RemoveFoldRangeFromSelectionAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: localize("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
      alias: "Remove Manual Folding Ranges",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 84),
        weight: 100
      }
    });
  }
  invoke(foldingController, foldingModel, editor2) {
    const selections = editor2.getSelections();
    if (selections) {
      const ranges = [];
      for (const selection of selections) {
        const { startLineNumber, endLineNumber } = selection;
        ranges.push(endLineNumber >= startLineNumber ? { startLineNumber, endLineNumber } : { endLineNumber, startLineNumber });
      }
      foldingModel.removeManualRanges(ranges);
      foldingController.triggerFoldingModelChanged();
    }
  }
};
__name(RemoveFoldRangeFromSelectionAction, "RemoveFoldRangeFromSelectionAction");
registerEditorContribution(FoldingController.ID, FoldingController, 0);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(FoldAllRegionsExceptAction);
registerEditorAction(UnfoldAllRegionsExceptAction);
registerEditorAction(ToggleFoldAction);
registerEditorAction(GotoParentFoldAction);
registerEditorAction(GotoPreviousFoldAction);
registerEditorAction(GotoNextFoldAction);
registerEditorAction(FoldRangeFromSelectionAction);
registerEditorAction(RemoveFoldRangeFromSelectionAction);
for (let i = 1; i <= 7; i++) {
  registerInstantiatedEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(i),
    label: localize("foldLevelAction.label", "Fold Level {0}", i),
    alias: `Fold Level ${i}`,
    precondition: CONTEXT_FOLDING_ENABLED,
    kbOpts: {
      kbExpr: EditorContextKeys.editorTextFocus,
      primary: KeyChord(2048 | 41, 2048 | 21 + i),
      weight: 100
    }
  }));
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/browser/fontZoom.js
init_define_process();
init_editorExtensions();
init_nls();
var EditorFontZoomIn = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
      alias: "Editor Font Zoom In",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
};
__name(EditorFontZoomIn, "EditorFontZoomIn");
var EditorFontZoomOut = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
      alias: "Editor Font Zoom Out",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
};
__name(EditorFontZoomOut, "EditorFontZoomOut");
var EditorFontZoomReset = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
      alias: "Editor Font Zoom Reset",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(0);
  }
};
__name(EditorFontZoomReset, "EditorFontZoomReset");
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

// ../../node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_formatActions = __toESM(require_formatActions());
var import_documentSymbols = __toESM(require_documentSymbols());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.contribution.js
init_define_process();
init_editorExtensions();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/consts.js
init_define_process();
var inlineSuggestCommitId = "editor.action.inlineSuggest.commit";

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextController.js
init_define_process();
init_event();
init_lifecycle();
init_strings();
init_editorExtensions();
init_cursorColumns();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextModel.js
init_define_process();
init_event();
init_lifecycle();
init_position();
init_languages();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js
init_define_process();
init_assert();
init_async();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_editOperation();
init_position();
init_range();
init_languages();
init_languageConfigurationRegistry();

// ../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js
init_define_process();
init_brackets();
init_length();
init_parser();
init_smallImmutableSet();
init_tokenizer();
function fixBracketsInLine(tokens, languageConfigurationService) {
  const denseKeyProvider = new DenseKeyProvider();
  const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));
  const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);
  const node = parseDocument(tokenizer, [], void 0, true);
  let str = "";
  const line = tokens.getLineContent();
  function processNode(node2, offset) {
    if (node2.kind === 2) {
      processNode(node2.openingBracket, offset);
      offset = lengthAdd(offset, node2.openingBracket.length);
      if (node2.child) {
        processNode(node2.child, offset);
        offset = lengthAdd(offset, node2.child.length);
      }
      if (node2.closingBracket) {
        processNode(node2.closingBracket, offset);
        offset = lengthAdd(offset, node2.closingBracket.length);
      } else {
        const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node2.openingBracket.languageId);
        const closingTokenText = singleLangBracketTokens.findClosingTokenText(node2.openingBracket.bracketIds);
        str += closingTokenText;
      }
    } else if (node2.kind === 3) {
    } else if (node2.kind === 0 || node2.kind === 1) {
      str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node2.length)));
    } else if (node2.kind === 4) {
      for (const child of node2.children) {
        processNode(child, offset);
        offset = lengthAdd(offset, child.length);
      }
    }
  }
  __name(processNode, "processNode");
  processNode(node, lengthZero);
  return str;
}
__name(fixBracketsInLine, "fixBracketsInLine");
var StaticTokenizerSource = class {
  constructor(lines) {
    this.lines = lines;
    this.tokenization = {
      getLineTokens: (lineNumber) => {
        return this.lines[lineNumber - 1];
      }
    };
  }
  getLineCount() {
    return this.lines.length;
  }
  getLineLength(lineNumber) {
    return this.lines[lineNumber - 1].getLineContent().length;
  }
};
__name(StaticTokenizerSource, "StaticTokenizerSource");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js
init_languageFeatureDebounce();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.js
init_define_process();
init_event();
init_lifecycle();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/utils.js
init_define_process();
init_range();
function createDisposableRef(object, disposable) {
  return {
    object,
    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
  };
}
__name(createDisposableRef, "createDisposableRef");
function applyEdits(text, edits) {
  const transformer = new PositionOffsetTransformer(text);
  const offsetEdits = edits.map((e) => {
    const range = Range.lift(e.range);
    return {
      startOffset: transformer.getOffset(range.getStartPosition()),
      endOffset: transformer.getOffset(range.getEndPosition()),
      text: e.text
    };
  });
  offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
  for (const edit of offsetEdits) {
    text = text.substring(0, edit.startOffset) + edit.text + text.substring(edit.endOffset);
  }
  return text;
}
__name(applyEdits, "applyEdits");
var PositionOffsetTransformer = class {
  constructor(text) {
    this.lineStartOffsetByLineIdx = [];
    this.lineStartOffsetByLineIdx.push(0);
    for (let i = 0; i < text.length; i++) {
      if (text.charAt(i) === "\n") {
        this.lineStartOffsetByLineIdx.push(i + 1);
      }
    }
  }
  getOffset(position) {
    return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
  }
};
__name(PositionOffsetTransformer, "PositionOffsetTransformer");
var array = [];
function getReadonlyEmptyArray() {
  return array;
}
__name(getReadonlyEmptyArray, "getReadonlyEmptyArray");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.js
var GhostText = class {
  constructor(lineNumber, parts, additionalReservedLineCount = 0) {
    this.lineNumber = lineNumber;
    this.parts = parts;
    this.additionalReservedLineCount = additionalReservedLineCount;
  }
  renderForScreenReader(lineText) {
    if (this.parts.length === 0) {
      return "";
    }
    const lastPart = this.parts[this.parts.length - 1];
    const cappedLineText = lineText.substr(0, lastPart.column - 1);
    const text = applyEdits(cappedLineText, this.parts.map((p) => ({
      range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },
      text: p.lines.join("\n")
    })));
    return text.substring(this.parts[0].column - 1);
  }
  isEmpty() {
    return this.parts.every((p) => p.lines.length === 0);
  }
};
__name(GhostText, "GhostText");
var GhostTextPart = class {
  constructor(column, lines, preview) {
    this.column = column;
    this.lines = lines;
    this.preview = preview;
  }
};
__name(GhostTextPart, "GhostTextPart");
var GhostTextReplacement = class {
  constructor(lineNumber, columnStart, length, newLines, additionalReservedLineCount = 0) {
    this.lineNumber = lineNumber;
    this.columnStart = columnStart;
    this.length = length;
    this.newLines = newLines;
    this.additionalReservedLineCount = additionalReservedLineCount;
    this.parts = [
      new GhostTextPart(this.columnStart + this.length, this.newLines, false)
    ];
  }
  renderForScreenReader(_lineText) {
    return this.newLines.join("\n");
  }
};
__name(GhostTextReplacement, "GhostTextReplacement");
var BaseGhostTextWidgetModel = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._expanded = void 0;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(110) && this._expanded === void 0) {
        this.onDidChangeEmitter.fire();
      }
    }));
  }
  setExpanded(expanded) {
    this._expanded = true;
    this.onDidChangeEmitter.fire();
  }
};
__name(BaseGhostTextWidgetModel, "BaseGhostTextWidgetModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionToGhostText.js
init_define_process();
init_strings();
init_range();
function minimizeInlineCompletion(model, inlineCompletion) {
  if (!inlineCompletion) {
    return inlineCompletion;
  }
  const valueToReplace = model.getValueInRange(inlineCompletion.range);
  const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.insertText);
  const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;
  const start = model.getPositionAt(startOffset);
  const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);
  const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.insertText);
  const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));
  return {
    range: Range.fromPositions(start, end),
    insertText: inlineCompletion.insertText.substr(commonPrefixLen, inlineCompletion.insertText.length - commonPrefixLen - commonSuffixLen),
    snippetInfo: inlineCompletion.snippetInfo,
    filterText: inlineCompletion.filterText,
    additionalTextEdits: inlineCompletion.additionalTextEdits
  };
}
__name(minimizeInlineCompletion, "minimizeInlineCompletion");
function normalizedInlineCompletionsEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.range.equalsRange(b.range) && a.insertText === b.insertText && a.command === b.command;
}
__name(normalizedInlineCompletionsEquals, "normalizedInlineCompletionsEquals");
function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {
  if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {
    return void 0;
  }
  const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);
  const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
  const suggestionTouchesIndentation = inlineCompletion.range.startColumn - 1 <= sourceIndentationLength;
  if (suggestionTouchesIndentation) {
    const suggestionAddedIndentationLength = getLeadingWhitespace(inlineCompletion.insertText).length;
    const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);
    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition());
    const suggestionWithoutIndentationChange = inlineCompletion.insertText.startsWith(replacedIndentation) ? inlineCompletion.insertText.substring(replacedIndentation.length) : inlineCompletion.insertText.substring(suggestionAddedIndentationLength);
    inlineCompletion = {
      range: rangeThatDoesNotReplaceIndentation,
      insertText: suggestionWithoutIndentationChange,
      command: inlineCompletion.command,
      snippetInfo: void 0,
      filterText: inlineCompletion.filterText,
      additionalTextEdits: inlineCompletion.additionalTextEdits
    };
  }
  const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);
  const changes = cachingDiff(valueToBeReplaced, inlineCompletion.insertText);
  if (!changes) {
    return void 0;
  }
  const lineNumber = inlineCompletion.range.startLineNumber;
  const parts = new Array();
  if (mode === "prefix") {
    const filteredChanges = changes.filter((c) => c.originalLength === 0);
    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {
      return void 0;
    }
  }
  const previewStartInCompletionText = inlineCompletion.insertText.length - previewSuffixLength;
  for (const c of changes) {
    const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;
    if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {
      return void 0;
    }
    if (c.originalLength > 0) {
      return void 0;
    }
    if (c.modifiedLength === 0) {
      continue;
    }
    const modifiedEnd = c.modifiedStart + c.modifiedLength;
    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
    const nonPreviewText = inlineCompletion.insertText.substring(c.modifiedStart, nonPreviewTextEnd);
    const italicText = inlineCompletion.insertText.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
    if (nonPreviewText.length > 0) {
      const lines = splitLines(nonPreviewText);
      parts.push(new GhostTextPart(insertColumn, lines, false));
    }
    if (italicText.length > 0) {
      const lines = splitLines(italicText);
      parts.push(new GhostTextPart(insertColumn, lines, true));
    }
  }
  return new GhostText(lineNumber, parts, 0);
}
__name(inlineCompletionToGhostText, "inlineCompletionToGhostText");
var lastRequest = void 0;
function cachingDiff(originalValue, newValue) {
  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {
    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
  } else {
    let changes = smartDiff(originalValue, newValue, true);
    if (changes) {
      const deletedChars = deletedCharacters(changes);
      if (deletedChars > 0) {
        const newChanges = smartDiff(originalValue, newValue, false);
        if (newChanges && deletedCharacters(newChanges) < deletedChars) {
          changes = newChanges;
        }
      }
    }
    lastRequest = {
      originalValue,
      newValue,
      changes
    };
    return changes;
  }
}
__name(cachingDiff, "cachingDiff");
function deletedCharacters(changes) {
  let sum2 = 0;
  for (const c of changes) {
    sum2 += Math.max(c.originalLength - c.modifiedLength, 0);
  }
  return sum2;
}
__name(deletedCharacters, "deletedCharacters");
function smartDiff(originalValue, newValue, smartBracketMatching) {
  if (originalValue.length > 5e3 || newValue.length > 5e3) {
    return void 0;
  }
  function getMaxCharCode(val) {
    let maxCharCode2 = 0;
    for (let i = 0, len = val.length; i < len; i++) {
      const charCode = val.charCodeAt(i);
      if (charCode > maxCharCode2) {
        maxCharCode2 = charCode;
      }
    }
    return maxCharCode2;
  }
  __name(getMaxCharCode, "getMaxCharCode");
  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
  function getUniqueCharCode(id) {
    if (id < 0) {
      throw new Error("unexpected");
    }
    return maxCharCode + id + 1;
  }
  __name(getUniqueCharCode, "getUniqueCharCode");
  function getElements(source) {
    let level = 0;
    let group = 0;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      if (smartBracketMatching && source[i] === "(") {
        const id = group * 100 + level;
        characters[i] = getUniqueCharCode(2 * id);
        level++;
      } else if (smartBracketMatching && source[i] === ")") {
        level = Math.max(level - 1, 0);
        const id = group * 100 + level;
        characters[i] = getUniqueCharCode(2 * id + 1);
        if (level === 0) {
          group++;
        }
      } else {
        characters[i] = source.charCodeAt(i);
      }
    }
    return characters;
  }
  __name(getElements, "getElements");
  const elements1 = getElements(originalValue);
  const elements2 = getElements(newValue);
  return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}
__name(smartDiff, "smartDiff");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js
init_define_process();
init_lifecycle();
init_types();
init_editorExtensions();
init_position();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_languageFeatures();
init_nls();
init_contextkey();
init_log();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js
init_define_process();
init_arrays();
init_lifecycle();
init_strings();
init_editOperation();
init_range();
init_selection();
init_languageConfigurationRegistry();
init_textModel();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetVariables.js
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/base/common/labels.js
init_define_process();
init_extpath();
init_platform();
function normalizeDriveLetter(path, isWindowsOS = isWindows) {
  if (hasDriveLetter(path, isWindowsOS)) {
    return path.charAt(0).toUpperCase() + path.slice(1);
  }
  return path;
}
__name(normalizeDriveLetter, "normalizeDriveLetter");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetVariables.js
init_path();
init_resources();
init_strings();
init_languageConfigurationRegistry();
init_nls();
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "CURSOR_INDEX": true,
  "CURSOR_NUMBER": true,
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});
var CompositeSnippetVariableResolver = class {
  constructor(_delegates) {
    this._delegates = _delegates;
  }
  resolve(variable) {
    for (const delegate of this._delegates) {
      const value = delegate.resolve(variable);
      if (value !== void 0) {
        return value;
      }
    }
    return void 0;
  }
};
__name(CompositeSnippetVariableResolver, "CompositeSnippetVariableResolver");
var SelectionBasedVariableResolver = class {
  constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
    this._model = _model;
    this._selection = _selection;
    this._selectionIdx = _selectionIdx;
    this._overtypingCapturer = _overtypingCapturer;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
      let value = this._model.getValueInRange(this._selection) || void 0;
      let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!value && this._overtypingCapturer) {
        const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        if (info) {
          value = info.value;
          isMultiline = info.multiline;
        }
      }
      if (value && isMultiline && variable.snippet) {
        const line = this._model.getLineContent(this._selection.startLineNumber);
        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
        let varLeadingWhitespace = lineLeadingWhitespace;
        variable.snippet.walk((marker) => {
          if (marker === variable) {
            return false;
          }
          if (marker instanceof Text) {
            varLeadingWhitespace = getLeadingWhitespace(splitLines(marker.value).pop());
          }
          return true;
        });
        const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
        value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
      }
      return value;
    } else if (name === "TM_CURRENT_LINE") {
      return this._model.getLineContent(this._selection.positionLineNumber);
    } else if (name === "TM_CURRENT_WORD") {
      const info = this._model.getWordAtPosition({
        lineNumber: this._selection.positionLineNumber,
        column: this._selection.positionColumn
      });
      return info && info.word || void 0;
    } else if (name === "TM_LINE_INDEX") {
      return String(this._selection.positionLineNumber - 1);
    } else if (name === "TM_LINE_NUMBER") {
      return String(this._selection.positionLineNumber);
    } else if (name === "CURSOR_INDEX") {
      return String(this._selectionIdx);
    } else if (name === "CURSOR_NUMBER") {
      return String(this._selectionIdx + 1);
    }
    return void 0;
  }
};
__name(SelectionBasedVariableResolver, "SelectionBasedVariableResolver");
var ModelBasedVariableResolver = class {
  constructor(_labelService, _model) {
    this._labelService = _labelService;
    this._model = _model;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "TM_FILENAME") {
      return basename(this._model.uri.fsPath);
    } else if (name === "TM_FILENAME_BASE") {
      const name2 = basename(this._model.uri.fsPath);
      const idx = name2.lastIndexOf(".");
      if (idx <= 0) {
        return name2;
      } else {
        return name2.slice(0, idx);
      }
    } else if (name === "TM_DIRECTORY") {
      if (dirname(this._model.uri.fsPath) === ".") {
        return "";
      }
      return this._labelService.getUriLabel(dirname2(this._model.uri));
    } else if (name === "TM_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri);
    } else if (name === "RELATIVE_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri, { relative: true, noPrefix: true });
    }
    return void 0;
  }
};
__name(ModelBasedVariableResolver, "ModelBasedVariableResolver");
var ClipboardBasedVariableResolver = class {
  constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
    this._readClipboardText = _readClipboardText;
    this._selectionIdx = _selectionIdx;
    this._selectionCount = _selectionCount;
    this._spread = _spread;
  }
  resolve(variable) {
    if (variable.name !== "CLIPBOARD") {
      return void 0;
    }
    const clipboardText = this._readClipboardText();
    if (!clipboardText) {
      return void 0;
    }
    if (this._spread) {
      const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
      if (lines.length === this._selectionCount) {
        return lines[this._selectionIdx];
      }
    }
    return clipboardText;
  }
};
__name(ClipboardBasedVariableResolver, "ClipboardBasedVariableResolver");
var CommentBasedVariableResolver = /* @__PURE__ */ __name(class CommentBasedVariableResolver2 {
  constructor(_model, _selection, _languageConfigurationService) {
    this._model = _model;
    this._selection = _selection;
    this._languageConfigurationService = _languageConfigurationService;
  }
  resolve(variable) {
    const { name } = variable;
    const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
    const config = this._languageConfigurationService.getLanguageConfiguration(langId).comments;
    if (!config) {
      return void 0;
    }
    if (name === "LINE_COMMENT") {
      return config.lineCommentToken || void 0;
    } else if (name === "BLOCK_COMMENT_START") {
      return config.blockCommentStartToken || void 0;
    } else if (name === "BLOCK_COMMENT_END") {
      return config.blockCommentEndToken || void 0;
    }
    return void 0;
  }
}, "CommentBasedVariableResolver");
CommentBasedVariableResolver = __decorate35([
  __param35(2, ILanguageConfigurationService)
], CommentBasedVariableResolver);
var TimeBasedVariableResolver = class {
  constructor() {
    this._date = new Date();
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "CURRENT_YEAR") {
      return String(this._date.getFullYear());
    } else if (name === "CURRENT_YEAR_SHORT") {
      return String(this._date.getFullYear()).slice(-2);
    } else if (name === "CURRENT_MONTH") {
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    } else if (name === "CURRENT_DATE") {
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_HOUR") {
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_MINUTE") {
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_SECOND") {
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_DAY_NAME") {
      return TimeBasedVariableResolver.dayNames[this._date.getDay()];
    } else if (name === "CURRENT_DAY_NAME_SHORT") {
      return TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];
    } else if (name === "CURRENT_MONTH_NAME") {
      return TimeBasedVariableResolver.monthNames[this._date.getMonth()];
    } else if (name === "CURRENT_MONTH_NAME_SHORT") {
      return TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];
    } else if (name === "CURRENT_SECONDS_UNIX") {
      return String(Math.floor(this._date.getTime() / 1e3));
    }
    return void 0;
  }
};
__name(TimeBasedVariableResolver, "TimeBasedVariableResolver");
TimeBasedVariableResolver.dayNames = [localize("Sunday", "Sunday"), localize("Monday", "Monday"), localize("Tuesday", "Tuesday"), localize("Wednesday", "Wednesday"), localize("Thursday", "Thursday"), localize("Friday", "Friday"), localize("Saturday", "Saturday")];
TimeBasedVariableResolver.dayNamesShort = [localize("SundayShort", "Sun"), localize("MondayShort", "Mon"), localize("TuesdayShort", "Tue"), localize("WednesdayShort", "Wed"), localize("ThursdayShort", "Thu"), localize("FridayShort", "Fri"), localize("SaturdayShort", "Sat")];
TimeBasedVariableResolver.monthNames = [localize("January", "January"), localize("February", "February"), localize("March", "March"), localize("April", "April"), localize("May", "May"), localize("June", "June"), localize("July", "July"), localize("August", "August"), localize("September", "September"), localize("October", "October"), localize("November", "November"), localize("December", "December")];
TimeBasedVariableResolver.monthNamesShort = [localize("JanuaryShort", "Jan"), localize("FebruaryShort", "Feb"), localize("MarchShort", "Mar"), localize("AprilShort", "Apr"), localize("MayShort", "May"), localize("JuneShort", "Jun"), localize("JulyShort", "Jul"), localize("AugustShort", "Aug"), localize("SeptemberShort", "Sep"), localize("OctoberShort", "Oct"), localize("NovemberShort", "Nov"), localize("DecemberShort", "Dec")];
var WorkspaceBasedVariableResolver = class {
  constructor(_workspaceService) {
    this._workspaceService = _workspaceService;
  }
  resolve(variable) {
    if (!this._workspaceService) {
      return void 0;
    }
    const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
    if (!workspaceIdentifier) {
      return void 0;
    }
    if (variable.name === "WORKSPACE_NAME") {
      return this._resolveWorkspaceName(workspaceIdentifier);
    } else if (variable.name === "WORKSPACE_FOLDER") {
      return this._resoveWorkspacePath(workspaceIdentifier);
    }
    return void 0;
  }
  _resolveWorkspaceName(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return basename(workspaceIdentifier.uri.path);
    }
    let filename = basename(workspaceIdentifier.configPath.path);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    return filename;
  }
  _resoveWorkspacePath(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);
    }
    const filename = basename(workspaceIdentifier.configPath.path);
    let folderpath = workspaceIdentifier.configPath.fsPath;
    if (folderpath.endsWith(filename)) {
      folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
    }
    return folderpath ? normalizeDriveLetter(folderpath) : "/";
  }
};
__name(WorkspaceBasedVariableResolver, "WorkspaceBasedVariableResolver");
var RandomBasedVariableResolver = class {
  resolve(variable) {
    const { name } = variable;
    if (name === "RANDOM") {
      return Math.random().toString().slice(-6);
    } else if (name === "RANDOM_HEX") {
      return Math.random().toString(16).slice(-6);
    } else if (name === "UUID") {
      return generateUuid();
    }
    return void 0;
  }
};
__name(RandomBasedVariableResolver, "RandomBasedVariableResolver");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetSession.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var OneSnippet = class {
  constructor(_editor, _snippet, _snippetLineLeadingWhitespace) {
    this._editor = _editor;
    this._snippet = _snippet;
    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;
    this._offset = -1;
    this._nestingLevel = 1;
    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);
    this._placeholderGroupsIdx = -1;
  }
  initialize(textChange) {
    this._offset = textChange.newPosition;
  }
  dispose() {
    if (this._placeholderDecorations) {
      this._editor.removeDecorations([...this._placeholderDecorations.values()]);
    }
    this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._offset === -1) {
      throw new Error(`Snippet not initialized!`);
    }
    if (this._placeholderDecorations) {
      return;
    }
    this._placeholderDecorations = /* @__PURE__ */ new Map();
    const model = this._editor.getModel();
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._snippet.placeholders) {
        const placeholderOffset = this._snippet.offset(placeholder);
        const placeholderLen = this._snippet.fullLen(placeholder);
        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;
        const handle = accessor.addDecoration(range, options);
        this._placeholderDecorations.set(placeholder, handle);
      }
    });
  }
  move(fwd) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this._initDecorations();
    if (this._placeholderGroupsIdx >= 0) {
      const operations = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        if (placeholder.transform) {
          const id = this._placeholderDecorations.get(placeholder);
          const range = this._editor.getModel().getDecorationRange(id);
          const currentValue = this._editor.getModel().getValueInRange(range);
          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\r\n|\r|\n/);
          for (let i = 1; i < transformedValueLines.length; i++) {
            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);
          }
          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));
        }
      }
      if (operations.length > 0) {
        this._editor.executeEdits("snippet.placeholderTransform", operations);
      }
    }
    let couldSkipThisPlaceholder = false;
    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
      this._placeholderGroupsIdx += 1;
      couldSkipThisPlaceholder = true;
    } else if (fwd === false && this._placeholderGroupsIdx > 0) {
      this._placeholderGroupsIdx -= 1;
      couldSkipThisPlaceholder = true;
    } else {
    }
    const newSelections = this._editor.getModel().changeDecorations((accessor) => {
      const activePlaceholders = /* @__PURE__ */ new Set();
      const selections = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));
        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
        activePlaceholders.add(placeholder);
        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
          const id2 = this._placeholderDecorations.get(enclosingPlaceholder);
          accessor.changeDecorationOptions(id2, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
          activePlaceholders.add(enclosingPlaceholder);
        }
      }
      for (const [placeholder, id] of this._placeholderDecorations) {
        if (!activePlaceholders.has(placeholder)) {
          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);
        }
      }
      return selections;
    });
    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
  }
  _hasPlaceholderBeenCollapsed(placeholder) {
    let marker = placeholder;
    while (marker) {
      if (marker instanceof Placeholder) {
        const id = this._placeholderDecorations.get(marker);
        const range = this._editor.getModel().getDecorationRange(id);
        if (range.isEmpty() && marker.toString().length > 0) {
          return true;
        }
      }
      marker = marker.parent;
    }
    return false;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  get isTrivialSnippet() {
    if (this._snippet.placeholders.length === 0) {
      return true;
    }
    if (this._snippet.placeholders.length === 1) {
      const [placeholder] = this._snippet.placeholders;
      if (placeholder.isFinalTabstop) {
        if (this._snippet.rightMostDescendant === placeholder) {
          return true;
        }
      }
    }
    return false;
  }
  computePossibleSelections() {
    const result = /* @__PURE__ */ new Map();
    for (const placeholdersWithEqualIndex of this._placeholderGroups) {
      let ranges;
      for (const placeholder of placeholdersWithEqualIndex) {
        if (placeholder.isFinalTabstop) {
          break;
        }
        if (!ranges) {
          ranges = [];
          result.set(placeholder.index, ranges);
        }
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        if (!range) {
          result.delete(placeholder.index);
          break;
        }
        ranges.push(range);
      }
    }
    return result;
  }
  get activeChoice() {
    if (!this._placeholderDecorations) {
      return void 0;
    }
    const placeholder = this._placeholderGroups[this._placeholderGroupsIdx][0];
    if (!(placeholder === null || placeholder === void 0 ? void 0 : placeholder.choice)) {
      return void 0;
    }
    const id = this._placeholderDecorations.get(placeholder);
    if (!id) {
      return void 0;
    }
    const range = this._editor.getModel().getDecorationRange(id);
    if (!range) {
      return void 0;
    }
    return { range, choice: placeholder.choice };
  }
  get hasChoice() {
    let result = false;
    this._snippet.walk((marker) => {
      result = marker instanceof Choice;
      return !result;
    });
    return result;
  }
  merge(others) {
    const model = this._editor.getModel();
    this._nestingLevel *= 10;
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const nested = others.shift();
        console.assert(nested._offset !== -1);
        console.assert(!nested._placeholderDecorations);
        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {
          if (nestedPlaceholder.isFinalTabstop) {
            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
          } else {
            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
          }
        }
        this._snippet.replace(placeholder, nested._snippet.children);
        const id = this._placeholderDecorations.get(placeholder);
        accessor.removeDecoration(id);
        this._placeholderDecorations.delete(placeholder);
        for (const placeholder2 of nested._snippet.placeholders) {
          const placeholderOffset = nested._snippet.offset(placeholder2);
          const placeholderLen = nested._snippet.fullLen(placeholder2);
          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);
          this._placeholderDecorations.set(placeholder2, handle);
        }
      }
      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
    });
  }
};
__name(OneSnippet, "OneSnippet");
OneSnippet._decor = {
  active: ModelDecorationOptions.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: ModelDecorationOptions.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
var _defaultOptions = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetSession = /* @__PURE__ */ __name(class SnippetSession2 {
  static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {
    const line = model.getLineContent(position.lineNumber);
    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
    let snippetTextString;
    snippet.walk((marker) => {
      if (!(marker instanceof Text) || marker.parent instanceof Choice) {
        return true;
      }
      const lines = marker.value.split(/\r\n|\r|\n/);
      if (adjustIndentation) {
        const offset = snippet.offset(marker);
        if (offset === 0) {
          lines[0] = model.normalizeIndentation(lines[0]);
        } else {
          snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();
          const prevChar = snippetTextString.charCodeAt(offset - 1);
          if (prevChar === 10 || prevChar === 13) {
            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
          }
        }
        for (let i = 1; i < lines.length; i++) {
          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);
        }
      }
      const newValue = lines.join(model.getEOL());
      if (newValue !== marker.value) {
        marker.parent.replace(marker, [new Text(newValue)]);
        snippetTextString = void 0;
      }
      return true;
    });
    return lineLeadingWhitespace;
  }
  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
    if (overwriteBefore !== 0 || overwriteAfter !== 0) {
      const { positionLineNumber, positionColumn } = selection;
      const positionColumnBefore = positionColumn - overwriteBefore;
      const positionColumnAfter = positionColumn + overwriteAfter;
      const range = model.validateRange({
        startLineNumber: positionLineNumber,
        startColumn: positionColumnBefore,
        endLineNumber: positionLineNumber,
        endColumn: positionColumnAfter
      });
      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());
    }
    return selection;
  }
  static createEditsAndSnippetsFromSelections(editor2, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
    const edits = [];
    const snippets = [];
    if (!editor2.hasModel()) {
      return { edits, snippets };
    }
    const model = editor2.getModel();
    const workspaceService = editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService));
    const modelBasedVariableResolver = editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model));
    const readClipboardText = /* @__PURE__ */ __name(() => clipboardText, "readClipboardText");
    const firstBeforeText = model.getValueInRange(SnippetSession2.adjustSelection(model, editor2.getSelection(), overwriteBefore, 0));
    const firstAfterText = model.getValueInRange(SnippetSession2.adjustSelection(model, editor2.getSelection(), 0, overwriteAfter));
    const firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor2.getSelection().positionLineNumber);
    const indexedSelections = editor2.getSelections().map((selection, idx) => ({ selection, idx })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    for (const { selection, idx } of indexedSelections) {
      let extensionBefore = SnippetSession2.adjustSelection(model, selection, overwriteBefore, 0);
      let extensionAfter = SnippetSession2.adjustSelection(model, selection, 0, overwriteAfter);
      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
        extensionBefore = selection;
      }
      if (firstAfterText !== model.getValueInRange(extensionAfter)) {
        extensionAfter = selection;
      }
      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
      const start = snippetSelection.getStartPosition();
      const snippetLineLeadingWhitespace = SnippetSession2.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);
      snippet.resolveVariables(new CompositeSnippetVariableResolver([
        modelBasedVariableResolver,
        new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor2.getOption(73) === "spread"),
        new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
        new CommentBasedVariableResolver(model, selection, languageConfigurationService),
        new TimeBasedVariableResolver(),
        new WorkspaceBasedVariableResolver(workspaceService),
        new RandomBasedVariableResolver()
      ]));
      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
      edits[idx].identifier = { major: idx, minor: 0 };
      edits[idx]._isTracked = true;
      snippets[idx] = new OneSnippet(editor2, snippet, snippetLineLeadingWhitespace);
    }
    return { edits, snippets };
  }
  static createEditsAndSnippetsFromEdits(editor2, snippetEdits, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer, languageConfigurationService) {
    if (!editor2.hasModel() || snippetEdits.length === 0) {
      return { edits: [], snippets: [] };
    }
    const edits = [];
    const model = editor2.getModel();
    const parser = new SnippetParser();
    const snippet = new TextmateSnippet();
    const resolver = new CompositeSnippetVariableResolver([
      editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model)),
      new ClipboardBasedVariableResolver(() => clipboardText, 0, editor2.getSelections().length, editor2.getOption(73) === "spread"),
      new SelectionBasedVariableResolver(model, editor2.getSelection(), 0, overtypingCapturer),
      new CommentBasedVariableResolver(model, editor2.getSelection(), languageConfigurationService),
      new TimeBasedVariableResolver(),
      new WorkspaceBasedVariableResolver(editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService))),
      new RandomBasedVariableResolver()
    ]);
    snippetEdits = snippetEdits.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
    let offset = 0;
    for (let i = 0; i < snippetEdits.length; i++) {
      const { range, template } = snippetEdits[i];
      if (i > 0) {
        const lastRange = snippetEdits[i - 1].range;
        const textRange = Range.fromPositions(lastRange.getEndPosition(), range.getStartPosition());
        const textNode = new Text(model.getValueInRange(textRange));
        snippet.appendChild(textNode);
        offset += textNode.value.length;
      }
      parser.parseFragment(template, snippet);
      snippet.resolveVariables(resolver);
      const snippetText = snippet.toString();
      const snippetFragmentText = snippetText.slice(offset);
      offset = snippetText.length;
      const edit = EditOperation.replace(range, snippetFragmentText);
      edit.identifier = { major: i, minor: 0 };
      edit._isTracked = true;
      edits.push(edit);
    }
    parser.ensureFinalTabstop(snippet, enforceFinalTabstop, true);
    return {
      edits,
      snippets: [new OneSnippet(editor2, snippet, "")]
    };
  }
  constructor(_editor, _template, _options = _defaultOptions, _languageConfigurationService) {
    this._editor = _editor;
    this._template = _template;
    this._options = _options;
    this._languageConfigurationService = _languageConfigurationService;
    this._templateMerges = [];
    this._snippets = [];
  }
  dispose() {
    dispose(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel()) {
      return;
    }
    const { edits, snippets } = typeof this._template === "string" ? SnippetSession2.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : SnippetSession2.createEditsAndSnippetsFromEdits(this._editor, this._template, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
    this._snippets = snippets;
    this._editor.executeEdits("snippet", edits, (_undoEdits) => {
      const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
      for (let idx = 0; idx < snippets.length; idx++) {
        snippets[idx].initialize(undoEdits[idx].textChange);
      }
      if (this._snippets[0].hasPlaceholder) {
        return this._move(true);
      } else {
        return undoEdits.map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
    this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(template, options = _defaultOptions) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
    const { edits, snippets } = SnippetSession2.createEditsAndSnippetsFromSelections(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer, this._languageConfigurationService);
    this._editor.executeEdits("snippet", edits, (_undoEdits) => {
      const undoEdits = _undoEdits.filter((edit) => !!edit.identifier);
      for (let idx = 0; idx < snippets.length; idx++) {
        snippets[idx].initialize(undoEdits[idx].textChange);
      }
      const isTrivialSnippet = snippets[0].isTrivialSnippet;
      if (!isTrivialSnippet) {
        for (const snippet of this._snippets) {
          snippet.merge(snippets);
        }
        console.assert(snippets.length === 0);
      }
      if (this._snippets[0].hasPlaceholder && !isTrivialSnippet) {
        return this._move(void 0);
      } else {
        return undoEdits.map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
  }
  next() {
    const newSelections = this._move(true);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  prev() {
    const newSelections = this._move(false);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  _move(fwd) {
    const selections = [];
    for (const snippet of this._snippets) {
      const oneSelection = snippet.move(fwd);
      selections.push(...oneSelection);
    }
    return selections;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get hasChoice() {
    return this._snippets[0].hasChoice;
  }
  get activeChoice() {
    return this._snippets[0].activeChoice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder) {
      return false;
    }
    const selections = this._editor.getSelections();
    if (selections.length < this._snippets.length) {
      return false;
    }
    const allPossibleSelections = /* @__PURE__ */ new Map();
    for (const snippet of this._snippets) {
      const possibleSelections = snippet.computePossibleSelections();
      if (allPossibleSelections.size === 0) {
        for (const [index, ranges] of possibleSelections) {
          ranges.sort(Range.compareRangesUsingStarts);
          for (const selection of selections) {
            if (ranges[0].containsRange(selection)) {
              allPossibleSelections.set(index, []);
              break;
            }
          }
        }
      }
      if (allPossibleSelections.size === 0) {
        return false;
      }
      allPossibleSelections.forEach((array2, index) => {
        array2.push(...possibleSelections.get(index));
      });
    }
    selections.sort(Range.compareRangesUsingStarts);
    for (const [index, ranges] of allPossibleSelections) {
      if (ranges.length !== selections.length) {
        allPossibleSelections.delete(index);
        continue;
      }
      ranges.sort(Range.compareRangesUsingStarts);
      for (let i = 0; i < ranges.length; i++) {
        if (!ranges[i].containsRange(selections[i])) {
          allPossibleSelections.delete(index);
          continue;
        }
      }
    }
    return allPossibleSelections.size > 0;
  }
}, "SnippetSession");
SnippetSession = __decorate36([
  __param36(3, ILanguageConfigurationService)
], SnippetSession);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _defaultOptions2 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: true,
  undoStopAfter: true,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetController2 = /* @__PURE__ */ __name(class SnippetController22 {
  static get(editor2) {
    return editor2.getContribution(SnippetController22.ID);
  }
  constructor(_editor, _logService, _languageFeaturesService, contextKeyService, _languageConfigurationService) {
    this._editor = _editor;
    this._logService = _logService;
    this._languageFeaturesService = _languageFeaturesService;
    this._languageConfigurationService = _languageConfigurationService;
    this._snippetListener = new DisposableStore();
    this._modelVersionId = -1;
    this._inSnippet = SnippetController22.InSnippetMode.bindTo(contextKeyService);
    this._hasNextTabstop = SnippetController22.HasNextTabstop.bindTo(contextKeyService);
    this._hasPrevTabstop = SnippetController22.HasPrevTabstop.bindTo(contextKeyService);
  }
  dispose() {
    var _a6;
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    (_a6 = this._session) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._snippetListener.dispose();
  }
  insert(template, opts) {
    try {
      this._doInsert(template, typeof opts === "undefined" ? _defaultOptions2 : Object.assign(Object.assign({}, _defaultOptions2), opts));
    } catch (e) {
      this.cancel();
      this._logService.error(e);
      this._logService.error("snippet_error");
      this._logService.error("insert_template=", template);
      this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(template, opts) {
    var _a6;
    if (!this._editor.hasModel()) {
      return;
    }
    this._snippetListener.clear();
    if (opts.undoStopBefore) {
      this._editor.getModel().pushStackElement();
    }
    if (this._session && typeof template !== "string") {
      this.cancel();
    }
    if (!this._session) {
      this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
      this._session = new SnippetSession(this._editor, template, opts, this._languageConfigurationService);
      this._session.insert();
    } else {
      assertType(typeof template === "string");
      this._session.merge(template, opts);
    }
    if (opts.undoStopAfter) {
      this._editor.getModel().pushStackElement();
    }
    if ((_a6 = this._session) === null || _a6 === void 0 ? void 0 : _a6.hasChoice) {
      this._choiceCompletionItemProvider = {
        provideCompletionItems: (model, position) => {
          if (!this._session || model !== this._editor.getModel() || !Position.equals(this._editor.getPosition(), position)) {
            return void 0;
          }
          const { activeChoice } = this._session;
          if (!activeChoice || activeChoice.choice.options.length === 0) {
            return void 0;
          }
          const word = model.getValueInRange(activeChoice.range);
          const isAnyOfOptions = Boolean(activeChoice.choice.options.find((o) => o.value === word));
          const suggestions = [];
          for (let i = 0; i < activeChoice.choice.options.length; i++) {
            const option = activeChoice.choice.options[i];
            suggestions.push({
              kind: 13,
              label: option.value,
              insertText: option.value,
              sortText: "a".repeat(i + 1),
              range: activeChoice.range,
              filterText: isAnyOfOptions ? `${word}_${option.value}` : void 0,
              command: { id: "jumpToNextSnippetPlaceholder", title: localize("next", "Go to next placeholder...") }
            });
          }
          return { suggestions };
        }
      };
      const registration = this._languageFeaturesService.completionProvider.register({
        language: this._editor.getModel().getLanguageId(),
        pattern: this._editor.getModel().uri.fsPath,
        scheme: this._editor.getModel().uri.scheme
      }, this._choiceCompletionItemProvider);
      this._snippetListener.add(registration);
    }
    this._updateState();
    this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
  }
  _updateState() {
    if (!this._session || !this._editor.hasModel()) {
      return;
    }
    if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
      return this.cancel();
    }
    if (!this._session.hasPlaceholder) {
      return this.cancel();
    }
    if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
      this._editor.getModel().pushStackElement();
      return this.cancel();
    }
    this._inSnippet.set(true);
    this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
    this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
    this._handleChoice();
  }
  _handleChoice() {
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { activeChoice } = this._session;
    if (!activeChoice || !this._choiceCompletionItemProvider) {
      this._currentChoice = void 0;
      return;
    }
    if (this._currentChoice !== activeChoice.choice) {
      this._currentChoice = activeChoice.choice;
      queueMicrotask(() => {
        showSimpleSuggestions(this._editor, this._choiceCompletionItemProvider);
      });
    }
  }
  finish() {
    while (this._inSnippet.get()) {
      this.next();
    }
  }
  cancel(resetSelection = false) {
    var _a6;
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    this._snippetListener.clear();
    this._currentChoice = void 0;
    (_a6 = this._session) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._session = void 0;
    this._modelVersionId = -1;
    if (resetSelection) {
      this._editor.setSelections([this._editor.getSelection()]);
    }
  }
  prev() {
    var _a6;
    (_a6 = this._session) === null || _a6 === void 0 ? void 0 : _a6.prev();
    this._updateState();
  }
  next() {
    var _a6;
    (_a6 = this._session) === null || _a6 === void 0 ? void 0 : _a6.next();
    this._updateState();
  }
  isInSnippet() {
    return Boolean(this._inSnippet.get());
  }
}, "SnippetController2");
SnippetController2.ID = "snippetController2";
SnippetController2.InSnippetMode = new RawContextKey("inSnippetMode", false, localize("inSnippetMode", "Whether the editor in current in snippet mode"));
SnippetController2.HasNextTabstop = new RawContextKey("hasNextTabstop", false, localize("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
SnippetController2.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false, localize("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
SnippetController2 = __decorate37([
  __param37(1, ILogService),
  __param37(2, ILanguageFeaturesService),
  __param37(3, IContextKeyService),
  __param37(4, ILanguageConfigurationService)
], SnippetController2);
registerEditorContribution(SnippetController2.ID, SnippetController2, 4);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
  id: "jumpToNextSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
  handler: (ctrl) => ctrl.next(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
  handler: (ctrl) => ctrl.prev(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 1024 | 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "leaveSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.cancel(true),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new CommandCtor({
  id: "acceptSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.finish()
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/inlineCompletionsModel.js
init_commands();
init_configuration();
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlineCompletionsModel = /* @__PURE__ */ __name(class InlineCompletionsModel2 extends Disposable {
  constructor(editor2, cache, commandService, languageConfigurationService, languageFeaturesService, debounceService, configurationService) {
    super();
    this.editor = editor2;
    this.cache = cache;
    this.commandService = commandService;
    this.languageConfigurationService = languageConfigurationService;
    this.languageFeaturesService = languageFeaturesService;
    this.debounceService = debounceService;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.completionSession = this._register(new MutableDisposable());
    this.active = false;
    this.disposed = false;
    this.debounceValue = this.debounceService.for(this.languageFeaturesService.inlineCompletionsProvider, "InlineCompletionsDebounce", { min: 50, max: 50 });
    this._register(commandService.onDidExecuteCommand((e) => {
      const commands = /* @__PURE__ */ new Set([
        CoreEditingCommands.Tab.id,
        CoreEditingCommands.DeleteLeft.id,
        CoreEditingCommands.DeleteRight.id,
        inlineSuggestCommitId,
        "acceptSelectedSuggestion"
      ]);
      if (commands.has(e.commandId) && editor2.hasTextFocus()) {
        this.handleUserInput();
      }
    }));
    this._register(this.editor.onDidType((e) => {
      this.handleUserInput();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || this.session && !this.session.isValid) {
        this.hide();
      }
    }));
    this._register(toDisposable(() => {
      this.disposed = true;
    }));
    this._register(this.editor.onDidBlurEditorWidget(() => {
      if (configurationService.getValue("editor.inlineSuggest.hideOnBlur")) {
        return;
      }
      this.hide();
    }));
  }
  handleUserInput() {
    if (this.session && !this.session.isValid) {
      this.hide();
    }
    setTimeout(() => {
      if (this.disposed) {
        return;
      }
      this.startSessionIfTriggered();
    }, 0);
  }
  get session() {
    return this.completionSession.value;
  }
  get ghostText() {
    var _a6;
    return (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.ghostText;
  }
  get minReservedLineCount() {
    return this.session ? this.session.minReservedLineCount : 0;
  }
  setExpanded(expanded) {
    var _a6;
    (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.setExpanded(expanded);
  }
  setActive(active) {
    var _a6;
    this.active = active;
    if (active) {
      (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.scheduleAutomaticUpdate();
    }
  }
  startSessionIfTriggered() {
    const suggestOptions = this.editor.getOption(57);
    if (!suggestOptions.enabled) {
      return;
    }
    if (this.session && this.session.isValid) {
      return;
    }
    this.trigger(InlineCompletionTriggerKind.Automatic);
  }
  trigger(triggerKind) {
    if (this.completionSession.value) {
      if (triggerKind === InlineCompletionTriggerKind.Explicit) {
        void this.completionSession.value.ensureUpdateWithExplicitContext();
      }
      return;
    }
    this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind, this.languageConfigurationService, this.languageFeaturesService.inlineCompletionsProvider, this.debounceValue);
    this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {
      this.onDidChangeEmitter.fire();
    }));
  }
  hide() {
    this.completionSession.clear();
    this.onDidChangeEmitter.fire();
  }
  commitCurrentSuggestion() {
    var _a6;
    (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.commitCurrentCompletion();
  }
  commitCurrentSuggestionPartially() {
    var _a6;
    (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.commitCurrentCompletionNextWord();
  }
  showNext() {
    var _a6;
    (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.showNextInlineCompletion();
  }
  showPrevious() {
    var _a6;
    (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.showPreviousInlineCompletion();
  }
  hasMultipleInlineCompletions() {
    var _a6;
    return __awaiter29(this, void 0, void 0, function* () {
      const result = yield (_a6 = this.session) === null || _a6 === void 0 ? void 0 : _a6.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
}, "InlineCompletionsModel");
InlineCompletionsModel = __decorate38([
  __param38(2, ICommandService),
  __param38(3, ILanguageConfigurationService),
  __param38(4, ILanguageFeaturesService),
  __param38(5, ILanguageFeatureDebounceService),
  __param38(6, IConfigurationService)
], InlineCompletionsModel);
var InlineCompletionsSession = class extends BaseGhostTextWidgetModel {
  constructor(editor2, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind, languageConfigurationService, registry, debounce) {
    super(editor2);
    this.triggerPosition = triggerPosition;
    this.shouldUpdate = shouldUpdate;
    this.commandService = commandService;
    this.cache = cache;
    this.initialTriggerKind = initialTriggerKind;
    this.languageConfigurationService = languageConfigurationService;
    this.registry = registry;
    this.debounce = debounce;
    this.minReservedLineCount = 0;
    this.updateOperation = this._register(new MutableDisposable());
    this.updateSoon = this._register(new RunOnceScheduler(() => {
      const triggerKind = this.initialTriggerKind;
      this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;
      return this.update(triggerKind);
    }, 50));
    this.filteredCompletions = [];
    this.currentlySelectedCompletionId = void 0;
    let lastCompletionItem = void 0;
    this._register(this.onDidChange(() => {
      var _a6;
      const currentCompletion = this.currentCompletion;
      if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {
        lastCompletionItem = currentCompletion.sourceInlineCompletion;
        const provider = currentCompletion.sourceProvider;
        (_a6 = provider.handleItemDidShow) === null || _a6 === void 0 ? void 0 : _a6.call(provider, currentCompletion.sourceInlineCompletions, lastCompletionItem);
      }
    }));
    this._register(toDisposable(() => {
      this.cache.clear();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      var _a6;
      if (e.reason === 3) {
        return;
      }
      (_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.updateRanges();
      if (this.cache.value) {
        this.updateFilteredInlineCompletions();
        this.onDidChangeEmitter.fire();
      }
    }));
    this._register(this.editor.onDidChangeModelContent((e) => {
      var _a6;
      (_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.updateRanges();
      this.updateFilteredInlineCompletions();
      this.scheduleAutomaticUpdate();
    }));
    this._register(this.registry.onDidChange(() => {
      this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
    }));
    this.scheduleAutomaticUpdate();
  }
  updateFilteredInlineCompletions() {
    if (!this.cache.value) {
      this.filteredCompletions = [];
      return;
    }
    const model = this.editor.getModel();
    const cursorPosition = model.validatePosition(this.editor.getPosition());
    this.filteredCompletions = this.cache.value.completions.filter((c) => {
      const originalValue = model.getValueInRange(c.synchronizedRange).toLowerCase();
      const filterText = c.inlineCompletion.filterText.toLowerCase();
      const indent = model.getLineIndentColumn(c.synchronizedRange.startLineNumber);
      const cursorPosIndex = Math.max(0, cursorPosition.column - c.synchronizedRange.startColumn);
      let filterTextBefore = filterText.substring(0, cursorPosIndex);
      let filterTextAfter = filterText.substring(cursorPosIndex);
      let originalValueBefore = originalValue.substring(0, cursorPosIndex);
      let originalValueAfter = originalValue.substring(cursorPosIndex);
      if (c.synchronizedRange.startColumn <= indent) {
        originalValueBefore = originalValueBefore.trimStart();
        if (originalValueBefore.length === 0) {
          originalValueAfter = originalValueAfter.trimStart();
        }
        filterTextBefore = filterTextBefore.trimStart();
        if (filterTextBefore.length === 0) {
          filterTextAfter = filterTextAfter.trimStart();
        }
      }
      return filterTextBefore.startsWith(originalValueBefore) && matchesSubString(originalValueAfter, filterTextAfter);
    });
  }
  fixAndGetIndexOfCurrentSelection() {
    if (!this.currentlySelectedCompletionId || !this.cache.value) {
      return 0;
    }
    if (this.cache.value.completions.length === 0) {
      return 0;
    }
    const idx = this.filteredCompletions.findIndex((v) => v.semanticId === this.currentlySelectedCompletionId);
    if (idx === -1) {
      this.currentlySelectedCompletionId = void 0;
      return 0;
    }
    return idx;
  }
  get currentCachedCompletion() {
    if (!this.cache.value) {
      return void 0;
    }
    return this.filteredCompletions[this.fixAndGetIndexOfCurrentSelection()];
  }
  showNextInlineCompletion() {
    return __awaiter29(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      const completions = this.filteredCompletions || [];
      if (completions.length > 0) {
        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;
        this.currentlySelectedCompletionId = completions[newIdx].semanticId;
      } else {
        this.currentlySelectedCompletionId = void 0;
      }
      this.onDidChangeEmitter.fire();
    });
  }
  showPreviousInlineCompletion() {
    return __awaiter29(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      const completions = this.filteredCompletions || [];
      if (completions.length > 0) {
        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;
        this.currentlySelectedCompletionId = completions[newIdx].semanticId;
      } else {
        this.currentlySelectedCompletionId = void 0;
      }
      this.onDidChangeEmitter.fire();
    });
  }
  ensureUpdateWithExplicitContext() {
    var _a6;
    return __awaiter29(this, void 0, void 0, function* () {
      if (this.updateOperation.value) {
        if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {
          yield this.updateOperation.value.promise;
        } else {
          yield this.update(InlineCompletionTriggerKind.Explicit);
        }
      } else if (((_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.triggerKind) !== InlineCompletionTriggerKind.Explicit) {
        yield this.update(InlineCompletionTriggerKind.Explicit);
      }
    });
  }
  hasMultipleInlineCompletions() {
    var _a6;
    return __awaiter29(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      return (((_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.completions.length) || 0) > 1;
    });
  }
  get ghostText() {
    const currentCompletion = this.currentCompletion;
    if (!currentCompletion) {
      return void 0;
    }
    const cursorPosition = this.editor.getPosition();
    if (currentCompletion.range.getEndPosition().isBefore(cursorPosition)) {
      return void 0;
    }
    const mode = this.editor.getOptions().get(57).mode;
    const ghostText = inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, cursorPosition);
    if (ghostText) {
      if (ghostText.isEmpty()) {
        return void 0;
      }
      return ghostText;
    }
    return new GhostTextReplacement(currentCompletion.range.startLineNumber, currentCompletion.range.startColumn, currentCompletion.range.endColumn - currentCompletion.range.startColumn, currentCompletion.insertText.split("\n"), 0);
  }
  get currentCompletion() {
    const completion = this.currentCachedCompletion;
    if (!completion) {
      return void 0;
    }
    return completion.toLiveInlineCompletion();
  }
  get isValid() {
    return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;
  }
  scheduleAutomaticUpdate() {
    this.updateOperation.clear();
    this.updateSoon.schedule(this.debounce.get(this.editor.getModel()));
  }
  update(triggerKind) {
    return __awaiter29(this, void 0, void 0, function* () {
      if (!this.shouldUpdate()) {
        return;
      }
      const position = this.editor.getPosition();
      const startTime = new Date();
      const promise = createCancelablePromise((token) => __awaiter29(this, void 0, void 0, function* () {
        let result;
        try {
          result = yield provideInlineCompletions(this.registry, position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: void 0 }, token, this.languageConfigurationService);
          const endTime = new Date();
          this.debounce.update(this.editor.getModel(), endTime.getTime() - startTime.getTime());
        } catch (e) {
          onUnexpectedError(e);
          return;
        }
        if (token.isCancellationRequested) {
          return;
        }
        this.cache.setValue(this.editor, result, triggerKind);
        this.updateFilteredInlineCompletions();
        this.onDidChangeEmitter.fire();
      }));
      const operation = new UpdateOperation(promise, triggerKind);
      this.updateOperation.value = operation;
      yield promise;
      if (this.updateOperation.value === operation) {
        this.updateOperation.clear();
      }
    });
  }
  takeOwnership(disposable) {
    this._register(disposable);
  }
  commitCurrentCompletionNextWord() {
    const ghostText = this.ghostText;
    if (!ghostText) {
      return;
    }
    const completion = this.currentCompletion;
    if (!completion) {
      return;
    }
    if (completion.snippetInfo || completion.filterText !== completion.insertText) {
      this.commit(completion);
      return;
    }
    if (ghostText.parts.length === 0) {
      return;
    }
    const firstPart = ghostText.parts[0];
    const position = new Position(ghostText.lineNumber, firstPart.column);
    const line = firstPart.lines[0];
    const langId = this.editor.getModel().getLanguageIdAtPosition(ghostText.lineNumber, 1);
    const config = this.languageConfigurationService.getLanguageConfiguration(langId);
    const r = new RegExp(config.wordDefinition, config.wordDefinition.flags.replace("g", ""));
    const m = line.match(r);
    let acceptUntilIndexExclusive = 0;
    if (m && m.index !== void 0) {
      if (m.index === 0) {
        acceptUntilIndexExclusive = m[0].length;
      } else {
        acceptUntilIndexExclusive = m.index;
      }
    } else {
      acceptUntilIndexExclusive = line.length;
    }
    const partialText = line.substring(0, acceptUntilIndexExclusive);
    this.editor.pushUndoStop();
    this.editor.executeEdits("inlineSuggestion.accept", [
      EditOperation.replace(Range.fromPositions(position), partialText)
    ]);
    this.editor.setPosition(position.delta(0, partialText.length));
  }
  commitCurrentCompletion() {
    const ghostText = this.ghostText;
    if (!ghostText) {
      return;
    }
    const completion = this.currentCompletion;
    if (completion) {
      this.commit(completion);
    }
  }
  commit(completion) {
    var _a6;
    const cache = this.cache.clearAndLeak();
    this.editor.pushUndoStop();
    if (completion.snippetInfo) {
      this.editor.executeEdits("inlineSuggestion.accept", [
        EditOperation.replaceMove(completion.range, ""),
        ...completion.additionalTextEdits
      ]);
      this.editor.setPosition(completion.snippetInfo.range.getStartPosition());
      (_a6 = SnippetController2.get(this.editor)) === null || _a6 === void 0 ? void 0 : _a6.insert(completion.snippetInfo.snippet, { undoStopBefore: false });
    } else {
      this.editor.executeEdits("inlineSuggestion.accept", [
        EditOperation.replaceMove(completion.range, completion.insertText),
        ...completion.additionalTextEdits
      ]);
    }
    if (completion.command) {
      this.commandService.executeCommand(completion.command.id, ...completion.command.arguments || []).finally(() => {
        cache === null || cache === void 0 ? void 0 : cache.dispose();
      }).then(void 0, onUnexpectedExternalError);
    } else {
      cache === null || cache === void 0 ? void 0 : cache.dispose();
    }
    this.onDidChangeEmitter.fire();
  }
  get commands() {
    var _a6;
    const lists = new Set(((_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.completions.map((c) => c.inlineCompletion.sourceInlineCompletions)) || []);
    return [...lists].flatMap((l) => l.commands || []);
  }
};
__name(InlineCompletionsSession, "InlineCompletionsSession");
var UpdateOperation = class {
  constructor(promise, triggerKind) {
    this.promise = promise;
    this.triggerKind = triggerKind;
  }
  dispose() {
    this.promise.cancel();
  }
};
__name(UpdateOperation, "UpdateOperation");
var SynchronizedInlineCompletionsCache = class extends Disposable {
  constructor(completionsSource, editor2, onChange, triggerKind) {
    super();
    this.editor = editor2;
    this.onChange = onChange;
    this.triggerKind = triggerKind;
    this.isDisposing = false;
    const decorationIds = editor2.changeDecorations((changeAccessor) => {
      return changeAccessor.deltaDecorations([], completionsSource.items.map((i) => ({
        range: i.range,
        options: {
          description: "inline-completion-tracking-range"
        }
      })));
    });
    this._register(toDisposable(() => {
      this.isDisposing = true;
      editor2.removeDecorations(decorationIds);
    }));
    this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));
    this._register(editor2.onDidChangeModelContent(() => {
      this.updateRanges();
    }));
    this._register(completionsSource);
  }
  updateRanges() {
    if (this.isDisposing) {
      return;
    }
    let hasChanged = false;
    const model = this.editor.getModel();
    for (const c of this.completions) {
      const newRange = model.getDecorationRange(c.decorationId);
      if (!newRange) {
        onUnexpectedError(new Error("Decoration has no range"));
        continue;
      }
      if (!c.synchronizedRange.equalsRange(newRange)) {
        hasChanged = true;
        c.synchronizedRange = newRange;
      }
    }
    if (hasChanged) {
      this.onChange();
    }
  }
};
__name(SynchronizedInlineCompletionsCache, "SynchronizedInlineCompletionsCache");
var CachedInlineCompletion = class {
  constructor(inlineCompletion, decorationId) {
    this.inlineCompletion = inlineCompletion;
    this.decorationId = decorationId;
    this.semanticId = JSON.stringify({
      text: this.inlineCompletion.insertText,
      abbreviation: this.inlineCompletion.filterText,
      startLine: this.inlineCompletion.range.startLineNumber,
      startColumn: this.inlineCompletion.range.startColumn,
      command: this.inlineCompletion.command
    });
    this.synchronizedRange = inlineCompletion.range;
  }
  toLiveInlineCompletion() {
    return {
      insertText: this.inlineCompletion.insertText,
      range: this.synchronizedRange,
      command: this.inlineCompletion.command,
      sourceProvider: this.inlineCompletion.sourceProvider,
      sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,
      sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion,
      snippetInfo: this.inlineCompletion.snippetInfo,
      filterText: this.inlineCompletion.filterText,
      additionalTextEdits: this.inlineCompletion.additionalTextEdits
    };
  }
};
__name(CachedInlineCompletion, "CachedInlineCompletion");
function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {
  return __awaiter29(this, void 0, void 0, function* () {
    const defaultReplaceRange = getDefaultRange(position, model);
    const providers = registry.all(model);
    const results = yield Promise.all(providers.map((provider) => __awaiter29(this, void 0, void 0, function* () {
      const completions = yield Promise.resolve(provider.provideInlineCompletions(model, position, context, token)).catch(onUnexpectedExternalError);
      return {
        completions,
        provider,
        dispose: () => {
          if (completions) {
            provider.freeInlineCompletions(completions);
          }
        }
      };
    })));
    const itemsByHash = /* @__PURE__ */ new Map();
    for (const result of results) {
      const completions = result.completions;
      if (!completions) {
        continue;
      }
      for (const item of completions.items) {
        let range = item.range ? Range.lift(item.range) : defaultReplaceRange;
        if (range.startLineNumber !== range.endLineNumber) {
          continue;
        }
        let insertText;
        let snippetInfo;
        if (typeof item.insertText === "string") {
          insertText = item.insertText;
          if (languageConfigurationService && item.completeBracketPairs) {
            insertText = closeBrackets(insertText, range.getStartPosition(), model, languageConfigurationService);
            const diff = insertText.length - item.insertText.length;
            if (diff !== 0) {
              range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
            }
          }
          snippetInfo = void 0;
        } else if ("snippet" in item.insertText) {
          const preBracketCompletionLength = item.insertText.snippet.length;
          if (languageConfigurationService && item.completeBracketPairs) {
            item.insertText.snippet = closeBrackets(item.insertText.snippet, range.getStartPosition(), model, languageConfigurationService);
            const diff = item.insertText.snippet.length - preBracketCompletionLength;
            if (diff !== 0) {
              range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);
            }
          }
          const snippet = new SnippetParser().parse(item.insertText.snippet);
          if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {
            insertText = snippet.children[0].value;
            snippetInfo = void 0;
          } else {
            insertText = snippet.toString();
            snippetInfo = {
              snippet: item.insertText.snippet,
              range
            };
          }
        } else {
          assertNever(item.insertText);
        }
        const trackedItem = {
          insertText,
          snippetInfo,
          range,
          command: item.command,
          sourceProvider: result.provider,
          sourceInlineCompletions: completions,
          sourceInlineCompletion: item,
          filterText: item.filterText || insertText,
          additionalTextEdits: item.additionalTextEdits || getReadonlyEmptyArray()
        };
        itemsByHash.set(JSON.stringify({ insertText, range: item.range }), trackedItem);
      }
    }
    return {
      items: [...itemsByHash.values()],
      dispose: () => {
        for (const result of results) {
          result.dispose();
        }
      }
    };
  });
}
__name(provideInlineCompletions, "provideInlineCompletions");
function getDefaultRange(position, model) {
  const word = model.getWordAtPosition(position);
  const maxColumn = model.getLineMaxColumn(position.lineNumber);
  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(void 0, maxColumn));
}
__name(getDefaultRange, "getDefaultRange");
function closeBrackets(text, position, model, languageConfigurationService) {
  const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);
  const newLine = lineStart + text;
  const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);
  const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);
  if (!slicedTokens) {
    return text;
  }
  const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);
  return newText;
}
__name(closeBrackets, "closeBrackets");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetPreviewModel.js
init_define_process();
init_async();
init_errors();
init_lifecycle();
init_languages();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js
init_define_process();
init_arrays();
init_event();
init_lifecycle();
init_position();
init_range();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_define_process();
init_aria();
init_arrays();
init_async();
init_cancellation();
init_errors();
init_event();
init_keybindings();
init_lifecycle();
init_platform();
init_stopwatch();
init_types();
init_editorExtensions();
init_editOperation();
init_position();
init_range();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestMemory.js
init_define_process();
init_async();
init_lifecycle();
init_map();
init_languages();
init_configuration();
init_extensions();
init_instantiation();
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Memory = class {
  constructor(name) {
    this.name = name;
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const topScore = items[0].score[0];
    for (let i = 0; i < items.length; i++) {
      const { score, completion: suggestion } = items[i];
      if (score[0] !== topScore) {
        break;
      }
      if (suggestion.preselect) {
        return i;
      }
    }
    return 0;
  }
};
__name(Memory, "Memory");
var NoMemory = class extends Memory {
  constructor() {
    super("first");
  }
  memorize(model, pos, item) {
  }
  toJSON() {
    return void 0;
  }
  fromJSON() {
  }
};
__name(NoMemory, "NoMemory");
var LRUMemory = class extends Memory {
  constructor() {
    super("recentlyUsed");
    this._cache = new LRUCache(300, 0.66);
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const key = `${model.getLanguageId()}/${item.textLabel}`;
    this._cache.set(key, {
      touch: this._seq++,
      type: item.completion.kind,
      insertText: item.completion.insertText
    });
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
    if (/\s$/.test(lineSuffix)) {
      return super.select(model, pos, items);
    }
    const topScore = items[0].score[0];
    let indexPreselect = -1;
    let indexRecency = -1;
    let seq = -1;
    for (let i = 0; i < items.length; i++) {
      if (items[i].score[0] !== topScore) {
        break;
      }
      const key = `${model.getLanguageId()}/${items[i].textLabel}`;
      const item = this._cache.peek(key);
      if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {
        seq = item.touch;
        indexRecency = i;
      }
      if (items[i].completion.preselect && indexPreselect === -1) {
        return indexPreselect = i;
      }
    }
    if (indexRecency !== -1) {
      return indexRecency;
    } else if (indexPreselect !== -1) {
      return indexPreselect;
    } else {
      return 0;
    }
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(data) {
    this._cache.clear();
    const seq = 0;
    for (const [key, value] of data) {
      value.touch = seq;
      value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
      this._cache.set(key, value);
    }
    this._seq = this._cache.size;
  }
};
__name(LRUMemory, "LRUMemory");
var PrefixMemory = class extends Memory {
  constructor() {
    super("recentlyUsedByPrefix");
    this._trie = TernarySearchTree.forStrings();
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const { word } = model.getWordUntilPosition(pos);
    const key = `${model.getLanguageId()}/${word}`;
    this._trie.set(key, {
      type: item.completion.kind,
      insertText: item.completion.insertText,
      touch: this._seq++
    });
  }
  select(model, pos, items) {
    const { word } = model.getWordUntilPosition(pos);
    if (!word) {
      return super.select(model, pos, items);
    }
    const key = `${model.getLanguageId()}/${word}`;
    let item = this._trie.get(key);
    if (!item) {
      item = this._trie.findSubstr(key);
    }
    if (item) {
      for (let i = 0; i < items.length; i++) {
        const { kind, insertText } = items[i].completion;
        if (kind === item.type && insertText === item.insertText) {
          return i;
        }
      }
    }
    return super.select(model, pos, items);
  }
  toJSON() {
    const entries = [];
    this._trie.forEach((value, key) => entries.push([key, value]));
    entries.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i) => value[1].touch = i);
    return entries.slice(0, 200);
  }
  fromJSON(data) {
    this._trie.clear();
    if (data.length > 0) {
      this._seq = data[0][1].touch + 1;
      for (const [key, value] of data) {
        value.type = typeof value.type === "number" ? value.type : CompletionItemKinds.fromString(value.type);
        this._trie.set(key, value);
      }
    }
  }
};
__name(PrefixMemory, "PrefixMemory");
var SuggestMemoryService = /* @__PURE__ */ __name(class SuggestMemoryService2 {
  constructor(_storageService, _configService) {
    this._storageService = _storageService;
    this._configService = _configService;
    this._disposables = new DisposableStore();
    this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
    this._disposables.add(_storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this._saveState();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._persistSoon.dispose();
  }
  memorize(model, pos, item) {
    this._withStrategy(model, pos).memorize(model, pos, item);
    this._persistSoon.schedule();
  }
  select(model, pos, items) {
    return this._withStrategy(model, pos).select(model, pos, items);
  }
  _withStrategy(model, pos) {
    var _a6;
    const mode = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: model.getLanguageIdAtPosition(pos.lineNumber, pos.column),
      resource: model.uri
    });
    if (((_a6 = this._strategy) === null || _a6 === void 0 ? void 0 : _a6.name) !== mode) {
      this._saveState();
      const ctor = SuggestMemoryService2._strategyCtors.get(mode) || NoMemory;
      this._strategy = new ctor();
      try {
        const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
        const scope = share ? 0 : 1;
        const raw = this._storageService.get(`${SuggestMemoryService2._storagePrefix}/${mode}`, scope);
        if (raw) {
          this._strategy.fromJSON(JSON.parse(raw));
        }
      } catch (e) {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
      const scope = share ? 0 : 1;
      const raw = JSON.stringify(this._strategy);
      this._storageService.store(`${SuggestMemoryService2._storagePrefix}/${this._strategy.name}`, raw, scope, 1);
    }
  }
}, "SuggestMemoryService");
SuggestMemoryService._strategyCtors = /* @__PURE__ */ new Map([
  ["recentlyUsedByPrefix", PrefixMemory],
  ["recentlyUsed", LRUMemory],
  ["first", NoMemory]
]);
SuggestMemoryService._storagePrefix = "suggest/memories";
SuggestMemoryService = __decorate39([
  __param39(0, IStorageService),
  __param39(1, IConfigurationService)
], SuggestMemoryService);
var ISuggestMemoryService = createDecorator("ISuggestMemories");
registerSingleton(ISuggestMemoryService, SuggestMemoryService, 1);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordContextKey.js
init_define_process();
init_contextkey();
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordContextKey = /* @__PURE__ */ __name(class WordContextKey2 {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._enabled = false;
    this._ckAtEnd = WordContextKey2.AtEnd.bindTo(contextKeyService);
    this._configListener = this._editor.onDidChangeConfiguration((e) => e.hasChanged(115) && this._update());
    this._update();
  }
  dispose() {
    var _a6;
    this._configListener.dispose();
    (_a6 = this._selectionListener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._ckAtEnd.reset();
  }
  _update() {
    const enabled = this._editor.getOption(115) === "on";
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    if (this._enabled) {
      const checkForWordEnd = /* @__PURE__ */ __name(() => {
        if (!this._editor.hasModel()) {
          this._ckAtEnd.set(false);
          return;
        }
        const model = this._editor.getModel();
        const selection = this._editor.getSelection();
        const word = model.getWordAtPosition(selection.getStartPosition());
        if (!word) {
          this._ckAtEnd.set(false);
          return;
        }
        this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);
      }, "checkForWordEnd");
      this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
      checkForWordEnd();
    } else if (this._selectionListener) {
      this._ckAtEnd.reset();
      this._selectionListener.dispose();
      this._selectionListener = void 0;
    }
  }
}, "WordContextKey");
WordContextKey.AtEnd = new RawContextKey("atEndOfWord", false);
WordContextKey = __decorate40([
  __param40(1, IContextKeyService)
], WordContextKey);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_nls();
init_commands();
init_contextkey();
init_instantiation();
init_log();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestAlternatives.js
init_define_process();
init_contextkey();
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestAlternatives = /* @__PURE__ */ __name(class SuggestAlternatives2 {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._index = 0;
    this._ckOtherSuggestions = SuggestAlternatives2.OtherSuggestions.bindTo(contextKeyService);
  }
  dispose() {
    this.reset();
  }
  reset() {
    var _a6;
    this._ckOtherSuggestions.reset();
    (_a6 = this._listener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._model = void 0;
    this._acceptNext = void 0;
    this._ignore = false;
  }
  set({ model, index }, acceptNext) {
    if (model.items.length === 0) {
      this.reset();
      return;
    }
    const nextIndex = SuggestAlternatives2._moveIndex(true, model, index);
    if (nextIndex === index) {
      this.reset();
      return;
    }
    this._acceptNext = acceptNext;
    this._model = model;
    this._index = index;
    this._listener = this._editor.onDidChangeCursorPosition(() => {
      if (!this._ignore) {
        this.reset();
      }
    });
    this._ckOtherSuggestions.set(true);
  }
  static _moveIndex(fwd, model, index) {
    let newIndex = index;
    while (true) {
      newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
      if (newIndex === index) {
        break;
      }
      if (!model.items[newIndex].completion.additionalTextEdits) {
        break;
      }
    }
    return newIndex;
  }
  next() {
    this._move(true);
  }
  prev() {
    this._move(false);
  }
  _move(fwd) {
    if (!this._model) {
      return;
    }
    try {
      this._ignore = true;
      this._index = SuggestAlternatives2._moveIndex(fwd, this._model, this._index);
      this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
    } finally {
      this._ignore = false;
    }
  }
}, "SuggestAlternatives");
SuggestAlternatives.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false);
SuggestAlternatives = __decorate41([
  __param41(1, IContextKeyService)
], SuggestAlternatives);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestCommitCharacters.js
init_define_process();
init_arrays();
init_lifecycle();
init_characterClassifier();
var CommitCharacterController = class {
  constructor(editor2, widget, model, accept) {
    this._disposables = new DisposableStore();
    this._disposables.add(model.onDidSuggest((e) => {
      if (e.completionModel.items.length === 0) {
        this.reset();
      }
    }));
    this._disposables.add(model.onDidCancel((e) => {
      this.reset();
    }));
    this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
    this._disposables.add(widget.onDidFocus(this._onItem, this));
    this._disposables.add(widget.onDidHide(this.reset, this));
    this._disposables.add(editor2.onWillType((text) => {
      if (this._active && !widget.isFrozen() && model.state !== 0) {
        const ch = text.charCodeAt(text.length - 1);
        if (this._active.acceptCharacters.has(ch) && editor2.getOption(0)) {
          accept(this._active.item);
        }
      }
    }));
  }
  _onItem(selected) {
    if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === selected.item) {
      return;
    }
    const acceptCharacters = new CharacterSet();
    for (const ch of selected.item.completion.commitCharacters) {
      if (ch.length > 0) {
        acceptCharacters.add(ch.charCodeAt(0));
      }
    }
    this._active = { acceptCharacters, item: selected };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};
__name(CommitCharacterController, "CommitCharacterController");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_define_process();
init_async();
init_cancellation();
init_errors();
init_event();
init_lifecycle();
init_strings();
init_selection();
init_editorWorker();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordDistance.js
init_define_process();
init_arrays();
init_range();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/bracketSelections.js
init_define_process();
init_linkedList();
init_position();
init_range();
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BracketSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    return __awaiter30(this, void 0, void 0, function* () {
      const result = [];
      for (const position of positions) {
        const bucket = [];
        result.push(bucket);
        const ranges = /* @__PURE__ */ new Map();
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
      }
      return result;
    });
  }
  static _bracketsRightYield(resolve, round, model, pos, ranges) {
    const counts = /* @__PURE__ */ new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      const bracket = model.bracketPairs.findNextBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      const d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
        break;
      }
      if (bracket.bracketInfo.isOpeningBracket) {
        const key = bracket.bracketInfo.bracketText;
        const val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        const key = bracket.bracketInfo.getClosedBrackets()[0].bracketText;
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (!list) {
            list = new LinkedList();
            ranges.set(key, list);
          }
          list.push(bracket.range);
        }
      }
      pos = bracket.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
    const counts = /* @__PURE__ */ new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      const bracket = model.bracketPairs.findPrevBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      const d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
        break;
      }
      if (!bracket.bracketInfo.isOpeningBracket) {
        const key = bracket.bracketInfo.getClosedBrackets()[0].bracketText;
        const val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        const key = bracket.bracketInfo.bracketText;
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          const list = ranges.get(key);
          if (list) {
            const closing = list.shift();
            if (list.size === 0) {
              ranges.delete(key);
            }
            const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
            const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
            bucket.push({ range: innerBracket });
            bucket.push({ range: outerBracket });
            BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
          }
        }
      }
      pos = bracket.range.getStartPosition();
    }
  }
  static _addBracketLeading(model, bracket, bucket) {
    if (bracket.startLineNumber === bracket.endLineNumber) {
      return;
    }
    const startLine = bracket.startLineNumber;
    const column = model.getLineFirstNonWhitespaceColumn(startLine);
    if (column !== 0 && column !== bracket.startColumn) {
      bucket.push({ range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition()) });
      bucket.push({ range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition()) });
    }
    const aboveLine = startLine - 1;
    if (aboveLine > 0) {
      const column2 = model.getLineFirstNonWhitespaceColumn(aboveLine);
      if (column2 === bracket.startColumn && column2 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, column2), bracket.getEndPosition()) });
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition()) });
      }
    }
  }
};
__name(BracketSelectionRangeProvider, "BracketSelectionRangeProvider");
BracketSelectionRangeProvider._maxDuration = 30;
BracketSelectionRangeProvider._maxRounds = 2;

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/wordDistance.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WordDistance = class {
  static create(service, editor2) {
    return __awaiter31(this, void 0, void 0, function* () {
      if (!editor2.getOption(110).localityBonus) {
        return WordDistance.None;
      }
      if (!editor2.hasModel()) {
        return WordDistance.None;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!service.canComputeWordRanges(model.uri)) {
        return WordDistance.None;
      }
      const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
      if (ranges.length === 0) {
        return WordDistance.None;
      }
      const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
      if (!wordRanges) {
        return WordDistance.None;
      }
      const wordUntilPos = model.getWordUntilPosition(position);
      delete wordRanges[wordUntilPos.word];
      return new class extends WordDistance {
        distance(anchor, item) {
          if (!position.equals(editor2.getPosition())) {
            return 0;
          }
          if (item.kind === 17) {
            return 2 << 20;
          }
          const word = typeof item.label === "string" ? item.label : item.label.label;
          const wordLines = wordRanges[word];
          if (isFalsyOrEmpty(wordLines)) {
            return 2 << 20;
          }
          const idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
          const bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
          let blockDistance = ranges.length;
          for (const range of ranges) {
            if (!Range.containsRange(range.range, bestWordRange)) {
              break;
            }
            blockDistance -= 1;
          }
          return blockDistance;
        }
      }();
    });
  }
};
__name(WordDistance, "WordDistance");
WordDistance.None = new class extends WordDistance {
  distance() {
    return 0;
  }
}();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_configuration();
init_contextkey();
init_log();
init_telemetry();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/completionModel.js
init_define_process();
init_arrays();
init_strings();
var LineContext = class {
  constructor(leadingLineContent, characterCountDelta) {
    this.leadingLineContent = leadingLineContent;
    this.characterCountDelta = characterCountDelta;
  }
};
__name(LineContext, "LineContext");
var CompletionModel = class {
  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, fuzzyScoreOptions = FuzzyScoreOptions.default, clipboardText = void 0) {
    this.clipboardText = clipboardText;
    this._snippetCompareFn = CompletionModel._compareCompletionItems;
    this._items = items;
    this._column = column;
    this._wordDistance = wordDistance;
    this._options = options;
    this._refilterKind = 1;
    this._lineContext = lineContext;
    this._fuzzyScoreOptions = fuzzyScoreOptions;
    if (snippetSuggestions === "top") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;
    } else if (snippetSuggestions === "bottom") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;
    }
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(value) {
    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
      this._lineContext = value;
    }
  }
  get items() {
    this._ensureCachedState();
    return this._filteredItems;
  }
  getItemsByProvider() {
    this._ensureCachedState();
    return this._itemsByProvider;
  }
  getIncompleteProvider() {
    this._ensureCachedState();
    const result = /* @__PURE__ */ new Set();
    for (const [provider, items] of this.getItemsByProvider()) {
      if (items.length > 0 && items[0].container.incomplete) {
        result.add(provider);
      }
    }
    return result;
  }
  get stats() {
    this._ensureCachedState();
    return this._stats;
  }
  _ensureCachedState() {
    if (this._refilterKind !== 0) {
      this._createCachedState();
    }
  }
  _createCachedState() {
    this._itemsByProvider = /* @__PURE__ */ new Map();
    const labelLengths = [];
    const { leadingLineContent, characterCountDelta } = this._lineContext;
    let word = "";
    let wordLow = "";
    const source = this._refilterKind === 1 ? this._items : this._filteredItems;
    const target = [];
    const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    for (let i = 0; i < source.length; i++) {
      const item = source[i];
      if (item.isInvalid) {
        continue;
      }
      const arr = this._itemsByProvider.get(item.provider);
      if (arr) {
        arr.push(item);
      } else {
        this._itemsByProvider.set(item.provider, [item]);
      }
      const overwriteBefore = item.position.column - item.editStart.column;
      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      item.word = word;
      if (wordLen === 0) {
        item.score = FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < overwriteBefore) {
          const ch = word.charCodeAt(wordPos);
          if (ch === 32 || ch === 9) {
            wordPos += 1;
          } else {
            break;
          }
        }
        if (wordPos >= wordLen) {
          item.score = FuzzyScore.Default;
        } else if (typeof item.completion.filterText === "string") {
          const match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, this._fuzzyScoreOptions);
          if (!match) {
            continue;
          }
          if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {
            item.score = match;
          } else {
            item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);
            item.score[0] = match[0];
          }
        } else {
          const match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, this._fuzzyScoreOptions);
          if (!match) {
            continue;
          }
          item.score = match;
        }
      }
      item.idx = i;
      item.distance = this._wordDistance.distance(item.position, item.completion);
      target.push(item);
      labelLengths.push(item.textLabel.length);
    }
    this._filteredItems = target.sort(this._snippetCompareFn);
    this._refilterKind = 0;
    this._stats = {
      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - 0.85, labelLengths, (a, b) => a - b) : 0
    };
  }
  static _compareCompletionItems(a, b) {
    if (a.score[0] > b.score[0]) {
      return -1;
    } else if (a.score[0] < b.score[0]) {
      return 1;
    } else if (a.distance < b.distance) {
      return -1;
    } else if (a.distance > b.distance) {
      return 1;
    } else if (a.idx < b.idx) {
      return -1;
    } else if (a.idx > b.idx) {
      return 1;
    } else {
      return 0;
    }
  }
  static _compareCompletionItemsSnippetsDown(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return 1;
      } else if (b.completion.kind === 27) {
        return -1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
  static _compareCompletionItemsSnippetsUp(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return -1;
      } else if (b.completion.kind === 27) {
        return 1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
};
__name(CompletionModel, "CompletionModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestModel.js
init_languageFeatures();
init_types();
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LineContext2 = class {
  static shouldAutoTrigger(editor2) {
    if (!editor2.hasModel()) {
      return false;
    }
    const model = editor2.getModel();
    const pos = editor2.getPosition();
    model.tokenization.tokenizeIfCheap(pos.lineNumber);
    const word = model.getWordAtPosition(pos);
    if (!word) {
      return false;
    }
    if (word.endColumn !== pos.column) {
      return false;
    }
    if (!isNaN(Number(word.word))) {
      return false;
    }
    return true;
  }
  constructor(model, position, auto, shy) {
    this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
    this.leadingWord = model.getWordUntilPosition(position);
    this.lineNumber = position.lineNumber;
    this.column = position.column;
    this.auto = auto;
    this.shy = shy !== null && shy !== void 0 ? shy : false;
  }
};
__name(LineContext2, "LineContext");
function canShowQuickSuggest(editor2, contextKeyService, configurationService) {
  var _a6, _b2;
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowQuickSuggestions", { overrideIdentifier: (_a6 = editor2.getModel()) === null || _a6 === void 0 ? void 0 : _a6.getLanguageId(), resource: (_b2 = editor2.getModel()) === null || _b2 === void 0 ? void 0 : _b2.uri });
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
__name(canShowQuickSuggest, "canShowQuickSuggest");
function canShowSuggestOnTriggerCharacters(editor2, contextKeyService, configurationService) {
  var _a6, _b2;
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowSuggestOnTriggerCharacters", { overrideIdentifier: (_a6 = editor2.getModel()) === null || _a6 === void 0 ? void 0 : _a6.getLanguageId(), resource: (_b2 = editor2.getModel()) === null || _b2 === void 0 ? void 0 : _b2.uri });
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
__name(canShowSuggestOnTriggerCharacters, "canShowSuggestOnTriggerCharacters");
var SuggestModel = /* @__PURE__ */ __name(class SuggestModel2 {
  constructor(_editor, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService, _languageFeaturesService) {
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._clipboardService = _clipboardService;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._languageFeaturesService = _languageFeaturesService;
    this._toDispose = new DisposableStore();
    this._triggerCharacterListener = new DisposableStore();
    this._triggerQuickSuggest = new TimeoutTimer();
    this._state = 0;
    this._completionDisposables = new DisposableStore();
    this._onDidCancel = new Emitter();
    this._onDidTrigger = new Emitter();
    this._onDidSuggest = new Emitter();
    this.onDidCancel = this._onDidCancel.event;
    this.onDidTrigger = this._onDidTrigger.event;
    this.onDidSuggest = this._onDidSuggest.event;
    this._telemetryGate = 0;
    this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
    this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
    }));
    this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
      this._updateTriggerCharacters();
      this._updateActiveSuggestSession();
    }));
    let editorIsComposing = false;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      editorIsComposing = true;
    }));
    this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      editorIsComposing = false;
      this._onCompositionEnd();
    }));
    this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
      if (!editorIsComposing) {
        this._onCursorChange(e);
      }
    }));
    this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!editorIsComposing) {
        this._refilterCompletionItems();
      }
    }));
    this._updateTriggerCharacters();
  }
  dispose() {
    dispose(this._triggerCharacterListener);
    dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);
    this._toDispose.dispose();
    this._completionDisposables.dispose();
    this.cancel();
  }
  _updateTriggerCharacters() {
    this._triggerCharacterListener.clear();
    if (this._editor.getOption(84) || !this._editor.hasModel() || !this._editor.getOption(113)) {
      return;
    }
    const supportsByTriggerCharacter = /* @__PURE__ */ new Map();
    for (const support of this._languageFeaturesService.completionProvider.all(this._editor.getModel())) {
      for (const ch of support.triggerCharacters || []) {
        let set = supportsByTriggerCharacter.get(ch);
        if (!set) {
          set = /* @__PURE__ */ new Set();
          set.add(getSnippetSuggestSupport());
          supportsByTriggerCharacter.set(ch, set);
        }
        set.add(support);
      }
    }
    const checkTriggerCharacter = /* @__PURE__ */ __name((text) => {
      var _a6;
      if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (LineContext2.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!text) {
        const position = this._editor.getPosition();
        const model = this._editor.getModel();
        text = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
      }
      let lastChar = "";
      if (isLowSurrogate(text.charCodeAt(text.length - 1))) {
        if (isHighSurrogate(text.charCodeAt(text.length - 2))) {
          lastChar = text.substr(text.length - 2);
        }
      } else {
        lastChar = text.charAt(text.length - 1);
      }
      const supports = supportsByTriggerCharacter.get(lastChar);
      if (supports) {
        const providerItemsToReuse = /* @__PURE__ */ new Map();
        if (this._completionModel) {
          for (const [provider, items] of this._completionModel.getItemsByProvider()) {
            if (!supports.has(provider)) {
              providerItemsToReuse.set(provider, items);
            }
          }
        }
        this.trigger({
          auto: true,
          triggerCharacter: lastChar,
          retrigger: Boolean(this._completionModel),
          clipboardText: (_a6 = this._completionModel) === null || _a6 === void 0 ? void 0 : _a6.clipboardText,
          completionOptions: { providerFilter: supports, providerItemsToReuse }
        });
      }
    }, "checkTriggerCharacter");
    this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
    this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => checkTriggerCharacter()));
  }
  get state() {
    return this._state;
  }
  cancel(retrigger = false) {
    var _a6;
    if (this._state !== 0) {
      this._triggerQuickSuggest.cancel();
      (_a6 = this._requestToken) === null || _a6 === void 0 ? void 0 : _a6.cancel();
      this._requestToken = void 0;
      this._state = 0;
      this._completionModel = void 0;
      this._context = void 0;
      this._onDidCancel.fire({ retrigger });
    }
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    if (this._state !== 0) {
      if (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel())) {
        this.cancel();
      } else {
        this.trigger({ auto: this._state === 2, retrigger: true });
      }
    }
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    const prevSelection = this._currentSelection;
    this._currentSelection = this._editor.getSelection();
    if (!e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    if (this._state === 0 && e.reason === 0) {
      if (prevSelection.containsRange(this._currentSelection) || prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {
        this._doTriggerQuickSuggest();
      }
    } else if (this._state !== 0 && e.reason === 3) {
      this._refilterCompletionItems();
    }
  }
  _onCompositionEnd() {
    if (this._state === 0) {
      this._doTriggerQuickSuggest();
    } else {
      this._refilterCompletionItems();
    }
  }
  _doTriggerQuickSuggest() {
    var _a6;
    if (QuickSuggestionsOptions.isAllOff(this._editor.getOption(82))) {
      return;
    }
    if (this._editor.getOption(110).snippetsPreventQuickSuggestions && ((_a6 = SnippetController2.get(this._editor)) === null || _a6 === void 0 ? void 0 : _a6.isInSnippet())) {
      return;
    }
    this.cancel();
    this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._state !== 0) {
        return;
      }
      if (!LineContext2.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
        return;
      }
      const model = this._editor.getModel();
      const pos = this._editor.getPosition();
      const config = this._editor.getOption(82);
      if (QuickSuggestionsOptions.isAllOff(config)) {
        return;
      }
      if (!QuickSuggestionsOptions.isAllOn(config)) {
        model.tokenization.tokenizeIfCheap(pos.lineNumber);
        const lineTokens = model.tokenization.getLineTokens(pos.lineNumber);
        const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
        if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "on") {
          return;
        }
      }
      if (!canShowQuickSuggest(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (!this._languageFeaturesService.completionProvider.has(model)) {
        return;
      }
      this.trigger({ auto: true });
    }, this._editor.getOption(83));
  }
  _refilterCompletionItems() {
    assertType(this._editor.hasModel());
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    const ctx = new LineContext2(model, position, this._state === 2, false);
    this._onNewContext(ctx);
  }
  trigger(options) {
    var _a6, _b2, _c2, _d2, _e2, _f2;
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const auto = options.auto;
    const ctx = new LineContext2(model, this._editor.getPosition(), auto, options.shy);
    this.cancel(options.retrigger);
    this._state = auto ? 2 : 1;
    this._onDidTrigger.fire({ auto, shy: (_a6 = options.shy) !== null && _a6 !== void 0 ? _a6 : false, position: this._editor.getPosition() });
    this._context = ctx;
    let suggestCtx = { triggerKind: (_b2 = options.triggerKind) !== null && _b2 !== void 0 ? _b2 : 0 };
    if (options.triggerCharacter) {
      suggestCtx = {
        triggerKind: 1,
        triggerCharacter: options.triggerCharacter
      };
    }
    this._requestToken = new CancellationTokenSource();
    const snippetSuggestions = this._editor.getOption(104);
    let snippetSortOrder = 1;
    switch (snippetSuggestions) {
      case "top":
        snippetSortOrder = 0;
        break;
      case "bottom":
        snippetSortOrder = 2;
        break;
    }
    const { itemKind: itemKindFilter, showDeprecated } = SuggestModel2._createSuggestFilter(this._editor);
    const completionOptions = new CompletionOptions(snippetSortOrder, (_d2 = (_c2 = options.completionOptions) === null || _c2 === void 0 ? void 0 : _c2.kindFilter) !== null && _d2 !== void 0 ? _d2 : itemKindFilter, (_e2 = options.completionOptions) === null || _e2 === void 0 ? void 0 : _e2.providerFilter, (_f2 = options.completionOptions) === null || _f2 === void 0 ? void 0 : _f2.providerItemsToReuse, showDeprecated);
    const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
    const completions = provideSuggestionItems(this._languageFeaturesService.completionProvider, model, this._editor.getPosition(), completionOptions, suggestCtx, this._requestToken.token);
    Promise.all([completions, wordDistance]).then(([completions2, wordDistance2]) => __awaiter32(this, void 0, void 0, function* () {
      var _g2;
      (_g2 = this._requestToken) === null || _g2 === void 0 ? void 0 : _g2.dispose();
      if (!this._editor.hasModel()) {
        return;
      }
      let clipboardText = options === null || options === void 0 ? void 0 : options.clipboardText;
      if (!clipboardText && completions2.needsClipboard) {
        clipboardText = yield this._clipboardService.readText();
      }
      if (this._state === 0) {
        return;
      }
      const model2 = this._editor.getModel();
      const ctx2 = new LineContext2(model2, this._editor.getPosition(), auto, options.shy);
      const fuzzySearchOptions = Object.assign(Object.assign({}, FuzzyScoreOptions.default), { firstMatchCanBeWeak: !this._editor.getOption(110).matchOnWordStartOnly });
      this._completionModel = new CompletionModel(completions2.items, this._context.column, {
        leadingLineContent: ctx2.leadingLineContent,
        characterCountDelta: ctx2.column - this._context.column
      }, wordDistance2, this._editor.getOption(110), this._editor.getOption(104), fuzzySearchOptions, clipboardText);
      this._completionDisposables.add(completions2.disposable);
      this._onNewContext(ctx2);
      this._reportDurationsTelemetry(completions2.durations);
    })).catch(onUnexpectedError);
  }
  _reportDurationsTelemetry(durations) {
    if (this._telemetryGate++ % 230 !== 0) {
      return;
    }
    setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(durations) });
      this._logService.debug("suggest.durations.json", durations);
    });
  }
  static _createSuggestFilter(editor2) {
    const result = /* @__PURE__ */ new Set();
    const snippetSuggestions = editor2.getOption(104);
    if (snippetSuggestions === "none") {
      result.add(27);
    }
    const suggestOptions = editor2.getOption(110);
    if (!suggestOptions.showMethods) {
      result.add(0);
    }
    if (!suggestOptions.showFunctions) {
      result.add(1);
    }
    if (!suggestOptions.showConstructors) {
      result.add(2);
    }
    if (!suggestOptions.showFields) {
      result.add(3);
    }
    if (!suggestOptions.showVariables) {
      result.add(4);
    }
    if (!suggestOptions.showClasses) {
      result.add(5);
    }
    if (!suggestOptions.showStructs) {
      result.add(6);
    }
    if (!suggestOptions.showInterfaces) {
      result.add(7);
    }
    if (!suggestOptions.showModules) {
      result.add(8);
    }
    if (!suggestOptions.showProperties) {
      result.add(9);
    }
    if (!suggestOptions.showEvents) {
      result.add(10);
    }
    if (!suggestOptions.showOperators) {
      result.add(11);
    }
    if (!suggestOptions.showUnits) {
      result.add(12);
    }
    if (!suggestOptions.showValues) {
      result.add(13);
    }
    if (!suggestOptions.showConstants) {
      result.add(14);
    }
    if (!suggestOptions.showEnums) {
      result.add(15);
    }
    if (!suggestOptions.showEnumMembers) {
      result.add(16);
    }
    if (!suggestOptions.showKeywords) {
      result.add(17);
    }
    if (!suggestOptions.showWords) {
      result.add(18);
    }
    if (!suggestOptions.showColors) {
      result.add(19);
    }
    if (!suggestOptions.showFiles) {
      result.add(20);
    }
    if (!suggestOptions.showReferences) {
      result.add(21);
    }
    if (!suggestOptions.showColors) {
      result.add(22);
    }
    if (!suggestOptions.showFolders) {
      result.add(23);
    }
    if (!suggestOptions.showTypeParameters) {
      result.add(24);
    }
    if (!suggestOptions.showSnippets) {
      result.add(27);
    }
    if (!suggestOptions.showUsers) {
      result.add(25);
    }
    if (!suggestOptions.showIssues) {
      result.add(26);
    }
    return { itemKind: result, showDeprecated: suggestOptions.showDeprecated };
  }
  _onNewContext(ctx) {
    if (!this._context) {
      return;
    }
    if (ctx.lineNumber !== this._context.lineNumber) {
      this.cancel();
      return;
    }
    if (getLeadingWhitespace(ctx.leadingLineContent) !== getLeadingWhitespace(this._context.leadingLineContent)) {
      this.cancel();
      return;
    }
    if (ctx.column < this._context.column) {
      if (ctx.leadingWord.word) {
        this.trigger({ auto: this._context.auto, retrigger: true });
      } else {
        this.cancel();
      }
      return;
    }
    if (!this._completionModel) {
      return;
    }
    if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
      const map = this._completionModel.getItemsByProvider();
      this.trigger({
        auto: this._context.auto,
        retrigger: true,
        clipboardText: this._completionModel.clipboardText,
        completionOptions: { providerItemsToReuse: map }
      });
      return;
    }
    if (ctx.column > this._context.column && this._completionModel.getIncompleteProvider().size > 0 && ctx.leadingWord.word.length !== 0) {
      const providerItemsToReuse = /* @__PURE__ */ new Map();
      const providerFilter = /* @__PURE__ */ new Set();
      for (const [provider, items] of this._completionModel.getItemsByProvider()) {
        if (items.length > 0 && items[0].container.incomplete) {
          providerFilter.add(provider);
        } else {
          providerItemsToReuse.set(provider, items);
        }
      }
      this.trigger({
        auto: this._state === 2,
        triggerKind: 2,
        retrigger: true,
        clipboardText: this._completionModel.clipboardText,
        completionOptions: { providerFilter, providerItemsToReuse }
      });
    } else {
      const oldLineContext = this._completionModel.lineContext;
      let isFrozen = false;
      this._completionModel.lineContext = {
        leadingLineContent: ctx.leadingLineContent,
        characterCountDelta: ctx.column - this._context.column
      };
      if (this._completionModel.items.length === 0) {
        const shouldAutoTrigger = LineContext2.shouldAutoTrigger(this._editor);
        if (!this._context) {
          this.cancel();
        }
        if (shouldAutoTrigger && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
          this.trigger({ auto: this._context.auto, retrigger: true });
          return;
        }
        if (!this._context.auto) {
          this._completionModel.lineContext = oldLineContext;
          isFrozen = this._completionModel.items.length > 0;
          if (isFrozen && ctx.leadingWord.word.length === 0) {
            this.cancel();
            return;
          }
        } else {
          this.cancel();
          return;
        }
      }
      this._onDidSuggest.fire({
        completionModel: this._completionModel,
        auto: this._context.auto,
        shy: this._context.shy,
        isFrozen
      });
    }
  }
}, "SuggestModel");
SuggestModel = __decorate42([
  __param42(1, IEditorWorkerService),
  __param42(2, IClipboardService),
  __param42(3, ITelemetryService),
  __param42(4, ILogService),
  __param42(5, IContextKeyService),
  __param42(6, IConfigurationService),
  __param42(7, ILanguageFeaturesService)
], SuggestModel);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestOvertypingCapturer.js
init_define_process();
init_lifecycle();
var OvertypingCapturer = class {
  constructor(editor2, suggestModel) {
    this._disposables = new DisposableStore();
    this._lastOvertyped = [];
    this._locked = false;
    this._disposables.add(editor2.onWillType(() => {
      if (this._locked || !editor2.hasModel()) {
        return;
      }
      const selections = editor2.getSelections();
      const selectionsLength = selections.length;
      let willOvertype = false;
      for (let i = 0; i < selectionsLength; i++) {
        if (!selections[i].isEmpty()) {
          willOvertype = true;
          break;
        }
      }
      if (!willOvertype) {
        if (this._lastOvertyped.length !== 0) {
          this._lastOvertyped.length = 0;
        }
        return;
      }
      this._lastOvertyped = [];
      const model = editor2.getModel();
      for (let i = 0; i < selectionsLength; i++) {
        const selection = selections[i];
        if (model.getValueLengthInRange(selection) > OvertypingCapturer._maxSelectionLength) {
          return;
        }
        this._lastOvertyped[i] = { value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber };
      }
    }));
    this._disposables.add(suggestModel.onDidTrigger((e) => {
      this._locked = true;
    }));
    this._disposables.add(suggestModel.onDidCancel((e) => {
      this._locked = false;
    }));
  }
  getLastOvertypedInfo(idx) {
    if (idx >= 0 && idx < this._lastOvertyped.length) {
      return this._lastOvertyped[idx];
    }
    return void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};
__name(OvertypingCapturer, "OvertypingCapturer");
OvertypingCapturer._maxSelectionLength = 51200;

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
init_define_process();
init_dom();
init_async();
init_errors();
init_event();
init_lifecycle();
init_numbers();
init_strings();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetStatus.js
init_define_process();
init_dom();
init_lifecycle();
init_nls();
init_actions2();
init_contextkey();
init_instantiation();
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StatusBarViewItem = class extends MenuEntryActionViewItem {
  updateLabel() {
    const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!kb) {
      return super.updateLabel();
    }
    if (this.label) {
      this.label.textContent = localize("ddd", "{0} ({1})", this._action.label, StatusBarViewItem.symbolPrintEnter(kb));
    }
  }
  static symbolPrintEnter(kb) {
    var _a6;
    return (_a6 = kb.getLabel()) === null || _a6 === void 0 ? void 0 : _a6.replace(/\benter\b/gi, "\u23CE");
  }
};
__name(StatusBarViewItem, "StatusBarViewItem");
var SuggestWidgetStatus = /* @__PURE__ */ __name(class SuggestWidgetStatus2 {
  constructor(container, instantiationService, _menuService, _contextKeyService) {
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._menuDisposables = new DisposableStore();
    this.element = append(container, $(".suggest-status-bar"));
    const actionViewItemProvider = /* @__PURE__ */ __name((action) => {
      return action instanceof MenuItemAction ? instantiationService.createInstance(StatusBarViewItem, action, void 0) : void 0;
    }, "actionViewItemProvider");
    this._leftActions = new ActionBar(this.element, { actionViewItemProvider });
    this._rightActions = new ActionBar(this.element, { actionViewItemProvider });
    this._leftActions.domNode.classList.add("left");
    this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose();
    this.element.remove();
  }
  show() {
    const menu = this._menuService.createMenu(suggestWidgetStatusbarMenu, this._contextKeyService);
    const renderMenu = /* @__PURE__ */ __name(() => {
      const left = [];
      const right = [];
      for (const [group, actions] of menu.getActions()) {
        if (group === "left") {
          left.push(...actions);
        } else {
          right.push(...actions);
        }
      }
      this._leftActions.clear();
      this._leftActions.push(left);
      this._rightActions.clear();
      this._rightActions.push(right);
    }, "renderMenu");
    this._menuDisposables.add(menu.onDidChange(() => renderMenu()));
    this._menuDisposables.add(menu);
  }
  hide() {
    this._menuDisposables.clear();
  }
}, "SuggestWidgetStatus");
SuggestWidgetStatus = __decorate43([
  __param43(1, IInstantiationService),
  __param43(2, IMenuService),
  __param43(3, IContextKeyService)
], SuggestWidgetStatus);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
init_nls();
init_contextkey();
init_instantiation();
init_colorRegistry();
init_theme();
init_themeService();

// ../../node_modules/monaco-editor/esm/vs/base/browser/ui/resizable/resizable.js
init_define_process();
init_dom();
init_event();
init_lifecycle();
var ResizableHTMLElement = class {
  constructor() {
    this._onDidWillResize = new Emitter();
    this.onDidWillResize = this._onDidWillResize.event;
    this._onDidResize = new Emitter();
    this.onDidResize = this._onDidResize.event;
    this._sashListener = new DisposableStore();
    this._size = new Dimension(0, 0);
    this._minSize = new Dimension(0, 0);
    this._maxSize = new Dimension(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    this.domNode = document.createElement("div");
    this._eastSash = new Sash(this.domNode, { getVerticalSashLeft: () => this._size.width }, { orientation: 0 });
    this._westSash = new Sash(this.domNode, { getVerticalSashLeft: () => 0 }, { orientation: 0 });
    this._northSash = new Sash(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: OrthogonalEdge.North });
    this._southSash = new Sash(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: OrthogonalEdge.South });
    this._northSash.orthogonalStartSash = this._westSash;
    this._northSash.orthogonalEndSash = this._eastSash;
    this._southSash.orthogonalStartSash = this._westSash;
    this._southSash.orthogonalEndSash = this._eastSash;
    let currentSize;
    let deltaY = 0;
    let deltaX = 0;
    this._sashListener.add(Event.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      if (currentSize === void 0) {
        this._onDidWillResize.fire();
        currentSize = this._size;
        deltaY = 0;
        deltaX = 0;
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      if (currentSize !== void 0) {
        currentSize = void 0;
        deltaY = 0;
        deltaX = 0;
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(this._eastSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = e.currentX - e.startX;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, east: true });
      }
    }));
    this._sashListener.add(this._westSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = -(e.currentX - e.startX);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, west: true });
      }
    }));
    this._sashListener.add(this._northSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = -(e.currentY - e.startY);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, north: true });
      }
    }));
    this._sashListener.add(this._southSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = e.currentY - e.startY;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, south: true });
      }
    }));
    this._sashListener.add(Event.any(this._eastSash.onDidReset, this._westSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._size.height, this._preferredSize.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidReset, this._southSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._preferredSize.height, this._size.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
  }
  dispose() {
    this._northSash.dispose();
    this._southSash.dispose();
    this._eastSash.dispose();
    this._westSash.dispose();
    this._sashListener.dispose();
    this._onDidResize.dispose();
    this._onDidWillResize.dispose();
    this.domNode.remove();
  }
  enableSashes(north, east, south, west) {
    this._northSash.state = north ? 3 : 0;
    this._eastSash.state = east ? 3 : 0;
    this._southSash.state = south ? 3 : 0;
    this._westSash.state = west ? 3 : 0;
  }
  layout(height = this.size.height, width = this.size.width) {
    const { height: minHeight, width: minWidth } = this._minSize;
    const { height: maxHeight, width: maxWidth } = this._maxSize;
    height = Math.max(minHeight, Math.min(maxHeight, height));
    width = Math.max(minWidth, Math.min(maxWidth, width));
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this.domNode.style.height = height + "px";
      this.domNode.style.width = width + "px";
      this._size = newSize;
      this._northSash.layout();
      this._eastSash.layout();
      this._southSash.layout();
      this._westSash.layout();
    }
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState();
    this._westSash.clearSashHoverState();
    this._northSash.clearSashHoverState();
    this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(value) {
    this._maxSize = value;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(value) {
    this._minSize = value;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(value) {
    this._preferredSize = value;
  }
  get preferredSize() {
    return this._preferredSize;
  }
};
__name(ResizableHTMLElement, "ResizableHTMLElement");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetDetails.js
init_define_process();
init_dom();
init_codicons();
init_event();
init_lifecycle();
init_nls();
init_instantiation();
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function canExpandCompletionItem(item) {
  return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);
}
__name(canExpandCompletionItem, "canExpandCompletionItem");
var SuggestDetailsWidget = /* @__PURE__ */ __name(class SuggestDetailsWidget2 {
  constructor(_editor, instaService) {
    this._editor = _editor;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    this._onDidChangeContents = new Emitter();
    this.onDidChangeContents = this._onDidChangeContents.event;
    this._disposables = new DisposableStore();
    this._renderDisposeable = new DisposableStore();
    this._borderWidth = 1;
    this._size = new Dimension(330, 0);
    this.domNode = $(".suggest-details");
    this.domNode.classList.add("no-docs");
    this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });
    this._body = $(".body");
    this._scrollbar = new DomScrollableElement(this._body, {
      alwaysConsumeMouseWheel: true
    });
    append(this.domNode, this._scrollbar.getDomNode());
    this._disposables.add(this._scrollbar);
    this._header = append(this._body, $(".header"));
    this._close = append(this._header, $("span" + Codicon.close.cssSelector));
    this._close.title = localize("details.close", "Close");
    this._type = append(this._header, $("p.type"));
    this._docs = append(this._body, $("p.docs"));
    this._configureFont();
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45)) {
        this._configureFont();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._renderDisposeable.dispose();
  }
  _configureFont() {
    const options = this._editor.getOptions();
    const fontInfo = options.get(45);
    const fontFamily = fontInfo.getMassagedFontFamily();
    const fontSize = options.get(111) || fontInfo.fontSize;
    const lineHeight = options.get(112) || fontInfo.lineHeight;
    const fontWeight = fontInfo.fontWeight;
    const fontSizePx = `${fontSize}px`;
    const lineHeightPx = `${lineHeight}px`;
    this.domNode.style.fontSize = fontSizePx;
    this.domNode.style.lineHeight = `${lineHeight / fontSize}`;
    this.domNode.style.fontWeight = fontWeight;
    this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    this._type.style.fontFamily = fontFamily;
    this._close.style.height = lineHeightPx;
    this._close.style.width = lineHeightPx;
  }
  getLayoutInfo() {
    const lineHeight = this._editor.getOption(112) || this._editor.getOption(45).lineHeight;
    const borderWidth = this._borderWidth;
    const borderHeight = borderWidth * 2;
    return {
      lineHeight,
      borderWidth,
      borderHeight,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = localize("loading", "Loading...");
    this._docs.textContent = "";
    this.domNode.classList.remove("no-docs", "no-type");
    this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
    this._onDidChangeContents.fire(this);
  }
  renderItem(item, explainMode) {
    var _a6, _b2;
    this._renderDisposeable.clear();
    let { detail, documentation } = item.completion;
    if (explainMode) {
      let md = "";
      md += `score: ${item.score[0]}
`;
      md += `prefix: ${(_a6 = item.word) !== null && _a6 !== void 0 ? _a6 : "(no prefix)"}
`;
      md += `word: ${item.completion.filterText ? item.completion.filterText + " (filterText)" : item.textLabel}
`;
      md += `distance: ${item.distance} (localityBonus-setting)
`;
      md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}
`;
      md += `commit_chars: ${(_b2 = item.completion.commitCharacters) === null || _b2 === void 0 ? void 0 : _b2.join("")}
`;
      documentation = new MarkdownString().appendCodeblock("empty", md);
      detail = `Provider: ${item.provider._debugDisplayName}`;
    }
    if (!explainMode && !canExpandCompletionItem(item)) {
      this.clearContents();
      return;
    }
    this.domNode.classList.remove("no-docs", "no-type");
    if (detail) {
      const cappedDetail = detail.length > 1e5 ? `${detail.substr(0, 1e5)}\u2026` : detail;
      this._type.textContent = cappedDetail;
      this._type.title = cappedDetail;
      show(this._type);
      this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(cappedDetail));
    } else {
      clearNode(this._type);
      this._type.title = "";
      hide(this._type);
      this.domNode.classList.add("no-type");
    }
    clearNode(this._docs);
    if (typeof documentation === "string") {
      this._docs.classList.remove("markdown-docs");
      this._docs.textContent = documentation;
    } else if (documentation) {
      this._docs.classList.add("markdown-docs");
      clearNode(this._docs);
      const renderedContents = this._markdownRenderer.render(documentation);
      this._docs.appendChild(renderedContents.element);
      this._renderDisposeable.add(renderedContents);
      this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
        this._onDidChangeContents.fire(this);
      }));
    }
    this.domNode.style.userSelect = "text";
    this.domNode.tabIndex = -1;
    this._close.onmousedown = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };
    this._close.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._onDidClose.fire();
    };
    this._body.scrollTop = 0;
    this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
    this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs");
    this._type.textContent = "";
    this._docs.textContent = "";
  }
  get size() {
    return this._size;
  }
  layout(width, height) {
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this._size = newSize;
      size(this.domNode, width, height);
    }
    this._scrollbar.scanDomNode();
  }
  scrollDown(much = 8) {
    this._body.scrollTop += much;
  }
  scrollUp(much = 8) {
    this._body.scrollTop -= much;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(width) {
    this._borderWidth = width;
  }
  get borderWidth() {
    return this._borderWidth;
  }
}, "SuggestDetailsWidget");
SuggestDetailsWidget = __decorate44([
  __param44(1, IInstantiationService)
], SuggestDetailsWidget);
var SuggestDetailsOverlay = class {
  constructor(widget, _editor) {
    this.widget = widget;
    this._editor = _editor;
    this._disposables = new DisposableStore();
    this._added = false;
    this._preferAlignAtTop = true;
    this._resizable = new ResizableHTMLElement();
    this._resizable.domNode.classList.add("suggest-details-container");
    this._resizable.domNode.appendChild(widget.domNode);
    this._resizable.enableSashes(false, true, true, false);
    let topLeftNow;
    let sizeNow;
    let deltaTop = 0;
    let deltaLeft = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      topLeftNow = this._topLeft;
      sizeNow = this._resizable.size;
    }));
    this._disposables.add(this._resizable.onDidResize((e) => {
      if (topLeftNow && sizeNow) {
        this.widget.layout(e.dimension.width, e.dimension.height);
        let updateTopLeft = false;
        if (e.west) {
          deltaLeft = sizeNow.width - e.dimension.width;
          updateTopLeft = true;
        }
        if (e.north) {
          deltaTop = sizeNow.height - e.dimension.height;
          updateTopLeft = true;
        }
        if (updateTopLeft) {
          this._applyTopLeft({
            top: topLeftNow.top + deltaTop,
            left: topLeftNow.left + deltaLeft
          });
        }
      }
      if (e.done) {
        topLeftNow = void 0;
        sizeNow = void 0;
        deltaTop = 0;
        deltaLeft = 0;
        this._userSize = e.dimension;
      }
    }));
    this._disposables.add(this.widget.onDidChangeContents(() => {
      var _a6;
      if (this._anchorBox) {
        this._placeAtAnchor(this._anchorBox, (_a6 = this._userSize) !== null && _a6 !== void 0 ? _a6 : this.widget.size, this._preferAlignAtTop);
      }
    }));
  }
  dispose() {
    this._resizable.dispose();
    this._disposables.dispose();
    this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return null;
  }
  show() {
    if (!this._added) {
      this._editor.addOverlayWidget(this);
      this.getDomNode().style.position = "fixed";
      this._added = true;
    }
  }
  hide(sessionEnded = false) {
    this._resizable.clearSashHoverState();
    if (this._added) {
      this._editor.removeOverlayWidget(this);
      this._added = false;
      this._anchorBox = void 0;
      this._topLeft = void 0;
    }
    if (sessionEnded) {
      this._userSize = void 0;
      this.widget.clearContents();
    }
  }
  placeAtAnchor(anchor, preferAlignAtTop) {
    var _a6;
    const anchorBox = anchor.getBoundingClientRect();
    this._anchorBox = anchorBox;
    this._preferAlignAtTop = preferAlignAtTop;
    this._placeAtAnchor(this._anchorBox, (_a6 = this._userSize) !== null && _a6 !== void 0 ? _a6 : this.widget.size, preferAlignAtTop);
  }
  _placeAtAnchor(anchorBox, size2, preferAlignAtTop) {
    var _a6;
    const bodyBox = getClientArea(document.body);
    const info = this.widget.getLayoutInfo();
    const defaultMinSize = new Dimension(220, 2 * info.lineHeight);
    const defaultTop = anchorBox.top;
    const eastPlacement = function() {
      const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);
      const left = -info.borderWidth + anchorBox.left + anchorBox.width;
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    }();
    const westPlacement = function() {
      const width = anchorBox.left - info.borderWidth - info.horizontalPadding;
      const left = Math.max(info.horizontalPadding, anchorBox.left - size2.width - info.borderWidth);
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    }();
    const southPacement = function() {
      const left = anchorBox.left;
      const top = -info.borderWidth + anchorBox.top + anchorBox.height;
      const maxSizeBottom = new Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);
      return { top, left, fit: maxSizeBottom.height - size2.height, maxSizeBottom, maxSizeTop: maxSizeBottom, minSize: defaultMinSize.with(maxSizeBottom.width) };
    }();
    const placements = [eastPlacement, westPlacement, southPacement];
    const placement = (_a6 = placements.find((p) => p.fit >= 0)) !== null && _a6 !== void 0 ? _a6 : placements.sort((a, b) => b.fit - a.fit)[0];
    const bottom = anchorBox.top + anchorBox.height - info.borderHeight;
    let alignAtTop;
    let height = size2.height;
    const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);
    if (height > maxHeight) {
      height = maxHeight;
    }
    let maxSize;
    if (preferAlignAtTop) {
      if (height <= placement.maxSizeTop.height) {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      } else {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      }
    } else {
      if (height <= placement.maxSizeBottom.height) {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      } else {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      }
    }
    this._applyTopLeft({ left: placement.left, top: alignAtTop ? placement.top : bottom - height });
    this.getDomNode().style.position = "fixed";
    this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);
    this._resizable.minSize = placement.minSize;
    this._resizable.maxSize = maxSize;
    this._resizable.layout(height, Math.min(maxSize.width, size2.width));
    this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(topLeft) {
    this._topLeft = topLeft;
    this.getDomNode().style.left = `${this._topLeft.left}px`;
    this.getDomNode().style.top = `${this._topLeft.top}px`;
  }
};
__name(SuggestDetailsOverlay, "SuggestDetailsOverlay");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
init_define_process();
init_dom();
init_codicons();
init_event();
init_lifecycle();
init_uri();
init_languages();

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
init_define_process();
init_network();
init_resources();
init_modesRegistry();

// ../../node_modules/monaco-editor/esm/vs/platform/files/common/files.js
init_define_process();
var FileKind;
(function(FileKind2) {
  FileKind2[FileKind2["FILE"] = 0] = "FILE";
  FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
  FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

// ../../node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
var fileIconDirectoryRegex = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function getIconClasses(modelService, languageService, resource, fileKind) {
  const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (resource) {
    let name;
    if (resource.scheme === Schemas.data) {
      const metadata = DataUri.parseMetaData(resource);
      name = metadata.get(DataUri.META_DATA_LABEL);
    } else {
      const match = resource.path.match(fileIconDirectoryRegex);
      if (match) {
        name = cssEscape(match[2].toLowerCase());
        if (match[1]) {
          classes.push(`${cssEscape(match[1].toLowerCase())}-name-dir-icon`);
        }
      } else {
        name = cssEscape(resource.authority.toLowerCase());
      }
    }
    if (fileKind === FileKind.FOLDER) {
      classes.push(`${name}-name-folder-icon`);
    } else {
      if (name) {
        classes.push(`${name}-name-file-icon`);
        classes.push(`name-file-icon`);
        if (name.length <= 255) {
          const dotSegments = name.split(".");
          for (let i = 1; i < dotSegments.length; i++) {
            classes.push(`${dotSegments.slice(i).join(".")}-ext-file-icon`);
          }
        }
        classes.push(`ext-file-icon`);
      }
      const detectedLanguageId = detectLanguageId(modelService, languageService, resource);
      if (detectedLanguageId) {
        classes.push(`${cssEscape(detectedLanguageId)}-lang-file-icon`);
      }
    }
  }
  return classes;
}
__name(getIconClasses, "getIconClasses");
function detectLanguageId(modelService, languageService, resource) {
  if (!resource) {
    return null;
  }
  let languageId = null;
  if (resource.scheme === Schemas.data) {
    const metadata = DataUri.parseMetaData(resource);
    const mime = metadata.get(DataUri.META_DATA_MIME);
    if (mime) {
      languageId = languageService.getLanguageIdByMimeType(mime);
    }
  } else {
    const model = modelService.getModel(resource);
    if (model) {
      languageId = model.getLanguageId();
    }
  }
  if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {
    return languageId;
  }
  return languageService.guessLanguageIdByFilepathOrFirstLine(resource);
}
__name(detectLanguageId, "detectLanguageId");
function cssEscape(str) {
  return str.replace(/[\11\12\14\15\40]/g, "/");
}
__name(cssEscape, "cssEscape");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidgetRenderer.js
init_model();
init_language();
init_nls();
init_themeService();
var __decorate45 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a3;
function getAriaId(index) {
  return `suggest-aria-id:${index}`;
}
__name(getAriaId, "getAriaId");
var suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight, localize("suggestMoreInfoIcon", "Icon for more information in the suggest widget."));
var _completionItemColor = new (_a3 = /* @__PURE__ */ __name(class ColorExtractor {
  extract(item, out) {
    if (item.textLabel.match(ColorExtractor._regexStrict)) {
      out[0] = item.textLabel;
      return true;
    }
    if (item.completion.detail && item.completion.detail.match(ColorExtractor._regexStrict)) {
      out[0] = item.completion.detail;
      return true;
    }
    if (typeof item.completion.documentation === "string") {
      const match = ColorExtractor._regexRelaxed.exec(item.completion.documentation);
      if (match && (match.index === 0 || match.index + match[0].length === item.completion.documentation.length)) {
        out[0] = match[0];
        return true;
      }
    }
    return false;
  }
}, "ColorExtractor"), _a3._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, _a3._regexStrict = new RegExp(`^${_a3._regexRelaxed.source}$`, "i"), _a3)();
var ItemRenderer = /* @__PURE__ */ __name(class ItemRenderer2 {
  constructor(_editor, _modelService, _languageService, _themeService) {
    this._editor = _editor;
    this._modelService = _modelService;
    this._languageService = _languageService;
    this._themeService = _themeService;
    this._onDidToggleDetails = new Emitter();
    this.onDidToggleDetails = this._onDidToggleDetails.event;
    this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(container) {
    const data = /* @__PURE__ */ Object.create(null);
    data.disposables = new DisposableStore();
    data.root = container;
    data.root.classList.add("show-file-icons");
    data.icon = append(container, $(".icon"));
    data.colorspan = append(data.icon, $("span.colorspan"));
    const text = append(container, $(".contents"));
    const main = append(text, $(".main"));
    data.iconContainer = append(main, $(".icon-label.codicon"));
    data.left = append(main, $("span.left"));
    data.right = append(main, $("span.right"));
    data.iconLabel = new IconLabel(data.left, { supportHighlights: true, supportIcons: true });
    data.disposables.add(data.iconLabel);
    data.parametersLabel = append(data.left, $("span.signature-label"));
    data.qualifierLabel = append(data.left, $("span.qualifier-label"));
    data.detailsLabel = append(data.right, $("span.details-label"));
    data.readMore = append(data.right, $("span.readMore" + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
    data.readMore.title = localize("readMore", "Read More");
    const configureFont = /* @__PURE__ */ __name(() => {
      const options = this._editor.getOptions();
      const fontInfo = options.get(45);
      const fontFamily = fontInfo.getMassagedFontFamily();
      const fontFeatureSettings = fontInfo.fontFeatureSettings;
      const fontSize = options.get(111) || fontInfo.fontSize;
      const lineHeight = options.get(112) || fontInfo.lineHeight;
      const fontWeight = fontInfo.fontWeight;
      const letterSpacing = fontInfo.letterSpacing;
      const fontSizePx = `${fontSize}px`;
      const lineHeightPx = `${lineHeight}px`;
      const letterSpacingPx = `${letterSpacing}px`;
      data.root.style.fontSize = fontSizePx;
      data.root.style.fontWeight = fontWeight;
      data.root.style.letterSpacing = letterSpacingPx;
      main.style.fontFamily = fontFamily;
      main.style.fontFeatureSettings = fontFeatureSettings;
      main.style.lineHeight = lineHeightPx;
      data.icon.style.height = lineHeightPx;
      data.icon.style.width = lineHeightPx;
      data.readMore.style.height = lineHeightPx;
      data.readMore.style.width = lineHeightPx;
    }, "configureFont");
    configureFont();
    data.disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45) || e.hasChanged(111) || e.hasChanged(112)) {
        configureFont();
      }
    }));
    return data;
  }
  renderElement(element, index, data) {
    const { completion } = element;
    data.root.id = getAriaId(index);
    data.colorspan.style.backgroundColor = "";
    const labelOptions = {
      labelEscapeNewLines: true,
      matches: createMatches(element.score)
    };
    const color = [];
    if (completion.kind === 19 && _completionItemColor.extract(element, color)) {
      data.icon.className = "icon customcolor";
      data.iconContainer.className = "icon hide";
      data.colorspan.style.backgroundColor = color[0];
    } else if (completion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      const labelClasses = getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FILE);
      const detailClasses = getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FILE);
      labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
    } else if (completion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      labelOptions.extraClasses = [
        getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FOLDER),
        getIconClasses(this._modelService, this._languageService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FOLDER)
      ].flat();
    } else {
      data.icon.className = "icon hide";
      data.iconContainer.className = "";
      data.iconContainer.classList.add("suggest-icon", ...CSSIcon.asClassNameArray(CompletionItemKinds.toIcon(completion.kind)));
    }
    if (completion.tags && completion.tags.indexOf(1) >= 0) {
      labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
      labelOptions.matches = [];
    }
    data.iconLabel.setLabel(element.textLabel, void 0, labelOptions);
    if (typeof completion.label === "string") {
      data.parametersLabel.textContent = "";
      data.detailsLabel.textContent = stripNewLines(completion.detail || "");
      data.root.classList.add("string-label");
    } else {
      data.parametersLabel.textContent = stripNewLines(completion.label.detail || "");
      data.detailsLabel.textContent = stripNewLines(completion.label.description || "");
      data.root.classList.remove("string-label");
    }
    if (this._editor.getOption(110).showInlineDetails) {
      show(data.detailsLabel);
    } else {
      hide(data.detailsLabel);
    }
    if (canExpandCompletionItem(element)) {
      data.right.classList.add("can-expand-details");
      show(data.readMore);
      data.readMore.onmousedown = (e) => {
        e.stopPropagation();
        e.preventDefault();
      };
      data.readMore.onclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        this._onDidToggleDetails.fire();
      };
    } else {
      data.right.classList.remove("can-expand-details");
      hide(data.readMore);
      data.readMore.onmousedown = null;
      data.readMore.onclick = null;
    }
  }
  disposeTemplate(templateData) {
    templateData.disposables.dispose();
  }
}, "ItemRenderer");
ItemRenderer = __decorate45([
  __param45(1, IModelService),
  __param45(2, ILanguageService),
  __param45(3, IThemeService)
], ItemRenderer);
function stripNewLines(str) {
  return str.replace(/\r\n|\r|\n/g, "");
}
__name(stripNewLines, "stripNewLines");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestWidget.js
var __decorate46 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
registerColor("editorSuggestWidget.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hcDark: editorWidgetBackground, hcLight: editorWidgetBackground }, localize("editorSuggestWidgetBackground", "Background color of the suggest widget."));
registerColor("editorSuggestWidget.border", { dark: editorWidgetBorder, light: editorWidgetBorder, hcDark: editorWidgetBorder, hcLight: editorWidgetBorder }, localize("editorSuggestWidgetBorder", "Border color of the suggest widget."));
var editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", { dark: editorForeground, light: editorForeground, hcDark: editorForeground, hcLight: editorForeground }, localize("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
registerColor("editorSuggestWidget.selectedForeground", { dark: quickInputListFocusForeground, light: quickInputListFocusForeground, hcDark: quickInputListFocusForeground, hcLight: quickInputListFocusForeground }, localize("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
registerColor("editorSuggestWidget.selectedIconForeground", { dark: quickInputListFocusIconForeground, light: quickInputListFocusIconForeground, hcDark: quickInputListFocusIconForeground, hcLight: quickInputListFocusIconForeground }, localize("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
var editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", { dark: quickInputListFocusBackground, light: quickInputListFocusBackground, hcDark: quickInputListFocusBackground, hcLight: quickInputListFocusBackground }, localize("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
registerColor("editorSuggestWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, localize("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
registerColor("editorSuggestWidget.focusHighlightForeground", { dark: listFocusHighlightForeground, light: listFocusHighlightForeground, hcDark: listFocusHighlightForeground, hcLight: listFocusHighlightForeground }, localize("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
registerColor("editorSuggestWidgetStatus.foreground", { dark: transparent(editorSuggestWidgetForeground, 0.5), light: transparent(editorSuggestWidgetForeground, 0.5), hcDark: transparent(editorSuggestWidgetForeground, 0.5), hcLight: transparent(editorSuggestWidgetForeground, 0.5) }, localize("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
var PersistedWidgetSize = class {
  constructor(_service, editor2) {
    this._service = _service;
    this._key = `suggestWidget.size/${editor2.getEditorType()}/${editor2 instanceof EmbeddedCodeEditorWidget}`;
  }
  restore() {
    var _a6;
    const raw = (_a6 = this._service.get(this._key, 0)) !== null && _a6 !== void 0 ? _a6 : "";
    try {
      const obj = JSON.parse(raw);
      if (Dimension.is(obj)) {
        return Dimension.lift(obj);
      }
    } catch (_b2) {
    }
    return void 0;
  }
  store(size2) {
    this._service.store(this._key, JSON.stringify(size2), 0, 1);
  }
  reset() {
    this._service.remove(this._key, 0);
  }
};
__name(PersistedWidgetSize, "PersistedWidgetSize");
var SuggestWidget = /* @__PURE__ */ __name(class SuggestWidget2 {
  constructor(editor2, _storageService, _contextKeyService, _themeService, instantiationService) {
    this.editor = editor2;
    this._storageService = _storageService;
    this._state = 0;
    this._isAuto = false;
    this._pendingLayout = new MutableDisposable();
    this._pendingShowDetails = new MutableDisposable();
    this._ignoreFocusEvents = false;
    this._forceRenderingAbove = false;
    this._explainMode = false;
    this._showTimeout = new TimeoutTimer();
    this._disposables = new DisposableStore();
    this._onDidSelect = new PauseableEmitter();
    this._onDidFocus = new PauseableEmitter();
    this._onDidHide = new Emitter();
    this._onDidShow = new Emitter();
    this.onDidSelect = this._onDidSelect.event;
    this.onDidFocus = this._onDidFocus.event;
    this.onDidHide = this._onDidHide.event;
    this.onDidShow = this._onDidShow.event;
    this._onDetailsKeydown = new Emitter();
    this.onDetailsKeyDown = this._onDetailsKeydown.event;
    this.element = new ResizableHTMLElement();
    this.element.domNode.classList.add("editor-widget", "suggest-widget");
    this._contentWidget = new SuggestContentWidget(this, editor2);
    this._persistedSize = new PersistedWidgetSize(_storageService, editor2);
    class ResizeState {
      constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
        this.persistedSize = persistedSize;
        this.currentSize = currentSize;
        this.persistHeight = persistHeight;
        this.persistWidth = persistWidth;
      }
    }
    __name(ResizeState, "ResizeState");
    let state;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference();
      state = new ResizeState(this._persistedSize.restore(), this.element.size);
    }));
    this._disposables.add(this.element.onDidResize((e) => {
      var _a6, _b2, _c2, _d2;
      this._resize(e.dimension.width, e.dimension.height);
      if (state) {
        state.persistHeight = state.persistHeight || !!e.north || !!e.south;
        state.persistWidth = state.persistWidth || !!e.east || !!e.west;
      }
      if (!e.done) {
        return;
      }
      if (state) {
        const { itemHeight, defaultSize } = this.getLayoutInfo();
        const threshold = Math.round(itemHeight / 2);
        let { width, height } = this.element.size;
        if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
          height = (_b2 = (_a6 = state.persistedSize) === null || _a6 === void 0 ? void 0 : _a6.height) !== null && _b2 !== void 0 ? _b2 : defaultSize.height;
        }
        if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
          width = (_d2 = (_c2 = state.persistedSize) === null || _c2 === void 0 ? void 0 : _c2.width) !== null && _d2 !== void 0 ? _d2 : defaultSize.width;
        }
        this._persistedSize.store(new Dimension(width, height));
      }
      this._contentWidget.unlockPreference();
      state = void 0;
    }));
    this._messageElement = append(this.element.domNode, $(".message"));
    this._listElement = append(this.element.domNode, $(".tree"));
    const details = instantiationService.createInstance(SuggestDetailsWidget, this.editor);
    details.onDidClose(this.toggleDetails, this, this._disposables);
    this._details = new SuggestDetailsOverlay(details, this.editor);
    const applyIconStyle = /* @__PURE__ */ __name(() => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(110).showIcons), "applyIconStyle");
    applyIconStyle();
    const renderer = instantiationService.createInstance(ItemRenderer, this.editor);
    this._disposables.add(renderer);
    this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));
    this._list = new List("SuggestWidget", this._listElement, {
      getHeight: (_element) => this.getLayoutInfo().itemHeight,
      getTemplateId: (_element) => "suggestion"
    }, [renderer], {
      alwaysConsumeMouseWheel: true,
      useShadows: false,
      mouseSupport: false,
      multipleSelectionSupport: false,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => localize("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (item) => {
          let label = item.textLabel;
          if (typeof item.completion.label !== "string") {
            const { detail: detail2, description } = item.completion.label;
            if (detail2 && description) {
              label = localize("label.full", "{0}{1}, {2}", label, detail2, description);
            } else if (detail2) {
              label = localize("label.detail", "{0}{1}", label, detail2);
            } else if (description) {
              label = localize("label.desc", "{0}, {1}", label, description);
            }
          }
          if (!item.isResolved || !this._isDetailsVisible()) {
            return label;
          }
          const { documentation, detail } = item.completion;
          const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
          return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", label, docs);
        }
      }
    });
    this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode);
    const applyStatusBarStyle = /* @__PURE__ */ __name(() => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(110).showStatusBar), "applyStatusBarStyle");
    applyStatusBarStyle();
    this._disposables.add(attachListStyler(this._list, _themeService, {
      listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
      listInactiveFocusOutline: activeContrastBorder
    }));
    this._disposables.add(_themeService.onDidColorThemeChange((t) => this._onThemeChange(t)));
    this._onThemeChange(_themeService.getColorTheme());
    this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
    this._disposables.add(this._list.onDidChangeFocus((e) => this._onListFocus(e)));
    this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));
    this._disposables.add(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(110)) {
        applyStatusBarStyle();
        applyIconStyle();
      }
    }));
    this._ctxSuggestWidgetVisible = Context.Visible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetDetailsVisible = Context.DetailsVisible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetMultipleSuggestions = Context.MultipleSuggestions.bindTo(_contextKeyService);
    this._ctxSuggestWidgetHasFocusedSuggestion = Context.HasFocusedSuggestion.bindTo(_contextKeyService);
    this._disposables.add(addStandardDisposableListener(this._details.widget.domNode, "keydown", (e) => {
      this._onDetailsKeydown.fire(e);
    }));
    this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
  }
  dispose() {
    var _a6;
    this._details.widget.dispose();
    this._details.dispose();
    this._list.dispose();
    this._status.dispose();
    this._disposables.dispose();
    (_a6 = this._loadingTimeout) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._pendingLayout.dispose();
    this._pendingShowDetails.dispose();
    this._showTimeout.dispose();
    this._contentWidget.dispose();
    this.element.dispose();
  }
  _onEditorMouseDown(mouseEvent) {
    if (this._details.widget.domNode.contains(mouseEvent.target.element)) {
      this._details.widget.domNode.focus();
    } else {
      if (this.element.domNode.contains(mouseEvent.target.element)) {
        this.editor.focus();
      }
    }
  }
  _onCursorSelectionChanged() {
    if (this._state !== 0) {
      this._contentWidget.layout();
    }
  }
  _onListMouseDownOrTap(e) {
    if (typeof e.element === "undefined" || typeof e.index === "undefined") {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
    this._select(e.element, e.index);
  }
  _onListSelection(e) {
    if (e.elements.length) {
      this._select(e.elements[0], e.indexes[0]);
    }
  }
  _select(item, index) {
    const completionModel = this._completionModel;
    if (completionModel) {
      this._onDidSelect.fire({ item, index, model: completionModel });
      this.editor.focus();
    }
  }
  _onThemeChange(theme) {
    this._details.widget.borderWidth = isHighContrast(theme.type) ? 2 : 1;
  }
  _onListFocus(e) {
    var _a6;
    if (this._ignoreFocusEvents) {
      return;
    }
    if (!e.elements.length) {
      if (this._currentSuggestionDetails) {
        this._currentSuggestionDetails.cancel();
        this._currentSuggestionDetails = void 0;
        this._focusedItem = void 0;
      }
      this.editor.setAriaOptions({ activeDescendant: void 0 });
      this._ctxSuggestWidgetHasFocusedSuggestion.set(false);
      return;
    }
    if (!this._completionModel) {
      return;
    }
    this._ctxSuggestWidgetHasFocusedSuggestion.set(true);
    const item = e.elements[0];
    const index = e.indexes[0];
    if (item !== this._focusedItem) {
      (_a6 = this._currentSuggestionDetails) === null || _a6 === void 0 ? void 0 : _a6.cancel();
      this._currentSuggestionDetails = void 0;
      this._focusedItem = item;
      this._list.reveal(index);
      this._currentSuggestionDetails = createCancelablePromise((token) => __awaiter33(this, void 0, void 0, function* () {
        const loading = disposableTimeout(() => {
          if (this._isDetailsVisible()) {
            this.showDetails(true);
          }
        }, 250);
        const sub = token.onCancellationRequested(() => loading.dispose());
        const result = yield item.resolve(token);
        loading.dispose();
        sub.dispose();
        return result;
      }));
      this._currentSuggestionDetails.then(() => {
        if (index >= this._list.length || item !== this._list.element(index)) {
          return;
        }
        this._ignoreFocusEvents = true;
        this._list.splice(index, 1, [item]);
        this._list.setFocus([index]);
        this._ignoreFocusEvents = false;
        if (this._isDetailsVisible()) {
          this.showDetails(false);
        } else {
          this.element.domNode.classList.remove("docs-side");
        }
        this.editor.setAriaOptions({ activeDescendant: getAriaId(index) });
      }).catch(onUnexpectedError);
    }
    this._onDidFocus.fire({ item, index, model: this._completionModel });
  }
  _setState(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.element.domNode.classList.toggle("frozen", state === 4);
    this.element.domNode.classList.remove("message");
    switch (state) {
      case 0:
        hide(this._messageElement, this._listElement, this._status.element);
        this._details.hide(true);
        this._status.hide();
        this._contentWidget.hide();
        this._ctxSuggestWidgetVisible.reset();
        this._ctxSuggestWidgetMultipleSuggestions.reset();
        this._ctxSuggestWidgetHasFocusedSuggestion.reset();
        this._showTimeout.cancel();
        this.element.domNode.classList.remove("visible");
        this._list.splice(0, this._list.length);
        this._focusedItem = void 0;
        this._cappedHeight = void 0;
        this._explainMode = false;
        break;
      case 1:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget2.LOADING_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        break;
      case 2:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget2.NO_SUGGESTIONS_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        break;
      case 3:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 4:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 5:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._details.show();
        this._show();
        break;
    }
  }
  _show() {
    this._status.show();
    this._contentWidget.show();
    this._layout(this._persistedSize.restore());
    this._ctxSuggestWidgetVisible.set(true);
    this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible");
      this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(auto, delay) {
    if (this._state !== 0) {
      return;
    }
    this._contentWidget.setPosition(this.editor.getPosition());
    this._isAuto = !!auto;
    if (!this._isAuto) {
      this._loadingTimeout = disposableTimeout(() => this._setState(1), delay);
    }
  }
  showSuggestions(completionModel, selectionIndex, isFrozen, isAuto, noFocus) {
    var _a6, _b2;
    this._contentWidget.setPosition(this.editor.getPosition());
    (_a6 = this._loadingTimeout) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    (_b2 = this._currentSuggestionDetails) === null || _b2 === void 0 ? void 0 : _b2.cancel();
    this._currentSuggestionDetails = void 0;
    if (this._completionModel !== completionModel) {
      this._completionModel = completionModel;
    }
    if (isFrozen && this._state !== 2 && this._state !== 0) {
      this._setState(4);
      return;
    }
    const visibleCount = this._completionModel.items.length;
    const isEmpty = visibleCount === 0;
    this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
    if (isEmpty) {
      this._setState(isAuto ? 0 : 2);
      this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0;
    this._onDidFocus.pause();
    this._onDidSelect.pause();
    try {
      this._list.splice(0, this._list.length, this._completionModel.items);
      this._setState(isFrozen ? 4 : 3);
      this._list.reveal(selectionIndex, 0);
      if (!noFocus) {
        this._list.setFocus([selectionIndex]);
      }
    } finally {
      this._onDidFocus.resume();
      this._onDidSelect.resume();
    }
    this._pendingLayout.value = runAtThisOrScheduleAtNextAnimationFrame(() => {
      this._pendingLayout.clear();
      this._layout(this.element.size);
      this._details.widget.domNode.classList.remove("focused");
    });
  }
  focusSelected() {
    if (this._list.length > 0) {
      this._list.setFocus([0]);
    }
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageDown();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNextPage();
        return true;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNext(1, true);
        return true;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollBottom();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusLast();
        return true;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageUp();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPreviousPage();
        return true;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPrevious(1, true);
        return false;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollTop();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusFirst();
        return true;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel && this._list.getFocus().length > 0) {
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
    }
    return void 0;
  }
  toggleDetailsFocus() {
    if (this._state === 5) {
      this._setState(3);
      this._details.widget.domNode.classList.remove("focused");
    } else if (this._state === 3 && this._isDetailsVisible()) {
      this._setState(5);
      this._details.widget.domNode.classList.add("focused");
    }
  }
  toggleDetails() {
    if (this._isDetailsVisible()) {
      this._pendingShowDetails.clear();
      this._ctxSuggestWidgetDetailsVisible.set(false);
      this._setDetailsVisible(false);
      this._details.hide();
      this.element.domNode.classList.remove("shows-details");
    } else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4)) {
      this._ctxSuggestWidgetDetailsVisible.set(true);
      this._setDetailsVisible(true);
      this.showDetails(false);
    }
  }
  showDetails(loading) {
    this._pendingShowDetails.value = runAtThisOrScheduleAtNextAnimationFrame(() => {
      this._pendingShowDetails.clear();
      this._details.show();
      if (loading) {
        this._details.widget.renderLoading();
      } else {
        this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);
      }
      this._positionDetails();
      this.editor.focus();
      this.element.domNode.classList.add("shows-details");
    });
  }
  toggleExplainMode() {
    if (this._list.getFocusedElements()[0]) {
      this._explainMode = !this._explainMode;
      if (!this._isDetailsVisible()) {
        this.toggleDetails();
      } else {
        this.showDetails(false);
      }
    }
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    var _a6;
    this._pendingLayout.clear();
    this._pendingShowDetails.clear();
    (_a6 = this._loadingTimeout) === null || _a6 === void 0 ? void 0 : _a6.dispose();
    this._setState(0);
    this._onDidHide.fire(this);
    this.element.clearSashHoverState();
    const dim = this._persistedSize.restore();
    const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    if (dim && dim.height < minPersistedHeight) {
      this._persistedSize.store(dim.with(void 0, minPersistedHeight));
    }
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(position) {
    if (position === null) {
      if (this._isDetailsVisible()) {
        this._details.hide();
      }
      return;
    }
    if (this._state === 2 || this._state === 1) {
      return;
    }
    if (this._isDetailsVisible()) {
      this._details.show();
    }
    this._positionDetails();
  }
  _layout(size2) {
    var _a6, _b2, _c2;
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this.editor.getDomNode()) {
      return;
    }
    const bodyBox = getClientArea(document.body);
    const info = this.getLayoutInfo();
    if (!size2) {
      size2 = info.defaultSize;
    }
    let height = size2.height;
    let width = size2.width;
    this._status.element.style.height = `${info.itemHeight}px`;
    if (this._state === 2 || this._state === 1) {
      height = info.itemHeight + info.borderHeight;
      width = info.defaultSize.width / 2;
      this.element.enableSashes(false, false, false, false);
      this.element.minSize = this.element.maxSize = new Dimension(width, height);
      this._contentWidget.setPreference(2);
    } else {
      const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
      if (width > maxWidth) {
        width = maxWidth;
      }
      const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
      const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
      const minHeight = info.itemHeight + info.statusBarHeight;
      const editorBox = getDomNodePagePosition(this.editor.getDomNode());
      const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
      const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
      const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
      const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
      const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
      let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
      if (height === ((_a6 = this._cappedHeight) === null || _a6 === void 0 ? void 0 : _a6.capped)) {
        height = this._cappedHeight.wanted;
      }
      if (height < minHeight) {
        height = minHeight;
      }
      if (height > maxHeight) {
        height = maxHeight;
      }
      const forceRenderingAboveRequiredSpace = 150;
      if (height > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace) {
        this._contentWidget.setPreference(1);
        this.element.enableSashes(true, true, false, false);
        maxHeight = maxHeightAbove;
      } else {
        this._contentWidget.setPreference(2);
        this.element.enableSashes(false, true, true, false);
        maxHeight = maxHeightBelow;
      }
      this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
      this.element.maxSize = new Dimension(maxWidth, maxHeight);
      this.element.minSize = new Dimension(220, minHeight);
      this._cappedHeight = height === fullHeight ? { wanted: (_c2 = (_b2 = this._cappedHeight) === null || _b2 === void 0 ? void 0 : _b2.wanted) !== null && _c2 !== void 0 ? _c2 : size2.height, capped: height } : void 0;
    }
    this._resize(width, height);
  }
  _resize(width, height) {
    const { width: maxWidth, height: maxHeight } = this.element.maxSize;
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    const { statusBarHeight } = this.getLayoutInfo();
    this._list.layout(height - statusBarHeight, width);
    this._listElement.style.height = `${height - statusBarHeight}px`;
    this.element.layout(height, width);
    this._contentWidget.layout();
    this._positionDetails();
  }
  _positionDetails() {
    var _a6;
    if (this._isDetailsVisible()) {
      this._details.placeAtAnchor(this.element.domNode, ((_a6 = this._contentWidget.getPosition()) === null || _a6 === void 0 ? void 0 : _a6.preference[0]) === 2);
    }
  }
  getLayoutInfo() {
    const fontInfo = this.editor.getOption(45);
    const itemHeight = clamp(this.editor.getOption(112) || fontInfo.lineHeight, 8, 1e3);
    const statusBarHeight = !this.editor.getOption(110).showStatusBar || this._state === 2 || this._state === 1 ? 0 : itemHeight;
    const borderWidth = this._details.widget.borderWidth;
    const borderHeight = 2 * borderWidth;
    return {
      itemHeight,
      statusBarHeight,
      borderWidth,
      borderHeight,
      typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight + borderHeight)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, false);
  }
  _setDetailsVisible(value) {
    this._storageService.store("expandSuggestionDocs", value, 0, 0);
  }
  forceRenderingAbove() {
    if (!this._forceRenderingAbove) {
      this._forceRenderingAbove = true;
      this._layout(this._persistedSize.restore());
    }
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = false;
  }
}, "SuggestWidget");
SuggestWidget.LOADING_MESSAGE = localize("suggestWidget.loading", "Loading...");
SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize("suggestWidget.noSuggestions", "No suggestions.");
SuggestWidget = __decorate46([
  __param46(1, IStorageService),
  __param46(2, IContextKeyService),
  __param46(3, IThemeService),
  __param46(4, IInstantiationService)
], SuggestWidget);
var SuggestContentWidget = class {
  constructor(_widget, _editor) {
    this._widget = _widget;
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._preferenceLocked = false;
    this._added = false;
    this._hidden = false;
  }
  dispose() {
    if (this._added) {
      this._added = false;
      this._editor.removeContentWidget(this);
    }
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = false;
    if (!this._added) {
      this._added = true;
      this._editor.addContentWidget(this);
    }
  }
  hide() {
    if (!this._hidden) {
      this._hidden = true;
      this.layout();
    }
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this._hidden || !this._position || !this._preference) {
      return null;
    }
    return {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height, width } = this._widget.element.size;
    const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();
    return new Dimension(width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);
  }
  afterRender(position) {
    this._widget._afterRender(position);
  }
  setPreference(preference) {
    if (!this._preferenceLocked) {
      this._preference = preference;
    }
  }
  lockPreference() {
    this._preferenceLocked = true;
  }
  unlockPreference() {
    this._preferenceLocked = false;
  }
  setPosition(position) {
    this._position = position;
  }
};
__name(SuggestContentWidget, "SuggestContentWidget");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestController.js
init_telemetry();
init_resources();
init_hash();
var __decorate47 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _sticky = false;
var LineSuffix = class {
  constructor(_model, _position) {
    this._model = _model;
    this._position = _position;
    const maxColumn = _model.getLineMaxColumn(_position.lineNumber);
    if (maxColumn !== _position.column) {
      const offset = _model.getOffsetAt(_position);
      const end = _model.getPositionAt(offset + 1);
      this._marker = _model.deltaDecorations([], [{
        range: Range.fromPositions(_position, end),
        options: { description: "suggest-line-suffix", stickiness: 1 }
      }]);
    }
  }
  dispose() {
    if (this._marker && !this._model.isDisposed()) {
      this._model.deltaDecorations(this._marker, []);
    }
  }
  delta(position) {
    if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {
      return 0;
    }
    if (this._marker) {
      const range = this._model.getDecorationRange(this._marker[0]);
      const end = this._model.getOffsetAt(range.getStartPosition());
      return end - this._model.getOffsetAt(position);
    } else {
      return this._model.getLineMaxColumn(position.lineNumber) - position.column;
    }
  }
};
__name(LineSuffix, "LineSuffix");
var SuggestController = /* @__PURE__ */ __name(class SuggestController2 {
  static get(editor2) {
    return editor2.getContribution(SuggestController2.ID);
  }
  constructor(editor2, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService, _telemetryService) {
    this._memoryService = _memoryService;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
    this._lineSuffix = new MutableDisposable();
    this._toDispose = new DisposableStore();
    this._selectors = new PriorityRegistry((s) => s.priority);
    this._telemetryGate = 0;
    this.editor = editor2;
    this.model = _instantiationService.createInstance(SuggestModel, this.editor);
    this._selectors.register({
      priority: 0,
      select: (model, pos, items) => this._memoryService.select(model, pos, items)
    });
    const ctxInsertMode = Context.InsertMode.bindTo(_contextKeyService);
    ctxInsertMode.set(editor2.getOption(110).insertMode);
    this.model.onDidTrigger(() => ctxInsertMode.set(editor2.getOption(110).insertMode));
    this.widget = this._toDispose.add(new IdleValue(() => {
      const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
      this._toDispose.add(widget);
      this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(item, 0), this));
      const commitCharacterController = new CommitCharacterController(this.editor, widget, this.model, (item) => this._insertSuggestion(item, 2));
      this._toDispose.add(commitCharacterController);
      const ctxMakesTextEdit = Context.MakesTextEdit.bindTo(this._contextKeyService);
      const ctxHasInsertAndReplace = Context.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
      const ctxCanResolve = Context.CanResolve.bindTo(this._contextKeyService);
      this._toDispose.add(toDisposable(() => {
        ctxMakesTextEdit.reset();
        ctxHasInsertAndReplace.reset();
        ctxCanResolve.reset();
      }));
      this._toDispose.add(widget.onDidFocus(({ item }) => {
        const position = this.editor.getPosition();
        const startColumn = item.editStart.column;
        const endColumn = position.column;
        let value = true;
        if (this.editor.getOption(1) === "smart" && this.model.state === 2 && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) {
          const oldText = this.editor.getModel().getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn,
            endLineNumber: position.lineNumber,
            endColumn
          });
          value = oldText !== item.completion.insertText;
        }
        ctxMakesTextEdit.set(value);
        ctxHasInsertAndReplace.set(!Position.equals(item.editInsertEnd, item.editReplaceEnd));
        ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
      }));
      this._toDispose.add(widget.onDetailsKeyDown((e) => {
        if (e.toKeybinding().equals(new SimpleKeybinding(true, false, false, false, 33)) || isMacintosh && e.toKeybinding().equals(new SimpleKeybinding(false, false, false, true, 33))) {
          e.stopPropagation();
          return;
        }
        if (!e.toKeybinding().isModifierKey()) {
          this.editor.focus();
        }
      }));
      return widget;
    }));
    this._overtypingCapturer = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
    }));
    this._alternatives = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
    }));
    this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor2));
    this._toDispose.add(this.model.onDidTrigger((e) => {
      this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
      this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
    }));
    this._toDispose.add(this.model.onDidSuggest((e) => {
      if (e.shy) {
        return;
      }
      let index = -1;
      for (const selector of this._selectors.itemsOrderedByPriorityDesc) {
        index = selector.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
        if (index !== -1) {
          break;
        }
      }
      if (index === -1) {
        index = 0;
      }
      this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.auto, e.auto && !this.editor.getOption(110).selectQuickSuggestions);
    }));
    this._toDispose.add(this.model.onDidCancel((e) => {
      if (!e.retrigger) {
        this.widget.value.hideWidget();
      }
    }));
    this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      if (!_sticky) {
        this.model.cancel();
        this.model.clear();
      }
    }));
    const acceptSuggestionsOnEnter = Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
    const updateFromConfig = /* @__PURE__ */ __name(() => {
      const acceptSuggestionOnEnter = this.editor.getOption(1);
      acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
    }, "updateFromConfig");
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
    updateFromConfig();
  }
  dispose() {
    this._alternatives.dispose();
    this._toDispose.dispose();
    this.widget.dispose();
    this.model.dispose();
    this._lineSuffix.dispose();
  }
  _insertSuggestion(event, flags) {
    if (!event || !event.item) {
      this._alternatives.value.reset();
      this.model.cancel();
      this.model.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const snippetController = SnippetController2.get(this.editor);
    if (!snippetController) {
      return;
    }
    const model = this.editor.getModel();
    const modelVersionNow = model.getAlternativeVersionId();
    const { item } = event;
    const tasks = [];
    const cts = new CancellationTokenSource();
    if (!(flags & 1)) {
      this.editor.pushUndoStop();
    }
    const info = this.getOverwriteInfo(item, Boolean(flags & 8));
    this._memoryService.memorize(model, this.editor.getPosition(), item);
    if (Array.isArray(item.completion.additionalTextEdits)) {
      const scrollState = StableEditorScrollState.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit) => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));
      scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!item.isResolved) {
      const sw = new StopWatch(true);
      let position;
      const docListener = model.onDidChangeContent((e) => {
        if (e.isFlush) {
          cts.cancel();
          docListener.dispose();
          return;
        }
        for (const change of e.changes) {
          const thisPosition = Range.getEndPosition(change.range);
          if (!position || Position.isBefore(thisPosition, position)) {
            position = thisPosition;
          }
        }
      });
      const oldFlags = flags;
      flags |= 2;
      let didType = false;
      const typeListener = this.editor.onWillType(() => {
        typeListener.dispose();
        didType = true;
        if (!(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
      });
      tasks.push(item.resolve(cts.token).then(() => {
        if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {
          return false;
        }
        if (position && item.completion.additionalTextEdits.some((edit) => Position.isBefore(position, Range.getStartPosition(edit.range)))) {
          return false;
        }
        if (didType) {
          this.editor.pushUndoStop();
        }
        const scrollState = StableEditorScrollState.capture(this.editor);
        this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit) => EditOperation.replaceMove(Range.lift(edit.range), edit.text)));
        scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
        if (didType || !(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
        return true;
      }).then((applied) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
        docListener.dispose();
        typeListener.dispose();
      }));
    }
    let { insertText } = item.completion;
    if (!(item.completion.insertTextRules & 4)) {
      insertText = SnippetParser.escape(insertText);
    }
    this.model.cancel();
    snippetController.insert(insertText, {
      overwriteBefore: info.overwriteBefore,
      overwriteAfter: info.overwriteAfter,
      undoStopBefore: false,
      undoStopAfter: false,
      adjustWhitespace: !(item.completion.insertTextRules & 1),
      clipboardText: event.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    });
    if (!(flags & 2)) {
      this.editor.pushUndoStop();
    }
    if (item.completion.command) {
      if (item.completion.command.id === TriggerSuggestAction.id) {
        this.model.trigger({ auto: true, retrigger: true });
      } else {
        tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch(onUnexpectedError));
      }
    }
    if (flags & 4) {
      this._alternatives.value.set(event, (next) => {
        cts.cancel();
        while (model.canUndo()) {
          if (modelVersionNow !== model.getAlternativeVersionId()) {
            model.undo();
          }
          this._insertSuggestion(next, 1 | 2 | (flags & 8 ? 8 : 0));
          break;
        }
      });
    }
    this._alertCompletionItem(item);
    Promise.all(tasks).finally(() => {
      this._reportSuggestionAcceptedTelemetry(item, model, event);
      this.model.clear();
      cts.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(item, model, acceptedSuggestion) {
    var _a6;
    if (this._telemetryGate++ % 100 !== 0) {
      return;
    }
    const providerId = item.extensionId ? item.extensionId.value : ((_a6 = acceptedSuggestion.item.provider._debugDisplayName) !== null && _a6 !== void 0 ? _a6 : "unknown").split("(", 1)[0].toLowerCase();
    this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      providerId,
      kind: item.completion.kind,
      basenameHash: hash(basename2(model.uri)).toString(16),
      languageId: model.getLanguageId(),
      fileExtension: extname(model.uri)
    });
  }
  getOverwriteInfo(item, toggleMode) {
    assertType(this.editor.hasModel());
    let replace = this.editor.getOption(110).insertMode === "replace";
    if (toggleMode) {
      replace = !replace;
    }
    const overwriteBefore = item.position.column - item.editStart.column;
    const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
    const columnDelta = this.editor.getPosition().column - item.position.column;
    const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: overwriteBefore + columnDelta,
      overwriteAfter: overwriteAfter + suffixDelta
    };
  }
  _alertCompletionItem(item) {
    if (isNonEmptyArray(item.completion.additionalTextEdits)) {
      const msg = localize("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
      alert(msg);
    }
  }
  triggerSuggest(onlyFrom, auto, noFilter) {
    if (this.editor.hasModel()) {
      this.model.trigger({
        auto: auto !== null && auto !== void 0 ? auto : false,
        completionOptions: { providerFilter: onlyFrom, kindFilter: noFilter ? /* @__PURE__ */ new Set() : void 0 }
      });
      this.editor.revealPosition(this.editor.getPosition(), 0);
      this.editor.focus();
    }
  }
  triggerSuggestAndAcceptBest(arg) {
    if (!this.editor.hasModel()) {
      return;
    }
    const positionNow = this.editor.getPosition();
    const fallback = /* @__PURE__ */ __name(() => {
      if (positionNow.equals(this.editor.getPosition())) {
        this._commandService.executeCommand(arg.fallback);
      }
    }, "fallback");
    const makesTextEdit = /* @__PURE__ */ __name((item) => {
      if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) {
        return true;
      }
      const position = this.editor.getPosition();
      const startColumn = item.editStart.column;
      const endColumn = position.column;
      if (endColumn - startColumn !== item.completion.insertText.length) {
        return true;
      }
      const textNow = this.editor.getModel().getValueInRange({
        startLineNumber: position.lineNumber,
        startColumn,
        endLineNumber: position.lineNumber,
        endColumn
      });
      return textNow !== item.completion.insertText;
    }, "makesTextEdit");
    Event.once(this.model.onDidTrigger)((_) => {
      const listener = [];
      Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        dispose(listener);
        fallback();
      }, void 0, listener);
      this.model.onDidSuggest(({ completionModel }) => {
        dispose(listener);
        if (completionModel.items.length === 0) {
          fallback();
          return;
        }
        const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
        const item = completionModel.items[index];
        if (!makesTextEdit(item)) {
          fallback();
          return;
        }
        this.editor.pushUndoStop();
        this._insertSuggestion({ index, item, model: completionModel }, 4 | 1 | 2);
      }, void 0, listener);
    });
    this.model.trigger({ auto: false, shy: true });
    this.editor.revealPosition(positionNow, 0);
    this.editor.focus();
  }
  acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
    const item = this.widget.value.getFocusedItem();
    let flags = 0;
    if (keepAlternativeSuggestions) {
      flags |= 4;
    }
    if (alternativeOverwriteConfig) {
      flags |= 8;
    }
    this._insertSuggestion(item, flags);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel();
    this.model.clear();
    this.widget.value.hideWidget();
  }
  focusSuggestion() {
    this.widget.value.focusSelected();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    this.widget.value.forceRenderingAbove();
  }
  stopForceRenderingAbove() {
    if (!this.widget.isInitialized) {
      return;
    }
    this.widget.value.stopForceRenderingAbove();
  }
  registerSelector(selector) {
    return this._selectors.register(selector);
  }
}, "SuggestController");
SuggestController.ID = "editor.contrib.suggestController";
SuggestController = __decorate47([
  __param47(1, ISuggestMemoryService),
  __param47(2, ICommandService),
  __param47(3, IContextKeyService),
  __param47(4, IInstantiationService),
  __param47(5, ILogService),
  __param47(6, ITelemetryService)
], SuggestController);
var PriorityRegistry = class {
  constructor(prioritySelector) {
    this.prioritySelector = prioritySelector;
    this._items = new Array();
  }
  register(value) {
    if (this._items.indexOf(value) !== -1) {
      throw new Error("Value is already registered");
    }
    this._items.push(value);
    this._items.sort((s1, s2) => this.prioritySelector(s2) - this.prioritySelector(s1));
    return {
      dispose: () => {
        const idx = this._items.indexOf(value);
        if (idx >= 0) {
          this._items.splice(idx, 1);
        }
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
};
__name(PriorityRegistry, "PriorityRegistry");
var TriggerSuggestAction = class extends EditorAction {
  constructor() {
    super({
      id: TriggerSuggestAction.id,
      label: localize("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 10,
        secondary: [2048 | 39],
        mac: { primary: 256 | 10, secondary: [512 | 9, 2048 | 39] },
        weight: 100
      }
    });
  }
  run(_accessor, editor2, args) {
    const controller = SuggestController.get(editor2);
    if (!controller) {
      return;
    }
    let auto;
    if (args && typeof args === "object") {
      if (args.auto === true) {
        auto = true;
      }
    }
    controller.triggerSuggest(void 0, auto, void 0);
  }
};
__name(TriggerSuggestAction, "TriggerSuggestAction");
TriggerSuggestAction.id = "editor.action.triggerSuggest";
registerEditorContribution(SuggestController.ID, SuggestController, 2);
registerEditorAction(TriggerSuggestAction);
var weight2 = 100 + 90;
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
  id: "acceptSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion),
  handler(x) {
    x.acceptSelectedSuggestion(true, false);
  },
  kbOpts: [{
    primary: 2,
    kbExpr: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
    weight: weight2
  }, {
    primary: 3,
    kbExpr: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.AcceptSuggestionsOnEnter, Context.MakesTextEdit),
    weight: weight2
  }],
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    title: localize("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: Context.HasInsertAndReplaceRange.toNegated()
  }, {
    menuId: suggestWidgetStatusbarMenu,
    title: localize("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert"))
  }, {
    menuId: suggestWidgetStatusbarMenu,
    title: localize("accept.replace", "Replace"),
    group: "left",
    order: 1,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace"))
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.HasFocusedSuggestion),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 3,
    secondary: [1024 | 2]
  },
  handler(x) {
    x.acceptSelectedSuggestion(false, true);
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert")),
    title: localize("accept.replace", "Replace")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace")),
    title: localize("accept.insert", "Insert")
  }]
}));
CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
registerEditorCommand(new SuggestCommand({
  id: "hideSuggestWidget",
  precondition: Context.Visible,
  handler: (x) => x.cancelSuggestWidget(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 18,
    secondary: [2048 | 18],
    mac: { primary: 18, secondary: [2048 | 18, 256 | 44] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectNextPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 12,
    secondary: [2048 | 12]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectLastSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectLastSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 16,
    secondary: [2048 | 16],
    mac: { primary: 16, secondary: [2048 | 16, 256 | 46] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectPrevPageSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 11,
    secondary: [2048 | 11]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectFirstSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectFirstSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "focusSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion.negate(), ContextKeyExpr.equals("config.editor.suggest.selectQuickSuggestions", false)),
  handler: (x) => x.focusSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    secondary: [2048 | 39],
    mac: { primary: 256 | 10, secondary: [2048 | 39] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionDetails",
  precondition: ContextKeyExpr.and(Context.Visible, Context.HasFocusedSuggestion),
  handler: (x) => x.toggleSuggestionDetails(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    secondary: [2048 | 39],
    mac: { primary: 256 | 10, secondary: [2048 | 39] }
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible, Context.CanResolve),
    title: localize("detail.more", "show less")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible.toNegated(), Context.CanResolve),
    title: localize("detail.less", "show more")
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleExplainMode",
  precondition: Context.Visible,
  handler: (x) => x.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2048 | 85
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionFocus",
  precondition: Context.Visible,
  handler: (x) => x.toggleSuggestionFocus(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 512 | 10,
    mac: { primary: 256 | 512 | 10 }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertBestCompletion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x, arg) => {
    x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({ fallback: "tab" }, arg) : { fallback: "tab" });
  },
  kbOpts: {
    weight: weight2,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertNextSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptNextSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertPrevSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptPrevSuggestion(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 2
  }
}));
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: localize("suggest.reset.label", "Reset Suggest Widget Size"),
      alias: "Reset Suggest Widget Size",
      precondition: void 0
    });
  }
  run(_accessor, editor2) {
    var _a6;
    (_a6 = SuggestController.get(editor2)) === null || _a6 === void 0 ? void 0 : _a6.resetWidgetSize();
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetInlineCompletionProvider.js
var SuggestWidgetInlineCompletionProvider = class extends Disposable {
  get state() {
    if (!this._isActive) {
      return void 0;
    }
    return { selectedItem: this._currentSuggestItemInfo };
  }
  constructor(editor2, suggestControllerPreselector) {
    super();
    this.editor = editor2;
    this.suggestControllerPreselector = suggestControllerPreselector;
    this.isSuggestWidgetVisible = false;
    this.isShiftKeyPressed = false;
    this._isActive = false;
    this._currentSuggestItemInfo = void 0;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this._register(editor2.onKeyDown((e) => {
      if (e.shiftKey && !this.isShiftKeyPressed) {
        this.isShiftKeyPressed = true;
        this.update(this._isActive);
      }
    }));
    this._register(editor2.onKeyUp((e) => {
      if (e.shiftKey && this.isShiftKeyPressed) {
        this.isShiftKeyPressed = false;
        this.update(this._isActive);
      }
    }));
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      this._register(suggestController.registerSelector({
        priority: 100,
        select: (model, pos, suggestItems) => {
          const textModel = this.editor.getModel();
          const normalizedItemToPreselect = minimizeInlineCompletion(textModel, this.suggestControllerPreselector());
          if (!normalizedItemToPreselect) {
            return -1;
          }
          const position = Position.lift(pos);
          const candidates = suggestItems.map((suggestItem, index) => {
            const inlineSuggestItem = suggestionToSuggestItemInfo(suggestController, position, suggestItem, this.isShiftKeyPressed);
            const normalizedSuggestItem = minimizeInlineCompletion(textModel, inlineSuggestItem === null || inlineSuggestItem === void 0 ? void 0 : inlineSuggestItem.normalizedInlineCompletion);
            if (!normalizedSuggestItem) {
              return void 0;
            }
            const valid = rangeStartsWith(normalizedItemToPreselect.range, normalizedSuggestItem.range) && normalizedItemToPreselect.insertText.startsWith(normalizedSuggestItem.insertText);
            return { index, valid, prefixLength: normalizedSuggestItem.insertText.length, suggestItem };
          }).filter((item) => item && item.valid);
          const result = findMaxBy(candidates, compareBy((s) => s.prefixLength, numberComparator));
          return result ? result.index : -1;
        }
      }));
      let isBoundToSuggestWidget = false;
      const bindToSuggestWidget = /* @__PURE__ */ __name(() => {
        if (isBoundToSuggestWidget) {
          return;
        }
        isBoundToSuggestWidget = true;
        this._register(suggestController.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
        this._register(suggestController.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = false;
          this.update(false);
        }));
        this._register(suggestController.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
      }, "bindToSuggestWidget");
      this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
        bindToSuggestWidget();
      }));
    }
    this.update(this._isActive);
  }
  update(newActive) {
    const newInlineCompletion = this.getSuggestItemInfo();
    let shouldFire = false;
    if (!suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
      this._currentSuggestItemInfo = newInlineCompletion;
      shouldFire = true;
    }
    if (this._isActive !== newActive) {
      this._isActive = newActive;
      shouldFire = true;
    }
    if (shouldFire) {
      this.onDidChangeEmitter.fire();
    }
  }
  getSuggestItemInfo() {
    const suggestController = SuggestController.get(this.editor);
    if (!suggestController) {
      return void 0;
    }
    if (!this.isSuggestWidgetVisible) {
      return void 0;
    }
    const focusedItem = suggestController.widget.value.getFocusedItem();
    if (!focusedItem) {
      return void 0;
    }
    return suggestionToSuggestItemInfo(suggestController, this.editor.getPosition(), focusedItem.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController === null || suggestController === void 0 ? void 0 : suggestController.stopForceRenderingAbove();
  }
  forceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    suggestController === null || suggestController === void 0 ? void 0 : suggestController.forceRenderingAbove();
  }
};
__name(SuggestWidgetInlineCompletionProvider, "SuggestWidgetInlineCompletionProvider");
function rangeStartsWith(rangeToTest, prefix) {
  return prefix.startLineNumber === rangeToTest.startLineNumber && prefix.startColumn === rangeToTest.startColumn && (prefix.endLineNumber < rangeToTest.endLineNumber || prefix.endLineNumber === rangeToTest.endLineNumber && prefix.endColumn <= rangeToTest.endColumn);
}
__name(rangeStartsWith, "rangeStartsWith");
function suggestItemInfoEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.completionItemKind === b.completionItemKind && a.isSnippetText === b.isSnippetText && normalizedInlineCompletionsEquals(a.normalizedInlineCompletion, b.normalizedInlineCompletion);
}
__name(suggestItemInfoEquals, "suggestItemInfoEquals");
function suggestionToSuggestItemInfo(suggestController, position, item, toggleMode) {
  if (Array.isArray(item.completion.additionalTextEdits) && item.completion.additionalTextEdits.length > 0) {
    return {
      completionItemKind: item.completion.kind,
      isSnippetText: false,
      normalizedInlineCompletion: {
        range: Range.fromPositions(position, position),
        insertText: "",
        filterText: "",
        snippetInfo: void 0,
        additionalTextEdits: []
      }
    };
  }
  let { insertText } = item.completion;
  let isSnippetText = false;
  if (item.completion.insertTextRules & 4) {
    const snippet = new SnippetParser().parse(insertText);
    const model = suggestController.editor.getModel();
    if (snippet.children.length > 100) {
      return void 0;
    }
    SnippetSession.adjustWhitespace(model, position, snippet, true, true);
    insertText = snippet.toString();
    isSnippetText = true;
  }
  const info = suggestController.getOverwriteInfo(item, toggleMode);
  return {
    isSnippetText,
    completionItemKind: item.completion.kind,
    normalizedInlineCompletion: {
      insertText,
      filterText: insertText,
      range: Range.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0))),
      snippetInfo: void 0,
      additionalTextEdits: []
    }
  };
}
__name(suggestionToSuggestItemInfo, "suggestionToSuggestItemInfo");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/suggestWidgetPreviewModel.js
var __decorate48 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SuggestWidgetPreviewModel = /* @__PURE__ */ __name(class SuggestWidgetPreviewModel2 extends BaseGhostTextWidgetModel {
  get isActive() {
    return this.suggestionInlineCompletionSource.state !== void 0;
  }
  constructor(editor2, cache, languageFeaturesService) {
    super(editor2);
    this.cache = cache;
    this.languageFeaturesService = languageFeaturesService;
    this.suggestionInlineCompletionSource = this._register(new SuggestWidgetInlineCompletionProvider(
      this.editor,
      () => {
        var _a6, _b2;
        return (_b2 = (_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion();
      }
    ));
    this.updateOperation = this._register(new MutableDisposable());
    this.updateCacheSoon = this._register(new RunOnceScheduler(() => this.updateCache(), 50));
    this.minReservedLineCount = 0;
    this._register(this.suggestionInlineCompletionSource.onDidChange(() => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.updateCacheSoon.schedule();
      const suggestWidgetState = this.suggestionInlineCompletionSource.state;
      if (!suggestWidgetState) {
        this.minReservedLineCount = 0;
      }
      const newGhostText = this.ghostText;
      if (newGhostText) {
        this.minReservedLineCount = Math.max(this.minReservedLineCount, sum(newGhostText.parts.map((p) => p.lines.length - 1)));
      }
      if (this.minReservedLineCount >= 1) {
        this.suggestionInlineCompletionSource.forceRenderingAbove();
      } else {
        this.suggestionInlineCompletionSource.stopForceRenderingAbove();
      }
      this.onDidChangeEmitter.fire();
    }));
    this._register(this.cache.onDidChange(() => {
      this.onDidChangeEmitter.fire();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      this.minReservedLineCount = 0;
      this.updateCacheSoon.schedule();
      this.onDidChangeEmitter.fire();
    }));
    this._register(toDisposable(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));
  }
  isSuggestionPreviewEnabled() {
    const suggestOptions = this.editor.getOption(110);
    return suggestOptions.preview;
  }
  updateCache() {
    return __awaiter34(this, void 0, void 0, function* () {
      const state = this.suggestionInlineCompletionSource.state;
      if (!state || !state.selectedItem) {
        return;
      }
      const info = {
        text: state.selectedItem.normalizedInlineCompletion.insertText,
        range: state.selectedItem.normalizedInlineCompletion.range,
        isSnippetText: state.selectedItem.isSnippetText,
        completionKind: state.selectedItem.completionItemKind
      };
      const position = this.editor.getPosition();
      if (state.selectedItem.isSnippetText || state.selectedItem.completionItemKind === 27 || state.selectedItem.completionItemKind === 20 || state.selectedItem.completionItemKind === 23) {
        this.cache.clear();
        return;
      }
      const promise = createCancelablePromise((token) => __awaiter34(this, void 0, void 0, function* () {
        let result;
        try {
          result = yield provideInlineCompletions(this.languageFeaturesService.inlineCompletionsProvider, position, this.editor.getModel(), { triggerKind: InlineCompletionTriggerKind.Automatic, selectedSuggestionInfo: info }, token);
        } catch (e) {
          onUnexpectedError(e);
          return;
        }
        if (token.isCancellationRequested) {
          result.dispose();
          return;
        }
        this.cache.setValue(this.editor, result, InlineCompletionTriggerKind.Automatic);
        this.onDidChangeEmitter.fire();
      }));
      const operation = new UpdateOperation(promise, InlineCompletionTriggerKind.Automatic);
      this.updateOperation.value = operation;
      yield promise;
      if (this.updateOperation.value === operation) {
        this.updateOperation.clear();
      }
    });
  }
  get ghostText() {
    var _a6, _b2, _c2;
    const isSuggestionPreviewEnabled = this.isSuggestionPreviewEnabled();
    const model = this.editor.getModel();
    const augmentedCompletion = minimizeInlineCompletion(model, (_b2 = (_a6 = this.cache.value) === null || _a6 === void 0 ? void 0 : _a6.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion());
    const suggestWidgetState = this.suggestionInlineCompletionSource.state;
    const suggestInlineCompletion = minimizeInlineCompletion(model, (_c2 = suggestWidgetState === null || suggestWidgetState === void 0 ? void 0 : suggestWidgetState.selectedItem) === null || _c2 === void 0 ? void 0 : _c2.normalizedInlineCompletion);
    const isAugmentedCompletionValid = augmentedCompletion && suggestInlineCompletion && augmentedCompletion.insertText.startsWith(suggestInlineCompletion.insertText) && augmentedCompletion.range.equalsRange(suggestInlineCompletion.range);
    if (!isSuggestionPreviewEnabled && !isAugmentedCompletionValid) {
      return void 0;
    }
    const finalCompletion = isAugmentedCompletionValid ? augmentedCompletion : suggestInlineCompletion || augmentedCompletion;
    const inlineCompletionPreviewLength = isAugmentedCompletionValid ? finalCompletion.insertText.length - suggestInlineCompletion.insertText.length : 0;
    const newGhostText = this.toGhostText(finalCompletion, inlineCompletionPreviewLength);
    return newGhostText;
  }
  toGhostText(completion, inlineCompletionPreviewLength) {
    const mode = this.editor.getOptions().get(110).previewMode;
    return completion ? inlineCompletionToGhostText(completion, this.editor.getModel(), mode, this.editor.getPosition(), inlineCompletionPreviewLength) || new GhostText(completion.range.endLineNumber, [], this.minReservedLineCount) : void 0;
  }
}, "SuggestWidgetPreviewModel");
SuggestWidgetPreviewModel = __decorate48([
  __param48(2, ILanguageFeaturesService)
], SuggestWidgetPreviewModel);
function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}
__name(sum, "sum");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextModel.js
init_instantiation();
var __decorate49 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DelegatingModel = class extends Disposable {
  constructor() {
    super(...arguments);
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.hasCachedGhostText = false;
    this.currentModelRef = this._register(new MutableDisposable());
  }
  get targetModel() {
    var _a6;
    return (_a6 = this.currentModelRef.value) === null || _a6 === void 0 ? void 0 : _a6.object;
  }
  setTargetModel(model) {
    var _a6;
    if (((_a6 = this.currentModelRef.value) === null || _a6 === void 0 ? void 0 : _a6.object) === model) {
      return;
    }
    this.currentModelRef.clear();
    this.currentModelRef.value = model ? createDisposableRef(model, model.onDidChange(() => {
      this.hasCachedGhostText = false;
      this.onDidChangeEmitter.fire();
    })) : void 0;
    this.hasCachedGhostText = false;
    this.onDidChangeEmitter.fire();
  }
  get ghostText() {
    var _a6, _b2;
    if (!this.hasCachedGhostText) {
      this.cachedGhostText = (_b2 = (_a6 = this.currentModelRef.value) === null || _a6 === void 0 ? void 0 : _a6.object) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
      this.hasCachedGhostText = true;
    }
    return this.cachedGhostText;
  }
  setExpanded(expanded) {
    var _a6;
    (_a6 = this.targetModel) === null || _a6 === void 0 ? void 0 : _a6.setExpanded(expanded);
  }
  get minReservedLineCount() {
    return this.targetModel ? this.targetModel.minReservedLineCount : 0;
  }
};
__name(DelegatingModel, "DelegatingModel");
var GhostTextModel = /* @__PURE__ */ __name(class GhostTextModel2 extends DelegatingModel {
  get activeInlineCompletionsModel() {
    if (this.targetModel === this.inlineCompletionsModel) {
      return this.inlineCompletionsModel;
    }
    return void 0;
  }
  constructor(editor2, instantiationService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.sharedCache = this._register(new SharedInlineCompletionCache());
    this.suggestWidgetAdapterModel = this._register(this.instantiationService.createInstance(SuggestWidgetPreviewModel, this.editor, this.sharedCache));
    this.inlineCompletionsModel = this._register(this.instantiationService.createInstance(InlineCompletionsModel, this.editor, this.sharedCache));
    this._register(this.suggestWidgetAdapterModel.onDidChange(() => {
      this.updateModel();
    }));
    this.updateModel();
  }
  updateModel() {
    this.setTargetModel(this.suggestWidgetAdapterModel.isActive ? this.suggestWidgetAdapterModel : this.inlineCompletionsModel);
    this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);
  }
  shouldShowHoverAt(hoverRange) {
    var _a6;
    const ghostText = (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.ghostText;
    if (ghostText) {
      return ghostText.parts.some((p) => hoverRange.containsPosition(new Position(ghostText.lineNumber, p.column)));
    }
    return false;
  }
  triggerInlineCompletion() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.trigger(InlineCompletionTriggerKind.Explicit);
  }
  commitInlineCompletion() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.commitCurrentSuggestion();
  }
  commitInlineCompletionPartially() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.commitCurrentSuggestionPartially();
  }
  hideInlineCompletion() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.hide();
  }
  showNextInlineCompletion() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.showNext();
  }
  showPreviousInlineCompletion() {
    var _a6;
    (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.showPrevious();
  }
  hasMultipleInlineCompletions() {
    var _a6;
    return __awaiter35(this, void 0, void 0, function* () {
      const result = yield (_a6 = this.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
}, "GhostTextModel");
GhostTextModel = __decorate49([
  __param49(1, IInstantiationService)
], GhostTextModel);
var SharedInlineCompletionCache = class extends Disposable {
  constructor() {
    super(...arguments);
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.cache = this._register(new MutableDisposable());
  }
  get value() {
    return this.cache.value;
  }
  setValue(editor2, completionsSource, triggerKind) {
    this.cache.value = new SynchronizedInlineCompletionsCache(completionsSource, editor2, () => this.onDidChangeEmitter.fire(), triggerKind);
  }
  clearAndLeak() {
    return this.cache.clearAndLeak();
  }
  clear() {
    this.cache.clear();
  }
};
__name(SharedInlineCompletionCache, "SharedInlineCompletionCache");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextWidget.js
init_define_process();
init_dom();
init_lifecycle();
init_strings();
init_lineTokens();
init_position();
init_range();
init_stringBuilder();
init_model2();
init_language();
init_instantiation();
var __decorate50 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a4;
var ttPolicy = (_a4 = window.trustedTypes) === null || _a4 === void 0 ? void 0 : _a4.createPolicy("editorGhostText", { createHTML: (value) => value });
var GhostTextWidget = /* @__PURE__ */ __name(class GhostTextWidget2 extends Disposable {
  constructor(editor2, model, instantiationService, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.instantiationService = instantiationService;
    this.languageService = languageService;
    this.disposed = false;
    this.partsWidget = this._register(this.instantiationService.createInstance(DecorationsWidget, this.editor));
    this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor, this.languageService.languageIdCodec));
    this.viewMoreContentWidget = void 0;
    this.replacementDecoration = this._register(new DisposableDecorations(this.editor));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(29) || e.hasChanged(109) || e.hasChanged(91) || e.hasChanged(86) || e.hasChanged(46) || e.hasChanged(45) || e.hasChanged(61)) {
        this.update();
      }
    }));
    this._register(toDisposable(() => {
      var _a6;
      this.disposed = true;
      this.update();
      (_a6 = this.viewMoreContentWidget) === null || _a6 === void 0 ? void 0 : _a6.dispose();
      this.viewMoreContentWidget = void 0;
    }));
    this._register(model.onDidChange(() => {
      this.update();
    }));
    this.update();
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    return this.additionalLinesWidget.viewZoneId === viewZoneId;
  }
  update() {
    var _a6;
    const ghostText = this.model.ghostText;
    if (!this.editor.hasModel() || !ghostText || this.disposed) {
      this.partsWidget.clear();
      this.additionalLinesWidget.clear();
      this.replacementDecoration.clear();
      return;
    }
    const inlineTexts = new Array();
    const additionalLines = new Array();
    function addToAdditionalLines(lines, className) {
      if (additionalLines.length > 0) {
        const lastLine = additionalLines[additionalLines.length - 1];
        if (className) {
          lastLine.decorations.push(new LineDecoration(lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0));
        }
        lastLine.content += lines[0];
        lines = lines.slice(1);
      }
      for (const line of lines) {
        additionalLines.push({
          content: line,
          decorations: className ? [new LineDecoration(1, line.length + 1, className, 0)] : []
        });
      }
    }
    __name(addToAdditionalLines, "addToAdditionalLines");
    if (ghostText instanceof GhostTextReplacement) {
      this.replacementDecoration.setDecorations([
        {
          range: new Range(ghostText.lineNumber, ghostText.columnStart, ghostText.lineNumber, ghostText.columnStart + ghostText.length),
          options: {
            inlineClassName: "inline-completion-text-to-replace",
            description: "GhostTextReplacement"
          }
        }
      ]);
    } else {
      this.replacementDecoration.setDecorations([]);
    }
    const textBufferLine = this.editor.getModel().getLineContent(ghostText.lineNumber);
    let hiddenTextStartColumn = void 0;
    let lastIdx = 0;
    for (const part of ghostText.parts) {
      let lines = part.lines;
      if (hiddenTextStartColumn === void 0) {
        inlineTexts.push({
          column: part.column,
          text: lines[0],
          preview: part.preview
        });
        lines = lines.slice(1);
      } else {
        addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], void 0);
      }
      if (lines.length > 0) {
        addToAdditionalLines(lines, "ghost-text");
        if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) {
          hiddenTextStartColumn = part.column;
        }
      }
      lastIdx = part.column - 1;
    }
    if (hiddenTextStartColumn !== void 0) {
      addToAdditionalLines([textBufferLine.substring(lastIdx)], void 0);
    }
    this.partsWidget.setParts(ghostText.lineNumber, inlineTexts, hiddenTextStartColumn !== void 0 ? { column: hiddenTextStartColumn, length: textBufferLine.length + 1 - hiddenTextStartColumn } : void 0);
    this.additionalLinesWidget.updateLines(ghostText.lineNumber, additionalLines, ghostText.additionalReservedLineCount);
    if (0 < 0) {
      this.viewMoreContentWidget = this.renderViewMoreLines(new Position(ghostText.lineNumber, this.editor.getModel().getLineMaxColumn(ghostText.lineNumber)), "", 0);
    } else {
      (_a6 = this.viewMoreContentWidget) === null || _a6 === void 0 ? void 0 : _a6.dispose();
      this.viewMoreContentWidget = void 0;
    }
  }
  renderViewMoreLines(position, firstLineText, remainingLinesLength) {
    const fontInfo = this.editor.getOption(45);
    const domNode = document.createElement("div");
    domNode.className = "suggest-preview-additional-widget";
    applyFontInfo(domNode, fontInfo);
    const spacer = document.createElement("span");
    spacer.className = "content-spacer";
    spacer.append(firstLineText);
    domNode.append(spacer);
    const newline = document.createElement("span");
    newline.className = "content-newline suggest-preview-text";
    newline.append("\u23CE  ");
    domNode.append(newline);
    const disposableStore = new DisposableStore();
    const button = document.createElement("div");
    button.className = "button suggest-preview-text";
    button.append(`+${remainingLinesLength} lines\u2026`);
    disposableStore.add(addStandardDisposableListener(button, "mousedown", (e) => {
      var _a6;
      (_a6 = this.model) === null || _a6 === void 0 ? void 0 : _a6.setExpanded(true);
      e.preventDefault();
      this.editor.focus();
    }));
    domNode.append(button);
    return new ViewMoreLinesContentWidget(this.editor, position, domNode, disposableStore);
  }
}, "GhostTextWidget");
GhostTextWidget = __decorate50([
  __param50(2, IInstantiationService),
  __param50(3, ILanguageService)
], GhostTextWidget);
var DisposableDecorations = class {
  constructor(editor2) {
    this.editor = editor2;
    this.decorationIds = [];
  }
  setDecorations(decorations) {
    this.editor.changeDecorations((accessor) => {
      this.decorationIds = accessor.deltaDecorations(this.decorationIds, decorations);
    });
  }
  clear() {
    this.setDecorations([]);
  }
  dispose() {
    this.clear();
  }
};
__name(DisposableDecorations, "DisposableDecorations");
var DecorationsWidget = class {
  constructor(editor2) {
    this.editor = editor2;
    this.decorationIds = [];
  }
  dispose() {
    this.clear();
  }
  clear() {
    this.editor.changeDecorations((accessor) => {
      this.decorationIds = accessor.deltaDecorations(this.decorationIds, []);
    });
  }
  setParts(lineNumber, parts, hiddenText) {
    const textModel = this.editor.getModel();
    if (!textModel) {
      return;
    }
    const hiddenTextDecorations = new Array();
    if (hiddenText) {
      hiddenTextDecorations.push({
        range: Range.fromPositions(new Position(lineNumber, hiddenText.column), new Position(lineNumber, hiddenText.column + hiddenText.length)),
        options: {
          inlineClassName: "ghost-text-hidden",
          description: "ghost-text-hidden"
        }
      });
    }
    this.editor.changeDecorations((accessor) => {
      this.decorationIds = accessor.deltaDecorations(this.decorationIds, parts.map((p) => {
        return {
          range: Range.fromPositions(new Position(lineNumber, p.column)),
          options: {
            description: "ghost-text",
            after: { content: p.text, inlineClassName: p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration", cursorStops: InjectedTextCursorStops.Left },
            showIfCollapsed: true
          }
        };
      }).concat(hiddenTextDecorations));
    });
  }
};
__name(DecorationsWidget, "DecorationsWidget");
var AdditionalLinesWidget = class {
  get viewZoneId() {
    return this._viewZoneId;
  }
  constructor(editor2, languageIdCodec) {
    this.editor = editor2;
    this.languageIdCodec = languageIdCodec;
    this._viewZoneId = void 0;
  }
  dispose() {
    this.clear();
  }
  clear() {
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
    });
  }
  updateLines(lineNumber, additionalLines, minReservedLineCount) {
    const textModel = this.editor.getModel();
    if (!textModel) {
      return;
    }
    const { tabSize } = textModel.getOptions();
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
      const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
      if (heightInLines > 0) {
        const domNode = document.createElement("div");
        renderLines(domNode, tabSize, additionalLines, this.editor.getOptions(), this.languageIdCodec);
        this._viewZoneId = changeAccessor.addZone({
          afterLineNumber: lineNumber,
          heightInLines,
          domNode,
          afterColumnAffinity: 1
        });
      }
    });
  }
};
__name(AdditionalLinesWidget, "AdditionalLinesWidget");
function renderLines(domNode, tabSize, lines, opts, languageIdCodec) {
  const disableMonospaceOptimizations = opts.get(29);
  const stopRenderingLineAfter = opts.get(109);
  const renderWhitespace = "none";
  const renderControlCharacters = opts.get(86);
  const fontLigatures = opts.get(46);
  const fontInfo = opts.get(45);
  const lineHeight = opts.get(61);
  const sb = new StringBuilder(1e4);
  sb.appendString('<div class="suggest-preview-text">');
  for (let i = 0, len = lines.length; i < len; i++) {
    const lineData = lines[i];
    const line = lineData.content;
    sb.appendString('<div class="view-line');
    sb.appendString('" style="top:');
    sb.appendString(String(i * lineHeight));
    sb.appendString('px;width:1000000px;">');
    const isBasicASCII2 = isBasicASCII(line);
    const containsRTL2 = containsRTL(line);
    const lineTokens = LineTokens.createEmpty(line, languageIdCodec);
    renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII2, containsRTL2, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
    sb.appendString("</div>");
  }
  sb.appendString("</div>");
  applyFontInfo(domNode, fontInfo);
  const html = sb.build();
  const trustedhtml = ttPolicy ? ttPolicy.createHTML(html) : html;
  domNode.innerHTML = trustedhtml;
}
__name(renderLines, "renderLines");
var ViewMoreLinesContentWidget = class extends Disposable {
  constructor(editor2, position, domNode, disposableStore) {
    super();
    this.editor = editor2;
    this.position = position;
    this.domNode = domNode;
    this.allowEditorOverflow = false;
    this.suppressMouseDown = false;
    this._register(disposableStore);
    this._register(toDisposable(() => {
      this.editor.removeContentWidget(this);
    }));
    this.editor.addContentWidget(this);
  }
  getId() {
    return "editor.widget.viewMoreLinesWidget";
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.position,
      preference: [0]
    };
  }
};
__name(ViewMoreLinesContentWidget, "ViewMoreLinesContentWidget");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextController.js
init_nls();
init_contextkey();
init_instantiation();
var __decorate51 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GhostTextController = /* @__PURE__ */ __name(class GhostTextController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(GhostTextController2.ID);
  }
  get activeModel() {
    var _a6;
    return (_a6 = this.activeController.value) === null || _a6 === void 0 ? void 0 : _a6.model;
  }
  constructor(editor2, instantiationService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.triggeredExplicitly = false;
    this.activeController = this._register(new MutableDisposable());
    this.activeModelDidChangeEmitter = this._register(new Emitter());
    this._register(this.editor.onDidChangeModel(() => {
      this.updateModelController();
    }));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(110) || e.hasChanged(57)) {
        this.updateModelController();
      }
    }));
    this.updateModelController();
  }
  updateModelController() {
    const suggestOptions = this.editor.getOption(110);
    const inlineSuggestOptions = this.editor.getOption(57);
    this.activeController.value = void 0;
    this.activeController.value = this.editor.hasModel() && (suggestOptions.preview || inlineSuggestOptions.enabled || this.triggeredExplicitly) ? this.instantiationService.createInstance(ActiveGhostTextController, this.editor) : void 0;
    this.activeModelDidChangeEmitter.fire();
  }
  shouldShowHoverAt(hoverRange) {
    var _a6;
    return ((_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.shouldShowHoverAt(hoverRange)) || false;
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    var _a6, _b2;
    return ((_b2 = (_a6 = this.activeController.value) === null || _a6 === void 0 ? void 0 : _a6.widget) === null || _b2 === void 0 ? void 0 : _b2.shouldShowHoverAtViewZone(viewZoneId)) || false;
  }
  trigger() {
    var _a6;
    this.triggeredExplicitly = true;
    if (!this.activeController.value) {
      this.updateModelController();
    }
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.triggerInlineCompletion();
  }
  commitPartially() {
    var _a6;
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.commitInlineCompletionPartially();
  }
  commit() {
    var _a6;
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.commitInlineCompletion();
  }
  hide() {
    var _a6;
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.hideInlineCompletion();
  }
  showNextInlineCompletion() {
    var _a6;
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.showNextInlineCompletion();
  }
  showPreviousInlineCompletion() {
    var _a6;
    (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.showPreviousInlineCompletion();
  }
  hasMultipleInlineCompletions() {
    var _a6;
    return __awaiter36(this, void 0, void 0, function* () {
      const result = yield (_a6 = this.activeModel) === null || _a6 === void 0 ? void 0 : _a6.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
}, "GhostTextController");
GhostTextController.inlineSuggestionVisible = new RawContextKey("inlineSuggestionVisible", false, localize("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
GhostTextController.inlineSuggestionHasIndentation = new RawContextKey("inlineSuggestionHasIndentation", false, localize("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
GhostTextController.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey("inlineSuggestionHasIndentationLessThanTabSize", true, localize("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
GhostTextController.ID = "editor.contrib.ghostTextController";
GhostTextController = __decorate51([
  __param51(1, IInstantiationService)
], GhostTextController);
var GhostTextContextKeys = class {
  constructor(contextKeyService) {
    this.contextKeyService = contextKeyService;
    this.inlineCompletionVisible = GhostTextController.inlineSuggestionVisible.bindTo(this.contextKeyService);
    this.inlineCompletionSuggestsIndentation = GhostTextController.inlineSuggestionHasIndentation.bindTo(this.contextKeyService);
    this.inlineCompletionSuggestsIndentationLessThanTabSize = GhostTextController.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService);
  }
};
__name(GhostTextContextKeys, "GhostTextContextKeys");
var ActiveGhostTextController = /* @__PURE__ */ __name(class ActiveGhostTextController2 extends Disposable {
  constructor(editor2, instantiationService, contextKeyService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.contextKeys = new GhostTextContextKeys(this.contextKeyService);
    this.model = this._register(this.instantiationService.createInstance(GhostTextModel, this.editor));
    this.widget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, this.model));
    this._register(toDisposable(() => {
      this.contextKeys.inlineCompletionVisible.set(false);
      this.contextKeys.inlineCompletionSuggestsIndentation.set(false);
      this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(true);
    }));
    this._register(this.model.onDidChange(() => {
      this.updateContextKeys();
    }));
    this.updateContextKeys();
  }
  updateContextKeys() {
    var _a6;
    this.contextKeys.inlineCompletionVisible.set(((_a6 = this.model.activeInlineCompletionsModel) === null || _a6 === void 0 ? void 0 : _a6.ghostText) !== void 0);
    let startsWithIndentation = false;
    let startsWithIndentationLessThanTabSize = true;
    const ghostText = this.model.inlineCompletionsModel.ghostText;
    if (!!this.model.activeInlineCompletionsModel && ghostText && ghostText.parts.length > 0) {
      const { column, lines } = ghostText.parts[0];
      const firstLine = lines[0];
      const indentationEndColumn = this.editor.getModel().getLineIndentColumn(ghostText.lineNumber);
      const inIndentation = column <= indentationEndColumn;
      if (inIndentation) {
        let firstNonWsIdx = firstNonWhitespaceIndex(firstLine);
        if (firstNonWsIdx === -1) {
          firstNonWsIdx = firstLine.length - 1;
        }
        startsWithIndentation = firstNonWsIdx > 0;
        const tabSize = this.editor.getModel().getOptions().tabSize;
        const visibleColumnIndentation = CursorColumns.visibleColumnFromColumn(firstLine, firstNonWsIdx + 1, tabSize);
        startsWithIndentationLessThanTabSize = visibleColumnIndentation < tabSize;
      }
    }
    this.contextKeys.inlineCompletionSuggestsIndentation.set(startsWithIndentation);
    this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(startsWithIndentationLessThanTabSize);
  }
}, "ActiveGhostTextController");
ActiveGhostTextController = __decorate51([
  __param51(1, IInstantiationService),
  __param51(2, IContextKeyService)
], ActiveGhostTextController);
var ShowNextInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: ShowNextInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 89
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter36(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.showNextInlineCompletion();
        editor2.focus();
      }
    });
  }
};
__name(ShowNextInlineSuggestionAction, "ShowNextInlineSuggestionAction");
ShowNextInlineSuggestionAction.ID = "editor.action.inlineSuggest.showNext";
var ShowPreviousInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: ShowPreviousInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 87
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter36(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.showPreviousInlineCompletion();
        editor2.focus();
      }
    });
  }
};
__name(ShowPreviousInlineSuggestionAction, "ShowPreviousInlineSuggestionAction");
ShowPreviousInlineSuggestionAction.ID = "editor.action.inlineSuggest.showPrevious";
var TriggerInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    return __awaiter36(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      controller === null || controller === void 0 ? void 0 : controller.trigger();
    });
  }
};
__name(TriggerInlineSuggestionAction, "TriggerInlineSuggestionAction");
var AcceptNextWordOfInlineCompletion = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.acceptNextWord",
      label: localize("action.inlineSuggest.acceptNextWord", "Accept Next Word Of Inline Suggestion"),
      alias: "Accept Next Word Of Inline Suggestion",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    return __awaiter36(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.commitPartially();
      }
    });
  }
};
__name(AcceptNextWordOfInlineCompletion, "AcceptNextWordOfInlineCompletion");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostTextHoverParticipant.js
init_define_process();
init_dom();
init_lifecycle();
init_range();
init_language();
init_nls();
init_actions2();
init_commands();
init_contextkey();
init_opener();
var __decorate52 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsHover = class {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
  hasMultipleSuggestions() {
    return this.controller.hasMultipleInlineCompletions();
  }
  get commands() {
    var _a6, _b2, _c2;
    return ((_c2 = (_b2 = (_a6 = this.controller.activeModel) === null || _a6 === void 0 ? void 0 : _a6.activeInlineCompletionsModel) === null || _b2 === void 0 ? void 0 : _b2.completionSession.value) === null || _c2 === void 0 ? void 0 : _c2.commands) || [];
  }
};
__name(InlineCompletionsHover, "InlineCompletionsHover");
var InlineCompletionsHoverParticipant = /* @__PURE__ */ __name(class InlineCompletionsHoverParticipant2 {
  constructor(_editor, _commandService, _menuService, _contextKeyService, _languageService, _openerService, accessibilityService) {
    this._editor = _editor;
    this._commandService = _commandService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.accessibilityService = accessibilityService;
    this.hoverOrdinal = 3;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = GhostTextController.get(this._editor);
    if (!controller) {
      return null;
    }
    const target = mouseEvent.target;
    if (target.type === 8) {
      const viewZoneData = target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        return new HoverForeignElementAnchor(1e3, this, Range.fromPositions(viewZoneData.positionBefore || viewZoneData.position, viewZoneData.positionBefore || viewZoneData.position), mouseEvent.event.posx, mouseEvent.event.posy);
      }
    }
    if (target.type === 7) {
      if (controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy);
      }
    }
    if (target.type === 6) {
      const mightBeForeignElement = target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(target.range)) {
        return new HoverForeignElementAnchor(1e3, this, target.range, mouseEvent.event.posx, mouseEvent.event.posy);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    const controller = GhostTextController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineCompletionsHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(context, hoverParts) {
    const disposableStore = new DisposableStore();
    const part = hoverParts[0];
    if (this.accessibilityService.isScreenReaderOptimized()) {
      this.renderScreenReaderText(context, part, disposableStore);
    }
    const menu = disposableStore.add(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
    const previousAction = context.statusBar.addAction({
      label: localize("showNextInlineSuggestion", "Next"),
      commandId: ShowNextInlineSuggestionAction.ID,
      run: () => this._commandService.executeCommand(ShowNextInlineSuggestionAction.ID)
    });
    const nextAction = context.statusBar.addAction({
      label: localize("showPreviousInlineSuggestion", "Previous"),
      commandId: ShowPreviousInlineSuggestionAction.ID,
      run: () => this._commandService.executeCommand(ShowPreviousInlineSuggestionAction.ID)
    });
    context.statusBar.addAction({
      label: localize("acceptInlineSuggestion", "Accept"),
      commandId: inlineSuggestCommitId,
      run: () => this._commandService.executeCommand(inlineSuggestCommitId)
    });
    const actions = [previousAction, nextAction];
    for (const action of actions) {
      action.setEnabled(false);
    }
    part.hasMultipleSuggestions().then((hasMore) => {
      for (const action of actions) {
        action.setEnabled(hasMore);
      }
    });
    for (const command of part.commands) {
      context.statusBar.addAction({
        label: command.title,
        commandId: command.id,
        run: () => this._commandService.executeCommand(command.id, ...command.arguments || [])
      });
    }
    for (const [_, group] of menu.getActions()) {
      for (const action of group) {
        if (action instanceof MenuItemAction) {
          context.statusBar.addAction({
            label: action.label,
            commandId: action.item.id,
            run: () => this._commandService.executeCommand(action.item.id)
          });
        }
      }
    }
    return disposableStore;
  }
  renderScreenReaderText(context, part, disposableStore) {
    var _a6, _b2;
    const $9 = $;
    const markdownHoverElement = $9("div.hover-row.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $9("div.hover-contents"));
    const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._languageService, this._openerService));
    const render = /* @__PURE__ */ __name((code) => {
      disposableStore.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        context.onContentsChanged();
      }));
      const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
      const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
      hoverContentsElement.replaceChildren(renderedContents.element);
    }, "render");
    const ghostText = (_b2 = (_a6 = part.controller.activeModel) === null || _a6 === void 0 ? void 0 : _a6.inlineCompletionsModel) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
    if (ghostText) {
      const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
      render(ghostText.renderForScreenReader(lineText));
    }
    context.fragment.appendChild(markdownHoverElement);
  }
}, "InlineCompletionsHoverParticipant");
InlineCompletionsHoverParticipant = __decorate52([
  __param52(1, ICommandService),
  __param52(2, IMenuService),
  __param52(3, IContextKeyService),
  __param52(4, ILanguageService),
  __param52(5, IOpenerService),
  __param52(6, IAccessibilityService)
], InlineCompletionsHoverParticipant);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/ghostText.contribution.js
init_contextkey();
init_keybindingsRegistry();
registerEditorContribution(GhostTextController.ID, GhostTextController, 3);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);
registerEditorAction(AcceptNextWordOfInlineCompletion);
HoverParticipantRegistry.register(InlineCompletionsHoverParticipant);
var GhostTextCommand = EditorCommand.bindToContribution(GhostTextController.get);
var commitInlineSuggestionAction = new GhostTextCommand({
  id: inlineSuggestCommitId,
  precondition: GhostTextController.inlineSuggestionVisible,
  handler(x) {
    x.commit();
    x.editor.focus();
  }
});
registerEditorCommand(commitInlineSuggestionAction);
KeybindingsRegistry.registerKeybindingRule({
  primary: 2,
  weight: 200,
  id: commitInlineSuggestionAction.id,
  when: ContextKeyExpr.and(commitInlineSuggestionAction.precondition, EditorContextKeys.tabMovesFocus.toNegated(), GhostTextController.inlineSuggestionHasIndentationLessThanTabSize)
});
registerEditorCommand(new GhostTextCommand({
  id: "editor.action.inlineSuggest.hide",
  precondition: GhostTextController.inlineSuggestionVisible,
  kbOpts: {
    weight: 100,
    primary: 9
  },
  handler(x) {
    x.hide();
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_define_process();
init_lifecycle();
init_strings();
init_editorExtensions();
init_editOperation();
init_range();
init_selection();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_model();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentUtils.js
init_define_process();
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
__name(getSpaceCnt, "getSpaceCnt");
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    const tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}
__name(generateIndent, "generateIndent");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/indentation/browser/indentation.js
init_nls();
init_indentation();
var __decorate53 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  const indentationRules = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentationRules;
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    const text = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = /* @__PURE__ */ __name((indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  }, "shiftIndent");
  const unshiftIndent = /* @__PURE__ */ __name((indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  }, "unshiftIndent");
  const indentEdits = [];
  let globalIndent;
  const currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    const oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    const text = model.getLineContent(lineNumber);
    const oldIndentation = getLeadingWhitespace(text);
    const adjustedLineContent2 = idealIndentForNextLine + text.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
__name(getReindentEditOperations, "getReindentEditOperations");
var IndentationToSpacesAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToSpacesAction.ID,
      label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
};
__name(IndentationToSpacesAction, "IndentationToSpacesAction");
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToTabsAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToTabsAction.ID,
      label: localize("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const modelOpts = model.getOptions();
    const selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
};
__name(IndentationToTabsAction, "IndentationToTabsAction");
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var ChangeIndentationSizeAction = class extends EditorAction {
  constructor(insertSpaces, displaySizeOnly, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
    this.displaySizeOnly = displaySizeOnly;
  }
  run(accessor, editor2) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    const modelOpts = model.getOptions();
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n) => ({
      id: n.toString(),
      label: n.toString(),
      description: n === creationOpts.tabSize && n === modelOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : n === creationOpts.tabSize ? localize("defaultTabSize", "Default Tab Size") : n === modelOpts.tabSize ? localize("currentTabSize", "Current Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(() => {
      quickInputService.pick(picks, { placeHolder: localize({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
        if (pick) {
          if (model && !model.isDisposed()) {
            const pickedVal = parseInt(pick.label, 10);
            if (this.displaySizeOnly) {
              model.updateOptions({
                tabSize: pickedVal
              });
            } else {
              model.updateOptions({
                tabSize: pickedVal,
                indentSize: pickedVal,
                insertSpaces: this.insertSpaces
              });
            }
          }
        }
      });
    }, 50);
  }
};
__name(ChangeIndentationSizeAction, "ChangeIndentationSizeAction");
var IndentUsingTabs = class extends ChangeIndentationSizeAction {
  constructor() {
    super(false, false, {
      id: IndentUsingTabs.ID,
      label: localize("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
};
__name(IndentUsingTabs, "IndentUsingTabs");
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingSpaces = class extends ChangeIndentationSizeAction {
  constructor() {
    super(true, false, {
      id: IndentUsingSpaces.ID,
      label: localize("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
};
__name(IndentUsingSpaces, "IndentUsingSpaces");
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var ChangeTabDisplaySize = class extends ChangeIndentationSizeAction {
  constructor() {
    super(true, true, {
      id: ChangeTabDisplaySize.ID,
      label: localize("changeTabDisplaySize", "Change Tab Display Size"),
      alias: "Change Tab Display Size",
      precondition: void 0
    });
  }
};
__name(ChangeTabDisplaySize, "ChangeTabDisplaySize");
ChangeTabDisplaySize.ID = "editor.action.changeTabDisplaySize";
var DetectIndentation = class extends EditorAction {
  constructor() {
    super({
      id: DetectIndentation.ID,
      label: localize("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const modelService = accessor.get(IModelService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
};
__name(DetectIndentation, "DetectIndentation");
DetectIndentation.ID = "editor.action.detectIndentation";
var ReindentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const edits = getReindentEditOperations(model, languageConfigurationService, 1, model.getLineCount());
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
__name(ReindentLinesAction, "ReindentLinesAction");
var ReindentSelectedLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const model = editor2.getModel();
    if (!model) {
      return;
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const edits = [];
    for (const selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      const editOperations = getReindentEditOperations(model, languageConfigurationService, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
__name(ReindentSelectedLinesAction, "ReindentSelectedLinesAction");
var AutoIndentOnPasteCommand = class {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (const edit of edits) {
      if (edit.range && typeof edit.text === "string") {
        this._edits.push(edit);
      }
    }
  }
  getEditOperations(model, builder) {
    for (const edit of this._edits) {
      builder.addEditOperation(Range.lift(edit.range), edit.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
__name(AutoIndentOnPasteCommand, "AutoIndentOnPasteCommand");
var AutoIndentOnPaste = /* @__PURE__ */ __name(class AutoIndentOnPaste2 {
  constructor(editor2, _languageConfigurationService) {
    this.editor = editor2;
    this._languageConfigurationService = _languageConfigurationService;
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (this.editor.getOption(9) < 4 || this.editor.getOption(50)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
      this.trigger(range);
    }));
  }
  trigger(range) {
    const selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    if (!model.tokenization.isCheapToTokenize(range.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(9);
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const textEdits = [];
    const indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range.startLineNumber;
    while (startLineNumber <= range.endLineNumber) {
      if (this.shouldIgnoreLine(model, startLineNumber)) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber > range.endLineNumber) {
      return;
    }
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
      const indentOfFirstLine = getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter, this._languageConfigurationService);
      if (indentOfFirstLine !== null) {
        const oldIndentation = getLeadingWhitespace(firstLineText);
        const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          const newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
        } else {
          const indentMetadata = getIndentMetadata(model, startLineNumber, this._languageConfigurationService);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range.endLineNumber) {
      const virtualModel = {
        tokenization: {
          getLineTokens: (lineNumber) => {
            return model.tokenization.getLineTokens(lineNumber);
          },
          getLanguageId: () => {
            return model.getLanguageId();
          },
          getLanguageIdAtPosition: (lineNumber, column) => {
            return model.getLanguageIdAtPosition(lineNumber, column);
          }
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      const indentOfSecondLine = getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter, this._languageConfigurationService);
      if (indentOfSecondLine !== null) {
        const newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        const oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          const spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
            const lineContent = model.getLineContent(i);
            const originalIndent = getLeadingWhitespace(lineContent);
            const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            const newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range(i, 1, i, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    if (textEdits.length > 0) {
      this.editor.pushUndoStop();
      const cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", cmd);
      this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(model, lineNumber) {
    model.tokenization.forceTokenization(lineNumber);
    const nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (nonWhitespaceColumn === 0) {
      return true;
    }
    const tokens = model.tokenization.getLineTokens(lineNumber);
    if (tokens.getCount() > 0) {
      const firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
}, "AutoIndentOnPaste");
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
AutoIndentOnPaste = __decorate53([
  __param53(1, ILanguageConfigurationService)
], AutoIndentOnPaste);
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  const spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
__name(getIndentationEditOperations, "getIndentationEditOperations");
var IndentationToSpacesCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
__name(IndentationToSpacesCommand, "IndentationToSpacesCommand");
var IndentationToTabsCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
__name(IndentationToTabsCommand, "IndentationToTabsCommand");
registerEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste, 2);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(ChangeTabDisplaySize);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
init_define_process();
init_editorExtensions();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
init_define_process();
init_dom();
init_arrays();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_map();
init_types();
init_uri();
init_editOperation();
init_range();
init_languages();
init_model2();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();
init_resolverService();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHints.js
init_define_process();
init_errors();
init_lifecycle();
init_position();
init_range();
init_network();
init_uri();
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlayHintAnchor = class {
  constructor(range, direction) {
    this.range = range;
    this.direction = direction;
  }
};
__name(InlayHintAnchor, "InlayHintAnchor");
var InlayHintItem = class {
  constructor(hint, anchor, provider) {
    this.hint = hint;
    this.anchor = anchor;
    this.provider = provider;
    this._isResolved = false;
  }
  with(delta) {
    const result = new InlayHintItem(this.hint, delta.anchor, this.provider);
    result._isResolved = this._isResolved;
    result._currentResolve = this._currentResolve;
    return result;
  }
  resolve(token) {
    return __awaiter37(this, void 0, void 0, function* () {
      if (typeof this.provider.resolveInlayHint !== "function") {
        return;
      }
      if (this._currentResolve) {
        yield this._currentResolve;
        if (token.isCancellationRequested) {
          return;
        }
        return this.resolve(token);
      }
      if (!this._isResolved) {
        this._currentResolve = this._doResolve(token).finally(() => this._currentResolve = void 0);
      }
      yield this._currentResolve;
    });
  }
  _doResolve(token) {
    var _a6, _b2;
    return __awaiter37(this, void 0, void 0, function* () {
      try {
        const newHint = yield Promise.resolve(this.provider.resolveInlayHint(this.hint, token));
        this.hint.tooltip = (_a6 = newHint === null || newHint === void 0 ? void 0 : newHint.tooltip) !== null && _a6 !== void 0 ? _a6 : this.hint.tooltip;
        this.hint.label = (_b2 = newHint === null || newHint === void 0 ? void 0 : newHint.label) !== null && _b2 !== void 0 ? _b2 : this.hint.label;
        this._isResolved = true;
      } catch (err) {
        onUnexpectedExternalError(err);
        this._isResolved = false;
      }
    });
  }
};
__name(InlayHintItem, "InlayHintItem");
var InlayHintsFragments = class {
  static create(registry, model, ranges, token) {
    return __awaiter37(this, void 0, void 0, function* () {
      const data = [];
      const promises = registry.ordered(model).reverse().map((provider) => ranges.map((range) => __awaiter37(this, void 0, void 0, function* () {
        try {
          const result = yield provider.provideInlayHints(model, range, token);
          if (result === null || result === void 0 ? void 0 : result.hints.length) {
            data.push([result, provider]);
          }
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      yield Promise.all(promises.flat());
      if (token.isCancellationRequested || model.isDisposed()) {
        throw new CancellationError();
      }
      return new InlayHintsFragments(ranges, data, model);
    });
  }
  constructor(ranges, data, model) {
    this._disposables = new DisposableStore();
    this.ranges = ranges;
    this.provider = /* @__PURE__ */ new Set();
    const items = [];
    for (const [list, provider] of data) {
      this._disposables.add(list);
      this.provider.add(provider);
      for (const hint of list.hints) {
        const position = model.validatePosition(hint.position);
        let direction = "before";
        const wordRange = InlayHintsFragments._getRangeAtPosition(model, position);
        let range;
        if (wordRange.getStartPosition().isBefore(position)) {
          range = Range.fromPositions(wordRange.getStartPosition(), position);
          direction = "after";
        } else {
          range = Range.fromPositions(position, wordRange.getEndPosition());
          direction = "before";
        }
        items.push(new InlayHintItem(hint, new InlayHintAnchor(range, direction), provider));
      }
    }
    this.items = items.sort((a, b) => Position.compare(a.hint.position, b.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(model, position) {
    const line = position.lineNumber;
    const word = model.getWordAtPosition(position);
    if (word) {
      return new Range(line, word.startColumn, line, word.endColumn);
    }
    model.tokenization.tokenizeIfCheap(line);
    const tokens = model.tokenization.getLineTokens(line);
    const offset = position.column - 1;
    const idx = tokens.findTokenIndexAtOffset(offset);
    let start = tokens.getStartOffset(idx);
    let end = tokens.getEndOffset(idx);
    if (end - start === 1) {
      if (start === offset && idx > 1) {
        start = tokens.getStartOffset(idx - 1);
        end = tokens.getEndOffset(idx - 1);
      } else if (end === offset && idx < tokens.getCount() - 1) {
        start = tokens.getStartOffset(idx + 1);
        end = tokens.getEndOffset(idx + 1);
      }
    }
    return new Range(line, start + 1, line, end + 1);
  }
};
__name(InlayHintsFragments, "InlayHintsFragments");
function asCommandLink(command) {
  return URI.from({
    scheme: Schemas.command,
    path: command.id,
    query: command.arguments && encodeURIComponent(JSON.stringify(command.arguments))
  }).toString();
}
__name(asCommandLink, "asCommandLink");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsLocations.js
init_define_process();
init_dom();
init_actions();
init_cancellation();
init_range();
init_resolverService();
init_actions2();
init_commands();
init_contextkey();
init_instantiation();
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function showGoToContextMenu(accessor, editor2, anchor, part) {
  var _a6;
  return __awaiter38(this, void 0, void 0, function* () {
    const resolverService = accessor.get(ITextModelService);
    const contextMenuService = accessor.get(IContextMenuService);
    const commandService = accessor.get(ICommandService);
    const instaService = accessor.get(IInstantiationService);
    const notificationService = accessor.get(INotificationService);
    yield part.item.resolve(CancellationToken.None);
    if (!part.part.location) {
      return;
    }
    const location2 = part.part.location;
    const menuActions = [];
    const filter = new Set(MenuRegistry.getMenuItems(MenuId.EditorContext).map((item) => isIMenuItem(item) ? item.command.id : ""));
    for (const delegate of SymbolNavigationAction.all()) {
      if (filter.has(delegate.desc.id)) {
        menuActions.push(new Action(delegate.desc.id, MenuItemAction.label(delegate.desc, { renderShortTitle: true }), void 0, true, () => __awaiter38(this, void 0, void 0, function* () {
          const ref = yield resolverService.createModelReference(location2.uri);
          try {
            yield instaService.invokeFunction(delegate.run.bind(delegate), editor2, new SymbolNavigationAnchor(ref.object.textEditorModel, Range.getStartPosition(location2.range)));
          } finally {
            ref.dispose();
          }
        })));
      }
    }
    if (part.part.command) {
      const { command } = part.part;
      menuActions.push(new Separator());
      menuActions.push(new Action(command.id, command.title, void 0, true, () => __awaiter38(this, void 0, void 0, function* () {
        var _b2;
        try {
          yield commandService.executeCommand(command.id, ...(_b2 = command.arguments) !== null && _b2 !== void 0 ? _b2 : []);
        } catch (err) {
          notificationService.notify({
            severity: Severity.Error,
            source: part.item.provider.displayName,
            message: err
          });
        }
      })));
    }
    const useShadowDOM = editor2.getOption(119);
    contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? (_a6 = editor2.getDomNode()) !== null && _a6 !== void 0 ? _a6 : void 0 : void 0,
      getAnchor: () => {
        const box = getDomNodePagePosition(anchor);
        return { x: box.left, y: box.top + box.height + 8 };
      },
      getActions: () => menuActions,
      onHide: () => {
        editor2.focus();
      },
      autoSelectFirstItem: true
    });
  });
}
__name(showGoToContextMenu, "showGoToContextMenu");
function goToDefinitionWithLocation(accessor, event, editor2, location2) {
  return __awaiter38(this, void 0, void 0, function* () {
    const resolverService = accessor.get(ITextModelService);
    const ref = yield resolverService.createModelReference(location2.uri);
    yield editor2.invokeWithinContext((accessor2) => __awaiter38(this, void 0, void 0, function* () {
      const openToSide = event.hasSideBySideModifier;
      const contextKeyService = accessor2.get(IContextKeyService);
      const isInPeek = PeekContext.inPeekEditor.getValue(contextKeyService);
      const canPeek = !openToSide && editor2.getOption(81) && !isInPeek;
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { title: { value: "", original: "" }, id: "", precondition: void 0 });
      return action.run(accessor2, editor2, { model: ref.object.textEditorModel, position: Range.getStartPosition(location2.range) }, Range.lift(location2.range));
    }));
    ref.dispose();
  });
}
__name(goToDefinitionWithLocation, "goToDefinitionWithLocation");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsController.js
init_commands();
init_extensions();
init_instantiation();
init_colorRegistry();
init_themeService();
var __decorate54 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlayHintsCache = class {
  constructor() {
    this._entries = new LRUCache(50);
  }
  get(model) {
    const key = InlayHintsCache._key(model);
    return this._entries.get(key);
  }
  set(model, value) {
    const key = InlayHintsCache._key(model);
    this._entries.set(key, value);
  }
  static _key(model) {
    return `${model.uri.toString()}/${model.getVersionId()}`;
  }
};
__name(InlayHintsCache, "InlayHintsCache");
var IInlayHintsCache = createDecorator("IInlayHintsCache");
registerSingleton(IInlayHintsCache, InlayHintsCache, 1);
var RenderedInlayHintLabelPart = class {
  constructor(item, index) {
    this.item = item;
    this.index = index;
  }
  get part() {
    const label = this.item.hint.label;
    if (typeof label === "string") {
      return { label };
    } else {
      return label[this.index];
    }
  }
};
__name(RenderedInlayHintLabelPart, "RenderedInlayHintLabelPart");
var ActiveInlayHintInfo = class {
  constructor(part, hasTriggerModifier2) {
    this.part = part;
    this.hasTriggerModifier = hasTriggerModifier2;
  }
};
__name(ActiveInlayHintInfo, "ActiveInlayHintInfo");
var InlayHintsController = /* @__PURE__ */ __name(class InlayHintsController2 {
  static get(editor2) {
    var _a6;
    return (_a6 = editor2.getContribution(InlayHintsController2.ID)) !== null && _a6 !== void 0 ? _a6 : void 0;
  }
  constructor(_editor, _languageFeaturesService, _featureDebounce, _inlayHintsCache, _commandService, _notificationService, _instaService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._inlayHintsCache = _inlayHintsCache;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._instaService = _instaService;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._decorationsMetadata = /* @__PURE__ */ new Map();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._activeRenderMode = 0;
    this._debounceInfo = _featureDebounce.for(_languageFeaturesService.inlayHintsProvider, "InlayHint", { min: 25 });
    this._disposables.add(_languageFeaturesService.inlayHintsProvider.onDidChange(() => this._update()));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(132)) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._sessionDisposables.dispose();
    this._removeAllDecorations();
    this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    this._removeAllDecorations();
    const options = this._editor.getOption(132);
    if (options.enabled === "off") {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !this._languageFeaturesService.inlayHintsProvider.has(model)) {
      return;
    }
    const cached = this._inlayHintsCache.get(model);
    if (cached) {
      this._updateHintsDecorators([model.getFullModelRange()], cached);
    }
    this._sessionDisposables.add(toDisposable(() => {
      if (!model.isDisposed()) {
        this._cacheHintsForFastRestore(model);
      }
    }));
    let cts;
    const watchedProviders = /* @__PURE__ */ new Set();
    const scheduler = new RunOnceScheduler(() => __awaiter39(this, void 0, void 0, function* () {
      const t1 = Date.now();
      cts === null || cts === void 0 ? void 0 : cts.dispose(true);
      cts = new CancellationTokenSource();
      const listener = model.onWillDispose(() => cts === null || cts === void 0 ? void 0 : cts.cancel());
      try {
        const myToken = cts.token;
        const inlayHints = yield InlayHintsFragments.create(this._languageFeaturesService.inlayHintsProvider, model, this._getHintsRanges(), myToken);
        scheduler.delay = this._debounceInfo.update(model, Date.now() - t1);
        if (myToken.isCancellationRequested) {
          inlayHints.dispose();
          return;
        }
        for (const provider of inlayHints.provider) {
          if (typeof provider.onDidChangeInlayHints === "function" && !watchedProviders.has(provider)) {
            watchedProviders.add(provider);
            this._sessionDisposables.add(provider.onDidChangeInlayHints(() => {
              if (!scheduler.isScheduled()) {
                scheduler.schedule();
              }
            }));
          }
        }
        this._sessionDisposables.add(inlayHints);
        this._updateHintsDecorators(inlayHints.ranges, inlayHints.items);
        this._cacheHintsForFastRestore(model);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        cts.dispose();
        listener.dispose();
      }
    }), this._debounceInfo.get(model));
    this._sessionDisposables.add(scheduler);
    this._sessionDisposables.add(toDisposable(() => cts === null || cts === void 0 ? void 0 : cts.dispose(true)));
    scheduler.schedule(0);
    this._sessionDisposables.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || !scheduler.isScheduled()) {
        scheduler.schedule();
      }
    }));
    this._sessionDisposables.add(this._editor.onDidChangeModelContent((e) => {
      const delay = Math.max(scheduler.delay, 1250);
      scheduler.schedule(delay);
    }));
    if (options.enabled === "on") {
      this._activeRenderMode = 0;
    } else {
      let defaultMode;
      let altMode;
      if (options.enabled === "onUnlessPressed") {
        defaultMode = 0;
        altMode = 1;
      } else {
        defaultMode = 1;
        altMode = 0;
      }
      this._activeRenderMode = defaultMode;
      this._sessionDisposables.add(ModifierKeyEmitter.getInstance().event((e) => {
        if (!this._editor.hasModel()) {
          return;
        }
        const newRenderMode = e.altKey && e.ctrlKey ? altMode : defaultMode;
        if (newRenderMode !== this._activeRenderMode) {
          this._activeRenderMode = newRenderMode;
          const model2 = this._editor.getModel();
          const copies = this._copyInlayHintsWithCurrentAnchor(model2);
          this._updateHintsDecorators([model2.getFullModelRange()], copies);
          scheduler.schedule(0);
        }
      }));
    }
    this._sessionDisposables.add(this._installDblClickGesture(() => scheduler.schedule(0)));
    this._sessionDisposables.add(this._installLinkGesture());
    this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const store = new DisposableStore();
    const gesture = store.add(new ClickLinkGesture(this._editor));
    const sessionStore = new DisposableStore();
    store.add(sessionStore);
    store.add(gesture.onMouseMoveOrRelevantKeyDown((e) => {
      const [mouseEvent] = e;
      const labelPart = this._getInlayHintLabelPart(mouseEvent);
      const model = this._editor.getModel();
      if (!labelPart || !model) {
        sessionStore.clear();
        return;
      }
      const cts = new CancellationTokenSource();
      sessionStore.add(toDisposable(() => cts.dispose(true)));
      labelPart.item.resolve(cts.token);
      this._activeInlayHintPart = labelPart.part.command || labelPart.part.location ? new ActiveInlayHintInfo(labelPart, mouseEvent.hasTriggerModifier) : void 0;
      const lineNumber = labelPart.item.hint.position.lineNumber;
      const range = new Range(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber));
      const lineHints = this._getInlineHintsForRange(range);
      this._updateHintsDecorators([range], lineHints);
      sessionStore.add(toDisposable(() => {
        this._activeInlayHintPart = void 0;
        this._updateHintsDecorators([range], lineHints);
      }));
    }));
    store.add(gesture.onCancel(() => sessionStore.clear()));
    store.add(gesture.onExecute((e) => __awaiter39(this, void 0, void 0, function* () {
      const label = this._getInlayHintLabelPart(e);
      if (label) {
        const part = label.part;
        if (part.location) {
          this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, part.location);
        } else if (Command.is(part.command)) {
          yield this._invokeCommand(part.command, label.item);
        }
      }
    })));
    return store;
  }
  _getInlineHintsForRange(range) {
    const lineHints = /* @__PURE__ */ new Set();
    for (const data of this._decorationsMetadata.values()) {
      if (range.containsRange(data.item.anchor.range)) {
        lineHints.add(data.item);
      }
    }
    return Array.from(lineHints);
  }
  _installDblClickGesture(updateInlayHints) {
    return this._editor.onMouseUp((e) => __awaiter39(this, void 0, void 0, function* () {
      if (e.event.detail !== 2) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (!part) {
        return;
      }
      e.event.preventDefault();
      yield part.item.resolve(CancellationToken.None);
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        const edits = part.item.hint.textEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text));
        this._editor.executeEdits("inlayHint.default", edits);
        updateInlayHints();
      }
    }));
  }
  _installContextMenu() {
    return this._editor.onContextMenu((e) => __awaiter39(this, void 0, void 0, function* () {
      if (!(e.event.target instanceof HTMLElement)) {
        return;
      }
      const part = this._getInlayHintLabelPart(e);
      if (part) {
        yield this._instaService.invokeFunction(showGoToContextMenu, this._editor, e.event.target, part);
      }
    }));
  }
  _getInlayHintLabelPart(e) {
    var _a6;
    if (e.target.type !== 6) {
      return void 0;
    }
    const options = (_a6 = e.target.detail.injectedText) === null || _a6 === void 0 ? void 0 : _a6.options;
    if (options instanceof ModelDecorationInjectedTextOptions && (options === null || options === void 0 ? void 0 : options.attachedData) instanceof RenderedInlayHintLabelPart) {
      return options.attachedData;
    }
    return void 0;
  }
  _invokeCommand(command, item) {
    var _a6;
    return __awaiter39(this, void 0, void 0, function* () {
      try {
        yield this._commandService.executeCommand(command.id, ...(_a6 = command.arguments) !== null && _a6 !== void 0 ? _a6 : []);
      } catch (err) {
        this._notificationService.notify({
          severity: Severity.Error,
          source: item.provider.displayName,
          message: err
        });
      }
    });
  }
  _cacheHintsForFastRestore(model) {
    const hints = this._copyInlayHintsWithCurrentAnchor(model);
    this._inlayHintsCache.set(model, hints);
  }
  _copyInlayHintsWithCurrentAnchor(model) {
    const items = /* @__PURE__ */ new Map();
    for (const [id, obj] of this._decorationsMetadata) {
      if (items.has(obj.item)) {
        continue;
      }
      const range = model.getDecorationRange(id);
      if (range) {
        const anchor = new InlayHintAnchor(range, obj.item.anchor.direction);
        const copy = obj.item.with({ anchor });
        items.set(obj.item, copy);
      }
    }
    return Array.from(items.values());
  }
  _getHintsRanges() {
    const extra = 30;
    const model = this._editor.getModel();
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    const result = [];
    for (const range of visibleRanges.sort(Range.compareRangesUsingStarts)) {
      const extendedRange = model.validateRange(new Range(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
      if (result.length === 0 || !Range.areIntersectingOrTouching(result[result.length - 1], extendedRange)) {
        result.push(extendedRange);
      } else {
        result[result.length - 1] = Range.plusRange(result[result.length - 1], extendedRange);
      }
    }
    return result;
  }
  _updateHintsDecorators(ranges, items) {
    var _a6, _b2;
    const newDecorationsData = [];
    const addInjectedText = /* @__PURE__ */ __name((item, ref, content, cursorStops, attachedData) => {
      const opts = {
        content,
        inlineClassNameAffectsLetterSpacing: true,
        inlineClassName: ref.className,
        cursorStops,
        attachedData
      };
      newDecorationsData.push({
        item,
        classNameRef: ref,
        decoration: {
          range: item.anchor.range,
          options: {
            description: "InlayHint",
            showIfCollapsed: item.anchor.range.isEmpty(),
            collapseOnReplaceEdit: !item.anchor.range.isEmpty(),
            stickiness: 0,
            [item.anchor.direction]: this._activeRenderMode === 0 ? opts : void 0
          }
        }
      });
    }, "addInjectedText");
    const addInjectedWhitespace = /* @__PURE__ */ __name((item, isLast) => {
      const marginRule = this._ruleFactory.createClassNameRef({
        width: `${fontSize / 3 | 0}px`,
        display: "inline-block"
      });
      addInjectedText(item, marginRule, "\u200A", isLast ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None);
    }, "addInjectedWhitespace");
    const { fontSize, fontFamily, padding, isUniform } = this._getLayoutInfo();
    const fontFamilyVar = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
    for (const item of items) {
      if (item.hint.paddingLeft) {
        addInjectedWhitespace(item, false);
      }
      const parts = typeof item.hint.label === "string" ? [{ label: item.hint.label }] : item.hint.label;
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const isFirst = i === 0;
        const isLast = i === parts.length - 1;
        const cssProperties = {
          fontSize: `${fontSize}px`,
          fontFamily: `var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}`,
          verticalAlign: isUniform ? "baseline" : "middle"
        };
        if (isNonEmptyArray(item.hint.textEdits)) {
          cssProperties.cursor = "default";
        }
        this._fillInColors(cssProperties, item.hint);
        if ((part.command || part.location) && ((_a6 = this._activeInlayHintPart) === null || _a6 === void 0 ? void 0 : _a6.part.item) === item && this._activeInlayHintPart.part.index === i) {
          cssProperties.textDecoration = "underline";
          if (this._activeInlayHintPart.hasTriggerModifier) {
            cssProperties.color = themeColorFromId(editorActiveLinkForeground);
            cssProperties.cursor = "pointer";
          }
        }
        if (padding) {
          if (isFirst && isLast) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px`;
          } else if (isFirst) {
            cssProperties.padding = `1px 0 1px ${Math.max(1, fontSize / 4) | 0}px`;
            cssProperties.borderRadius = `${fontSize / 4 | 0}px 0 0 ${fontSize / 4 | 0}px`;
          } else if (isLast) {
            cssProperties.padding = `1px ${Math.max(1, fontSize / 4) | 0}px 1px 0`;
            cssProperties.borderRadius = `0 ${fontSize / 4 | 0}px ${fontSize / 4 | 0}px 0`;
          } else {
            cssProperties.padding = `1px 0 1px 0`;
          }
        }
        addInjectedText(item, this._ruleFactory.createClassNameRef(cssProperties), fixSpace(part.label), isLast && !item.hint.paddingRight ? InjectedTextCursorStops.Right : InjectedTextCursorStops.None, new RenderedInlayHintLabelPart(item, i));
      }
      if (item.hint.paddingRight) {
        addInjectedWhitespace(item, true);
      }
      if (newDecorationsData.length > InlayHintsController2._MAX_DECORATORS) {
        break;
      }
    }
    const decorationIdsToReplace = [];
    for (const range of ranges) {
      for (const { id } of (_b2 = this._editor.getDecorationsInRange(range)) !== null && _b2 !== void 0 ? _b2 : []) {
        const metadata = this._decorationsMetadata.get(id);
        if (metadata) {
          decorationIdsToReplace.push(id);
          metadata.classNameRef.dispose();
          this._decorationsMetadata.delete(id);
        }
      }
    }
    this._editor.changeDecorations((accessor) => {
      const newDecorationIds = accessor.deltaDecorations(decorationIdsToReplace, newDecorationsData.map((d) => d.decoration));
      for (let i = 0; i < newDecorationIds.length; i++) {
        const data = newDecorationsData[i];
        this._decorationsMetadata.set(newDecorationIds[i], data);
      }
    });
  }
  _fillInColors(props, hint) {
    if (hint.kind === InlayHintKind.Parameter) {
      props.backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
      props.color = themeColorFromId(editorInlayHintParameterForeground);
    } else if (hint.kind === InlayHintKind.Type) {
      props.backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
      props.color = themeColorFromId(editorInlayHintTypeForeground);
    } else {
      props.backgroundColor = themeColorFromId(editorInlayHintBackground);
      props.color = themeColorFromId(editorInlayHintForeground);
    }
  }
  _getLayoutInfo() {
    const options = this._editor.getOption(132);
    const padding = options.padding;
    const editorFontSize = this._editor.getOption(47);
    const editorFontFamily = this._editor.getOption(44);
    let fontSize = options.fontSize;
    if (!fontSize || fontSize < 5 || fontSize > editorFontSize) {
      fontSize = editorFontSize;
    }
    const fontFamily = options.fontFamily || editorFontFamily;
    const isUniform = !padding && fontFamily === editorFontFamily && fontSize === editorFontSize;
    return { fontSize, fontFamily, padding, isUniform };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const obj of this._decorationsMetadata.values()) {
      obj.classNameRef.dispose();
    }
    this._decorationsMetadata.clear();
  }
}, "InlayHintsController");
InlayHintsController.ID = "editor.contrib.InlayHints";
InlayHintsController._MAX_DECORATORS = 1500;
InlayHintsController = __decorate54([
  __param54(1, ILanguageFeaturesService),
  __param54(2, ILanguageFeatureDebounceService),
  __param54(3, IInlayHintsCache),
  __param54(4, ICommandService),
  __param54(5, INotificationService),
  __param54(6, IInstantiationService)
], InlayHintsController);
function fixSpace(str) {
  const noBreakWhitespace2 = "\xA0";
  return str.replace(/[ \t]/g, noBreakWhitespace2);
}
__name(fixSpace, "fixSpace");
CommandsRegistry.registerCommand("_executeInlayHintProvider", (accessor, ...args) => __awaiter39(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(URI.isUri(uri));
  assertType(Range.isIRange(range));
  const { inlayHintsProvider } = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const model = yield InlayHintsFragments.create(inlayHintsProvider, ref.object.textEditorModel, [Range.lift(range)], CancellationToken.None);
    const result = model.items.map((i) => i.hint);
    setTimeout(() => model.dispose(), 0);
    return result;
  } finally {
    ref.dispose();
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsHover.js
init_define_process();
init_async();
init_position();
init_textModel();
init_language();
init_resolverService();
init_configuration();
init_opener();
init_languageFeatures();
init_nls();
init_platform();
init_arrays();
var __decorate55 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param55 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues2 = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
  __name(settle, "settle");
};
var InlayHintsHoverAnchor = class extends HoverForeignElementAnchor {
  constructor(part, owner, initialMousePosX, initialMousePosY) {
    super(10, owner, part.item.anchor.range, initialMousePosX, initialMousePosY);
    this.part = part;
  }
};
__name(InlayHintsHoverAnchor, "InlayHintsHoverAnchor");
var InlayHintsHover = /* @__PURE__ */ __name(class InlayHintsHover2 extends MarkdownHoverParticipant {
  constructor(editor2, languageService, openerService, configurationService, _resolverService, languageFeaturesService) {
    super(editor2, languageService, openerService, configurationService, languageFeaturesService);
    this._resolverService = _resolverService;
    this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(mouseEvent) {
    var _a6;
    const controller = InlayHintsController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type !== 6) {
      return null;
    }
    const options = (_a6 = mouseEvent.target.detail.injectedText) === null || _a6 === void 0 ? void 0 : _a6.options;
    if (!(options instanceof ModelDecorationInjectedTextOptions && options.attachedData instanceof RenderedInlayHintLabelPart)) {
      return null;
    }
    return new InlayHintsHoverAnchor(options.attachedData, this, mouseEvent.event.posx, mouseEvent.event.posy);
  }
  computeSync() {
    return [];
  }
  computeAsync(anchor, _lineDecorations, token) {
    if (!(anchor instanceof InlayHintsHoverAnchor)) {
      return AsyncIterableObject.EMPTY;
    }
    return new AsyncIterableObject((executor) => __awaiter40(this, void 0, void 0, function* () {
      var _a6, e_1, _b2, _c2;
      const { part } = anchor;
      yield part.item.resolve(token);
      if (token.isCancellationRequested) {
        return;
      }
      let itemTooltip;
      if (typeof part.item.hint.tooltip === "string") {
        itemTooltip = new MarkdownString().appendText(part.item.hint.tooltip);
      } else if (part.item.hint.tooltip) {
        itemTooltip = part.item.hint.tooltip;
      }
      if (itemTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [itemTooltip], false, 0));
      }
      if (isNonEmptyArray(part.item.hint.textEdits)) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("hint.dbl", "Double click to insert"))], false, 10001));
      }
      let partTooltip;
      if (typeof part.part.tooltip === "string") {
        partTooltip = new MarkdownString().appendText(part.part.tooltip);
      } else if (part.part.tooltip) {
        partTooltip = part.part.tooltip;
      }
      if (partTooltip) {
        executor.emitOne(new MarkdownHover(this, anchor.range, [partTooltip], false, 1));
      }
      if (part.part.location || part.part.command) {
        let linkHint;
        const useMetaKey = this._editor.getOption(72) === "altKey";
        const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
        if (part.part.location && part.part.command) {
          linkHint = new MarkdownString().appendText(localize("hint.defAndCommand", "Go to Definition ({0}), right click for more", kb));
        } else if (part.part.location) {
          linkHint = new MarkdownString().appendText(localize("hint.def", "Go to Definition ({0})", kb));
        } else if (part.part.command) {
          linkHint = new MarkdownString(`[${localize("hint.cmd", "Execute Command")}](${asCommandLink(part.part.command)} "${part.part.command.title}") (${kb})`, { isTrusted: true });
        }
        if (linkHint) {
          executor.emitOne(new MarkdownHover(this, anchor.range, [linkHint], false, 1e4));
        }
      }
      const iterable = yield this._resolveInlayHintLabelPartHover(part, token);
      try {
        for (var _d2 = true, iterable_1 = __asyncValues2(iterable), iterable_1_1; iterable_1_1 = yield iterable_1.next(), _a6 = iterable_1_1.done, !_a6; ) {
          _c2 = iterable_1_1.value;
          _d2 = false;
          try {
            const item = _c2;
            executor.emitOne(item);
          } finally {
            _d2 = true;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d2 && !_a6 && (_b2 = iterable_1.return))
            yield _b2.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }));
  }
  _resolveInlayHintLabelPartHover(part, token) {
    return __awaiter40(this, void 0, void 0, function* () {
      if (!part.part.location) {
        return AsyncIterableObject.EMPTY;
      }
      const { uri, range } = part.part.location;
      const ref = yield this._resolverService.createModelReference(uri);
      try {
        const model = ref.object.textEditorModel;
        if (!this._languageFeaturesService.hoverProvider.has(model)) {
          return AsyncIterableObject.EMPTY;
        }
        return getHover(this._languageFeaturesService.hoverProvider, model, new Position(range.startLineNumber, range.startColumn), token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => new MarkdownHover(this, part.item.anchor.range, item.hover.contents, false, 2 + item.ordinal));
      } finally {
        ref.dispose();
      }
    });
  }
}, "InlayHintsHover");
InlayHintsHover = __decorate55([
  __param55(1, ILanguageService),
  __param55(2, IOpenerService),
  __param55(3, IConfigurationService),
  __param55(4, ITextModelService),
  __param55(5, ILanguageFeaturesService)
], InlayHintsHover);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/browser/inlayHintsContribution.js
registerEditorContribution(InlayHintsController.ID, InlayHintsController, 1);
HoverParticipantRegistry.register(InlayHintsHover);

// ../../node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_inPlaceReplace = __toESM(require_inPlaceReplace());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/lineSelection/browser/lineSelection.js
init_define_process();
init_editorExtensions();
init_editorContextKeys();
init_nls();
var ExpandLineSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "expandLineSelection",
      label: localize("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 42
      }
    });
  }
  run(_accessor, editor2, args) {
    args = args || {};
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    viewModel.model.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
    viewModel.revealPrimaryCursor(args.source, true);
  }
};
__name(ExpandLineSelectionAction, "ExpandLineSelectionAction");
registerEditorAction(ExpandLineSelectionAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_define_process();
init_keyCodes();
init_editorExtensions();

// ../../node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
init_define_process();
init_strings();
init_editOperation();
init_range();
var TrimTrailingWhitespaceCommand = class {
  constructor(selection, cursors) {
    this._selection = selection;
    this._cursors = cursors;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    const ops = trimTrailingWhitespace(model, this._cursors);
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
__name(TrimTrailingWhitespaceCommand, "TrimTrailingWhitespaceCommand");
function trimTrailingWhitespace(model, cursors) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i = cursors.length - 2; i >= 0; i--) {
    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
      cursors.splice(i, 1);
    }
  }
  const r = [];
  let rLen = 0;
  let cursorIndex = 0;
  const cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    const lineContent = model.getLineContent(lineNumber);
    const maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    const lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex2 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex2 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex2 + 2;
    } else {
      continue;
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}
__name(trimTrailingWhitespace, "trimTrailingWhitespace");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_editOperation();
init_position();
init_range();
init_selection();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/copyLinesCommand.js
init_define_process();
init_range();
init_selection();
var CopyLinesCommand = class {
  constructor(selection, isCopyingDown, noop) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._noop = noop || false;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const sourceLines = [];
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      sourceLines.push(model.getLineContent(i));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (this._noop) {
      builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
    } else {
      if (!this._isCopyingDown) {
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
      } else {
        builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
      }
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
};
__name(CopyLinesCommand, "CopyLinesCommand");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/moveLinesCommand.js
init_define_process();
init_strings();
init_range();
init_selection();
init_languageConfiguration();
init_languageConfigurationRegistry();
var __decorate56 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param56 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MoveLinesCommand = /* @__PURE__ */ __name(class MoveLinesCommand2 {
  constructor(selection, isMovingDown, autoIndent, _languageConfigurationService) {
    this._languageConfigurationService = _languageConfigurationService;
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    const modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    const indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    const virtualModel = {
      tokenization: {
        getLineTokens: (lineNumber) => {
          return model.tokenization.getLineTokens(lineNumber);
        },
        getLanguageId: () => {
          return model.getLanguageId();
        },
        getLanguageIdAtPosition: (lineNumber, column) => {
          return model.getLanguageIdAtPosition(lineNumber, column);
        }
      },
      getLineContent: null
    };
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      const lineNumber = s.startLineNumber;
      const otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          const movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            const newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimLeft(movingLineText);
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return model.getLineContent(movingLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const indentOfMovingLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfMovingLine !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimLeft(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          const ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return insertingText;
              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                return model.getLineContent(lineNumber - 1);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            const newIndentatOfMovingBlock = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter, this._languageConfigurationService);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          virtualModel.getLineContent = (lineNumber) => {
            if (lineNumber === movingLineNumber) {
              return model.getLineContent(s.startLineNumber);
            } else {
              return model.getLineContent(lineNumber);
            }
          };
          const ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            const indentOfFirstLine = getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter, this._languageConfigurationService);
            if (indentOfFirstLine !== null) {
              const oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  parseEnterResult(model, indentConverter, tabSize, line, enter) {
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      const movingLineText = model.getLineContent(line);
      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
        const oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        const indentMetadataOfMovelingLine = getIndentMetadata(model, line, this._languageConfigurationService);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        const newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
    if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
      const maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
      const enter = getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    } else {
      let validPrecedingLine = line - 1;
      while (validPrecedingLine >= 1) {
        const lineContent = model.getLineContent(validPrecedingLine);
        const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
        validPrecedingLine--;
      }
      if (validPrecedingLine < 1 || line > model.getLineCount()) {
        return null;
      }
      const maxColumn = model.getLineMaxColumn(validPrecedingLine);
      const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    }
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
        lineContent = previousLineText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      const nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    const maxColumn = model.getLineMaxColumn(validPrecedingLine);
    const enter = getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn), this._languageConfigurationService);
    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
  }
  trimLeft(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.tokenization.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    const languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    const languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (this._languageConfigurationService.getLanguageConfiguration(languageAtSelectionStart).indentRulesSupport === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      const lineContent = model.getLineContent(i);
      const originalIndent = getLeadingWhitespace(lineContent);
      const originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      const newSpacesCnt = originalSpacesCnt + offset;
      const newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);
        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
}, "MoveLinesCommand");
MoveLinesCommand = __decorate56([
  __param56(3, ILanguageConfigurationService)
], MoveLinesCommand);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/sortLinesCommand.js
init_define_process();
init_editOperation();
init_range();
var SortLinesCommand = class {
  static getCollator() {
    if (!SortLinesCommand._COLLATOR) {
      SortLinesCommand._COLLATOR = new Intl.Collator();
    }
    return SortLinesCommand._COLLATOR;
  }
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    const op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    const data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i = 0, len = data.before.length; i < len; i++) {
      if (data.before[i] !== data.after[i]) {
        return true;
      }
    }
    return false;
  }
};
__name(SortLinesCommand, "SortLinesCommand");
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
  const startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  const linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
__name(getSortData, "getSortData");
function sortLines(model, selection, descending) {
  const data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}
__name(sortLines, "sortLines");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/browser/linesOperations.js
init_nls();
init_actions2();
init_languageConfigurationRegistry();
var AbstractCopyLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignore: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands = [];
    for (const selection of selections) {
      commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(AbstractCopyLinesAction, "AbstractCopyLinesAction");
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: { primary: 2048 | 512 | 1024 | 16 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
};
__name(CopyLinesUpAction, "CopyLinesUpAction");
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: { primary: 2048 | 512 | 1024 | 18 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
};
__name(CopyLinesDownAction, "CopyLinesDownAction");
var DuplicateSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    const model = editor2.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(DuplicateSelectionAction, "DuplicateSelectionAction");
var AbstractMoveLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(accessor, editor2) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    const commands = [];
    const selections = editor2.getSelections() || [];
    const autoIndent = editor2.getOption(9);
    for (const selection of selections) {
      commands.push(new MoveLinesCommand(selection, this.down, autoIndent, languageConfigurationService));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(AbstractMoveLinesAction, "AbstractMoveLinesAction");
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: { primary: 512 | 16 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
};
__name(MoveLinesUpAction, "MoveLinesUpAction");
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: { primary: 512 | 18 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
};
__name(MoveLinesDownAction, "MoveLinesDownAction");
var AbstractSortLinesAction = class extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections() || [];
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
        return;
      }
    }
    const commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new SortLinesCommand(selections[i], this.descending);
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(AbstractSortLinesAction, "AbstractSortLinesAction");
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(SortLinesAscendingAction, "SortLinesAscendingAction");
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(SortLinesDescendingAction, "SortLinesDescendingAction");
var DeleteDuplicateLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: localize("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let linesDeleted = 0;
    for (const selection of editor2.getSelections()) {
      const uniqueLines = /* @__PURE__ */ new Set();
      const lines = [];
      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {
        const line = model.getLineContent(i);
        if (uniqueLines.has(line)) {
          continue;
        }
        lines.push(line);
        uniqueLines.add(line);
      }
      const selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
      const adjustedSelectionStart = selection.startLineNumber - linesDeleted;
      const finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
      edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
      endCursorState.push(finalSelection);
      linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
__name(DeleteDuplicateLinesAction, "DeleteDuplicateLinesAction");
var TrimTrailingWhitespaceAction = class extends EditorAction {
  constructor() {
    super({
      id: TrimTrailingWhitespaceAction.ID,
      label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 54),
        weight: 100
      }
    });
  }
  run(_accessor, editor2, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor2.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
    }
    const selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    const command = new TrimTrailingWhitespaceCommand(selection, cursors);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
};
__name(TrimTrailingWhitespaceAction, "TrimTrailingWhitespaceAction");
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var DeleteLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const ops = this._getLinesToRemove(editor2);
    const model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    const edits = [];
    const cursorState = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, cursorState);
    editor2.pushUndoStop();
  }
  _getLinesToRemove(editor2) {
    const operations = editor2.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    const mergedOperations = [];
    let previousOperation = operations[0];
    for (let i = 1; i < operations.length; i++) {
      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
        previousOperation.endLineNumber = operations[i].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
};
__name(DeleteLinesAction, "DeleteLinesAction");
var IndentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 89,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
    editor2.pushUndoStop();
  }
};
__name(IndentLinesAction, "IndentLinesAction");
var OutdentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 87,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
  }
};
__name(OutdentLinesAction, "OutdentLinesAction");
var InsertLineBeforeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
__name(InsertLineBeforeAction, "InsertLineBeforeAction");
var InsertLineAfterAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
__name(InsertLineAfterAction, "InsertLineAfterAction");
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const primaryCursor = editor2.getSelection();
    const rangesToDelete = this._getRangesToDelete(editor2);
    const effectiveRanges = [];
    for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
      const range = rangesToDelete[i];
      const nextRange = rangesToDelete[i + 1];
      if (Range.intersectRanges(range, nextRange) === null) {
        effectiveRanges.push(range);
      } else {
        rangesToDelete[i + 1] = Range.plusRange(range, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    const endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    const edits = effectiveRanges.map((range) => {
      return EditOperation.replace(range, "");
    });
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
__name(AbstractDeleteAllToBoundaryAction, "AbstractDeleteAllToBoundaryAction");
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 2048 | 1 },
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range) => {
      let endCursor;
      if (range.endColumn === 1 && deletedLines > 0) {
        const newStartLine = range.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
      } else {
        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      deletedLines += range.endLineNumber - range.startLineNumber;
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          const deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          const deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
          return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
};
__name(DeleteAllLeftAction, "DeleteAllLeftAction");
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 41, secondary: [2048 | 20] },
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    const endCursorState = [];
    for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
      const range = rangesToDelete[i];
      const endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    const model = editor2.getModel();
    if (model === null) {
      return [];
    }
    const selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    const rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    return rangesToDelete;
  }
};
__name(DeleteAllRightAction, "DeleteAllRightAction");
var JoinLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: { primary: 256 | 40 },
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor2.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range.compareRangesUsingStarts);
    const reducedSelections = [];
    const lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const edits = [];
    const endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i = 0, len = reducedSelections.length; i < len; i++) {
      const selection = reducedSelections[i];
      const startLineNumber = selection.startLineNumber;
      const startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      const selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        const position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
        const lineText = model.getLineContent(i2);
        const firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      const deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
__name(JoinLinesAction, "JoinLinesAction");
var TransposeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize("editor.transpose", "Transpose characters around the cursor"),
      alias: "Transpose characters around the cursor",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      const selection = selections[i];
      if (!selection.isEmpty()) {
        continue;
      }
      const cursor = selection.getStartPosition();
      const maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        const deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        const chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(TransposeAction, "TransposeAction");
var AbstractCaseAction = class extends EditorAction {
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const wordSeparators = editor2.getOption(122);
    const textEdits = [];
    for (const selection of selections) {
      if (selection.isEmpty()) {
        const cursor = selection.getStartPosition();
        const word = editor2.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        const text = model.getValueInRange(wordRange);
        textEdits.push(EditOperation.replace(wordRange, this._modifyText(text, wordSeparators)));
      } else {
        const text = model.getValueInRange(selection);
        textEdits.push(EditOperation.replace(selection, this._modifyText(text, wordSeparators)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, textEdits);
    editor2.pushUndoStop();
  }
};
__name(AbstractCaseAction, "AbstractCaseAction");
var UpperCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleUpperCase();
  }
};
__name(UpperCaseAction, "UpperCaseAction");
var LowerCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    return text.toLocaleLowerCase();
  }
};
__name(LowerCaseAction, "LowerCaseAction");
var BackwardsCompatibleRegExp = class {
  constructor(_pattern, _flags) {
    this._pattern = _pattern;
    this._flags = _flags;
    this._actual = null;
    this._evaluated = false;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = true;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch (err) {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
};
__name(BackwardsCompatibleRegExp, "BackwardsCompatibleRegExp");
var TitleCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const titleBoundary = TitleCaseAction.titleBoundary.get();
    if (!titleBoundary) {
      return text;
    }
    return text.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
  }
};
__name(TitleCaseAction, "TitleCaseAction");
TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
var SnakeCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, wordSeparators) {
    const caseBoundary = SnakeCaseAction.caseBoundary.get();
    const singleLetters = SnakeCaseAction.singleLetters.get();
    if (!caseBoundary || !singleLetters) {
      return text;
    }
    return text.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
  }
};
__name(SnakeCaseAction, "SnakeCaseAction");
SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
var KebabCaseAction = class extends AbstractCaseAction {
  static isSupported() {
    const areAllRegexpsSupported = [
      this.caseBoundary,
      this.singleLetters,
      this.underscoreBoundary
    ].every((regexp) => regexp.isSupported());
    return areAllRegexpsSupported;
  }
  constructor() {
    super({
      id: "editor.action.transformToKebabcase",
      label: localize("editor.transformToKebabcase", "Transform to Kebab Case"),
      alias: "Transform to Kebab Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text, _) {
    const caseBoundary = KebabCaseAction.caseBoundary.get();
    const singleLetters = KebabCaseAction.singleLetters.get();
    const underscoreBoundary = KebabCaseAction.underscoreBoundary.get();
    if (!caseBoundary || !singleLetters || !underscoreBoundary) {
      return text;
    }
    return text.replace(underscoreBoundary, "$1-$3").replace(caseBoundary, "$1-$2").replace(singleLetters, "$1-$2").toLocaleLowerCase();
  }
};
__name(KebabCaseAction, "KebabCaseAction");
KebabCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
KebabCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu}\\p{Ll})", "gmu");
KebabCaseAction.underscoreBoundary = new BackwardsCompatibleRegExp("(\\S)(_)(\\S)", "gm");
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {
  registerEditorAction(SnakeCaseAction);
}
if (TitleCaseAction.titleBoundary.isSupported()) {
  registerEditorAction(TitleCaseAction);
}
if (KebabCaseAction.isSupported()) {
  registerEditorAction(KebabCaseAction);
}

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/browser/linkedEditing.js
init_define_process();
init_arrays();
init_async();
init_cancellation();
init_color();
init_errors();
init_event();
init_lifecycle();
init_strings();
init_uri();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_textModel();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
init_languageFeatures();
init_colorRegistry();
init_languageFeatureDebounce();
init_stopwatch();
var __decorate57 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param57 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
var DECORATION_CLASS_NAME = "linked-editing-decoration";
var LinkedEditingContribution = /* @__PURE__ */ __name(class LinkedEditingContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkedEditingContribution2.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService, languageConfigurationService, languageFeatureDebounceService) {
    super();
    this.languageConfigurationService = languageConfigurationService;
    this._syncRangesToken = 0;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._providers = languageFeaturesService.linkedEditingRangeProvider;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._debounceInformation = languageFeatureDebounceService.for(this._providers, "Linked Editing", { min: 200 });
    this._currentDecorations = this._editor.createDecorationsCollection();
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequest = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(64) || e.hasChanged(85)) {
        this.reinitialize(false);
      }
    }));
    this._register(this._providers.onDidChange(() => this.reinitialize(false)));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
    this.reinitialize(true);
  }
  reinitialize(forceRefresh) {
    const model = this._editor.getModel();
    const isEnabled = model !== null && (this._editor.getOption(64) || this._editor.getOption(85)) && this._providers.has(model);
    if (isEnabled === this._enabled && !forceRefresh) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._localToDispose.add(Event.runAndSubscribe(model.onDidChangeLanguageConfiguration, () => {
      this._languageWordPattern = this.languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getWordDefinition();
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceInformation.get(model));
    const triggerRangeUpdate = /* @__PURE__ */ __name(() => {
      var _a6;
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), (_a6 = this._debounceDuration) !== null && _a6 !== void 0 ? _a6 : this._debounceInformation.get(model));
    }, "triggerRangeUpdate");
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = /* @__PURE__ */ __name((token) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(token));
    }, "triggerRangeSync");
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = this._currentDecorations.getRange(0);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._syncRangesToken);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.dispose();
        rangeSyncScheduler.dispose();
      }
    });
    this.updateRanges();
  }
  _syncRanges(token) {
    if (!this._editor.hasModel() || token !== this._syncRangesToken || this._currentDecorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = this._currentDecorations.getRange(0);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match = referenceValue.match(this._currentWordPattern);
      const matchLength = match ? match[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    const edits = [];
    for (let i = 1, len = this._currentDecorations.length; i < len; i++) {
      const mirrorRange = this._currentDecorations.getRange(i);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength2;
        oldValue = oldValue.substr(commonPrefixLength2);
        newValue = newValue.substr(commonPrefixLength2);
        const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength2;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._editor.popUndoStop();
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("linkedEditing", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations.clear();
    if (this._currentRequest) {
      this._currentRequest.cancel();
      this._currentRequest = null;
      this._currentRequestPosition = null;
    }
  }
  updateRanges(force = false) {
    return __awaiter41(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        this.clearRanges();
        return;
      }
      const position = this._editor.getPosition();
      if (!this._enabled && !force || this._editor.getSelections().length > 1) {
        this.clearRanges();
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
        if (position.equals(this._currentRequestPosition)) {
          return;
        }
        if (this._currentDecorations.length > 0) {
          const range = this._currentDecorations.getRange(0);
          if (range && range.containsPosition(position)) {
            return;
          }
        }
      }
      this._currentRequestPosition = position;
      this._currentRequestModelVersion = modelVersionId;
      const request = createCancelablePromise((token) => __awaiter41(this, void 0, void 0, function* () {
        try {
          const sw = new StopWatch(false);
          const response = yield getLinkedEditingRanges(this._providers, model, position, token);
          this._debounceInformation.update(model, sw.elapsed());
          if (request !== this._currentRequest) {
            return;
          }
          this._currentRequest = null;
          if (modelVersionId !== model.getVersionId()) {
            return;
          }
          let ranges = [];
          if (response === null || response === void 0 ? void 0 : response.ranges) {
            ranges = response.ranges;
          }
          this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
          let foundReferenceRange = false;
          for (let i = 0, len = ranges.length; i < len; i++) {
            if (Range.containsPosition(ranges[i], position)) {
              foundReferenceRange = true;
              if (i !== 0) {
                const referenceRange = ranges[i];
                ranges.splice(i, 1);
                ranges.unshift(referenceRange);
              }
              break;
            }
          }
          if (!foundReferenceRange) {
            this.clearRanges();
            return;
          }
          const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution2.DECORATION }));
          this._visibleContextKey.set(true);
          this._currentDecorations.set(decorations);
          this._syncRangesToken++;
        } catch (err) {
          if (!isCancellationError(err)) {
            onUnexpectedError(err);
          }
          if (this._currentRequest === request || !this._currentRequest) {
            this.clearRanges();
          }
        }
      }));
      this._currentRequest = request;
      return request;
    });
  }
}, "LinkedEditingContribution");
LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
  description: "linked-editing",
  stickiness: 0,
  className: DECORATION_CLASS_NAME
});
LinkedEditingContribution = __decorate57([
  __param57(1, IContextKeyService),
  __param57(2, ILanguageFeaturesService),
  __param57(3, ILanguageConfigurationService),
  __param57(4, ILanguageFeatureDebounceService)
], LinkedEditingContribution);
var LinkedEditingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: localize("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor2) {
    const controller = LinkedEditingContribution.get(editor2);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
};
__name(LinkedEditingAction, "LinkedEditingAction");
var LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
registerEditorCommand(new LinkedEditingCommand({
  id: "cancelLinkedEditingInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
function getLinkedEditingRanges(providers, model, position, token) {
  const orderedByScore = providers.ordered(model);
  return first(orderedByScore.map((provider) => () => __awaiter41(this, void 0, void 0, function* () {
    try {
      return yield provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  })), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
__name(getLinkedEditingRanges, "getLinkedEditingRanges");
var editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", { dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hcDark: Color.fromHex("#f00").transparent(0.3), hcLight: Color.white }, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
registerModelAndPositionCommand("_executeLinkedEditingProvider", (_accessor, model, position) => {
  const { linkedEditingRangeProvider } = _accessor.get(ILanguageFeaturesService);
  return getLinkedEditingRanges(linkedEditingRangeProvider, model, position, CancellationToken.None);
});
registerEditorContribution(LinkedEditingContribution.ID, LinkedEditingContribution, 1);
registerEditorAction(LinkedEditingAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_define_process();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_network();
init_platform();
init_resources();
init_stopwatch();
init_uri();
init_editorExtensions();
init_textModel();
init_languageFeatureDebounce();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/getLinks.js
init_define_process();
init_arrays();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_range();
init_model();
init_commands();
init_languageFeatures();
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Link = class {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  resolve(token) {
    return __awaiter42(this, void 0, void 0, function* () {
      if (this._link.url) {
        return this._link.url;
      }
      if (typeof this._provider.resolveLink === "function") {
        return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
          this._link = value || this._link;
          if (this._link.url) {
            return this.resolve(token);
          }
          return Promise.reject(new Error("missing"));
        });
      }
      return Promise.reject(new Error("missing"));
    });
  }
};
__name(Link, "Link");
var LinksList = class {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link(link, provider));
      links = LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._disposables.add(list);
      }
    }
    this.links = links;
  }
  dispose() {
    this._disposables.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    const result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
};
__name(LinksList, "LinksList");
function getLinks(providers, model, token) {
  const lists = [];
  const promises = providers.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
__name(getLinks, "getLinks");
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter42(void 0, void 0, void 0, function* () {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI);
  if (typeof resolveCount !== "number") {
    resolveCount = 0;
  }
  const { linkProvider } = accessor.get(ILanguageFeaturesService);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = yield getLinks(linkProvider, model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
    yield list.links[i].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/links/browser/links.js
init_nls();
init_opener();
var __decorate58 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param58 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LinkDetector = /* @__PURE__ */ __name(class LinkDetector2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(LinkDetector2.ID);
  }
  constructor(editor2, openerService, notificationService, languageFeaturesService, languageFeatureDebounceService) {
    super();
    this.editor = editor2;
    this.openerService = openerService;
    this.notificationService = notificationService;
    this.languageFeaturesService = languageFeaturesService;
    this.providers = this.languageFeaturesService.linkProvider;
    this.debounceInformation = languageFeatureDebounceService.for(this.providers, "Links", { min: 1e3, max: 4e3 });
    this.computeLinks = this._register(new RunOnceScheduler(() => this.computeLinksNow(), 1e3));
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    const clickLinkGesture = this._register(new ClickLinkGesture(editor2));
    this._register(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this._register(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this._register(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (!e.hasChanged(65)) {
        return;
      }
      this.updateDecorations([]);
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (!this.editor.hasModel()) {
        return;
      }
      this.computeLinks.schedule(this.debounceInformation.get(this.editor.getModel()));
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(editor2.onDidChangeModelLanguage((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this._register(this.providers.onDidChange((e) => {
      this.stop();
      this.computeLinks.schedule(0);
    }));
    this.computeLinks.schedule(0);
  }
  computeLinksNow() {
    return __awaiter43(this, void 0, void 0, function* () {
      if (!this.editor.hasModel() || !this.editor.getOption(65)) {
        return;
      }
      const model = this.editor.getModel();
      if (!this.providers.has(model)) {
        return;
      }
      if (this.activeLinksList) {
        this.activeLinksList.dispose();
        this.activeLinksList = null;
      }
      this.computePromise = createCancelablePromise((token) => getLinks(this.providers, model, token));
      try {
        const sw = new StopWatch(false);
        this.activeLinksList = yield this.computePromise;
        this.debounceInformation.update(model, sw.elapsed());
        if (model.isDisposed()) {
          return;
        }
        this.updateDecorations(this.activeLinksList.links);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        this.computePromise = null;
      }
    });
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(72) === "altKey";
    const oldDecorations = [];
    const keys = Object.keys(this.currentOccurrences);
    for (const decorationId of keys) {
      const occurence = this.currentOccurrences[decorationId];
      oldDecorations.push(occurence.decorationId);
    }
    const newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    this.editor.changeDecorations((changeAccessor) => {
      const decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
      this.currentOccurrences = {};
      this.activeLinkDecorationId = null;
      for (let i = 0, len = decorations.length; i < len; i++) {
        const occurence = new LinkOccurrence(links[i], decorations[i]);
        this.currentOccurrences[occurence.decorationId] = occurence;
      }
    });
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(72) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(72) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier, true);
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const { link } = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath2 = null;
            if (fsPath.startsWith("/./")) {
              relativePath2 = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith("//./")) {
              relativePath2 = `.${fsPath.substr(2)}`;
            }
            if (relativePath2) {
              uri = joinPath(modelUri, relativePath2);
            }
          }
        }
      }
      return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true, fromWorkspace: true });
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration2 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration2.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    var _a6;
    this.computeLinks.cancel();
    if (this.activeLinksList) {
      (_a6 = this.activeLinksList) === null || _a6 === void 0 ? void 0 : _a6.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    super.dispose();
    this.stop();
  }
}, "LinkDetector");
LinkDetector.ID = "editor.linkDetector";
LinkDetector = __decorate58([
  __param58(1, IOpenerService),
  __param58(2, INotificationService),
  __param58(3, ILanguageFeaturesService),
  __param58(4, ILanguageFeatureDebounceService)
], LinkDetector);
var decoration = {
  general: ModelDecorationOptions.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
var LinkOccurrence = class {
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = Object.assign({}, isActive ? decoration.active : decoration.general);
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
};
__name(LinkOccurrence, "LinkOccurrence");
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        nativeLabel = localize("tooltip.explanation", "Execute command {0}", commandId);
      }
    }
    const hoverMessage = new MarkdownString("", true).appendLink(link.url.toString(true).replace(/ /g, "%20"), label, nativeLabel).appendMarkdown(` (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
__name(getHoverMessage, "getHoverMessage");
var OpenLinkAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const linkDetector = LinkDetector.get(editor2);
    if (!linkDetector) {
      return;
    }
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    for (const sel of selections) {
      const link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
};
__name(OpenLinkAction, "OpenLinkAction");
registerEditorContribution(LinkDetector.ID, LinkDetector, 1);
registerEditorAction(OpenLinkAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/longLinesHelper/browser/longLinesHelper.js
init_define_process();
init_lifecycle();
init_editorExtensions();
var LongLinesHelper = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(this._editor.onMouseDown((e) => {
      const stopRenderingLineAfter = this._editor.getOption(109);
      if (stopRenderingLineAfter >= 0 && e.target.type === 6 && e.target.position.column >= stopRenderingLineAfter) {
        this._editor.updateOptions({
          stopRenderingLineAfter: -1
        });
      }
    }));
  }
};
__name(LongLinesHelper, "LongLinesHelper");
LongLinesHelper.ID = "editor.contrib.longLinesHelper";
registerEditorContribution(LongLinesHelper.ID, LongLinesHelper, 2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
init_define_process();
init_aria();
init_async();
init_keyCodes();
init_lifecycle();
init_editorExtensions();
init_range();
init_selection();
init_editorContextKeys();
init_nls();
init_actions2();
init_contextkey();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/highlightDecorations.js
init_define_process();
init_model2();
init_textModel();
init_languages();
init_nls();
init_colorRegistry();
init_themeService();
registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hcDark: null, hcLight: null }, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hcDark: null, hcLight: null }, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
registerColor("editor.wordHighlightBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hcDark: activeContrastBorder, hcLight: activeContrastBorder }, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hcDark: "#A0A0A0CC", hcLight: "#A0A0A0CC" }, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hcDark: "#C0A0C0CC", hcLight: "#C0A0C0CC" }, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var _WRITE_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var _TEXT_OPTIONS = ModelDecorationOptions.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var _TEXT_OPTIONS_NO_OVERVIEW = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
});
var _REGULAR_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
function getHighlightDecorationOptions(kind) {
  if (kind === DocumentHighlightKind.Write) {
    return _WRITE_OPTIONS;
  } else if (kind === DocumentHighlightKind.Text) {
    return _TEXT_OPTIONS;
  } else {
    return _REGULAR_OPTIONS;
  }
}
__name(getHighlightDecorationOptions, "getHighlightDecorationOptions");
function getSelectionHighlightDecorationOptions(hasSemanticHighlights) {
  return hasSemanticHighlights ? _TEXT_OPTIONS_NO_OVERVIEW : _TEXT_OPTIONS;
}
__name(getSelectionHighlightDecorationOptions, "getSelectionHighlightDecorationOptions");
registerThemingParticipant((theme, collector) => {
  const selectionHighlight = theme.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/browser/multicursor.js
var __decorate59 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param59 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
__name(announceCursorChange, "announceCursorChange");
var InsertCursorAbove = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [2048 | 1024 | 16]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(InsertCursorAbove, "InsertCursorAbove");
var InsertCursorBelow = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [2048 | 1024 | 18]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(InsertCursorBelow, "InsertCursorBelow");
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
      const currentLineMaxColumn = model.getLineMaxColumn(i);
      result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    const newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(InsertCursorAtEndOfEachLineSelected, "InsertCursorAtEndOfEachLineSelected");
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const lineCount = editor2.getModel().getLineCount();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(InsertCursorAtEndOfLineSelected, "InsertCursorAtEndOfLineSelected");
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const newSelections = [];
    for (let i = selections[0].startLineNumber; i >= 1; i--) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(InsertCursorAtTopOfLineSelected, "InsertCursorAtTopOfLineSelected");
var MultiCursorSessionResult = class {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
};
__name(MultiCursorSessionResult, "MultiCursorSessionResult");
var MultiCursorSession = class {
  static create(editor2, findController) {
    if (!editor2.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor2.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0);
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0);
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(122) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0);
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0);
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(122) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll(searchScope) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    const editorModel = this._editor.getModel();
    if (searchScope) {
      return editorModel.findMatches(this.searchText, searchScope, false, this.matchCase, this.wholeWord ? this._editor.getOption(122) : null, false, 1073741824);
    }
    return editorModel.findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(122) : null, false, 1073741824);
  }
};
__name(MultiCursorSession, "MultiCursorSession");
var MultiCursorSelectionController = class extends Disposable {
  static get(editor2) {
    return editor2.getContribution(MultiCursorSelectionController.ID);
  }
  constructor(editor2) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = { searchString: this._session.searchText };
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          const resultingSelections = [];
          for (let i = 0, len = allSelections.length; i < len; i++) {
            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      const editorModel = this._editor.getModel();
      if (findState.searchScope) {
        matches = editorModel.findMatches(findState.searchString, findState.searchScope, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(122) : null, false, 1073741824);
      } else {
        matches = editorModel.findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(122) : null, false, 1073741824);
      }
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll(findState.searchScope);
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i = 0, len = matches.length; i < len; i++) {
        const match = matches[i];
        const intersection = match.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i] = matches[0];
          matches[0] = match;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
};
__name(MultiCursorSelectionController, "MultiCursorSelectionController");
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionControllerAction = class extends EditorAction {
  run(accessor, editor2) {
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel) {
      const previousCursorState = viewModel.getCursorStates();
      this._run(multiCursorController, findController);
      announceCursorChange(previousCursorState, viewModel.getCursorStates());
    }
  }
};
__name(MultiCursorSelectionControllerAction, "MultiCursorSelectionControllerAction");
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
};
__name(AddSelectionToNextFindMatchAction, "AddSelectionToNextFindMatchAction");
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
};
__name(AddSelectionToPreviousFindMatchAction, "AddSelectionToPreviousFindMatchAction");
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(2048 | 41, 2048 | 34),
        weight: 100
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
};
__name(MoveSelectionToNextFindMatchAction, "MoveSelectionToNextFindMatchAction");
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
};
__name(MoveSelectionToPreviousFindMatchAction, "MoveSelectionToPreviousFindMatchAction");
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
__name(SelectHighlightsAction, "SelectHighlightsAction");
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
__name(CompatChangeAll, "CompatChangeAll");
var SelectionHighlighterState = class {
  constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
    this._model = _model;
    this._searchText = _searchText;
    this._matchCase = _matchCase;
    this._wordSeparators = _wordSeparators;
    this._modelVersionId = this._model.getVersionId();
    this._cachedFindMatches = null;
    if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) {
      this._cachedFindMatches = prevState._cachedFindMatches;
    }
  }
  findMatches() {
    if (this._cachedFindMatches === null) {
      this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
      this._cachedFindMatches.sort(Range.compareRangesUsingStarts);
    }
    return this._cachedFindMatches;
  }
};
__name(SelectionHighlighterState, "SelectionHighlighterState");
var SelectionHighlighter = /* @__PURE__ */ __name(class SelectionHighlighter2 extends Disposable {
  constructor(editor2, _languageFeaturesService) {
    super();
    this._languageFeaturesService = _languageFeaturesService;
    this.editor = editor2;
    this._isEnabled = editor2.getOption(100);
    this._decorations = editor2.createDecorationsCollection();
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor2.onDidChangeConfiguration((e) => {
      this._isEnabled = editor2.getOption(100);
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    const findController = CommonFindController.get(editor2);
    if (findController) {
      this._register(findController.getState().onFindReplaceStateChange((e) => {
        this._update();
      }));
    }
    this.updateSoon.schedule();
  }
  _update() {
    this._setState(SelectionHighlighter2._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(oldState, isEnabled, editor2) {
    if (!isEnabled) {
      return null;
    }
    if (!editor2.hasModel()) {
      return null;
    }
    const s = editor2.getSelection();
    if (s.startLineNumber !== s.endLineNumber) {
      return null;
    }
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor2.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor2, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (r.searchText.length > 200) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(editor2.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(122) : null, oldState);
  }
  _setState(newState) {
    this.state = newState;
    if (!this.state) {
      this._decorations.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const allMatches = this.state.findMatches();
    const selections = this.editor.getSelections();
    selections.sort(Range.compareRangesUsingStarts);
    const matches = [];
    for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
      const match = allMatches[i];
      if (j >= lenJ) {
        matches.push(match);
        i++;
      } else {
        const cmp = Range.compareRangesUsingStarts(match, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {
            matches.push(match);
          }
          i++;
        } else if (cmp > 0) {
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    const hasSemanticHighlights = this._languageFeaturesService.documentHighlightProvider.has(model) && this.editor.getOption(75);
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: getSelectionHighlightDecorationOptions(hasSemanticHighlights)
      };
    });
    this._decorations.set(decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
}, "SelectionHighlighter");
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter = __decorate59([
  __param59(1, ILanguageFeaturesService)
], SelectionHighlighter);
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range = ranges[i];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
__name(modelRangesContainSameText, "modelRangesContainSameText");
function getValueInRange(model, range, toLowerCase) {
  const text = model.getValueInRange(range);
  return toLowerCase ? text.toLowerCase() : text;
}
__name(getValueInRange, "getValueInRange");
var FocusNextCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusNextCursor",
      label: localize("mutlicursor.focusNextCursor", "Focus Next Cursor"),
      description: {
        description: localize("mutlicursor.focusNextCursor.description", "Focuses the next cursor"),
        args: []
      },
      alias: "Focus Next Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.shift();
    if (!firstCursor) {
      return;
    }
    previousCursorState.push(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(FocusNextCursor, "FocusNextCursor");
var FocusPreviousCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.focusPreviousCursor",
      label: localize("mutlicursor.focusPreviousCursor", "Focus Previous Cursor"),
      description: {
        description: localize("mutlicursor.focusPreviousCursor.description", "Focuses the previous cursor"),
        args: []
      },
      alias: "Focus Previous Cursor",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.model.pushStackElement();
    const previousCursorState = Array.from(viewModel.getCursorStates());
    const firstCursor = previousCursorState.pop();
    if (!firstCursor) {
      return;
    }
    previousCursorState.unshift(firstCursor);
    viewModel.setCursorStates(args.source, 3, previousCursorState);
    viewModel.revealPrimaryCursor(args.source, true);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
__name(FocusPreviousCursor, "FocusPreviousCursor");
registerEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController, 4);
registerEditorContribution(SelectionHighlighter.ID, SelectionHighlighter, 1);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);
registerEditorAction(FocusNextCursor);
registerEditorAction(FocusPreviousCursor);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_define_process();
init_lazy();
init_lifecycle();
init_editorExtensions();
init_editorContextKeys();
init_languages();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
init_define_process();
init_async();
init_errors();
init_event();
init_lifecycle();
init_characterClassifier();
init_languages();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/provideSignatureHelp.js
init_define_process();
init_cancellation();
init_errors();
init_types();
init_uri();
init_position();
init_languages();
init_languageFeatures();
init_resolverService();
init_commands();
init_contextkey();
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context2 = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(registry, model, position, context, token) {
  return __awaiter44(this, void 0, void 0, function* () {
    const supports = registry.ordered(model);
    for (const support of supports) {
      try {
        const result = yield support.provideSignatureHelp(model, position, token, context);
        if (result) {
          return result;
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }
    return void 0;
  });
}
__name(provideSignatureHelp, "provideSignatureHelp");
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter44(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = yield provideSignatureHelp(languageFeaturesService.signatureHelpProvider, ref.object.textEditorModel, Position.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return void 0;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsModel.js
var __awaiter45 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = { type: 0 };
  class Pending {
    constructor(request, previouslyActiveHints) {
      this.request = request;
      this.previouslyActiveHints = previouslyActiveHints;
      this.type = 2;
    }
  }
  __name(Pending, "Pending");
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  __name(Active, "Active");
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var ParameterHintsModel = class extends Disposable {
  constructor(editor2, providers, delay = ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor2;
    this.providers = providers;
    this.throttledDelayer = new Delayer(delay);
    this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(this.providers.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text) => this.onDidType(text)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context, delay) {
    const model = this.editor.getModel();
    if (!model || !this.providers.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length === length - 1;
    const cycle = this.editor.getOption(79).cycle;
    if ((length < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(79).cycle;
    if ((length < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
    this._onChangedHints.fire(this.state.hints);
  }
  doTrigger(triggerId) {
    return __awaiter45(this, void 0, void 0, function* () {
      const isRetrigger = this.state.type === 1 || this.state.type === 2;
      const activeSignatureHelp = this.getLastActiveHints();
      this.cancel(true);
      if (this._pendingTriggers.length === 0) {
        return false;
      }
      const context = this._pendingTriggers.reduce(mergeTriggerContexts);
      this._pendingTriggers = [];
      const triggerContext = {
        triggerKind: context.triggerKind,
        triggerCharacter: context.triggerCharacter,
        isRetrigger,
        activeSignatureHelp
      };
      if (!this.editor.hasModel()) {
        return false;
      }
      const model = this.editor.getModel();
      const position = this.editor.getPosition();
      this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(this.providers, model, position, triggerContext, token)), activeSignatureHelp);
      try {
        const result = yield this.state.request;
        if (triggerId !== this.triggerId) {
          result === null || result === void 0 ? void 0 : result.dispose();
          return false;
        }
        if (!result || !result.value.signatures || result.value.signatures.length === 0) {
          result === null || result === void 0 ? void 0 : result.dispose();
          this._lastSignatureHelpResult.clear();
          this.cancel();
          return false;
        } else {
          this.state = new ParameterHintState.Active(result.value);
          this._lastSignatureHelpResult.value = result;
          this._onChangedHints.fire(this.state.hints);
          return true;
        }
      } catch (error) {
        if (triggerId === this.triggerId) {
          this.state = ParameterHintState.Default;
        }
        onUnexpectedError(error);
        return false;
      }
    });
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return void 0;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars.clear();
    this.retriggerChars.clear();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of this.providers.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        if (ch.length) {
          const charCode = ch.charCodeAt(0);
          this.triggerChars.add(charCode);
          this.retriggerChars.add(charCode);
        }
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        if (ch.length) {
          this.retriggerChars.add(ch.charCodeAt(0));
        }
      }
    }
  }
  onDidType(text) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text.length - 1;
    const triggerCharCode = text.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(79).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
};
__name(ParameterHintsModel, "ParameterHintsModel");
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}
__name(mergeTriggerContexts, "mergeTriggerContexts");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
init_nls();
init_contextkey();
init_instantiation();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.js
init_define_process();
init_dom();
init_aria();
init_codicons();
init_event();
init_lifecycle();
init_strings();
init_types();
init_language();
init_nls();
init_contextkey();
init_opener();
init_colorRegistry();
init_themeService();
var __decorate60 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param60 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $8 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var ParameterHintsWidget = /* @__PURE__ */ __name(class ParameterHintsWidget2 extends Disposable {
  constructor(editor2, model, contextKeyService, openerService, languageService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor2 }, languageService, openerService));
    this.keyVisible = Context2.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context2.MultipleSignatures.bindTo(contextKeyService);
  }
  createParameterHintDOMNodes() {
    const element = $8(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $8(".phwrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $8(".controls"));
    const previous = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $8(".overloads"));
    const next = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, "click", (e) => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, "click", (e) => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $8(".body");
    const scrollbar = new DomScrollableElement(body, {
      alwaysConsumeMouseWheel: true
    });
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $8(".signature"));
    const docs = append(body, $8(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = /* @__PURE__ */ __name(() => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(45);
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
      this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
    }, "updateFont");
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(45)).on(updateFont, null));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      var _a6;
      (_a6 = this.domNodes) === null || _a6 === void 0 ? void 0 : _a6.element.classList.add("visible");
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    var _a6;
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    (_a6 = this.domNodes) === null || _a6 === void 0 ? void 0 : _a6.element.classList.remove("visible");
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [1, 2]
      };
    }
    return null;
  }
  render(hints) {
    var _a6;
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $8(".code"));
    const fontInfo = this.editor.getOption(45);
    code.style.fontSize = `${fontInfo.fontSize}px`;
    code.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = (_a6 = signature.activeParameter) !== null && _a6 !== void 0 ? _a6 : hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $8("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
      const documentation = $8("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $8("p", {}, documentation));
    }
    if (signature.documentation === void 0) {
    } else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $8("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle("has-docs", hasDocs);
    this.domNodes.docs.classList.toggle("empty", !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = "";
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize("hint", "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        var _a6;
        (_a6 = this.domNodes) === null || _a6 === void 0 ? void 0 : _a6.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add("markdown-docs");
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget2.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
}, "ParameterHintsWidget");
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = __decorate60([
  __param60(2, IContextKeyService),
  __param60(3, IOpenerService),
  __param60(4, ILanguageService)
], ParameterHintsWidget);
registerColor("editorHoverWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hcDark: listHighlightForeground, hcLight: listHighlightForeground }, localize("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/browser/parameterHints.js
var __decorate61 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param61 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsController = /* @__PURE__ */ __name(class ParameterHintsController2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(ParameterHintsController2.ID);
  }
  constructor(editor2, instantiationService, languageFeaturesService) {
    super();
    this.editor = editor2;
    this.model = this._register(new ParameterHintsModel(editor2, languageFeaturesService.signatureHelpProvider));
    this._register(this.model.onChangedHints((newParameterHints) => {
      var _a6;
      if (newParameterHints) {
        this.widget.getValue().show();
        this.widget.getValue().render(newParameterHints);
      } else {
        (_a6 = this.widget.rawValue) === null || _a6 === void 0 ? void 0 : _a6.hide();
      }
    }));
    this.widget = new Lazy(() => this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    var _a6;
    (_a6 = this.widget.rawValue) === null || _a6 === void 0 ? void 0 : _a6.previous();
  }
  next() {
    var _a6;
    (_a6 = this.widget.rawValue) === null || _a6 === void 0 ? void 0 : _a6.next();
  }
  trigger(context) {
    this.model.trigger(context, 0);
  }
}, "ParameterHintsController");
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = __decorate61([
  __param61(1, IInstantiationService),
  __param61(2, ILanguageFeaturesService)
], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const controller = ParameterHintsController.get(editor2);
    controller === null || controller === void 0 ? void 0 : controller.trigger({
      triggerKind: SignatureHelpTriggerKind.Invoke
    });
  }
};
__name(TriggerParameterHintsAction, "TriggerParameterHintsAction");
registerEditorContribution(ParameterHintsController.ID, ParameterHintsController, 2);
registerEditorAction(TriggerParameterHintsAction);
var weight3 = 100 + 75;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context2.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [512 | 16],
    mac: { primary: 16, secondary: [512 | 16, 256 | 46] }
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight: weight3,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [512 | 18],
    mac: { primary: 18, secondary: [512 | 18, 256 | 44] }
  }
}));

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
init_define_process();
init_aria();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_types();
init_uri();
init_editorState();
init_editorExtensions();
init_codeEditorService();
init_position();
init_range();
init_editorContextKeys();
init_textResourceConfiguration();
init_nls();
init_configurationRegistry();
init_contextkey();
init_instantiation();
init_log();
init_progress();
init_platform2();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/renameInputField.js
init_define_process();
init_lifecycle();
init_position();
init_nls();
init_contextkey();
init_colorRegistry();
init_themeService();
var __decorate62 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param62 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
var RenameInputField = /* @__PURE__ */ __name(class RenameInputField2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this.allowEditorOverflow = true;
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(45)) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._input = document.createElement("input");
      this._input.className = "rename-input";
      this._input.type = "text";
      this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._input);
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      const updateLabel = /* @__PURE__ */ __name(() => {
        var _a6, _b2;
        const [accept, preview] = this._acceptKeybindings;
        this._keybindingService.lookupKeybinding(accept);
        this._label.innerText = localize({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a6 = this._keybindingService.lookupKeybinding(accept)) === null || _a6 === void 0 ? void 0 : _a6.getLabel(), (_b2 = this._keybindingService.lookupKeybinding(preview)) === null || _b2 === void 0 ? void 0 : _b2.getLabel());
      }, "updateLabel");
      updateLabel();
      this._disposables.add(this._keybindingService.onDidUpdateKeybindings(updateLabel));
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme) {
    var _a6, _b2, _c2, _d2;
    if (!this._input || !this._domNode) {
      return;
    }
    const widgetShadowColor = theme.getColor(widgetShadow);
    this._domNode.style.backgroundColor = String((_a6 = theme.getColor(editorWidgetBackground)) !== null && _a6 !== void 0 ? _a6 : "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
    this._domNode.style.color = String((_b2 = theme.getColor(inputForeground)) !== null && _b2 !== void 0 ? _b2 : "");
    this._input.style.backgroundColor = String((_c2 = theme.getColor(inputBackground)) !== null && _c2 !== void 0 ? _c2 : "");
    const border = theme.getColor(inputBorder);
    this._input.style.borderWidth = border ? "1px" : "0px";
    this._input.style.borderStyle = border ? "solid" : "none";
    this._input.style.borderColor = (_d2 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d2 !== void 0 ? _d2 : "none";
  }
  _updateFont() {
    if (!this._input || !this._label) {
      return;
    }
    const fontInfo = this._editor.getOption(45);
    this._input.style.fontFamily = fontInfo.fontFamily;
    this._input.style.fontWeight = fontInfo.fontWeight;
    this._input.style.fontSize = `${fontInfo.fontSize}px`;
    this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    return {
      position: this._position,
      preference: [2, 1]
    };
  }
  afterRender(position) {
    if (!position) {
      this.cancelInput(true);
    }
  }
  acceptInput(wantsPreview) {
    var _a6;
    (_a6 = this._currentAcceptInput) === null || _a6 === void 0 ? void 0 : _a6.call(this, wantsPreview);
  }
  cancelInput(focusEditor) {
    var _a6;
    (_a6 = this._currentCancelInput) === null || _a6 === void 0 ? void 0 : _a6.call(this, focusEditor);
  }
  getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position(where.startLineNumber, where.startColumn);
    this._input.value = value;
    this._input.setAttribute("selectionStart", selectionStart.toString());
    this._input.setAttribute("selectionEnd", selectionEnd.toString());
    this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    const disposeOnDone = new DisposableStore();
    return new Promise((resolve) => {
      this._currentCancelInput = (focusEditor) => {
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve(focusEditor);
        return true;
      };
      this._currentAcceptInput = (wantsPreview) => {
        if (this._input.value.trim().length === 0 || this._input.value === value) {
          this.cancelInput(true);
          return;
        }
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve({
          newName: this._input.value,
          wantsPreview: supportPreview && wantsPreview
        });
      };
      disposeOnDone.add(token.onCancellationRequested(() => this.cancelInput(true)));
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(!document.hasFocus())));
      this._show();
    }).finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
  }
  _show() {
    this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0);
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._input.focus();
      this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  _hide() {
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
}, "RenameInputField");
RenameInputField = __decorate62([
  __param62(2, IThemeService),
  __param62(3, IKeybindingService),
  __param62(4, IContextKeyService)
], RenameInputField);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/rename/browser/rename.js
init_languageFeatures();
var __decorate63 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param63 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter46 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RenameSkeleton = class {
  constructor(model, position, registry) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = registry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  resolveRenameLocation(token) {
    return __awaiter46(this, void 0, void 0, function* () {
      const rejects = [];
      for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
        const provider = this._providers[this._providerRenameIdx];
        if (!provider.resolveRenameLocation) {
          break;
        }
        const res = yield provider.resolveRenameLocation(this.model, this.position, token);
        if (!res) {
          continue;
        }
        if (res.rejectReason) {
          rejects.push(res.rejectReason);
          continue;
        }
        return res;
      }
      const word = this.model.getWordAtPosition(this.position);
      if (!word) {
        return {
          range: Range.fromPositions(this.position),
          text: "",
          rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
        };
      }
      return {
        range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
        text: word.word,
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    });
  }
  provideRenameEdits(newName, token) {
    return __awaiter46(this, void 0, void 0, function* () {
      return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    });
  }
  _provideRenameEdits(newName, i, rejects, token) {
    return __awaiter46(this, void 0, void 0, function* () {
      const provider = this._providers[i];
      if (!provider) {
        return {
          edits: [],
          rejectReason: rejects.join("\n")
        };
      }
      const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
      if (!result) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
      } else if (result.rejectReason) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
      }
      return result;
    });
  }
};
__name(RenameSkeleton, "RenameSkeleton");
function rename(registry, model, position, newName) {
  return __awaiter46(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position, registry);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
__name(rename, "rename");
var RenameController = /* @__PURE__ */ __name(class RenameController2 {
  static get(editor2) {
    return editor2.getContribution(RenameController2.ID);
  }
  constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService, _languageFeaturesService) {
    this.editor = editor2;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._languageFeaturesService = _languageFeaturesService;
    this._disposableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameInputField = this._disposableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]));
  }
  dispose() {
    this._disposableStore.dispose();
    this._cts.dispose(true);
  }
  run() {
    var _a6, _b2;
    return __awaiter46(this, void 0, void 0, function* () {
      this._cts.dispose(true);
      if (!this.editor.hasModel()) {
        return void 0;
      }
      const position = this.editor.getPosition();
      const skeleton = new RenameSkeleton(this.editor.getModel(), position, this._languageFeaturesService.renameProvider);
      if (!skeleton.hasProvider()) {
        return void 0;
      }
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1);
      let loc;
      try {
        const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);
        this._progressService.showWhile(resolveLocationOperation, 250);
        loc = yield resolveLocationOperation;
      } catch (e) {
        (_a6 = MessageController.get(this.editor)) === null || _a6 === void 0 ? void 0 : _a6.showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
        return void 0;
      }
      if (!loc) {
        return void 0;
      }
      if (loc.rejectReason) {
        (_b2 = MessageController.get(this.editor)) === null || _b2 === void 0 ? void 0 : _b2.showMessage(loc.rejectReason, position);
        return void 0;
      }
      if (this._cts.token.isCancellationRequested) {
        return void 0;
      }
      this._cts.dispose();
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range);
      const selection = this.editor.getSelection();
      let selectionStart = 0;
      let selectionEnd = loc.text.length;
      if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
        selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
        selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
      }
      const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
      const inputFieldResult = yield this._renameInputField.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);
      if (typeof inputFieldResult === "boolean") {
        if (inputFieldResult) {
          this.editor.focus();
        }
        return void 0;
      }
      this.editor.focus();
      const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter46(this, void 0, void 0, function* () {
        if (!renameResult || !this.editor.hasModel()) {
          return;
        }
        if (renameResult.rejectReason) {
          this._notificationService.info(renameResult.rejectReason);
          return;
        }
        this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
        this._bulkEditService.apply(renameResult, {
          editor: this.editor,
          showPreview: inputFieldResult.wantsPreview,
          label: localize("label", "Renaming '{0}' to '{1}'", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          code: "undoredo.rename",
          quotableLabel: localize("quotableLabel", "Renaming {0} to {1}", loc === null || loc === void 0 ? void 0 : loc.text, inputFieldResult.newName),
          respectAutoSaveConfig: true
        }).then((result) => {
          if (result.ariaSummary) {
            alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
          }
        }).catch((err) => {
          this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
          this._logService.error(err);
        });
      }), (err) => {
        this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
        this._logService.error(err);
      });
      this._progressService.showWhile(renameOperation, 250);
      return renameOperation;
    });
  }
  acceptRenameInput(wantsPreview) {
    this._renameInputField.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameInputField.cancelInput(true);
  }
}, "RenameController");
RenameController.ID = "editor.contrib.renameController";
RenameController = __decorate63([
  __param63(1, IInstantiationService),
  __param63(2, INotificationService),
  __param63(3, IBulkEditService),
  __param63(4, IEditorProgressService),
  __param63(5, ILogService),
  __param63(6, ITextResourceConfigurationService),
  __param63(7, ILanguageFeaturesService)
], RenameController);
var RenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor2) {
    const controller = RenameController.get(editor2);
    if (controller) {
      return controller.run();
    }
    return Promise.resolve();
  }
};
__name(RenameAction, "RenameAction");
registerEditorContribution(RenameController.ID, RenameController, 4);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 1024 + 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(accessor, model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  const { renameProvider } = accessor.get(ILanguageFeaturesService);
  return rename(renameProvider, model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", function(accessor, model, position) {
  return __awaiter46(this, void 0, void 0, function* () {
    const { renameProvider } = accessor.get(ILanguageFeaturesService);
    const skeleton = new RenameSkeleton(model, position, renameProvider);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      throw new Error(loc.rejectReason);
    }
    return loc;
  });
});
Registry.as(Extensions.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_define_process();
init_editorExtensions();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
init_define_process();
init_nls();

// ../../node_modules/monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js
init_define_process();
init_nls();
var Categories = Object.freeze({
  View: { value: localize("view", "View"), original: "View" },
  Help: { value: localize("help", "Help"), original: "Help" },
  Test: { value: localize("test", "Test"), original: "Test" },
  Preferences: { value: localize("preferences", "Preferences"), original: "Preferences" },
  Developer: { value: localize({ key: "developer", comment: ["A developer on Code itself or someone diagnosing issues in Code"] }, "Developer"), original: "Developer" }
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollActions.js
init_actions2();
init_configuration();
init_contextkey();
var __awaiter47 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ToggleStickyScroll = class extends Action2 {
  constructor() {
    super({
      id: "editor.action.toggleStickyScroll",
      title: {
        value: localize("toggleStickyScroll", "Toggle Sticky Scroll"),
        mnemonicTitle: localize({ key: "mitoggleStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Toggle Sticky Scroll"),
        original: "Toggle Sticky Scroll"
      },
      category: Categories.View,
      toggled: {
        condition: ContextKeyExpr.equals("config.editor.stickyScroll.enabled", true),
        title: localize("stickyScroll", "Sticky Scroll"),
        mnemonicTitle: localize({ key: "miStickyScroll", comment: ["&& denotes a mnemonic"] }, "&&Sticky Scroll")
      },
      menu: [
        { id: MenuId.CommandPalette },
        { id: MenuId.MenubarViewMenu, group: "5_editor", order: 2 },
        { id: MenuId.StickyScrollContext }
      ]
    });
  }
  run(accessor) {
    return __awaiter47(this, void 0, void 0, function* () {
      const configurationService = accessor.get(IConfigurationService);
      const newValue = !configurationService.getValue("editor.stickyScroll.enabled");
      return configurationService.updateValue("editor.stickyScroll.enabled", newValue);
    });
  }
};
__name(ToggleStickyScroll, "ToggleStickyScroll");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_define_process();
init_lifecycle();
init_languageFeatures();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollWidget.js
init_define_process();
init_lifecycle();
init_dom();
init_stringBuilder();
init_position();
init_languageFeatures();
init_instantiation();
init_cancellation();
init_range();
init_mouseEvent();
var __decorate64 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param64 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter48 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a5;
var StickyScrollWidgetState = class {
  constructor(lineNumbers, lastLineRelativePosition) {
    this.lineNumbers = lineNumbers;
    this.lastLineRelativePosition = lastLineRelativePosition;
  }
};
__name(StickyScrollWidgetState, "StickyScrollWidgetState");
var _ttPolicy = (_a5 = window.trustedTypes) === null || _a5 === void 0 ? void 0 : _a5.createPolicy("stickyScrollViewLayer", { createHTML: (value) => value });
var StickyScrollWidget = /* @__PURE__ */ __name(class StickyScrollWidget2 extends Disposable {
  constructor(_editor, _languageFeatureService, _instaService) {
    super();
    this._editor = _editor;
    this._languageFeatureService = _languageFeatureService;
    this._instaService = _instaService;
    this._rootDomNode = document.createElement("div");
    this._disposableStore = this._register(new DisposableStore());
    this._layoutInfo = this._editor.getLayoutInfo();
    this._rootDomNode = document.createElement("div");
    this._rootDomNode.className = "sticky-widget";
    this._rootDomNode.style.width = `${this._layoutInfo.width - this._layoutInfo.minimap.minimapCanvasOuterWidth - this._layoutInfo.verticalScrollbarWidth}px`;
    this._lineNumbers = [];
    this._lastLineRelativePosition = 0;
    this._hoverOnLine = -1;
    this._hoverOnColumn = -1;
    this._stickyRangeProjectedOnEditor = null;
    this._candidateDefinitionsLength = -1;
    this._lineHeight = this._editor.getOption(61);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(61)) {
        this._lineHeight = this._editor.getOption(61);
      }
    }));
    this._register(this.updateLinkGesture());
  }
  updateLinkGesture() {
    const linkGestureStore = new DisposableStore();
    const sessionStore = new DisposableStore();
    linkGestureStore.add(sessionStore);
    const gesture = new ClickLinkGesture(this._editor, true);
    linkGestureStore.add(gesture);
    linkGestureStore.add(gesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, _keyboardEvent]) => {
      if (!this._editor.hasModel() || !mouseEvent.hasTriggerModifier) {
        sessionStore.clear();
        return;
      }
      const targetMouseEvent = mouseEvent.target;
      if (targetMouseEvent.detail === this.getId() && targetMouseEvent.element.innerText === targetMouseEvent.element.innerHTML) {
        const text = targetMouseEvent.element.innerText;
        if (this._hoverOnColumn === -1) {
          return;
        }
        const lineNumber = this._hoverOnLine;
        const column = this._hoverOnColumn;
        const stickyPositionProjectedOnEditor = new Range(lineNumber, column, lineNumber, column + text.length);
        if (!stickyPositionProjectedOnEditor.equalsRange(this._stickyRangeProjectedOnEditor)) {
          this._stickyRangeProjectedOnEditor = stickyPositionProjectedOnEditor;
          sessionStore.clear();
        } else if (targetMouseEvent.element.style.textDecoration === "underline") {
          return;
        }
        const cancellationToken = new CancellationTokenSource();
        sessionStore.add(toDisposable(() => cancellationToken.dispose(true)));
        let currentHTMLChild;
        getDefinitionsAtPosition(this._languageFeatureService.definitionProvider, this._editor.getModel(), new Position(lineNumber, column + 1), cancellationToken.token).then((candidateDefinitions) => {
          if (cancellationToken.token.isCancellationRequested) {
            return;
          }
          if (candidateDefinitions.length !== 0) {
            this._candidateDefinitionsLength = candidateDefinitions.length;
            const childHTML = targetMouseEvent.element;
            if (currentHTMLChild !== childHTML) {
              sessionStore.clear();
              currentHTMLChild = childHTML;
              currentHTMLChild.style.textDecoration = "underline";
              sessionStore.add(toDisposable(() => {
                currentHTMLChild.style.textDecoration = "none";
              }));
            } else if (!currentHTMLChild) {
              currentHTMLChild = childHTML;
              currentHTMLChild.style.textDecoration = "underline";
              sessionStore.add(toDisposable(() => {
                currentHTMLChild.style.textDecoration = "none";
              }));
            }
          } else {
            sessionStore.clear();
          }
        });
      } else {
        sessionStore.clear();
      }
    }));
    linkGestureStore.add(gesture.onCancel(() => {
      sessionStore.clear();
    }));
    linkGestureStore.add(gesture.onExecute((e) => __awaiter48(this, void 0, void 0, function* () {
      if (e.target.detail !== this.getId()) {
        return;
      }
      if (e.hasTriggerModifier) {
        if (this._candidateDefinitionsLength > 1) {
          this._editor.revealPosition({ lineNumber: this._hoverOnLine, column: 1 });
        }
        this._instaService.invokeFunction(goToDefinitionWithLocation, e, this._editor, { uri: this._editor.getModel().uri, range: this._stickyRangeProjectedOnEditor });
      } else if (!e.isRightClick) {
        this._editor.revealPosition({ lineNumber: this._hoverOnLine, column: 1 });
      }
    })));
    return linkGestureStore;
  }
  getCurrentLines() {
    return this._lineNumbers;
  }
  setState(state) {
    this._disposableStore.clear();
    this._lineNumbers.length = 0;
    clearNode(this._rootDomNode);
    this._lastLineRelativePosition = state.lastLineRelativePosition;
    this._lineNumbers = state.lineNumbers;
    this.renderRootNode();
  }
  getChildNode(index, line) {
    const child = document.createElement("div");
    const viewModel = this._editor._getViewModel();
    const viewLineNumber = viewModel.coordinatesConverter.convertModelPositionToViewPosition(new Position(line, 1)).lineNumber;
    const lineRenderingData = viewModel.getViewLineRenderingData(viewLineNumber);
    const layoutInfo = this._editor.getLayoutInfo();
    const width = layoutInfo.width - layoutInfo.minimap.minimapCanvasOuterWidth - layoutInfo.verticalScrollbarWidth;
    const minimapSide = this._editor.getOption(67).side;
    const lineHeight = this._editor.getOption(61);
    const lineNumberOption = this._editor.getOption(62);
    let actualInlineDecorations;
    try {
      actualInlineDecorations = LineDecoration.filter(lineRenderingData.inlineDecorations, viewLineNumber, lineRenderingData.minColumn, lineRenderingData.maxColumn);
    } catch (err) {
      actualInlineDecorations = [];
    }
    const renderLineInput = new RenderLineInput(true, true, lineRenderingData.content, lineRenderingData.continuesWithWrappedLine, lineRenderingData.isBasicASCII, lineRenderingData.containsRTL, 0, lineRenderingData.tokens, actualInlineDecorations, lineRenderingData.tabSize, lineRenderingData.startVisibleColumn, 1, 1, 1, 500, "none", true, true, null);
    const sb = new StringBuilder(2e3);
    renderViewLine(renderLineInput, sb);
    let newLine;
    if (_ttPolicy) {
      newLine = _ttPolicy.createHTML(sb.build());
    } else {
      newLine = sb.build();
    }
    const lineHTMLNode = document.createElement("span");
    lineHTMLNode.className = "sticky-line";
    lineHTMLNode.classList.add(`stickyLine${line}`);
    lineHTMLNode.style.lineHeight = `${lineHeight}px`;
    lineHTMLNode.innerHTML = newLine;
    const lineNumberHTMLNode = document.createElement("span");
    lineNumberHTMLNode.className = "sticky-line";
    lineNumberHTMLNode.style.lineHeight = `${lineHeight}px`;
    if (minimapSide === "left") {
      lineNumberHTMLNode.style.width = `${layoutInfo.contentLeft - layoutInfo.minimap.minimapCanvasOuterWidth}px`;
    } else if (minimapSide === "right") {
      lineNumberHTMLNode.style.width = `${layoutInfo.contentLeft}px`;
    }
    const innerLineNumberHTML = document.createElement("span");
    if (lineNumberOption.renderType === 1 || lineNumberOption.renderType === 3 && line % 10 === 0) {
      innerLineNumberHTML.innerText = line.toString();
    } else if (lineNumberOption.renderType === 2) {
      innerLineNumberHTML.innerText = Math.abs(line - this._editor.getPosition().lineNumber).toString();
    }
    innerLineNumberHTML.className = "sticky-line-number";
    innerLineNumberHTML.style.lineHeight = `${lineHeight}px`;
    innerLineNumberHTML.style.width = `${layoutInfo.lineNumbersWidth}px`;
    if (minimapSide === "left") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft - layoutInfo.minimap.minimapCanvasOuterWidth}px`;
    } else if (minimapSide === "right") {
      innerLineNumberHTML.style.paddingLeft = `${layoutInfo.lineNumbersLeft}px`;
    }
    lineNumberHTMLNode.appendChild(innerLineNumberHTML);
    this._editor.applyFontInfo(lineHTMLNode);
    this._editor.applyFontInfo(innerLineNumberHTML);
    child.appendChild(lineNumberHTMLNode);
    child.appendChild(lineHTMLNode);
    child.className = "sticky-line-root";
    child.style.lineHeight = `${lineHeight}px`;
    child.style.width = `${width}px`;
    child.style.height = `${lineHeight}px`;
    child.style.zIndex = "0";
    if (index === this._lineNumbers.length - 1) {
      child.style.position = "relative";
      child.style.zIndex = "-1";
      child.style.top = this._lastLineRelativePosition + "px";
    }
    this._disposableStore.add(addDisposableListener(child, "mouseover", (e) => {
      if (this._editor.hasModel()) {
        const mouseOverEvent = new StandardMouseEvent(e);
        const text = mouseOverEvent.target.innerText;
        this._hoverOnLine = line;
        this._hoverOnColumn = this._editor.getModel().getLineContent(line).indexOf(text) + 1 || -1;
      }
    }));
    return child;
  }
  renderRootNode() {
    if (!this._editor._getViewModel()) {
      return;
    }
    for (const [index, line] of this._lineNumbers.entries()) {
      this._rootDomNode.appendChild(this.getChildNode(index, line));
    }
    const widgetHeight = this._lineNumbers.length * this._lineHeight + this._lastLineRelativePosition;
    this._rootDomNode.style.height = widgetHeight.toString() + "px";
    const minimapSide = this._editor.getOption(67).side;
    if (minimapSide === "left") {
      this._rootDomNode.style.marginLeft = this._editor.getLayoutInfo().minimap.minimapCanvasOuterWidth + "px";
    } else if (minimapSide === "right") {
      this._rootDomNode.style.marginLeft = "1px";
    }
    this._rootDomNode.style.zIndex = "11";
  }
  getId() {
    return "editor.contrib.stickyScrollWidget";
  }
  getDomNode() {
    return this._rootDomNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
  dispose() {
    super.dispose();
  }
}, "StickyScrollWidget");
StickyScrollWidget = __decorate64([
  __param64(1, ILanguageFeaturesService),
  __param64(2, IInstantiationService)
], StickyScrollWidget);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollProvider.js
init_define_process();
init_lifecycle();
init_languageFeatures();
init_outlineModel();
init_cancellation();
init_async();
init_event();
init_arrays();
init_iterator();
init_resources();
var __decorate65 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param65 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter49 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StickyRange = class {
  constructor(startLineNumber, endLineNumber) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
  }
};
__name(StickyRange, "StickyRange");
var StickyLineCandidate = class {
  constructor(startLineNumber, endLineNumber, nestingDepth) {
    this.startLineNumber = startLineNumber;
    this.endLineNumber = endLineNumber;
    this.nestingDepth = nestingDepth;
  }
};
__name(StickyLineCandidate, "StickyLineCandidate");
var StickyLineCandidateProvider = /* @__PURE__ */ __name(class StickyLineCandidateProvider2 extends Disposable {
  constructor(editor2, languageFeaturesService) {
    super();
    this._onDidChangeStickyScroll = this._store.add(new Emitter());
    this.onDidChangeStickyScroll = this._onDidChangeStickyScroll.event;
    this._sessionStore = new DisposableStore();
    this._editor = editor2;
    this._languageFeaturesService = languageFeaturesService;
    this._updateSoon = this._register(new RunOnceScheduler(() => this.update(), 50));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(107)) {
        this.readConfiguration();
      }
    }));
    this.readConfiguration();
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
  readConfiguration() {
    const options = this._editor.getOption(107);
    if (options.enabled === false) {
      this._sessionStore.clear();
      return;
    } else {
      this._sessionStore.add(this._editor.onDidChangeModel(() => {
        this.update();
      }));
      this._sessionStore.add(this._editor.onDidChangeHiddenAreas(() => this.update()));
      this._sessionStore.add(this._editor.onDidChangeModelContent(() => this._updateSoon.schedule()));
      this._sessionStore.add(this._languageFeaturesService.documentSymbolProvider.onDidChange(() => {
        this.update();
      }));
      this.update();
    }
  }
  getVersionId() {
    var _a6;
    return (_a6 = this._model) === null || _a6 === void 0 ? void 0 : _a6.version;
  }
  update() {
    var _a6;
    return __awaiter49(this, void 0, void 0, function* () {
      (_a6 = this._cts) === null || _a6 === void 0 ? void 0 : _a6.dispose(true);
      this._cts = new CancellationTokenSource();
      yield this.updateOutlineModel(this._cts.token);
      this._onDidChangeStickyScroll.fire();
    });
  }
  updateOutlineModel(token) {
    var _a6;
    return __awaiter49(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      const isDifferentModel = this._model ? !isEqual(this._model.uri, model.uri) : false;
      const resetHandle = isDifferentModel ? setTimeout(() => {
        if (!token.isCancellationRequested) {
          this._model = new StickyOutlineModel(model.uri, model.getVersionId(), void 0, void 0);
          this._onDidChangeStickyScroll.fire();
        }
      }, 75) : void 0;
      const outlineModel = yield OutlineModel.create(this._languageFeaturesService.documentSymbolProvider, model, token);
      if (token.isCancellationRequested) {
        return;
      }
      if (outlineModel.children.size !== 0) {
        const { stickyOutlineElement, providerID } = StickyOutlineElement.fromOutlineModel(outlineModel, (_a6 = this._model) === null || _a6 === void 0 ? void 0 : _a6.outlineProviderId);
        this._model = new StickyOutlineModel(model.uri, modelVersionId, stickyOutlineElement, providerID);
      } else {
        const foldingController = FoldingController.get(this._editor);
        const foldingModel = yield foldingController === null || foldingController === void 0 ? void 0 : foldingController.getFoldingModel();
        if (token.isCancellationRequested) {
          return;
        }
        if (foldingModel && foldingModel.regions.length !== 0) {
          const foldingElement = StickyOutlineElement.fromFoldingModel(foldingModel);
          this._model = new StickyOutlineModel(model.uri, modelVersionId, foldingElement, void 0);
        } else {
          this._model = void 0;
        }
      }
      clearTimeout(resetHandle);
    });
  }
  updateIndex(index) {
    if (index === -1) {
      index = 0;
    } else if (index < 0) {
      index = -index - 2;
    }
    return index;
  }
  getCandidateStickyLinesIntersectingFromOutline(range, outlineModel, result, depth, lastStartLineNumber) {
    if (outlineModel.children.length === 0) {
      return;
    }
    let lastLine = lastStartLineNumber;
    const childrenStartLines = [];
    for (let i = 0; i < outlineModel.children.length; i++) {
      const child = outlineModel.children[i];
      if (child.range) {
        childrenStartLines.push(child.range.startLineNumber);
      }
    }
    const lowerBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber, (a, b) => {
      return a - b;
    }));
    const upperBound = this.updateIndex(binarySearch(childrenStartLines, range.startLineNumber + depth, (a, b) => {
      return a - b;
    }));
    for (let i = lowerBound; i <= upperBound; i++) {
      const child = outlineModel.children[i];
      if (!child) {
        return;
      }
      if (child.range) {
        const childStartLine = child.range.startLineNumber;
        const childEndLine = child.range.endLineNumber;
        if (range.startLineNumber <= childEndLine + 1 && childStartLine - 1 <= range.endLineNumber && childStartLine !== lastLine) {
          lastLine = childStartLine;
          result.push(new StickyLineCandidate(childStartLine, childEndLine - 1, depth + 1));
          this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth + 1, childStartLine);
        }
      } else {
        this.getCandidateStickyLinesIntersectingFromOutline(range, child, result, depth, lastStartLineNumber);
      }
    }
  }
  getCandidateStickyLinesIntersecting(range) {
    var _a6, _b2;
    if (!((_a6 = this._model) === null || _a6 === void 0 ? void 0 : _a6.element)) {
      return [];
    }
    let stickyLineCandidates = [];
    this.getCandidateStickyLinesIntersectingFromOutline(range, this._model.element, stickyLineCandidates, 0, -1);
    const hiddenRanges = (_b2 = this._editor._getViewModel()) === null || _b2 === void 0 ? void 0 : _b2.getHiddenAreas();
    if (hiddenRanges) {
      for (const hiddenRange of hiddenRanges) {
        stickyLineCandidates = stickyLineCandidates.filter((stickyLine) => !(stickyLine.startLineNumber >= hiddenRange.startLineNumber && stickyLine.endLineNumber <= hiddenRange.endLineNumber + 1));
      }
    }
    return stickyLineCandidates;
  }
}, "StickyLineCandidateProvider");
StickyLineCandidateProvider = __decorate65([
  __param65(1, ILanguageFeaturesService)
], StickyLineCandidateProvider);
var StickyOutlineElement = class {
  static comparator(range1, range2) {
    if (range1.startLineNumber !== range2.startLineNumber) {
      return range1.startLineNumber - range2.startLineNumber;
    } else {
      return range2.endLineNumber - range1.endLineNumber;
    }
  }
  static fromOutlineElement(outlineElement, previousStartLine) {
    const children = [];
    for (const child of outlineElement.children.values()) {
      if (child.symbol.selectionRange.startLineNumber !== child.symbol.range.endLineNumber) {
        if (child.symbol.selectionRange.startLineNumber !== previousStartLine) {
          children.push(StickyOutlineElement.fromOutlineElement(child, child.symbol.selectionRange.startLineNumber));
        } else {
          for (const subchild of child.children.values()) {
            children.push(StickyOutlineElement.fromOutlineElement(subchild, child.symbol.selectionRange.startLineNumber));
          }
        }
      }
    }
    children.sort((child1, child2) => this.comparator(child1.range, child2.range));
    const range = new StickyRange(outlineElement.symbol.selectionRange.startLineNumber, outlineElement.symbol.range.endLineNumber);
    return new StickyOutlineElement(range, children, void 0);
  }
  static fromOutlineModel(outlineModel, preferredProvider) {
    let outlineElements;
    if (Iterable.first(outlineModel.children.values()) instanceof OutlineGroup) {
      const provider = Iterable.find(outlineModel.children.values(), (outlineGroupOfModel) => outlineGroupOfModel.id === preferredProvider);
      if (provider) {
        outlineElements = provider.children;
      } else {
        let tempID = "";
        let maxTotalSumOfRanges = -1;
        let optimalOutlineGroup = void 0;
        for (const [_key, outlineGroup] of outlineModel.children.entries()) {
          const totalSumRanges = StickyOutlineElement.findSumOfRangesOfGroup(outlineGroup);
          if (totalSumRanges > maxTotalSumOfRanges) {
            optimalOutlineGroup = outlineGroup;
            maxTotalSumOfRanges = totalSumRanges;
            tempID = outlineGroup.id;
          }
        }
        preferredProvider = tempID;
        outlineElements = optimalOutlineGroup.children;
      }
    } else {
      outlineElements = outlineModel.children;
    }
    const stickyChildren = [];
    const outlineElementsArray = Array.from(outlineElements.values()).sort((element1, element2) => {
      const range1 = new StickyRange(element1.symbol.range.startLineNumber, element1.symbol.range.endLineNumber);
      const range2 = new StickyRange(element2.symbol.range.startLineNumber, element2.symbol.range.endLineNumber);
      return this.comparator(range1, range2);
    });
    for (const outlineElement of outlineElementsArray) {
      stickyChildren.push(StickyOutlineElement.fromOutlineElement(outlineElement, outlineElement.symbol.selectionRange.startLineNumber));
    }
    const stickyOutlineElement = new StickyOutlineElement(void 0, stickyChildren, void 0);
    return {
      stickyOutlineElement,
      providerID: preferredProvider
    };
  }
  static findSumOfRangesOfGroup(outline) {
    let res = 0;
    for (const child of outline.children.values()) {
      res += this.findSumOfRangesOfGroup(child);
    }
    if (outline instanceof OutlineElement) {
      return res + outline.symbol.range.endLineNumber - outline.symbol.selectionRange.startLineNumber;
    } else {
      return res;
    }
  }
  static fromFoldingModel(foldingModel) {
    const regions = foldingModel.regions;
    const length = regions.length;
    let range;
    const stackOfParents = [];
    const stickyOutlineElement = new StickyOutlineElement(void 0, [], void 0);
    let parentStickyOutlineElement = stickyOutlineElement;
    for (let i = 0; i < length; i++) {
      range = new StickyRange(regions.getStartLineNumber(i), regions.getEndLineNumber(i) + 1);
      while (stackOfParents.length !== 0 && (range.startLineNumber < stackOfParents[stackOfParents.length - 1].startLineNumber || range.endLineNumber > stackOfParents[stackOfParents.length - 1].endLineNumber)) {
        stackOfParents.pop();
        if (parentStickyOutlineElement.parent !== void 0) {
          parentStickyOutlineElement = parentStickyOutlineElement.parent;
        }
      }
      const child = new StickyOutlineElement(range, [], parentStickyOutlineElement);
      parentStickyOutlineElement.children.push(child);
      parentStickyOutlineElement = child;
      stackOfParents.push(range);
    }
    return stickyOutlineElement;
  }
  constructor(range, children, parent) {
    this.range = range;
    this.children = children;
    this.parent = parent;
  }
};
__name(StickyOutlineElement, "StickyOutlineElement");
var StickyOutlineModel = class {
  constructor(uri, version, element, outlineProviderId) {
    this.uri = uri;
    this.version = version;
    this.element = element;
    this.outlineProviderId = outlineProviderId;
  }
};
__name(StickyOutlineModel, "StickyOutlineModel");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollController.js
init_instantiation();
init_dom();
init_actions2();
var __decorate66 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param66 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter50 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StickyScrollController = /* @__PURE__ */ __name(class StickyScrollController2 extends Disposable {
  constructor(_editor, _languageFeaturesService, _instaService, _contextMenuService) {
    super();
    this._contextMenuService = _contextMenuService;
    this._sessionStore = new DisposableStore();
    this._editor = _editor;
    this._stickyScrollWidget = new StickyScrollWidget(this._editor, _languageFeaturesService, _instaService);
    this._stickyLineCandidateProvider = new StickyLineCandidateProvider(this._editor, _languageFeaturesService);
    this._widgetState = new StickyScrollWidgetState([], 0);
    this._register(this._stickyScrollWidget);
    this._register(this._stickyLineCandidateProvider);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(107)) {
        this.readConfiguration();
      }
    }));
    this.readConfiguration();
    this._register(addDisposableListener(this._stickyScrollWidget.getDomNode(), EventType.CONTEXT_MENU, (event) => __awaiter50(this, void 0, void 0, function* () {
      this.onContextMenu(event);
    })));
  }
  onContextMenu(event) {
    this._contextMenuService.showContextMenu({
      menuId: MenuId.StickyScrollContext,
      getAnchor: () => event
    });
  }
  readConfiguration() {
    const options = this._editor.getOption(107);
    if (options.enabled === false) {
      this._editor.removeOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.clear();
      return;
    } else {
      this._editor.addOverlayWidget(this._stickyScrollWidget);
      this._sessionStore.add(this._editor.onDidScrollChange(() => this.renderStickyScroll()));
      this._sessionStore.add(this._editor.onDidLayoutChange(() => this.onDidResize()));
      this._sessionStore.add(this._editor.onDidChangeModelTokens((e) => this.onTokensChange(e)));
      this._sessionStore.add(this._stickyLineCandidateProvider.onDidChangeStickyScroll(() => this.renderStickyScroll()));
      const lineNumberOption = this._editor.getOption(62);
      if (lineNumberOption.renderType === 2) {
        this._sessionStore.add(this._editor.onDidChangeCursorPosition(() => this.renderStickyScroll()));
      }
    }
  }
  needsUpdate(event) {
    const stickyLineNumbers = this._stickyScrollWidget.getCurrentLines();
    for (const stickyLineNumber of stickyLineNumbers) {
      for (const range of event.ranges) {
        if (stickyLineNumber >= range.fromLineNumber && stickyLineNumber <= range.toLineNumber) {
          return true;
        }
      }
    }
    return false;
  }
  onTokensChange(event) {
    if (this.needsUpdate(event)) {
      this.renderStickyScroll();
    }
  }
  onDidResize() {
    const width = this._editor.getLayoutInfo().width - this._editor.getLayoutInfo().minimap.minimapCanvasOuterWidth - this._editor.getLayoutInfo().verticalScrollbarWidth;
    this._stickyScrollWidget.getDomNode().style.width = `${width}px`;
  }
  renderStickyScroll() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const stickyLineVersion = this._stickyLineCandidateProvider.getVersionId();
    if (stickyLineVersion === void 0 || stickyLineVersion === model.getVersionId()) {
      this._widgetState = this.getScrollWidgetState();
      this._stickyScrollWidget.setState(this._widgetState);
    }
  }
  getScrollWidgetState() {
    const lineHeight = this._editor.getOption(61);
    const maxNumberStickyLines = this._editor.getOption(107).maxLineCount;
    const scrollTop = this._editor.getScrollTop();
    let lastLineRelativePosition = 0;
    const lineNumbers = [];
    const arrayVisibleRanges = this._editor.getVisibleRanges();
    if (arrayVisibleRanges.length !== 0) {
      const fullVisibleRange = new StickyRange(arrayVisibleRanges[0].startLineNumber, arrayVisibleRanges[arrayVisibleRanges.length - 1].endLineNumber);
      const candidateRanges = this._stickyLineCandidateProvider.getCandidateStickyLinesIntersecting(fullVisibleRange);
      for (const range of candidateRanges) {
        const start = range.startLineNumber;
        const end = range.endLineNumber;
        const depth = range.nestingDepth;
        if (end - start > 0) {
          const topOfElementAtDepth = (depth - 1) * lineHeight;
          const bottomOfElementAtDepth = depth * lineHeight;
          const bottomOfBeginningLine = this._editor.getBottomForLineNumber(start) - scrollTop;
          const topOfEndLine = this._editor.getTopForLineNumber(end) - scrollTop;
          const bottomOfEndLine = this._editor.getBottomForLineNumber(end) - scrollTop;
          if (topOfElementAtDepth > topOfEndLine && topOfElementAtDepth <= bottomOfEndLine) {
            lineNumbers.push(start);
            lastLineRelativePosition = bottomOfEndLine - bottomOfElementAtDepth;
            break;
          } else if (bottomOfElementAtDepth > bottomOfBeginningLine && bottomOfElementAtDepth <= bottomOfEndLine) {
            lineNumbers.push(start);
          }
          if (lineNumbers.length === maxNumberStickyLines) {
            break;
          }
        }
      }
    }
    return new StickyScrollWidgetState(lineNumbers, lastLineRelativePosition);
  }
  dispose() {
    super.dispose();
    this._sessionStore.dispose();
  }
}, "StickyScrollController");
StickyScrollController.ID = "store.contrib.stickyScrollController";
StickyScrollController = __decorate66([
  __param66(1, ILanguageFeaturesService),
  __param66(2, IInstantiationService),
  __param66(3, IContextMenuService)
], StickyScrollController);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/stickyScroll/browser/stickyScrollContribution.js
init_actions2();
registerEditorContribution(StickyScrollController.ID, StickyScrollController, 1);
registerAction2(ToggleStickyScroll);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_define_process();
init_arrays();
init_cancellation();
init_errors();
init_editorExtensions();
init_position();
init_range();
init_selection();
init_editorContextKeys();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/wordSelections.js
init_define_process();
init_strings();
init_range();
var WordSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      this._addInWordRanges(bucket, model, position);
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({ range: model.getFullModelRange() });
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    const { word, startColumn } = obj;
    const offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      const ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      const ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
    }
  }
};
__name(WordSelectionRangeProvider, "WordSelectionRangeProvider");

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/smartSelect.js
init_nls();
init_actions2();
init_commands();
init_languageFeatures();
init_resolverService();
init_types();
init_uri();
var __decorate67 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param67 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter51 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionRanges = class {
  constructor(index, ranges) {
    this.index = index;
    this.ranges = ranges;
  }
  mov(fwd) {
    const index = this.index + (fwd ? 1 : -1);
    if (index < 0 || index >= this.ranges.length) {
      return this;
    }
    const res = new SelectionRanges(index, this.ranges);
    if (res.ranges[index].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
};
__name(SelectionRanges, "SelectionRanges");
var SmartSelectController = /* @__PURE__ */ __name(class SmartSelectController2 {
  static get(editor2) {
    return editor2.getContribution(SmartSelectController2.ID);
  }
  constructor(_editor, _languageFeaturesService) {
    this._editor = _editor;
    this._languageFeaturesService = _languageFeaturesService;
    this._ignoreSelection = false;
  }
  dispose() {
    var _a6;
    (_a6 = this._selectionListener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
  }
  run(forward) {
    return __awaiter51(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const selections = this._editor.getSelections();
      const model = this._editor.getModel();
      if (!this._state) {
        yield provideSelectionRanges(this._languageFeaturesService.selectionRangeProvider, model, selections.map((s) => s.getPosition()), this._editor.getOption(105), CancellationToken.None).then((ranges) => {
          var _a6;
          if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
            return;
          }
          if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
            return;
          }
          for (let i = 0; i < ranges.length; i++) {
            ranges[i] = ranges[i].filter((range) => {
              return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
            });
            ranges[i].unshift(selections[i]);
          }
          this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
          (_a6 = this._selectionListener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
          this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
            var _a7;
            if (!this._ignoreSelection) {
              (_a7 = this._selectionListener) === null || _a7 === void 0 ? void 0 : _a7.dispose();
              this._state = void 0;
            }
          });
        });
      }
      if (!this._state) {
        return;
      }
      this._state = this._state.map((state) => state.mov(forward));
      const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
      this._ignoreSelection = true;
      try {
        this._editor.setSelections(newSelections);
      } finally {
        this._ignoreSelection = false;
      }
    });
  }
}, "SmartSelectController");
SmartSelectController.ID = "editor.contrib.smartSelectController";
SmartSelectController = __decorate67([
  __param67(1, ILanguageFeaturesService)
], SmartSelectController);
var AbstractSmartSelect = class extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  run(_accessor, editor2) {
    return __awaiter51(this, void 0, void 0, function* () {
      const controller = SmartSelectController.get(editor2);
      if (controller) {
        yield controller.run(this._forward);
      }
    });
  }
};
__name(AbstractSmartSelect, "AbstractSmartSelect");
var GrowSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [256 | 1024 | 17]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
};
__name(GrowSelectionAction, "GrowSelectionAction");
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [256 | 1024 | 15]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
};
__name(ShrinkSelectionAction, "ShrinkSelectionAction");
registerEditorContribution(SmartSelectController.ID, SmartSelectController, 4);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
function provideSelectionRanges(registry, model, positions, options, token) {
  return __awaiter51(this, void 0, void 0, function* () {
    const providers = registry.all(model).concat(new WordSelectionRangeProvider());
    if (providers.length === 1) {
      providers.unshift(new BracketSelectionRangeProvider());
    }
    const work = [];
    const allRawRanges = [];
    for (const provider of providers) {
      work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
        if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
          for (let i = 0; i < positions.length; i++) {
            if (!allRawRanges[i]) {
              allRawRanges[i] = [];
            }
            for (const oneProviderRanges of allProviderRanges[i]) {
              if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
                allRawRanges[i].push(Range.lift(oneProviderRanges.range));
              }
            }
          }
        }
      }, onUnexpectedExternalError));
    }
    yield Promise.all(work);
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      const oneRanges = [];
      let last;
      for (const range of oneRawRanges) {
        if (!last || Range.containsRange(range, last) && !Range.equalsRange(range, last)) {
          oneRanges.push(range);
          last = range;
        }
      }
      if (!options.selectLeadingAndTrailingWhitespace) {
        return oneRanges;
      }
      const oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
__name(provideSelectionRanges, "provideSelectionRanges");
CommandsRegistry.registerCommand("_executeSelectionRangeProvider", function(accessor, ...args) {
  return __awaiter51(this, void 0, void 0, function* () {
    const [resource, positions] = args;
    assertType(URI.isUri(resource));
    const registry = accessor.get(ILanguageFeaturesService).selectionRangeProvider;
    const reference = yield accessor.get(ITextModelService).createModelReference(resource);
    try {
      return provideSelectionRanges(registry, reference.object.textEditorModel, positions, { selectLeadingAndTrailingWhitespace: true }, CancellationToken.None);
    } finally {
      reference.dispose();
    }
  });
});

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/suggest/browser/suggestInlineCompletions.js
init_define_process();
init_cancellation();
init_iterator();
init_lifecycle();
init_editorExtensions();
init_codeEditorService();
init_range();
init_languageFeatures();
init_instantiation();
var __decorate68 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param68 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter52 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SuggestInlineCompletion = class {
  constructor(range, insertText, filterText, additionalTextEdits, command, completion) {
    this.range = range;
    this.insertText = insertText;
    this.filterText = filterText;
    this.additionalTextEdits = additionalTextEdits;
    this.command = command;
    this.completion = completion;
  }
};
__name(SuggestInlineCompletion, "SuggestInlineCompletion");
var InlineCompletionResults = /* @__PURE__ */ __name(class InlineCompletionResults2 extends RefCountedDisposable {
  constructor(model, line, word, completionModel, completions, _suggestMemoryService) {
    super(completions.disposable);
    this.model = model;
    this.line = line;
    this.word = word;
    this.completionModel = completionModel;
    this._suggestMemoryService = _suggestMemoryService;
  }
  canBeReused(model, line, word) {
    return this.model === model && this.line === line && this.word.word.length > 0 && this.word.startColumn === word.startColumn && this.word.endColumn < word.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    var _a6;
    const result = [];
    const { items } = this.completionModel;
    const selectedIndex = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, items);
    const first2 = Iterable.slice(items, selectedIndex);
    const second = Iterable.slice(items, 0, selectedIndex);
    let resolveCount = 5;
    for (const item of Iterable.concat(first2, second)) {
      if (item.score === FuzzyScore.Default) {
        continue;
      }
      const range = new Range(
        item.editStart.lineNumber,
        item.editStart.column,
        item.editInsertEnd.lineNumber,
        item.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
      );
      const insertText = item.completion.insertTextRules && item.completion.insertTextRules & CompletionItemInsertTextRule.InsertAsSnippet ? { snippet: item.completion.insertText } : item.completion.insertText;
      result.push(new SuggestInlineCompletion(range, insertText, (_a6 = item.filterTextLow) !== null && _a6 !== void 0 ? _a6 : item.labelLow, item.completion.additionalTextEdits, item.completion.command, item));
      if (resolveCount-- >= 0) {
        item.resolve(CancellationToken.None);
      }
    }
    return result;
  }
}, "InlineCompletionResults");
InlineCompletionResults = __decorate68([
  __param68(5, ISuggestMemoryService)
], InlineCompletionResults);
var SuggestInlineCompletions = /* @__PURE__ */ __name(class SuggestInlineCompletions2 {
  constructor(_getEditorOption, _languageFeatureService, _clipboardService, _suggestMemoryService) {
    this._getEditorOption = _getEditorOption;
    this._languageFeatureService = _languageFeatureService;
    this._clipboardService = _clipboardService;
    this._suggestMemoryService = _suggestMemoryService;
  }
  provideInlineCompletions(model, position, context, token) {
    var _a6;
    return __awaiter52(this, void 0, void 0, function* () {
      if (context.selectedSuggestionInfo) {
        return;
      }
      const config = this._getEditorOption(82, model);
      if (QuickSuggestionsOptions.isAllOff(config)) {
        return;
      }
      model.tokenization.tokenizeIfCheap(position.lineNumber);
      const lineTokens = model.tokenization.getLineTokens(position.lineNumber);
      const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(position.column - 1 - 1, 0)));
      if (QuickSuggestionsOptions.valueFor(config, tokenType) !== "inline") {
        return void 0;
      }
      let wordInfo = model.getWordAtPosition(position);
      let triggerCharacterInfo;
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word)) {
        triggerCharacterInfo = this._getTriggerCharacterInfo(model, position);
      }
      if (!(wordInfo === null || wordInfo === void 0 ? void 0 : wordInfo.word) && !triggerCharacterInfo) {
        return;
      }
      if (!wordInfo) {
        wordInfo = model.getWordUntilPosition(position);
      }
      if (wordInfo.endColumn !== position.column) {
        return;
      }
      let result;
      const leadingLineContents = model.getValueInRange(new Range(position.lineNumber, 1, position.lineNumber, position.column));
      if (!triggerCharacterInfo && ((_a6 = this._lastResult) === null || _a6 === void 0 ? void 0 : _a6.canBeReused(model, position.lineNumber, wordInfo))) {
        const newLineContext = new LineContext(leadingLineContents, position.column - this._lastResult.word.endColumn);
        this._lastResult.completionModel.lineContext = newLineContext;
        this._lastResult.acquire();
        result = this._lastResult;
      } else {
        const completions = yield provideSuggestionItems(this._languageFeatureService.completionProvider, model, position, new CompletionOptions(void 0, void 0, triggerCharacterInfo === null || triggerCharacterInfo === void 0 ? void 0 : triggerCharacterInfo.providers), triggerCharacterInfo && { triggerKind: 1, triggerCharacter: triggerCharacterInfo.ch }, token);
        let clipboardText;
        if (completions.needsClipboard) {
          clipboardText = yield this._clipboardService.readText();
        }
        const completionModel = new CompletionModel(completions.items, position.column, new LineContext(leadingLineContents, 0), WordDistance.None, this._getEditorOption(110, model), this._getEditorOption(104, model), { boostFullMatch: false, firstMatchCanBeWeak: false }, clipboardText);
        result = new InlineCompletionResults(model, position.lineNumber, wordInfo, completionModel, completions, this._suggestMemoryService);
      }
      this._lastResult = result;
      return result;
    });
  }
  handleItemDidShow(_completions, item) {
    item.completion.resolve(CancellationToken.None);
  }
  freeInlineCompletions(result) {
    result.release();
  }
  _getTriggerCharacterInfo(model, position) {
    var _a6;
    const ch = model.getValueInRange(Range.fromPositions({ lineNumber: position.lineNumber, column: position.column - 1 }, position));
    const providers = /* @__PURE__ */ new Set();
    for (const provider of this._languageFeatureService.completionProvider.all(model)) {
      if ((_a6 = provider.triggerCharacters) === null || _a6 === void 0 ? void 0 : _a6.includes(ch)) {
        providers.add(provider);
      }
    }
    if (providers.size === 0) {
      return void 0;
    }
    return { providers, ch };
  }
}, "SuggestInlineCompletions");
SuggestInlineCompletions = __decorate68([
  __param68(1, ILanguageFeaturesService),
  __param68(2, IClipboardService),
  __param68(3, ISuggestMemoryService)
], SuggestInlineCompletions);
var EditorContribution = /* @__PURE__ */ __name(class EditorContribution2 {
  constructor(_editor, languageFeatureService, editorService, instaService) {
    if (++EditorContribution2._counter === 1) {
      const provider = instaService.createInstance(SuggestInlineCompletions, (id, model) => {
        var _a6;
        const editor2 = (_a6 = editorService.listCodeEditors().find((editor3) => editor3.getModel() === model)) !== null && _a6 !== void 0 ? _a6 : _editor;
        return editor2.getOption(id);
      });
      EditorContribution2._disposable = languageFeatureService.inlineCompletionsProvider.register("*", provider);
    }
  }
  dispose() {
    var _a6;
    if (--EditorContribution2._counter === 0) {
      (_a6 = EditorContribution2._disposable) === null || _a6 === void 0 ? void 0 : _a6.dispose();
      EditorContribution2._disposable = void 0;
    }
  }
}, "EditorContribution");
EditorContribution._counter = 0;
EditorContribution = __decorate68([
  __param68(1, ILanguageFeaturesService),
  __param68(2, ICodeEditorService),
  __param68(3, IInstantiationService)
], EditorContribution);
registerEditorContribution("suggest.inlineCompletionsProvider", EditorContribution, 0);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/browser/tokenization.js
init_define_process();
init_stopwatch();
init_editorExtensions();
init_nls();
var ForceRetokenizeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    model.tokenization.resetTokenization();
    const sw = new StopWatch(true);
    model.tokenization.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
};
__name(ForceRetokenizeAction, "ForceRetokenizeAction");
registerEditorAction(ForceRetokenizeAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/browser/toggleTabFocusMode.js
init_define_process();
init_aria();
init_editorExtensions();
init_nls();
var ToggleTabFocusModeAction = class extends EditorAction {
  constructor() {
    super({
      id: ToggleTabFocusModeAction.ID,
      label: localize({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
      alias: "Toggle Tab Key Moves Focus",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 43,
        mac: { primary: 256 | 1024 | 43 },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const oldValue = TabFocus.getTabFocusMode();
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue);
    if (newValue) {
      alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
};
__name(ToggleTabFocusModeAction, "ToggleTabFocusModeAction");
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerEditorAction(ToggleTabFocusModeAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_define_process();
init_async();
init_codicons();
init_lifecycle();
init_platform();
init_strings();
init_editorExtensions();
init_textModel();
init_editorWorker();
init_language();

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
init_define_process();
init_dom();
init_actions();
init_lifecycle();
init_instantiation();

// ../../node_modules/monaco-editor/esm/vs/platform/opener/browser/link.js
init_define_process();
init_dom();
init_keyboardEvent();
init_event();
init_lifecycle();
init_opener();
var __decorate69 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param69 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Link2 = /* @__PURE__ */ __name(class Link3 extends Disposable {
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    if (enabled) {
      this.el.setAttribute("aria-disabled", "false");
      this.el.tabIndex = 0;
      this.el.style.pointerEvents = "auto";
      this.el.style.opacity = "1";
      this.el.style.cursor = "pointer";
      this._enabled = false;
    } else {
      this.el.setAttribute("aria-disabled", "true");
      this.el.tabIndex = -1;
      this.el.style.pointerEvents = "none";
      this.el.style.opacity = "0.4";
      this.el.style.cursor = "default";
      this._enabled = true;
    }
    this._enabled = enabled;
  }
  constructor(container, _link, options = {}, openerService) {
    var _a6;
    super();
    this._link = _link;
    this._enabled = true;
    this.el = append(container, $("a.monaco-link", {
      tabIndex: (_a6 = _link.tabIndex) !== null && _a6 !== void 0 ? _a6 : 0,
      href: _link.href,
      title: _link.title
    }, _link.label));
    this.el.setAttribute("role", "button");
    const onClickEmitter = this._register(new DomEmitter(this.el, "click"));
    const onKeyPress = this._register(new DomEmitter(this.el, "keypress"));
    const onEnterPress = Event.chain(onKeyPress.event).map((e) => new StandardKeyboardEvent(e)).filter((e) => e.keyCode === 3).event;
    const onTap = this._register(new DomEmitter(this.el, EventType2.Tap)).event;
    this._register(Gesture.addTarget(this.el));
    const onOpen = Event.any(onClickEmitter.event, onEnterPress, onTap);
    this._register(onOpen((e) => {
      if (!this.enabled) {
        return;
      }
      EventHelper.stop(e, true);
      if (options === null || options === void 0 ? void 0 : options.opener) {
        options.opener(this._link.href);
      } else {
        openerService.open(this._link.href, { allowCommands: true });
      }
    }));
    this.enabled = true;
  }
}, "Link");
Link2 = __decorate69([
  __param69(3, IOpenerService)
], Link2);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/bannerController.js
init_themeService();
var __decorate70 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param70 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BANNER_ELEMENT_HEIGHT = 26;
var BannerController = /* @__PURE__ */ __name(class BannerController2 extends Disposable {
  constructor(_editor, instantiationService) {
    super();
    this._editor = _editor;
    this.instantiationService = instantiationService;
    this.banner = this._register(this.instantiationService.createInstance(Banner));
  }
  hide() {
    this._editor.setBanner(null, 0);
    this.banner.clear();
  }
  show(item) {
    this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
      var _a6;
      this.hide();
      (_a6 = item.onClose) === null || _a6 === void 0 ? void 0 : _a6.call(item);
    } }));
    this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
  }
}, "BannerController");
BannerController = __decorate70([
  __param70(1, IInstantiationService)
], BannerController);
var Banner = /* @__PURE__ */ __name(class Banner2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.instantiationService = instantiationService;
    this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    this.element = $("div.editor-banner");
    this.element.tabIndex = 0;
  }
  getAriaLabel(item) {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.message === "string") {
      return item.message;
    }
    return void 0;
  }
  getBannerMessage(message) {
    if (typeof message === "string") {
      const element = $("span");
      element.innerText = message;
      return element;
    }
    return this.markdownRenderer.render(message).element;
  }
  clear() {
    clearNode(this.element);
  }
  show(item) {
    clearNode(this.element);
    const ariaLabel = this.getAriaLabel(item);
    if (ariaLabel) {
      this.element.setAttribute("aria-label", ariaLabel);
    }
    const iconContainer = append(this.element, $("div.icon-container"));
    iconContainer.setAttribute("aria-hidden", "true");
    if (item.icon) {
      iconContainer.appendChild($(`div${ThemeIcon.asCSSSelector(item.icon)}`));
    }
    const messageContainer = append(this.element, $("div.message-container"));
    messageContainer.setAttribute("aria-hidden", "true");
    messageContainer.appendChild(this.getBannerMessage(item.message));
    this.messageActionsContainer = append(this.element, $("div.message-actions-container"));
    if (item.actions) {
      for (const action of item.actions) {
        this._register(this.instantiationService.createInstance(Link2, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
      }
    }
    const actionBarContainer = append(this.element, $("div.action-container"));
    this.actionBar = this._register(new ActionBar(actionBarContainer));
    this.actionBar.push(this._register(new Action("banner.close", "Close Banner", ThemeIcon.asClassName(widgetClose), true, () => {
      if (typeof item.onClose === "function") {
        item.onClose();
      }
    })), { icon: true, label: false });
    this.actionBar.setFocusable(false);
  }
}, "Banner");
Banner = __decorate70([
  __param70(0, IInstantiationService)
], Banner);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/browser/unicodeHighlighter.js
init_nls();
init_configuration();
init_instantiation();
init_opener();
var __decorate71 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param71 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter53 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize("warningIcon", "Icon shown with a warning message in the extensions editor."));
var UnicodeHighlighter = /* @__PURE__ */ __name(class UnicodeHighlighter2 extends Disposable {
  constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
    super();
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._workspaceTrustService = _workspaceTrustService;
    this._highlighter = null;
    this._bannerClosed = false;
    this._updateState = (state) => {
      if (state && state.hasMore) {
        if (this._bannerClosed) {
          return;
        }
        const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
        let data;
        if (state.nonBasicAsciiCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
          };
        } else if (state.ambiguousCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new DisableHighlightingOfAmbiguousCharactersAction()
          };
        } else if (state.invisibleCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new DisableHighlightingOfInvisibleCharactersAction()
          };
        } else {
          throw new Error("Unreachable");
        }
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: data.message,
          icon: warningIcon,
          actions: [
            {
              label: data.command.shortLabel,
              href: `command:${data.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = true;
          }
        });
      } else {
        this._bannerController.hide();
      }
    };
    this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
    this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = false;
      this._updateHighlighter();
    }));
    this._options = _editor.getOption(117);
    this._register(_workspaceTrustService.onDidChangeTrust((e) => {
      this._updateHighlighter();
    }));
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(117)) {
        this._options = _editor.getOption(117);
        this._updateHighlighter();
      }
    }));
    this._updateHighlighter();
  }
  dispose() {
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    super.dispose();
  }
  _updateHighlighter() {
    this._updateState(null);
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      options.nonBasicASCII,
      options.ambiguousCharacters,
      options.invisibleCharacters
    ].every((option) => option === false)) {
      return;
    }
    const highlightOptions = {
      nonBasicASCII: options.nonBasicASCII,
      ambiguousCharacters: options.ambiguousCharacters,
      invisibleCharacters: options.invisibleCharacters,
      includeComments: options.includeComments,
      includeStrings: options.includeStrings,
      allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0)),
      allowedLocales: Object.keys(options.allowedLocales).map((locale) => {
        if (locale === "_os") {
          const osLocale = new Intl.NumberFormat().resolvedOptions().locale;
          return osLocale;
        } else if (locale === "_vscode") {
          return language;
        }
        return locale;
      })
    };
    if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) {
      this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
    } else {
      this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
    }
  }
  getDecorationInfo(decoration2) {
    if (this._highlighter) {
      return this._highlighter.getDecorationInfo(decoration2);
    }
    return null;
  }
}, "UnicodeHighlighter");
UnicodeHighlighter.ID = "editor.contrib.unicodeHighlighter";
UnicodeHighlighter = __decorate71([
  __param71(1, IEditorWorkerService),
  __param71(2, IWorkspaceTrustManagementService),
  __param71(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
  return {
    nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
    ambiguousCharacters: options.ambiguousCharacters,
    invisibleCharacters: options.invisibleCharacters,
    includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
    includeStrings: options.includeStrings === inUntrustedWorkspace ? !trusted : options.includeStrings,
    allowedCharacters: options.allowedCharacters,
    allowedLocales: options.allowedLocales
  };
}
__name(resolveOptions, "resolveOptions");
var DocumentUnicodeHighlighter = /* @__PURE__ */ __name(class DocumentUnicodeHighlighter2 extends Disposable {
  constructor(_editor, _options, _updateState, _editorWorkerService) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._editorWorkerService = _editorWorkerService;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const modelVersionId = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
      if (this._model.isDisposed()) {
        return;
      }
      if (this._model.getVersionId() !== modelVersionId) {
        return;
      }
      this._updateState(info);
      const decorations = [];
      if (!info.hasMore) {
        for (const range of info.ranges) {
          decorations.push({
            range,
            options: Decorations.instance.getDecorationFromOptions(this._options)
          });
        }
      }
      this._decorations.set(decorations);
    });
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    const text = model.getValueInRange(decoration2.range);
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
}, "DocumentUnicodeHighlighter");
DocumentUnicodeHighlighter = __decorate71([
  __param71(3, IEditorWorkerService)
], DocumentUnicodeHighlighter);
var ViewportUnicodeHighlighter = class extends Disposable {
  constructor(_editor, _options, _updateState) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._model = this._editor.getModel();
    this._decorations = this._editor.createDecorationsCollection();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorations.clear();
    super.dispose();
  }
  _update() {
    if (this._model.isDisposed()) {
      return;
    }
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorations.clear();
      return;
    }
    const ranges = this._editor.getVisibleRanges();
    const decorations = [];
    const totalResult = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: false
    };
    for (const range of ranges) {
      const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
      for (const r of result.ranges) {
        totalResult.ranges.push(r);
      }
      totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
      totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
      totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
      totalResult.hasMore = totalResult.hasMore || result.hasMore;
    }
    if (!totalResult.hasMore) {
      for (const range of totalResult.ranges) {
        decorations.push({ range, options: Decorations.instance.getDecorationFromOptions(this._options) });
      }
    }
    this._updateState(totalResult);
    this._decorations.set(decorations);
  }
  getDecorationInfo(decoration2) {
    if (!this._decorations.has(decoration2)) {
      return null;
    }
    const model = this._editor.getModel();
    const text = model.getValueInRange(decoration2.range);
    if (!isModelDecorationVisible(model, decoration2)) {
      return null;
    }
    return {
      reason: computeReason(text, this._options),
      inComment: isModelDecorationInComment(model, decoration2),
      inString: isModelDecorationInString(model, decoration2)
    };
  }
};
__name(ViewportUnicodeHighlighter, "ViewportUnicodeHighlighter");
var UnicodeHighlighterHoverParticipant = /* @__PURE__ */ __name(class UnicodeHighlighterHoverParticipant2 {
  constructor(_editor, _languageService, _openerService) {
    this._editor = _editor;
    this._languageService = _languageService;
    this._openerService = _openerService;
    this.hoverOrdinal = 4;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const unicodeHighlighter = this._editor.getContribution(UnicodeHighlighter.ID);
    if (!unicodeHighlighter) {
      return [];
    }
    const result = [];
    let index = 300;
    for (const d of lineDecorations) {
      const highlightInfo = unicodeHighlighter.getDecorationInfo(d);
      if (!highlightInfo) {
        continue;
      }
      const char = model.getValueInRange(d.range);
      const codePoint = char.codePointAt(0);
      const codePointStr = formatCodePointMarkdown(codePoint);
      let reason;
      switch (highlightInfo.reason.kind) {
        case 0:
          reason = localize("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePointMarkdown(highlightInfo.reason.confusableWith.codePointAt(0)));
          break;
        case 1:
          reason = localize("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", codePointStr);
          break;
        case 2:
          reason = localize("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", codePointStr);
          break;
      }
      const adjustSettingsArgs = {
        codePoint,
        reason: highlightInfo.reason,
        inComment: highlightInfo.inComment,
        inString: highlightInfo.inString
      };
      const adjustSettings = localize("unicodeHighlight.adjustSettings", "Adjust settings");
      const uri = `command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))}`;
      const markdown = new MarkdownString("", true).appendMarkdown(reason).appendText(" ").appendLink(uri, adjustSettings);
      result.push(new MarkdownHover(this, d.range, [markdown], false, index++));
    }
    return result;
  }
  renderHoverParts(context, hoverParts) {
    return renderMarkdownHovers(context, hoverParts, this._editor, this._languageService, this._openerService);
  }
}, "UnicodeHighlighterHoverParticipant");
UnicodeHighlighterHoverParticipant = __decorate71([
  __param71(1, ILanguageService),
  __param71(2, IOpenerService)
], UnicodeHighlighterHoverParticipant);
function codePointToHex(codePoint) {
  return `U+${codePoint.toString(16).padStart(4, "0")}`;
}
__name(codePointToHex, "codePointToHex");
function formatCodePointMarkdown(codePoint) {
  let value = `\`${codePointToHex(codePoint)}\``;
  if (!InvisibleCharacters.isInvisibleCharacter(codePoint)) {
    value += ` "${`${renderCodePointAsInlineCode(codePoint)}`}"`;
  }
  return value;
}
__name(formatCodePointMarkdown, "formatCodePointMarkdown");
function renderCodePointAsInlineCode(codePoint) {
  if (codePoint === 96) {
    return "`` ` ``";
  }
  return "`" + String.fromCodePoint(codePoint) + "`";
}
__name(renderCodePointAsInlineCode, "renderCodePointAsInlineCode");
function computeReason(char, options) {
  return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
__name(computeReason, "computeReason");
var Decorations = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  getDecorationFromOptions(options) {
    return this.getDecoration(!options.includeComments, !options.includeStrings);
  }
  getDecoration(hideInComments, hideInStrings) {
    const key = `${hideInComments}${hideInStrings}`;
    let options = this.map.get(key);
    if (!options) {
      options = ModelDecorationOptions.createDynamic({
        description: "unicode-highlight",
        stickiness: 1,
        className: "unicode-highlight",
        showIfCollapsed: true,
        overviewRuler: null,
        minimap: null,
        hideInCommentTokens: hideInComments,
        hideInStringTokens: hideInStrings
      });
      this.map.set(key, options);
    }
    return options;
  }
};
__name(Decorations, "Decorations");
Decorations.instance = new Decorations();
var DisableHighlightingInCommentsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInComments", "Disable highlighting of characters in comments"),
      alias: "Disable highlighting of characters in comments",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInComments.shortLabel", "Disable Highlight In Comments");
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter53(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.includeComments, false, 2);
    });
  }
};
__name(DisableHighlightingInCommentsAction, "DisableHighlightingInCommentsAction");
var DisableHighlightingInStringsAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingInStrings", "Disable highlighting of characters in strings"),
      alias: "Disable highlighting of characters in strings",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingInStrings.shortLabel", "Disable Highlight In Strings");
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter53(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.includeStrings, false, 2);
    });
  }
};
__name(DisableHighlightingInStringsAction, "DisableHighlightingInStringsAction");
var DisableHighlightingOfAmbiguousCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter53(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.ambiguousCharacters, false, 2);
    });
  }
};
__name(DisableHighlightingOfAmbiguousCharactersAction, "DisableHighlightingOfAmbiguousCharactersAction");
DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
var DisableHighlightingOfInvisibleCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfInvisibleCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter53(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.invisibleCharacters, false, 2);
    });
  }
};
__name(DisableHighlightingOfInvisibleCharactersAction, "DisableHighlightingOfInvisibleCharactersAction");
DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
var DisableHighlightingOfNonBasicAsciiCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter53(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.nonBasicASCII, false, 2);
    });
  }
};
__name(DisableHighlightingOfNonBasicAsciiCharactersAction, "DisableHighlightingOfNonBasicAsciiCharactersAction");
DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
var ShowExcludeOptions = class extends EditorAction {
  constructor() {
    super({
      id: ShowExcludeOptions.ID,
      label: localize("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    return __awaiter53(this, void 0, void 0, function* () {
      const { codePoint, reason, inString, inComment } = args;
      const char = String.fromCodePoint(codePoint);
      const quickPickService = accessor.get(IQuickInputService);
      const configurationService = accessor.get(IConfigurationService);
      function getExcludeCharFromBeingHighlightedLabel(codePoint2) {
        if (InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          return localize("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", codePointToHex(codePoint2));
        }
        return localize("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `${codePointToHex(codePoint2)} "${char}"`);
      }
      __name(getExcludeCharFromBeingHighlightedLabel, "getExcludeCharFromBeingHighlightedLabel");
      const options = [];
      if (reason.kind === 0) {
        for (const locale of reason.notAmbiguousInLocales) {
          options.push({
            label: localize("unicodeHighlight.allowCommonCharactersInLanguage", 'Allow unicode characters that are more common in the language "{0}".', locale),
            run: () => __awaiter53(this, void 0, void 0, function* () {
              excludeLocaleFromBeingHighlighted(configurationService, [locale]);
            })
          });
        }
      }
      options.push({
        label: getExcludeCharFromBeingHighlightedLabel(codePoint),
        run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
      });
      if (inComment) {
        const action = new DisableHighlightingInCommentsAction();
        options.push({ label: action.label, run: () => __awaiter53(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (inString) {
        const action = new DisableHighlightingInStringsAction();
        options.push({ label: action.label, run: () => __awaiter53(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      }
      if (reason.kind === 0) {
        const action = new DisableHighlightingOfAmbiguousCharactersAction();
        options.push({ label: action.label, run: () => __awaiter53(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 1) {
        const action = new DisableHighlightingOfInvisibleCharactersAction();
        options.push({ label: action.label, run: () => __awaiter53(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason.kind === 2) {
        const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
        options.push({ label: action.label, run: () => __awaiter53(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else {
        expectNever(reason);
      }
      const result = yield quickPickService.pick(options, { title: localize("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
      if (result) {
        yield result.run();
      }
    });
  }
};
__name(ShowExcludeOptions, "ShowExcludeOptions");
ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
function excludeCharFromBeingHighlighted(configurationService, charCodes) {
  return __awaiter53(this, void 0, void 0, function* () {
    const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = existingValue;
    } else {
      value = {};
    }
    for (const charCode of charCodes) {
      value[String.fromCodePoint(charCode)] = true;
    }
    yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedCharacters, value, 2);
  });
}
__name(excludeCharFromBeingHighlighted, "excludeCharFromBeingHighlighted");
function excludeLocaleFromBeingHighlighted(configurationService, locales) {
  var _a6;
  return __awaiter53(this, void 0, void 0, function* () {
    const existingValue = (_a6 = configurationService.inspect(unicodeHighlightConfigKeys.allowedLocales).user) === null || _a6 === void 0 ? void 0 : _a6.value;
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = Object.assign({}, existingValue);
    } else {
      value = {};
    }
    for (const locale of locales) {
      value[locale] = true;
    }
    yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedLocales, value, 2);
  });
}
__name(excludeLocaleFromBeingHighlighted, "excludeLocaleFromBeingHighlighted");
function expectNever(value) {
  throw new Error(`Unexpected value: ${value}`);
}
__name(expectNever, "expectNever");
registerEditorAction(DisableHighlightingOfAmbiguousCharactersAction);
registerEditorAction(DisableHighlightingOfInvisibleCharactersAction);
registerEditorAction(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerEditorAction(ShowExcludeOptions);
registerEditorContribution(UnicodeHighlighter.ID, UnicodeHighlighter, 1);
HoverParticipantRegistry.register(UnicodeHighlighterHoverParticipant);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/browser/unusualLineTerminators.js
init_define_process();
init_lifecycle();
init_resources();
init_editorExtensions();
init_codeEditorService();
init_nls();
var __decorate72 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param72 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter54 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
__name(writeIgnoreState, "writeIgnoreState");
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
__name(readIgnoreState, "readIgnoreState");
var UnusualLineTerminatorsDetector = /* @__PURE__ */ __name(class UnusualLineTerminatorsDetector2 extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._isPresentingDialog = false;
    this._config = this._editor.getOption(118);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(118)) {
        this._config = this._editor.getOption(118);
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
    this._checkForUnusualLineTerminators();
  }
  _checkForUnusualLineTerminators() {
    return __awaiter54(this, void 0, void 0, function* () {
      if (this._config === "off") {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!model.mightContainUnusualLineTerminators()) {
        return;
      }
      const ignoreState = readIgnoreState(this._codeEditorService, model);
      if (ignoreState === true) {
        return;
      }
      if (this._editor.getOption(84)) {
        return;
      }
      if (this._config === "auto") {
        model.removeUnusualLineTerminators(this._editor.getSelections());
        return;
      }
      if (this._isPresentingDialog) {
        return;
      }
      let result;
      try {
        this._isPresentingDialog = true;
        result = yield this._dialogService.confirm({
          title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
          message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
          detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename2(model.uri)),
          primaryButton: localize("unusualLineTerminators.fix", "Remove Unusual Line Terminators"),
          secondaryButton: localize("unusualLineTerminators.ignore", "Ignore")
        });
      } finally {
        this._isPresentingDialog = false;
      }
      if (!result.confirmed) {
        writeIgnoreState(this._codeEditorService, model, true);
        return;
      }
      model.removeUnusualLineTerminators(this._editor.getSelections());
    });
  }
}, "UnusualLineTerminatorsDetector");
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate72([
  __param72(1, IDialogService),
  __param72(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(UnusualLineTerminatorsDetector.ID, UnusualLineTerminatorsDetector, 1);

// ../../node_modules/monaco-editor/esm/vs/editor/editor.all.js
var import_viewportSemanticTokens = __toESM(require_viewportSemanticTokens());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/browser/wordHighlighter.js
init_define_process();
init_aria();
init_arrays();
init_async();
init_cancellation();
init_errors();
init_lifecycle();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_languages();
init_nls();
init_contextkey();
init_languageFeatures();
var __decorate73 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param73 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(registry, model, position, token) {
  const orderedByScore = registry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
__name(getOccurrencesAtPosition, "getOccurrencesAtPosition");
var OccurenceAtPositionRequest = class {
  constructor(_model, _selection, _wordSeparators) {
    this._model = _model;
    this._selection = _selection;
    this._wordSeparators = _wordSeparators;
    this._wordRange = this._getCurrentWordRange(_model, _selection);
    this._result = null;
  }
  get result() {
    if (!this._result) {
      this._result = createCancelablePromise((token) => this._compute(this._model, this._selection, this._wordSeparators, token));
    }
    return this._result;
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  isValid(model, selection, decorations) {
    const lineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endColumn = selection.endColumn;
    const currentWordRange = this._getCurrentWordRange(model, selection);
    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
    for (let i = 0, len = decorations.length; !requestIsValid && i < len; i++) {
      const range = decorations.getRange(i);
      if (range && range.startLineNumber === lineNumber) {
        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
          requestIsValid = true;
        }
      }
    }
    return requestIsValid;
  }
  cancel() {
    this.result.cancel();
  }
};
__name(OccurenceAtPositionRequest, "OccurenceAtPositionRequest");
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators, providers) {
    super(model, selection, wordSeparators);
    this._providers = providers;
  }
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAtPosition(this._providers, model, selection.getPosition(), token).then((value) => value || []);
  }
};
__name(SemanticOccurenceAtPositionRequest, "SemanticOccurenceAtPositionRequest");
var TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators) {
    super(model, selection, wordSeparators);
    this._selectionIsEmpty = selection.isEmpty();
  }
  _compute(model, selection, wordSeparators, token) {
    return timeout(250, token).then(() => {
      if (!selection.isEmpty()) {
        return [];
      }
      const word = model.getWordAtPosition(selection.getPosition());
      if (!word || word.word.length > 1e3) {
        return [];
      }
      const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);
      return matches.map((m) => {
        return {
          range: m.range,
          kind: DocumentHighlightKind.Text
        };
      });
    });
  }
  isValid(model, selection, decorations) {
    const currentSelectionIsEmpty = selection.isEmpty();
    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
      return false;
    }
    return super.isValid(model, selection, decorations);
  }
};
__name(TextualOccurenceAtPositionRequest, "TextualOccurenceAtPositionRequest");
function computeOccurencesAtPosition(registry, model, selection, wordSeparators) {
  if (registry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators, registry);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
__name(computeOccurencesAtPosition, "computeOccurencesAtPosition");
registerModelAndPositionCommand("_executeDocumentHighlights", (accessor, model, position) => {
  const languageFeaturesService = accessor.get(ILanguageFeaturesService);
  return getOccurrencesAtPosition(languageFeaturesService.documentHighlightProvider, model, position, CancellationToken.None);
});
var WordHighlighter = class {
  constructor(editor2, providers, contextKeyService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = [];
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
    this.editor = editor2;
    this.providers = providers;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlight = this.editor.getOption(75);
    this.model = this.editor.getModel();
    this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (!this.occurrencesHighlight) {
        return;
      }
      this._onPositionChanged(e);
    }));
    this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
      this._stopAll();
    }));
    this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
      const newValue = this.editor.getOption(75);
      if (this.occurrencesHighlight !== newValue) {
        this.occurrencesHighlight = newValue;
        this._stopAll();
      }
    }));
    this.decorations = this.editor.createDecorationsCollection();
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
  }
  hasDecorations() {
    return this.decorations.length > 0;
  }
  restore() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._run();
  }
  _getSortedHighlights() {
    return this.decorations.getRanges().sort(Range.compareRangesUsingStarts);
  }
  moveNext() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index + 1) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    const highlights = this._getSortedHighlights();
    const index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    const newIndex = (index - 1 + highlights.length) % highlights.length;
    const dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeDecorations() {
    if (this.decorations.length > 0) {
      this.decorations.clear();
      this._hasWordHighlights.set(false);
    }
  }
  _stopAll() {
    this._removeDecorations();
    if (this.renderDecorationsTimer !== -1) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = -1;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (!this.occurrencesHighlight) {
      this._stopAll();
      return;
    }
    if (e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    const editorSelection = this.editor.getSelection();
    const lineNumber = editorSelection.startLineNumber;
    const startColumn = editorSelection.startColumn;
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  _run() {
    const editorSelection = this.editor.getSelection();
    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
      this._stopAll();
      return;
    }
    const startColumn = editorSelection.startColumn;
    const endColumn = editorSelection.endColumn;
    const word = this._getWord();
    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
      this._stopAll();
      return;
    }
    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this.decorations);
    this.lastCursorPositionChangeTime = new Date().getTime();
    if (workerRequestIsValid) {
      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
        clearTimeout(this.renderDecorationsTimer);
        this.renderDecorationsTimer = -1;
        this._beginRenderDecorations();
      }
    } else {
      this._stopAll();
      const myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      this.workerRequest = computeOccurencesAtPosition(this.providers, this.model, this.editor.getSelection(), this.editor.getOption(122));
      this.workerRequest.result.then((data) => {
        if (myRequestId === this.workerRequestTokenId) {
          this.workerRequestCompleted = true;
          this.workerRequestValue = data || [];
          this._beginRenderDecorations();
        }
      }, onUnexpectedError);
    }
  }
  _beginRenderDecorations() {
    const currentTime = new Date().getTime();
    const minimumRenderTime = this.lastCursorPositionChangeTime + 250;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = -1;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = -1;
    const decorations = [];
    for (const info of this.workerRequestValue) {
      if (info.range) {
        decorations.push({
          range: info.range,
          options: getHighlightDecorationOptions(info.kind)
        });
      }
    }
    this.decorations.set(decorations);
    this._hasWordHighlights.set(this.hasDecorations());
  }
  dispose() {
    this._stopAll();
    this.toUnhook.dispose();
  }
};
__name(WordHighlighter, "WordHighlighter");
var WordHighlighterContribution = /* @__PURE__ */ __name(class WordHighlighterContribution2 extends Disposable {
  static get(editor2) {
    return editor2.getContribution(WordHighlighterContribution2.ID);
  }
  constructor(editor2, contextKeyService, languageFeaturesService) {
    super();
    this.wordHighlighter = null;
    const createWordHighlighterIfPossible = /* @__PURE__ */ __name(() => {
      if (editor2.hasModel()) {
        this.wordHighlighter = new WordHighlighter(editor2, languageFeaturesService.documentHighlightProvider, contextKeyService);
      }
    }, "createWordHighlighterIfPossible");
    this._register(editor2.onDidChangeModel((e) => {
      if (this.wordHighlighter) {
        this.wordHighlighter.dispose();
        this.wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  saveViewState() {
    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    var _a6;
    (_a6 = this.wordHighlighter) === null || _a6 === void 0 ? void 0 : _a6.moveNext();
  }
  moveBack() {
    var _a6;
    (_a6 = this.wordHighlighter) === null || _a6 === void 0 ? void 0 : _a6.moveBack();
  }
  restoreViewState(state) {
    if (this.wordHighlighter && state) {
      this.wordHighlighter.restore();
    }
  }
  dispose() {
    if (this.wordHighlighter) {
      this.wordHighlighter.dispose();
      this.wordHighlighter = null;
    }
    super.dispose();
  }
}, "WordHighlighterContribution");
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = __decorate73([
  __param73(1, IContextKeyService),
  __param73(2, ILanguageFeaturesService)
], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor2) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
};
__name(WordHighlightNavigationAction, "WordHighlightNavigationAction");
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
      }
    });
  }
};
__name(NextWordHighlightAction, "NextWordHighlightAction");
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
      }
    });
  }
};
__name(PrevWordHighlightAction, "PrevWordHighlightAction");
var TriggerWordHighlightAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: ctxHasWordHighlights.toNegated(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
};
__name(TriggerWordHighlightAction, "TriggerWordHighlightAction");
registerEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution, 0);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/browser/wordOperations.js
init_define_process();
init_editorExtensions();
init_wordCharacterClassifier();
init_position();
init_range();
init_selection();
init_editorContextKeys();
init_languageConfigurationRegistry();
init_nls();
init_contextkey();
var MoveWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(122));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const result = selections.map((sel) => {
      const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
      editor2.revealPosition(pos, 0);
    }
  }
  _moveTo(from, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
};
__name(MoveWordCommand, "MoveWordCommand");
var WordLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
  }
};
__name(WordLeftCommand, "WordLeftCommand");
var WordRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
  }
};
__name(WordRightCommand, "WordRightCommand");
var CursorWordStartLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
};
__name(CursorWordStartLeft, "CursorWordStartLeft");
var CursorWordEndLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
};
__name(CursorWordEndLeft, "CursorWordEndLeft");
var CursorWordLeft = class extends WordLeftCommand {
  constructor() {
    var _a6;
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a6 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a6 === void 0 ? void 0 : _a6.negate()),
        primary: 2048 | 15,
        mac: { primary: 512 | 15 },
        weight: 100
      }
    });
  }
};
__name(CursorWordLeft, "CursorWordLeft");
var CursorWordStartLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
};
__name(CursorWordStartLeftSelect, "CursorWordStartLeftSelect");
var CursorWordEndLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
};
__name(CursorWordEndLeftSelect, "CursorWordEndLeftSelect");
var CursorWordLeftSelect = class extends WordLeftCommand {
  constructor() {
    var _a6;
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a6 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a6 === void 0 ? void 0 : _a6.negate()),
        primary: 2048 | 1024 | 15,
        mac: { primary: 512 | 1024 | 15 },
        weight: 100
      }
    });
  }
};
__name(CursorWordLeftSelect, "CursorWordLeftSelect");
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
__name(CursorWordAccessibilityLeft, "CursorWordAccessibilityLeft");
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
__name(CursorWordAccessibilityLeftSelect, "CursorWordAccessibilityLeftSelect");
var CursorWordStartRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
};
__name(CursorWordStartRight, "CursorWordStartRight");
var CursorWordEndRight = class extends WordRightCommand {
  constructor() {
    var _a6;
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a6 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a6 === void 0 ? void 0 : _a6.negate()),
        primary: 2048 | 17,
        mac: { primary: 512 | 17 },
        weight: 100
      }
    });
  }
};
__name(CursorWordEndRight, "CursorWordEndRight");
var CursorWordRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
};
__name(CursorWordRight, "CursorWordRight");
var CursorWordStartRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
};
__name(CursorWordStartRightSelect, "CursorWordStartRightSelect");
var CursorWordEndRightSelect = class extends WordRightCommand {
  constructor() {
    var _a6;
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a6 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a6 === void 0 ? void 0 : _a6.negate()),
        primary: 2048 | 1024 | 17,
        mac: { primary: 512 | 1024 | 17 },
        weight: 100
      }
    });
  }
};
__name(CursorWordEndRightSelect, "CursorWordEndRightSelect");
var CursorWordRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
};
__name(CursorWordRightSelect, "CursorWordRightSelect");
var CursorWordAccessibilityRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
__name(CursorWordAccessibilityRight, "CursorWordAccessibilityRight");
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
__name(CursorWordAccessibilityRightSelect, "CursorWordAccessibilityRightSelect");
var DeleteWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    const languageConfigurationService = accessor.get(ILanguageConfigurationService);
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(122));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const autoClosingBrackets = editor2.getOption(5);
    const autoClosingQuotes = editor2.getOption(8);
    const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
    const viewModel = editor2._getViewModel();
    const commands = selections.map((sel) => {
      const deleteRange = this._delete({
        wordSeparators,
        model,
        selection: sel,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: editor2.getOption(6),
        autoClosingBrackets,
        autoClosingQuotes,
        autoClosingPairs,
        autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(DeleteWordCommand, "DeleteWordCommand");
var DeleteWordLeftCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
__name(DeleteWordLeftCommand, "DeleteWordLeftCommand");
var DeleteWordRightCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
__name(DeleteWordRightCommand, "DeleteWordRightCommand");
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(DeleteWordStartLeft, "DeleteWordStartLeft");
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(DeleteWordEndLeft, "DeleteWordEndLeft");
var DeleteWordLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: { primary: 512 | 1 },
        weight: 100
      }
    });
  }
};
__name(DeleteWordLeft, "DeleteWordLeft");
var DeleteWordStartRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(DeleteWordStartRight, "DeleteWordStartRight");
var DeleteWordEndRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
};
__name(DeleteWordEndRight, "DeleteWordEndRight");
var DeleteWordRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: { primary: 512 | 20 },
        weight: 100
      }
    });
  }
};
__name(DeleteWordRight, "DeleteWordRight");
var DeleteInsideWord = class extends EditorAction {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: EditorContextKeys.writable,
      label: localize("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(122));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const commands = selections.map((sel) => {
      const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
__name(DeleteInsideWord, "DeleteInsideWord");
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/browser/wordPartOperations.js
init_define_process();
init_editorExtensions();
init_range();
init_editorContextKeys();
init_commands();
var DeleteWordPartLeft = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1 },
        weight: 100
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartLeft(ctx);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
__name(DeleteWordPartLeft, "DeleteWordPartLeft");
var DeleteWordPartRight = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 20 },
        weight: 100
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    const r = WordPartOperations.deleteWordPartRight(ctx);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
__name(DeleteWordPartRight, "DeleteWordPartRight");
var WordPartLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
  }
};
__name(WordPartLeftCommand, "WordPartLeftCommand");
var CursorWordPartLeft = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 15 },
        weight: 100
      }
    });
  }
};
__name(CursorWordPartLeft, "CursorWordPartLeft");
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1024 | 15 },
        weight: 100
      }
    });
  }
};
__name(CursorWordPartLeftSelect, "CursorWordPartLeftSelect");
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
  }
};
__name(WordPartRightCommand, "WordPartRightCommand");
var CursorWordPartRight = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 17 },
        weight: 100
      }
    });
  }
};
__name(CursorWordPartRight, "CursorWordPartRight");
var CursorWordPartRightSelect = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1024 | 17 },
        weight: 100
      }
    });
  }
};
__name(CursorWordPartRightSelect, "CursorWordPartRightSelect");
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

// ../../node_modules/monaco-editor/esm/vs/editor/contrib/readOnlyMessage/browser/contribution.js
init_define_process();
init_lifecycle();
init_editorExtensions();
init_nls();
var ReadOnlyMessageController = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._register(this.editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit()));
  }
  _onDidAttemptReadOnlyEdit() {
    const messageController = MessageController.get(this.editor);
    if (messageController && this.editor.hasModel()) {
      if (this.editor.isSimpleWidget) {
        messageController.showMessage(localize("editor.simple.readonly", "Cannot edit in read-only input"), this.editor.getPosition());
      } else {
        messageController.showMessage(localize("editor.readonly", "Cannot edit in read-only editor"), this.editor.getPosition());
      }
    }
  }
};
__name(ReadOnlyMessageController, "ReadOnlyMessageController");
ReadOnlyMessageController.ID = "editor.contrib.readOnlyMessageController";
registerEditorContribution(ReadOnlyMessageController.ID, ReadOnlyMessageController, 2);

// ../../node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
init_define_process();

// ../../node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js
init_define_process();
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = /* @__PURE__ */ __name((to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
}, "__copyProps");
var __reExport = /* @__PURE__ */ __name((target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default")), "__reExport");
var monaco_editor_core_exports = {};
__reExport(monaco_editor_core_exports, editor_api_exports);
var languageDefinitions = {};
var lazyLanguageLoaders = {};
var LazyLanguageLoader = /* @__PURE__ */ __name(class {
  static getOrCreate(languageId) {
    if (!lazyLanguageLoaders[languageId]) {
      lazyLanguageLoaders[languageId] = new LazyLanguageLoader(languageId);
    }
    return lazyLanguageLoaders[languageId];
  }
  _languageId;
  _loadingTriggered;
  _lazyLoadPromise;
  _lazyLoadPromiseResolve;
  _lazyLoadPromiseReject;
  constructor(languageId) {
    this._languageId = languageId;
    this._loadingTriggered = false;
    this._lazyLoadPromise = new Promise((resolve, reject) => {
      this._lazyLoadPromiseResolve = resolve;
      this._lazyLoadPromiseReject = reject;
    });
  }
  load() {
    if (!this._loadingTriggered) {
      this._loadingTriggered = true;
      languageDefinitions[this._languageId].loader().then((mod2) => this._lazyLoadPromiseResolve(mod2), (err) => this._lazyLoadPromiseReject(err));
    }
    return this._lazyLoadPromise;
  }
}, "LazyLanguageLoader");
function registerLanguage(def) {
  const languageId = def.id;
  languageDefinitions[languageId] = def;
  monaco_editor_core_exports.languages.register(def);
  const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);
  monaco_editor_core_exports.languages.registerTokensProviderFactory(languageId, {
    create: async () => {
      const mod2 = await lazyLanguageLoader.load();
      return mod2.language;
    }
  });
  monaco_editor_core_exports.languages.onLanguage(languageId, async () => {
    const mod2 = await lazyLanguageLoader.load();
    monaco_editor_core_exports.languages.setLanguageConfiguration(languageId, mod2.conf);
  });
}
__name(registerLanguage, "registerLanguage");

// ../../node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
registerLanguage({
  id: "typescript",
  extensions: [".ts", ".tsx"],
  aliases: ["TypeScript", "ts", "typescript"],
  mimetypes: ["text/typescript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/typescript/typescript"], resolve, reject);
      });
    } else {
      return import("./chunk-typescript-SVSEZPYK.mjs");
    }
  }
});

// js/monacoExtra.ts
init_define_process();
var import_replace_all = __toESM(require_replace_all2(), 1);
function extraStuff(code, uri, typescript) {
  const getTsWorker = /* @__PURE__ */ __name(() => typescript.getTypeScriptWorker(), "getTsWorker");
  const addExtraLib = /* @__PURE__ */ __name((content, filePath) => typescript.typescriptDefaults.addExtraLib(content, filePath), "addExtraLib");
  const setExtraLibs = /* @__PURE__ */ __name((libs) => typescript.typescriptDefaults.setExtraLibs(libs), "setExtraLibs");
  const extraModelCache = {};
  const extraModels = {};
  Object.assign(globalThis, { extraModels, extraModelCache });
  const addExtraModels = /* @__PURE__ */ __name(async (code2, url) => {
    try {
      if (extraModels[url])
        return;
      extraModels[url] = [];
      const baSe = new URL(".", url).toString();
      const parent = new URL("..", url).toString();
      const gParent = new URL("../..", url).toString();
      const ggParent = new URL("../../..", url).toString();
      let replaced = removeComments(code2);
      replaced = replaceAll(replaced, ` from '../../`, ` from '${ggParent}`);
      replaced = replaceAll(replaced, ` from "../../`, ` from "${ggParent}`);
      replaced = replaceAll(replaced, ` from '../../`, ` from '${gParent}`);
      replaced = replaceAll(replaced, ` from "../../`, ` from "${gParent}`);
      replaced = replaceAll(replaced, ` from '../`, ` from '${parent}`);
      replaced = replaceAll(replaced, ` from './`, ` from '${baSe}`);
      replaced = replaceAll(replaced, ` from "../`, ` from "${parent}`);
      replaced = replaceAll(replaced, ` from "./`, ` from "${baSe}`);
      extraModelCache[url] = replaced;
      const regex = /((https:\/\/)+[^\s.]+\.[\w][^\s]+)/gm;
      const models = replaced.matchAll(regex);
      for (const match of models) {
        try {
          const dts = match[0].indexOf(".d.ts");
          if (!match[0].includes("spike.land"))
            continue;
          if (dts === -1)
            continue;
          const extraModel = match[0].slice(0, dts + 5);
          if (extraModels[url].includes(extraModel))
            continue;
          extraModels[url].push(extraModel);
          if (extraModels[extraModel])
            continue;
          if (extraModelCache[extraModel])
            continue;
          let extraModelUrl = new URL(extraModel, location.origin).toString();
          const extraModelContent = await fetch(extraModelUrl).then(
            (resp) => resp.status === 307 ? fetch(resp.headers.get("location")) : resp
          ).then((res) => {
            extraModelUrl = res.url;
            return res.text();
          });
          if (extraModelUrl !== extraModel) {
            extraModelCache[url] = replaceAll(
              extraModelCache[url],
              extraModel,
              extraModelUrl
            );
          }
          extraModelCache[extraModelUrl] = extraModelContent;
          await addExtraModels(extraModelCache[extraModelUrl], extraModelUrl);
        } catch (err) {
          console.error("Error in add extra models", code2, url, { err });
        }
      }
    } catch (err) {
      console.log("error in extra lib  mining", url, { err });
      return;
    }
  }, "addExtraModels");
  const replaceMaps = {};
  const ATA = /* @__PURE__ */ __name(async () => {
    console.log("ATA");
    const mappings = (await Promise.all(
      (await (await (await getTsWorker())(uri)).getSemanticDiagnostics(
        uri.toString()
      )).map((x) => {
        return x.messageText;
      }).filter(
        (x) => typeof x === "string" && x.includes(" or its corresponding type declarations.")
      ).map((x) => typeof x === "string" && x.split("'")[1]).map(
        async (mod3) => {
          const retMod = { url: "", mod: mod3, content: "" };
          if (mod3 && mod3.startsWith("https://")) {
            return retMod;
          }
          retMod.content = await fetch("/npm:/" + mod3).then(
            (resp) => resp.headers.has("location") ? fetch(resp.headers.get("location")) : resp
          ).then((x) => {
            retMod.url = (x.headers.has("x-dts") ? x.headers.get("x-dts") : x.headers.get("x-typescript-types")) || "";
            retMod.url.length && fetch(retMod.url, { redirect: "follow" }).then(
              (resp) => resp.status === 307 || resp.redirected ? fetch(retMod.url = resp.url) : resp
            ).then((resp) => resp.text());
          }).catch(() => "") || "";
          return retMod;
        }
      )
    )).filter((m) => m.mod && m.content).map(async (m) => {
      console.log(`Aga-Insert: ${m.mod}`);
      await addExtraModels(
        m.content,
        m.url
      );
      return {
        [location.origin + `/node_modules/${m.mod}/index.d.ts`]: m.url
      };
    });
    const maps = await Promise.all(mappings);
    maps.forEach((m) => Object.assign(replaceMaps, m));
    console.log({ replaceMaps });
    const extraLib2 = xxxsetExtraLibs();
    extraLib2.map((lib2) => {
      addExtraLib(
        lib2.content,
        lib2.filePath
      );
    });
    typescript.typescriptDefaults.setDiagnosticsOptions({
      noSuggestionDiagnostics: false,
      noSemanticValidation: false,
      noSyntaxValidation: false
    });
  }, "ATA");
  const xxxsetExtraLibs = /* @__PURE__ */ __name(() => {
    const versionNumbers = /@\d+.\d+.\d+/gm;
    const types = /\/types\//gm;
    const extraLibs = Object.keys(extraModelCache).map((filePath) => {
      const url = replaceMappings(filePath, replaceMaps).replaceAll(
        versionNumbers,
        ``
      ).replaceAll(types, `/`);
      const fileDir = new URL(".", url).toString();
      const content = replaceMappings(extraModelCache[filePath], replaceMaps).replaceAll(versionNumbers, ``).replaceAll(types, `/`);
      const fileDirRemoved = replaceAll(content, fileDir, "./");
      const linksRemoved = replaceAll(
        fileDirRemoved,
        location.origin + "/node_modules/",
        ""
      );
      const indexDtsRemoved = replaceAll(linksRemoved, "/index.d.ts", "");
      const dtsRemoved = replaceAll(indexDtsRemoved, ".d.ts", "");
      return {
        filePath: url,
        content: dtsRemoved
      };
    });
    console.log({ extraLibs });
    setExtraLibs(
      extraLibs
    );
    return extraLibs;
  }, "xxxsetExtraLibs");
  const extraLib = xxxsetExtraLibs();
  extraLib.map((lib2) => {
    addExtraLib(
      lib2.content,
      lib2.filePath
    );
  });
  const mod2 = {
    ATA,
    silent: false,
    code
  };
  setTimeout(() => mod2.ATA(), 2e3);
}
__name(extraStuff, "extraStuff");
function replaceAll(input, search, replace) {
  return input.split(search).join(replace);
}
__name(replaceAll, "replaceAll");
function replaceMappings(input, maps) {
  let result = input;
  Object.keys(maps).map((x) => result = replaceAll(result, maps[x], x));
  return result;
}
__name(replaceMappings, "replaceMappings");
function removeComments(str) {
  const regex = /\/\*.*?\*\//gi;
  /\/\*.*?\*\//gi;
  return str.replaceAll(regex, ``).split(`
`).filter(
    (x) => x && x.trim() && (!x.trim().startsWith("//") || x.includes("reference"))
  ).join(`
`);
}
__name(removeComments, "removeComments");

// js/monacoWorkers.mjs
init_define_process();

// js/monaco-workers/editor/editor.workerJs.js
var editor_workerJs_default = "./chunk-editor.workerJs-OM7NEBPV.js";

// js/monaco-workers/language/css/css.workerJs.js
var css_workerJs_default = "./chunk-css.workerJs-65GYNOSN.js";

// js/monaco-workers/language/html/html.workerJs.js
var html_workerJs_default = "./chunk-html.workerJs-LCRMOOPZ.js";

// js/monaco-workers/language/json/json.workerJs.js
var json_workerJs_default = "./chunk-json.workerJs-4JHQEPJM.js";

// js/monaco-workers/language/typescript/ts.workerJs.js
var ts_workerJs_default = "./chunk-ts.workerJs-NZKUFXSO.js";

// js/monacoWorkers.mjs
var getWorkerUrl = /* @__PURE__ */ __name((_moduleId, label) => {
  if (label === "json") {
    return new URL(json_workerJs_default, location.origin).toString();
  }
  if (label === "css" || label === "scss" || label === "less") {
    return new URL(css_workerJs_default, location.origin).toString();
  }
  if (label === "html" || label === "handlebars" || label === "razor") {
    return new URL(html_workerJs_default, location.origin).toString();
  }
  if (label === "typescript" || label === "javascript") {
    return new URL(ts_workerJs_default, location.origin).toString();
  }
  return new URL(editor_workerJs_default, location.origin).toString();
}, "getWorkerUrl");

// js/startMonaco.ts
var { createModel } = editor;
var create = editor.create;
var originToUse = window.origin.includes("spike") ? location.origin : "https://testing.spike.land/";
var lib = [
  "dom",
  "dom.iterable",
  "es2015.collection",
  "es2015.core",
  "es2015",
  "es2015.generator",
  "es2015.iterable",
  "es2015.promise",
  "es2015.proxy",
  "es2015.reflect",
  "es2015.symbol",
  "es2015.symbol.wellknown",
  "es2016.array.include",
  "es2016",
  "es2016.full",
  "es2017",
  "es2017.full",
  "es2017.intl",
  "es2017.object",
  "es2017.sharedmemory",
  "es2017.string",
  "es2017.typedarrays",
  "es2018.asyncgenerator",
  "es2018.asynciterator",
  "es2018",
  "es2018.full",
  "es2018.intl",
  "es2018.promise",
  "es2018.regexp",
  "es2019.array",
  "es2019",
  "es2019.full",
  "es2019.object",
  "es2019.string",
  "es2019.symbol",
  "es2020.bigint",
  "es2020",
  "es2020.full",
  "es2020.intl",
  "es2020.promise",
  "es2020.sharedmemory",
  "es2020.string",
  "es2020.symbol.wellknown",
  "es2022",
  "es2022.full",
  "es2022.intl",
  "es2022.promise",
  "es2022.string",
  "es2022.weakref",
  "es5",
  "es6",
  "esnext",
  "esnext.full",
  "esnext.intl",
  "esnext.promise",
  "esnext.string",
  "esnext.weakref",
  "scripthost"
];
var monacoContribution = /* @__PURE__ */ __name(async (code) => {
  languages.typescript.typescriptDefaults.setCompilerOptions({
    baseUrl: originToUse + "/",
    target: languages.typescript.ScriptTarget.ES2016,
    importHelpers: false,
    lib,
    allowJs: true,
    skipLibCheck: true,
    esModuleInterop: true,
    allowSyntheticDefaultImports: true,
    strict: true,
    forceConsistentCasingInFileNames: true,
    noFallthroughCasesInSwitch: true,
    resolveJsonModule: true,
    isolatedModules: true,
    noEmit: true,
    allowNonTsExtensions: true,
    traceResolution: true,
    moduleResolution: languages.typescript.ModuleResolutionKind.NodeJs,
    moduleSpecifierCompletion: 2,
    declaration: true,
    module: languages.typescript.ModuleKind.CommonJS,
    noEmitOnError: true,
    sourceMap: true,
    mapRoot: originToUse + "/src/sourcemaps",
    maxNodeModuleJsDepth: 10,
    rootDir: originToUse,
    paths: {
      [originToUse + "/live/node_modules/"]: [originToUse + "/*"],
      [originToUse + "/live/*"]: [originToUse + "/live/*"],
      [originToUse + "*"]: [originToUse + "/*"],
      [originToUse + "/node_modules/*"]: [originToUse + "/*"],
      [originToUse + "node_modules/*"]: [originToUse + "/*"],
      [originToUse + "/*"]: [originToUse + "/*"],
      [originToUse + "^/*"]: [originToUse + "/*"]
    },
    typeRoots: [
      originToUse + "/@types/",
      originToUse + "/unpkg/@types/",
      originToUse + "/",
      originToUse + "/unpkg:/"
    ],
    jsxImportSource: "@emotion/react",
    jsx: languages.typescript.JsxEmit.ReactJSX,
    allowUmdGlobalAccess: false,
    include: [originToUse + "/node_modules"]
  });
  languages.typescript.typescriptDefaults.setEagerModelSync(true);
  return code;
}, "monacoContribution");
self.MonacoEnvironment = {
  baseUrl: originToUse + "/",
  getWorkerUrl
};
var mod = {};
var startMonaco = /* @__PURE__ */ __name(async ({ code, container, codeSpace, onChange }) => mod[codeSpace] = mod[codeSpace] || await startMonacoPristine({ code, container, codeSpace, onChange }), "startMonaco");
async function startMonacoPristine({ code, container, codeSpace, onChange }) {
  const replaced = await monacoContribution(
    code
  );
  languages.typescript.typescriptDefaults.setDiagnosticsOptions({
    noSuggestionDiagnostics: true,
    noSemanticValidation: true,
    noSyntaxValidation: true
  });
  const uri = Uri.parse(`${originToUse}/live/${codeSpace}/index.tsx`);
  const model = editor.getModel(uri) || createModel(
    replaced,
    "typescript",
    uri
  );
  const addExtraM = /* @__PURE__ */ __name(async () => {
    const search = new RegExp(
      ` from '(${originToUse}/)?live/[a-zA-Z]+`,
      "gm"
    );
    const models = replaced.matchAll(search);
    for (const match of models) {
      console.log("***** EXTRA MODELS *****");
      const codeSpace2 = match[0].split("/live/").pop();
      const extraModel = new URL(
        "/live/" + codeSpace2 + "/index.tsx",
        location.origin
      ).toString();
      const mUri = Uri.parse(`${originToUse}/live/${codeSpace2}/index.tsx`);
      const content = await fetch(extraModel).then((res) => res.text());
      editor.getModel(mUri) || createModel(
        content,
        "typescript",
        mUri
      );
    }
  }, "addExtraM");
  setTimeout(() => addExtraM(), 500);
  const target = container;
  const myEditor = create(target, {
    model,
    scrollbar: {
      scrollByPage: false,
      alwaysConsumeMouseWheel: false
    },
    scrollBeyondLastLine: true,
    scrollPredominantAxis: false,
    smoothScrolling: true,
    suggest: {
      insertMode: "replace",
      filterGraceful: false,
      snippetsPreventQuickSuggestions: false,
      localityBonus: true,
      shareSuggestSelections: true,
      showIcons: true,
      showStatusBar: true,
      preview: true,
      previewMode: "subwordSmart",
      showInlineDetails: true,
      showMethods: true,
      showFunctions: true,
      showConstructors: true,
      showFields: true,
      showModules: true,
      showColors: true,
      showFiles: true,
      showReferences: true,
      showFolders: true,
      showTypeParameters: true,
      showIssues: true,
      showUsers: true,
      showSnippets: true
    },
    automaticLayout: true,
    useShadowDOM: false,
    roundedSelection: true,
    bracketPairColorization: {
      independentColorPoolPerBracketType: true,
      enabled: true
    },
    codeLens: true,
    "semanticHighlighting.enabled": true,
    dragAndDrop: true,
    codeActionsOnSaveTimeout: 300,
    dropIntoEditor: { enabled: true },
    mouseStyle: "default",
    definitionLinkOpensInPeek: true,
    theme: "vs-dark",
    autoClosingBrackets: "beforeWhitespace"
  });
  languages.typescript.typescriptDefaults.setEagerModelSync(true);
  setTimeout(() => extraStuff(code, uri, languages.typescript), 1e3);
  myEditor.onDidBlurEditorText(() => console.log("blur"));
  const mod2 = {
    getValue: () => model.getValue(),
    silent: false,
    getErrors: async () => {
      return (await (await languages.typescript.getTypeScriptWorker())(uri)).getSuggestionDiagnostics(uri.toString()).then((diag) => diag.map((d) => d.messageText.toString())).catch(
        (e) => {
          console.log("ts error, will retry", e);
        }
      );
    },
    setValue: (code2) => {
      console.log("setValue! ", code2);
      mod2.silent = true;
      let state = null;
      try {
        console.log("trying to change code");
        try {
          state = myEditor.saveViewState();
        } catch {
          console.error("error while saving monaco state");
        }
        console.log("trying to change code");
        model.setValue(code2);
        if (state) {
          myEditor.restoreViewState(state);
        }
      } catch {
        console.error("error while saving the state");
      } finally {
        mod2.silent = false;
      }
    }
  };
  const testModel = globalThis.testModel = globalThis.testModel || createModel(model.getValue(), "typescript", Uri.parse(`${originToUse}/live/${codeSpace}/test.tsx`));
  model.onDidChangeContent((ev) => {
    testModel.applyEdits(ev.changes);
    console.log({ version: model.getVersionId(), ev });
    mod2.silent == false && onChange(model.getValue());
  });
  return mod2;
}
__name(startMonacoPristine, "startMonacoPristine");
export {
  startMonaco
};
