import {
  applyPatch,
  hashCode,
  mST,
  makePatch,
  makePatchFrom,
  onSessionUpdate,
  patchSync,
  require_lodash,
  startSession
} from "./chunk-chunk-QABWHZTN.mjs";
import {
  LazyMotion,
  domAnimation,
  domMax,
  m,
  motion
} from "./chunk-chunk-HOIPHXDO.mjs";
import {
  require_emotion_react_jsx_runtime_cjs
} from "./chunk-chunk-3K5FGABK.mjs";
import {
  require_emotion_react_cjs
} from "./chunk-chunk-C2ZKYUOB.mjs";
import {
  $,
  Children,
  PureComponent,
  Suspense,
  _n,
  cloneElement,
  createRef,
  createRoot,
  h,
  init_react_preact,
  isValidElement,
  lazy,
  p,
  useEffect,
  useMemo,
  useRef,
  useState
} from "./chunk-chunk-QVJ2UJAV.mjs";
import {
  init_define_process
} from "./chunk-chunk-QTIR5YHF.mjs";
import {
  __commonJS,
  __toESM
} from "./chunk-chunk-477FBAEY.mjs";

// ../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/standalone.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        f.prettier = e();
      }
    })(function() {
      "use strict";
      var we = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
      var Ye = we((Ig, ru) => {
        var rr = function(e) {
          return e && e.Math == Math && e;
        };
        ru.exports = rr(typeof globalThis == "object" && globalThis) || rr(typeof window == "object" && window) || rr(typeof self == "object" && self) || rr(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var Dt = we((Lg, nu) => {
        nu.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Ct = we((jg, uu) => {
        var So = Dt();
        uu.exports = !So(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var nr = we((Og, su) => {
        var xo = Dt();
        su.exports = !xo(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var Et = we((qg, iu) => {
        var bo = nr(), ur = Function.prototype.call;
        iu.exports = bo ? ur.bind(ur) : function() {
          return ur.apply(ur, arguments);
        };
      });
      var cu = we((lu) => {
        "use strict";
        var au = {}.propertyIsEnumerable, ou = Object.getOwnPropertyDescriptor, To = ou && !au.call({ 1: 2 }, 1);
        lu.f = To ? function(n) {
          var t = ou(this, n);
          return !!t && t.enumerable;
        } : au;
      });
      var sr = we((Rg, pu) => {
        pu.exports = function(e, n) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
        };
      });
      var at = we((Vg, mu) => {
        var fu = nr(), Du = Function.prototype, Bo = Du.bind, Or = Du.call, No = fu && Bo.bind(Or, Or);
        mu.exports = fu ? function(e) {
          return e && No(e);
        } : function(e) {
          return e && function() {
            return Or.apply(e, arguments);
          };
        };
      });
      var ir = we((Wg, gu) => {
        var du = at(), wo = du({}.toString), _o = du("".slice);
        gu.exports = function(e) {
          return _o(wo(e), 8, -1);
        };
      });
      var hu = we(($g, yu) => {
        var Po = Ye(), ko = at(), Io = Dt(), Lo = ir(), qr = Po.Object, jo = ko("".split);
        yu.exports = Io(function() {
          return !qr("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return Lo(e) == "String" ? jo(e, "") : qr(e);
        } : qr;
      });
      var Mr = we((Hg, vu) => {
        var Oo = Ye(), qo = Oo.TypeError;
        vu.exports = function(e) {
          if (e == null)
            throw qo("Can't call method on " + e);
          return e;
        };
      });
      var ar = we((Gg, Cu) => {
        var Mo = hu(), Ro = Mr();
        Cu.exports = function(e) {
          return Mo(Ro(e));
        };
      });
      var ot = we((Jg, Eu) => {
        Eu.exports = function(e) {
          return typeof e == "function";
        };
      });
      var Ft = we((Ug, Fu) => {
        var Vo = ot();
        Fu.exports = function(e) {
          return typeof e == "object" ? e !== null : Vo(e);
        };
      });
      var Rt = we((zg, Au) => {
        var Rr = Ye(), Wo = ot(), $o = function(e) {
          return Wo(e) ? e : void 0;
        };
        Au.exports = function(e, n) {
          return arguments.length < 2 ? $o(Rr[e]) : Rr[e] && Rr[e][n];
        };
      });
      var Vr = we((Xg, Su) => {
        var Ho = at();
        Su.exports = Ho({}.isPrototypeOf);
      });
      var bu = we((Kg, xu) => {
        var Go = Rt();
        xu.exports = Go("navigator", "userAgent") || "";
      });
      var ku = we((Yg, Pu) => {
        var _u = Ye(), Wr = bu(), Tu = _u.process, Bu = _u.Deno, Nu = Tu && Tu.versions || Bu && Bu.version, wu = Nu && Nu.v8, ft, or;
        wu && (ft = wu.split("."), or = ft[0] > 0 && ft[0] < 4 ? 1 : +(ft[0] + ft[1]));
        !or && Wr && (ft = Wr.match(/Edge\/(\d+)/), (!ft || ft[1] >= 74) && (ft = Wr.match(/Chrome\/(\d+)/), ft && (or = +ft[1])));
        Pu.exports = or;
      });
      var $r = we((Qg, Lu) => {
        var Iu = ku(), Jo = Dt();
        Lu.exports = !!Object.getOwnPropertySymbols && !Jo(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Iu && Iu < 41;
        });
      });
      var Hr = we((Zg, ju) => {
        var Uo = $r();
        ju.exports = Uo && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Gr = we((e0, Ou) => {
        var zo = Ye(), Xo = Rt(), Ko = ot(), Yo = Vr(), Qo = Hr(), Zo = zo.Object;
        Ou.exports = Qo ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var n = Xo("Symbol");
          return Ko(n) && Yo(n.prototype, Zo(e));
        };
      });
      var lr = we((t0, qu) => {
        var el = Ye(), tl = el.String;
        qu.exports = function(e) {
          try {
            return tl(e);
          } catch {
            return "Object";
          }
        };
      });
      var Vt = we((r0, Mu) => {
        var rl = Ye(), nl = ot(), ul = lr(), sl = rl.TypeError;
        Mu.exports = function(e) {
          if (nl(e))
            return e;
          throw sl(ul(e) + " is not a function");
        };
      });
      var cr = we((n0, Ru) => {
        var il = Vt();
        Ru.exports = function(e, n) {
          var t = e[n];
          return t == null ? void 0 : il(t);
        };
      });
      var Wu = we((u0, Vu) => {
        var al = Ye(), Jr = Et(), Ur = ot(), zr = Ft(), ol = al.TypeError;
        Vu.exports = function(e, n) {
          var t, s;
          if (n === "string" && Ur(t = e.toString) && !zr(s = Jr(t, e)) || Ur(t = e.valueOf) && !zr(s = Jr(t, e)) || n !== "string" && Ur(t = e.toString) && !zr(s = Jr(t, e)))
            return s;
          throw ol("Can't convert object to primitive value");
        };
      });
      var Hu = we((s0, $u) => {
        $u.exports = false;
      });
      var pr = we((i0, Ju) => {
        var Gu = Ye(), ll = Object.defineProperty;
        Ju.exports = function(e, n) {
          try {
            ll(Gu, e, { value: n, configurable: true, writable: true });
          } catch {
            Gu[e] = n;
          }
          return n;
        };
      });
      var fr = we((a0, zu) => {
        var cl = Ye(), pl = pr(), Uu = "__core-js_shared__", fl = cl[Uu] || pl(Uu, {});
        zu.exports = fl;
      });
      var Xr = we((o0, Ku) => {
        var Dl = Hu(), Xu = fr();
        (Ku.exports = function(e, n) {
          return Xu[e] || (Xu[e] = n !== void 0 ? n : {});
        })("versions", []).push({ version: "3.22.2", mode: Dl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Dr = we((l0, Yu) => {
        var ml = Ye(), dl = Mr(), gl = ml.Object;
        Yu.exports = function(e) {
          return gl(dl(e));
        };
      });
      var gt = we((c0, Qu) => {
        var yl = at(), hl = Dr(), vl = yl({}.hasOwnProperty);
        Qu.exports = Object.hasOwn || function(n, t) {
          return vl(hl(n), t);
        };
      });
      var Kr = we((p0, Zu) => {
        var Cl = at(), El = 0, Fl = Math.random(), Al = Cl(1 .toString);
        Zu.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Al(++El + Fl, 36);
        };
      });
      var St = we((f0, us) => {
        var Sl = Ye(), xl = Xr(), es = gt(), bl = Kr(), ts = $r(), ns = Hr(), Nt = xl("wks"), At = Sl.Symbol, rs = At && At.for, Tl = ns ? At : At && At.withoutSetter || bl;
        us.exports = function(e) {
          if (!es(Nt, e) || !(ts || typeof Nt[e] == "string")) {
            var n = "Symbol." + e;
            ts && es(At, e) ? Nt[e] = At[e] : ns && rs ? Nt[e] = rs(n) : Nt[e] = Tl(n);
          }
          return Nt[e];
        };
      });
      var os = we((D0, as) => {
        var Bl = Ye(), Nl = Et(), ss = Ft(), is = Gr(), wl = cr(), _l = Wu(), Pl = St(), kl = Bl.TypeError, Il = Pl("toPrimitive");
        as.exports = function(e, n) {
          if (!ss(e) || is(e))
            return e;
          var t = wl(e, Il), s;
          if (t) {
            if (n === void 0 && (n = "default"), s = Nl(t, e, n), !ss(s) || is(s))
              return s;
            throw kl("Can't convert object to primitive value");
          }
          return n === void 0 && (n = "number"), _l(e, n);
        };
      });
      var mr = we((m0, ls) => {
        var Ll = os(), jl = Gr();
        ls.exports = function(e) {
          var n = Ll(e, "string");
          return jl(n) ? n : n + "";
        };
      });
      var fs = we((d0, ps) => {
        var Ol = Ye(), cs = Ft(), Yr = Ol.document, ql = cs(Yr) && cs(Yr.createElement);
        ps.exports = function(e) {
          return ql ? Yr.createElement(e) : {};
        };
      });
      var Qr = we((g0, Ds) => {
        var Ml = Ct(), Rl = Dt(), Vl = fs();
        Ds.exports = !Ml && !Rl(function() {
          return Object.defineProperty(Vl("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Zr = we((ds) => {
        var Wl = Ct(), $l = Et(), Hl = cu(), Gl = sr(), Jl = ar(), Ul = mr(), zl = gt(), Xl = Qr(), ms = Object.getOwnPropertyDescriptor;
        ds.f = Wl ? ms : function(n, t) {
          if (n = Jl(n), t = Ul(t), Xl)
            try {
              return ms(n, t);
            } catch {
            }
          if (zl(n, t))
            return Gl(!$l(Hl.f, n, t), n[t]);
        };
      });
      var ys = we((h0, gs) => {
        var Kl = Ct(), Yl = Dt();
        gs.exports = Kl && Yl(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var wt = we((v0, vs) => {
        var hs = Ye(), Ql = Ft(), Zl = hs.String, ec = hs.TypeError;
        vs.exports = function(e) {
          if (Ql(e))
            return e;
          throw ec(Zl(e) + " is not an object");
        };
      });
      var gr = we((Es) => {
        var tc = Ye(), rc = Ct(), nc = Qr(), uc = ys(), dr = wt(), Cs = mr(), sc = tc.TypeError, en = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, tn = "enumerable", rn = "configurable", nn = "writable";
        Es.f = rc ? uc ? function(n, t, s) {
          if (dr(n), t = Cs(t), dr(s), typeof n == "function" && t === "prototype" && "value" in s && nn in s && !s[nn]) {
            var a = ic(n, t);
            a && a[nn] && (n[t] = s.value, s = { configurable: rn in s ? s[rn] : a[rn], enumerable: tn in s ? s[tn] : a[tn], writable: false });
          }
          return en(n, t, s);
        } : en : function(n, t, s) {
          if (dr(n), t = Cs(t), dr(s), nc)
            try {
              return en(n, t, s);
            } catch {
            }
          if ("get" in s || "set" in s)
            throw sc("Accessors not supported");
          return "value" in s && (n[t] = s.value), n;
        };
      });
      var yr = we((E0, Fs) => {
        var ac = Ct(), oc = gr(), lc = sr();
        Fs.exports = ac ? function(e, n, t) {
          return oc.f(e, n, lc(1, t));
        } : function(e, n, t) {
          return e[n] = t, e;
        };
      });
      var hr = we((F0, As) => {
        var cc = at(), pc = ot(), un = fr(), fc = cc(Function.toString);
        pc(un.inspectSource) || (un.inspectSource = function(e) {
          return fc(e);
        });
        As.exports = un.inspectSource;
      });
      var bs = we((A0, xs) => {
        var Dc = Ye(), mc = ot(), dc = hr(), Ss = Dc.WeakMap;
        xs.exports = mc(Ss) && /native code/.test(dc(Ss));
      });
      var Ns = we((S0, Bs) => {
        var gc = Xr(), yc = Kr(), Ts = gc("keys");
        Bs.exports = function(e) {
          return Ts[e] || (Ts[e] = yc(e));
        };
      });
      var sn = we((x0, ws2) => {
        ws2.exports = {};
      });
      var js = we((b0, Ls) => {
        var hc = bs(), Is = Ye(), an = at(), vc = Ft(), Cc = yr(), on = gt(), ln = fr(), Ec = Ns(), Fc = sn(), _s = "Object already initialized", pn = Is.TypeError, Ac = Is.WeakMap, vr, Wt, Cr, Sc = function(e) {
          return Cr(e) ? Wt(e) : vr(e, {});
        }, xc = function(e) {
          return function(n) {
            var t;
            if (!vc(n) || (t = Wt(n)).type !== e)
              throw pn("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        hc || ln.state ? (yt = ln.state || (ln.state = new Ac()), Ps = an(yt.get), cn = an(yt.has), ks = an(yt.set), vr = function(e, n) {
          if (cn(yt, e))
            throw new pn(_s);
          return n.facade = e, ks(yt, e, n), n;
        }, Wt = function(e) {
          return Ps(yt, e) || {};
        }, Cr = function(e) {
          return cn(yt, e);
        }) : (xt = Ec("state"), Fc[xt] = true, vr = function(e, n) {
          if (on(e, xt))
            throw new pn(_s);
          return n.facade = e, Cc(e, xt, n), n;
        }, Wt = function(e) {
          return on(e, xt) ? e[xt] : {};
        }, Cr = function(e) {
          return on(e, xt);
        });
        var yt, Ps, cn, ks, xt;
        Ls.exports = { set: vr, get: Wt, has: Cr, enforce: Sc, getterFor: xc };
      });
      var Ms = we((T0, qs) => {
        var fn = Ct(), bc2 = gt(), Os = Function.prototype, Tc = fn && Object.getOwnPropertyDescriptor, Dn = bc2(Os, "name"), Bc = Dn && function() {
        }.name === "something", Nc = Dn && (!fn || fn && Tc(Os, "name").configurable);
        qs.exports = { EXISTS: Dn, PROPER: Bc, CONFIGURABLE: Nc };
      });
      var Hs = we((B0, $s) => {
        var wc = Ye(), Rs = ot(), _c = gt(), Vs = yr(), Pc = pr(), kc = hr(), Ws = js(), Ic = Ms().CONFIGURABLE, Lc = Ws.get, jc = Ws.enforce, Oc = String(String).split("String");
        ($s.exports = function(e, n, t, s) {
          var a = s ? !!s.unsafe : false, r = s ? !!s.enumerable : false, u = s ? !!s.noTargetGet : false, i = s && s.name !== void 0 ? s.name : n, o;
          if (Rs(t) && (String(i).slice(0, 7) === "Symbol(" && (i = "[" + String(i).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!_c(t, "name") || Ic && t.name !== i) && Vs(t, "name", i), o = jc(t), o.source || (o.source = Oc.join(typeof i == "string" ? i : ""))), e === wc) {
            r ? e[n] = t : Pc(n, t);
            return;
          } else
            a ? !u && e[n] && (r = true) : delete e[n];
          r ? e[n] = t : Vs(e, n, t);
        })(Function.prototype, "toString", function() {
          return Rs(this) && Lc(this).source || kc(this);
        });
      });
      var Er = we((N0, Gs) => {
        var qc = Math.ceil, Mc = Math.floor;
        Gs.exports = function(e) {
          var n = +e;
          return n !== n || n === 0 ? 0 : (n > 0 ? Mc : qc)(n);
        };
      });
      var Us = we((w0, Js) => {
        var Rc = Er(), Vc = Math.max, Wc = Math.min;
        Js.exports = function(e, n) {
          var t = Rc(e);
          return t < 0 ? Vc(t + n, 0) : Wc(t, n);
        };
      });
      var Xs = we((_0, zs) => {
        var $c = Er(), Hc = Math.min;
        zs.exports = function(e) {
          return e > 0 ? Hc($c(e), 9007199254740991) : 0;
        };
      });
      var _t = we((P0, Ks) => {
        var Gc = Xs();
        Ks.exports = function(e) {
          return Gc(e.length);
        };
      });
      var Zs = we((k0, Qs) => {
        var Jc = ar(), Uc = Us(), zc = _t(), Ys = function(e) {
          return function(n, t, s) {
            var a = Jc(n), r = zc(a), u = Uc(s, r), i;
            if (e && t != t) {
              for (; r > u; )
                if (i = a[u++], i != i)
                  return true;
            } else
              for (; r > u; u++)
                if ((e || u in a) && a[u] === t)
                  return e || u || 0;
            return !e && -1;
          };
        };
        Qs.exports = { includes: Ys(true), indexOf: Ys(false) };
      });
      var ri = we((I0, ti) => {
        var Xc = at(), mn = gt(), Kc = ar(), Yc = Zs().indexOf, Qc = sn(), ei = Xc([].push);
        ti.exports = function(e, n) {
          var t = Kc(e), s = 0, a = [], r;
          for (r in t)
            !mn(Qc, r) && mn(t, r) && ei(a, r);
          for (; n.length > s; )
            mn(t, r = n[s++]) && (~Yc(a, r) || ei(a, r));
          return a;
        };
      });
      var ui = we((L0, ni) => {
        ni.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var ii = we((si) => {
        var Zc = ri(), ep = ui(), tp = ep.concat("length", "prototype");
        si.f = Object.getOwnPropertyNames || function(n) {
          return Zc(n, tp);
        };
      });
      var oi = we((ai) => {
        ai.f = Object.getOwnPropertySymbols;
      });
      var ci = we((q0, li) => {
        var rp = Rt(), np = at(), up = ii(), sp = oi(), ip = wt(), ap = np([].concat);
        li.exports = rp("Reflect", "ownKeys") || function(n) {
          var t = up.f(ip(n)), s = sp.f;
          return s ? ap(t, s(n)) : t;
        };
      });
      var Di = we((M0, fi) => {
        var pi = gt(), op = ci(), lp = Zr(), cp = gr();
        fi.exports = function(e, n, t) {
          for (var s = op(n), a = cp.f, r = lp.f, u = 0; u < s.length; u++) {
            var i = s[u];
            !pi(e, i) && !(t && pi(t, i)) && a(e, i, r(n, i));
          }
        };
      });
      var di = we((R0, mi) => {
        var pp = Dt(), fp = ot(), Dp = /#|\.prototype\./, $t = function(e, n) {
          var t = dp[mp(e)];
          return t == yp ? true : t == gp ? false : fp(n) ? pp(n) : !!n;
        }, mp = $t.normalize = function(e) {
          return String(e).replace(Dp, ".").toLowerCase();
        }, dp = $t.data = {}, gp = $t.NATIVE = "N", yp = $t.POLYFILL = "P";
        mi.exports = $t;
      });
      var Ht = we((V0, gi) => {
        var dn = Ye(), hp = Zr().f, vp = yr(), Cp = Hs(), Ep = pr(), Fp = Di(), Ap = di();
        gi.exports = function(e, n) {
          var t = e.target, s = e.global, a = e.stat, r, u, i, o, c, v;
          if (s ? u = dn : a ? u = dn[t] || Ep(t, {}) : u = (dn[t] || {}).prototype, u)
            for (i in n) {
              if (c = n[i], e.noTargetGet ? (v = hp(u, i), o = v && v.value) : o = u[i], r = Ap(s ? i : t + (a ? "." : "#") + i, e.forced), !r && o !== void 0) {
                if (typeof c == typeof o)
                  continue;
                Fp(c, o);
              }
              (e.sham || o && o.sham) && vp(c, "sham", true), Cp(u, i, c, e);
            }
        };
      });
      var gn = we((W0, yi) => {
        var Sp = ir();
        yi.exports = Array.isArray || function(n) {
          return Sp(n) == "Array";
        };
      });
      var yn = we(($0, vi) => {
        var hi = at(), xp = Vt(), bp = nr(), Tp = hi(hi.bind);
        vi.exports = function(e, n) {
          return xp(e), n === void 0 ? e : bp ? Tp(e, n) : function() {
            return e.apply(n, arguments);
          };
        };
      });
      var hn = we((H0, Ei) => {
        "use strict";
        var Bp = Ye(), Np = gn(), wp = _t(), _p = yn(), Pp = Bp.TypeError, Ci = function(e, n, t, s, a, r, u, i) {
          for (var o = a, c = 0, v = u ? _p(u, i) : false, m2, d; c < s; ) {
            if (c in t) {
              if (m2 = v ? v(t[c], c, n) : t[c], r > 0 && Np(m2))
                d = wp(m2), o = Ci(e, n, m2, d, o, r - 1) - 1;
              else {
                if (o >= 9007199254740991)
                  throw Pp("Exceed the acceptable array length");
                e[o] = m2;
              }
              o++;
            }
            c++;
          }
          return o;
        };
        Ei.exports = Ci;
      });
      var Si = we((G0, Ai) => {
        var kp = St(), Ip = kp("toStringTag"), Fi = {};
        Fi[Ip] = "z";
        Ai.exports = String(Fi) === "[object z]";
      });
      var vn = we((J0, xi) => {
        var Lp = Ye(), jp = Si(), Op = ot(), Fr = ir(), qp = St(), Mp = qp("toStringTag"), Rp = Lp.Object, Vp = Fr(function() {
          return arguments;
        }()) == "Arguments", Wp = function(e, n) {
          try {
            return e[n];
          } catch {
          }
        };
        xi.exports = jp ? Fr : function(e) {
          var n, t, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Wp(n = Rp(e), Mp)) == "string" ? t : Vp ? Fr(n) : (s = Fr(n)) == "Object" && Op(n.callee) ? "Arguments" : s;
        };
      });
      var _i = we((U0, wi) => {
        var $p = at(), Hp = Dt(), bi = ot(), Gp = vn(), Jp = Rt(), Up = hr(), Ti = function() {
        }, zp = [], Bi = Jp("Reflect", "construct"), Cn = /^\s*(?:class|function)\b/, Xp = $p(Cn.exec), Kp = !Cn.exec(Ti), Gt = function(n) {
          if (!bi(n))
            return false;
          try {
            return Bi(Ti, zp, n), true;
          } catch {
            return false;
          }
        }, Ni = function(n) {
          if (!bi(n))
            return false;
          switch (Gp(n)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Kp || !!Xp(Cn, Up(n));
          } catch {
            return true;
          }
        };
        Ni.sham = true;
        wi.exports = !Bi || Hp(function() {
          var e;
          return Gt(Gt.call) || !Gt(Object) || !Gt(function() {
            e = true;
          }) || e;
        }) ? Ni : Gt;
      });
      var Li = we((z0, Ii) => {
        var Yp = Ye(), Pi = gn(), Qp = _i(), Zp = Ft(), ef = St(), tf = ef("species"), ki = Yp.Array;
        Ii.exports = function(e) {
          var n;
          return Pi(e) && (n = e.constructor, Qp(n) && (n === ki || Pi(n.prototype)) ? n = void 0 : Zp(n) && (n = n[tf], n === null && (n = void 0))), n === void 0 ? ki : n;
        };
      });
      var En = we((X0, ji) => {
        var rf = Li();
        ji.exports = function(e, n) {
          return new (rf(e))(n === 0 ? 0 : n);
        };
      });
      var Oi = we(() => {
        "use strict";
        var nf = Ht(), uf = hn(), sf = Vt(), af = Dr(), of = _t(), lf = En();
        nf({ target: "Array", proto: true }, { flatMap: function(n) {
          var t = af(this), s = of(t), a;
          return sf(n), a = lf(t, 0), a.length = uf(a, t, t, s, 0, 1, n, arguments.length > 1 ? arguments[1] : void 0), a;
        } });
      });
      var Fn = we((Q0, qi) => {
        qi.exports = {};
      });
      var Ri = we((Z0, Mi) => {
        var cf = St(), pf = Fn(), ff = cf("iterator"), Df = Array.prototype;
        Mi.exports = function(e) {
          return e !== void 0 && (pf.Array === e || Df[ff] === e);
        };
      });
      var An = we((ey, Wi) => {
        var mf = vn(), Vi = cr(), df = Fn(), gf = St(), yf = gf("iterator");
        Wi.exports = function(e) {
          if (e != null)
            return Vi(e, yf) || Vi(e, "@@iterator") || df[mf(e)];
        };
      });
      var Hi = we((ty, $i) => {
        var hf = Ye(), vf = Et(), Cf = Vt(), Ef = wt(), Ff = lr(), Af = An(), Sf = hf.TypeError;
        $i.exports = function(e, n) {
          var t = arguments.length < 2 ? Af(e) : n;
          if (Cf(t))
            return Ef(vf(t, e));
          throw Sf(Ff(e) + " is not iterable");
        };
      });
      var Ui = we((ry, Ji) => {
        var xf = Et(), Gi = wt(), bf = cr();
        Ji.exports = function(e, n, t) {
          var s, a;
          Gi(e);
          try {
            if (s = bf(e, "return"), !s) {
              if (n === "throw")
                throw t;
              return t;
            }
            s = xf(s, e);
          } catch (r) {
            a = true, s = r;
          }
          if (n === "throw")
            throw t;
          if (a)
            throw s;
          return Gi(s), t;
        };
      });
      var Qi = we((ny, Yi) => {
        var Tf = Ye(), Bf = yn(), Nf = Et(), wf = wt(), _f = lr(), Pf = Ri(), kf = _t(), zi = Vr(), If = Hi(), Lf = An(), Xi = Ui(), jf = Tf.TypeError, Ar = function(e, n) {
          this.stopped = e, this.result = n;
        }, Ki = Ar.prototype;
        Yi.exports = function(e, n, t) {
          var s = t && t.that, a = !!(t && t.AS_ENTRIES), r = !!(t && t.IS_ITERATOR), u = !!(t && t.INTERRUPTED), i = Bf(n, s), o, c, v, m2, d, p2, f, h3 = function(T) {
            return o && Xi(o, "normal", T), new Ar(true, T);
          }, w = function(T) {
            return a ? (wf(T), u ? i(T[0], T[1], h3) : i(T[0], T[1])) : u ? i(T, h3) : i(T);
          };
          if (r)
            o = e;
          else {
            if (c = Lf(e), !c)
              throw jf(_f(e) + " is not iterable");
            if (Pf(c)) {
              for (v = 0, m2 = kf(e); m2 > v; v++)
                if (d = w(e[v]), d && zi(Ki, d))
                  return d;
              return new Ar(false);
            }
            o = If(e, c);
          }
          for (p2 = o.next; !(f = Nf(p2, o)).done; ) {
            try {
              d = w(f.value);
            } catch (T) {
              Xi(o, "throw", T);
            }
            if (typeof d == "object" && d && zi(Ki, d))
              return d;
          }
          return new Ar(false);
        };
      });
      var ea = we((uy, Zi) => {
        "use strict";
        var Of = mr(), qf = gr(), Mf = sr();
        Zi.exports = function(e, n, t) {
          var s = Of(n);
          s in e ? qf.f(e, s, Mf(0, t)) : e[s] = t;
        };
      });
      var ta = we(() => {
        var Rf = Ht(), Vf = Qi(), Wf = ea();
        Rf({ target: "Object", stat: true }, { fromEntries: function(n) {
          var t = {};
          return Vf(n, function(s, a) {
            Wf(t, s, a);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var ra = we(() => {
        var $f = Ht(), Hf = Ye();
        $f({ global: true }, { globalThis: Hf });
      });
      var na = we(() => {
        ra();
      });
      var ua = we(() => {
        "use strict";
        var Gf = Ht(), Jf = hn(), Uf = Dr(), zf = _t(), Xf = Er(), Kf = En();
        Gf({ target: "Array", proto: true }, { flat: function() {
          var n = arguments.length ? arguments[0] : void 0, t = Uf(this), s = zf(t), a = Kf(t, 0);
          return a.length = Jf(a, t, t, s, 0, n === void 0 ? 1 : Xf(n)), a;
        } });
      });
      var Pg = we((my, Co) => {
        var Yf = ["cliName", "cliCategory", "cliDescription"], Qf = ["_"], Zf = ["languageId"], sa, ia, aa, oa, la, ca;
        function kn(e, n) {
          if (e == null)
            return {};
          var t = eD(e, n), s, a;
          if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            for (a = 0; a < r.length; a++)
              s = r[a], !(n.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
          }
          return t;
        }
        function eD(e, n) {
          if (e == null)
            return {};
          var t = {}, s = Object.keys(e), a, r;
          for (r = 0; r < s.length; r++)
            a = s[r], !(n.indexOf(a) >= 0) && (t[a] = e[a]);
          return t;
        }
        Oi();
        ta();
        na();
        ua();
        function Pt(e, n) {
          return n || (n = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(n) } }));
        }
        var tD = Object.create, Br = Object.defineProperty, rD = Object.getOwnPropertyDescriptor, In = Object.getOwnPropertyNames, nD = Object.getPrototypeOf, uD = Object.prototype.hasOwnProperty, mt = (e, n) => function() {
          return e && (n = (0, e[In(e)[0]])(e = 0)), n;
        }, Z = (e, n) => function() {
          return n || (0, e[In(e)[0]])((n = { exports: {} }).exports, n), n.exports;
        }, Ut = (e, n) => {
          for (var t in n)
            Br(e, t, { get: n[t], enumerable: true });
        }, ga = (e, n, t, s) => {
          if (n && typeof n == "object" || typeof n == "function")
            for (let a of In(n))
              !uD.call(e, a) && a !== t && Br(e, a, { get: () => n[a], enumerable: !(s = rD(n, a)) || s.enumerable });
          return e;
        }, sD = (e, n, t) => (t = e != null ? tD(nD(e)) : {}, ga(n || !e || !e.__esModule ? Br(t, "default", { value: e, enumerable: true }) : t, e)), lt = (e) => ga(Br({}, "__esModule", { value: true }), e), pa, fa, Tt, re = mt({ "<define:process>"() {
          pa = {}, fa = [], Tt = { env: pa, argv: fa };
        } }), ya = Z({ "package.json"(e, n) {
          n.exports = { version: "2.7.1" };
        } }), iD = Z({ "node_modules/diff/lib/diff/base.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.default = n;
          function n() {
          }
          n.prototype = { diff: function(r, u) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = i.callback;
            typeof i == "function" && (o = i, i = {}), this.options = i;
            var c = this;
            function v(S) {
              return o ? (setTimeout(function() {
                o(void 0, S);
              }, 0), true) : S;
            }
            r = this.castInput(r), u = this.castInput(u), r = this.removeEmpty(this.tokenize(r)), u = this.removeEmpty(this.tokenize(u));
            var m2 = u.length, d = r.length, p2 = 1, f = m2 + d, h3 = [{ newPos: -1, components: [] }], w = this.extractCommon(h3[0], u, r, 0);
            if (h3[0].newPos + 1 >= m2 && w + 1 >= d)
              return v([{ value: this.join(u), count: u.length }]);
            function T() {
              for (var S = -1 * p2; S <= p2; S += 2) {
                var B = void 0, I = h3[S - 1], k = h3[S + 1], P = (k ? k.newPos : 0) - S;
                I && (h3[S - 1] = void 0);
                var C = I && I.newPos + 1 < m2, D = k && 0 <= P && P < d;
                if (!C && !D) {
                  h3[S] = void 0;
                  continue;
                }
                if (!C || D && I.newPos < k.newPos ? (B = s(k), c.pushComponent(B.components, void 0, true)) : (B = I, B.newPos++, c.pushComponent(B.components, true, void 0)), P = c.extractCommon(B, u, r, S), B.newPos + 1 >= m2 && P + 1 >= d)
                  return v(t(c, B.components, u, r, c.useLongestToken));
                h3[S] = B;
              }
              p2++;
            }
            if (o)
              (function S() {
                setTimeout(function() {
                  if (p2 > f)
                    return o();
                  T() || S();
                }, 0);
              })();
            else
              for (; p2 <= f; ) {
                var A = T();
                if (A)
                  return A;
              }
          }, pushComponent: function(r, u, i) {
            var o = r[r.length - 1];
            o && o.added === u && o.removed === i ? r[r.length - 1] = { count: o.count + 1, added: u, removed: i } : r.push({ count: 1, added: u, removed: i });
          }, extractCommon: function(r, u, i, o) {
            for (var c = u.length, v = i.length, m2 = r.newPos, d = m2 - o, p2 = 0; m2 + 1 < c && d + 1 < v && this.equals(u[m2 + 1], i[d + 1]); )
              m2++, d++, p2++;
            return p2 && r.components.push({ count: p2 }), r.newPos = m2, d;
          }, equals: function(r, u) {
            return this.options.comparator ? this.options.comparator(r, u) : r === u || this.options.ignoreCase && r.toLowerCase() === u.toLowerCase();
          }, removeEmpty: function(r) {
            for (var u = [], i = 0; i < r.length; i++)
              r[i] && u.push(r[i]);
            return u;
          }, castInput: function(r) {
            return r;
          }, tokenize: function(r) {
            return r.split("");
          }, join: function(r) {
            return r.join("");
          } };
          function t(a, r, u, i, o) {
            for (var c = 0, v = r.length, m2 = 0, d = 0; c < v; c++) {
              var p2 = r[c];
              if (p2.removed) {
                if (p2.value = a.join(i.slice(d, d + p2.count)), d += p2.count, c && r[c - 1].added) {
                  var h3 = r[c - 1];
                  r[c - 1] = r[c], r[c] = h3;
                }
              } else {
                if (!p2.added && o) {
                  var f = u.slice(m2, m2 + p2.count);
                  f = f.map(function(T, A) {
                    var S = i[d + A];
                    return S.length > T.length ? S : T;
                  }), p2.value = a.join(f);
                } else
                  p2.value = a.join(u.slice(m2, m2 + p2.count));
                m2 += p2.count, p2.added || (d += p2.count);
              }
            }
            var w = r[v - 1];
            return v > 1 && typeof w.value == "string" && (w.added || w.removed) && a.equals("", w.value) && (r[v - 2].value += w.value, r.pop()), r;
          }
          function s(a) {
            return { newPos: a.newPos, components: a.components.slice(0) };
          }
        } }), aD = Z({ "node_modules/diff/lib/diff/array.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
          var n = t(iD());
          function t(r) {
            return r && r.__esModule ? r : { default: r };
          }
          var s = new n.default();
          e.arrayDiff = s, s.tokenize = function(r) {
            return r.slice();
          }, s.join = s.removeEmpty = function(r) {
            return r;
          };
          function a(r, u, i) {
            return s.diff(r, u, i);
          }
        } }), Ln = Z({ "src/document/doc-builders.js"(e, n) {
          "use strict";
          re();
          function t(F) {
            return { type: "concat", parts: F };
          }
          function s(F) {
            return { type: "indent", contents: F };
          }
          function a(F, l) {
            return { type: "align", contents: l, n: F };
          }
          function r(F) {
            let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return { type: "group", id: l.id, contents: F, break: Boolean(l.shouldBreak), expandedStates: l.expandedStates };
          }
          function u(F) {
            return a(Number.NEGATIVE_INFINITY, F);
          }
          function i(F) {
            return a({ type: "root" }, F);
          }
          function o(F) {
            return a(-1, F);
          }
          function c(F, l) {
            return r(F[0], Object.assign(Object.assign({}, l), {}, { expandedStates: F }));
          }
          function v(F) {
            return { type: "fill", parts: F };
          }
          function m2(F, l) {
            let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return { type: "if-break", breakContents: F, flatContents: l, groupId: E.groupId };
          }
          function d(F, l) {
            return { type: "indent-if-break", contents: F, groupId: l.groupId, negate: l.negate };
          }
          function p2(F) {
            return { type: "line-suffix", contents: F };
          }
          var f = { type: "line-suffix-boundary" }, h3 = { type: "break-parent" }, w = { type: "trim" }, T = { type: "line", hard: true }, A = { type: "line", hard: true, literal: true }, S = { type: "line" }, B = { type: "line", soft: true }, I = t([T, h3]), k = t([A, h3]), P = { type: "cursor", placeholder: Symbol("cursor") };
          function C(F, l) {
            let E = [];
            for (let y = 0; y < l.length; y++)
              y !== 0 && E.push(F), E.push(l[y]);
            return t(E);
          }
          function D(F, l, E) {
            let y = F;
            if (l > 0) {
              for (let N = 0; N < Math.floor(l / E); ++N)
                y = s(y);
              y = a(l % E, y), y = a(Number.NEGATIVE_INFINITY, y);
            }
            return y;
          }
          function g(F, l) {
            return { type: "label", label: F, contents: l };
          }
          n.exports = { concat: t, join: C, line: S, softline: B, hardline: I, literalline: k, group: r, conditionalGroup: c, fill: v, lineSuffix: p2, lineSuffixBoundary: f, cursor: P, breakParent: h3, ifBreak: m2, trim: w, indent: s, indentIfBreak: d, align: a, addAlignmentToDoc: D, markAsRoot: i, dedentToRoot: u, dedent: o, hardlineWithoutBreakParent: T, literallineWithoutBreakParent: A, label: g };
        } }), jn = Z({ "src/common/end-of-line.js"(e, n) {
          "use strict";
          re();
          function t(u) {
            let i = u.indexOf("\r");
            return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function s(u) {
            switch (u) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function a(u, i) {
            let o;
            switch (i) {
              case `
`:
                o = /\n/g;
                break;
              case "\r":
                o = /\r/g;
                break;
              case `\r
`:
                o = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(i), "."));
            }
            let c = u.match(o);
            return c ? c.length : 0;
          }
          function r(u) {
            return u.replace(/\r\n?/g, `
`);
          }
          n.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: r };
        } }), it = Z({ "src/utils/get-last.js"(e, n) {
          "use strict";
          re();
          var t = (s) => s[s.length - 1];
          n.exports = t;
        } });
        function oD() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(n, e ? void 0 : "g");
        }
        var lD = mt({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          re();
        } });
        function cD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
          return e.replace(oD(), "");
        }
        var pD = mt({ "node_modules/strip-ansi/index.js"() {
          re(), lD();
        } });
        function fD(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var DD = mt({ "node_modules/is-fullwidth-code-point/index.js"() {
          re();
        } }), mD = Z({ "node_modules/emoji-regex/index.js"(e, n) {
          "use strict";
          re(), n.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), ha = {};
        Ut(ha, { default: () => dD });
        function dD(e) {
          if (typeof e != "string" || e.length === 0 || (e = cD(e), e.length === 0))
            return 0;
          e = e.replace((0, va.default)(), "  ");
          let n = 0;
          for (let t = 0; t < e.length; t++) {
            let s = e.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, n += fD(s) ? 2 : 1);
          }
          return n;
        }
        var va, gD = mt({ "node_modules/string-width/index.js"() {
          re(), pD(), DD(), va = sD(mD());
        } }), Ca = Z({ "src/utils/get-string-width.js"(e, n) {
          "use strict";
          re();
          var t = (gD(), lt(ha)).default, s = /[^\x20-\x7F]/;
          function a(r) {
            return r ? s.test(r) ? t(r) : r.length : 0;
          }
          n.exports = a;
        } }), On = Z({ "src/document/doc-utils.js"(e, n) {
          "use strict";
          re();
          var t = it(), { literalline: s, join: a } = Ln(), r = (l) => Array.isArray(l) || l && l.type === "concat", u = (l) => {
            if (Array.isArray(l))
              return l;
            if (l.type !== "concat" && l.type !== "fill")
              throw new Error("Expect doc type to be `concat` or `fill`.");
            return l.parts;
          }, i = {};
          function o(l, E, y, N) {
            let x = [l];
            for (; x.length > 0; ) {
              let b = x.pop();
              if (b === i) {
                y(x.pop());
                continue;
              }
              if (y && x.push(b, i), !E || E(b) !== false)
                if (r(b) || b.type === "fill") {
                  let L = u(b);
                  for (let M = L.length, j = M - 1; j >= 0; --j)
                    x.push(L[j]);
                } else if (b.type === "if-break")
                  b.flatContents && x.push(b.flatContents), b.breakContents && x.push(b.breakContents);
                else if (b.type === "group" && b.expandedStates)
                  if (N)
                    for (let L = b.expandedStates.length, M = L - 1; M >= 0; --M)
                      x.push(b.expandedStates[M]);
                  else
                    x.push(b.contents);
                else
                  b.contents && x.push(b.contents);
            }
          }
          function c(l, E) {
            let y = /* @__PURE__ */ new Map();
            return N(l);
            function N(b) {
              if (y.has(b))
                return y.get(b);
              let L = x(b);
              return y.set(b, L), L;
            }
            function x(b) {
              if (Array.isArray(b))
                return E(b.map(N));
              if (b.type === "concat" || b.type === "fill") {
                let L = b.parts.map(N);
                return E(Object.assign(Object.assign({}, b), {}, { parts: L }));
              }
              if (b.type === "if-break") {
                let L = b.breakContents && N(b.breakContents), M = b.flatContents && N(b.flatContents);
                return E(Object.assign(Object.assign({}, b), {}, { breakContents: L, flatContents: M }));
              }
              if (b.type === "group" && b.expandedStates) {
                let L = b.expandedStates.map(N), M = L[0];
                return E(Object.assign(Object.assign({}, b), {}, { contents: M, expandedStates: L }));
              }
              if (b.contents) {
                let L = N(b.contents);
                return E(Object.assign(Object.assign({}, b), {}, { contents: L }));
              }
              return E(b);
            }
          }
          function v(l, E, y) {
            let N = y, x = false;
            function b(L) {
              let M = E(L);
              if (M !== void 0 && (x = true, N = M), x)
                return false;
            }
            return o(l, b), N;
          }
          function m2(l) {
            if (l.type === "group" && l.break || l.type === "line" && l.hard || l.type === "break-parent")
              return true;
          }
          function d(l) {
            return v(l, m2, false);
          }
          function p2(l) {
            if (l.length > 0) {
              let E = t(l);
              !E.expandedStates && !E.break && (E.break = "propagated");
            }
            return null;
          }
          function f(l) {
            let E = /* @__PURE__ */ new Set(), y = [];
            function N(b) {
              if (b.type === "break-parent" && p2(y), b.type === "group") {
                if (y.push(b), E.has(b))
                  return false;
                E.add(b);
              }
            }
            function x(b) {
              b.type === "group" && y.pop().break && p2(y);
            }
            o(l, N, x, true);
          }
          function h3(l) {
            return l.type === "line" && !l.hard ? l.soft ? "" : " " : l.type === "if-break" ? l.flatContents || "" : l;
          }
          function w(l) {
            return c(l, h3);
          }
          var T = (l, E) => l && l.type === "line" && l.hard && E && E.type === "break-parent";
          function A(l) {
            if (!l)
              return l;
            if (r(l) || l.type === "fill") {
              let E = u(l);
              for (; E.length > 1 && T(...E.slice(-2)); )
                E.length -= 2;
              if (E.length > 0) {
                let y = A(t(E));
                E[E.length - 1] = y;
              }
              return Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
            }
            switch (l.type) {
              case "align":
              case "indent":
              case "indent-if-break":
              case "group":
              case "line-suffix":
              case "label": {
                let E = A(l.contents);
                return Object.assign(Object.assign({}, l), {}, { contents: E });
              }
              case "if-break": {
                let E = A(l.breakContents), y = A(l.flatContents);
                return Object.assign(Object.assign({}, l), {}, { breakContents: E, flatContents: y });
              }
            }
            return l;
          }
          function S(l) {
            return A(I(l));
          }
          function B(l) {
            switch (l.type) {
              case "fill":
                if (l.parts.every((y) => y === ""))
                  return "";
                break;
              case "group":
                if (!l.contents && !l.id && !l.break && !l.expandedStates)
                  return "";
                if (l.contents.type === "group" && l.contents.id === l.id && l.contents.break === l.break && l.contents.expandedStates === l.expandedStates)
                  return l.contents;
                break;
              case "align":
              case "indent":
              case "indent-if-break":
              case "line-suffix":
                if (!l.contents)
                  return "";
                break;
              case "if-break":
                if (!l.flatContents && !l.breakContents)
                  return "";
                break;
            }
            if (!r(l))
              return l;
            let E = [];
            for (let y of u(l)) {
              if (!y)
                continue;
              let [N, ...x] = r(y) ? u(y) : [y];
              typeof N == "string" && typeof t(E) == "string" ? E[E.length - 1] += N : E.push(N), E.push(...x);
            }
            return E.length === 0 ? "" : E.length === 1 ? E[0] : Array.isArray(l) ? E : Object.assign(Object.assign({}, l), {}, { parts: E });
          }
          function I(l) {
            return c(l, (E) => B(E));
          }
          function k(l) {
            let E = [], y = l.filter(Boolean);
            for (; y.length > 0; ) {
              let N = y.shift();
              if (!!N) {
                if (r(N)) {
                  y.unshift(...u(N));
                  continue;
                }
                if (E.length > 0 && typeof t(E) == "string" && typeof N == "string") {
                  E[E.length - 1] += N;
                  continue;
                }
                E.push(N);
              }
            }
            return E;
          }
          function P(l) {
            return c(l, (E) => Array.isArray(E) ? k(E) : E.parts ? Object.assign(Object.assign({}, E), {}, { parts: k(E.parts) }) : E);
          }
          function C(l) {
            return c(l, (E) => typeof E == "string" && E.includes(`
`) ? D(E) : E);
          }
          function D(l) {
            let E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
            return a(E, l.split(`
`)).parts;
          }
          function g(l) {
            if (l.type === "line")
              return true;
          }
          function F(l) {
            return v(l, g, false);
          }
          n.exports = { isConcat: r, getDocParts: u, willBreak: d, traverseDoc: o, findInDoc: v, mapDoc: c, propagateBreaks: f, removeLines: w, stripTrailingHardline: S, normalizeParts: k, normalizeDoc: P, cleanDoc: I, replaceTextEndOfLine: D, replaceEndOfLine: C, canBreak: F };
        } }), yD = Z({ "src/document/doc-printer.js"(e, n) {
          "use strict";
          re();
          var { convertEndOfLineToChars: t } = jn(), s = it(), a = Ca(), { fill: r, cursor: u, indent: i } = Ln(), { isConcat: o, getDocParts: c } = On(), v, m2 = 1, d = 2;
          function p2() {
            return { value: "", length: 0, queue: [] };
          }
          function f(B, I) {
            return w(B, { type: "indent" }, I);
          }
          function h3(B, I, k) {
            return I === Number.NEGATIVE_INFINITY ? B.root || p2() : I < 0 ? w(B, { type: "dedent" }, k) : I ? I.type === "root" ? Object.assign(Object.assign({}, B), {}, { root: B }) : w(B, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, k) : B;
          }
          function w(B, I, k) {
            let P = I.type === "dedent" ? B.queue.slice(0, -1) : [...B.queue, I], C = "", D = 0, g = 0, F = 0;
            for (let L of P)
              switch (L.type) {
                case "indent":
                  y(), k.useTabs ? l(1) : E(k.tabWidth);
                  break;
                case "stringAlign":
                  y(), C += L.n, D += L.n.length;
                  break;
                case "numberAlign":
                  g += 1, F += L.n;
                  break;
                default:
                  throw new Error("Unexpected type '".concat(L.type, "'"));
              }
            return x(), Object.assign(Object.assign({}, B), {}, { value: C, length: D, queue: P });
            function l(L) {
              C += "	".repeat(L), D += k.tabWidth * L;
            }
            function E(L) {
              C += " ".repeat(L), D += L;
            }
            function y() {
              k.useTabs ? N() : x();
            }
            function N() {
              g > 0 && l(g), b();
            }
            function x() {
              F > 0 && E(F), b();
            }
            function b() {
              g = 0, F = 0;
            }
          }
          function T(B) {
            if (B.length === 0)
              return 0;
            let I = 0;
            for (; B.length > 0 && typeof s(B) == "string" && /^[\t ]*$/.test(s(B)); )
              I += B.pop().length;
            if (B.length > 0 && typeof s(B) == "string") {
              let k = s(B).replace(/[\t ]*$/, "");
              I += s(B).length - k.length, B[B.length - 1] = k;
            }
            return I;
          }
          function A(B, I, k, P, C, D) {
            let g = I.length, F = [B], l = [];
            for (; k >= 0; ) {
              if (F.length === 0) {
                if (g === 0)
                  return true;
                F.push(I[g - 1]), g--;
                continue;
              }
              let [E, y, N] = F.pop();
              if (typeof N == "string")
                l.push(N), k -= a(N);
              else if (o(N)) {
                let x = c(N);
                for (let b = x.length - 1; b >= 0; b--)
                  F.push([E, y, x[b]]);
              } else
                switch (N.type) {
                  case "indent":
                    F.push([f(E, P), y, N.contents]);
                    break;
                  case "align":
                    F.push([h3(E, N.n, P), y, N.contents]);
                    break;
                  case "trim":
                    k += T(l);
                    break;
                  case "group": {
                    if (D && N.break)
                      return false;
                    let x = N.break ? m2 : y;
                    F.push([E, x, N.expandedStates && x === m2 ? s(N.expandedStates) : N.contents]), N.id && (v[N.id] = x);
                    break;
                  }
                  case "fill":
                    for (let x = N.parts.length - 1; x >= 0; x--)
                      F.push([E, y, N.parts[x]]);
                    break;
                  case "if-break":
                  case "indent-if-break": {
                    let x = N.groupId ? v[N.groupId] : y;
                    if (x === m2) {
                      let b = N.type === "if-break" ? N.breakContents : N.negate ? N.contents : i(N.contents);
                      b && F.push([E, y, b]);
                    }
                    if (x === d) {
                      let b = N.type === "if-break" ? N.flatContents : N.negate ? i(N.contents) : N.contents;
                      b && F.push([E, y, b]);
                    }
                    break;
                  }
                  case "line":
                    switch (y) {
                      case d:
                        if (!N.hard) {
                          N.soft || (l.push(" "), k -= 1);
                          break;
                        }
                        return true;
                      case m2:
                        return true;
                    }
                    break;
                  case "line-suffix":
                    C = true;
                    break;
                  case "line-suffix-boundary":
                    if (C)
                      return false;
                    break;
                  case "label":
                    F.push([E, y, N.contents]);
                    break;
                }
            }
            return false;
          }
          function S(B, I) {
            v = {};
            let k = I.printWidth, P = t(I.endOfLine), C = 0, D = [[p2(), m2, B]], g = [], F = false, l = [];
            for (; D.length > 0; ) {
              let [y, N, x] = D.pop();
              if (typeof x == "string") {
                let b = P !== `
` ? x.replace(/\n/g, P) : x;
                g.push(b), C += a(b);
              } else if (o(x)) {
                let b = c(x);
                for (let L = b.length - 1; L >= 0; L--)
                  D.push([y, N, b[L]]);
              } else
                switch (x.type) {
                  case "cursor":
                    g.push(u.placeholder);
                    break;
                  case "indent":
                    D.push([f(y, I), N, x.contents]);
                    break;
                  case "align":
                    D.push([h3(y, x.n, I), N, x.contents]);
                    break;
                  case "trim":
                    C -= T(g);
                    break;
                  case "group":
                    switch (N) {
                      case d:
                        if (!F) {
                          D.push([y, x.break ? m2 : d, x.contents]);
                          break;
                        }
                      case m2: {
                        F = false;
                        let b = [y, d, x.contents], L = k - C, M = l.length > 0;
                        if (!x.break && A(b, D, L, I, M))
                          D.push(b);
                        else if (x.expandedStates) {
                          let j = s(x.expandedStates);
                          if (x.break) {
                            D.push([y, m2, j]);
                            break;
                          } else
                            for (let $2 = 1; $2 < x.expandedStates.length + 1; $2++)
                              if ($2 >= x.expandedStates.length) {
                                D.push([y, m2, j]);
                                break;
                              } else {
                                let V = x.expandedStates[$2], q = [y, d, V];
                                if (A(q, D, L, I, M)) {
                                  D.push(q);
                                  break;
                                }
                              }
                        } else
                          D.push([y, m2, x.contents]);
                        break;
                      }
                    }
                    x.id && (v[x.id] = s(D)[1]);
                    break;
                  case "fill": {
                    let b = k - C, { parts: L } = x;
                    if (L.length === 0)
                      break;
                    let [M, j] = L, $2 = [y, d, M], V = [y, m2, M], q = A($2, [], b, I, l.length > 0, true);
                    if (L.length === 1) {
                      q ? D.push($2) : D.push(V);
                      break;
                    }
                    let Y = [y, d, j], H = [y, m2, j];
                    if (L.length === 2) {
                      q ? D.push(Y, $2) : D.push(H, V);
                      break;
                    }
                    L.splice(0, 2);
                    let R = [y, N, r(L)], Q = L[0];
                    A([y, d, [M, j, Q]], [], b, I, l.length > 0, true) ? D.push(R, Y, $2) : q ? D.push(R, H, $2) : D.push(R, H, V);
                    break;
                  }
                  case "if-break":
                  case "indent-if-break": {
                    let b = x.groupId ? v[x.groupId] : N;
                    if (b === m2) {
                      let L = x.type === "if-break" ? x.breakContents : x.negate ? x.contents : i(x.contents);
                      L && D.push([y, N, L]);
                    }
                    if (b === d) {
                      let L = x.type === "if-break" ? x.flatContents : x.negate ? i(x.contents) : x.contents;
                      L && D.push([y, N, L]);
                    }
                    break;
                  }
                  case "line-suffix":
                    l.push([y, N, x.contents]);
                    break;
                  case "line-suffix-boundary":
                    l.length > 0 && D.push([y, N, { type: "line", hard: true }]);
                    break;
                  case "line":
                    switch (N) {
                      case d:
                        if (x.hard)
                          F = true;
                        else {
                          x.soft || (g.push(" "), C += 1);
                          break;
                        }
                      case m2:
                        if (l.length > 0) {
                          D.push([y, N, x], ...l.reverse()), l = [];
                          break;
                        }
                        x.literal ? y.root ? (g.push(P, y.root.value), C = y.root.length) : (g.push(P), C = 0) : (C -= T(g), g.push(P + y.value), C = y.length);
                        break;
                    }
                    break;
                  case "label":
                    D.push([y, N, x.contents]);
                    break;
                  default:
                }
              D.length === 0 && l.length > 0 && (D.push(...l.reverse()), l = []);
            }
            let E = g.indexOf(u.placeholder);
            if (E !== -1) {
              let y = g.indexOf(u.placeholder, E + 1), N = g.slice(0, E).join(""), x = g.slice(E + 1, y).join(""), b = g.slice(y + 1).join("");
              return { formatted: N + x + b, cursorNodeStart: N.length, cursorNodeText: x };
            }
            return { formatted: g.join("") };
          }
          n.exports = { printDocToString: S };
        } }), hD = Z({ "src/document/doc-debug.js"(e, n) {
          "use strict";
          re();
          var { isConcat: t, getDocParts: s } = On();
          function a(u) {
            if (!u)
              return "";
            if (t(u)) {
              let i = [];
              for (let o of s(u))
                if (t(o))
                  i.push(...a(o).parts);
                else {
                  let c = a(o);
                  c !== "" && i.push(c);
                }
              return { type: "concat", parts: i };
            }
            return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
          }
          function r(u) {
            let i = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Set();
            return c(a(u));
            function c(m2, d, p2) {
              if (typeof m2 == "string")
                return JSON.stringify(m2);
              if (t(m2)) {
                let f = s(m2).map(c).filter(Boolean);
                return f.length === 1 ? f[0] : "[".concat(f.join(", "), "]");
              }
              if (m2.type === "line") {
                let f = Array.isArray(p2) && p2[d + 1] && p2[d + 1].type === "break-parent";
                return m2.literal ? f ? "literalline" : "literallineWithoutBreakParent" : m2.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : m2.soft ? "softline" : "line";
              }
              if (m2.type === "break-parent")
                return Array.isArray(p2) && p2[d - 1] && p2[d - 1].type === "line" && p2[d - 1].hard ? void 0 : "breakParent";
              if (m2.type === "trim")
                return "trim";
              if (m2.type === "indent")
                return "indent(" + c(m2.contents) + ")";
              if (m2.type === "align")
                return m2.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + c(m2.contents) + ")" : m2.n < 0 ? "dedent(" + c(m2.contents) + ")" : m2.n.type === "root" ? "markAsRoot(" + c(m2.contents) + ")" : "align(" + JSON.stringify(m2.n) + ", " + c(m2.contents) + ")";
              if (m2.type === "if-break")
                return "ifBreak(" + c(m2.breakContents) + (m2.flatContents ? ", " + c(m2.flatContents) : "") + (m2.groupId ? (m2.flatContents ? "" : ', ""') + ", { groupId: ".concat(v(m2.groupId), " }") : "") + ")";
              if (m2.type === "indent-if-break") {
                let f = [];
                m2.negate && f.push("negate: true"), m2.groupId && f.push("groupId: ".concat(v(m2.groupId)));
                let h3 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                return "indentIfBreak(".concat(c(m2.contents)).concat(h3, ")");
              }
              if (m2.type === "group") {
                let f = [];
                m2.break && m2.break !== "propagated" && f.push("shouldBreak: true"), m2.id && f.push("id: ".concat(v(m2.id)));
                let h3 = f.length > 0 ? ", { ".concat(f.join(", "), " }") : "";
                return m2.expandedStates ? "conditionalGroup([".concat(m2.expandedStates.map((w) => c(w)).join(","), "]").concat(h3, ")") : "group(".concat(c(m2.contents)).concat(h3, ")");
              }
              if (m2.type === "fill")
                return "fill([".concat(m2.parts.map((f) => c(f)).join(", "), "])");
              if (m2.type === "line-suffix")
                return "lineSuffix(" + c(m2.contents) + ")";
              if (m2.type === "line-suffix-boundary")
                return "lineSuffixBoundary";
              if (m2.type === "label")
                return "label(".concat(JSON.stringify(m2.label), ", ").concat(c(m2.contents), ")");
              throw new Error("Unknown doc type " + m2.type);
            }
            function v(m2) {
              if (typeof m2 != "symbol")
                return JSON.stringify(String(m2));
              if (m2 in i)
                return i[m2];
              let d = String(m2).slice(7, -1) || "symbol";
              for (let p2 = 0; ; p2++) {
                let f = d + (p2 > 0 ? " #".concat(p2) : "");
                if (!o.has(f))
                  return o.add(f), i[m2] = "Symbol.for(".concat(JSON.stringify(f), ")");
              }
            }
          }
          n.exports = { printDocToDebug: r };
        } }), Oe = Z({ "src/document/index.js"(e, n) {
          "use strict";
          re(), n.exports = { builders: Ln(), printer: yD(), utils: On(), debug: hD() };
        } }), Ea = {};
        Ut(Ea, { default: () => vD });
        function vD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var CD = mt({ "node_modules/escape-string-regexp/index.js"() {
          re();
        } }), Fa = Z({ "node_modules/semver/internal/debug.js"(e, n) {
          re();
          var t = typeof Tt == "object" && Tt.env && Tt.env.NODE_DEBUG && /\bsemver\b/i.test(Tt.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, a = new Array(s), r = 0; r < s; r++)
              a[r] = arguments[r];
            return console.error("SEMVER", ...a);
          } : () => {
          };
          n.exports = t;
        } }), Aa = Z({ "node_modules/semver/internal/constants.js"(e, n) {
          re();
          var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, r = 16;
          n.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: r };
        } }), ED = Z({ "node_modules/semver/internal/re.js"(e, n) {
          re();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Aa(), s = Fa();
          e = n.exports = {};
          var a = e.re = [], r = e.src = [], u = e.t = {}, i = 0, o = (c, v, m2) => {
            let d = i++;
            s(c, d, v), u[c] = d, r[d] = v, a[d] = new RegExp(v, m2 ? "g" : void 0);
          };
          o("NUMERICIDENTIFIER", "0|[1-9]\\d*"), o("NUMERICIDENTIFIERLOOSE", "[0-9]+"), o("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), o("MAINVERSION", "(".concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")\\.(").concat(r[u.NUMERICIDENTIFIER], ")")), o("MAINVERSIONLOOSE", "(".concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(r[u.NUMERICIDENTIFIERLOOSE], ")")), o("PRERELEASEIDENTIFIER", "(?:".concat(r[u.NUMERICIDENTIFIER], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(r[u.NUMERICIDENTIFIERLOOSE], "|").concat(r[u.NONNUMERICIDENTIFIER], ")")), o("PRERELEASE", "(?:-(".concat(r[u.PRERELEASEIDENTIFIER], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIER], ")*))")), o("PRERELEASELOOSE", "(?:-?(".concat(r[u.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(r[u.PRERELEASEIDENTIFIERLOOSE], ")*))")), o("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), o("BUILD", "(?:\\+(".concat(r[u.BUILDIDENTIFIER], "(?:\\.").concat(r[u.BUILDIDENTIFIER], ")*))")), o("FULLPLAIN", "v?".concat(r[u.MAINVERSION]).concat(r[u.PRERELEASE], "?").concat(r[u.BUILD], "?")), o("FULL", "^".concat(r[u.FULLPLAIN], "$")), o("LOOSEPLAIN", "[v=\\s]*".concat(r[u.MAINVERSIONLOOSE]).concat(r[u.PRERELEASELOOSE], "?").concat(r[u.BUILD], "?")), o("LOOSE", "^".concat(r[u.LOOSEPLAIN], "$")), o("GTLT", "((?:<|>)?=?)"), o("XRANGEIDENTIFIERLOOSE", "".concat(r[u.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), o("XRANGEIDENTIFIER", "".concat(r[u.NUMERICIDENTIFIER], "|x|X|\\*")), o("XRANGEPLAIN", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIER], ")(?:").concat(r[u.PRERELEASE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(r[u.XRANGEIDENTIFIERLOOSE], ")(?:").concat(r[u.PRERELEASELOOSE], ")?").concat(r[u.BUILD], "?)?)?")), o("XRANGE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAIN], "$")), o("XRANGELOOSE", "^".concat(r[u.GTLT], "\\s*").concat(r[u.XRANGEPLAINLOOSE], "$")), o("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), o("COERCERTL", r[u.COERCE], true), o("LONETILDE", "(?:~>?)"), o("TILDETRIM", "(\\s*)".concat(r[u.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", o("TILDE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAIN], "$")), o("TILDELOOSE", "^".concat(r[u.LONETILDE]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("LONECARET", "(?:\\^)"), o("CARETTRIM", "(\\s*)".concat(r[u.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", o("CARET", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAIN], "$")), o("CARETLOOSE", "^".concat(r[u.LONECARET]).concat(r[u.XRANGEPLAINLOOSE], "$")), o("COMPARATORLOOSE", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], ")$|^$")), o("COMPARATOR", "^".concat(r[u.GTLT], "\\s*(").concat(r[u.FULLPLAIN], ")$|^$")), o("COMPARATORTRIM", "(\\s*)".concat(r[u.GTLT], "\\s*(").concat(r[u.LOOSEPLAIN], "|").concat(r[u.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", o("HYPHENRANGE", "^\\s*(".concat(r[u.XRANGEPLAIN], ")\\s+-\\s+(").concat(r[u.XRANGEPLAIN], ")\\s*$")), o("HYPHENRANGELOOSE", "^\\s*(".concat(r[u.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(r[u.XRANGEPLAINLOOSE], ")\\s*$")), o("STAR", "(<|>)?=?\\s*\\*"), o("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), o("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), FD = Z({ "node_modules/semver/internal/parse-options.js"(e, n) {
          re();
          var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((r) => a[r]).reduce((r, u) => (r[u] = true, r), {}) : {};
          n.exports = s;
        } }), AD = Z({ "node_modules/semver/internal/identifiers.js"(e, n) {
          re();
          var t = /^[0-9]+$/, s = (r, u) => {
            let i = t.test(r), o = t.test(u);
            return i && o && (r = +r, u = +u), r === u ? 0 : i && !o ? -1 : o && !i ? 1 : r < u ? -1 : 1;
          }, a = (r, u) => s(u, r);
          n.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
        } }), SD = Z({ "node_modules/semver/classes/semver.js"(e, n) {
          re();
          var t = Fa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = Aa(), { re: r, t: u } = ED(), i = FD(), { compareIdentifiers: o } = AD(), c = class {
            constructor(v, m2) {
              if (m2 = i(m2), v instanceof c) {
                if (v.loose === !!m2.loose && v.includePrerelease === !!m2.includePrerelease)
                  return v;
                v = v.version;
              } else if (typeof v != "string")
                throw new TypeError("Invalid Version: ".concat(v));
              if (v.length > s)
                throw new TypeError("version is longer than ".concat(s, " characters"));
              t("SemVer", v, m2), this.options = m2, this.loose = !!m2.loose, this.includePrerelease = !!m2.includePrerelease;
              let d = v.trim().match(m2.loose ? r[u.LOOSE] : r[u.FULL]);
              if (!d)
                throw new TypeError("Invalid Version: ".concat(v));
              if (this.raw = v, this.major = +d[1], this.minor = +d[2], this.patch = +d[3], this.major > a || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > a || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > a || this.patch < 0)
                throw new TypeError("Invalid patch version");
              d[4] ? this.prerelease = d[4].split(".").map((p2) => {
                if (/^[0-9]+$/.test(p2)) {
                  let f = +p2;
                  if (f >= 0 && f < a)
                    return f;
                }
                return p2;
              }) : this.prerelease = [], this.build = d[5] ? d[5].split(".") : [], this.format();
            }
            format() {
              return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
            }
            toString() {
              return this.version;
            }
            compare(v) {
              if (t("SemVer.compare", this.version, this.options, v), !(v instanceof c)) {
                if (typeof v == "string" && v === this.version)
                  return 0;
                v = new c(v, this.options);
              }
              return v.version === this.version ? 0 : this.compareMain(v) || this.comparePre(v);
            }
            compareMain(v) {
              return v instanceof c || (v = new c(v, this.options)), o(this.major, v.major) || o(this.minor, v.minor) || o(this.patch, v.patch);
            }
            comparePre(v) {
              if (v instanceof c || (v = new c(v, this.options)), this.prerelease.length && !v.prerelease.length)
                return -1;
              if (!this.prerelease.length && v.prerelease.length)
                return 1;
              if (!this.prerelease.length && !v.prerelease.length)
                return 0;
              let m2 = 0;
              do {
                let d = this.prerelease[m2], p2 = v.prerelease[m2];
                if (t("prerelease compare", m2, d, p2), d === void 0 && p2 === void 0)
                  return 0;
                if (p2 === void 0)
                  return 1;
                if (d === void 0)
                  return -1;
                if (d === p2)
                  continue;
                return o(d, p2);
              } while (++m2);
            }
            compareBuild(v) {
              v instanceof c || (v = new c(v, this.options));
              let m2 = 0;
              do {
                let d = this.build[m2], p2 = v.build[m2];
                if (t("prerelease compare", m2, d, p2), d === void 0 && p2 === void 0)
                  return 0;
                if (p2 === void 0)
                  return 1;
                if (d === void 0)
                  return -1;
                if (d === p2)
                  continue;
                return o(d, p2);
              } while (++m2);
            }
            inc(v, m2) {
              switch (v) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", m2);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", m2);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", m2), this.inc("pre", m2);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", m2), this.inc("pre", m2);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let d = this.prerelease.length;
                    for (; --d >= 0; )
                      typeof this.prerelease[d] == "number" && (this.prerelease[d]++, d = -2);
                    d === -1 && this.prerelease.push(0);
                  }
                  m2 && (o(this.prerelease[0], m2) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [m2, 0]) : this.prerelease = [m2, 0]);
                  break;
                default:
                  throw new Error("invalid increment argument: ".concat(v));
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          n.exports = c;
        } }), qn = Z({ "node_modules/semver/functions/compare.js"(e, n) {
          re();
          var t = SD(), s = (a, r, u) => new t(a, u).compare(new t(r, u));
          n.exports = s;
        } }), xD = Z({ "node_modules/semver/functions/lt.js"(e, n) {
          re();
          var t = qn(), s = (a, r, u) => t(a, r, u) < 0;
          n.exports = s;
        } }), bD = Z({ "node_modules/semver/functions/gte.js"(e, n) {
          re();
          var t = qn(), s = (a, r, u) => t(a, r, u) >= 0;
          n.exports = s;
        } }), TD = Z({ "src/utils/arrayify.js"(e, n) {
          "use strict";
          re(), n.exports = (t, s) => Object.entries(t).map((a) => {
            let [r, u] = a;
            return Object.assign({ [s]: r }, u);
          });
        } }), BD = Z({ "node_modules/outdent/lib/index.js"(e, n) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var A = [], S = 0; S < arguments.length; S++)
              A[S] = arguments[S];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
          }
          function a() {
            return { add: t, delete: t, get: t, set: t, has: function(A) {
              return false;
            } };
          }
          var r = Object.prototype.hasOwnProperty, u = function(A, S) {
            return r.call(A, S);
          };
          function i(A, S) {
            for (var B in S)
              u(S, B) && (A[B] = S[B]);
            return A;
          }
          var o = /^[ \t]*(?:\r\n|\r|\n)/, c = /(?:\r\n|\r|\n)[ \t]*$/, v = /^(?:[\r\n]|$)/, m2 = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, d = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function p2(A, S, B) {
            var I = 0, k = A[0].match(m2);
            k && (I = k[1].length);
            var P = "(\\r\\n|\\r|\\n).{0," + I + "}", C = new RegExp(P, "g");
            S && (A = A.slice(1));
            var D = B.newline, g = B.trimLeadingNewline, F = B.trimTrailingNewline, l = typeof D == "string", E = A.length, y = A.map(function(N, x) {
              return N = N.replace(C, "$1"), x === 0 && g && (N = N.replace(o, "")), x === E - 1 && F && (N = N.replace(c, "")), l && (N = N.replace(/\r\n|\n|\r/g, function(b) {
                return D;
              })), N;
            });
            return y;
          }
          function f(A, S) {
            for (var B = "", I = 0, k = A.length; I < k; I++)
              B += A[I], I < k - 1 && (B += S[I]);
            return B;
          }
          function h3(A) {
            return u(A, "raw") && u(A, "length");
          }
          function w(A) {
            var S = s(), B = s();
            function I(P) {
              for (var C = [], D = 1; D < arguments.length; D++)
                C[D - 1] = arguments[D];
              if (h3(P)) {
                var g = P, F = (C[0] === I || C[0] === T) && d.test(g[0]) && v.test(g[1]), l = F ? B : S, E = l.get(g);
                if (E || (E = p2(g, F, A), l.set(g, E)), C.length === 0)
                  return E[0];
                var y = f(E, F ? C.slice(1) : C);
                return y;
              } else
                return w(i(i({}, A), P || {}));
            }
            var k = i(I, { string: function(P) {
              return p2([P], false, A)[0];
            } });
            return k;
          }
          var T = w({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = T, e.default = T, typeof n < "u")
            try {
              n.exports = T, Object.defineProperty(T, "__esModule", { value: true }), T.default = T, T.outdent = T;
            } catch {
            }
        } }), ND = Z({ "src/main/core-options.js"(e, n) {
          "use strict";
          re();
          var { outdent: t } = BD(), s = "Config", a = "Editor", r = "Format", u = "Other", i = "Output", o = "Global", c = "Special", v = { cursorOffset: { since: "1.4.0", category: c, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(sa || (sa = Pt([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: a }, endOfLine: { since: "1.15.0", category: o, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(ia || (ia = Pt([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: c, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: c, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: o, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (m2) => typeof m2 == "string" || typeof m2 == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: o, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: o, description: t(aa || (aa = Pt([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (m2) => typeof m2 == "string" || typeof m2 == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: o, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: c, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(oa || (oa = Pt([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a }, rangeStart: { since: "1.4.0", category: c, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(la || (la = Pt([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: a }, requirePragma: { since: "1.7.0", category: c, type: "boolean", default: false, description: t(ca || (ca = Pt([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: u }, tabWidth: { type: "int", category: o, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: o, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: o, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          n.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: r, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: o, CATEGORY_SPECIAL: c, options: v };
        } }), Mn = Z({ "src/main/support.js"(e, n) {
          "use strict";
          re();
          var t = { compare: qn(), lt: xD(), gte: bD() }, s = TD(), a = ya().version, r = ND().options;
          function u() {
            let { plugins: o = [], showUnreleased: c = false, showDeprecated: v = false, showInternal: m2 = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, d = a.split("-", 1)[0], p2 = o.flatMap((A) => A.languages || []).filter(h3), f = s(Object.assign({}, ...o.map((A) => {
              let { options: S } = A;
              return S;
            }), r), "name").filter((A) => h3(A) && w(A)).sort((A, S) => A.name === S.name ? 0 : A.name < S.name ? -1 : 1).map(T).map((A) => {
              A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(h3).sort((B, I) => t.compare(I.since, B.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter((B) => h3(B) && w(B)), A.name === "parser" && i(A, p2, o));
              let S = Object.fromEntries(o.filter((B) => B.defaultOptions && B.defaultOptions[A.name] !== void 0).map((B) => [B.name, B.defaultOptions[A.name]]));
              return Object.assign(Object.assign({}, A), {}, { pluginDefaults: S });
            });
            return { languages: p2, options: f };
            function h3(A) {
              return c || !("since" in A) || A.since && t.gte(d, A.since);
            }
            function w(A) {
              return v || !("deprecated" in A) || A.deprecated && t.lt(d, A.deprecated);
            }
            function T(A) {
              if (m2)
                return A;
              let { cliName: S, cliCategory: B, cliDescription: I } = A;
              return kn(A, Yf);
            }
          }
          function i(o, c, v) {
            let m2 = new Set(o.choices.map((d) => d.value));
            for (let d of c)
              if (d.parsers) {
                for (let p2 of d.parsers)
                  if (!m2.has(p2)) {
                    m2.add(p2);
                    let f = v.find((w) => w.parsers && w.parsers[p2]), h3 = d.name;
                    f && f.name && (h3 += " (plugin: ".concat(f.name, ")")), o.choices.push({ value: p2, description: h3 });
                  }
              }
          }
          n.exports = { getSupportInfo: u };
        } }), Rn = Z({ "src/utils/is-non-empty-array.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          n.exports = t;
        } }), Nr = Z({ "src/utils/text/skip.js"(e, n) {
          "use strict";
          re();
          function t(i) {
            return (o, c, v) => {
              let m2 = v && v.backwards;
              if (c === false)
                return false;
              let { length: d } = o, p2 = c;
              for (; p2 >= 0 && p2 < d; ) {
                let f = o.charAt(p2);
                if (i instanceof RegExp) {
                  if (!i.test(f))
                    return p2;
                } else if (!i.includes(f))
                  return p2;
                m2 ? p2-- : p2++;
              }
              return p2 === -1 || p2 === d ? p2 : false;
            };
          }
          var s = t(/\s/), a = t(" 	"), r = t(",; 	"), u = t(/[^\n\r]/);
          n.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: r, skipEverythingButNewLine: u };
        } }), Sa = Z({ "src/utils/text/skip-inline-comment.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            if (a === false)
              return false;
            if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
              for (let r = a + 2; r < s.length; ++r)
                if (s.charAt(r) === "*" && s.charAt(r + 1) === "/")
                  return r + 2;
            }
            return a;
          }
          n.exports = t;
        } }), xa = Z({ "src/utils/text/skip-trailing-comment.js"(e, n) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t } = Nr();
          function s(a, r) {
            return r === false ? false : a.charAt(r) === "/" && a.charAt(r + 1) === "/" ? t(a, r) : r;
          }
          n.exports = s;
        } }), ba = Z({ "src/utils/text/skip-newline.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r) {
            let u = r && r.backwards;
            if (a === false)
              return false;
            let i = s.charAt(a);
            if (u) {
              if (s.charAt(a - 1) === "\r" && i === `
`)
                return a - 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a - 1;
            } else {
              if (i === "\r" && s.charAt(a + 1) === `
`)
                return a + 2;
              if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029")
                return a + 1;
            }
            return a;
          }
          n.exports = t;
        } }), wD = Z({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, n) {
          "use strict";
          re();
          var t = Sa(), s = ba(), a = xa(), { skipSpaces: r } = Nr();
          function u(i, o) {
            let c = null, v = o;
            for (; v !== c; )
              c = v, v = r(i, v), v = t(i, v), v = a(i, v), v = s(i, v);
            return v;
          }
          n.exports = u;
        } }), Ue = Z({ "src/common/util.js"(e, n) {
          "use strict";
          re();
          var { default: t } = (CD(), lt(Ea)), s = it(), { getSupportInfo: a } = Mn(), r = Rn(), u = Ca(), { skipWhitespace: i, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v } = Nr(), m2 = Sa(), d = xa(), p2 = ba(), f = wD(), h3 = (H) => H[H.length - 2];
          function w(H) {
            return (R, Q, ee) => {
              let te = ee && ee.backwards;
              if (Q === false)
                return false;
              let { length: oe } = R, W = Q;
              for (; W >= 0 && W < oe; ) {
                let X = R.charAt(W);
                if (H instanceof RegExp) {
                  if (!H.test(X))
                    return W;
                } else if (!H.includes(X))
                  return W;
                te ? W-- : W++;
              }
              return W === -1 || W === oe ? W : false;
            };
          }
          function T(H, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ee = o(H, Q.backwards ? R - 1 : R, Q), te = p2(H, ee, Q);
            return ee !== te;
          }
          function A(H, R, Q) {
            for (let ee = R; ee < Q; ++ee)
              if (H.charAt(ee) === `
`)
                return true;
            return false;
          }
          function S(H, R, Q) {
            let ee = Q(R) - 1;
            ee = o(H, ee, { backwards: true }), ee = p2(H, ee, { backwards: true }), ee = o(H, ee, { backwards: true });
            let te = p2(H, ee, { backwards: true });
            return ee !== te;
          }
          function B(H, R) {
            let Q = null, ee = R;
            for (; ee !== Q; )
              Q = ee, ee = c(H, ee), ee = m2(H, ee), ee = o(H, ee);
            return ee = d(H, ee), ee = p2(H, ee), ee !== false && T(H, ee);
          }
          function I(H, R, Q) {
            return B(H, Q(R));
          }
          function k(H, R, Q) {
            return f(H, Q(R));
          }
          function P(H, R, Q) {
            return H.charAt(k(H, R, Q));
          }
          function C(H, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return o(H, Q.backwards ? R - 1 : R, Q) !== R;
          }
          function D(H, R) {
            let Q = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ee = 0;
            for (let te = Q; te < H.length; ++te)
              H[te] === "	" ? ee = ee + R - ee % R : ee++;
            return ee;
          }
          function g(H, R) {
            let Q = H.lastIndexOf(`
`);
            return Q === -1 ? 0 : D(H.slice(Q + 1).match(/^[\t ]*/)[0], R);
          }
          function F(H, R) {
            let Q = { quote: '"', regex: /"/g, escaped: "&quot;" }, ee = { quote: "'", regex: /'/g, escaped: "&apos;" }, te = R === "'" ? ee : Q, oe = te === ee ? Q : ee, W = te;
            if (H.includes(te.quote) || H.includes(oe.quote)) {
              let X = (H.match(te.regex) || []).length, ue = (H.match(oe.regex) || []).length;
              W = X > ue ? oe : te;
            }
            return W;
          }
          function l(H, R) {
            let Q = H.slice(1, -1), ee = R.parser === "json" || R.parser === "json5" && R.quoteProps === "preserve" && !R.singleQuote ? '"' : R.__isInHtmlAttribute ? "'" : F(Q, R.singleQuote ? "'" : '"').quote;
            return E(Q, ee, !(R.parser === "css" || R.parser === "less" || R.parser === "scss" || R.__embeddedInHtml));
          }
          function E(H, R, Q) {
            let ee = R === '"' ? "'" : '"', te = /\\(.)|(["'])/gs, oe = H.replace(te, (W, X, ue) => X === ee ? X : ue === R ? "\\" + ue : ue || (Q && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(X) ? X : "\\" + X));
            return R + oe + R;
          }
          function y(H) {
            return H.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function N(H, R) {
            let Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
            return Q === null ? 0 : Q.reduce((ee, te) => Math.max(ee, te.length / R.length), 0);
          }
          function x(H, R) {
            let Q = H.match(new RegExp("(".concat(t(R), ")+"), "g"));
            if (Q === null)
              return 0;
            let ee = /* @__PURE__ */ new Map(), te = 0;
            for (let oe of Q) {
              let W = oe.length / R.length;
              ee.set(W, true), W > te && (te = W);
            }
            for (let oe = 1; oe < te; oe++)
              if (!ee.get(oe))
                return oe;
            return te + 1;
          }
          function b(H, R) {
            (H.comments || (H.comments = [])).push(R), R.printed = false, R.nodeDescription = Y(H);
          }
          function L(H, R) {
            R.leading = true, R.trailing = false, b(H, R);
          }
          function M(H, R, Q) {
            R.leading = false, R.trailing = false, Q && (R.marker = Q), b(H, R);
          }
          function j(H, R) {
            R.leading = false, R.trailing = true, b(H, R);
          }
          function $2(H, R) {
            let { languages: Q } = a({ plugins: R.plugins }), ee = Q.find((te) => {
              let { name: oe } = te;
              return oe.toLowerCase() === H;
            }) || Q.find((te) => {
              let { aliases: oe } = te;
              return Array.isArray(oe) && oe.includes(H);
            }) || Q.find((te) => {
              let { extensions: oe } = te;
              return Array.isArray(oe) && oe.includes(".".concat(H));
            });
            return ee && ee.parsers[0];
          }
          function V(H) {
            return H && H.type === "front-matter";
          }
          function q(H) {
            let R = /* @__PURE__ */ new WeakMap();
            return function(Q) {
              return R.has(Q) || R.set(Q, Symbol(H)), R.get(Q);
            };
          }
          function Y(H) {
            let R = H.type || H.kind || "(unknown type)", Q = String(H.name || H.id && (typeof H.id == "object" ? H.id.name : H.id) || H.key && (typeof H.key == "object" ? H.key.name : H.key) || H.value && (typeof H.value == "object" ? "" : String(H.value)) || H.operator || "");
            return Q.length > 20 && (Q = Q.slice(0, 19) + "\u2026"), R + (Q ? " " + Q : "");
          }
          n.exports = { inferParserByLanguage: $2, getStringWidth: u, getMaxContinuousCount: N, getMinNotPresentContinuousCount: x, getPenultimate: h3, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: k, getNextNonSpaceNonCommentCharacter: P, skip: w, skipWhitespace: i, skipSpaces: o, skipToLineEnd: c, skipEverythingButNewLine: v, skipInlineComment: m2, skipTrailingComment: d, skipNewline: p2, isNextLineEmptyAfterIndex: B, isNextLineEmpty: I, isPreviousLineEmpty: S, hasNewline: T, hasNewlineInRange: A, hasSpaces: C, getAlignmentSize: D, getIndentSize: g, getPreferredQuote: F, printString: l, printNumber: y, makeString: E, addLeadingComment: L, addDanglingComment: M, addTrailingComment: j, isFrontMatterNode: V, isNonEmptyArray: r, createGroupIdMapper: q };
        } }), Ta = {};
        Ut(Ta, { basename: () => Pa, default: () => Ia, delimiter: () => Bn, dirname: () => _a, extname: () => ka, isAbsolute: () => Wn, join: () => Na, normalize: () => Vn, relative: () => wa, resolve: () => Tr, sep: () => Tn });
        function Ba(e, n) {
          for (var t = 0, s = e.length - 1; s >= 0; s--) {
            var a = e[s];
            a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
          }
          if (n)
            for (; t--; t)
              e.unshift("..");
          return e;
        }
        function Tr() {
          for (var e = "", n = false, t = arguments.length - 1; t >= -1 && !n; t--) {
            var s = t >= 0 ? arguments[t] : "/";
            if (typeof s != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!s)
              continue;
            e = s + "/" + e, n = s.charAt(0) === "/";
          }
          return e = Ba($n(e.split("/"), function(a) {
            return !!a;
          }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        function Vn(e) {
          var n = Wn(e), t = La(e, -1) === "/";
          return e = Ba($n(e.split("/"), function(s) {
            return !!s;
          }), !n).join("/"), !e && !n && (e = "."), e && t && (e += "/"), (n ? "/" : "") + e;
        }
        function Wn(e) {
          return e.charAt(0) === "/";
        }
        function Na() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Vn($n(e, function(n, t) {
            if (typeof n != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return n;
          }).join("/"));
        }
        function wa(e, n) {
          e = Tr(e).substr(1), n = Tr(n).substr(1);
          function t(c) {
            for (var v = 0; v < c.length && c[v] === ""; v++)
              ;
            for (var m2 = c.length - 1; m2 >= 0 && c[m2] === ""; m2--)
              ;
            return v > m2 ? [] : c.slice(v, m2 - v + 1);
          }
          for (var s = t(e.split("/")), a = t(n.split("/")), r = Math.min(s.length, a.length), u = r, i = 0; i < r; i++)
            if (s[i] !== a[i]) {
              u = i;
              break;
            }
          for (var o = [], i = u; i < s.length; i++)
            o.push("..");
          return o = o.concat(a.slice(u)), o.join("/");
        }
        function _a(e) {
          var n = wr(e), t = n[0], s = n[1];
          return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
        }
        function Pa(e, n) {
          var t = wr(e)[2];
          return n && t.substr(-1 * n.length) === n && (t = t.substr(0, t.length - n.length)), t;
        }
        function ka(e) {
          return wr(e)[3];
        }
        function $n(e, n) {
          if (e.filter)
            return e.filter(n);
          for (var t = [], s = 0; s < e.length; s++)
            n(e[s], s, e) && t.push(e[s]);
          return t;
        }
        var Da, wr, Tn, Bn, Ia, La, _D = mt({ "node-modules-polyfills:path"() {
          re(), Da = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, wr = function(e) {
            return Da.exec(e).slice(1);
          }, Tn = "/", Bn = ":", Ia = { extname: ka, basename: Pa, dirname: _a, sep: Tn, delimiter: Bn, relative: wa, join: Na, isAbsolute: Wn, normalize: Vn, resolve: Tr }, La = "ab".substr(-1) === "b" ? function(e, n, t) {
            return e.substr(n, t);
          } : function(e, n, t) {
            return n < 0 && (n = e.length + n), e.substr(n, t);
          };
        } }), PD = Z({ "node-modules-polyfills-commonjs:path"(e, n) {
          re();
          var t = (_D(), lt(Ta));
          if (t && t.default) {
            n.exports = t.default;
            for (let s in t)
              n.exports[s] = t[s];
          } else
            t && (n.exports = t);
        } }), zt = Z({ "src/common/errors.js"(e, n) {
          "use strict";
          re();
          var t = class extends Error {
          }, s = class extends Error {
          }, a = class extends Error {
          }, r = class extends Error {
          };
          n.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: r };
        } }), dt = {};
        Ut(dt, { __assign: () => br, __asyncDelegator: () => GD, __asyncGenerator: () => HD, __asyncValues: () => JD, __await: () => Jt, __awaiter: () => qD, __classPrivateFieldGet: () => KD, __classPrivateFieldSet: () => YD, __createBinding: () => RD, __decorate: () => LD, __exportStar: () => VD, __extends: () => kD, __generator: () => MD, __importDefault: () => XD, __importStar: () => zD, __makeTemplateObject: () => UD, __metadata: () => OD, __param: () => jD, __read: () => ja, __rest: () => ID, __spread: () => WD, __spreadArrays: () => $D, __values: () => Nn });
        function kD(e, n) {
          xr(e, n);
          function t() {
            this.constructor = e;
          }
          e.prototype = n === null ? Object.create(n) : (t.prototype = n.prototype, new t());
        }
        function ID(e, n) {
          var t = {};
          for (var s in e)
            Object.prototype.hasOwnProperty.call(e, s) && n.indexOf(s) < 0 && (t[s] = e[s]);
          if (e != null && typeof Object.getOwnPropertySymbols == "function")
            for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++)
              n.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
          return t;
        }
        function LD(e, n, t, s) {
          var a = arguments.length, r = a < 3 ? n : s === null ? s = Object.getOwnPropertyDescriptor(n, t) : s, u;
          if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
            r = Reflect.decorate(e, n, t, s);
          else
            for (var i = e.length - 1; i >= 0; i--)
              (u = e[i]) && (r = (a < 3 ? u(r) : a > 3 ? u(n, t, r) : u(n, t)) || r);
          return a > 3 && r && Object.defineProperty(n, t, r), r;
        }
        function jD(e, n) {
          return function(t, s) {
            n(t, s, e);
          };
        }
        function OD(e, n) {
          if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
            return Reflect.metadata(e, n);
        }
        function qD(e, n, t, s) {
          function a(r) {
            return r instanceof t ? r : new t(function(u) {
              u(r);
            });
          }
          return new (t || (t = Promise))(function(r, u) {
            function i(v) {
              try {
                c(s.next(v));
              } catch (m2) {
                u(m2);
              }
            }
            function o(v) {
              try {
                c(s.throw(v));
              } catch (m2) {
                u(m2);
              }
            }
            function c(v) {
              v.done ? r(v.value) : a(v.value).then(i, o);
            }
            c((s = s.apply(e, n || [])).next());
          });
        }
        function MD(e, n) {
          var t = { label: 0, sent: function() {
            if (r[0] & 1)
              throw r[1];
            return r[1];
          }, trys: [], ops: [] }, s, a, r, u;
          return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
            return this;
          }), u;
          function i(c) {
            return function(v) {
              return o([c, v]);
            };
          }
          function o(c) {
            if (s)
              throw new TypeError("Generator is already executing.");
            for (; t; )
              try {
                if (s = 1, a && (r = c[0] & 2 ? a.return : c[0] ? a.throw || ((r = a.return) && r.call(a), 0) : a.next) && !(r = r.call(a, c[1])).done)
                  return r;
                switch (a = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                  case 0:
                  case 1:
                    r = c;
                    break;
                  case 4:
                    return t.label++, { value: c[1], done: false };
                  case 5:
                    t.label++, a = c[1], c = [0];
                    continue;
                  case 7:
                    c = t.ops.pop(), t.trys.pop();
                    continue;
                  default:
                    if (r = t.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                      t = 0;
                      continue;
                    }
                    if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                      t.label = c[1];
                      break;
                    }
                    if (c[0] === 6 && t.label < r[1]) {
                      t.label = r[1], r = c;
                      break;
                    }
                    if (r && t.label < r[2]) {
                      t.label = r[2], t.ops.push(c);
                      break;
                    }
                    r[2] && t.ops.pop(), t.trys.pop();
                    continue;
                }
                c = n.call(e, t);
              } catch (v) {
                c = [6, v], a = 0;
              } finally {
                s = r = 0;
              }
            if (c[0] & 5)
              throw c[1];
            return { value: c[0] ? c[1] : void 0, done: true };
          }
        }
        function RD(e, n, t, s) {
          s === void 0 && (s = t), e[s] = n[t];
        }
        function VD(e, n) {
          for (var t in e)
            t !== "default" && !n.hasOwnProperty(t) && (n[t] = e[t]);
        }
        function Nn(e) {
          var n = typeof Symbol == "function" && Symbol.iterator, t = n && e[n], s = 0;
          if (t)
            return t.call(e);
          if (e && typeof e.length == "number")
            return { next: function() {
              return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
            } };
          throw new TypeError(n ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function ja(e, n) {
          var t = typeof Symbol == "function" && e[Symbol.iterator];
          if (!t)
            return e;
          var s = t.call(e), a, r = [], u;
          try {
            for (; (n === void 0 || n-- > 0) && !(a = s.next()).done; )
              r.push(a.value);
          } catch (i) {
            u = { error: i };
          } finally {
            try {
              a && !a.done && (t = s.return) && t.call(s);
            } finally {
              if (u)
                throw u.error;
            }
          }
          return r;
        }
        function WD() {
          for (var e = [], n = 0; n < arguments.length; n++)
            e = e.concat(ja(arguments[n]));
          return e;
        }
        function $D() {
          for (var e = 0, n = 0, t = arguments.length; n < t; n++)
            e += arguments[n].length;
          for (var s = Array(e), a = 0, n = 0; n < t; n++)
            for (var r = arguments[n], u = 0, i = r.length; u < i; u++, a++)
              s[a] = r[u];
          return s;
        }
        function Jt(e) {
          return this instanceof Jt ? (this.v = e, this) : new Jt(e);
        }
        function HD(e, n, t) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var s = t.apply(e, n || []), a, r = [];
          return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
            return this;
          }, a;
          function u(d) {
            s[d] && (a[d] = function(p2) {
              return new Promise(function(f, h3) {
                r.push([d, p2, f, h3]) > 1 || i(d, p2);
              });
            });
          }
          function i(d, p2) {
            try {
              o(s[d](p2));
            } catch (f) {
              m2(r[0][3], f);
            }
          }
          function o(d) {
            d.value instanceof Jt ? Promise.resolve(d.value.v).then(c, v) : m2(r[0][2], d);
          }
          function c(d) {
            i("next", d);
          }
          function v(d) {
            i("throw", d);
          }
          function m2(d, p2) {
            d(p2), r.shift(), r.length && i(r[0][0], r[0][1]);
          }
        }
        function GD(e) {
          var n, t;
          return n = {}, s("next"), s("throw", function(a) {
            throw a;
          }), s("return"), n[Symbol.iterator] = function() {
            return this;
          }, n;
          function s(a, r) {
            n[a] = e[a] ? function(u) {
              return (t = !t) ? { value: Jt(e[a](u)), done: a === "return" } : r ? r(u) : u;
            } : r;
          }
        }
        function JD(e) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var n = e[Symbol.asyncIterator], t;
          return n ? n.call(e) : (e = typeof Nn == "function" ? Nn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
            return this;
          }, t);
          function s(r) {
            t[r] = e[r] && function(u) {
              return new Promise(function(i, o) {
                u = e[r](u), a(i, o, u.done, u.value);
              });
            };
          }
          function a(r, u, i, o) {
            Promise.resolve(o).then(function(c) {
              r({ value: c, done: i });
            }, u);
          }
        }
        function UD(e, n) {
          return Object.defineProperty ? Object.defineProperty(e, "raw", { value: n }) : e.raw = n, e;
        }
        function zD(e) {
          if (e && e.__esModule)
            return e;
          var n = {};
          if (e != null)
            for (var t in e)
              Object.hasOwnProperty.call(e, t) && (n[t] = e[t]);
          return n.default = e, n;
        }
        function XD(e) {
          return e && e.__esModule ? e : { default: e };
        }
        function KD(e, n) {
          if (!n.has(e))
            throw new TypeError("attempted to get private field on non-instance");
          return n.get(e);
        }
        function YD(e, n, t) {
          if (!n.has(e))
            throw new TypeError("attempted to set private field on non-instance");
          return n.set(e, t), t;
        }
        var xr, br, ht = mt({ "node_modules/tslib/tslib.es6.js"() {
          re(), xr = function(e, n) {
            return xr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
              t.__proto__ = s;
            } || function(t, s) {
              for (var a in s)
                s.hasOwnProperty(a) && (t[a] = s[a]);
            }, xr(e, n);
          }, br = function() {
            return br = Object.assign || function(n) {
              for (var t, s = 1, a = arguments.length; s < a; s++) {
                t = arguments[s];
                for (var r in t)
                  Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
              }
              return n;
            }, br.apply(this, arguments);
          };
        } }), Oa = Z({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (n) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(n) ? n : JSON.stringify(n), value(n) {
            if (n === null || typeof n != "object")
              return JSON.stringify(n);
            if (Array.isArray(n))
              return "[".concat(n.map((s) => e.apiDescriptor.value(s)).join(", "), "]");
            let t = Object.keys(n);
            return t.length === 0 ? "{}" : "{ ".concat(t.map((s) => "".concat(e.apiDescriptor.key(s), ": ").concat(e.apiDescriptor.value(n[s]))).join(", "), " }");
          }, pair: (n) => {
            let { key: t, value: s } = n;
            return e.apiDescriptor.value({ [t]: s });
          } };
        } }), QD = Z({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(Oa(), e);
        } }), _r = Z({ "scripts/build/shims/chalk.cjs"(e, n) {
          "use strict";
          re();
          var t = (s) => s;
          t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, n.exports = t;
        } }), qa = Z({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r();
          e.commonDeprecatedHandler = (t, s, a) => {
            let { descriptor: r } = a, u = ["".concat(n.default.yellow(typeof t == "string" ? r.key(t) : r.pair(t)), " is deprecated")];
            return s && u.push("we now treat it as ".concat(n.default.blue(typeof s == "string" ? r.key(s) : r.pair(s)))), u.join("; ") + ".";
          };
        } }), ZD = Z({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(qa(), e);
        } }), em = Z({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r();
          e.commonInvalidHandler = (t, s, a) => ["Invalid ".concat(n.default.red(a.descriptor.key(t)), " value."), "Expected ".concat(n.default.blue(a.schemas[t].expected(a)), ","), "but received ".concat(n.default.red(a.descriptor.value(s)), ".")].join(" ");
        } }), Ma = Z({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(em(), e);
        } }), tm = Z({ "node_modules/vnopts/node_modules/leven/index.js"(e, n) {
          "use strict";
          re();
          var t = [], s = [];
          n.exports = function(a, r) {
            if (a === r)
              return 0;
            var u = a;
            a.length > r.length && (a = r, r = u);
            var i = a.length, o = r.length;
            if (i === 0)
              return o;
            if (o === 0)
              return i;
            for (; i > 0 && a.charCodeAt(~-i) === r.charCodeAt(~-o); )
              i--, o--;
            if (i === 0)
              return o;
            for (var c = 0; c < i && a.charCodeAt(c) === r.charCodeAt(c); )
              c++;
            if (i -= c, o -= c, i === 0)
              return o;
            for (var v, m2, d, p2, f = 0, h3 = 0; f < i; )
              s[c + f] = a.charCodeAt(c + f), t[f] = ++f;
            for (; h3 < o; )
              for (v = r.charCodeAt(c + h3), d = h3++, m2 = h3, f = 0; f < i; f++)
                p2 = v === s[c + f] ? d : d + 1, d = t[f], m2 = t[f] = d > m2 ? p2 > m2 ? m2 + 1 : p2 : p2 > d ? d + 1 : p2;
            return m2;
          };
        } }), Ra = Z({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = _r(), t = tm();
          e.levenUnknownHandler = (s, a, r) => {
            let { descriptor: u, logger: i, schemas: o } = r, c = ["Ignored unknown option ".concat(n.default.yellow(u.pair({ key: s, value: a })), ".")], v = Object.keys(o).sort().find((m2) => t(s, m2) < 3);
            v && c.push("Did you mean ".concat(n.default.blue(u.key(v)), "?")), i.warn(c.join(" "));
          };
        } }), rm = Z({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(Ra(), e);
        } }), nm = Z({ "node_modules/vnopts/lib/handlers/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(ZD(), e), n.__exportStar(Ma(), e), n.__exportStar(rm(), e);
        } }), vt = Z({ "node_modules/vnopts/lib/schema.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
          function t(r, u) {
            let i = new r(u), o = Object.create(i);
            for (let c of n)
              c in u && (o[c] = a(u[c], i, s.prototype[c].length));
            return o;
          }
          e.createSchema = t;
          var s = class {
            constructor(r) {
              this.name = r.name;
            }
            static create(r) {
              return t(this, r);
            }
            default(r) {
            }
            expected(r) {
              return "nothing";
            }
            validate(r, u) {
              return false;
            }
            deprecated(r, u) {
              return false;
            }
            forward(r, u) {
            }
            redirect(r, u) {
            }
            overlap(r, u, i) {
              return r;
            }
            preprocess(r, u) {
              return r;
            }
            postprocess(r, u) {
              return r;
            }
          };
          e.Schema = s;
          function a(r, u, i) {
            return typeof r == "function" ? function() {
              for (var o = arguments.length, c = new Array(o), v = 0; v < o; v++)
                c[v] = arguments[v];
              return r(...c.slice(0, i - 1), u, ...c.slice(i - 1));
            } : () => r;
          }
        } }), um = Z({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = class extends n.Schema {
            constructor(s) {
              super(s), this._sourceName = s.sourceName;
            }
            expected(s) {
              return s.schemas[this._sourceName].expected(s);
            }
            validate(s, a) {
              return a.schemas[this._sourceName].validate(s, a);
            }
            redirect(s, a) {
              return this._sourceName;
            }
          };
          e.AliasSchema = t;
        } }), sm = Z({ "node_modules/vnopts/lib/schemas/any.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = class extends n.Schema {
            expected() {
              return "anything";
            }
            validate() {
              return true;
            }
          };
          e.AnySchema = t;
        } }), im = Z({ "node_modules/vnopts/lib/schemas/array.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt)), t = vt(), s = class extends t.Schema {
            constructor(r) {
              var { valueSchema: u, name: i = u.name } = r, o = n.__rest(r, ["valueSchema", "name"]);
              super(Object.assign({}, o, { name: i })), this._valueSchema = u;
            }
            expected(r) {
              return "an array of ".concat(this._valueSchema.expected(r));
            }
            validate(r, u) {
              if (!Array.isArray(r))
                return false;
              let i = [];
              for (let o of r) {
                let c = u.normalizeValidateResult(this._valueSchema.validate(o, u), o);
                c !== true && i.push(c.value);
              }
              return i.length === 0 ? true : { value: i };
            }
            deprecated(r, u) {
              let i = [];
              for (let o of r) {
                let c = u.normalizeDeprecatedResult(this._valueSchema.deprecated(o, u), o);
                c !== false && i.push(...c.map((v) => {
                  let { value: m2 } = v;
                  return { value: [m2] };
                }));
              }
              return i;
            }
            forward(r, u) {
              let i = [];
              for (let o of r) {
                let c = u.normalizeForwardResult(this._valueSchema.forward(o, u), o);
                i.push(...c.map(a));
              }
              return i;
            }
            redirect(r, u) {
              let i = [], o = [];
              for (let c of r) {
                let v = u.normalizeRedirectResult(this._valueSchema.redirect(c, u), c);
                "remain" in v && i.push(v.remain), o.push(...v.redirect.map(a));
              }
              return i.length === 0 ? { redirect: o } : { redirect: o, remain: i };
            }
            overlap(r, u) {
              return r.concat(u);
            }
          };
          e.ArraySchema = s;
          function a(r) {
            let { from: u, to: i } = r;
            return { from: [u], to: i };
          }
        } }), am = Z({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = class extends n.Schema {
            expected() {
              return "true or false";
            }
            validate(s) {
              return typeof s == "boolean";
            }
          };
          e.BooleanSchema = t;
        } }), Hn = Z({ "node_modules/vnopts/lib/utils.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          function n(p2, f) {
            let h3 = /* @__PURE__ */ Object.create(null);
            for (let w of p2) {
              let T = w[f];
              if (h3[T])
                throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
              h3[T] = w;
            }
            return h3;
          }
          e.recordFromArray = n;
          function t(p2, f) {
            let h3 = /* @__PURE__ */ new Map();
            for (let w of p2) {
              let T = w[f];
              if (h3.has(T))
                throw new Error("Duplicate ".concat(f, " ").concat(JSON.stringify(T)));
              h3.set(T, w);
            }
            return h3;
          }
          e.mapFromArray = t;
          function s() {
            let p2 = /* @__PURE__ */ Object.create(null);
            return (f) => {
              let h3 = JSON.stringify(f);
              return p2[h3] ? true : (p2[h3] = true, false);
            };
          }
          e.createAutoChecklist = s;
          function a(p2, f) {
            let h3 = [], w = [];
            for (let T of p2)
              f(T) ? h3.push(T) : w.push(T);
            return [h3, w];
          }
          e.partition = a;
          function r(p2) {
            return p2 === Math.floor(p2);
          }
          e.isInt = r;
          function u(p2, f) {
            if (p2 === f)
              return 0;
            let h3 = typeof p2, w = typeof f, T = ["undefined", "object", "boolean", "number", "string"];
            return h3 !== w ? T.indexOf(h3) - T.indexOf(w) : h3 !== "string" ? Number(p2) - Number(f) : p2.localeCompare(f);
          }
          e.comparePrimitive = u;
          function i(p2) {
            return p2 === void 0 ? {} : p2;
          }
          e.normalizeDefaultResult = i;
          function o(p2, f) {
            return p2 === true ? true : p2 === false ? { value: f } : p2;
          }
          e.normalizeValidateResult = o;
          function c(p2, f) {
            let h3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            return p2 === false ? false : p2 === true ? h3 ? true : [{ value: f }] : "value" in p2 ? [p2] : p2.length === 0 ? false : p2;
          }
          e.normalizeDeprecatedResult = c;
          function v(p2, f) {
            return typeof p2 == "string" || "key" in p2 ? { from: f, to: p2 } : "from" in p2 ? { from: p2.from, to: p2.to } : { from: f, to: p2.to };
          }
          e.normalizeTransferResult = v;
          function m2(p2, f) {
            return p2 === void 0 ? [] : Array.isArray(p2) ? p2.map((h3) => v(h3, f)) : [v(p2, f)];
          }
          e.normalizeForwardResult = m2;
          function d(p2, f) {
            let h3 = m2(typeof p2 == "object" && "redirect" in p2 ? p2.redirect : p2, f);
            return h3.length === 0 ? { remain: f, redirect: h3 } : typeof p2 == "object" && "remain" in p2 ? { remain: p2.remain, redirect: h3 } : { redirect: h3 };
          }
          e.normalizeRedirectResult = d;
        } }), om = Z({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = Hn(), s = class extends n.Schema {
            constructor(a) {
              super(a), this._choices = t.mapFromArray(a.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
            }
            expected(a) {
              let { descriptor: r } = a, u = Array.from(this._choices.keys()).map((c) => this._choices.get(c)).filter((c) => !c.deprecated).map((c) => c.value).sort(t.comparePrimitive).map(r.value), i = u.slice(0, -2), o = u.slice(-2);
              return i.concat(o.join(" or ")).join(", ");
            }
            validate(a) {
              return this._choices.has(a);
            }
            deprecated(a) {
              let r = this._choices.get(a);
              return r && r.deprecated ? { value: a } : false;
            }
            forward(a) {
              let r = this._choices.get(a);
              return r ? r.forward : void 0;
            }
            redirect(a) {
              let r = this._choices.get(a);
              return r ? r.redirect : void 0;
            }
          };
          e.ChoiceSchema = s;
        } }), Va = Z({ "node_modules/vnopts/lib/schemas/number.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = class extends n.Schema {
            expected() {
              return "a number";
            }
            validate(s, a) {
              return typeof s == "number";
            }
          };
          e.NumberSchema = t;
        } }), lm = Z({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Hn(), t = Va(), s = class extends t.NumberSchema {
            expected() {
              return "an integer";
            }
            validate(a, r) {
              return r.normalizeValidateResult(super.validate(a, r), a) === true && n.isInt(a);
            }
          };
          e.IntegerSchema = s;
        } }), cm = Z({ "node_modules/vnopts/lib/schemas/string.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = vt(), t = class extends n.Schema {
            expected() {
              return "a string";
            }
            validate(s) {
              return typeof s == "string";
            }
          };
          e.StringSchema = t;
        } }), pm = Z({ "node_modules/vnopts/lib/schemas/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(um(), e), n.__exportStar(sm(), e), n.__exportStar(im(), e), n.__exportStar(am(), e), n.__exportStar(om(), e), n.__exportStar(lm(), e), n.__exportStar(Va(), e), n.__exportStar(cm(), e);
        } }), fm = Z({ "node_modules/vnopts/lib/defaults.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Oa(), t = qa(), s = Ma(), a = Ra();
          e.defaultDescriptor = n.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
        } }), Dm = Z({ "node_modules/vnopts/lib/normalize.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = fm(), t = Hn();
          e.normalize = (a, r, u) => new s(r, u).normalize(a);
          var s = class {
            constructor(a, r) {
              let { logger: u = console, descriptor: i = n.defaultDescriptor, unknown: o = n.defaultUnknownHandler, invalid: c = n.defaultInvalidHandler, deprecated: v = n.defaultDeprecatedHandler } = r || {};
              this._utils = { descriptor: i, logger: u || { warn: () => {
              } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = o, this._invalidHandler = c, this._deprecatedHandler = v, this.cleanHistory();
            }
            cleanHistory() {
              this._hasDeprecationWarned = t.createAutoChecklist();
            }
            normalize(a) {
              let r = {}, u = [a], i = () => {
                for (; u.length !== 0; ) {
                  let o = u.shift(), c = this._applyNormalization(o, r);
                  u.push(...c);
                }
              };
              i();
              for (let o of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[o];
                if (!(o in r)) {
                  let v = t.normalizeDefaultResult(c.default(this._utils));
                  "value" in v && u.push({ [o]: v.value });
                }
              }
              i();
              for (let o of Object.keys(this._utils.schemas)) {
                let c = this._utils.schemas[o];
                o in r && (r[o] = c.postprocess(r[o], this._utils));
              }
              return r;
            }
            _applyNormalization(a, r) {
              let u = [], [i, o] = t.partition(Object.keys(a), (c) => c in this._utils.schemas);
              for (let c of i) {
                let v = this._utils.schemas[c], m2 = v.preprocess(a[c], this._utils), d = t.normalizeValidateResult(v.validate(m2, this._utils), m2);
                if (d !== true) {
                  let { value: T } = d, A = this._invalidHandler(c, T, this._utils);
                  throw typeof A == "string" ? new Error(A) : A;
                }
                let p2 = (T) => {
                  let { from: A, to: S } = T;
                  u.push(typeof S == "string" ? { [S]: A } : { [S.key]: S.value });
                }, f = (T) => {
                  let { value: A, redirectTo: S } = T, B = t.normalizeDeprecatedResult(v.deprecated(A, this._utils), m2, true);
                  if (B !== false)
                    if (B === true)
                      this._hasDeprecationWarned(c) || this._utils.logger.warn(this._deprecatedHandler(c, S, this._utils));
                    else
                      for (let { value: I } of B) {
                        let k = { key: c, value: I };
                        if (!this._hasDeprecationWarned(k)) {
                          let P = typeof S == "string" ? { key: S, value: I } : S;
                          this._utils.logger.warn(this._deprecatedHandler(k, P, this._utils));
                        }
                      }
                };
                t.normalizeForwardResult(v.forward(m2, this._utils), m2).forEach(p2);
                let w = t.normalizeRedirectResult(v.redirect(m2, this._utils), m2);
                if (w.redirect.forEach(p2), "remain" in w) {
                  let T = w.remain;
                  r[c] = c in r ? v.overlap(r[c], T, this._utils) : T, f({ value: T });
                }
                for (let { from: T, to: A } of w.redirect)
                  f({ value: T, redirectTo: A });
              }
              for (let c of o) {
                let v = a[c], m2 = this._unknownHandler(c, v, this._utils);
                if (m2)
                  for (let d of Object.keys(m2)) {
                    let p2 = { [d]: m2[d] };
                    d in this._utils.schemas ? u.push(p2) : Object.assign(r, p2);
                  }
              }
              return u;
            }
          };
          e.Normalizer = s;
        } }), mm = Z({ "node_modules/vnopts/lib/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = (ht(), lt(dt));
          n.__exportStar(QD(), e), n.__exportStar(nm(), e), n.__exportStar(pm(), e), n.__exportStar(Dm(), e), n.__exportStar(vt(), e);
        } }), dm = Z({ "src/main/options-normalizer.js"(e, n) {
          "use strict";
          re();
          var t = mm(), s = it(), a = { key: (d) => d.length === 1 ? "-".concat(d) : "--".concat(d), value: (d) => t.apiDescriptor.value(d), pair: (d) => {
            let { key: p2, value: f } = d;
            return f === false ? "--no-".concat(p2) : f === true ? a.key(p2) : f === "" ? "".concat(a.key(p2), " without an argument") : "".concat(a.key(p2), "=").concat(f);
          } }, r = (d) => {
            let { colorsModule: p2, levenshteinDistance: f } = d;
            return class extends t.ChoiceSchema {
              constructor(w) {
                let { name: T, flags: A } = w;
                super({ name: T, choices: A }), this._flags = [...A].sort();
              }
              preprocess(w, T) {
                if (typeof w == "string" && w.length > 0 && !this._flags.includes(w)) {
                  let A = this._flags.find((S) => f(S, w) < 3);
                  if (A)
                    return T.logger.warn(["Unknown flag ".concat(p2.yellow(T.descriptor.value(w)), ","), "did you mean ".concat(p2.blue(T.descriptor.value(A)), "?")].join(" ")), A;
                }
                return w;
              }
              expected() {
                return "a flag";
              }
            };
          }, u;
          function i(d, p2) {
            let { logger: f = false, isCLI: h3 = false, passThrough: w = false, colorsModule: T = null, levenshteinDistance: A = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, S = w ? Array.isArray(w) ? (D, g) => w.includes(D) ? { [D]: g } : void 0 : (D, g) => ({ [D]: g }) : (D, g, F) => {
              let l = F.schemas, { _: E } = l, y = kn(l, Qf);
              return t.levenUnknownHandler(D, g, Object.assign(Object.assign({}, F), {}, { schemas: y }));
            }, B = h3 ? a : t.apiDescriptor, I = o(p2, { isCLI: h3, colorsModule: T, levenshteinDistance: A }), k = new t.Normalizer(I, { logger: f, unknown: S, descriptor: B }), P = f !== false;
            P && u && (k._hasDeprecationWarned = u);
            let C = k.normalize(d);
            return P && (u = k._hasDeprecationWarned), h3 && C["plugin-search"] === false && (C["plugin-search-dir"] = false), C;
          }
          function o(d, p2) {
            let { isCLI: f, colorsModule: h3, levenshteinDistance: w } = p2, T = [];
            f && T.push(t.AnySchema.create({ name: "_" }));
            for (let A of d)
              T.push(c(A, { isCLI: f, optionInfos: d, colorsModule: h3, levenshteinDistance: w })), A.alias && f && T.push(t.AliasSchema.create({ name: A.alias, sourceName: A.name }));
            return T;
          }
          function c(d, p2) {
            let { isCLI: f, optionInfos: h3, colorsModule: w, levenshteinDistance: T } = p2, { name: A } = d;
            if (A === "plugin-search-dir" || A === "pluginSearchDirs")
              return t.AnySchema.create({ name: A, preprocess(k) {
                return k === false || (k = Array.isArray(k) ? k : [k]), k;
              }, validate(k) {
                return k === false ? true : k.every((P) => typeof P == "string");
              }, expected() {
                return "false or paths to plugin search dir";
              } });
            let S = { name: A }, B, I = {};
            switch (d.type) {
              case "int":
                B = t.IntegerSchema, f && (S.preprocess = Number);
                break;
              case "string":
                B = t.StringSchema;
                break;
              case "choice":
                B = t.ChoiceSchema, S.choices = d.choices.map((k) => typeof k == "object" && k.redirect ? Object.assign(Object.assign({}, k), {}, { redirect: { to: { key: d.name, value: k.redirect } } }) : k);
                break;
              case "boolean":
                B = t.BooleanSchema;
                break;
              case "flag":
                B = r({ colorsModule: w, levenshteinDistance: T }), S.flags = h3.flatMap((k) => [k.alias, k.description && k.name, k.oppositeDescription && "no-".concat(k.name)].filter(Boolean));
                break;
              case "path":
                B = t.StringSchema;
                break;
              default:
                throw new Error("Unexpected type ".concat(d.type));
            }
            if (d.exception ? S.validate = (k, P, C) => d.exception(k) || P.validate(k, C) : S.validate = (k, P, C) => k === void 0 || P.validate(k, C), d.redirect && (I.redirect = (k) => k ? { to: { key: d.redirect.option, value: d.redirect.value } } : void 0), d.deprecated && (I.deprecated = true), f && !d.array) {
              let k = S.preprocess || ((P) => P);
              S.preprocess = (P, C, D) => C.preprocess(k(Array.isArray(P) ? s(P) : P), D);
            }
            return d.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (k) => Array.isArray(k) ? k : [k] } : {}), I), {}, { valueSchema: B.create(S) })) : B.create(Object.assign(Object.assign({}, S), I));
          }
          function v(d, p2, f) {
            return i(d, p2, f);
          }
          function m2(d, p2, f) {
            return i(d, p2, Object.assign({ isCLI: true }, f));
          }
          n.exports = { normalizeApiOptions: v, normalizeCliOptions: m2 };
        } }), st = Z({ "src/language-js/loc.js"(e, n) {
          "use strict";
          re();
          var t = Rn();
          function s(o, c) {
            let { ignoreDecorators: v } = c || {};
            if (!v) {
              let m2 = o.declaration && o.declaration.decorators || o.decorators;
              if (t(m2))
                return s(m2[0]);
            }
            return o.range ? o.range[0] : o.start;
          }
          function a(o) {
            return o.range ? o.range[1] : o.end;
          }
          function r(o, c) {
            let v = s(o);
            return Number.isInteger(v) && v === s(c);
          }
          function u(o, c) {
            let v = a(o);
            return Number.isInteger(v) && v === a(c);
          }
          function i(o, c) {
            return r(o, c) && u(o, c);
          }
          n.exports = { locStart: s, locEnd: a, hasSameLocStart: r, hasSameLoc: i };
        } }), gm = Z({ "src/main/load-parser.js"(e, n) {
          re(), n.exports = () => {
          };
        } }), ym = Z({ "scripts/build/shims/babel-highlight.cjs"(e, n) {
          "use strict";
          re();
          var t = _r(), s = { shouldHighlight: () => false, getChalk: () => t };
          n.exports = s;
        } }), hm = Z({ "node_modules/@babel/code-frame/lib/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
          var n = ym(), t = false;
          function s(o) {
            return { gutter: o.grey, marker: o.red.bold, message: o.red.bold };
          }
          var a = /\r\n|[\n\r\u2028\u2029]/;
          function r(o, c, v) {
            let m2 = Object.assign({ column: 0, line: -1 }, o.start), d = Object.assign({}, m2, o.end), { linesAbove: p2 = 2, linesBelow: f = 3 } = v || {}, h3 = m2.line, w = m2.column, T = d.line, A = d.column, S = Math.max(h3 - (p2 + 1), 0), B = Math.min(c.length, T + f);
            h3 === -1 && (S = 0), T === -1 && (B = c.length);
            let I = T - h3, k = {};
            if (I)
              for (let P = 0; P <= I; P++) {
                let C = P + h3;
                if (!w)
                  k[C] = true;
                else if (P === 0) {
                  let D = c[C - 1].length;
                  k[C] = [w, D - w + 1];
                } else if (P === I)
                  k[C] = [0, A];
                else {
                  let D = c[C - P].length;
                  k[C] = [0, D];
                }
              }
            else
              w === A ? w ? k[h3] = [w, 0] : k[h3] = true : k[h3] = [w, A - w];
            return { start: S, end: B, markerLines: k };
          }
          function u(o, c) {
            let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m2 = (v.highlightCode || v.forceColor) && (0, n.shouldHighlight)(v), d = (0, n.getChalk)(v), p2 = s(d), f = (P, C) => m2 ? P(C) : C, h3 = o.split(a), { start: w, end: T, markerLines: A } = r(c, h3, v), S = c.start && typeof c.start.column == "number", B = String(T).length, k = (m2 ? (0, n.default)(o, v) : o).split(a, T).slice(w, T).map((P, C) => {
              let D = w + 1 + C, g = " ".concat(D).slice(-B), F = " ".concat(g, " |"), l = A[D], E = !A[D + 1];
              if (l) {
                let y = "";
                if (Array.isArray(l)) {
                  let N = P.slice(0, Math.max(l[0] - 1, 0)).replace(/[^\t]/g, " "), x = l[1] || 1;
                  y = [`
 `, f(p2.gutter, F.replace(/\d/g, " ")), " ", N, f(p2.marker, "^").repeat(x)].join(""), E && v.message && (y += " " + f(p2.message, v.message));
                }
                return [f(p2.marker, ">"), f(p2.gutter, F), P.length > 0 ? " ".concat(P) : "", y].join("");
              } else
                return " ".concat(f(p2.gutter, F)).concat(P.length > 0 ? " ".concat(P) : "");
            }).join(`
`);
            return v.message && !S && (k = "".concat(" ".repeat(B + 1)).concat(v.message, `
`).concat(k)), m2 ? d.reset(k) : k;
          }
          function i(o, c, v) {
            let m2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!t) {
              t = true;
              let p2 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
              if (Tt.emitWarning)
                Tt.emitWarning(p2, "DeprecationWarning");
              else {
                let f = new Error(p2);
                f.name = "DeprecationWarning", console.warn(new Error(p2));
              }
            }
            return v = Math.max(v, 0), u(o, { start: { column: v, line: c } }, m2);
          }
        } }), Gn = Z({ "src/main/parser.js"(e, n) {
          "use strict";
          re();
          var { ConfigError: t } = zt(), s = st(), a = gm(), { locStart: r, locEnd: u } = s, i = Object.getOwnPropertyNames, o = Object.getOwnPropertyDescriptor;
          function c(d) {
            let p2 = {};
            for (let f of d.plugins)
              if (!!f.parsers)
                for (let h3 of i(f.parsers))
                  Object.defineProperty(p2, h3, o(f.parsers, h3));
            return p2;
          }
          function v(d) {
            let p2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c(d);
            if (typeof d.parser == "function")
              return { parse: d.parser, astFormat: "estree", locStart: r, locEnd: u };
            if (typeof d.parser == "string") {
              if (Object.prototype.hasOwnProperty.call(p2, d.parser))
                return p2[d.parser];
              throw new t(`Couldn't resolve parser "`.concat(d.parser, '". Parsers must be explicitly added to the standalone bundle.'));
            }
          }
          function m2(d, p2) {
            let f = c(p2), h3 = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((T) => [T, { enumerable: true, get() {
              return f[T].parse;
            } }]))), w = v(p2, f);
            try {
              return w.preprocess && (d = w.preprocess(d, p2)), { text: d, ast: w.parse(d, h3, p2) };
            } catch (T) {
              let { loc: A } = T;
              if (A) {
                let { codeFrameColumns: S } = hm();
                throw T.codeFrame = S(d, A, { highlightCode: true }), T.message += `
` + T.codeFrame, T;
              }
              throw T.stack;
            }
          }
          n.exports = { parse: m2, resolveParser: v };
        } }), Wa = Z({ "src/main/options.js"(e, n) {
          "use strict";
          re();
          var t = PD(), { UndefinedParserError: s } = zt(), { getSupportInfo: a } = Mn(), r = dm(), { resolveParser: u } = Gn(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
          function o(m2) {
            let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p2 = Object.assign({}, m2), f = a({ plugins: m2.plugins, showUnreleased: true, showDeprecated: true }).options, h3 = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((B) => B.default !== void 0).map((B) => [B.name, B.default])));
            if (!p2.parser) {
              if (!p2.filepath)
                (d.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), p2.parser = "babel";
              else if (p2.parser = v(p2.filepath, p2.plugins), !p2.parser)
                throw new s("No parser could be inferred for file: ".concat(p2.filepath));
            }
            let w = u(r.normalizeApiOptions(p2, [f.find((B) => B.name === "parser")], { passThrough: true, logger: false }));
            p2.astFormat = w.astFormat, p2.locEnd = w.locEnd, p2.locStart = w.locStart;
            let T = c(p2);
            p2.printer = T.printers[p2.astFormat];
            let A = Object.fromEntries(f.filter((B) => B.pluginDefaults && B.pluginDefaults[T.name] !== void 0).map((B) => [B.name, B.pluginDefaults[T.name]])), S = Object.assign(Object.assign({}, h3), A);
            for (let [B, I] of Object.entries(S))
              (p2[B] === null || p2[B] === void 0) && (p2[B] = I);
            return p2.parser === "json" && (p2.trailingComma = "none"), r.normalizeApiOptions(p2, f, Object.assign({ passThrough: Object.keys(i) }, d));
          }
          function c(m2) {
            let { astFormat: d } = m2;
            if (!d)
              throw new Error("getPlugin() requires astFormat to be set");
            let p2 = m2.plugins.find((f) => f.printers && f.printers[d]);
            if (!p2)
              throw new Error(`Couldn't find plugin for AST format "`.concat(d, '"'));
            return p2;
          }
          function v(m2, d) {
            let p2 = t.basename(m2).toLowerCase(), h3 = a({ plugins: d }).languages.filter((w) => w.since !== null).find((w) => w.extensions && w.extensions.some((T) => p2.endsWith(T)) || w.filenames && w.filenames.some((T) => T.toLowerCase() === p2));
            return h3 && h3.parsers[0];
          }
          n.exports = { normalize: o, hiddenDefaults: i, inferParser: v };
        } }), vm = Z({ "src/main/massage-ast.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r) {
            if (Array.isArray(s))
              return s.map((c) => t(c, a, r)).filter(Boolean);
            if (!s || typeof s != "object")
              return s;
            let u = a.printer.massageAstNode, i;
            u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
            let o = {};
            for (let [c, v] of Object.entries(s))
              !i.has(c) && typeof v != "function" && (o[c] = t(v, a, s));
            if (u) {
              let c = u(s, o, r);
              if (c === null)
                return;
              if (c)
                return c;
            }
            return o;
          }
          n.exports = t;
        } }), Xt = Z({ "scripts/build/shims/assert.cjs"(e, n) {
          "use strict";
          re();
          var t = () => {
          };
          t.ok = t, t.strictEqual = t, n.exports = t;
        } }), et = Z({ "src/main/comments.js"(e, n) {
          "use strict";
          re();
          var t = Xt(), { builders: { line: s, hardline: a, breakParent: r, indent: u, lineSuffix: i, join: o, cursor: c } } = Oe(), { hasNewline: v, skipNewline: m2, skipSpaces: d, isPreviousLineEmpty: p2, addLeadingComment: f, addDanglingComment: h3, addTrailingComment: w } = Ue(), T = /* @__PURE__ */ new WeakMap();
          function A(L, M, j) {
            if (!L)
              return;
            let { printer: $2, locStart: V, locEnd: q } = M;
            if (j) {
              if ($2.canAttachComment && $2.canAttachComment(L)) {
                let H;
                for (H = j.length - 1; H >= 0 && !(V(j[H]) <= V(L) && q(j[H]) <= q(L)); --H)
                  ;
                j.splice(H + 1, 0, L);
                return;
              }
            } else if (T.has(L))
              return T.get(L);
            let Y = $2.getCommentChildNodes && $2.getCommentChildNodes(L, M) || typeof L == "object" && Object.entries(L).filter((H) => {
              let [R] = H;
              return R !== "enclosingNode" && R !== "precedingNode" && R !== "followingNode" && R !== "tokens" && R !== "comments" && R !== "parent";
            }).map((H) => {
              let [, R] = H;
              return R;
            });
            if (!!Y) {
              j || (j = [], T.set(L, j));
              for (let H of Y)
                A(H, M, j);
              return j;
            }
          }
          function S(L, M, j, $2) {
            let { locStart: V, locEnd: q } = j, Y = V(M), H = q(M), R = A(L, j), Q, ee, te = 0, oe = R.length;
            for (; te < oe; ) {
              let W = te + oe >> 1, X = R[W], ue = V(X), De = q(X);
              if (ue <= Y && H <= De)
                return S(X, M, j, X);
              if (De <= Y) {
                Q = X, te = W + 1;
                continue;
              }
              if (H <= ue) {
                ee = X, oe = W;
                continue;
              }
              throw new Error("Comment location overlaps with node location");
            }
            if ($2 && $2.type === "TemplateLiteral") {
              let { quasis: W } = $2, X = F(W, M, j);
              Q && F(W, Q, j) !== X && (Q = null), ee && F(W, ee, j) !== X && (ee = null);
            }
            return { enclosingNode: $2, precedingNode: Q, followingNode: ee };
          }
          var B = () => false;
          function I(L, M, j, $2) {
            if (!Array.isArray(L))
              return;
            let V = [], { locStart: q, locEnd: Y, printer: { handleComments: H = {} } } = $2, { avoidAstMutation: R, ownLine: Q = B, endOfLine: ee = B, remaining: te = B } = H, oe = L.map((W, X) => Object.assign(Object.assign({}, S(M, W, $2)), {}, { comment: W, text: j, options: $2, ast: M, isLastComment: L.length - 1 === X }));
            for (let [W, X] of oe.entries()) {
              let { comment: ue, precedingNode: De, enclosingNode: ie, followingNode: G, text: z, options: U, ast: le, isLastComment: ge } = X;
              if (U.parser === "json" || U.parser === "json5" || U.parser === "__js_expression" || U.parser === "__vue_expression" || U.parser === "__vue_ts_expression") {
                if (q(ue) - q(le) <= 0) {
                  f(le, ue);
                  continue;
                }
                if (Y(ue) - Y(le) >= 0) {
                  w(le, ue);
                  continue;
                }
              }
              let Ae;
              if (R ? Ae = [X] : (ue.enclosingNode = ie, ue.precedingNode = De, ue.followingNode = G, Ae = [ue, z, U, le, ge]), P(z, U, oe, W))
                ue.placement = "ownLine", Q(...Ae) || (G ? f(G, ue) : De ? w(De, ue) : h3(ie || le, ue));
              else if (C(z, U, oe, W))
                ue.placement = "endOfLine", ee(...Ae) || (De ? w(De, ue) : G ? f(G, ue) : h3(ie || le, ue));
              else if (ue.placement = "remaining", !te(...Ae))
                if (De && G) {
                  let Ne = V.length;
                  Ne > 0 && V[Ne - 1].followingNode !== G && D(V, z, U), V.push(X);
                } else
                  De ? w(De, ue) : G ? f(G, ue) : h3(ie || le, ue);
            }
            if (D(V, j, $2), !R)
              for (let W of L)
                delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
          }
          var k = (L) => !/[\S\n\u2028\u2029]/.test(L);
          function P(L, M, j, $2) {
            let { comment: V, precedingNode: q } = j[$2], { locStart: Y, locEnd: H } = M, R = Y(V);
            if (q)
              for (let Q = $2 - 1; Q >= 0; Q--) {
                let { comment: ee, precedingNode: te } = j[Q];
                if (te !== q || !k(L.slice(H(ee), R)))
                  break;
                R = Y(ee);
              }
            return v(L, R, { backwards: true });
          }
          function C(L, M, j, $2) {
            let { comment: V, followingNode: q } = j[$2], { locStart: Y, locEnd: H } = M, R = H(V);
            if (q)
              for (let Q = $2 + 1; Q < j.length; Q++) {
                let { comment: ee, followingNode: te } = j[Q];
                if (te !== q || !k(L.slice(R, Y(ee))))
                  break;
                R = H(ee);
              }
            return v(L, R);
          }
          function D(L, M, j) {
            let $2 = L.length;
            if ($2 === 0)
              return;
            let { precedingNode: V, followingNode: q, enclosingNode: Y } = L[0], H = j.printer.getGapRegex && j.printer.getGapRegex(Y) || /^[\s(]*$/, R = j.locStart(q), Q;
            for (Q = $2; Q > 0; --Q) {
              let { comment: ee, precedingNode: te, followingNode: oe } = L[Q - 1];
              t.strictEqual(te, V), t.strictEqual(oe, q);
              let W = M.slice(j.locEnd(ee), R);
              if (H.test(W))
                R = j.locStart(ee);
              else
                break;
            }
            for (let [ee, { comment: te }] of L.entries())
              ee < Q ? w(V, te) : f(q, te);
            for (let ee of [V, q])
              ee.comments && ee.comments.length > 1 && ee.comments.sort((te, oe) => j.locStart(te) - j.locStart(oe));
            L.length = 0;
          }
          function g(L, M) {
            let j = L.getValue();
            return j.printed = true, M.printer.printComment(L, M);
          }
          function F(L, M, j) {
            let $2 = j.locStart(M) - 1;
            for (let V = 1; V < L.length; ++V)
              if ($2 < j.locStart(L[V]))
                return V - 1;
            return 0;
          }
          function l(L, M) {
            let j = L.getValue(), $2 = [g(L, M)], { printer: V, originalText: q, locStart: Y, locEnd: H } = M;
            if (V.isBlockComment && V.isBlockComment(j)) {
              let ee = v(q, H(j)) ? v(q, Y(j), { backwards: true }) ? a : s : " ";
              $2.push(ee);
            } else
              $2.push(a);
            let Q = m2(q, d(q, H(j)));
            return Q !== false && v(q, Q) && $2.push(a), $2;
          }
          function E(L, M) {
            let j = L.getValue(), $2 = g(L, M), { printer: V, originalText: q, locStart: Y } = M, H = V.isBlockComment && V.isBlockComment(j);
            if (v(q, Y(j), { backwards: true })) {
              let Q = p2(q, j, Y);
              return i([a, Q ? a : "", $2]);
            }
            let R = [" ", $2];
            return H || (R = [i(R), r]), R;
          }
          function y(L, M, j, $2) {
            let V = [], q = L.getValue();
            return !q || !q.comments || (L.each(() => {
              let Y = L.getValue();
              !Y.leading && !Y.trailing && (!$2 || $2(Y)) && V.push(g(L, M));
            }, "comments"), V.length === 0) ? "" : j ? o(a, V) : u([a, o(a, V)]);
          }
          function N(L, M, j) {
            let $2 = L.getValue();
            if (!$2)
              return {};
            let V = $2.comments || [];
            j && (V = V.filter((R) => !j.has(R)));
            let q = $2 === M.cursorNode;
            if (V.length === 0) {
              let R = q ? c : "";
              return { leading: R, trailing: R };
            }
            let Y = [], H = [];
            return L.each(() => {
              let R = L.getValue();
              if (j && j.has(R))
                return;
              let { leading: Q, trailing: ee } = R;
              Q ? Y.push(l(L, M)) : ee && H.push(E(L, M));
            }, "comments"), q && (Y.unshift(c), H.push(c)), { leading: Y, trailing: H };
          }
          function x(L, M, j, $2) {
            let { leading: V, trailing: q } = N(L, j, $2);
            return !V && !q ? M : [V, M, q];
          }
          function b(L) {
            if (!!L)
              for (let M of L) {
                if (!M.printed)
                  throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
                delete M.printed;
              }
          }
          n.exports = { attach: I, printComments: x, printCommentsSeparately: N, printDanglingComments: y, getSortedChildNodes: A, ensureAllCommentsPrinted: b };
        } }), Cm = Z({ "src/common/ast-path.js"(e, n) {
          "use strict";
          re();
          var t = it();
          function s(u, i) {
            let o = a(u.stack, i);
            return o === -1 ? null : u.stack[o];
          }
          function a(u, i) {
            for (let o = u.length - 1; o >= 0; o -= 2) {
              let c = u[o];
              if (c && !Array.isArray(c) && --i < 0)
                return o;
            }
            return -1;
          }
          var r = class {
            constructor(u) {
              this.stack = [u];
            }
            getName() {
              let { stack: u } = this, { length: i } = u;
              return i > 1 ? u[i - 2] : null;
            }
            getValue() {
              return t(this.stack);
            }
            getNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u);
            }
            getParentNode() {
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
              return s(this, u + 1);
            }
            call(u) {
              let { stack: i } = this, { length: o } = i, c = t(i);
              for (var v = arguments.length, m2 = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++)
                m2[d - 1] = arguments[d];
              for (let f of m2)
                c = c[f], i.push(f, c);
              let p2 = u(this);
              return i.length = o, p2;
            }
            callParent(u) {
              let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, o = a(this.stack, i + 1), c = this.stack.splice(o + 1), v = u(this);
              return this.stack.push(...c), v;
            }
            each(u) {
              let { stack: i } = this, { length: o } = i, c = t(i);
              for (var v = arguments.length, m2 = new Array(v > 1 ? v - 1 : 0), d = 1; d < v; d++)
                m2[d - 1] = arguments[d];
              for (let p2 of m2)
                c = c[p2], i.push(p2, c);
              for (let p2 = 0; p2 < c.length; ++p2)
                i.push(p2, c[p2]), u(this, p2, c), i.length -= 2;
              i.length = o;
            }
            map(u) {
              let i = [];
              for (var o = arguments.length, c = new Array(o > 1 ? o - 1 : 0), v = 1; v < o; v++)
                c[v - 1] = arguments[v];
              return this.each((m2, d, p2) => {
                i[d] = u(m2, d, p2);
              }, ...c), i;
            }
            try(u) {
              let { stack: i } = this, o = [...i];
              try {
                return u();
              } finally {
                i.length = 0, i.push(...o);
              }
            }
            match() {
              let u = this.stack.length - 1, i = null, o = this.stack[u--];
              for (var c = arguments.length, v = new Array(c), m2 = 0; m2 < c; m2++)
                v[m2] = arguments[m2];
              for (let d of v) {
                if (o === void 0)
                  return false;
                let p2 = null;
                if (typeof i == "number" && (p2 = i, i = this.stack[u--], o = this.stack[u--]), d && !d(o, i, p2))
                  return false;
                i = this.stack[u--], o = this.stack[u--];
              }
              return true;
            }
            findAncestor(u) {
              let i = this.stack.length - 1, o = null, c = this.stack[i--];
              for (; c; ) {
                let v = null;
                if (typeof o == "number" && (v = o, o = this.stack[i--], c = this.stack[i--]), o !== null && u(c, o, v))
                  return c;
                o = this.stack[i--], c = this.stack[i--];
              }
            }
          };
          n.exports = r;
        } }), Em = Z({ "src/main/multiparser.js"(e, n) {
          "use strict";
          re();
          var { utils: { stripTrailingHardline: t } } = Oe(), { normalize: s } = Wa(), a = et();
          function r(i, o, c, v) {
            if (c.printer.embed && c.embeddedLanguageFormatting === "auto")
              return c.printer.embed(i, o, (m2, d, p2) => u(m2, d, c, v, p2), c);
          }
          function u(i, o, c, v) {
            let { stripTrailingHardline: m2 = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, d = s(Object.assign(Object.assign(Object.assign({}, c), o), {}, { parentParser: c.parser, originalText: i }), { passThrough: true }), p2 = Gn().parse(i, d), { ast: f } = p2;
            i = p2.text;
            let h3 = f.comments;
            delete f.comments, a.attach(h3, f, i, d), d[Symbol.for("comments")] = h3 || [], d[Symbol.for("tokens")] = f.tokens || [];
            let w = v(f, d);
            return a.ensureAllCommentsPrinted(h3), m2 ? typeof w == "string" ? w.replace(/(?:\r?\n)*$/, "") : t(w) : w;
          }
          n.exports = { printSubtree: r };
        } }), Fm = Z({ "src/main/ast-to-doc.js"(e, n) {
          "use strict";
          re();
          var t = Cm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: r } } = Oe(), { printComments: u } = et(), i = Em();
          function o(m2, d) {
            let p2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = d;
            f.preprocess && (m2 = f.preprocess(m2, d));
            let h3 = /* @__PURE__ */ new Map(), w = new t(m2), T = A();
            return p2 > 0 && (T = a([s, T], p2, d.tabWidth)), r(T), T;
            function A(B, I) {
              return B === void 0 || B === w ? S(I) : Array.isArray(B) ? w.call(() => S(I), ...B) : w.call(() => S(I), B);
            }
            function S(B) {
              let I = w.getValue(), k = I && typeof I == "object" && B === void 0;
              if (k && h3.has(I))
                return h3.get(I);
              let P = v(w, d, A, B);
              return k && h3.set(I, P), P;
            }
          }
          function c(m2, d) {
            let { originalText: p2, [Symbol.for("comments")]: f, locStart: h3, locEnd: w } = d, T = h3(m2), A = w(m2), S = /* @__PURE__ */ new Set();
            for (let B of f)
              h3(B) >= T && w(B) <= A && (B.printed = true, S.add(B));
            return { doc: p2.slice(T, A), printedComments: S };
          }
          function v(m2, d, p2, f) {
            let h3 = m2.getValue(), { printer: w } = d, T, A;
            if (w.hasPrettierIgnore && w.hasPrettierIgnore(m2))
              ({ doc: T, printedComments: A } = c(h3, d));
            else {
              if (h3)
                try {
                  T = i.printSubtree(m2, p2, d, o);
                } catch (S) {
                  if (globalThis.PRETTIER_DEBUG)
                    throw S;
                }
              T || (T = w.print(m2, d, p2, f));
            }
            return (!w.willPrintOwnComments || !w.willPrintOwnComments(m2, d)) && (T = u(m2, T, d, A)), T;
          }
          n.exports = o;
        } }), Am = Z({ "src/main/range-util.js"(e, n) {
          "use strict";
          re();
          var t = Xt(), s = et(), a = (f) => {
            let { parser: h3 } = f;
            return h3 === "json" || h3 === "json5" || h3 === "json-stringify";
          };
          function r(f, h3) {
            let w = [f.node, ...f.parentNodes], T = /* @__PURE__ */ new Set([h3.node, ...h3.parentNodes]);
            return w.find((A) => v.has(A.type) && T.has(A));
          }
          function u(f) {
            let h3 = f.length - 1;
            for (; ; ) {
              let w = f[h3];
              if (w && (w.type === "Program" || w.type === "File"))
                h3--;
              else
                break;
            }
            return f.slice(0, h3 + 1);
          }
          function i(f, h3, w) {
            let { locStart: T, locEnd: A } = w, S = f.node, B = h3.node;
            if (S === B)
              return { startNode: S, endNode: B };
            let I = T(f.node);
            for (let P of u(h3.parentNodes))
              if (T(P) >= I)
                B = P;
              else
                break;
            let k = A(h3.node);
            for (let P of u(f.parentNodes))
              if (A(P) <= k)
                S = P;
              else
                break;
            return { startNode: S, endNode: B };
          }
          function o(f, h3, w, T) {
            let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], S = arguments.length > 5 ? arguments[5] : void 0, { locStart: B, locEnd: I } = w, k = B(f), P = I(f);
            if (!(h3 > P || h3 < k || S === "rangeEnd" && h3 === k || S === "rangeStart" && h3 === P)) {
              for (let C of s.getSortedChildNodes(f, w)) {
                let D = o(C, h3, w, T, [f, ...A], S);
                if (D)
                  return D;
              }
              if (!T || T(f, A[0]))
                return { node: f, parentNodes: A };
            }
          }
          function c(f, h3) {
            return h3 !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
          }
          var v = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), m2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
          function d(f, h3, w) {
            if (!h3)
              return false;
            switch (f.parser) {
              case "flow":
              case "babel":
              case "babel-flow":
              case "babel-ts":
              case "typescript":
              case "acorn":
              case "espree":
              case "meriyah":
              case "__babel_estree":
                return c(h3.type, w && w.type);
              case "json":
              case "json5":
              case "json-stringify":
                return v.has(h3.type);
              case "graphql":
                return m2.has(h3.kind);
              case "vue":
                return h3.tag !== "root";
            }
            return false;
          }
          function p2(f, h3, w) {
            let { rangeStart: T, rangeEnd: A, locStart: S, locEnd: B } = h3;
            t.ok(A > T);
            let I = f.slice(T, A).search(/\S/), k = I === -1;
            if (!k)
              for (T += I; A > T && !/\S/.test(f[A - 1]); --A)
                ;
            let P = o(w, T, h3, (F, l) => d(h3, F, l), [], "rangeStart"), C = k ? P : o(w, A, h3, (F) => d(h3, F), [], "rangeEnd");
            if (!P || !C)
              return { rangeStart: 0, rangeEnd: 0 };
            let D, g;
            if (a(h3)) {
              let F = r(P, C);
              D = F, g = F;
            } else
              ({ startNode: D, endNode: g } = i(P, C, h3));
            return { rangeStart: Math.min(S(D), S(g)), rangeEnd: Math.max(B(D), B(g)) };
          }
          n.exports = { calculateRange: p2, findNodeAtOffset: o };
        } }), Sm = Z({ "src/main/core.js"(e, n) {
          "use strict";
          re();
          var { diffArrays: t } = aD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = Oe(), { getAlignmentSize: r } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: o, normalizeEndOfLine: c } = jn(), v = Wa().normalize, m2 = vm(), d = et(), p2 = Gn(), f = Fm(), h3 = Am(), w = "\uFEFF", T = Symbol("cursor");
          function A(g, F, l) {
            let E = F.comments;
            return E && (delete F.comments, d.attach(E, F, g, l)), l[Symbol.for("comments")] = E || [], l[Symbol.for("tokens")] = F.tokens || [], l.originalText = g, E;
          }
          function S(g, F) {
            let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            if (!g || g.trim().length === 0)
              return { formatted: "", cursorOffset: -1, comments: [] };
            let { ast: E, text: y } = p2.parse(g, F);
            if (F.cursorOffset >= 0) {
              let L = h3.findNodeAtOffset(E, F.cursorOffset, F);
              L && L.node && (F.cursorNode = L.node);
            }
            let N = A(y, E, F), x = f(E, F, l), b = s(x, F);
            if (d.ensureAllCommentsPrinted(N), l > 0) {
              let L = b.formatted.trim();
              b.cursorNodeStart !== void 0 && (b.cursorNodeStart -= b.formatted.indexOf(L)), b.formatted = L + i(F.endOfLine);
            }
            if (F.cursorOffset >= 0) {
              let L, M, j, $2, V;
              if (F.cursorNode && b.cursorNodeText ? (L = F.locStart(F.cursorNode), M = y.slice(L, F.locEnd(F.cursorNode)), j = F.cursorOffset - L, $2 = b.cursorNodeStart, V = b.cursorNodeText) : (L = 0, M = y, j = F.cursorOffset, $2 = 0, V = b.formatted), M === V)
                return { formatted: b.formatted, cursorOffset: $2 + j, comments: N };
              let q = [...M];
              q.splice(j, 0, T);
              let Y = [...V], H = t(q, Y), R = $2;
              for (let Q of H)
                if (Q.removed) {
                  if (Q.value.includes(T))
                    break;
                } else
                  R += Q.count;
              return { formatted: b.formatted, cursorOffset: R, comments: N };
            }
            return { formatted: b.formatted, cursorOffset: -1, comments: N };
          }
          function B(g, F) {
            let { ast: l, text: E } = p2.parse(g, F), { rangeStart: y, rangeEnd: N } = h3.calculateRange(E, F, l), x = E.slice(y, N), b = Math.min(y, E.lastIndexOf(`
`, y) + 1), L = E.slice(b, y).match(/^\s*/)[0], M = r(L, F.tabWidth), j = S(x, Object.assign(Object.assign({}, F), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: F.cursorOffset > y && F.cursorOffset <= N ? F.cursorOffset - y : -1, endOfLine: "lf" }), M), $2 = j.formatted.trimEnd(), { cursorOffset: V } = F;
            V > N ? V += $2.length - x.length : j.cursorOffset >= 0 && (V = j.cursorOffset + y);
            let q = E.slice(0, y) + $2 + E.slice(N);
            if (F.endOfLine !== "lf") {
              let Y = i(F.endOfLine);
              V >= 0 && Y === `\r
` && (V += o(q.slice(0, V), `
`)), q = q.replace(/\n/g, Y);
            }
            return { formatted: q, cursorOffset: V, comments: j.comments };
          }
          function I(g, F, l) {
            return typeof F != "number" || Number.isNaN(F) || F < 0 || F > g.length ? l : F;
          }
          function k(g, F) {
            let { cursorOffset: l, rangeStart: E, rangeEnd: y } = F;
            return l = I(g, l, -1), E = I(g, E, 0), y = I(g, y, g.length), Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y });
          }
          function P(g, F) {
            let { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N } = k(g, F), x = g.charAt(0) === w;
            if (x && (g = g.slice(1), l--, E--, y--), N === "auto" && (N = u(g)), g.includes("\r")) {
              let b = (L) => o(g.slice(0, Math.max(L, 0)), `\r
`);
              l -= b(l), E -= b(E), y -= b(y), g = c(g);
            }
            return { hasBOM: x, text: g, options: k(g, Object.assign(Object.assign({}, F), {}, { cursorOffset: l, rangeStart: E, rangeEnd: y, endOfLine: N })) };
          }
          function C(g, F) {
            let l = p2.resolveParser(F);
            return !l.hasPragma || l.hasPragma(g);
          }
          function D(g, F) {
            let { hasBOM: l, text: E, options: y } = P(g, v(F));
            if (y.rangeStart >= y.rangeEnd && E !== "" || y.requirePragma && !C(E, y))
              return { formatted: g, cursorOffset: F.cursorOffset, comments: [] };
            let N;
            return y.rangeStart > 0 || y.rangeEnd < E.length ? N = B(E, y) : (!y.requirePragma && y.insertPragma && y.printer.insertPragma && !C(E, y) && (E = y.printer.insertPragma(E)), N = S(E, y)), l && (N.formatted = w + N.formatted, N.cursorOffset >= 0 && N.cursorOffset++), N;
          }
          n.exports = { formatWithCursor: D, parse(g, F, l) {
            let { text: E, options: y } = P(g, v(F)), N = p2.parse(E, y);
            return l && (N.ast = m2(N.ast, y)), N;
          }, formatAST(g, F) {
            F = v(F);
            let l = f(g, F);
            return s(l, F);
          }, formatDoc(g, F) {
            return D(a(g), Object.assign(Object.assign({}, F), {}, { parser: "__js_expression" })).formatted;
          }, printToDoc(g, F) {
            F = v(F);
            let { ast: l, text: E } = p2.parse(g, F);
            return A(E, l, F), f(l, F);
          }, printDocToString(g, F) {
            return s(g, v(F));
          } };
        } }), xm = Z({ "src/common/util-shared.js"(e, n) {
          "use strict";
          re();
          var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m2, skipInlineComment: d, skipTrailingComment: p2, hasNewline: f, hasNewlineInRange: h3, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: S, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: k, addDanglingComment: P, addTrailingComment: C } = Ue();
          n.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: r, skip: u, skipWhitespace: i, skipSpaces: o, skipNewline: c, skipToLineEnd: v, skipEverythingButNewLine: m2, skipInlineComment: d, skipTrailingComment: p2, hasNewline: f, hasNewlineInRange: h3, hasSpaces: w, isNextLineEmpty: T, isNextLineEmptyAfterIndex: A, isPreviousLineEmpty: S, getNextNonSpaceNonCommentCharacterIndex: B, makeString: I, addLeadingComment: k, addDanglingComment: P, addTrailingComment: C };
        } }), Bt = Z({ "src/utils/create-language.js"(e, n) {
          "use strict";
          re(), n.exports = function(t, s) {
            let { languageId: a } = t, r = kn(t, Zf);
            return Object.assign(Object.assign({ linguistLanguageId: a }, r), s(t));
          };
        } }), bm = Z({ "node_modules/esutils/lib/ast.js"(e, n) {
          re(), function() {
            "use strict";
            function t(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "ArrayExpression":
                case "AssignmentExpression":
                case "BinaryExpression":
                case "CallExpression":
                case "ConditionalExpression":
                case "FunctionExpression":
                case "Identifier":
                case "Literal":
                case "LogicalExpression":
                case "MemberExpression":
                case "NewExpression":
                case "ObjectExpression":
                case "SequenceExpression":
                case "ThisExpression":
                case "UnaryExpression":
                case "UpdateExpression":
                  return true;
              }
              return false;
            }
            function s(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForStatement":
                case "WhileStatement":
                  return true;
              }
              return false;
            }
            function a(o) {
              if (o == null)
                return false;
              switch (o.type) {
                case "BlockStatement":
                case "BreakStatement":
                case "ContinueStatement":
                case "DebuggerStatement":
                case "DoWhileStatement":
                case "EmptyStatement":
                case "ExpressionStatement":
                case "ForInStatement":
                case "ForStatement":
                case "IfStatement":
                case "LabeledStatement":
                case "ReturnStatement":
                case "SwitchStatement":
                case "ThrowStatement":
                case "TryStatement":
                case "VariableDeclaration":
                case "WhileStatement":
                case "WithStatement":
                  return true;
              }
              return false;
            }
            function r(o) {
              return a(o) || o != null && o.type === "FunctionDeclaration";
            }
            function u(o) {
              switch (o.type) {
                case "IfStatement":
                  return o.alternate != null ? o.alternate : o.consequent;
                case "LabeledStatement":
                case "ForStatement":
                case "ForInStatement":
                case "WhileStatement":
                case "WithStatement":
                  return o.body;
              }
              return null;
            }
            function i(o) {
              var c;
              if (o.type !== "IfStatement" || o.alternate == null)
                return false;
              c = o.consequent;
              do {
                if (c.type === "IfStatement" && c.alternate == null)
                  return true;
                c = u(c);
              } while (c);
              return false;
            }
            n.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: r, isProblematicIfStatement: i, trailingStatement: u };
          }();
        } }), $a = Z({ "node_modules/esutils/lib/code.js"(e, n) {
          re(), function() {
            "use strict";
            var t, s, a, r, u, i;
            s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
            function o(A) {
              return 48 <= A && A <= 57;
            }
            function c(A) {
              return 48 <= A && A <= 57 || 97 <= A && A <= 102 || 65 <= A && A <= 70;
            }
            function v(A) {
              return A >= 48 && A <= 55;
            }
            a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
            function m2(A) {
              return A === 32 || A === 9 || A === 11 || A === 12 || A === 160 || A >= 5760 && a.indexOf(A) >= 0;
            }
            function d(A) {
              return A === 10 || A === 13 || A === 8232 || A === 8233;
            }
            function p2(A) {
              if (A <= 65535)
                return String.fromCharCode(A);
              var S = String.fromCharCode(Math.floor((A - 65536) / 1024) + 55296), B = String.fromCharCode((A - 65536) % 1024 + 56320);
              return S + B;
            }
            for (r = new Array(128), i = 0; i < 128; ++i)
              r[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
            for (u = new Array(128), i = 0; i < 128; ++i)
              u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
            function f(A) {
              return A < 128 ? r[A] : s.NonAsciiIdentifierStart.test(p2(A));
            }
            function h3(A) {
              return A < 128 ? u[A] : s.NonAsciiIdentifierPart.test(p2(A));
            }
            function w(A) {
              return A < 128 ? r[A] : t.NonAsciiIdentifierStart.test(p2(A));
            }
            function T(A) {
              return A < 128 ? u[A] : t.NonAsciiIdentifierPart.test(p2(A));
            }
            n.exports = { isDecimalDigit: o, isHexDigit: c, isOctalDigit: v, isWhiteSpace: m2, isLineTerminator: d, isIdentifierStartES5: f, isIdentifierPartES5: h3, isIdentifierStartES6: w, isIdentifierPartES6: T };
          }();
        } }), Tm = Z({ "node_modules/esutils/lib/keyword.js"(e, n) {
          re(), function() {
            "use strict";
            var t = $a();
            function s(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "let":
                  return true;
                default:
                  return false;
              }
            }
            function a(f, h3) {
              return !h3 && f === "yield" ? false : r(f, h3);
            }
            function r(f, h3) {
              if (h3 && s(f))
                return true;
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return false;
              }
            }
            function u(f, h3) {
              return f === "null" || f === "true" || f === "false" || a(f, h3);
            }
            function i(f, h3) {
              return f === "null" || f === "true" || f === "false" || r(f, h3);
            }
            function o(f) {
              return f === "eval" || f === "arguments";
            }
            function c(f) {
              var h3, w, T;
              if (f.length === 0 || (T = f.charCodeAt(0), !t.isIdentifierStartES5(T)))
                return false;
              for (h3 = 1, w = f.length; h3 < w; ++h3)
                if (T = f.charCodeAt(h3), !t.isIdentifierPartES5(T))
                  return false;
              return true;
            }
            function v(f, h3) {
              return (f - 55296) * 1024 + (h3 - 56320) + 65536;
            }
            function m2(f) {
              var h3, w, T, A, S;
              if (f.length === 0)
                return false;
              for (S = t.isIdentifierStartES6, h3 = 0, w = f.length; h3 < w; ++h3) {
                if (T = f.charCodeAt(h3), 55296 <= T && T <= 56319) {
                  if (++h3, h3 >= w || (A = f.charCodeAt(h3), !(56320 <= A && A <= 57343)))
                    return false;
                  T = v(T, A);
                }
                if (!S(T))
                  return false;
                S = t.isIdentifierPartES6;
              }
              return true;
            }
            function d(f, h3) {
              return c(f) && !u(f, h3);
            }
            function p2(f, h3) {
              return m2(f) && !i(f, h3);
            }
            n.exports = { isKeywordES5: a, isKeywordES6: r, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: o, isIdentifierNameES5: c, isIdentifierNameES6: m2, isIdentifierES5: d, isIdentifierES6: p2 };
          }();
        } }), Bm = Z({ "node_modules/esutils/lib/utils.js"(e) {
          re(), function() {
            "use strict";
            e.ast = bm(), e.code = $a(), e.keyword = Tm();
          }();
        } }), It = Z({ "src/language-js/utils/is-block-comment.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
          n.exports = s;
        } }), Nm = Z({ "src/language-js/utils/is-node-matches.js"(e, n) {
          "use strict";
          re();
          function t(a, r) {
            let u = r.split(".");
            for (let i = u.length - 1; i >= 0; i--) {
              let o = u[i];
              if (i === 0)
                return a.type === "Identifier" && a.name === o;
              if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== o)
                return false;
              a = a.object;
            }
          }
          function s(a, r) {
            return r.some((u) => t(a, u));
          }
          n.exports = s;
        } }), Ke = Z({ "src/language-js/utils/index.js"(e, n) {
          "use strict";
          re();
          var t = Bm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: r, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: o } = Ue(), { locStart: c, locEnd: v, hasSameLocStart: m2 } = st(), d = It(), p2 = Nm(), f = "(?:(?=.)\\s)", h3 = new RegExp("^".concat(f, "*:")), w = new RegExp("^".concat(f, "*::"));
          function T(O) {
            var fe, Te;
            return ((fe = O.extra) === null || fe === void 0 ? void 0 : fe.parenthesized) && d((Te = O.trailingComments) === null || Te === void 0 ? void 0 : Te[0]) && h3.test(O.trailingComments[0].value);
          }
          function A(O) {
            let fe = O == null ? void 0 : O[0];
            return d(fe) && w.test(fe.value);
          }
          function S(O, fe) {
            if (!O || typeof O != "object")
              return false;
            if (Array.isArray(O))
              return O.some(($e) => S($e, fe));
            let Te = fe(O);
            return typeof Te == "boolean" ? Te : Object.values(O).some(($e) => S($e, fe));
          }
          function B(O) {
            return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || ue(O) || De(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || O.type === "TSAsExpression" || O.type === "TSNonNullExpression";
          }
          function I(O) {
            var fe, Te, $e, Je, Ze, ut;
            return O.expressions ? O.expressions[0] : (fe = (Te = ($e = (Je = (Ze = (ut = O.left) !== null && ut !== void 0 ? ut : O.test) !== null && Ze !== void 0 ? Ze : O.callee) !== null && Je !== void 0 ? Je : O.object) !== null && $e !== void 0 ? $e : O.tag) !== null && Te !== void 0 ? Te : O.argument) !== null && fe !== void 0 ? fe : O.expression;
          }
          function k(O, fe) {
            if (fe.expressions)
              return ["expressions", 0];
            if (fe.left)
              return ["left"];
            if (fe.test)
              return ["test"];
            if (fe.object)
              return ["object"];
            if (fe.callee)
              return ["callee"];
            if (fe.tag)
              return ["tag"];
            if (fe.argument)
              return ["argument"];
            if (fe.expression)
              return ["expression"];
            throw new Error("Unexpected node has no left side.");
          }
          function P(O) {
            return O = new Set(O), (fe) => O.has(fe == null ? void 0 : fe.type);
          }
          var C = P(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), D = P(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
          function g(O) {
            let fe = O.getParentNode();
            return O.getName() === "declaration" && D(fe) ? fe : null;
          }
          var F = P(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
          function l(O) {
            return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
          }
          function E(O) {
            return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && l(O.argument);
          }
          function y(O) {
            return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
          }
          var N = P(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), x = P(["FunctionExpression", "ArrowFunctionExpression"]);
          function b(O) {
            return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
          }
          function L(O) {
            return ue(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
          }
          var M = P(["JSXElement", "JSXFragment"]);
          function j(O, fe) {
            if (O.parentParser !== "markdown" && O.parentParser !== "mdx")
              return false;
            let Te = fe.getNode();
            if (!Te.expression || !M(Te.expression))
              return false;
            let $e = fe.getParentNode();
            return $e.type === "Program" && $e.body.length === 1;
          }
          function $2(O) {
            return O.kind === "get" || O.kind === "set";
          }
          function V(O) {
            return $2(O) || m2(O, O.value);
          }
          function q(O) {
            return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !V(O);
          }
          function Y(O) {
            return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !m2(O, O.typeAnnotation);
          }
          var H = P(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
          function R(O) {
            return De(O) || O.type === "BindExpression" && Boolean(O.object);
          }
          var Q = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
          function ee(O) {
            return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Q.has(O.type)) : false;
          }
          function te(O) {
            let fe = /^(?:before|after)(?:Each|All)$/;
            return O.callee.type === "Identifier" && fe.test(O.callee.name) && O.arguments.length === 1;
          }
          var oe = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
          function W(O) {
            return p2(O, oe);
          }
          function X(O, fe) {
            if (O.type !== "CallExpression")
              return false;
            if (O.arguments.length === 1) {
              if (L(O) && fe && X(fe))
                return x(O.arguments[0]);
              if (te(O))
                return L(O.arguments[0]);
            } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || y(O.arguments[0])) && W(O.callee))
              return O.arguments[2] && !l(O.arguments[2]) ? false : (O.arguments.length === 2 ? x(O.arguments[1]) : b(O.arguments[1]) && Se(O.arguments[1]).length <= 1) || L(O.arguments[1]);
            return false;
          }
          var ue = P(["CallExpression", "OptionalCallExpression"]), De = P(["MemberExpression", "OptionalMemberExpression"]);
          function ie(O) {
            let fe = "expressions";
            O.type === "TSTemplateLiteralType" && (fe = "types");
            let Te = O[fe];
            return Te.length === 0 ? false : Te.every(($e) => {
              if (se($e))
                return false;
              if ($e.type === "Identifier" || $e.type === "ThisExpression")
                return true;
              if (De($e)) {
                let Je = $e;
                for (; De(Je); )
                  if (Je.property.type !== "Identifier" && Je.property.type !== "Literal" && Je.property.type !== "StringLiteral" && Je.property.type !== "NumericLiteral" || (Je = Je.object, se(Je)))
                    return false;
                return Je.type === "Identifier" || Je.type === "ThisExpression";
              }
              return false;
            });
          }
          function G(O, fe) {
            return O === "+" || O === "-" ? O + fe : fe;
          }
          function z(O, fe) {
            let Te = c(fe), $e = r(O, v(fe));
            return $e !== false && O.slice(Te, Te + 2) === "/*" && O.slice($e, $e + 2) === "*/";
          }
          function U(O, fe) {
            return M(fe) ? Re(fe) : se(fe, Le.Leading, (Te) => a(O, v(Te)));
          }
          function le(O, fe) {
            return fe.parser !== "json" && y(O.key) && ve(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(fe.parser === "babel-ts" && O.type === "ClassProperty" || fe.parser === "typescript" && O.type === "PropertyDefinition") || ge(O.key.value) && String(Number(O.key.value)) === O.key.value && (fe.parser === "babel" || fe.parser === "acorn" || fe.parser === "espree" || fe.parser === "meriyah" || fe.parser === "__babel_estree"));
          }
          function ge(O) {
            return /^(?:\d+|\d+\.\d+)$/.test(O);
          }
          function Ae(O, fe) {
            let Te = /^[fx]?(?:describe|it|test)$/;
            return fe.type === "TaggedTemplateExpression" && fe.quasi === O && fe.tag.type === "MemberExpression" && fe.tag.property.type === "Identifier" && fe.tag.property.name === "each" && (fe.tag.object.type === "Identifier" && Te.test(fe.tag.object.name) || fe.tag.object.type === "MemberExpression" && fe.tag.object.property.type === "Identifier" && (fe.tag.object.property.name === "only" || fe.tag.object.property.name === "skip") && fe.tag.object.object.type === "Identifier" && Te.test(fe.tag.object.object.name));
          }
          function Ne(O) {
            return O.quasis.some((fe) => fe.value.raw.includes(`
`));
          }
          function ke(O, fe) {
            return (O.type === "TemplateLiteral" && Ne(O) || O.type === "TaggedTemplateExpression" && Ne(O.quasi)) && !a(fe, c(O), { backwards: true });
          }
          function ce(O) {
            if (!se(O))
              return false;
            let fe = s(He(O, Le.Dangling));
            return fe && !d(fe);
          }
          function pe(O) {
            if (O.length <= 1)
              return false;
            let fe = 0;
            for (let Te of O)
              if (x(Te)) {
                if (fe += 1, fe > 1)
                  return true;
              } else if (ue(Te)) {
                for (let $e of Te.arguments)
                  if (x($e))
                    return true;
              }
            return false;
          }
          function de(O) {
            let fe = O.getValue(), Te = O.getParentNode();
            return ue(fe) && ue(Te) && Te.callee === fe && fe.arguments.length > Te.arguments.length && Te.arguments.length > 0;
          }
          function ae(O, fe) {
            if (fe >= 2)
              return false;
            let Te = (Je) => ae(Je, fe + 1), $e = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
            return $e && o($e) > 5 ? false : O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import" ? true : O.type === "TemplateLiteral" ? O.quasis.every((Je) => !Je.value.raw.includes(`
`)) && O.expressions.every(Te) : O.type === "ObjectExpression" ? O.properties.every((Je) => !Je.computed && (Je.shorthand || Je.value && Te(Je.value))) : O.type === "ArrayExpression" ? O.elements.every((Je) => Je === null || Te(Je)) : ze(O) ? (O.type === "ImportExpression" || ae(O.callee, fe)) && Xe(O).every(Te) : De(O) ? ae(O.object, fe) && ae(O.property, fe) : O.type === "UnaryExpression" && (O.operator === "!" || O.operator === "-") ? ae(O.argument, fe) : O.type === "TSNonNullExpression" ? ae(O.expression, fe) : false;
          }
          function ve(O) {
            var fe, Te;
            return (fe = (Te = O.extra) === null || Te === void 0 ? void 0 : Te.raw) !== null && fe !== void 0 ? fe : O.raw;
          }
          function K(O) {
            return O;
          }
          function he(O) {
            return O.filepath && /\.tsx$/i.test(O.filepath);
          }
          function ye(O) {
            let fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
            return O.trailingComma === "es5" && fe === "es5" || O.trailingComma === "all" && (fe === "all" || fe === "es5");
          }
          function Ce(O, fe) {
            switch (O = Ee(O), O.type) {
              case "FunctionExpression":
              case "ClassExpression":
              case "DoExpression":
                return fe;
              case "ObjectExpression":
                return true;
              case "MemberExpression":
              case "OptionalMemberExpression":
                return Ce(O.object, fe);
              case "TaggedTemplateExpression":
                return O.tag.type === "FunctionExpression" ? false : Ce(O.tag, fe);
              case "CallExpression":
              case "OptionalCallExpression":
                return O.callee.type === "FunctionExpression" ? false : Ce(O.callee, fe);
              case "ConditionalExpression":
                return Ce(O.test, fe);
              case "UpdateExpression":
                return !O.prefix && Ce(O.argument, fe);
              case "BindExpression":
                return O.object && Ce(O.object, fe);
              case "SequenceExpression":
                return Ce(O.expressions[0], fe);
              case "TSAsExpression":
              case "TSNonNullExpression":
                return Ce(O.expression, fe);
              default:
                return false;
            }
          }
          var Ie = { "==": true, "!=": true, "===": true, "!==": true }, Fe = { "*": true, "/": true, "%": true }, me = { ">>": true, ">>>": true, "<<": true };
          function _(O, fe) {
            return !(ne(fe) !== ne(O) || O === "**" || Ie[O] && Ie[fe] || fe === "%" && Fe[O] || O === "%" && Fe[fe] || fe !== O && Fe[fe] && Fe[O] || me[O] && me[fe]);
          }
          var J = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, fe) => O.map((Te) => [Te, fe])));
          function ne(O) {
            return J.get(O);
          }
          function Ee(O) {
            for (; O.left; )
              O = O.left;
            return O;
          }
          function We(O) {
            return Boolean(me[O]) || O === "|" || O === "^" || O === "&";
          }
          function Be(O) {
            var fe;
            if (O.rest)
              return true;
            let Te = Se(O);
            return ((fe = s(Te)) === null || fe === void 0 ? void 0 : fe.type) === "RestElement";
          }
          var Pe = /* @__PURE__ */ new WeakMap();
          function Se(O) {
            if (Pe.has(O))
              return Pe.get(O);
            let fe = [];
            return O.this && fe.push(O.this), Array.isArray(O.parameters) ? fe.push(...O.parameters) : Array.isArray(O.params) && fe.push(...O.params), O.rest && fe.push(O.rest), Pe.set(O, fe), fe;
          }
          function Qe(O, fe) {
            let Te = O.getValue(), $e = 0, Je = (Ze) => fe(Ze, $e++);
            Te.this && O.call(Je, "this"), Array.isArray(Te.parameters) ? O.each(Je, "parameters") : Array.isArray(Te.params) && O.each(Je, "params"), Te.rest && O.call(Je, "rest");
          }
          var xe = /* @__PURE__ */ new WeakMap();
          function Xe(O) {
            if (xe.has(O))
              return xe.get(O);
            let fe = O.arguments;
            return O.type === "ImportExpression" && (fe = [O.source], O.attributes && fe.push(O.attributes)), xe.set(O, fe), fe;
          }
          function _e(O, fe) {
            let Te = O.getValue();
            Te.type === "ImportExpression" ? (O.call(($e) => fe($e, 0), "source"), Te.attributes && O.call(($e) => fe($e, 1), "attributes")) : O.each(fe, "arguments");
          }
          function je(O) {
            return O.value.trim() === "prettier-ignore" && !O.unignore;
          }
          function Re(O) {
            return O && (O.prettierIgnore || se(O, Le.PrettierIgnore));
          }
          function be(O) {
            let fe = O.getValue();
            return Re(fe);
          }
          var Le = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, qe = (O, fe) => {
            if (typeof O == "function" && (fe = O, O = 0), O || fe)
              return (Te, $e, Je) => !(O & Le.Leading && !Te.leading || O & Le.Trailing && !Te.trailing || O & Le.Dangling && (Te.leading || Te.trailing) || O & Le.Block && !d(Te) || O & Le.Line && !C(Te) || O & Le.First && $e !== 0 || O & Le.Last && $e !== Je.length - 1 || O & Le.PrettierIgnore && !je(Te) || fe && !fe(Te));
          };
          function se(O, fe, Te) {
            if (!u(O == null ? void 0 : O.comments))
              return false;
            let $e = qe(fe, Te);
            return $e ? O.comments.some($e) : true;
          }
          function He(O, fe, Te) {
            if (!Array.isArray(O == null ? void 0 : O.comments))
              return [];
            let $e = qe(fe, Te);
            return $e ? O.comments.filter($e) : O.comments;
          }
          var Me = (O, fe) => {
            let { originalText: Te } = fe;
            return i(Te, v(O));
          };
          function ze(O) {
            return ue(O) || O.type === "NewExpression" || O.type === "ImportExpression";
          }
          function nt(O) {
            return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
          }
          function tt(O) {
            return Boolean(O.__isUsingHackPipeline);
          }
          var pt = Symbol("ifWithoutBlockAndSameLineComment");
          n.exports = { getFunctionParameters: Se, iterateFunctionParametersPath: Qe, getCallArguments: Xe, iterateCallArgumentsPath: _e, hasRestParameter: Be, getLeftSide: I, getLeftSidePathName: k, getParentExportDeclaration: g, getTypeScriptMappedTypeModifier: G, hasFlowAnnotationComment: A, hasFlowShorthandAnnotationComment: T, hasLeadingOwnLineComment: U, hasNakedLeftSide: B, hasNode: S, hasIgnoreComment: be, hasNodeIgnoreComment: Re, identity: K, isBinaryish: H, isCallLikeExpression: ze, isEnabledHackPipeline: tt, isLineComment: C, isPrettierIgnoreComment: je, isCallExpression: ue, isMemberExpression: De, isExportDeclaration: D, isFlowAnnotationComment: z, isFunctionCompositionArgs: pe, isFunctionNotation: V, isFunctionOrArrowExpression: x, isGetterOrSetter: $2, isJestEachTemplateLiteral: Ae, isJsxNode: M, isLiteral: F, isLongCurriedCallExpression: de, isSimpleCallArgument: ae, isMemberish: R, isNumericLiteral: l, isSignedNumericLiteral: E, isObjectProperty: nt, isObjectType: N, isObjectTypePropertyAFunction: q, isSimpleType: ee, isSimpleNumber: ge, isSimpleTemplateLiteral: ie, isStringLiteral: y, isStringPropSafeToUnquote: le, isTemplateOnItsOwnLine: ke, isTestCall: X, isTheOnlyJsxElementInMarkdown: j, isTSXFile: he, isTypeAnnotationAFunction: Y, isNextLineEmpty: Me, needsHardlineAfterDanglingComment: ce, rawText: ve, shouldPrintComma: ye, isBitwiseOperator: We, shouldFlatten: _, startsWithNoLookaheadToken: Ce, getPrecedence: ne, hasComment: se, getComments: He, CommentCheckFlags: Le, markerForIfWithoutBlockAndSameLineComment: pt };
        } }), Lt = Z({ "src/language-js/print/template-literal.js"(e, n) {
          "use strict";
          re();
          var t = it(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: r, hardline: u, softline: i, group: o, indent: c, align: v, lineSuffixBoundary: m2, addAlignmentToDoc: d }, printer: { printDocToString: p2 }, utils: { mapDoc: f } } = Oe(), { isBinaryish: h3, isJestEachTemplateLiteral: w, isSimpleTemplateLiteral: T, hasComment: A, isMemberExpression: S } = Ke();
          function B(g, F, l) {
            let E = g.getValue();
            if (E.type === "TemplateLiteral" && w(E, g.getParentNode())) {
              let M = I(g, l, F);
              if (M)
                return M;
            }
            let N = "expressions";
            E.type === "TSTemplateLiteralType" && (N = "types");
            let x = [], b = g.map(F, N), L = T(E);
            return L && (b = b.map((M) => p2(M, Object.assign(Object.assign({}, l), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), x.push(m2, "`"), g.each((M) => {
              let j = M.getName();
              if (x.push(F()), j < b.length) {
                let { tabWidth: $2 } = l, V = M.getValue(), q = a(V.value.raw, $2), Y = b[j];
                if (!L) {
                  let R = E[N][j];
                  (A(R) || S(R) || R.type === "ConditionalExpression" || R.type === "SequenceExpression" || R.type === "TSAsExpression" || h3(R)) && (Y = [c([i, Y]), i]);
                }
                let H = q === 0 && V.value.raw.endsWith(`
`) ? v(Number.NEGATIVE_INFINITY, Y) : d(Y, q, $2);
                x.push(o(["${", H, m2, "}"]));
              }
            }, "quasis"), x.push("`"), x;
          }
          function I(g, F, l) {
            let E = g.getNode(), y = E.quasis[0].value.raw.trim().split(/\s*\|\s*/);
            if (y.length > 1 || y.some((N) => N.length > 0)) {
              F.__inJestEach = true;
              let N = g.map(l, "expressions");
              F.__inJestEach = false;
              let x = [], b = N.map((V) => "${" + p2(V, Object.assign(Object.assign({}, F), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), L = [{ hasLineBreak: false, cells: [] }];
              for (let V = 1; V < E.quasis.length; V++) {
                let q = t(L), Y = b[V - 1];
                q.cells.push(Y), Y.includes(`
`) && (q.hasLineBreak = true), E.quasis[V].value.raw.includes(`
`) && L.push({ hasLineBreak: false, cells: [] });
              }
              let M = Math.max(y.length, ...L.map((V) => V.cells.length)), j = Array.from({ length: M }).fill(0), $2 = [{ cells: y }, ...L.filter((V) => V.cells.length > 0)];
              for (let { cells: V } of $2.filter((q) => !q.hasLineBreak))
                for (let [q, Y] of V.entries())
                  j[q] = Math.max(j[q], s(Y));
              return x.push(m2, "`", c([u, r(u, $2.map((V) => r(" | ", V.cells.map((q, Y) => V.hasLineBreak ? q : q + " ".repeat(j[Y] - s(q))))))]), u, "`"), x;
            }
          }
          function k(g, F) {
            let l = g.getValue(), E = F();
            return A(l) && (E = o([c([i, E]), i])), ["${", E, m2, "}"];
          }
          function P(g, F) {
            return g.map((l) => k(l, F), "expressions");
          }
          function C(g, F) {
            return f(g, (l) => typeof l == "string" ? F ? l.replace(/(\\*)`/g, "$1$1\\`") : D(l) : l);
          }
          function D(g) {
            return g.replace(/([\\`]|\${)/g, "\\$1");
          }
          n.exports = { printTemplateLiteral: B, printTemplateExpressions: P, escapeTemplateCharacters: C, uncookTemplateElementValue: D };
        } }), wm = Z({ "src/language-js/embed/markdown.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: r } } = Oe(), { escapeTemplateCharacters: u } = Lt();
          function i(c, v, m2) {
            let p2 = c.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (T, A) => "\\".repeat(A.length / 2) + "`"), f = o(p2), h3 = f !== "";
            h3 && (p2 = p2.replace(new RegExp("^".concat(f), "gm"), ""));
            let w = u(m2(p2, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
            return ["`", h3 ? t([s, w]) : [a, r(w)], s, "`"];
          }
          function o(c) {
            let v = c.match(/^([^\S\n]*)\S/m);
            return v === null ? "" : v[1];
          }
          n.exports = i;
        } }), _m = Z({ "src/language-js/embed/css.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: r }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: o } } = Oe(), { printTemplateExpressions: c } = Lt();
          function v(p2, f, h3) {
            let w = p2.getValue(), T = w.quasis.map((k) => k.value.raw), A = 0, S = T.reduce((k, P, C) => C === 0 ? P : k + "@prettier-placeholder-" + A++ + "-id" + P, ""), B = h3(S, { parser: "scss" }, { stripTrailingHardline: true }), I = c(p2, f);
            return m2(B, w, I);
          }
          function m2(p2, f, h3) {
            if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim())
              return "``";
            let T = d(p2, h3);
            if (!T)
              throw new Error("Couldn't insert all the expressions");
            return ["`", s([a, T]), r, "`"];
          }
          function d(p2, f) {
            if (!t(f))
              return p2;
            let h3 = 0, w = u(o(p2), (T) => typeof T != "string" || !T.includes("@prettier-placeholder") ? T : T.split(/@prettier-placeholder-(\d+)-id/).map((A, S) => S % 2 === 0 ? i(A) : (h3++, f[A])));
            return f.length === h3 ? w : null;
          }
          n.exports = v;
        } }), Pm = Z({ "src/language-js/embed/graphql.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, join: s, hardline: a } } = Oe(), { escapeTemplateCharacters: r, printTemplateExpressions: u } = Lt();
          function i(c, v, m2) {
            let d = c.getValue(), p2 = d.quasis.length;
            if (p2 === 1 && d.quasis[0].value.raw.trim() === "")
              return "``";
            let f = u(c, v), h3 = [];
            for (let w = 0; w < p2; w++) {
              let T = d.quasis[w], A = w === 0, S = w === p2 - 1, B = T.value.cooked, I = B.split(`
`), k = I.length, P = f[w], C = k > 2 && I[0].trim() === "" && I[1].trim() === "", D = k > 2 && I[k - 1].trim() === "" && I[k - 2].trim() === "", g = I.every((l) => /^\s*(?:#[^\n\r]*)?$/.test(l));
              if (!S && /#[^\n\r]*$/.test(I[k - 1]))
                return null;
              let F = null;
              g ? F = o(I) : F = m2(B, { parser: "graphql" }, { stripTrailingHardline: true }), F ? (F = r(F, false), !A && C && h3.push(""), h3.push(F), !S && D && h3.push("")) : !A && !S && C && h3.push(""), P && h3.push(P);
            }
            return ["`", t([a, s(a, h3)]), a, "`"];
          }
          function o(c) {
            let v = [], m2 = false, d = c.map((p2) => p2.trim());
            for (let [p2, f] of d.entries())
              f !== "" && (d[p2 - 1] === "" && m2 ? v.push([a, f]) : v.push(f), m2 = true);
            return v.length === 0 ? null : s(a, v);
          }
          n.exports = i;
        } }), km = Z({ "src/language-js/embed/html.js"(e, n) {
          "use strict";
          re();
          var { builders: { indent: t, line: s, hardline: a, group: r }, utils: { mapDoc: u } } = Oe(), { printTemplateExpressions: i, uncookTemplateElementValue: o } = Lt(), c = 0;
          function v(m2, d, p2, f, h3) {
            let { parser: w } = h3, T = m2.getValue(), A = c;
            c = c + 1 >>> 0;
            let S = (E) => "PRETTIER_HTML_PLACEHOLDER_".concat(E, "_").concat(A, "_IN_JS"), B = T.quasis.map((E, y, N) => y === N.length - 1 ? E.value.cooked : E.value.cooked + S(y)).join(""), I = i(m2, d);
            if (I.length === 0 && B.trim().length === 0)
              return "``";
            let k = new RegExp(S("(\\d+)"), "g"), P = 0, C = p2(B, { parser: w, __onHtmlRoot(E) {
              P = E.children.length;
            } }, { stripTrailingHardline: true }), D = u(C, (E) => {
              if (typeof E != "string")
                return E;
              let y = [], N = E.split(k);
              for (let x = 0; x < N.length; x++) {
                let b = N[x];
                if (x % 2 === 0) {
                  b && (b = o(b), f.__embeddedInHtml && (b = b.replace(/<\/(script)\b/gi, "<\\/$1")), y.push(b));
                  continue;
                }
                let L = Number(b);
                y.push(I[L]);
              }
              return y;
            }), g = /^\s/.test(B) ? " " : "", F = /\s$/.test(B) ? " " : "", l = f.htmlWhitespaceSensitivity === "ignore" ? a : g && F ? s : null;
            return r(l ? ["`", t([l, r(D)]), l, "`"] : ["`", g, P > 1 ? t(r(D)) : r(D), F, "`"]);
          }
          n.exports = v;
        } }), Im = Z({ "src/language-js/embed.js"(e, n) {
          "use strict";
          re();
          var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), r = wm(), u = _m(), i = Pm(), o = km();
          function c(C) {
            if (d(C) || w(C) || T(C) || p2(C))
              return "css";
            if (B(C))
              return "graphql";
            if (k(C))
              return "html";
            if (f(C))
              return "angular";
            if (m2(C))
              return "markdown";
          }
          function v(C, D, g, F) {
            let l = C.getValue();
            if (l.type !== "TemplateLiteral" || P(l))
              return;
            let E = c(C);
            if (!!E) {
              if (E === "markdown")
                return r(C, D, g);
              if (E === "css")
                return u(C, D, g);
              if (E === "graphql")
                return i(C, D, g);
              if (E === "html" || E === "angular")
                return o(C, D, g, F, { parser: E });
            }
          }
          function m2(C) {
            let D = C.getValue(), g = C.getParentNode();
            return g && g.type === "TaggedTemplateExpression" && D.quasis.length === 1 && g.tag.type === "Identifier" && (g.tag.name === "md" || g.tag.name === "markdown");
          }
          function d(C) {
            let D = C.getValue(), g = C.getParentNode(), F = C.getParentNode(1);
            return F && D.quasis && g.type === "JSXExpressionContainer" && F.type === "JSXElement" && F.openingElement.name.name === "style" && F.openingElement.attributes.some((l) => l.name.name === "jsx") || g && g.type === "TaggedTemplateExpression" && g.tag.type === "Identifier" && g.tag.name === "css" || g && g.type === "TaggedTemplateExpression" && g.tag.type === "MemberExpression" && g.tag.object.name === "css" && (g.tag.property.name === "global" || g.tag.property.name === "resolve");
          }
          function p2(C) {
            return C.match((D) => D.type === "TemplateLiteral", (D, g) => D.type === "ArrayExpression" && g === "elements", (D, g) => a(D) && D.key.type === "Identifier" && D.key.name === "styles" && g === "value", ...h3);
          }
          function f(C) {
            return C.match((D) => D.type === "TemplateLiteral", (D, g) => a(D) && D.key.type === "Identifier" && D.key.name === "template" && g === "value", ...h3);
          }
          var h3 = [(C, D) => C.type === "ObjectExpression" && D === "properties", (C, D) => C.type === "CallExpression" && C.callee.type === "Identifier" && C.callee.name === "Component" && D === "arguments", (C, D) => C.type === "Decorator" && D === "expression"];
          function w(C) {
            let D = C.getParentNode();
            if (!D || D.type !== "TaggedTemplateExpression")
              return false;
            let g = D.tag.type === "ParenthesizedExpression" ? D.tag.expression : D.tag;
            switch (g.type) {
              case "MemberExpression":
                return A(g.object) || S(g);
              case "CallExpression":
                return A(g.callee) || g.callee.type === "MemberExpression" && (g.callee.object.type === "MemberExpression" && (A(g.callee.object.object) || S(g.callee.object)) || g.callee.object.type === "CallExpression" && A(g.callee.object.callee));
              case "Identifier":
                return g.name === "css";
              default:
                return false;
            }
          }
          function T(C) {
            let D = C.getParentNode(), g = C.getParentNode(1);
            return g && D.type === "JSXExpressionContainer" && g.type === "JSXAttribute" && g.name.type === "JSXIdentifier" && g.name.name === "css";
          }
          function A(C) {
            return C.type === "Identifier" && C.name === "styled";
          }
          function S(C) {
            return /^[A-Z]/.test(C.object.name) && C.property.name === "extend";
          }
          function B(C) {
            let D = C.getValue(), g = C.getParentNode();
            return I(D, "GraphQL") || g && (g.type === "TaggedTemplateExpression" && (g.tag.type === "MemberExpression" && g.tag.object.name === "graphql" && g.tag.property.name === "experimental" || g.tag.type === "Identifier" && (g.tag.name === "gql" || g.tag.name === "graphql")) || g.type === "CallExpression" && g.callee.type === "Identifier" && g.callee.name === "graphql");
          }
          function I(C, D) {
            return t(C, s.Block | s.Leading, (g) => {
              let { value: F } = g;
              return F === " ".concat(D, " ");
            });
          }
          function k(C) {
            return I(C.getValue(), "HTML") || C.match((D) => D.type === "TemplateLiteral", (D, g) => D.type === "TaggedTemplateExpression" && D.tag.type === "Identifier" && D.tag.name === "html" && g === "quasi");
          }
          function P(C) {
            let { quasis: D } = C;
            return D.some((g) => {
              let { value: { cooked: F } } = g;
              return F === null;
            });
          }
          n.exports = v;
        } }), Lm = Z({ "src/language-js/clean.js"(e, n) {
          "use strict";
          re();
          var t = It(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
            for (let i of u.quasis)
              delete i.value;
          };
          function r(u, i, o) {
            if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ")
              return null;
            if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((m2) => m2.name.name === "jsx"))
              for (let { type: m2, expression: d } of i.children)
                m2 === "JSXExpressionContainer" && d.type === "TemplateLiteral" && a(d);
            u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
            let c = u.expression || u.callee;
            if (u.type === "Decorator" && c.type === "CallExpression" && c.callee.name === "Component" && c.arguments.length === 1) {
              let m2 = u.expression.arguments[0].properties;
              for (let [d, p2] of i.expression.arguments[0].properties.entries())
                switch (m2[d].key.name) {
                  case "styles":
                    p2.value.type === "ArrayExpression" && a(p2.value.elements[0]);
                    break;
                  case "template":
                    p2.value.type === "TemplateLiteral" && a(p2.value);
                    break;
                }
            }
            if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
              var v;
              (((v = u.leadingComments) === null || v === void 0 ? void 0 : v.some((d) => t(d) && ["GraphQL", "HTML"].some((p2) => d.value === " ".concat(p2, " ")))) || o.type === "CallExpression" && o.callee.name === "graphql" || !u.leadingComments) && a(i);
            }
            if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1)
              return i.types[0];
          }
          r.ignoredProperties = s, n.exports = r;
        } }), Ha = {};
        Ut(Ha, { EOL: () => Pn, arch: () => jm, cpus: () => Ya, default: () => ro, endianness: () => Ga, freemem: () => Xa, getNetworkInterfaces: () => to, hostname: () => Ja, loadavg: () => Ua, networkInterfaces: () => eo, platform: () => Om, release: () => Za, tmpDir: () => wn, tmpdir: () => _n2, totalmem: () => Ka, type: () => Qa, uptime: () => za });
        function Ga() {
          if (typeof Sr > "u") {
            var e = new ArrayBuffer(2), n = new Uint8Array(e), t = new Uint16Array(e);
            if (n[0] = 1, n[1] = 2, t[0] === 258)
              Sr = "BE";
            else if (t[0] === 513)
              Sr = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return Sr;
        }
        function Ja() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Ua() {
          return [];
        }
        function za() {
          return 0;
        }
        function Xa() {
          return Number.MAX_VALUE;
        }
        function Ka() {
          return Number.MAX_VALUE;
        }
        function Ya() {
          return [];
        }
        function Qa() {
          return "Browser";
        }
        function Za() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function eo() {
        }
        function to() {
        }
        function jm() {
          return "javascript";
        }
        function Om() {
          return "browser";
        }
        function wn() {
          return "/tmp";
        }
        var Sr, _n2, Pn, ro, qm = mt({ "node-modules-polyfills:os"() {
          re(), _n2 = wn, Pn = `
`, ro = { EOL: Pn, tmpdir: _n2, tmpDir: wn, networkInterfaces: eo, getNetworkInterfaces: to, release: Za, type: Qa, cpus: Ya, totalmem: Ka, freemem: Xa, uptime: za, loadavg: Ua, hostname: Ja, endianness: Ga };
        } }), Mm = Z({ "node-modules-polyfills-commonjs:os"(e, n) {
          re();
          var t = (qm(), lt(Ha));
          if (t && t.default) {
            n.exports = t.default;
            for (let s in t)
              n.exports[s] = t[s];
          } else
            t && (n.exports = t);
        } }), Rm = Z({ "node_modules/detect-newline/index.js"(e, n) {
          "use strict";
          re();
          var t = (s) => {
            if (typeof s != "string")
              throw new TypeError("Expected a string");
            let a = s.match(/(?:\r?\n)/g) || [];
            if (a.length === 0)
              return;
            let r = a.filter((i) => i === `\r
`).length, u = a.length - r;
            return r > u ? `\r
` : `
`;
          };
          n.exports = t, n.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
        } }), Vm = Z({ "node_modules/jest-docblock/build/index.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = p2, e.parse = h3, e.parseWithComments = w, e.print = T, e.strip = f;
          function n() {
            let S = Mm();
            return n = function() {
              return S;
            }, S;
          }
          function t() {
            let S = s(Rm());
            return t = function() {
              return S;
            }, S;
          }
          function s(S) {
            return S && S.__esModule ? S : { default: S };
          }
          var a = /\*\/$/, r = /^\/\*\*/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, o = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, v = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, m2 = /(\r?\n|^) *\* ?/g, d = [];
          function p2(S) {
            let B = S.match(u);
            return B ? B[0].trimLeft() : "";
          }
          function f(S) {
            let B = S.match(u);
            return B && B[0] ? S.substring(B[0].length) : S;
          }
          function h3(S) {
            return w(S).pragmas;
          }
          function w(S) {
            let B = (0, t().default)(S) || n().EOL;
            S = S.replace(r, "").replace(a, "").replace(m2, "$1");
            let I = "";
            for (; I !== S; )
              I = S, S = S.replace(c, "".concat(B, "$1 $2").concat(B));
            S = S.replace(o, "").trimRight();
            let k = /* @__PURE__ */ Object.create(null), P = S.replace(v, "").replace(o, "").trimRight(), C;
            for (; C = v.exec(S); ) {
              let D = C[2].replace(i, "");
              typeof k[C[1]] == "string" || Array.isArray(k[C[1]]) ? k[C[1]] = d.concat(k[C[1]], D) : k[C[1]] = D;
            }
            return { comments: P, pragmas: k };
          }
          function T(S) {
            let { comments: B = "", pragmas: I = {} } = S, k = (0, t().default)(B) || n().EOL, P = "/**", C = " *", D = " */", g = Object.keys(I), F = g.map((E) => A(E, I[E])).reduce((E, y) => E.concat(y), []).map((E) => C + " " + E + k).join("");
            if (!B) {
              if (g.length === 0)
                return "";
              if (g.length === 1 && !Array.isArray(I[g[0]])) {
                let E = I[g[0]];
                return "".concat(P, " ").concat(A(g[0], E)[0]).concat(D);
              }
            }
            let l = B.split(k).map((E) => "".concat(C, " ").concat(E)).join(k) + k;
            return P + k + (B ? l : "") + (B && g.length ? C + k : "") + F + D;
          }
          function A(S, B) {
            return d.concat(B).map((I) => "@".concat(S, " ").concat(I).trim());
          }
        } }), Wm = Z({ "src/language-js/utils/get-shebang.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            if (!s.startsWith("#!"))
              return "";
            let a = s.indexOf(`
`);
            return a === -1 ? s : s.slice(0, a);
          }
          n.exports = t;
        } }), no = Z({ "src/language-js/pragma.js"(e, n) {
          "use strict";
          re();
          var { parseWithComments: t, strip: s, extract: a, print: r } = Vm(), { normalizeEndOfLine: u } = jn(), i = Wm();
          function o(m2) {
            let d = i(m2);
            d && (m2 = m2.slice(d.length + 1));
            let p2 = a(m2), { pragmas: f, comments: h3 } = t(p2);
            return { shebang: d, text: m2, pragmas: f, comments: h3 };
          }
          function c(m2) {
            let d = Object.keys(o(m2).pragmas);
            return d.includes("prettier") || d.includes("format");
          }
          function v(m2) {
            let { shebang: d, text: p2, pragmas: f, comments: h3 } = o(m2), w = s(p2), T = r({ pragmas: Object.assign({ format: "" }, f), comments: h3.trimStart() });
            return (d ? "".concat(d, `
`) : "") + u(T) + (w.startsWith(`
`) ? `
` : `

`) + w;
          }
          n.exports = { hasPragma: c, insertPragma: v };
        } }), uo = Z({ "src/language-js/comments.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: r, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: o, addDanglingComment: c, getNextNonSpaceNonCommentCharacterIndex: v, isNonEmptyArray: m2 } = Ue(), { getFunctionParameters: d, isPrettierIgnoreComment: p2, isJsxNode: f, hasFlowShorthandAnnotationComment: h3, hasFlowAnnotationComment: w, hasIgnoreComment: T, isCallLikeExpression: A, getCallArguments: S, isCallExpression: B, isMemberExpression: I, isObjectProperty: k, isLineComment: P, getComments: C, CommentCheckFlags: D, markerForIfWithoutBlockAndSameLineComment: g } = Ke(), { locStart: F, locEnd: l } = st(), E = It();
          function y(me) {
            return [ve, De, q, j, $2, V, Q, Ae, U, ge, Ne, ke, te, ie, G].some((_) => _(me));
          }
          function N(me) {
            return [M, De, Y, Ne, j, $2, V, Q, ie, z, le, ge, de, G, he].some((_) => _(me));
          }
          function x(me) {
            return [ve, j, $2, H, ue, te, ge, X, W, K, G, ae].some((_) => _(me));
          }
          function b(me, _) {
            let J = (me.body || me.properties).find((ne) => {
              let { type: Ee } = ne;
              return Ee !== "EmptyStatement";
            });
            J ? i(J, _) : c(me, _);
          }
          function L(me, _) {
            me.type === "BlockStatement" ? b(me, _) : i(me, _);
          }
          function M(me) {
            let { comment: _, followingNode: J } = me;
            return J && Ie(_) ? (i(J, _), true) : false;
          }
          function j(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
            if ((ne == null ? void 0 : ne.type) !== "IfStatement" || !Ee)
              return false;
            if (r(We, _, l) === ")")
              return o(J, _), true;
            if (J === ne.consequent && Ee === ne.alternate) {
              if (J.type === "BlockStatement")
                o(J, _);
              else {
                let Pe = _.type === "SingleLine" || _.loc.start.line === _.loc.end.line, Se = _.loc.start.line === J.loc.start.line;
                Pe && Se ? c(J, _, g) : c(ne, _);
              }
              return true;
            }
            return Ee.type === "BlockStatement" ? (b(Ee, _), true) : Ee.type === "IfStatement" ? (L(Ee.consequent, _), true) : ne.consequent === Ee ? (i(Ee, _), true) : false;
          }
          function $2(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
            return (ne == null ? void 0 : ne.type) !== "WhileStatement" || !Ee ? false : r(We, _, l) === ")" ? (o(J, _), true) : Ee.type === "BlockStatement" ? (b(Ee, _), true) : ne.body === Ee ? (i(Ee, _), true) : false;
          }
          function V(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
            return (ne == null ? void 0 : ne.type) !== "TryStatement" && (ne == null ? void 0 : ne.type) !== "CatchClause" || !Ee ? false : ne.type === "CatchClause" && J ? (o(J, _), true) : Ee.type === "BlockStatement" ? (b(Ee, _), true) : Ee.type === "TryStatement" ? (L(Ee.finalizer, _), true) : Ee.type === "CatchClause" ? (L(Ee.body, _), true) : false;
          }
          function q(me) {
            let { comment: _, enclosingNode: J, followingNode: ne } = me;
            return I(J) && (ne == null ? void 0 : ne.type) === "Identifier" ? (i(J, _), true) : false;
          }
          function Y(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me, Be = J && !u(We, l(J), F(_));
            return (!J || !Be) && ((ne == null ? void 0 : ne.type) === "ConditionalExpression" || (ne == null ? void 0 : ne.type) === "TSConditionalType") && Ee ? (i(Ee, _), true) : false;
          }
          function H(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne } = me;
            return k(ne) && ne.shorthand && ne.key === J && ne.value.type === "AssignmentPattern" ? (o(ne.value.left, _), true) : false;
          }
          var R = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
          function Q(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
            if (R.has(ne == null ? void 0 : ne.type)) {
              if (m2(ne.decorators) && !(Ee && Ee.type === "Decorator"))
                return o(t(ne.decorators), _), true;
              if (ne.body && Ee === ne.body)
                return b(ne.body, _), true;
              if (Ee) {
                if (ne.superClass && Ee === ne.superClass && J && (J === ne.id || J === ne.typeParameters))
                  return o(J, _), true;
                for (let We of ["implements", "extends", "mixins"])
                  if (ne[We] && Ee === ne[We][0])
                    return J && (J === ne.id || J === ne.typeParameters || J === ne.superClass) ? o(J, _) : c(ne, _, We), true;
              }
            }
            return false;
          }
          var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition"]);
          function te(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
            return ne && J && r(Ee, _, l) === "(" && (ne.type === "Property" || ne.type === "TSDeclareMethod" || ne.type === "TSAbstractMethodDefinition") && J.type === "Identifier" && ne.key === J && r(Ee, J, l) !== ":" || (J == null ? void 0 : J.type) === "Decorator" && ee.has(ne == null ? void 0 : ne.type) ? (o(J, _), true) : false;
          }
          var oe = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
          function W(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
            return r(Ee, _, l) !== "(" ? false : J && oe.has(ne == null ? void 0 : ne.type) ? (o(J, _), true) : false;
          }
          function X(me) {
            let { comment: _, enclosingNode: J, text: ne } = me;
            if ((J == null ? void 0 : J.type) !== "ArrowFunctionExpression")
              return false;
            let Ee = v(ne, _, l);
            return Ee !== false && ne.slice(Ee, Ee + 2) === "=>" ? (c(J, _), true) : false;
          }
          function ue(me) {
            let { comment: _, enclosingNode: J, text: ne } = me;
            return r(ne, _, l) !== ")" ? false : J && (ye(J) && d(J).length === 0 || A(J) && S(J).length === 0) ? (c(J, _), true) : ((J == null ? void 0 : J.type) === "MethodDefinition" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && d(J.value).length === 0 ? (c(J.value, _), true) : false;
          }
          function De(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee, text: We } = me;
            if ((J == null ? void 0 : J.type) === "FunctionTypeParam" && (ne == null ? void 0 : ne.type) === "FunctionTypeAnnotation" && (Ee == null ? void 0 : Ee.type) !== "FunctionTypeParam" || ((J == null ? void 0 : J.type) === "Identifier" || (J == null ? void 0 : J.type) === "AssignmentPattern") && ne && ye(ne) && r(We, _, l) === ")")
              return o(J, _), true;
            if ((ne == null ? void 0 : ne.type) === "FunctionDeclaration" && (Ee == null ? void 0 : Ee.type) === "BlockStatement") {
              let Be = (() => {
                let Pe = d(ne);
                if (Pe.length > 0)
                  return a(We, l(t(Pe)));
                let Se = a(We, l(ne.id));
                return Se !== false && a(We, Se + 1);
              })();
              if (F(_) > Be)
                return b(Ee, _), true;
            }
            return false;
          }
          function ie(me) {
            let { comment: _, enclosingNode: J } = me;
            return (J == null ? void 0 : J.type) === "LabeledStatement" ? (i(J, _), true) : false;
          }
          function G(me) {
            let { comment: _, enclosingNode: J } = me;
            return ((J == null ? void 0 : J.type) === "ContinueStatement" || (J == null ? void 0 : J.type) === "BreakStatement") && !J.label ? (o(J, _), true) : false;
          }
          function z(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne } = me;
            return B(ne) && J && ne.callee === J && ne.arguments.length > 0 ? (i(ne.arguments[0], _), true) : false;
          }
          function U(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
            return (ne == null ? void 0 : ne.type) === "UnionTypeAnnotation" || (ne == null ? void 0 : ne.type) === "TSUnionType" ? (p2(_) && (Ee.prettierIgnore = true, _.unignore = true), J ? (o(J, _), true) : false) : (((Ee == null ? void 0 : Ee.type) === "UnionTypeAnnotation" || (Ee == null ? void 0 : Ee.type) === "TSUnionType") && p2(_) && (Ee.types[0].prettierIgnore = true, _.unignore = true), false);
          }
          function le(me) {
            let { comment: _, enclosingNode: J } = me;
            return k(J) ? (i(J, _), true) : false;
          }
          function ge(me) {
            let { comment: _, enclosingNode: J, followingNode: ne, ast: Ee, isLastComment: We } = me;
            return Ee && Ee.body && Ee.body.length === 0 ? (We ? c(Ee, _) : i(Ee, _), true) : (J == null ? void 0 : J.type) === "Program" && (J == null ? void 0 : J.body.length) === 0 && !m2(J.directives) ? (We ? c(J, _) : i(J, _), true) : (ne == null ? void 0 : ne.type) === "Program" && (ne == null ? void 0 : ne.body.length) === 0 && (J == null ? void 0 : J.type) === "ModuleExpression" ? (c(ne, _), true) : false;
          }
          function Ae(me) {
            let { comment: _, enclosingNode: J } = me;
            return (J == null ? void 0 : J.type) === "ForInStatement" || (J == null ? void 0 : J.type) === "ForOfStatement" ? (i(J, _), true) : false;
          }
          function Ne(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, text: Ee } = me;
            if ((ne == null ? void 0 : ne.type) === "ImportSpecifier" || (ne == null ? void 0 : ne.type) === "ExportSpecifier")
              return i(ne, _), true;
            let We = (J == null ? void 0 : J.type) === "ImportSpecifier" && (ne == null ? void 0 : ne.type) === "ImportDeclaration", Be = (J == null ? void 0 : J.type) === "ExportSpecifier" && (ne == null ? void 0 : ne.type) === "ExportNamedDeclaration";
            return (We || Be) && s(Ee, l(_)) ? (o(J, _), true) : false;
          }
          function ke(me) {
            let { comment: _, enclosingNode: J } = me;
            return (J == null ? void 0 : J.type) === "AssignmentPattern" ? (i(J, _), true) : false;
          }
          var ce = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), pe = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
          function de(me) {
            let { comment: _, enclosingNode: J, followingNode: ne } = me;
            return ce.has(J == null ? void 0 : J.type) && ne && (pe.has(ne.type) || E(_)) ? (i(ne, _), true) : false;
          }
          function ae(me) {
            let { comment: _, enclosingNode: J, followingNode: ne, text: Ee } = me;
            return !ne && ((J == null ? void 0 : J.type) === "TSMethodSignature" || (J == null ? void 0 : J.type) === "TSDeclareFunction" || (J == null ? void 0 : J.type) === "TSAbstractMethodDefinition") && r(Ee, _, l) === ";" ? (o(J, _), true) : false;
          }
          function ve(me) {
            let { comment: _, enclosingNode: J, followingNode: ne } = me;
            if (p2(_) && (J == null ? void 0 : J.type) === "TSMappedType" && (ne == null ? void 0 : ne.type) === "TSTypeParameter" && ne.constraint)
              return J.prettierIgnore = true, _.unignore = true, true;
          }
          function K(me) {
            let { comment: _, precedingNode: J, enclosingNode: ne, followingNode: Ee } = me;
            return (ne == null ? void 0 : ne.type) !== "TSMappedType" ? false : (Ee == null ? void 0 : Ee.type) === "TSTypeParameter" && Ee.name ? (i(Ee.name, _), true) : (J == null ? void 0 : J.type) === "TSTypeParameter" && J.constraint ? (o(J.constraint, _), true) : false;
          }
          function he(me) {
            let { comment: _, enclosingNode: J, followingNode: ne } = me;
            return !J || J.type !== "SwitchCase" || J.test ? false : (ne.type === "BlockStatement" && P(_) ? b(ne, _) : c(J, _), true);
          }
          function ye(me) {
            return me.type === "ArrowFunctionExpression" || me.type === "FunctionExpression" || me.type === "FunctionDeclaration" || me.type === "ObjectMethod" || me.type === "ClassMethod" || me.type === "TSDeclareFunction" || me.type === "TSCallSignatureDeclaration" || me.type === "TSConstructSignatureDeclaration" || me.type === "TSMethodSignature" || me.type === "TSConstructorType" || me.type === "TSFunctionType" || me.type === "TSDeclareMethod";
          }
          function Ce(me, _) {
            if ((_.parser === "typescript" || _.parser === "flow" || _.parser === "acorn" || _.parser === "espree" || _.parser === "meriyah" || _.parser === "__babel_estree") && me.type === "MethodDefinition" && me.value && me.value.type === "FunctionExpression" && d(me.value).length === 0 && !me.value.returnType && !m2(me.value.typeParameters) && me.value.body)
              return [...me.decorators || [], me.key, me.value.body];
          }
          function Ie(me) {
            return E(me) && me.value[0] === "*" && /@type\b/.test(me.value);
          }
          function Fe(me) {
            let _ = me.getValue(), J = me.getParentNode(), ne = (Ee) => w(C(Ee, D.Leading)) || w(C(Ee, D.Trailing));
            return (_ && (f(_) || h3(_) || B(J) && ne(_)) || J && (J.type === "JSXSpreadAttribute" || J.type === "JSXSpreadChild" || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType" || (J.type === "ClassDeclaration" || J.type === "ClassExpression") && J.superClass === _)) && (!T(me) || J.type === "UnionTypeAnnotation" || J.type === "TSUnionType");
          }
          n.exports = { handleOwnLineComment: y, handleEndOfLineComment: N, handleRemainingComment: x, isTypeCastComment: Ie, getCommentChildNodes: Ce, willPrintOwnComments: Fe };
        } }), jt = Z({ "src/language-js/needs-parens.js"(e, n) {
          "use strict";
          re();
          var t = it(), s = Rn(), { getFunctionParameters: a, getLeftSidePathName: r, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: o, isBitwiseOperator: c, startsWithNoLookaheadToken: v, shouldFlatten: m2, getPrecedence: d, isCallExpression: p2, isMemberExpression: f, isObjectProperty: h3 } = Ke();
          function w(P, C) {
            let D = P.getParentNode();
            if (!D)
              return false;
            let g = P.getName(), F = P.getNode();
            if (C.__isInHtmlInterpolation && !C.bracketSpacing && B(F) && I(P))
              return true;
            if (T(F))
              return false;
            if (C.parser !== "flow" && u(P.getValue()))
              return true;
            if (F.type === "Identifier")
              return !!(F.extra && F.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(F.name) || g === "left" && F.name === "async" && D.type === "ForOfStatement" && !D.await);
            switch (D.type) {
              case "ParenthesizedExpression":
                return false;
              case "ClassDeclaration":
              case "ClassExpression": {
                if (g === "superClass" && (F.type === "ArrowFunctionExpression" || F.type === "AssignmentExpression" || F.type === "AwaitExpression" || F.type === "BinaryExpression" || F.type === "ConditionalExpression" || F.type === "LogicalExpression" || F.type === "NewExpression" || F.type === "ObjectExpression" || F.type === "SequenceExpression" || F.type === "TaggedTemplateExpression" || F.type === "UnaryExpression" || F.type === "UpdateExpression" || F.type === "YieldExpression" || F.type === "TSNonNullExpression"))
                  return true;
                break;
              }
              case "ExportDefaultDeclaration":
                return k(P, C) || F.type === "SequenceExpression";
              case "Decorator": {
                if (g === "expression") {
                  let l = false, E = false, y = F;
                  for (; y; )
                    switch (y.type) {
                      case "MemberExpression":
                        E = true, y = y.object;
                        break;
                      case "CallExpression":
                        if (E || l)
                          return C.parser !== "typescript";
                        l = true, y = y.callee;
                        break;
                      case "Identifier":
                        return false;
                      case "TaggedTemplateExpression":
                        return C.parser !== "typescript";
                      default:
                        return true;
                    }
                  return true;
                }
                break;
              }
              case "ExpressionStatement": {
                if (v(F, true))
                  return true;
                break;
              }
              case "ArrowFunctionExpression": {
                if (g === "body" && F.type !== "SequenceExpression" && v(F, false))
                  return true;
                break;
              }
            }
            switch (F.type) {
              case "UpdateExpression":
                if (D.type === "UnaryExpression")
                  return F.prefix && (F.operator === "++" && D.operator === "+" || F.operator === "--" && D.operator === "-");
              case "UnaryExpression":
                switch (D.type) {
                  case "UnaryExpression":
                    return F.operator === D.operator && (F.operator === "+" || F.operator === "-");
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "TaggedTemplateExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "BinaryExpression":
                    return g === "left" && D.operator === "**";
                  case "TSNonNullExpression":
                    return true;
                  default:
                    return false;
                }
              case "BinaryExpression": {
                if (D.type === "UpdateExpression" || F.operator === "in" && A(P))
                  return true;
                if (F.operator === "|>" && F.extra && F.extra.parenthesized) {
                  let l = P.getParentNode(1);
                  if (l.type === "BinaryExpression" && l.operator === "|>")
                    return true;
                }
              }
              case "TSTypeAssertion":
              case "TSAsExpression":
              case "LogicalExpression":
                switch (D.type) {
                  case "TSAsExpression":
                    return F.type !== "TSAsExpression";
                  case "ConditionalExpression":
                    return F.type === "TSAsExpression";
                  case "CallExpression":
                  case "NewExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ClassExpression":
                  case "ClassDeclaration":
                    return g === "superClass";
                  case "TSTypeAssertion":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "JSXSpreadAttribute":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BindExpression":
                  case "AwaitExpression":
                  case "TSNonNullExpression":
                  case "UpdateExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "AssignmentExpression":
                  case "AssignmentPattern":
                    return g === "left" && (F.type === "TSTypeAssertion" || F.type === "TSAsExpression");
                  case "LogicalExpression":
                    if (F.type === "LogicalExpression")
                      return D.operator !== F.operator;
                  case "BinaryExpression": {
                    let { operator: l, type: E } = F;
                    if (!l && E !== "TSTypeAssertion")
                      return true;
                    let y = d(l), N = D.operator, x = d(N);
                    return x > y || g === "right" && x === y || x === y && !m2(N, l) ? true : x < y && l === "%" ? N === "+" || N === "-" : !!c(N);
                  }
                  default:
                    return false;
                }
              case "SequenceExpression":
                switch (D.type) {
                  case "ReturnStatement":
                    return false;
                  case "ForStatement":
                    return false;
                  case "ExpressionStatement":
                    return g !== "expression";
                  case "ArrowFunctionExpression":
                    return g !== "body";
                  default:
                    return true;
                }
              case "YieldExpression":
                if (D.type === "UnaryExpression" || D.type === "AwaitExpression" || D.type === "TSAsExpression" || D.type === "TSNonNullExpression")
                  return true;
              case "AwaitExpression":
                switch (D.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                    return true;
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ConditionalExpression":
                    return g === "test";
                  case "BinaryExpression":
                    return !(!F.argument && D.operator === "|>");
                  default:
                    return false;
                }
              case "TSConditionalType":
                if (g === "extendsType" && D.type === "TSConditionalType")
                  return true;
              case "TSFunctionType":
              case "TSConstructorType":
                if (g === "checkType" && D.type === "TSConditionalType")
                  return true;
              case "TSUnionType":
              case "TSIntersectionType":
                if ((D.type === "TSUnionType" || D.type === "TSIntersectionType") && D.types.length > 1 && (!F.types || F.types.length > 1))
                  return true;
              case "TSInferType":
                if (F.type === "TSInferType" && D.type === "TSRestType")
                  return false;
              case "TSTypeOperator":
                return D.type === "TSArrayType" || D.type === "TSOptionalType" || D.type === "TSRestType" || g === "objectType" && D.type === "TSIndexedAccessType" || D.type === "TSTypeOperator" || D.type === "TSTypeAnnotation" && P.getParentNode(1).type.startsWith("TSJSDoc");
              case "ArrayTypeAnnotation":
                return D.type === "NullableTypeAnnotation";
              case "IntersectionTypeAnnotation":
              case "UnionTypeAnnotation":
                return D.type === "ArrayTypeAnnotation" || D.type === "NullableTypeAnnotation" || D.type === "IntersectionTypeAnnotation" || D.type === "UnionTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "NullableTypeAnnotation":
                return D.type === "ArrayTypeAnnotation" || g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "FunctionTypeAnnotation": {
                let l = D.type === "NullableTypeAnnotation" ? P.getParentNode(1) : D;
                return l.type === "UnionTypeAnnotation" || l.type === "IntersectionTypeAnnotation" || l.type === "ArrayTypeAnnotation" || g === "objectType" && (l.type === "IndexedAccessType" || l.type === "OptionalIndexedAccessType") || l.type === "NullableTypeAnnotation" || D.type === "FunctionTypeParam" && D.name === null && a(F).some((E) => E.typeAnnotation && E.typeAnnotation.type === "NullableTypeAnnotation");
              }
              case "OptionalIndexedAccessType":
                return g === "objectType" && D.type === "IndexedAccessType";
              case "TypeofTypeAnnotation":
                return g === "objectType" && (D.type === "IndexedAccessType" || D.type === "OptionalIndexedAccessType");
              case "StringLiteral":
              case "NumericLiteral":
              case "Literal":
                if (typeof F.value == "string" && D.type === "ExpressionStatement" && !D.directive) {
                  let l = P.getParentNode(1);
                  return l.type === "Program" || l.type === "BlockStatement";
                }
                return g === "object" && D.type === "MemberExpression" && typeof F.value == "number";
              case "AssignmentExpression": {
                let l = P.getParentNode(1);
                return g === "body" && D.type === "ArrowFunctionExpression" ? true : g === "key" && (D.type === "ClassProperty" || D.type === "PropertyDefinition") && D.computed || (g === "init" || g === "update") && D.type === "ForStatement" ? false : D.type === "ExpressionStatement" ? F.left.type === "ObjectPattern" : !(g === "key" && D.type === "TSPropertySignature" || D.type === "AssignmentExpression" || D.type === "SequenceExpression" && l && l.type === "ForStatement" && (l.init === D || l.update === D) || g === "value" && D.type === "Property" && l && l.type === "ObjectPattern" && l.properties.includes(D) || D.type === "NGChainedExpression");
              }
              case "ConditionalExpression":
                switch (D.type) {
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "SpreadElement":
                  case "SpreadProperty":
                  case "BinaryExpression":
                  case "LogicalExpression":
                  case "NGPipeExpression":
                  case "ExportDefaultDeclaration":
                  case "AwaitExpression":
                  case "JSXSpreadAttribute":
                  case "TSTypeAssertion":
                  case "TypeCastExpression":
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                    return true;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "ConditionalExpression":
                    return g === "test";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  default:
                    return false;
                }
              case "FunctionExpression":
                switch (D.type) {
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "TaggedTemplateExpression":
                    return true;
                  default:
                    return false;
                }
              case "ArrowFunctionExpression":
                switch (D.type) {
                  case "BinaryExpression":
                    return D.operator !== "|>" || F.extra && F.extra.parenthesized;
                  case "NewExpression":
                  case "CallExpression":
                  case "OptionalCallExpression":
                    return g === "callee";
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return g === "object";
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "BindExpression":
                  case "TaggedTemplateExpression":
                  case "UnaryExpression":
                  case "LogicalExpression":
                  case "AwaitExpression":
                  case "TSTypeAssertion":
                    return true;
                  case "ConditionalExpression":
                    return g === "test";
                  default:
                    return false;
                }
              case "ClassExpression":
                if (s(F.decorators))
                  return true;
                switch (D.type) {
                  case "NewExpression":
                    return g === "callee";
                  default:
                    return false;
                }
              case "OptionalMemberExpression":
              case "OptionalCallExpression": {
                let l = P.getParentNode(1);
                if (g === "object" && D.type === "MemberExpression" || g === "callee" && (D.type === "CallExpression" || D.type === "NewExpression") || D.type === "TSNonNullExpression" && l.type === "MemberExpression" && l.object === D)
                  return true;
              }
              case "CallExpression":
              case "MemberExpression":
              case "TaggedTemplateExpression":
              case "TSNonNullExpression":
                if (g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression")) {
                  let l = F;
                  for (; l; )
                    switch (l.type) {
                      case "CallExpression":
                      case "OptionalCallExpression":
                        return true;
                      case "MemberExpression":
                      case "OptionalMemberExpression":
                      case "BindExpression":
                        l = l.object;
                        break;
                      case "TaggedTemplateExpression":
                        l = l.tag;
                        break;
                      case "TSNonNullExpression":
                        l = l.expression;
                        break;
                      default:
                        return false;
                    }
                }
                return false;
              case "BindExpression":
                return g === "callee" && (D.type === "BindExpression" || D.type === "NewExpression") || g === "object" && f(D);
              case "NGPipeExpression":
                return !(D.type === "NGRoot" || D.type === "NGMicrosyntaxExpression" || D.type === "ObjectProperty" && !(F.extra && F.extra.parenthesized) || D.type === "ArrayExpression" || p2(D) && D.arguments[g] === F || g === "right" && D.type === "NGPipeExpression" || g === "property" && D.type === "MemberExpression" || D.type === "AssignmentExpression");
              case "JSXFragment":
              case "JSXElement":
                return g === "callee" || g === "left" && D.type === "BinaryExpression" && D.operator === "<" || D.type !== "ArrayExpression" && D.type !== "ArrowFunctionExpression" && D.type !== "AssignmentExpression" && D.type !== "AssignmentPattern" && D.type !== "BinaryExpression" && D.type !== "NewExpression" && D.type !== "ConditionalExpression" && D.type !== "ExpressionStatement" && D.type !== "JsExpressionRoot" && D.type !== "JSXAttribute" && D.type !== "JSXElement" && D.type !== "JSXExpressionContainer" && D.type !== "JSXFragment" && D.type !== "LogicalExpression" && !p2(D) && !h3(D) && D.type !== "ReturnStatement" && D.type !== "ThrowStatement" && D.type !== "TypeCastExpression" && D.type !== "VariableDeclarator" && D.type !== "YieldExpression";
              case "TypeAnnotation":
                return g === "returnType" && D.type === "ArrowFunctionExpression" && S(F);
            }
            return false;
          }
          function T(P) {
            return P.type === "BlockStatement" || P.type === "BreakStatement" || P.type === "ClassBody" || P.type === "ClassDeclaration" || P.type === "ClassMethod" || P.type === "ClassProperty" || P.type === "PropertyDefinition" || P.type === "ClassPrivateProperty" || P.type === "ContinueStatement" || P.type === "DebuggerStatement" || P.type === "DeclareClass" || P.type === "DeclareExportAllDeclaration" || P.type === "DeclareExportDeclaration" || P.type === "DeclareFunction" || P.type === "DeclareInterface" || P.type === "DeclareModule" || P.type === "DeclareModuleExports" || P.type === "DeclareVariable" || P.type === "DoWhileStatement" || P.type === "EnumDeclaration" || P.type === "ExportAllDeclaration" || P.type === "ExportDefaultDeclaration" || P.type === "ExportNamedDeclaration" || P.type === "ExpressionStatement" || P.type === "ForInStatement" || P.type === "ForOfStatement" || P.type === "ForStatement" || P.type === "FunctionDeclaration" || P.type === "IfStatement" || P.type === "ImportDeclaration" || P.type === "InterfaceDeclaration" || P.type === "LabeledStatement" || P.type === "MethodDefinition" || P.type === "ReturnStatement" || P.type === "SwitchStatement" || P.type === "ThrowStatement" || P.type === "TryStatement" || P.type === "TSDeclareFunction" || P.type === "TSEnumDeclaration" || P.type === "TSImportEqualsDeclaration" || P.type === "TSInterfaceDeclaration" || P.type === "TSModuleDeclaration" || P.type === "TSNamespaceExportDeclaration" || P.type === "TypeAlias" || P.type === "VariableDeclaration" || P.type === "WhileStatement" || P.type === "WithStatement";
          }
          function A(P) {
            let C = 0, D = P.getValue();
            for (; D; ) {
              let g = P.getParentNode(C++);
              if (g && g.type === "ForStatement" && g.init === D)
                return true;
              D = g;
            }
            return false;
          }
          function S(P) {
            return o(P, (C) => C.type === "ObjectTypeAnnotation" && o(C, (D) => D.type === "FunctionTypeAnnotation" || void 0) || void 0);
          }
          function B(P) {
            switch (P.type) {
              case "ObjectExpression":
                return true;
              default:
                return false;
            }
          }
          function I(P) {
            let C = P.getValue(), D = P.getParentNode(), g = P.getName();
            switch (D.type) {
              case "NGPipeExpression":
                if (typeof g == "number" && D.arguments[g] === C && D.arguments.length - 1 === g)
                  return P.callParent(I);
                break;
              case "ObjectProperty":
                if (g === "value") {
                  let F = P.getParentNode(1);
                  return t(F.properties) === D;
                }
                break;
              case "BinaryExpression":
              case "LogicalExpression":
                if (g === "right")
                  return P.callParent(I);
                break;
              case "ConditionalExpression":
                if (g === "alternate")
                  return P.callParent(I);
                break;
              case "UnaryExpression":
                if (D.prefix)
                  return P.callParent(I);
                break;
            }
            return false;
          }
          function k(P, C) {
            let D = P.getValue(), g = P.getParentNode();
            return D.type === "FunctionExpression" || D.type === "ClassExpression" ? g.type === "ExportDefaultDeclaration" || !w(P, C) : !i(D) || g.type !== "ExportDefaultDeclaration" && w(P, C) ? false : P.call((F) => k(F, C), ...r(P, D));
          }
          n.exports = w;
        } }), so = Z({ "src/language-js/print-preprocess.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            switch (a.parser) {
              case "json":
              case "json5":
              case "json-stringify":
              case "__js_expression":
              case "__vue_expression":
              case "__vue_ts_expression":
                return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
              default:
                return s;
            }
          }
          n.exports = t;
        } }), $m = Z({ "src/language-js/print/html-binding.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, line: s, group: a, softline: r, indent: u } } = Oe();
          function i(c, v, m2) {
            let d = c.getValue();
            if (v.__onHtmlBindingRoot && c.getName() === null && v.__onHtmlBindingRoot(d, v), d.type === "File") {
              if (v.__isVueForBindingLeft)
                return c.call((p2) => {
                  let f = t([",", s], p2.map(m2, "params")), { params: h3 } = p2.getValue();
                  return h3.length === 1 ? f : ["(", u([r, a(f)]), r, ")"];
                }, "program", "body", 0);
              if (v.__isVueBindings)
                return c.call((p2) => t([",", s], p2.map(m2, "params")), "program", "body", 0);
            }
          }
          function o(c) {
            switch (c.type) {
              case "MemberExpression":
                switch (c.property.type) {
                  case "Identifier":
                  case "NumericLiteral":
                  case "StringLiteral":
                    return o(c.object);
                }
                return false;
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          n.exports = { isVueEventBindingExpression: o, printHtmlBinding: i };
        } }), Jn = Z({ "src/language-js/print/binaryish.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: r, softline: u, group: i, indent: o, align: c, ifBreak: v, indentIfBreak: m2 }, utils: { cleanDoc: d, getDocParts: p2, isConcat: f } } = Oe(), { hasLeadingOwnLineComment: h3, isBinaryish: w, isJsxNode: T, shouldFlatten: A, hasComment: S, CommentCheckFlags: B, isCallExpression: I, isMemberExpression: k, isObjectProperty: P, isEnabledHackPipeline: C } = Ke(), D = 0;
          function g(E, y, N) {
            let x = E.getValue(), b = E.getParentNode(), L = E.getParentNode(1), M = x !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), j = C(y) && x.operator === "|>", $2 = F(E, N, y, false, M);
            if (M)
              return $2;
            if (j)
              return i($2);
            if (I(b) && b.callee === x || b.type === "UnaryExpression" || k(b) && !b.computed)
              return i([o([u, ...$2]), u]);
            let V = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && L.type === "JSXAttribute" || x.operator !== "|" && b.type === "JsExpressionRoot" || x.type !== "NGPipeExpression" && (b.type === "NGRoot" && y.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && L.type === "NGMicrosyntax" && L.body.length === 1) || x === b.body && b.type === "ArrowFunctionExpression" || x !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && L.type !== "ReturnStatement" && L.type !== "ThrowStatement" && !I(L) || b.type === "TemplateLiteral", q = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), Y = w(x.left) && A(x.operator, x.left.operator);
            if (V || l(x) && !Y || !l(x) && q)
              return i($2);
            if ($2.length === 0)
              return "";
            let H = T(x.right), R = $2.findIndex((X) => typeof X != "string" && !Array.isArray(X) && X.type === "group"), Q = $2.slice(0, R === -1 ? 1 : R + 1), ee = $2.slice(Q.length, H ? -1 : void 0), te = Symbol("logicalChain-" + ++D), oe = i([...Q, o(ee)], { id: te });
            if (!H)
              return oe;
            let W = s($2);
            return i([oe, m2(W, { groupId: te })]);
          }
          function F(E, y, N, x, b) {
            let L = E.getValue();
            if (!w(L))
              return [i(y())];
            let M = [];
            A(L.operator, L.left.operator) ? M = E.call((ee) => F(ee, y, N, true, b), "left") : M.push(i(y("left")));
            let j = l(L), $2 = (L.operator === "|>" || L.type === "NGPipeExpression" || L.operator === "|" && N.parser === "__vue_expression") && !h3(N.originalText, L.right), V = L.type === "NGPipeExpression" ? "|" : L.operator, q = L.type === "NGPipeExpression" && L.arguments.length > 0 ? i(o([u, ": ", a([u, ":", v(" ")], E.map(y, "arguments").map((ee) => c(2, i(ee))))])) : "", Y;
            if (j)
              Y = [V, " ", y("right"), q];
            else {
              let te = C(N) && V === "|>" ? E.call((oe) => F(oe, y, N, true, b), "right") : y("right");
              Y = [$2 ? r : "", V, $2 ? " " : r, te, q];
            }
            let H = E.getParentNode(), R = S(L.left, B.Trailing | B.Line), Q = R || !(b && L.type === "LogicalExpression") && H.type !== L.type && L.left.type !== L.type && L.right.type !== L.type;
            if (M.push($2 ? "" : " ", Q ? i(Y, { shouldBreak: R }) : Y), x && S(L)) {
              let ee = d(t(E, M, N));
              return f(ee) || ee.type === "fill" ? p2(ee) : [ee];
            }
            return M;
          }
          function l(E) {
            return E.type !== "LogicalExpression" ? false : !!(E.right.type === "ObjectExpression" && E.right.properties.length > 0 || E.right.type === "ArrayExpression" && E.right.elements.length > 0 || T(E.right));
          }
          n.exports = { printBinaryishExpression: g, shouldInlineLogicalExpression: l };
        } }), Hm = Z({ "src/language-js/print/angular.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, line: s, group: a } } = Oe(), { hasNode: r, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: o } = Jn();
          function c(d, p2, f) {
            let h3 = d.getValue();
            if (!!h3.type.startsWith("NG"))
              switch (h3.type) {
                case "NGRoot":
                  return [f("node"), u(h3.node) ? " //" + i(h3.node)[0].value.trimEnd() : ""];
                case "NGPipeExpression":
                  return o(d, p2, f);
                case "NGChainedExpression":
                  return a(t([";", s], d.map((w) => m2(w) ? f() : ["(", f(), ")"], "expressions")));
                case "NGEmptyExpression":
                  return "";
                case "NGQuotedExpression":
                  return [h3.prefix, ": ", h3.value.trim()];
                case "NGMicrosyntax":
                  return d.map((w, T) => [T === 0 ? "" : v(w.getValue(), T, h3) ? " " : [";", s], f()], "body");
                case "NGMicrosyntaxKey":
                  return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(h3.name) ? h3.name : JSON.stringify(h3.name);
                case "NGMicrosyntaxExpression":
                  return [f("expression"), h3.alias === null ? "" : [" as ", f("alias")]];
                case "NGMicrosyntaxKeyedExpression": {
                  let w = d.getName(), T = d.getParentNode(), A = v(h3, w, T) || (w === 1 && (h3.key.name === "then" || h3.key.name === "else") || w === 2 && h3.key.name === "else" && T.body[w - 1].type === "NGMicrosyntaxKeyedExpression" && T.body[w - 1].key.name === "then") && T.body[0].type === "NGMicrosyntaxExpression";
                  return [f("key"), A ? " " : ": ", f("expression")];
                }
                case "NGMicrosyntaxLet":
                  return ["let ", f("key"), h3.value === null ? "" : [" = ", f("value")]];
                case "NGMicrosyntaxAs":
                  return [f("key"), " as ", f("alias")];
                default:
                  throw new Error("Unknown Angular node type: ".concat(JSON.stringify(h3.type), "."));
              }
          }
          function v(d, p2, f) {
            return d.type === "NGMicrosyntaxKeyedExpression" && d.key.name === "of" && p2 === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
          }
          function m2(d) {
            return r(d.getValue(), (p2) => {
              switch (p2.type) {
                case void 0:
                  return false;
                case "CallExpression":
                case "OptionalCallExpression":
                case "AssignmentExpression":
                  return true;
              }
            });
          }
          n.exports = { printAngular: c };
        } }), Gm = Z({ "src/language-js/print/jsx.js"(e, n) {
          "use strict";
          re();
          var { printComments: t, printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: o, conditionalGroup: c, fill: v, ifBreak: m2, lineSuffixBoundary: d, join: p2 }, utils: { willBreak: f } } = Oe(), { getLast: h3, getPreferredQuote: w } = Ue(), { isJsxNode: T, rawText: A, isLiteral: S, isCallExpression: B, isStringLiteral: I, isBinaryish: k, hasComment: P, CommentCheckFlags: C, hasNodeIgnoreComment: D } = Ke(), g = jt(), { willPrintOwnComments: F } = uo(), l = (ie) => ie === "" || ie === a || ie === r || ie === u;
          function E(ie, G, z) {
            let U = ie.getValue();
            if (U.type === "JSXElement" && W(U))
              return [z("openingElement"), z("closingElement")];
            let le = U.type === "JSXElement" ? z("openingElement") : z("openingFragment"), ge = U.type === "JSXElement" ? z("closingElement") : z("closingFragment");
            if (U.children.length === 1 && U.children[0].type === "JSXExpressionContainer" && (U.children[0].expression.type === "TemplateLiteral" || U.children[0].expression.type === "TaggedTemplateExpression"))
              return [le, ...ie.map(z, "children"), ge];
            U.children = U.children.map((Fe) => ue(Fe) ? { type: "JSXText", value: " ", raw: " " } : Fe);
            let Ae = U.children.some(T), Ne = U.children.filter((Fe) => Fe.type === "JSXExpressionContainer").length > 1, ke = U.type === "JSXElement" && U.openingElement.attributes.length > 1, ce = f(le) || Ae || ke || Ne, pe = ie.getParentNode().rootMarker === "mdx", de = G.singleQuote ? "{' '}" : '{" "}', ae = pe ? " " : m2([de, u], " "), ve = U.openingElement && U.openingElement.name && U.openingElement.name.name === "fbt", K = y(ie, G, z, ae, ve), he = U.children.some((Fe) => X(Fe));
            for (let Fe = K.length - 2; Fe >= 0; Fe--) {
              let me = K[Fe] === "" && K[Fe + 1] === "", _ = K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === r, J = (K[Fe] === u || K[Fe] === r) && K[Fe + 1] === "" && K[Fe + 2] === ae, ne = K[Fe] === ae && K[Fe + 1] === "" && (K[Fe + 2] === u || K[Fe + 2] === r), Ee = K[Fe] === ae && K[Fe + 1] === "" && K[Fe + 2] === ae, We = K[Fe] === u && K[Fe + 1] === "" && K[Fe + 2] === r || K[Fe] === r && K[Fe + 1] === "" && K[Fe + 2] === u;
              _ && he || me || J || Ee || We ? K.splice(Fe, 2) : ne && K.splice(Fe + 1, 2);
            }
            for (; K.length > 0 && l(h3(K)); )
              K.pop();
            for (; K.length > 1 && l(K[0]) && l(K[1]); )
              K.shift(), K.shift();
            let ye = [];
            for (let [Fe, me] of K.entries()) {
              if (me === ae) {
                if (Fe === 1 && K[Fe - 1] === "") {
                  if (K.length === 2) {
                    ye.push(de);
                    continue;
                  }
                  ye.push([de, r]);
                  continue;
                } else if (Fe === K.length - 1) {
                  ye.push(de);
                  continue;
                } else if (K[Fe - 1] === "" && K[Fe - 2] === r) {
                  ye.push(de);
                  continue;
                }
              }
              ye.push(me), f(me) && (ce = true);
            }
            let Ce = he ? v(ye) : i(ye, { shouldBreak: true });
            if (pe)
              return Ce;
            let Ie = i([le, o([r, Ce]), r, ge]);
            return ce ? Ie : c([i([le, ...K, ge]), Ie]);
          }
          function y(ie, G, z, U, le) {
            let ge = [];
            return ie.each((Ae, Ne, ke) => {
              let ce = Ae.getValue();
              if (S(ce)) {
                let pe = A(ce);
                if (X(ce)) {
                  let de = pe.split(ee);
                  if (de[0] === "") {
                    if (ge.push(""), de.shift(), /\n/.test(de[0])) {
                      let ve = ke[Ne + 1];
                      ge.push(x(le, de[1], ce, ve));
                    } else
                      ge.push(U);
                    de.shift();
                  }
                  let ae;
                  if (h3(de) === "" && (de.pop(), ae = de.pop()), de.length === 0)
                    return;
                  for (let [ve, K] of de.entries())
                    ve % 2 === 1 ? ge.push(a) : ge.push(K);
                  if (ae !== void 0)
                    if (/\n/.test(ae)) {
                      let ve = ke[Ne + 1];
                      ge.push(x(le, h3(ge), ce, ve));
                    } else
                      ge.push(U);
                  else {
                    let ve = ke[Ne + 1];
                    ge.push(N(le, h3(ge), ce, ve));
                  }
                } else
                  /\n/.test(pe) ? pe.match(/\n/g).length > 1 && ge.push("", r) : ge.push("", U);
              } else {
                let pe = z();
                ge.push(pe);
                let de = ke[Ne + 1];
                if (de && X(de)) {
                  let ve = oe(A(de)).split(ee)[0];
                  ge.push(N(le, ve, ce, de));
                } else
                  ge.push(r);
              }
            }, "children"), ge;
          }
          function N(ie, G, z, U) {
            return ie ? "" : z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? G.length === 1 ? u : r : u;
          }
          function x(ie, G, z, U) {
            return ie ? r : G.length === 1 ? z.type === "JSXElement" && !z.closingElement || U && U.type === "JSXElement" && !U.closingElement ? r : u : r;
          }
          function b(ie, G, z) {
            let U = ie.getParentNode();
            if (!U || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[U.type])
              return G;
            let ge = ie.match(void 0, (Ne) => Ne.type === "ArrowFunctionExpression", B, (Ne) => Ne.type === "JSXExpressionContainer"), Ae = g(ie, z);
            return i([Ae ? "" : m2("("), o([u, G]), u, Ae ? "" : m2(")")], { shouldBreak: ge });
          }
          function L(ie, G, z) {
            let U = ie.getValue(), le = [];
            if (le.push(z("name")), U.value) {
              let ge;
              if (I(U.value)) {
                let Ne = A(U.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: ke, quote: ce, regex: pe } = w(Ne, G.jsxSingleQuote ? "'" : '"');
                Ne = Ne.replace(pe, ke), ge = [ce, Ne, ce];
              } else
                ge = z("value");
              le.push("=", ge);
            }
            return le;
          }
          function M(ie, G, z) {
            let U = ie.getValue(), le = (ge, Ae) => ge.type === "JSXEmptyExpression" || !P(ge) && (ge.type === "ArrayExpression" || ge.type === "ObjectExpression" || ge.type === "ArrowFunctionExpression" || ge.type === "AwaitExpression" && (le(ge.argument, ge) || ge.argument.type === "JSXElement") || B(ge) || ge.type === "FunctionExpression" || ge.type === "TemplateLiteral" || ge.type === "TaggedTemplateExpression" || ge.type === "DoExpression" || T(Ae) && (ge.type === "ConditionalExpression" || k(ge)));
            return le(U.expression, ie.getParentNode(0)) ? i(["{", z("expression"), d, "}"]) : i(["{", o([u, z("expression")]), u, d, "}"]);
          }
          function j(ie, G, z) {
            let U = ie.getValue(), le = U.name && P(U.name) || U.typeParameters && P(U.typeParameters);
            if (U.selfClosing && U.attributes.length === 0 && !le)
              return ["<", z("name"), z("typeParameters"), " />"];
            if (U.attributes && U.attributes.length === 1 && U.attributes[0].value && I(U.attributes[0].value) && !U.attributes[0].value.value.includes(`
`) && !le && !P(U.attributes[0]))
              return i(["<", z("name"), z("typeParameters"), " ", ...ie.map(z, "attributes"), U.selfClosing ? " />" : ">"]);
            let ge = U.attributes.length > 0 && P(h3(U.attributes), C.Trailing), Ae = U.attributes.length === 0 && !le || (G.bracketSameLine || G.jsxBracketSameLine) && (!le || U.attributes.length > 0) && !ge, Ne = U.attributes && U.attributes.some((ce) => ce.value && I(ce.value) && ce.value.value.includes(`
`)), ke = G.singleAttributePerLine && U.attributes.length > 1 ? r : a;
            return i(["<", z("name"), z("typeParameters"), o(ie.map(() => [ke, z()], "attributes")), U.selfClosing ? a : Ae ? ">" : u, U.selfClosing ? "/>" : Ae ? "" : ">"], { shouldBreak: Ne });
          }
          function $2(ie, G, z) {
            let U = ie.getValue(), le = [];
            le.push("</");
            let ge = z("name");
            return P(U.name, C.Leading | C.Line) ? le.push(o([r, ge]), r) : P(U.name, C.Leading | C.Block) ? le.push(" ", ge) : le.push(ge), le.push(">"), le;
          }
          function V(ie, G) {
            let z = ie.getValue(), U = P(z), le = P(z, C.Line), ge = z.type === "JSXOpeningFragment";
            return [ge ? "<" : "</", o([le ? r : U && !ge ? " " : "", s(ie, G, true)]), le ? r : "", ">"];
          }
          function q(ie, G, z) {
            let U = t(ie, E(ie, G, z), G);
            return b(ie, U, G);
          }
          function Y(ie, G) {
            let z = ie.getValue(), U = P(z, C.Line);
            return [s(ie, G, !U), U ? r : ""];
          }
          function H(ie, G, z) {
            let U = ie.getValue();
            return ["{", ie.call((le) => {
              let ge = ["...", z()], Ae = le.getValue();
              return !P(Ae) || !F(le) ? ge : [o([u, t(le, ge, G)]), u];
            }, U.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
          }
          function R(ie, G, z) {
            let U = ie.getValue();
            if (!!U.type.startsWith("JSX"))
              switch (U.type) {
                case "JSXAttribute":
                  return L(ie, G, z);
                case "JSXIdentifier":
                  return String(U.name);
                case "JSXNamespacedName":
                  return p2(":", [z("namespace"), z("name")]);
                case "JSXMemberExpression":
                  return p2(".", [z("object"), z("property")]);
                case "JSXSpreadAttribute":
                  return H(ie, G, z);
                case "JSXSpreadChild":
                  return H(ie, G, z);
                case "JSXExpressionContainer":
                  return M(ie, G, z);
                case "JSXFragment":
                case "JSXElement":
                  return q(ie, G, z);
                case "JSXOpeningElement":
                  return j(ie, G, z);
                case "JSXClosingElement":
                  return $2(ie, G, z);
                case "JSXOpeningFragment":
                case "JSXClosingFragment":
                  return V(ie, G);
                case "JSXEmptyExpression":
                  return Y(ie, G);
                case "JSXText":
                  throw new Error("JSXTest should be handled by JSXElement");
                default:
                  throw new Error("Unknown JSX node type: ".concat(JSON.stringify(U.type), "."));
              }
          }
          var Q = ` 
\r	`, ee = new RegExp("([" + Q + "]+)"), te = new RegExp("[^" + Q + "]"), oe = (ie) => ie.replace(new RegExp("(?:^" + ee.source + "|" + ee.source + "$)"), "");
          function W(ie) {
            if (ie.children.length === 0)
              return true;
            if (ie.children.length > 1)
              return false;
            let G = ie.children[0];
            return S(G) && !X(G);
          }
          function X(ie) {
            return S(ie) && (te.test(A(ie)) || !/\n/.test(A(ie)));
          }
          function ue(ie) {
            return ie.type === "JSXExpressionContainer" && S(ie.expression) && ie.expression.value === " " && !P(ie.expression);
          }
          function De(ie) {
            let G = ie.getValue(), z = ie.getParentNode();
            if (!z || !G || !T(G) || !T(z))
              return false;
            let U = z.children.indexOf(G), le = null;
            for (let ge = U; ge > 0; ge--) {
              let Ae = z.children[ge - 1];
              if (!(Ae.type === "JSXText" && !X(Ae))) {
                le = Ae;
                break;
              }
            }
            return le && le.type === "JSXExpressionContainer" && le.expression.type === "JSXEmptyExpression" && D(le.expression);
          }
          n.exports = { hasJsxIgnoreComment: De, printJsx: R };
        } }), ct = Z({ "src/language-js/print/misc.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: r } } = Oe(), { isFlowAnnotationComment: u } = Ke();
          function i(h3) {
            let w = h3.getValue();
            return !w.optional || w.type === "Identifier" && w === h3.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
          }
          function o(h3) {
            return h3.getValue().definite || h3.match(void 0, (w, T) => T === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
          }
          function c(h3, w, T) {
            let A = h3.getValue();
            return A.typeArguments ? T("typeArguments") : A.typeParameters ? T("typeParameters") : "";
          }
          function v(h3, w, T) {
            let A = h3.getValue();
            if (!A.typeAnnotation)
              return "";
            let S = h3.getParentNode(), B = S.type === "DeclareFunction" && S.id === A;
            return u(w.originalText, A.typeAnnotation) ? [" /*: ", T("typeAnnotation"), " */"] : [B ? "" : ": ", T("typeAnnotation")];
          }
          function m2(h3, w, T) {
            return ["::", T("callee")];
          }
          function d(h3, w, T) {
            let A = h3.getValue();
            return t(A.modifiers) ? [a(" ", h3.map(T, "modifiers")), " "] : "";
          }
          function p2(h3, w, T) {
            return h3.type === "EmptyStatement" ? ";" : h3.type === "BlockStatement" || T ? [" ", w] : s([r, w]);
          }
          function f(h3, w, T) {
            return ["...", T("argument"), v(h3, w, T)];
          }
          n.exports = { printOptionalToken: i, printDefiniteToken: o, printFunctionTypeParameters: c, printBindExpressionCallee: m2, printTypeScriptModifiers: d, printTypeAnnotation: v, printRestSpread: f, adjustClause: p2 };
        } }), Kt = Z({ "src/language-js/print/array.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: r, group: u, indent: i, ifBreak: o, fill: c } } = Oe(), { getLast: v, hasNewline: m2 } = Ue(), { shouldPrintComma: d, hasComment: p2, CommentCheckFlags: f, isNextLineEmpty: h3, isNumericLiteral: w, isSignedNumericLiteral: T } = Ke(), { locStart: A } = st(), { printOptionalToken: S, printTypeAnnotation: B } = ct();
          function I(D, g, F) {
            let l = D.getValue(), E = [], y = l.type === "TupleExpression" ? "#[" : "[", N = "]";
            if (l.elements.length === 0)
              p2(l, f.Dangling) ? E.push(u([y, t(D, g), a, N])) : E.push(y, N);
            else {
              let x = v(l.elements), b = !(x && x.type === "RestElement"), L = x === null, M = Symbol("array"), j = !g.__inJestEach && l.elements.length > 1 && l.elements.every((q, Y, H) => {
                let R = q && q.type;
                if (R !== "ArrayExpression" && R !== "ObjectExpression")
                  return false;
                let Q = H[Y + 1];
                if (Q && R !== Q.type)
                  return false;
                let ee = R === "ArrayExpression" ? "elements" : "properties";
                return q[ee] && q[ee].length > 1;
              }), $2 = k(l, g), V = b ? L ? "," : d(g) ? $2 ? o(",", "", { groupId: M }) : o(",") : "" : "";
              E.push(u([y, i([a, $2 ? C(D, g, F, V) : [P(D, g, "elements", F), V], t(D, g, true)]), a, N], { shouldBreak: j, id: M }));
            }
            return E.push(S(D), B(D, g, F)), E;
          }
          function k(D, g) {
            return D.elements.length > 1 && D.elements.every((F) => F && (w(F) || T(F) && !p2(F.argument)) && !p2(F, f.Trailing | f.Line, (l) => !m2(g.originalText, A(l), { backwards: true })));
          }
          function P(D, g, F, l) {
            let E = [], y = [];
            return D.each((N) => {
              E.push(y, u(l())), y = [",", s], N.getValue() && h3(N.getValue(), g) && y.push(a);
            }, F), E;
          }
          function C(D, g, F, l) {
            let E = [];
            return D.each((y, N, x) => {
              let b = N === x.length - 1;
              E.push([F(), b ? l : ","]), b || E.push(h3(y.getValue(), g) ? [r, r] : p2(x[N + 1], f.Leading | f.Line) ? r : s);
            }, "elements"), c(E);
          }
          n.exports = { printArray: I, printArrayItems: P, isConciselyPrintedArray: k };
        } }), io = Z({ "src/language-js/print/call-arguments.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: r, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: o, isJsxNode: c, isLongCurriedCallExpression: v, shouldPrintComma: m2, getCallArguments: d, iterateCallArgumentsPath: p2, isNextLineEmpty: f, isCallExpression: h3, isStringLiteral: w, isObjectProperty: T } = Ke(), { builders: { line: A, hardline: S, softline: B, group: I, indent: k, conditionalGroup: P, ifBreak: C, breakParent: D }, utils: { willBreak: g } } = Oe(), { ArgExpansionBailout: F } = zt(), { isConciselyPrintedArray: l } = Kt();
          function E(j, $2, V) {
            let q = j.getValue(), Y = q.type === "ImportExpression", H = d(q);
            if (H.length === 0)
              return ["(", t(j, $2, true), ")"];
            if (b(H))
              return ["(", V(["arguments", 0]), ", ", V(["arguments", 1]), ")"];
            let R = false, Q = false, ee = H.length - 1, te = [];
            p2(j, (ie, G) => {
              let z = ie.getNode(), U = [V()];
              G === ee || (f(z, $2) ? (G === 0 && (Q = true), R = true, U.push(",", S, S)) : U.push(",", A)), te.push(U);
            });
            let oe = !(Y || q.callee && q.callee.type === "Import") && m2($2, "all") ? "," : "";
            function W() {
              return I(["(", k([A, ...te]), oe, A, ")"], { shouldBreak: true });
            }
            if (R || j.getParentNode().type !== "Decorator" && o(H))
              return W();
            let X = x(H), ue = N(H, $2);
            if (X || ue) {
              if (X ? te.slice(1).some(g) : te.slice(0, -1).some(g))
                return W();
              let ie = [];
              try {
                j.try(() => {
                  p2(j, (G, z) => {
                    X && z === 0 && (ie = [[V([], { expandFirstArg: true }), te.length > 1 ? "," : "", Q ? S : A, Q ? S : ""], ...te.slice(1)]), ue && z === ee && (ie = [...te.slice(0, -1), V([], { expandLastArg: true })]);
                  });
                });
              } catch (G) {
                if (G instanceof F)
                  return W();
                throw G;
              }
              return [te.some(g) ? D : "", P([["(", ...ie, ")"], X ? ["(", I(ie[0], { shouldBreak: true }), ...ie.slice(1), ")"] : ["(", ...te.slice(0, -1), I(s(ie), { shouldBreak: true }), ")"], W()])];
            }
            let De = ["(", k([B, ...te]), C(oe), B, ")"];
            return v(j) ? De : I(De, { shouldBreak: te.some(g) || R });
          }
          function y(j) {
            let $2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            return j.type === "ObjectExpression" && (j.properties.length > 0 || u(j)) || j.type === "ArrayExpression" && (j.elements.length > 0 || u(j)) || j.type === "TSTypeAssertion" && y(j.expression) || j.type === "TSAsExpression" && y(j.expression) || j.type === "FunctionExpression" || j.type === "ArrowFunctionExpression" && (!j.returnType || !j.returnType.typeAnnotation || j.returnType.typeAnnotation.type !== "TSTypeReference" || L(j.body)) && (j.body.type === "BlockStatement" || j.body.type === "ArrowFunctionExpression" && y(j.body, true) || j.body.type === "ObjectExpression" || j.body.type === "ArrayExpression" || !$2 && (h3(j.body) || j.body.type === "ConditionalExpression") || c(j.body)) || j.type === "DoExpression" || j.type === "ModuleExpression";
          }
          function N(j, $2) {
            let V = s(j), q = a(j);
            return !u(V, i.Leading) && !u(V, i.Trailing) && y(V) && (!q || q.type !== V.type) && (j.length !== 2 || q.type !== "ArrowFunctionExpression" || V.type !== "ArrayExpression") && !(j.length > 1 && V.type === "ArrayExpression" && l(V, $2));
          }
          function x(j) {
            if (j.length !== 2)
              return false;
            let [$2, V] = j;
            return $2.type === "ModuleExpression" && M(V) ? true : !u($2) && ($2.type === "FunctionExpression" || $2.type === "ArrowFunctionExpression" && $2.body.type === "BlockStatement") && V.type !== "FunctionExpression" && V.type !== "ArrowFunctionExpression" && V.type !== "ConditionalExpression" && !y(V);
          }
          function b(j) {
            return j.length === 2 && j[0].type === "ArrowFunctionExpression" && r(j[0]).length === 0 && j[0].body.type === "BlockStatement" && j[1].type === "ArrayExpression" && !j.some(($2) => u($2));
          }
          function L(j) {
            return j.type === "BlockStatement" && (j.body.some(($2) => $2.type !== "EmptyStatement") || u(j, i.Dangling));
          }
          function M(j) {
            return j.type === "ObjectExpression" && j.properties.length === 1 && T(j.properties[0]) && j.properties[0].key.type === "Identifier" && j.properties[0].key.name === "type" && w(j.properties[0].value) && j.properties[0].value.value === "module";
          }
          n.exports = E;
        } }), ao = Z({ "src/language-js/print/member.js"(e, n) {
          "use strict";
          re();
          var { builders: { softline: t, group: s, indent: a, label: r } } = Oe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: o } = Ke(), { printOptionalToken: c } = ct();
          function v(d, p2, f) {
            let h3 = d.getValue(), w = d.getParentNode(), T, A = 0;
            do
              T = d.getParentNode(A), A++;
            while (T && (i(T) || T.type === "TSNonNullExpression"));
            let S = f("object"), B = m2(d, p2, f), I = T && (T.type === "NewExpression" || T.type === "BindExpression" || T.type === "AssignmentExpression" && T.left.type !== "Identifier") || h3.computed || h3.object.type === "Identifier" && h3.property.type === "Identifier" && !i(w) || (w.type === "AssignmentExpression" || w.type === "VariableDeclarator") && (o(h3.object) && h3.object.arguments.length > 0 || h3.object.type === "TSNonNullExpression" && o(h3.object.expression) && h3.object.expression.arguments.length > 0 || S.label === "member-chain");
            return r(S.label === "member-chain" ? "member-chain" : "member", [S, I ? B : s(a([t, B]))]);
          }
          function m2(d, p2, f) {
            let h3 = f("property"), w = d.getValue(), T = c(d);
            return w.computed ? !w.property || u(w.property) ? [T, "[", h3, "]"] : s([T, "[", a([t, h3]), t, "]"]) : [T, ".", h3];
          }
          n.exports = { printMemberExpression: v, printMemberLookup: m2 };
        } }), Jm = Z({ "src/language-js/print/member-chain.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: r } = Ue(), u = jt(), { isCallExpression: i, isMemberExpression: o, isFunctionOrArrowExpression: c, isLongCurriedCallExpression: v, isMemberish: m2, isNumericLiteral: d, isSimpleCallArgument: p2, hasComment: f, CommentCheckFlags: h3, isNextLineEmpty: w } = Ke(), { locEnd: T } = st(), { builders: { join: A, hardline: S, group: B, indent: I, conditionalGroup: k, breakParent: P, label: C }, utils: { willBreak: D } } = Oe(), g = io(), { printMemberLookup: F } = ao(), { printOptionalToken: l, printFunctionTypeParameters: E, printBindExpressionCallee: y } = ct();
          function N(x, b, L) {
            let M = x.getParentNode(), j = !M || M.type === "ExpressionStatement", $2 = [];
            function V(de) {
              let { originalText: ae } = b, ve = r(ae, de, T);
              return ae.charAt(ve) === ")" ? ve !== false && a(ae, ve + 1) : w(de, b);
            }
            function q(de) {
              let ae = de.getValue();
              i(ae) && (m2(ae.callee) || i(ae.callee)) ? ($2.unshift({ node: ae, printed: [t(de, [l(de), E(de, b, L), g(de, b, L)], b), V(ae) ? S : ""] }), de.call((ve) => q(ve), "callee")) : m2(ae) ? ($2.unshift({ node: ae, needsParens: u(de, b), printed: t(de, o(ae) ? F(de, b, L) : y(de, b, L), b) }), de.call((ve) => q(ve), "object")) : ae.type === "TSNonNullExpression" ? ($2.unshift({ node: ae, printed: t(de, "!", b) }), de.call((ve) => q(ve), "expression")) : $2.unshift({ node: ae, printed: L() });
            }
            let Y = x.getValue();
            $2.unshift({ node: Y, printed: [l(x), E(x, b, L), g(x, b, L)] }), Y.callee && x.call((de) => q(de), "callee");
            let H = [], R = [$2[0]], Q = 1;
            for (; Q < $2.length && ($2[Q].node.type === "TSNonNullExpression" || i($2[Q].node) || o($2[Q].node) && $2[Q].node.computed && d($2[Q].node.property)); ++Q)
              R.push($2[Q]);
            if (!i($2[0].node))
              for (; Q + 1 < $2.length && (m2($2[Q].node) && m2($2[Q + 1].node)); ++Q)
                R.push($2[Q]);
            H.push(R), R = [];
            let ee = false;
            for (; Q < $2.length; ++Q) {
              if (ee && m2($2[Q].node)) {
                if ($2[Q].node.computed && d($2[Q].node.property)) {
                  R.push($2[Q]);
                  continue;
                }
                H.push(R), R = [], ee = false;
              }
              (i($2[Q].node) || $2[Q].node.type === "ImportExpression") && (ee = true), R.push($2[Q]), f($2[Q].node, h3.Trailing) && (H.push(R), R = [], ee = false);
            }
            R.length > 0 && H.push(R);
            function te(de) {
              return /^[A-Z]|^[$_]+$/.test(de);
            }
            function oe(de) {
              return de.length <= b.tabWidth;
            }
            function W(de) {
              let ae = de[1].length > 0 && de[1][0].node.computed;
              if (de[0].length === 1) {
                let K = de[0][0].node;
                return K.type === "ThisExpression" || K.type === "Identifier" && (te(K.name) || j && oe(K.name) || ae);
              }
              let ve = s(de[0]).node;
              return o(ve) && ve.property.type === "Identifier" && (te(ve.property.name) || ae);
            }
            let X = H.length >= 2 && !f(H[1][0].node) && W(H);
            function ue(de) {
              let ae = de.map((ve) => ve.printed);
              return de.length > 0 && s(de).needsParens ? ["(", ...ae, ")"] : ae;
            }
            function De(de) {
              return de.length === 0 ? "" : I(B([S, A(S, de.map(ue))]));
            }
            let ie = H.map(ue), G = ie, z = X ? 3 : 2, U = H.flat(), le = U.slice(1, -1).some((de) => f(de.node, h3.Leading)) || U.slice(0, -1).some((de) => f(de.node, h3.Trailing)) || H[z] && f(H[z][0].node, h3.Leading);
            if (H.length <= z && !le)
              return v(x) ? G : B(G);
            let ge = s(H[X ? 1 : 0]).node, Ae = !i(ge) && V(ge), Ne = [ue(H[0]), X ? H.slice(1, 2).map(ue) : "", Ae ? S : "", De(H.slice(X ? 2 : 1))], ke = $2.map((de) => {
              let { node: ae } = de;
              return ae;
            }).filter(i);
            function ce() {
              let de = s(s(H)).node, ae = s(ie);
              return i(de) && D(ae) && ke.slice(0, -1).some((ve) => ve.arguments.some(c));
            }
            let pe;
            return le || ke.length > 2 && ke.some((de) => !de.arguments.every((ae) => p2(ae, 0))) || ie.slice(0, -1).some(D) || ce() ? pe = B(Ne) : pe = [D(G) || Ae ? P : "", k([G, Ne])], C("member-chain", pe);
          }
          n.exports = N;
        } }), oo = Z({ "src/language-js/print/call-expression.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, group: s } } = Oe(), a = jt(), { getCallArguments: r, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: o, isStringLiteral: c, isTemplateOnItsOwnLine: v, isTestCall: m2, iterateCallArgumentsPath: d } = Ke(), p2 = Jm(), f = io(), { printOptionalToken: h3, printFunctionTypeParameters: w } = ct();
          function T(S, B, I) {
            let k = S.getValue(), P = S.getParentNode(), C = k.type === "NewExpression", D = k.type === "ImportExpression", g = h3(S), F = r(k);
            if (F.length > 0 && (!D && !C && A(k, P) || F.length === 1 && v(F[0], B.originalText) || !C && m2(k, P))) {
              let y = [];
              return d(S, () => {
                y.push(I());
              }), [C ? "new " : "", I("callee"), g, w(S, B, I), "(", t(", ", y), ")"];
            }
            let l = (B.parser === "babel" || B.parser === "babel-flow") && k.callee && k.callee.type === "Identifier" && u(k.callee.trailingComments);
            if (l && (k.callee.trailingComments[0].printed = true), !D && !C && o(k.callee) && !S.call((y) => a(y, B), "callee"))
              return p2(S, B, I);
            let E = [C ? "new " : "", D ? "import" : I("callee"), g, l ? "/*:: ".concat(k.callee.trailingComments[0].value.slice(2).trim(), " */") : "", w(S, B, I), f(S, B, I)];
            return D || i(k.callee) ? s(E) : E;
          }
          function A(S, B) {
            if (S.callee.type !== "Identifier")
              return false;
            if (S.callee.name === "require")
              return true;
            if (S.callee.name === "define") {
              let I = r(S);
              return B.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && c(I[0]) && I[1].type === "ArrayExpression");
            }
            return false;
          }
          n.exports = { printCallExpression: T };
        } }), Yt = Z({ "src/language-js/print/assignment.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: r, indent: u, indentIfBreak: i, lineSuffixBoundary: o }, utils: { cleanDoc: c, willBreak: v, canBreak: m2 } } = Oe(), { hasLeadingOwnLineComment: d, isBinaryish: p2, isStringLiteral: f, isLiteral: h3, isNumericLiteral: w, isCallExpression: T, isMemberExpression: A, getCallArguments: S, rawText: B, hasComment: I, isSignedNumericLiteral: k, isObjectProperty: P } = Ke(), { shouldInlineLogicalExpression: C } = Jn(), { printCallExpression: D } = oo();
          function g(W, X, ue, De, ie, G) {
            let z = E(W, X, ue, De, G), U = ue(G, { assignmentLayout: z });
            switch (z) {
              case "break-after-operator":
                return r([r(De), ie, r(u([a, U]))]);
              case "never-break-after-operator":
                return r([r(De), ie, " ", U]);
              case "fluid": {
                let le = Symbol("assignment");
                return r([r(De), ie, r(u(a), { id: le }), o, i(U, { groupId: le })]);
              }
              case "break-lhs":
                return r([De, ie, " ", r(U)]);
              case "chain":
                return [r(De), ie, a, U];
              case "chain-tail":
                return [r(De), ie, u([a, U])];
              case "chain-tail-arrow-chain":
                return [r(De), ie, U];
              case "only-left":
                return De;
            }
          }
          function F(W, X, ue) {
            let De = W.getValue();
            return g(W, X, ue, ue("left"), [" ", De.operator], "right");
          }
          function l(W, X, ue) {
            return g(W, X, ue, ue("id"), " =", "init");
          }
          function E(W, X, ue, De, ie) {
            let G = W.getValue(), z = G[ie];
            if (!z)
              return "only-left";
            let U = !x(z);
            if (W.match(x, b, (Ne) => !U || Ne.type !== "ExpressionStatement" && Ne.type !== "VariableDeclaration"))
              return U ? z.type === "ArrowFunctionExpression" && z.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
            if (!U && x(z.right) || d(X.originalText, z))
              return "break-after-operator";
            if (z.type === "CallExpression" && z.callee.name === "require" || X.parser === "json5" || X.parser === "json")
              return "never-break-after-operator";
            if (N(G) || L(G) || $2(G) || V(G) && m2(De))
              return "break-lhs";
            let Ae = ee(G, De, X);
            return W.call(() => y(W, X, ue, Ae), ie) ? "break-after-operator" : Ae || z.type === "TemplateLiteral" || z.type === "TaggedTemplateExpression" || z.type === "BooleanLiteral" || w(z) || z.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
          }
          function y(W, X, ue, De) {
            let ie = W.getValue();
            if (p2(ie) && !C(ie))
              return true;
            switch (ie.type) {
              case "StringLiteralTypeAnnotation":
              case "SequenceExpression":
                return true;
              case "ConditionalExpression": {
                let { test: U } = ie;
                return p2(U) && !C(U);
              }
              case "ClassExpression":
                return t(ie.decorators);
            }
            if (De)
              return false;
            let G = ie, z = [];
            for (; ; )
              if (G.type === "UnaryExpression")
                G = G.argument, z.push("argument");
              else if (G.type === "TSNonNullExpression")
                G = G.expression, z.push("expression");
              else
                break;
            return !!(f(G) || W.call(() => H(W, X, ue), ...z));
          }
          function N(W) {
            if (b(W)) {
              let X = W.left || W.id;
              return X.type === "ObjectPattern" && X.properties.length > 2 && X.properties.some((ue) => P(ue) && (!ue.shorthand || ue.value && ue.value.type === "AssignmentPattern"));
            }
            return false;
          }
          function x(W) {
            return W.type === "AssignmentExpression";
          }
          function b(W) {
            return x(W) || W.type === "VariableDeclarator";
          }
          function L(W) {
            let X = M(W);
            if (t(X)) {
              let ue = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
              if (X.length > 1 && X.some((De) => De[ue] || De.default))
                return true;
            }
            return false;
          }
          function M(W) {
            return j(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function j(W) {
            return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
          }
          function $2(W) {
            if (W.type !== "VariableDeclarator")
              return false;
            let { typeAnnotation: X } = W.id;
            if (!X || !X.typeAnnotation)
              return false;
            let ue = q(X.typeAnnotation);
            return t(ue) && ue.length > 1 && ue.some((De) => t(q(De)) || De.type === "TSConditionalType");
          }
          function V(W) {
            return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
          }
          function q(W) {
            return Y(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
          }
          function Y(W) {
            return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
          }
          function H(W, X, ue) {
            let De = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, ie = W.getValue(), G = () => H(W, X, ue, true);
            if (ie.type === "TSNonNullExpression")
              return W.call(G, "expression");
            if (T(ie)) {
              if (D(W, X, ue).label === "member-chain")
                return false;
              let U = S(ie);
              return !(U.length === 0 || U.length === 1 && Q(U[0], X)) || te(ie, ue) ? false : W.call(G, "callee");
            }
            return A(ie) ? W.call(G, "object") : De && (ie.type === "Identifier" || ie.type === "ThisExpression");
          }
          var R = 0.25;
          function Q(W, X) {
            let { printWidth: ue } = X;
            if (I(W))
              return false;
            let De = ue * R;
            if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= De || k(W) && !I(W.argument))
              return true;
            let ie = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
            return ie ? ie.length <= De : f(W) ? B(W).length <= De : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= De && !W.quasis[0].value.raw.includes(`
`) : h3(W);
          }
          function ee(W, X, ue) {
            if (!P(W))
              return false;
            X = c(X);
            let De = 3;
            return typeof X == "string" && s(X) < ue.tabWidth + De;
          }
          function te(W, X) {
            let ue = oe(W);
            if (t(ue)) {
              if (ue.length > 1)
                return true;
              if (ue.length === 1) {
                let ie = ue[0];
                if (ie.type === "TSUnionType" || ie.type === "UnionTypeAnnotation" || ie.type === "TSIntersectionType" || ie.type === "IntersectionTypeAnnotation" || ie.type === "TSTypeLiteral" || ie.type === "ObjectTypeAnnotation")
                  return true;
              }
              let De = W.typeParameters ? "typeParameters" : "typeArguments";
              if (v(X(De)))
                return true;
            }
            return false;
          }
          function oe(W) {
            return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
          }
          n.exports = { printVariableDeclarator: l, printAssignmentExpression: F, printAssignment: g, isArrowFunctionVariableDeclarator: V };
        } }), Pr = Z({ "src/language-js/print/function-parameters.js"(e, n) {
          "use strict";
          re();
          var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: r, softline: u, group: i, indent: o, ifBreak: c }, utils: { removeLines: v, willBreak: m2 } } = Oe(), { getFunctionParameters: d, iterateFunctionParametersPath: p2, isSimpleType: f, isTestCall: h3, isTypeAnnotationAFunction: w, isObjectType: T, isObjectTypePropertyAFunction: A, hasRestParameter: S, shouldPrintComma: B, hasComment: I, isNextLineEmpty: k } = Ke(), { locEnd: P } = st(), { ArgExpansionBailout: C } = zt(), { printFunctionTypeParameters: D } = ct();
          function g(y, N, x, b, L) {
            let M = y.getValue(), j = d(M), $2 = L ? D(y, x, N) : "";
            if (j.length === 0)
              return [$2, "(", s(y, x, true, (ee) => t(x.originalText, ee, P) === ")"), ")"];
            let V = y.getParentNode(), q = h3(V), Y = F(M), H = [];
            if (p2(y, (ee, te) => {
              let oe = te === j.length - 1;
              oe && M.rest && H.push("..."), H.push(N()), !oe && (H.push(","), q || Y ? H.push(" ") : k(j[te], x) ? H.push(r, r) : H.push(a));
            }), b) {
              if (m2($2) || m2(H))
                throw new C();
              return i([v($2), "(", v(H), ")"]);
            }
            let R = j.every((ee) => !ee.decorators);
            return Y && R ? [$2, "(", ...H, ")"] : q ? [$2, "(", ...H, ")"] : (A(V) || w(V) || V.type === "TypeAlias" || V.type === "UnionTypeAnnotation" || V.type === "TSUnionType" || V.type === "IntersectionTypeAnnotation" || V.type === "FunctionTypeAnnotation" && V.returnType === M) && j.length === 1 && j[0].name === null && M.this !== j[0] && j[0].typeAnnotation && M.typeParameters === null && f(j[0].typeAnnotation) && !M.rest ? x.arrowParens === "always" ? ["(", ...H, ")"] : H : [$2, "(", o([u, ...H]), c(!S(M) && B(x, "all") ? "," : ""), u, ")"];
          }
          function F(y) {
            if (!y)
              return false;
            let N = d(y);
            if (N.length !== 1)
              return false;
            let [x] = N;
            return !I(x) && (x.type === "ObjectPattern" || x.type === "ArrayPattern" || x.type === "Identifier" && x.typeAnnotation && (x.typeAnnotation.type === "TypeAnnotation" || x.typeAnnotation.type === "TSTypeAnnotation") && T(x.typeAnnotation.typeAnnotation) || x.type === "FunctionTypeParam" && T(x.typeAnnotation) || x.type === "AssignmentPattern" && (x.left.type === "ObjectPattern" || x.left.type === "ArrayPattern") && (x.right.type === "Identifier" || x.right.type === "ObjectExpression" && x.right.properties.length === 0 || x.right.type === "ArrayExpression" && x.right.elements.length === 0));
          }
          function l(y) {
            let N;
            return y.returnType ? (N = y.returnType, N.typeAnnotation && (N = N.typeAnnotation)) : y.typeAnnotation && (N = y.typeAnnotation), N;
          }
          function E(y, N) {
            let x = l(y);
            if (!x)
              return false;
            let b = y.typeParameters && y.typeParameters.params;
            if (b) {
              if (b.length > 1)
                return false;
              if (b.length === 1) {
                let L = b[0];
                if (L.constraint || L.default)
                  return false;
              }
            }
            return d(y).length === 1 && (T(x) || m2(N));
          }
          n.exports = { printFunctionParameters: g, shouldHugFunctionParameters: F, shouldGroupFunctionParameters: E };
        } }), kr = Z({ "src/language-js/print/type-annotation.js"(e, n) {
          "use strict";
          re();
          var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: r, join: u, line: i, softline: o, indent: c, align: v, ifBreak: m2 } } = Oe(), d = jt(), { locStart: p2 } = st(), { isSimpleType: f, isObjectType: h3, hasLeadingOwnLineComment: w, isObjectTypePropertyAFunction: T, shouldPrintComma: A } = Ke(), { printAssignment: S } = Yt(), { printFunctionParameters: B, shouldGroupFunctionParameters: I } = Pr(), { printArrayItems: k } = Kt();
          function P(x) {
            if (f(x) || h3(x))
              return true;
            if (x.type === "UnionTypeAnnotation" || x.type === "TSUnionType") {
              let b = x.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, L = x.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
              if (x.types.length - 1 === b && L)
                return true;
            }
            return false;
          }
          function C(x, b, L) {
            let M = b.semi ? ";" : "", j = x.getValue(), $2 = [];
            return $2.push("opaque type ", L("id"), L("typeParameters")), j.supertype && $2.push(": ", L("supertype")), j.impltype && $2.push(" = ", L("impltype")), $2.push(M), $2;
          }
          function D(x, b, L) {
            let M = b.semi ? ";" : "", j = x.getValue(), $2 = [];
            j.declare && $2.push("declare "), $2.push("type ", L("id"), L("typeParameters"));
            let V = j.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
            return [S(x, b, L, $2, " =", V), M];
          }
          function g(x, b, L) {
            let M = x.getValue(), j = x.map(L, "types"), $2 = [], V = false;
            for (let q = 0; q < j.length; ++q)
              q === 0 ? $2.push(j[q]) : h3(M.types[q - 1]) && h3(M.types[q]) ? $2.push([" & ", V ? c(j[q]) : j[q]]) : !h3(M.types[q - 1]) && !h3(M.types[q]) ? $2.push(c([" &", i, j[q]])) : (q > 1 && (V = true), $2.push(" & ", q > 1 ? c(j[q]) : j[q]));
            return r($2);
          }
          function F(x, b, L) {
            let M = x.getValue(), j = x.getParentNode(), $2 = j.type !== "TypeParameterInstantiation" && j.type !== "TSTypeParameterInstantiation" && j.type !== "GenericTypeAnnotation" && j.type !== "TSTypeReference" && j.type !== "TSTypeAssertion" && j.type !== "TupleTypeAnnotation" && j.type !== "TSTupleType" && !(j.type === "FunctionTypeParam" && !j.name && x.getParentNode(1).this !== j) && !((j.type === "TypeAlias" || j.type === "VariableDeclarator" || j.type === "TSTypeAliasDeclaration") && w(b.originalText, M)), V = P(M), q = x.map((R) => {
              let Q = L();
              return V || (Q = v(2, Q)), t(R, Q, b);
            }, "types");
            if (V)
              return u(" | ", q);
            let Y = $2 && !w(b.originalText, M), H = [m2([Y ? i : "", "| "]), u([i, "| "], q)];
            return d(x, b) ? r([c(H), o]) : j.type === "TupleTypeAnnotation" && j.types.length > 1 || j.type === "TSTupleType" && j.elementTypes.length > 1 ? r([c([m2(["(", o]), H]), o, m2(")")]) : r($2 ? c(H) : H);
          }
          function l(x, b, L) {
            let M = x.getValue(), j = [], $2 = x.getParentNode(0), V = x.getParentNode(1), q = x.getParentNode(2), Y = M.type === "TSFunctionType" || !(($2.type === "ObjectTypeProperty" || $2.type === "ObjectTypeInternalSlot") && !$2.variance && !$2.optional && p2($2) === p2(M) || $2.type === "ObjectTypeCallProperty" || q && q.type === "DeclareFunction"), H = Y && ($2.type === "TypeAnnotation" || $2.type === "TSTypeAnnotation"), R = H && Y && ($2.type === "TypeAnnotation" || $2.type === "TSTypeAnnotation") && V.type === "ArrowFunctionExpression";
            T($2) && (Y = true, H = true), R && j.push("(");
            let Q = B(x, L, b, false, true), ee = M.returnType || M.predicate || M.typeAnnotation ? [Y ? " => " : ": ", L("returnType"), L("predicate"), L("typeAnnotation")] : "", te = I(M, ee);
            return j.push(te ? r(Q) : Q), ee && j.push(ee), R && j.push(")"), r(j);
          }
          function E(x, b, L) {
            let M = x.getValue(), j = M.type === "TSTupleType" ? "elementTypes" : "types", $2 = M[j], V = a($2), q = V ? o : "";
            return r(["[", c([q, k(x, b, j, L)]), m2(V && A(b, "all") ? "," : ""), s(x, b, true), q, "]"]);
          }
          function y(x, b, L) {
            let M = x.getValue(), j = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
            return [L("objectType"), j, L("indexType"), "]"];
          }
          function N(x, b, L) {
            let M = x.getValue();
            return [M.postfix ? "" : L, b("typeAnnotation"), M.postfix ? L : ""];
          }
          n.exports = { printOpaqueType: C, printTypeAlias: D, printIntersectionType: g, printUnionType: F, printFunctionType: l, printTupleType: E, printIndexedAccessType: y, shouldHugType: P, printJSDocType: N };
        } }), Ir = Z({ "src/language-js/print/type-parameters.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: r, softline: u, group: i, indent: o, ifBreak: c } } = Oe(), { isTestCall: v, hasComment: m2, CommentCheckFlags: d, isTSXFile: p2, shouldPrintComma: f, getFunctionParameters: h3, isObjectType: w } = Ke(), { createGroupIdMapper: T } = Ue(), { shouldHugType: A } = kr(), { isArrowFunctionVariableDeclarator: S } = Yt(), B = T("typeParameters");
          function I(C, D, g, F) {
            let l = C.getValue();
            if (!l[F])
              return "";
            if (!Array.isArray(l[F]))
              return g(F);
            let E = C.getNode(2), y = E && v(E);
            if (!C.match((L) => !(L[F].length === 1 && w(L[F][0])), void 0, (L, M) => M === "typeAnnotation", (L) => L.type === "Identifier", S) && (y || l[F].length === 0 || l[F].length === 1 && (l[F][0].type === "NullableTypeAnnotation" || A(l[F][0]))))
              return ["<", s(", ", C.map(g, F)), k(C, D), ">"];
            let b = l.type === "TSTypeParameterInstantiation" ? "" : h3(l).length === 1 && p2(D) && !l[F][0].constraint && C.getParentNode().type === "ArrowFunctionExpression" ? "," : f(D, "all") ? c(",") : "";
            return i(["<", o([u, s([",", a], C.map(g, F))]), b, u, ">"], { id: B(l) });
          }
          function k(C, D) {
            let g = C.getValue();
            if (!m2(g, d.Dangling))
              return "";
            let F = !m2(g, d.Line), l = t(C, D, F);
            return F ? l : [l, r];
          }
          function P(C, D, g) {
            let F = C.getValue(), l = [], E = C.getParentNode();
            return E.type === "TSMappedType" ? (l.push("[", g("name")), F.constraint && l.push(" in ", g("constraint")), E.nameType && l.push(" as ", C.callParent(() => g("nameType"))), l.push("]"), l) : (F.variance && l.push(g("variance")), F.in && l.push("in "), F.out && l.push("out "), l.push(g("name")), F.bound && l.push(": ", g("bound")), F.constraint && l.push(" extends ", g("constraint")), F.default && l.push(" = ", g("default")), l);
          }
          n.exports = { printTypeParameter: P, printTypeParameters: I, getTypeParametersGroupId: B };
        } }), Qt = Z({ "src/language-js/print/property.js"(e, n) {
          "use strict";
          re();
          var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: r, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: o, rawText: c } = Ke(), { printAssignment: v } = Yt(), m2 = /* @__PURE__ */ new WeakMap();
          function d(f, h3, w) {
            let T = f.getNode();
            if (T.computed)
              return ["[", w("key"), "]"];
            let A = f.getParentNode(), { key: S } = T;
            if (T.type === "ClassPrivateProperty" && S.type === "Identifier")
              return ["#", w("key")];
            if (h3.quoteProps === "consistent" && !m2.has(A)) {
              let B = (A.properties || A.body || A.members).some((I) => !I.computed && I.key && i(I.key) && !o(I, h3));
              m2.set(A, B);
            }
            if ((S.type === "Identifier" || r(S) && u(a(c(S))) && String(S.value) === a(c(S)) && !(h3.parser === "typescript" || h3.parser === "babel-ts")) && (h3.parser === "json" || h3.quoteProps === "consistent" && m2.get(A))) {
              let B = s(JSON.stringify(S.type === "Identifier" ? S.name : S.value.toString()), h3);
              return f.call((I) => t(I, B, h3), "key");
            }
            return o(T, h3) && (h3.quoteProps === "as-needed" || h3.quoteProps === "consistent" && !m2.get(A)) ? f.call((B) => t(B, /^\d/.test(S.value) ? a(S.value) : S.value, h3), "key") : w("key");
          }
          function p2(f, h3, w) {
            return f.getValue().shorthand ? w("value") : v(f, h3, w, d(f, h3, w), ":", "value");
          }
          n.exports = { printProperty: p2, printPropertyKey: d };
        } }), Lr = Z({ "src/language-js/print/function.js"(e, n) {
          "use strict";
          re();
          var t = Xt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), r = it(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: o, group: c, indent: v, ifBreak: m2, hardline: d, join: p2, indentIfBreak: f }, utils: { removeLines: h3, willBreak: w } } = Oe(), { ArgExpansionBailout: T } = zt(), { getFunctionParameters: A, hasLeadingOwnLineComment: S, isFlowAnnotationComment: B, isJsxNode: I, isTemplateOnItsOwnLine: k, shouldPrintComma: P, startsWithNoLookaheadToken: C, isBinaryish: D, isLineComment: g, hasComment: F, getComments: l, CommentCheckFlags: E, isCallLikeExpression: y, isCallExpression: N, getCallArguments: x, hasNakedLeftSide: b, getLeftSide: L } = Ke(), { locEnd: M } = st(), { printFunctionParameters: j, shouldGroupFunctionParameters: $2 } = Pr(), { printPropertyKey: V } = Qt(), { printFunctionTypeParameters: q } = ct();
          function Y(z, U, le, ge) {
            let Ae = z.getValue(), Ne = false;
            if ((Ae.type === "FunctionDeclaration" || Ae.type === "FunctionExpression") && ge && ge.expandLastArg) {
              let ae = z.getParentNode();
              N(ae) && x(ae).length > 1 && (Ne = true);
            }
            let ke = [];
            Ae.type === "TSDeclareFunction" && Ae.declare && ke.push("declare "), Ae.async && ke.push("async "), Ae.generator ? ke.push("function* ") : ke.push("function "), Ae.id && ke.push(U("id"));
            let ce = j(z, U, le, Ne), pe = X(z, U, le), de = $2(Ae, pe);
            return ke.push(q(z, le, U), c([de ? c(ce) : ce, pe]), Ae.body ? " " : "", U("body")), le.semi && (Ae.declare || !Ae.body) && ke.push(";"), ke;
          }
          function H(z, U, le) {
            let ge = z.getNode(), { kind: Ae } = ge, Ne = ge.value || ge, ke = [];
            return !Ae || Ae === "init" || Ae === "method" || Ae === "constructor" ? Ne.async && ke.push("async ") : (t.ok(Ae === "get" || Ae === "set"), ke.push(Ae, " ")), Ne.generator && ke.push("*"), ke.push(V(z, U, le), ge.optional || ge.key.optional ? "?" : ""), ge === Ne ? ke.push(R(z, U, le)) : Ne.type === "FunctionExpression" ? ke.push(z.call((ce) => R(ce, U, le), "value")) : ke.push(le("value")), ke;
          }
          function R(z, U, le) {
            let ge = z.getNode(), Ae = j(z, le, U), Ne = X(z, le, U), ke = $2(ge, Ne), ce = [q(z, U, le), c([ke ? c(Ae) : Ae, Ne])];
            return ge.body ? ce.push(" ", le("body")) : ce.push(U.semi ? ";" : ""), ce;
          }
          function Q(z, U, le, ge) {
            let Ae = z.getValue(), Ne = [];
            if (Ae.async && Ne.push("async "), W(z, U))
              Ne.push(le(["params", 0]));
            else {
              let ce = ge && (ge.expandLastArg || ge.expandFirstArg), pe = X(z, le, U);
              if (ce) {
                if (w(pe))
                  throw new T();
                pe = c(h3(pe));
              }
              Ne.push(c([j(z, le, U, ce, true), pe]));
            }
            let ke = s(z, U, true, (ce) => {
              let pe = u(U.originalText, ce, M);
              return pe !== false && U.originalText.slice(pe, pe + 2) === "=>";
            });
            return ke && Ne.push(" ", ke), Ne;
          }
          function ee(z, U, le, ge, Ae, Ne) {
            let ke = z.getName(), ce = z.getParentNode(), pe = y(ce) && ke === "callee", de = Boolean(U && U.assignmentLayout), ae = Ne.body.type !== "BlockStatement" && Ne.body.type !== "ObjectExpression" && Ne.body.type !== "SequenceExpression", ve = pe && ae || U && U.assignmentLayout === "chain-tail-arrow-chain", K = Symbol("arrow-chain");
            return Ne.body.type === "SequenceExpression" && (Ae = c(["(", v([o, Ae]), o, ")"])), c([c(v([pe || de ? o : "", c(p2([" =>", i], le), { shouldBreak: ge })]), { id: K, shouldBreak: ve }), " =>", f(ae ? v([i, Ae]) : [" ", Ae], { groupId: K }), pe ? m2(o, "", { groupId: K }) : ""]);
          }
          function te(z, U, le, ge) {
            let Ae = z.getValue(), Ne = [], ke = [], ce = false;
            if (function K() {
              let he = Q(z, U, le, ge);
              if (Ne.length === 0)
                Ne.push(he);
              else {
                let { leading: ye, trailing: Ce } = a(z, U);
                Ne.push([ye, he]), ke.unshift(Ce);
              }
              ce = ce || Ae.returnType && A(Ae).length > 0 || Ae.typeParameters || A(Ae).some((ye) => ye.type !== "Identifier"), Ae.body.type !== "ArrowFunctionExpression" || ge && ge.expandLastArg ? ke.unshift(le("body", ge)) : (Ae = Ae.body, z.call(K, "body"));
            }(), Ne.length > 1)
              return ee(z, ge, Ne, ce, ke, Ae);
            let pe = Ne;
            if (pe.push(" =>"), !S(U.originalText, Ae.body) && (Ae.body.type === "ArrayExpression" || Ae.body.type === "ObjectExpression" || Ae.body.type === "BlockStatement" || I(Ae.body) || k(Ae.body, U.originalText) || Ae.body.type === "ArrowFunctionExpression" || Ae.body.type === "DoExpression"))
              return c([...pe, " ", ke]);
            if (Ae.body.type === "SequenceExpression")
              return c([...pe, c([" (", v([o, ke]), o, ")"])]);
            let de = (ge && ge.expandLastArg || z.getParentNode().type === "JSXExpressionContainer") && !F(Ae), ae = ge && ge.expandLastArg && P(U, "all"), ve = Ae.body.type === "ConditionalExpression" && !C(Ae.body, false);
            return c([...pe, c([v([i, ve ? m2("", "(") : "", ke, ve ? m2("", ")") : ""]), de ? [m2(ae ? "," : ""), o] : ""])]);
          }
          function oe(z) {
            let U = A(z);
            return U.length === 1 && !z.typeParameters && !F(z, E.Dangling) && U[0].type === "Identifier" && !U[0].typeAnnotation && !F(U[0]) && !U[0].optional && !z.predicate && !z.returnType;
          }
          function W(z, U) {
            if (U.arrowParens === "always")
              return false;
            if (U.arrowParens === "avoid") {
              let le = z.getValue();
              return oe(le);
            }
            return false;
          }
          function X(z, U, le) {
            let ge = z.getValue(), Ae = U("returnType");
            if (ge.returnType && B(le.originalText, ge.returnType))
              return [" /*: ", Ae, " */"];
            let Ne = [Ae];
            return ge.returnType && ge.returnType.typeAnnotation && Ne.unshift(": "), ge.predicate && Ne.push(ge.returnType ? " " : ": ", U("predicate")), Ne;
          }
          function ue(z, U, le) {
            let ge = z.getValue(), Ae = U.semi ? ";" : "", Ne = [];
            ge.argument && (G(U, ge.argument) ? Ne.push([" (", v([d, le("argument")]), d, ")"]) : D(ge.argument) || ge.argument.type === "SequenceExpression" ? Ne.push(c([m2(" (", " "), v([o, le("argument")]), o, m2(")")])) : Ne.push(" ", le("argument")));
            let ke = l(ge), ce = r(ke), pe = ce && g(ce);
            return pe && Ne.push(Ae), F(ge, E.Dangling) && Ne.push(" ", s(z, U, true)), pe || Ne.push(Ae), Ne;
          }
          function De(z, U, le) {
            return ["return", ue(z, U, le)];
          }
          function ie(z, U, le) {
            return ["throw", ue(z, U, le)];
          }
          function G(z, U) {
            if (S(z.originalText, U))
              return true;
            if (b(U)) {
              let le = U, ge;
              for (; ge = L(le); )
                if (le = ge, S(z.originalText, le))
                  return true;
            }
            return false;
          }
          n.exports = { printFunction: Y, printArrowFunction: te, printMethod: H, printReturnStatement: De, printThrowStatement: ie, printMethodInternal: R, shouldPrintParamsWithoutParens: W };
        } }), Un = Z({ "src/language-js/print/decorators.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: r, join: u, breakParent: i, group: o } } = Oe(), { locStart: c, locEnd: v } = st(), { getParentExportDeclaration: m2 } = Ke();
          function d(T, A, S) {
            let B = T.getValue();
            return o([u(a, T.map(S, "decorators")), h3(B, A) ? r : a]);
          }
          function p2(T, A, S) {
            return [u(r, T.map(S, "declaration", "decorators")), r];
          }
          function f(T, A, S) {
            let B = T.getValue(), { decorators: I } = B;
            if (!t(I) || w(T.getParentNode()))
              return;
            let k = B.type === "ClassExpression" || B.type === "ClassDeclaration" || h3(B, A);
            return [m2(T) ? r : k ? i : "", u(a, T.map(S, "decorators")), a];
          }
          function h3(T, A) {
            return T.decorators.some((S) => s(A.originalText, v(S)));
          }
          function w(T) {
            if (T.type !== "ExportDefaultDeclaration" && T.type !== "ExportNamedDeclaration" && T.type !== "DeclareExportDeclaration")
              return false;
            let A = T.declaration && T.declaration.decorators;
            return t(A) && c(T, { ignoreDecorators: true }) > c(A[0]);
          }
          n.exports = { printDecorators: f, printClassMemberDecorators: d, printDecoratorsBeforeExport: p2, hasDecoratorsBeforeExport: w };
        } }), Zt = Z({ "src/language-js/print/class.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: r } = et(), { builders: { join: u, line: i, hardline: o, softline: c, group: v, indent: m2, ifBreak: d } } = Oe(), { hasComment: p2, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: h3 } = Ir(), { printMethod: w } = Lr(), { printOptionalToken: T, printTypeAnnotation: A, printDefiniteToken: S } = ct(), { printPropertyKey: B } = Qt(), { printAssignment: I } = Yt(), { printClassMemberDecorators: k } = Un();
          function P(x, b, L) {
            let M = x.getValue(), j = [];
            M.declare && j.push("declare "), M.abstract && j.push("abstract "), j.push("class");
            let $2 = M.id && p2(M.id, f.Trailing) || M.typeParameters && p2(M.typeParameters, f.Trailing) || M.superClass && p2(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), V = [], q = [];
            if (M.id && V.push(" ", L("id")), V.push(L("typeParameters")), M.superClass) {
              let Y = [E(x, b, L), L("superTypeParameters")], H = x.call((R) => ["extends ", a(R, Y, b)], "superClass");
              $2 ? q.push(i, v(H)) : q.push(" ", H);
            } else
              q.push(l(x, b, L, "extends"));
            if (q.push(l(x, b, L, "mixins"), l(x, b, L, "implements")), $2) {
              let Y;
              F(M) ? Y = [...V, m2(q)] : Y = m2([...V, q]), j.push(v(Y, { id: C(M) }));
            } else
              j.push(...V, ...q);
            return j.push(" ", L("body")), j;
          }
          var C = s("heritageGroup");
          function D(x) {
            return d(o, "", { groupId: C(x) });
          }
          function g(x) {
            return ["superClass", "extends", "mixins", "implements"].filter((b) => Boolean(x[b])).length > 1;
          }
          function F(x) {
            return x.typeParameters && !p2(x.typeParameters, f.Trailing | f.Line) && !g(x);
          }
          function l(x, b, L, M) {
            let j = x.getValue();
            if (!t(j[M]))
              return "";
            let $2 = r(x, b, true, (V) => {
              let { marker: q } = V;
              return q === M;
            });
            return [F(j) ? d(" ", i, { groupId: h3(j.typeParameters) }) : i, $2, $2 && o, M, v(m2([i, u([",", i], x.map(L, M))]))];
          }
          function E(x, b, L) {
            let M = L("superClass");
            return x.getParentNode().type === "AssignmentExpression" ? v(d(["(", m2([c, M]), c, ")"], M)) : M;
          }
          function y(x, b, L) {
            let M = x.getValue(), j = [];
            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.readonly && j.push("readonly "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), j.push(w(x, b, L)), j;
          }
          function N(x, b, L) {
            let M = x.getValue(), j = [], $2 = b.semi ? ";" : "";
            return t(M.decorators) && j.push(k(x, b, L)), M.accessibility && j.push(M.accessibility + " "), M.declare && j.push("declare "), M.static && j.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.abstract) && j.push("abstract "), M.override && j.push("override "), M.readonly && j.push("readonly "), M.variance && j.push(L("variance")), M.type === "ClassAccessorProperty" && j.push("accessor "), j.push(B(x, b, L), T(x), S(x), A(x, b, L)), [I(x, b, L, j, " =", "value"), $2];
          }
          n.exports = { printClass: P, printClassMethod: y, printClassProperty: N, printHardlineAfterHeritage: D };
        } }), lo = Z({ "src/language-js/print/interface.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: r, indent: u, ifBreak: i } } = Oe(), { hasComment: o, identity: c, CommentCheckFlags: v } = Ke(), { getTypeParametersGroupId: m2 } = Ir(), { printTypeScriptModifiers: d } = ct();
          function p2(f, h3, w) {
            let T = f.getValue(), A = [];
            T.declare && A.push("declare "), T.type === "TSInterfaceDeclaration" && A.push(T.abstract ? "abstract " : "", d(f, h3, w)), A.push("interface");
            let S = [], B = [];
            T.type !== "InterfaceTypeAnnotation" && S.push(" ", w("id"), w("typeParameters"));
            let I = T.typeParameters && !o(T.typeParameters, v.Trailing | v.Line);
            return t(T.extends) && B.push(I ? i(" ", a, { groupId: m2(T.typeParameters) }) : a, "extends ", (T.extends.length === 1 ? c : u)(s([",", a], f.map(w, "extends")))), T.id && o(T.id, v.Trailing) || t(T.extends) ? I ? A.push(r([...S, u(B)])) : A.push(r(u([...S, ...B]))) : A.push(...S, ...B), A.push(" ", w("body")), r(A);
          }
          n.exports = { printInterface: p2 };
        } }), co = Z({ "src/language-js/print/module.js"(e, n) {
          "use strict";
          re();
          var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: r, join: u, line: i, ifBreak: o, hardline: c } } = Oe(), { printDanglingComments: v } = et(), { hasComment: m2, CommentCheckFlags: d, shouldPrintComma: p2, needsHardlineAfterDanglingComment: f, isStringLiteral: h3, rawText: w } = Ke(), { locStart: T, hasSameLoc: A } = st(), { hasDecoratorsBeforeExport: S, printDecoratorsBeforeExport: B } = Un();
          function I(N, x, b) {
            let L = N.getValue(), M = x.semi ? ";" : "", j = [], { importKind: $2 } = L;
            return j.push("import"), $2 && $2 !== "value" && j.push(" ", $2), j.push(g(N, x, b), D(N, x, b), l(N, x, b), M), j;
          }
          function k(N, x, b) {
            let L = N.getValue(), M = [];
            S(L) && M.push(B(N, x, b));
            let { type: j, exportKind: $2, declaration: V } = L;
            return M.push("export"), (L.default || j === "ExportDefaultDeclaration") && M.push(" default"), m2(L, d.Dangling) && (M.push(" ", v(N, x, true)), f(L) && M.push(c)), V ? M.push(" ", b("declaration")) : M.push($2 === "type" ? " type" : "", g(N, x, b), D(N, x, b), l(N, x, b)), C(L, x) && M.push(";"), M;
          }
          function P(N, x, b) {
            let L = N.getValue(), M = x.semi ? ";" : "", j = [], { exportKind: $2, exported: V } = L;
            return j.push("export"), $2 === "type" && j.push(" type"), j.push(" *"), V && j.push(" as ", b("exported")), j.push(D(N, x, b), l(N, x, b), M), j;
          }
          function C(N, x) {
            if (!x.semi)
              return false;
            let { type: b, declaration: L } = N, M = N.default || b === "ExportDefaultDeclaration";
            if (!L)
              return true;
            let { type: j } = L;
            return !!(M && j !== "ClassDeclaration" && j !== "FunctionDeclaration" && j !== "TSInterfaceDeclaration" && j !== "DeclareClass" && j !== "DeclareFunction" && j !== "TSDeclareFunction" && j !== "EnumDeclaration");
          }
          function D(N, x, b) {
            let L = N.getValue();
            if (!L.source)
              return "";
            let M = [];
            return F(L, x) || M.push(" from"), M.push(" ", b("source")), M;
          }
          function g(N, x, b) {
            let L = N.getValue();
            if (F(L, x))
              return "";
            let M = [" "];
            if (t(L.specifiers)) {
              let j = [], $2 = [];
              N.each(() => {
                let V = N.getValue().type;
                if (V === "ExportNamespaceSpecifier" || V === "ExportDefaultSpecifier" || V === "ImportNamespaceSpecifier" || V === "ImportDefaultSpecifier")
                  j.push(b());
                else if (V === "ExportSpecifier" || V === "ImportSpecifier")
                  $2.push(b());
                else
                  throw new Error("Unknown specifier type ".concat(JSON.stringify(V)));
              }, "specifiers"), M.push(u(", ", j)), $2.length > 0 && (j.length > 0 && M.push(", "), $2.length > 1 || j.length > 0 || L.specifiers.some((q) => m2(q)) ? M.push(a(["{", r([x.bracketSpacing ? i : s, u([",", i], $2)]), o(p2(x) ? "," : ""), x.bracketSpacing ? i : s, "}"])) : M.push(["{", x.bracketSpacing ? " " : "", ...$2, x.bracketSpacing ? " " : "", "}"]));
            } else
              M.push("{}");
            return M;
          }
          function F(N, x) {
            let { type: b, importKind: L, source: M, specifiers: j } = N;
            return b !== "ImportDeclaration" || t(j) || L === "type" ? false : !/{\s*}/.test(x.originalText.slice(T(N), T(M)));
          }
          function l(N, x, b) {
            let L = N.getNode();
            return t(L.assertions) ? [" assert {", x.bracketSpacing ? " " : "", u(", ", N.map(b, "assertions")), x.bracketSpacing ? " " : "", "}"] : "";
          }
          function E(N, x, b) {
            let L = N.getNode(), { type: M } = L, j = [], $2 = M === "ImportSpecifier" ? L.importKind : L.exportKind;
            $2 && $2 !== "value" && j.push($2, " ");
            let V = M.startsWith("Import"), q = V ? "imported" : "local", Y = V ? "local" : "exported", H = L[q], R = L[Y], Q = "", ee = "";
            return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Q = "*" : H && (Q = b(q)), R && !y(L) && (ee = b(Y)), j.push(Q, Q && ee ? " as " : "", ee), j;
          }
          function y(N) {
            if (N.type !== "ImportSpecifier" && N.type !== "ExportSpecifier")
              return false;
            let { local: x, [N.type === "ImportSpecifier" ? "imported" : "exported"]: b } = N;
            if (x.type !== b.type || !A(x, b))
              return false;
            if (h3(x))
              return x.value === b.value && w(x) === w(b);
            switch (x.type) {
              case "Identifier":
                return x.name === b.name;
              default:
                return false;
            }
          }
          n.exports = { printImportDeclaration: I, printExportDeclaration: k, printExportAllDeclaration: P, printModuleSpecifier: E };
        } }), zn = Z({ "src/language-js/print/object.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: r, indent: u, ifBreak: i, hardline: o } } = Oe(), { getLast: c, hasNewlineInRange: v, hasNewline: m2, isNonEmptyArray: d } = Ue(), { shouldPrintComma: p2, hasComment: f, getComments: h3, CommentCheckFlags: w, isNextLineEmpty: T } = Ke(), { locStart: A, locEnd: S } = st(), { printOptionalToken: B, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: k } = Pr(), { shouldHugType: P } = kr(), { printHardlineAfterHeritage: C } = Zt();
          function D(g, F, l) {
            let E = F.semi ? ";" : "", y = g.getValue(), N;
            y.type === "TSTypeLiteral" ? N = "members" : y.type === "TSInterfaceBody" ? N = "body" : N = "properties";
            let x = y.type === "ObjectTypeAnnotation", b = [N];
            x && b.push("indexers", "callProperties", "internalSlots");
            let L = b.map((W) => y[W][0]).sort((W, X) => A(W) - A(X))[0], M = g.getParentNode(0), j = x && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && g.getName() === "body", $2 = y.type === "TSInterfaceBody" || j || y.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && y.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || y.type !== "ObjectPattern" && L && v(F.originalText, A(y), A(L)), V = j ? ";" : y.type === "TSInterfaceBody" || y.type === "TSTypeLiteral" ? i(E, ";") : ",", q = y.type === "RecordExpression" ? "#{" : y.exact ? "{|" : "{", Y = y.exact ? "|}" : "}", H = [];
            for (let W of b)
              g.each((X) => {
                let ue = X.getValue();
                H.push({ node: ue, printed: l(), loc: A(ue) });
              }, W);
            b.length > 1 && H.sort((W, X) => W.loc - X.loc);
            let R = [], Q = H.map((W) => {
              let X = [...R, r(W.printed)];
              return R = [V, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, w.PrettierIgnore) && R.shift(), T(W.node, F) && R.push(o), X;
            });
            if (y.inexact) {
              let W;
              if (f(y, w.Dangling)) {
                let X = f(y, w.Line);
                W = [t(g, F, true), X || m2(F.originalText, S(c(h3(y)))) ? o : s, "..."];
              } else
                W = ["..."];
              Q.push([...R, ...W]);
            }
            let ee = c(y[N]), te = !(y.inexact || ee && ee.type === "RestElement" || ee && (ee.type === "TSPropertySignature" || ee.type === "TSCallSignatureDeclaration" || ee.type === "TSMethodSignature" || ee.type === "TSConstructSignatureDeclaration") && f(ee, w.PrettierIgnore)), oe;
            if (Q.length === 0) {
              if (!f(y, w.Dangling))
                return [q, Y, I(g, F, l)];
              oe = r([q, t(g, F), a, Y, B(g), I(g, F, l)]);
            } else
              oe = [j && d(y.properties) ? C(M) : "", q, u([F.bracketSpacing ? s : a, ...Q]), i(te && (V !== "," || p2(F)) ? V : ""), F.bracketSpacing ? s : a, Y, B(g), I(g, F, l)];
            return g.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, X, ue) => k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0) || g.match(P, (W, X) => X === "typeAnnotation", (W, X) => X === "typeAnnotation", (W, X, ue) => k(W) && (X === "params" || X === "parameters" || X === "this" || X === "rest") && ue === 0) || !$2 && g.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? oe : r(oe, { shouldBreak: $2 });
          }
          n.exports = { printObject: D };
        } }), Um = Z({ "src/language-js/print/flow.js"(e, n) {
          "use strict";
          re();
          var t = Xt(), { printDanglingComments: s } = et(), { printString: a, printNumber: r } = Ue(), { builders: { hardline: u, softline: i, group: o, indent: c } } = Oe(), { getParentExportDeclaration: v, isFunctionNotation: m2, isGetterOrSetter: d, rawText: p2, shouldPrintComma: f } = Ke(), { locStart: h3, locEnd: w } = st(), { printClass: T } = Zt(), { printOpaqueType: A, printTypeAlias: S, printIntersectionType: B, printUnionType: I, printFunctionType: k, printTupleType: P, printIndexedAccessType: C } = kr(), { printInterface: D } = lo(), { printTypeParameter: g, printTypeParameters: F } = Ir(), { printExportDeclaration: l, printExportAllDeclaration: E } = co(), { printArrayItems: y } = Kt(), { printObject: N } = zn(), { printPropertyKey: x } = Qt(), { printOptionalToken: b, printTypeAnnotation: L, printRestSpread: M } = ct();
          function j(V, q, Y) {
            let H = V.getValue(), R = q.semi ? ";" : "", Q = [];
            switch (H.type) {
              case "DeclareClass":
                return $2(V, T(V, q, Y));
              case "DeclareFunction":
                return $2(V, ["function ", Y("id"), H.predicate ? " " : "", Y("predicate"), R]);
              case "DeclareModule":
                return $2(V, ["module ", Y("id"), " ", Y("body")]);
              case "DeclareModuleExports":
                return $2(V, ["module.exports", ": ", Y("typeAnnotation"), R]);
              case "DeclareVariable":
                return $2(V, ["var ", Y("id"), R]);
              case "DeclareOpaqueType":
                return $2(V, A(V, q, Y));
              case "DeclareInterface":
                return $2(V, D(V, q, Y));
              case "DeclareTypeAlias":
                return $2(V, S(V, q, Y));
              case "DeclareExportDeclaration":
                return $2(V, l(V, q, Y));
              case "DeclareExportAllDeclaration":
                return $2(V, E(V, q, Y));
              case "OpaqueType":
                return A(V, q, Y);
              case "TypeAlias":
                return S(V, q, Y);
              case "IntersectionTypeAnnotation":
                return B(V, q, Y);
              case "UnionTypeAnnotation":
                return I(V, q, Y);
              case "FunctionTypeAnnotation":
                return k(V, q, Y);
              case "TupleTypeAnnotation":
                return P(V, q, Y);
              case "GenericTypeAnnotation":
                return [Y("id"), F(V, q, Y, "typeParameters")];
              case "IndexedAccessType":
              case "OptionalIndexedAccessType":
                return C(V, q, Y);
              case "TypeAnnotation":
                return Y("typeAnnotation");
              case "TypeParameter":
                return g(V, q, Y);
              case "TypeofTypeAnnotation":
                return ["typeof ", Y("argument")];
              case "ExistsTypeAnnotation":
                return "*";
              case "EmptyTypeAnnotation":
                return "empty";
              case "MixedTypeAnnotation":
                return "mixed";
              case "ArrayTypeAnnotation":
                return [Y("elementType"), "[]"];
              case "BooleanLiteralTypeAnnotation":
                return String(H.value);
              case "EnumDeclaration":
                return ["enum ", Y("id"), " ", Y("body")];
              case "EnumBooleanBody":
              case "EnumNumberBody":
              case "EnumStringBody":
              case "EnumSymbolBody": {
                if (H.type === "EnumSymbolBody" || H.explicitType) {
                  let ee = null;
                  switch (H.type) {
                    case "EnumBooleanBody":
                      ee = "boolean";
                      break;
                    case "EnumNumberBody":
                      ee = "number";
                      break;
                    case "EnumStringBody":
                      ee = "string";
                      break;
                    case "EnumSymbolBody":
                      ee = "symbol";
                      break;
                  }
                  Q.push("of ", ee, " ");
                }
                if (H.members.length === 0 && !H.hasUnknownMembers)
                  Q.push(o(["{", s(V, q), i, "}"]));
                else {
                  let ee = H.members.length > 0 ? [u, y(V, q, "members", Y), H.hasUnknownMembers || f(q) ? "," : ""] : [];
                  Q.push(o(["{", c([...ee, ...H.hasUnknownMembers ? [u, "..."] : []]), s(V, q, true), u, "}"]));
                }
                return Q;
              }
              case "EnumBooleanMember":
              case "EnumNumberMember":
              case "EnumStringMember":
                return [Y("id"), " = ", typeof H.init == "object" ? Y("init") : String(H.init)];
              case "EnumDefaultedMember":
                return Y("id");
              case "FunctionTypeParam": {
                let ee = H.name ? Y("name") : V.getParentNode().this === H ? "this" : "";
                return [ee, b(V), ee ? ": " : "", Y("typeAnnotation")];
              }
              case "InterfaceDeclaration":
              case "InterfaceTypeAnnotation":
                return D(V, q, Y);
              case "ClassImplements":
              case "InterfaceExtends":
                return [Y("id"), Y("typeParameters")];
              case "NullableTypeAnnotation":
                return ["?", Y("typeAnnotation")];
              case "Variance": {
                let { kind: ee } = H;
                return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
              }
              case "ObjectTypeCallProperty":
                return H.static && Q.push("static "), Q.push(Y("value")), Q;
              case "ObjectTypeIndexer":
                return [H.static ? "static " : "", H.variance ? Y("variance") : "", "[", Y("id"), H.id ? ": " : "", Y("key"), "]: ", Y("value")];
              case "ObjectTypeProperty": {
                let ee = "";
                return H.proto ? ee = "proto " : H.static && (ee = "static "), [ee, d(H) ? H.kind + " " : "", H.variance ? Y("variance") : "", x(V, q, Y), b(V), m2(H) ? "" : ": ", Y("value")];
              }
              case "ObjectTypeAnnotation":
                return N(V, q, Y);
              case "ObjectTypeInternalSlot":
                return [H.static ? "static " : "", "[[", Y("id"), "]]", b(V), H.method ? "" : ": ", Y("value")];
              case "ObjectTypeSpreadProperty":
                return M(V, q, Y);
              case "QualifiedTypeofIdentifier":
              case "QualifiedTypeIdentifier":
                return [Y("qualification"), ".", Y("id")];
              case "StringLiteralTypeAnnotation":
                return a(p2(H), q);
              case "NumberLiteralTypeAnnotation":
                t.strictEqual(typeof H.value, "number");
              case "BigIntLiteralTypeAnnotation":
                return H.extra ? r(H.extra.raw) : r(H.raw);
              case "TypeCastExpression":
                return ["(", Y("expression"), L(V, q, Y), ")"];
              case "TypeParameterDeclaration":
              case "TypeParameterInstantiation": {
                let ee = F(V, q, Y, "params");
                if (q.parser === "flow") {
                  let te = h3(H), oe = w(H), W = q.originalText.lastIndexOf("/*", te), X = q.originalText.indexOf("*/", oe);
                  if (W !== -1 && X !== -1) {
                    let ue = q.originalText.slice(W + 2, X).trim();
                    if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/"))
                      return ["/*:: ", ee, " */"];
                  }
                }
                return ee;
              }
              case "InferredPredicate":
                return "%checks";
              case "DeclaredPredicate":
                return ["%checks(", Y("value"), ")"];
              case "AnyTypeAnnotation":
                return "any";
              case "BooleanTypeAnnotation":
                return "boolean";
              case "BigIntTypeAnnotation":
                return "bigint";
              case "NullLiteralTypeAnnotation":
                return "null";
              case "NumberTypeAnnotation":
                return "number";
              case "SymbolTypeAnnotation":
                return "symbol";
              case "StringTypeAnnotation":
                return "string";
              case "VoidTypeAnnotation":
                return "void";
              case "ThisTypeAnnotation":
                return "this";
              case "Node":
              case "Printable":
              case "SourceLocation":
              case "Position":
              case "Statement":
              case "Function":
              case "Pattern":
              case "Expression":
              case "Declaration":
              case "Specifier":
              case "NamedSpecifier":
              case "Comment":
              case "MemberTypeAnnotation":
              case "Type":
                throw new Error("unprintable type: " + JSON.stringify(H.type));
            }
          }
          function $2(V, q) {
            let Y = v(V);
            return Y ? (t.strictEqual(Y.type, "DeclareExportDeclaration"), q) : ["declare ", q];
          }
          n.exports = { printFlow: j };
        } }), zm = Z({ "src/language-js/utils/is-ts-keyword-type.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            let { type: a } = s;
            return a.startsWith("TS") && a.endsWith("Keyword");
          }
          n.exports = t;
        } }), po = Z({ "src/language-js/print/ternary.js"(e, n) {
          "use strict";
          re();
          var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: r, isMemberExpression: u } = Ke(), { locStart: i, locEnd: o } = st(), c = It(), { builders: { line: v, softline: m2, group: d, indent: p2, align: f, ifBreak: h3, dedent: w, breakParent: T } } = Oe();
          function A(P) {
            let C = [P];
            for (let D = 0; D < C.length; D++) {
              let g = C[D];
              for (let F of ["test", "consequent", "alternate"]) {
                let l = g[F];
                if (s(l))
                  return true;
                l.type === "ConditionalExpression" && C.push(l);
              }
            }
            return false;
          }
          function S(P, C, D) {
            let g = P.getValue(), F = g.type === "ConditionalExpression", l = F ? "alternate" : "falseType", E = P.getParentNode(), y = F ? D("test") : [D("checkType"), " ", "extends", " ", D("extendsType")];
            return E.type === g.type && E[l] === g ? f(2, y) : y;
          }
          var B = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
          function I(P) {
            let C = P.getValue();
            if (C.type !== "ConditionalExpression")
              return false;
            let D, g = C;
            for (let F = 0; !D; F++) {
              let l = P.getParentNode(F);
              if (r(l) && l.callee === g || u(l) && l.object === g || l.type === "TSNonNullExpression" && l.expression === g) {
                g = l;
                continue;
              }
              l.type === "NewExpression" && l.callee === g || l.type === "TSAsExpression" && l.expression === g ? (D = P.getParentNode(F + 1), g = l) : D = l;
            }
            return g === C ? false : D[B.get(D.type)] === g;
          }
          function k(P, C, D) {
            let g = P.getValue(), F = g.type === "ConditionalExpression", l = F ? "consequent" : "trueType", E = F ? "alternate" : "falseType", y = F ? ["test"] : ["checkType", "extendsType"], N = g[l], x = g[E], b = [], L = false, M = P.getParentNode(), j = M.type === g.type && y.some((ue) => M[ue] === g), $2 = M.type === g.type && !j, V, q, Y = 0;
            do
              q = V || g, V = P.getParentNode(Y), Y++;
            while (V && V.type === g.type && y.every((ue) => V[ue] !== q));
            let H = V || M, R = q;
            if (F && (s(g[y[0]]) || s(N) || s(x) || A(R))) {
              L = true, $2 = true;
              let ue = (ie) => [h3("("), p2([m2, ie]), m2, h3(")")], De = (ie) => ie.type === "NullLiteral" || ie.type === "Literal" && ie.value === null || ie.type === "Identifier" && ie.name === "undefined";
              b.push(" ? ", De(N) ? D(l) : ue(D(l)), " : ", x.type === g.type || De(x) ? D(E) : ue(D(E)));
            } else {
              let ue = [v, "? ", N.type === g.type ? h3("", "(") : "", f(2, D(l)), N.type === g.type ? h3("", ")") : "", v, ": ", x.type === g.type ? D(E) : f(2, D(E))];
              b.push(M.type !== g.type || M[E] === g || j ? ue : C.useTabs ? w(p2(ue)) : f(Math.max(0, C.tabWidth - 2), ue));
            }
            let ee = [...y.map((ue) => a(g[ue])), a(N), a(x)].flat().some((ue) => c(ue) && t(C.originalText, i(ue), o(ue))), te = (ue) => M === H ? d(ue, { shouldBreak: ee }) : ee ? [ue, T] : ue, oe = !L && (u(M) || M.type === "NGPipeExpression" && M.left === g) && !M.computed, W = I(P), X = te([S(P, C, D), $2 ? b : p2(b), F && oe && !W ? m2 : ""]);
            return j || W ? d([p2([m2, X]), m2]) : X;
          }
          n.exports = { printTernary: k };
        } }), fo = Z({ "src/language-js/print/statement.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t } } = Oe(), s = jt(), { getLeftSidePathName: a, hasNakedLeftSide: r, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: o, CommentCheckFlags: c, isNextLineEmpty: v } = Ke(), { shouldPrintParamsWithoutParens: m2 } = Lr();
          function d(B, I, k, P) {
            let C = B.getValue(), D = [], g = C.type === "ClassBody", F = p2(C[P]);
            return B.each((l, E, y) => {
              let N = l.getValue();
              if (N.type === "EmptyStatement")
                return;
              let x = k();
              !I.semi && !g && !i(I, l) && f(l, I) ? o(N, c.Leading) ? D.push(k([], { needsSemi: true })) : D.push(";", x) : D.push(x), !I.semi && g && A(N) && S(N, y[E + 1]) && D.push(";"), N !== F && (D.push(t), v(N, I) && D.push(t));
            }, P), D;
          }
          function p2(B) {
            for (let I = B.length - 1; I >= 0; I--) {
              let k = B[I];
              if (k.type !== "EmptyStatement")
                return k;
            }
          }
          function f(B, I) {
            return B.getNode().type !== "ExpressionStatement" ? false : B.call((P) => h3(P, I), "expression");
          }
          function h3(B, I) {
            let k = B.getValue();
            switch (k.type) {
              case "ParenthesizedExpression":
              case "TypeCastExpression":
              case "ArrayExpression":
              case "ArrayPattern":
              case "TemplateLiteral":
              case "TemplateElement":
              case "RegExpLiteral":
                return true;
              case "ArrowFunctionExpression": {
                if (!m2(B, I))
                  return true;
                break;
              }
              case "UnaryExpression": {
                let { prefix: P, operator: C } = k;
                if (P && (C === "+" || C === "-"))
                  return true;
                break;
              }
              case "BindExpression": {
                if (!k.object)
                  return true;
                break;
              }
              case "Literal": {
                if (k.regex)
                  return true;
                break;
              }
              default:
                if (u(k))
                  return true;
            }
            return s(B, I) ? true : r(k) ? B.call((P) => h3(P, I), ...a(B, k)) : false;
          }
          function w(B, I, k) {
            return d(B, I, k, "body");
          }
          function T(B, I, k) {
            return d(B, I, k, "consequent");
          }
          var A = (B) => {
            let { type: I } = B;
            return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty";
          };
          function S(B, I) {
            let k = B.key && B.key.name;
            if ((k === "static" || k === "get" || k === "set") && !B.value && !B.typeAnnotation)
              return true;
            if (!I || I.static || I.accessibility)
              return false;
            if (!I.computed) {
              let P = I.key && I.key.name;
              if (P === "in" || P === "instanceof")
                return true;
            }
            if (A(I) && I.variance && !I.static && !I.declare)
              return true;
            switch (I.type) {
              case "ClassProperty":
              case "PropertyDefinition":
              case "TSAbstractPropertyDefinition":
                return I.computed;
              case "MethodDefinition":
              case "TSAbstractMethodDefinition":
              case "ClassMethod":
              case "ClassPrivateMethod": {
                if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set")
                  return false;
                let C = I.value ? I.value.generator : I.generator;
                return !!(I.computed || C);
              }
              case "TSIndexSignature":
                return true;
            }
            return false;
          }
          n.exports = { printBody: w, printSwitchCaseConsequent: T };
        } }), Do = Z({ "src/language-js/print/block.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: r } } = Oe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: o } = Ke(), { printHardlineAfterHeritage: c } = Zt(), { printBody: v } = fo();
          function m2(p2, f, h3) {
            let w = p2.getValue(), T = [];
            if (w.type === "StaticBlock" && T.push("static "), w.type === "ClassBody" && s(w.body)) {
              let S = p2.getParentNode();
              T.push(c(S));
            }
            T.push("{");
            let A = d(p2, f, h3);
            if (A)
              T.push(r([a, A]), a);
            else {
              let S = p2.getParentNode(), B = p2.getParentNode(1);
              S.type === "ArrowFunctionExpression" || S.type === "FunctionExpression" || S.type === "FunctionDeclaration" || S.type === "ObjectMethod" || S.type === "ClassMethod" || S.type === "ClassPrivateMethod" || S.type === "ForStatement" || S.type === "WhileStatement" || S.type === "DoWhileStatement" || S.type === "DoExpression" || S.type === "CatchClause" && !B.finalizer || S.type === "TSModuleDeclaration" || S.type === "TSDeclareFunction" || w.type === "StaticBlock" || w.type === "ClassBody" || T.push(a);
            }
            return T.push("}"), T;
          }
          function d(p2, f, h3) {
            let w = p2.getValue(), T = s(w.directives), A = w.body.some((I) => I.type !== "EmptyStatement"), S = u(w, i.Dangling);
            if (!T && !A && !S)
              return "";
            let B = [];
            if (T && p2.each((I, k, P) => {
              B.push(h3()), (k < P.length - 1 || A || S) && (B.push(a), o(I.getValue(), f) && B.push(a));
            }, "directives"), A && B.push(v(p2, f, h3)), S && B.push(t(p2, f, true)), w.type === "Program") {
              let I = p2.getParentNode();
              (!I || I.type !== "ModuleExpression") && B.push(a);
            }
            return B;
          }
          n.exports = { printBlock: m2, printBlockBody: d };
        } }), Xm = Z({ "src/language-js/print/typescript.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: r, hardline: u, softline: i, group: o, indent: c, conditionalGroup: v, ifBreak: m2 } } = Oe(), { isLiteral: d, getTypeScriptMappedTypeModifier: p2, shouldPrintComma: f, isCallExpression: h3, isMemberExpression: w } = Ke(), T = zm(), { locStart: A, locEnd: S } = st(), { printOptionalToken: B, printTypeScriptModifiers: I } = ct(), { printTernary: k } = po(), { printFunctionParameters: P, shouldGroupFunctionParameters: C } = Pr(), { printTemplateLiteral: D } = Lt(), { printArrayItems: g } = Kt(), { printObject: F } = zn(), { printClassProperty: l, printClassMethod: E } = Zt(), { printTypeParameter: y, printTypeParameters: N } = Ir(), { printPropertyKey: x } = Qt(), { printFunction: b, printMethodInternal: L } = Lr(), { printInterface: M } = lo(), { printBlock: j } = Do(), { printTypeAlias: $2, printIntersectionType: V, printUnionType: q, printFunctionType: Y, printTupleType: H, printIndexedAccessType: R, printJSDocType: Q } = kr();
          function ee(te, oe, W) {
            let X = te.getValue();
            if (!X.type.startsWith("TS"))
              return;
            if (T(X))
              return X.type.slice(2, -7).toLowerCase();
            let ue = oe.semi ? ";" : "", De = [];
            switch (X.type) {
              case "TSThisType":
                return "this";
              case "TSTypeAssertion": {
                let ie = !(X.expression.type === "ArrayExpression" || X.expression.type === "ObjectExpression"), G = o(["<", c([i, W("typeAnnotation")]), i, ">"]), z = [m2("("), c([i, W("expression")]), i, m2(")")];
                return ie ? v([[G, W("expression")], [G, o(z, { shouldBreak: true })], [G, W("expression")]]) : o([G, W("expression")]);
              }
              case "TSDeclareFunction":
                return b(te, W, oe);
              case "TSExportAssignment":
                return ["export = ", W("expression"), ue];
              case "TSModuleBlock":
                return j(te, oe, W);
              case "TSInterfaceBody":
              case "TSTypeLiteral":
                return F(te, oe, W);
              case "TSTypeAliasDeclaration":
                return $2(te, oe, W);
              case "TSQualifiedName":
                return a(".", [W("left"), W("right")]);
              case "TSAbstractMethodDefinition":
              case "TSDeclareMethod":
                return E(te, oe, W);
              case "TSAbstractPropertyDefinition":
                return l(te, oe, W);
              case "TSInterfaceHeritage":
              case "TSExpressionWithTypeArguments":
                return De.push(W("expression")), X.typeParameters && De.push(W("typeParameters")), De;
              case "TSTemplateLiteralType":
                return D(te, W, oe);
              case "TSNamedTupleMember":
                return [W("label"), X.optional ? "?" : "", ": ", W("elementType")];
              case "TSRestType":
                return ["...", W("typeAnnotation")];
              case "TSOptionalType":
                return [W("typeAnnotation"), "?"];
              case "TSInterfaceDeclaration":
                return M(te, oe, W);
              case "TSClassImplements":
                return [W("expression"), W("typeParameters")];
              case "TSTypeParameterDeclaration":
              case "TSTypeParameterInstantiation":
                return N(te, oe, W, "params");
              case "TSTypeParameter":
                return y(te, oe, W);
              case "TSAsExpression": {
                De.push(W("expression"), " as ", W("typeAnnotation"));
                let ie = te.getParentNode();
                return h3(ie) && ie.callee === X || w(ie) && ie.object === X ? o([c([i, ...De]), i]) : De;
              }
              case "TSArrayType":
                return [W("elementType"), "[]"];
              case "TSPropertySignature":
                return X.readonly && De.push("readonly "), De.push(x(te, oe, W), B(te)), X.typeAnnotation && De.push(": ", W("typeAnnotation")), X.initializer && De.push(" = ", W("initializer")), De;
              case "TSParameterProperty":
                return X.accessibility && De.push(X.accessibility + " "), X.export && De.push("export "), X.static && De.push("static "), X.override && De.push("override "), X.readonly && De.push("readonly "), De.push(W("parameter")), De;
              case "TSTypeQuery":
                return ["typeof ", W("exprName"), W("typeParameters")];
              case "TSIndexSignature": {
                let ie = te.getParentNode(), G = X.parameters.length > 1 ? m2(f(oe) ? "," : "") : "", z = o([c([i, a([", ", i], te.map(W, "parameters"))]), G, i]);
                return [X.export ? "export " : "", X.accessibility ? [X.accessibility, " "] : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.declare ? "declare " : "", "[", X.parameters ? z : "", X.typeAnnotation ? "]: " : "]", X.typeAnnotation ? W("typeAnnotation") : "", ie.type === "ClassBody" ? ue : ""];
              }
              case "TSTypePredicate":
                return [X.asserts ? "asserts " : "", W("parameterName"), X.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
              case "TSNonNullExpression":
                return [W("expression"), "!"];
              case "TSImportType":
                return [X.isTypeOf ? "typeof " : "", "import(", W(X.parameter ? "parameter" : "argument"), ")", X.qualifier ? [".", W("qualifier")] : "", N(te, oe, W, "typeParameters")];
              case "TSLiteralType":
                return W("literal");
              case "TSIndexedAccessType":
                return R(te, oe, W);
              case "TSConstructSignatureDeclaration":
              case "TSCallSignatureDeclaration":
              case "TSConstructorType": {
                if (X.type === "TSConstructorType" && X.abstract && De.push("abstract "), X.type !== "TSCallSignatureDeclaration" && De.push("new "), De.push(o(P(te, W, oe, false, true))), X.returnType || X.typeAnnotation) {
                  let ie = X.type === "TSConstructorType";
                  De.push(ie ? " => " : ": ", W("returnType"), W("typeAnnotation"));
                }
                return De;
              }
              case "TSTypeOperator":
                return [X.operator, " ", W("typeAnnotation")];
              case "TSMappedType": {
                let ie = s(oe.originalText, A(X), S(X));
                return o(["{", c([oe.bracketSpacing ? r : i, X.readonly ? [p2(X.readonly, "readonly"), " "] : "", I(te, oe, W), W("typeParameter"), X.optional ? p2(X.optional, "?") : "", X.typeAnnotation ? ": " : "", W("typeAnnotation"), m2(ue)]), t(te, oe, true), oe.bracketSpacing ? r : i, "}"], { shouldBreak: ie });
              }
              case "TSMethodSignature": {
                let ie = X.kind && X.kind !== "method" ? "".concat(X.kind, " ") : "";
                De.push(X.accessibility ? [X.accessibility, " "] : "", ie, X.export ? "export " : "", X.static ? "static " : "", X.readonly ? "readonly " : "", X.abstract ? "abstract " : "", X.declare ? "declare " : "", X.computed ? "[" : "", W("key"), X.computed ? "]" : "", B(te));
                let G = P(te, W, oe, false, true), z = X.returnType ? "returnType" : "typeAnnotation", U = X[z], le = U ? W(z) : "", ge = C(X, le);
                return De.push(ge ? o(G) : G), U && De.push(": ", o(le)), o(De);
              }
              case "TSNamespaceExportDeclaration":
                return De.push("export as namespace ", W("id")), oe.semi && De.push(";"), o(De);
              case "TSEnumDeclaration":
                return X.declare && De.push("declare "), X.modifiers && De.push(I(te, oe, W)), X.const && De.push("const "), De.push("enum ", W("id"), " "), X.members.length === 0 ? De.push(o(["{", t(te, oe), i, "}"])) : De.push(o(["{", c([u, g(te, oe, "members", W), f(oe, "es5") ? "," : ""]), t(te, oe, true), u, "}"])), De;
              case "TSEnumMember":
                return X.computed ? De.push("[", W("id"), "]") : De.push(W("id")), X.initializer && De.push(" = ", W("initializer")), De;
              case "TSImportEqualsDeclaration":
                return X.isExport && De.push("export "), De.push("import "), X.importKind && X.importKind !== "value" && De.push(X.importKind, " "), De.push(W("id"), " = ", W("moduleReference")), oe.semi && De.push(";"), o(De);
              case "TSExternalModuleReference":
                return ["require(", W("expression"), ")"];
              case "TSModuleDeclaration": {
                let ie = te.getParentNode(), G = d(X.id), z = ie.type === "TSModuleDeclaration", U = X.body && X.body.type === "TSModuleDeclaration";
                if (z)
                  De.push(".");
                else {
                  X.declare && De.push("declare "), De.push(I(te, oe, W));
                  let le = oe.originalText.slice(A(X), A(X.id));
                  X.id.type === "Identifier" && X.id.name === "global" && !/namespace|module/.test(le) || De.push(G || /(?:^|\s)module(?:\s|$)/.test(le) ? "module " : "namespace ");
                }
                return De.push(W("id")), U ? De.push(W("body")) : X.body ? De.push(" ", o(W("body"))) : De.push(ue), De;
              }
              case "TSConditionalType":
                return k(te, oe, W);
              case "TSInferType":
                return ["infer", " ", W("typeParameter")];
              case "TSIntersectionType":
                return V(te, oe, W);
              case "TSUnionType":
                return q(te, oe, W);
              case "TSFunctionType":
                return Y(te, oe, W);
              case "TSTupleType":
                return H(te, oe, W);
              case "TSTypeReference":
                return [W("typeName"), N(te, oe, W, "typeParameters")];
              case "TSTypeAnnotation":
                return W("typeAnnotation");
              case "TSEmptyBodyFunctionExpression":
                return L(te, oe, W);
              case "TSJSDocAllType":
                return "*";
              case "TSJSDocUnknownType":
                return "?";
              case "TSJSDocNullableType":
                return Q(te, W, "?");
              case "TSJSDocNonNullableType":
                return Q(te, W, "!");
              case "TSInstantiationExpression":
                return [W("expression"), W("typeParameters")];
              default:
                throw new Error("Unknown TypeScript node type: ".concat(JSON.stringify(X.type), "."));
            }
          }
          n.exports = { printTypescript: ee };
        } }), Km = Z({ "src/language-js/print/comment.js"(e, n) {
          "use strict";
          re();
          var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: r } } = Oe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: o } = st(), c = It();
          function v(p2, f) {
            let h3 = p2.getValue();
            if (u(h3))
              return f.originalText.slice(i(h3), o(h3)).trimEnd();
            if (c(h3)) {
              if (m2(h3)) {
                let A = d(h3);
                return h3.trailing && !t(f.originalText, i(h3), { backwards: true }) ? [a, A] : A;
              }
              let w = o(h3), T = f.originalText.slice(w - 3, w) === "*-/";
              return ["/*", r(h3.value), T ? "*-/" : "*/"];
            }
            throw new Error("Not a comment: " + JSON.stringify(h3));
          }
          function m2(p2) {
            let f = "*".concat(p2.value, "*").split(`
`);
            return f.length > 1 && f.every((h3) => h3.trim()[0] === "*");
          }
          function d(p2) {
            let f = p2.value.split(`
`);
            return ["/*", s(a, f.map((h3, w) => w === 0 ? h3.trimEnd() : " " + (w < f.length - 1 ? h3.trim() : h3.trimStart()))), "*/"];
          }
          n.exports = { printComment: v };
        } }), Ym = Z({ "src/language-js/print/literal.js"(e, n) {
          "use strict";
          re();
          var { printString: t, printNumber: s } = Ue();
          function a(i, o) {
            let c = i.getNode();
            switch (c.type) {
              case "RegExpLiteral":
                return u(c);
              case "BigIntLiteral":
                return r(c.bigint || c.extra.raw);
              case "NumericLiteral":
                return s(c.extra.raw);
              case "StringLiteral":
                return t(c.extra.raw, o);
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return String(c.value);
              case "DecimalLiteral":
                return s(c.value) + "m";
              case "Literal": {
                if (c.regex)
                  return u(c.regex);
                if (c.bigint)
                  return r(c.raw);
                if (c.decimal)
                  return s(c.decimal) + "m";
                let { value: v } = c;
                return typeof v == "number" ? s(c.raw) : typeof v == "string" ? t(c.raw, o) : String(v);
              }
            }
          }
          function r(i) {
            return i.toLowerCase();
          }
          function u(i) {
            let { pattern: o, flags: c } = i;
            return c = [...c].sort().join(""), "/".concat(o, "/").concat(c);
          }
          n.exports = { printLiteral: a };
        } }), Qm = Z({ "src/language-js/printer-estree.js"(e, n) {
          "use strict";
          re();
          var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: r, hardline: u, softline: i, group: o, indent: c }, utils: { replaceTextEndOfLine: v } } = Oe(), m2 = Im(), d = Lm(), { insertPragma: p2 } = no(), f = uo(), h3 = jt(), w = so(), { hasFlowShorthandAnnotationComment: T, hasComment: A, CommentCheckFlags: S, isTheOnlyJsxElementInMarkdown: B, isLineComment: I, isNextLineEmpty: k, needsHardlineAfterDanglingComment: P, rawText: C, hasIgnoreComment: D, isCallExpression: g, isMemberExpression: F, markerForIfWithoutBlockAndSameLineComment: l } = Ke(), { locStart: E, locEnd: y } = st(), N = It(), { printHtmlBinding: x, isVueEventBindingExpression: b } = $m(), { printAngular: L } = Hm(), { printJsx: M, hasJsxIgnoreComment: j } = Gm(), { printFlow: $2 } = Um(), { printTypescript: V } = Xm(), { printOptionalToken: q, printBindExpressionCallee: Y, printTypeAnnotation: H, adjustClause: R, printRestSpread: Q, printDefiniteToken: ee } = ct(), { printImportDeclaration: te, printExportDeclaration: oe, printExportAllDeclaration: W, printModuleSpecifier: X } = co(), { printTernary: ue } = po(), { printTemplateLiteral: De } = Lt(), { printArray: ie } = Kt(), { printObject: G } = zn(), { printClass: z, printClassMethod: U, printClassProperty: le } = Zt(), { printProperty: ge } = Qt(), { printFunction: Ae, printArrowFunction: Ne, printMethod: ke, printReturnStatement: ce, printThrowStatement: pe } = Lr(), { printCallExpression: de } = oo(), { printVariableDeclarator: ae, printAssignmentExpression: ve } = Yt(), { printBinaryishExpression: K } = Jn(), { printSwitchCaseConsequent: he } = fo(), { printMemberExpression: ye } = ao(), { printBlock: Ce, printBlockBody: Ie } = Do(), { printComment: Fe } = Km(), { printLiteral: me } = Ym(), { printDecorators: _ } = Un();
          function J(Be, Pe, Se, Qe) {
            let xe = ne(Be, Pe, Se, Qe);
            if (!xe)
              return "";
            let Xe = Be.getValue(), { type: _e } = Xe;
            if (_e === "ClassMethod" || _e === "ClassPrivateMethod" || _e === "ClassProperty" || _e === "ClassAccessorProperty" || _e === "PropertyDefinition" || _e === "TSAbstractPropertyDefinition" || _e === "ClassPrivateProperty" || _e === "MethodDefinition" || _e === "TSAbstractMethodDefinition" || _e === "TSDeclareMethod")
              return xe;
            let je = [xe], Re = _(Be, Pe, Se), be = Xe.type === "ClassExpression" && Re;
            if (Re && (je = [...Re, xe], !be))
              return o(je);
            if (!h3(Be, Pe))
              return Qe && Qe.needsSemi && je.unshift(";"), je.length === 1 && je[0] === xe ? xe : je;
            if (be && (je = [c([r, ...je])]), je.unshift("("), Qe && Qe.needsSemi && je.unshift(";"), T(Xe)) {
              let [qe] = Xe.trailingComments;
              je.push(" /*", qe.value.trimStart(), "*/"), qe.printed = true;
            }
            return be && je.push(r), je.push(")"), je;
          }
          function ne(Be, Pe, Se, Qe) {
            let xe = Be.getValue(), Xe = Pe.semi ? ";" : "";
            if (!xe)
              return "";
            if (typeof xe == "string")
              return xe;
            for (let je of [me, x, L, M, $2, V]) {
              let Re = je(Be, Pe, Se);
              if (typeof Re < "u")
                return Re;
            }
            let _e = [];
            switch (xe.type) {
              case "JsExpressionRoot":
                return Se("node");
              case "JsonRoot":
                return [Se("node"), u];
              case "File":
                return xe.program && xe.program.interpreter && _e.push(Se(["program", "interpreter"])), _e.push(Se("program")), _e;
              case "Program":
                return Ie(Be, Pe, Se);
              case "EmptyStatement":
                return "";
              case "ExpressionStatement": {
                if (xe.directive)
                  return [Ee(xe.expression, Pe), Xe];
                if (Pe.parser === "__vue_event_binding" || Pe.parser === "__vue_ts_event_binding") {
                  let Re = Be.getParentNode();
                  if (Re.type === "Program" && Re.body.length === 1 && Re.body[0] === xe)
                    return [Se("expression"), b(xe.expression) ? ";" : ""];
                }
                let je = t(Be, Pe, true, (Re) => {
                  let { marker: be } = Re;
                  return be === l;
                });
                return [Se("expression"), B(Pe, Be) ? "" : Xe, je ? [" ", je] : ""];
              }
              case "ParenthesizedExpression":
                return !A(xe.expression) && (xe.expression.type === "ObjectExpression" || xe.expression.type === "ArrayExpression") ? ["(", Se("expression"), ")"] : o(["(", c([i, Se("expression")]), i, ")"]);
              case "AssignmentExpression":
                return ve(Be, Pe, Se);
              case "VariableDeclarator":
                return ae(Be, Pe, Se);
              case "BinaryExpression":
              case "LogicalExpression":
                return K(Be, Pe, Se);
              case "AssignmentPattern":
                return [Se("left"), " = ", Se("right")];
              case "OptionalMemberExpression":
              case "MemberExpression":
                return ye(Be, Pe, Se);
              case "MetaProperty":
                return [Se("meta"), ".", Se("property")];
              case "BindExpression":
                return xe.object && _e.push(Se("object")), _e.push(o(c([i, Y(Be, Pe, Se)]))), _e;
              case "Identifier":
                return [xe.name, q(Be), ee(Be), H(Be, Pe, Se)];
              case "V8IntrinsicIdentifier":
                return ["%", xe.name];
              case "SpreadElement":
              case "SpreadElementPattern":
              case "SpreadProperty":
              case "SpreadPropertyPattern":
              case "RestElement":
                return Q(Be, Pe, Se);
              case "FunctionDeclaration":
              case "FunctionExpression":
                return Ae(Be, Se, Pe, Qe);
              case "ArrowFunctionExpression":
                return Ne(Be, Pe, Se, Qe);
              case "YieldExpression":
                return _e.push("yield"), xe.delegate && _e.push("*"), xe.argument && _e.push(" ", Se("argument")), _e;
              case "AwaitExpression": {
                if (_e.push("await"), xe.argument) {
                  _e.push(" ", Se("argument"));
                  let je = Be.getParentNode();
                  if (g(je) && je.callee === xe || F(je) && je.object === xe) {
                    _e = [c([i, ..._e]), i];
                    let Re = Be.findAncestor((be) => be.type === "AwaitExpression" || be.type === "BlockStatement");
                    if (!Re || Re.type !== "AwaitExpression")
                      return o(_e);
                  }
                }
                return _e;
              }
              case "ExportDefaultDeclaration":
              case "ExportNamedDeclaration":
                return oe(Be, Pe, Se);
              case "ExportAllDeclaration":
                return W(Be, Pe, Se);
              case "ImportDeclaration":
                return te(Be, Pe, Se);
              case "ImportSpecifier":
              case "ExportSpecifier":
              case "ImportNamespaceSpecifier":
              case "ExportNamespaceSpecifier":
              case "ImportDefaultSpecifier":
              case "ExportDefaultSpecifier":
                return X(Be, Pe, Se);
              case "ImportAttribute":
                return [Se("key"), ": ", Se("value")];
              case "Import":
                return "import";
              case "BlockStatement":
              case "StaticBlock":
              case "ClassBody":
                return Ce(Be, Pe, Se);
              case "ThrowStatement":
                return pe(Be, Pe, Se);
              case "ReturnStatement":
                return ce(Be, Pe, Se);
              case "NewExpression":
              case "ImportExpression":
              case "OptionalCallExpression":
              case "CallExpression":
                return de(Be, Pe, Se);
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                return G(Be, Pe, Se);
              case "ObjectProperty":
              case "Property":
                return xe.method || xe.kind === "get" || xe.kind === "set" ? ke(Be, Pe, Se) : ge(Be, Pe, Se);
              case "ObjectMethod":
                return ke(Be, Pe, Se);
              case "Decorator":
                return ["@", Se("expression")];
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                return ie(Be, Pe, Se);
              case "SequenceExpression": {
                let je = Be.getParentNode(0);
                if (je.type === "ExpressionStatement" || je.type === "ForStatement") {
                  let Re = [];
                  return Be.each((be, Le) => {
                    Le === 0 ? Re.push(Se()) : Re.push(",", c([r, Se()]));
                  }, "expressions"), o(Re);
                }
                return o(a([",", r], Be.map(Se, "expressions")));
              }
              case "ThisExpression":
                return "this";
              case "Super":
                return "super";
              case "Directive":
                return [Se("value"), Xe];
              case "DirectiveLiteral":
                return Ee(xe, Pe);
              case "UnaryExpression":
                return _e.push(xe.operator), /[a-z]$/.test(xe.operator) && _e.push(" "), A(xe.argument) ? _e.push(o(["(", c([i, Se("argument")]), i, ")"])) : _e.push(Se("argument")), _e;
              case "UpdateExpression":
                return _e.push(Se("argument"), xe.operator), xe.prefix && _e.reverse(), _e;
              case "ConditionalExpression":
                return ue(Be, Pe, Se);
              case "VariableDeclaration": {
                let je = Be.map(Se, "declarations"), Re = Be.getParentNode(), be = Re.type === "ForStatement" || Re.type === "ForInStatement" || Re.type === "ForOfStatement", Le = xe.declarations.some((se) => se.init), qe;
                return je.length === 1 && !A(xe.declarations[0]) ? qe = je[0] : je.length > 0 && (qe = c(je[0])), _e = [xe.declare ? "declare " : "", xe.kind, qe ? [" ", qe] : "", c(je.slice(1).map((se) => [",", Le && !be ? u : r, se]))], be && Re.body !== xe || _e.push(Xe), o(_e);
              }
              case "WithStatement":
                return o(["with (", Se("object"), ")", R(xe.body, Se("body"))]);
              case "IfStatement": {
                let je = R(xe.consequent, Se("consequent")), Re = o(["if (", o([c([i, Se("test")]), i]), ")", je]);
                if (_e.push(Re), xe.alternate) {
                  let be = A(xe.consequent, S.Trailing | S.Line) || P(xe), Le = xe.consequent.type === "BlockStatement" && !be;
                  _e.push(Le ? " " : u), A(xe, S.Dangling) && _e.push(t(Be, Pe, true), be ? u : " "), _e.push("else", o(R(xe.alternate, Se("alternate"), xe.alternate.type === "IfStatement")));
                }
                return _e;
              }
              case "ForStatement": {
                let je = R(xe.body, Se("body")), Re = t(Be, Pe, true), be = Re ? [Re, i] : "";
                return !xe.init && !xe.test && !xe.update ? [be, o(["for (;;)", je])] : [be, o(["for (", o([c([i, Se("init"), ";", r, Se("test"), ";", r, Se("update")]), i]), ")", je])];
              }
              case "WhileStatement":
                return o(["while (", o([c([i, Se("test")]), i]), ")", R(xe.body, Se("body"))]);
              case "ForInStatement":
                return o(["for (", Se("left"), " in ", Se("right"), ")", R(xe.body, Se("body"))]);
              case "ForOfStatement":
                return o(["for", xe.await ? " await" : "", " (", Se("left"), " of ", Se("right"), ")", R(xe.body, Se("body"))]);
              case "DoWhileStatement": {
                let je = R(xe.body, Se("body"));
                return _e = [o(["do", je])], xe.body.type === "BlockStatement" ? _e.push(" ") : _e.push(u), _e.push("while (", o([c([i, Se("test")]), i]), ")", Xe), _e;
              }
              case "DoExpression":
                return [xe.async ? "async " : "", "do ", Se("body")];
              case "BreakStatement":
                return _e.push("break"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
              case "ContinueStatement":
                return _e.push("continue"), xe.label && _e.push(" ", Se("label")), _e.push(Xe), _e;
              case "LabeledStatement":
                return xe.body.type === "EmptyStatement" ? [Se("label"), ":;"] : [Se("label"), ": ", Se("body")];
              case "TryStatement":
                return ["try ", Se("block"), xe.handler ? [" ", Se("handler")] : "", xe.finalizer ? [" finally ", Se("finalizer")] : ""];
              case "CatchClause":
                if (xe.param) {
                  let je = A(xe.param, (be) => !N(be) || be.leading && s(Pe.originalText, y(be)) || be.trailing && s(Pe.originalText, E(be), { backwards: true })), Re = Se("param");
                  return ["catch ", je ? ["(", c([i, Re]), i, ") "] : ["(", Re, ") "], Se("body")];
                }
                return ["catch ", Se("body")];
              case "SwitchStatement":
                return [o(["switch (", c([i, Se("discriminant")]), i, ")"]), " {", xe.cases.length > 0 ? c([u, a(u, Be.map((je, Re, be) => {
                  let Le = je.getValue();
                  return [Se(), Re !== be.length - 1 && k(Le, Pe) ? u : ""];
                }, "cases"))]) : "", u, "}"];
              case "SwitchCase": {
                xe.test ? _e.push("case ", Se("test"), ":") : _e.push("default:"), A(xe, S.Dangling) && _e.push(" ", t(Be, Pe, true));
                let je = xe.consequent.filter((Re) => Re.type !== "EmptyStatement");
                if (je.length > 0) {
                  let Re = he(Be, Pe, Se);
                  _e.push(je.length === 1 && je[0].type === "BlockStatement" ? [" ", Re] : c([u, Re]));
                }
                return _e;
              }
              case "DebuggerStatement":
                return ["debugger", Xe];
              case "ClassDeclaration":
              case "ClassExpression":
                return z(Be, Pe, Se);
              case "ClassMethod":
              case "ClassPrivateMethod":
              case "MethodDefinition":
                return U(Be, Pe, Se);
              case "ClassProperty":
              case "PropertyDefinition":
              case "ClassPrivateProperty":
              case "ClassAccessorProperty":
                return le(Be, Pe, Se);
              case "TemplateElement":
                return v(xe.value.raw);
              case "TemplateLiteral":
                return De(Be, Se, Pe);
              case "TaggedTemplateExpression":
                return [Se("tag"), Se("typeParameters"), Se("quasi")];
              case "PrivateIdentifier":
                return ["#", Se("name")];
              case "PrivateName":
                return ["#", Se("id")];
              case "InterpreterDirective":
                return _e.push("#!", xe.value, u), k(xe, Pe) && _e.push(u), _e;
              case "TopicReference":
                return "%";
              case "ArgumentPlaceholder":
                return "?";
              case "ModuleExpression": {
                _e.push("module {");
                let je = Se("body");
                return je && _e.push(c([u, je]), u), _e.push("}"), _e;
              }
              default:
                throw new Error("unknown type: " + JSON.stringify(xe.type));
            }
          }
          function Ee(Be, Pe) {
            let Se = C(Be), Qe = Se.slice(1, -1);
            if (Qe.includes('"') || Qe.includes("'"))
              return Se;
            let xe = Pe.singleQuote ? "'" : '"';
            return xe + Qe + xe;
          }
          function We(Be) {
            return Be.type && !N(Be) && !I(Be) && Be.type !== "EmptyStatement" && Be.type !== "TemplateElement" && Be.type !== "Import" && Be.type !== "TSEmptyBodyFunctionExpression";
          }
          n.exports = { preprocess: w, print: J, embed: m2, insertPragma: p2, massageAstNode: d, hasPrettierIgnore(Be) {
            return D(Be) || j(Be);
          }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: We, printComment: Fe, isBlockComment: N, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
        } }), Zm = Z({ "src/language-js/printer-estree-json.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t, indent: s, join: a } } = Oe(), r = so();
          function u(c, v, m2) {
            let d = c.getValue();
            switch (d.type) {
              case "JsonRoot":
                return [m2("node"), t];
              case "ArrayExpression": {
                if (d.elements.length === 0)
                  return "[]";
                let p2 = c.map(() => c.getValue() === null ? "null" : m2(), "elements");
                return ["[", s([t, a([",", t], p2)]), t, "]"];
              }
              case "ObjectExpression":
                return d.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], c.map(m2, "properties"))]), t, "}"];
              case "ObjectProperty":
                return [m2("key"), ": ", m2("value")];
              case "UnaryExpression":
                return [d.operator === "+" ? "" : d.operator, m2("argument")];
              case "NullLiteral":
                return "null";
              case "BooleanLiteral":
                return d.value ? "true" : "false";
              case "StringLiteral":
              case "NumericLiteral":
                return JSON.stringify(d.value);
              case "Identifier": {
                let p2 = c.getParentNode();
                return p2 && p2.type === "ObjectProperty" && p2.key === d ? JSON.stringify(d.name) : d.name;
              }
              case "TemplateLiteral":
                return m2(["quasis", 0]);
              case "TemplateElement":
                return JSON.stringify(d.value.cooked);
              default:
                throw new Error("unknown type: " + JSON.stringify(d.type));
            }
          }
          var i = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
          function o(c, v) {
            let { type: m2 } = c;
            if (m2 === "ObjectProperty" && c.key.type === "Identifier") {
              v.key = { type: "StringLiteral", value: c.key.name };
              return;
            }
            if (m2 === "UnaryExpression" && c.operator === "+")
              return v.argument;
            if (m2 === "ArrayExpression") {
              for (let [d, p2] of c.elements.entries())
                p2 === null && v.elements.splice(d, 0, { type: "NullLiteral" });
              return;
            }
            if (m2 === "TemplateLiteral")
              return { type: "StringLiteral", value: c.quasis[0].value.cooked };
          }
          o.ignoredProperties = i, n.exports = { preprocess: r, print: u, massageAstNode: o };
        } }), Ot = Z({ "src/common/common-options.js"(e, n) {
          "use strict";
          re();
          var t = "Common";
          n.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
        } }), ed = Z({ "src/language-js/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot(), s = "JavaScript";
          n.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
        } }), td = Z({ "src/language-js/parse/parsers.js"() {
          re();
        } }), Sn = Z({ "node_modules/linguist-languages/data/JavaScript.json"(e, n) {
          n.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
        } }), rd = Z({ "node_modules/linguist-languages/data/TypeScript.json"(e, n) {
          n.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
        } }), nd = Z({ "node_modules/linguist-languages/data/TSX.json"(e, n) {
          n.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
        } }), ma = Z({ "node_modules/linguist-languages/data/JSON.json"(e, n) {
          n.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
        } }), ud = Z({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, n) {
          n.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
        } }), sd = Z({ "node_modules/linguist-languages/data/JSON5.json"(e, n) {
          n.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
        } }), id = Z({ "src/language-js/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = Qm(), a = Zm(), r = ed(), u = td(), i = [t(Sn(), (c) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...c.interpreters, "zx"], extensions: [...c.extensions.filter((v) => v !== ".jsx"), ".wxs"] })), t(Sn(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(Sn(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(rd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(nd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(ma(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(ma(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: c.extensions.filter((v) => v !== ".jsonl") })), t(ud(), (c) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...c.filenames, ".eslintrc", ".swcrc"] })), t(sd(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], o = { estree: s, "estree-json": a };
          n.exports = { languages: i, options: r, printers: o, parsers: u };
        } }), ad = Z({ "src/language-css/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ue(), s = it(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
          function r(i, o, c) {
            if (t(i) && i.lang === "yaml" && delete o.value, i.type === "css-comment" && c.type === "css-root" && c.nodes.length > 0 && ((c.nodes[0] === i || t(c.nodes[0]) && c.nodes[1] === i) && (delete o.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || c.type === "css-root" && s(c.nodes) === i))
              return null;
            if (i.type === "value-root" && delete o.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete o.value, i.type === "css-rule" && delete o.params, i.type === "selector-combinator" && (o.value = o.value.replace(/\s+/g, " ")), i.type === "media-feature" && (o.value = o.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(o.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (o.value = o.value.toLowerCase()), i.type === "css-decl" && (o.prop = o.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (o.name = o.name.toLowerCase()), i.type === "value-number" && (o.unit = o.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && o.value && (o.value = u(o.value)), i.type === "selector-attribute" && (o.attribute = o.attribute.trim(), o.namespace && typeof o.namespace == "string" && (o.namespace = o.namespace.trim(), o.namespace.length === 0 && (o.namespace = true)), o.value && (o.value = o.value.trim().replace(/^["']|["']$/g, ""), delete o.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && o.value && (o.value = o.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (v, m2, d) => {
              let p2 = Number(m2);
              return Number.isNaN(p2) ? v : p2 + d.toLowerCase();
            })), i.type === "selector-tag") {
              let v = i.value.toLowerCase();
              ["from", "to"].includes(v) && (o.value = v);
            }
            if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete o.value, i.type === "selector-unknown" && delete o.value, i.type === "value-comma_group") {
              let v = i.groups.findIndex((m2) => m2.type === "value-number" && m2.unit === "...");
              v !== -1 && (o.groups[v].unit = "", o.groups.splice(v + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
            }
          }
          r.ignoredProperties = a;
          function u(i) {
            return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
          }
          n.exports = r;
        } }), Xn = Z({ "src/utils/front-matter/print.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t, markAsRoot: s } } = Oe();
          function a(r, u) {
            if (r.lang === "yaml") {
              let i = r.value.trim(), o = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
              return s([r.startDelimiter, t, o, o ? t : "", r.endDelimiter]);
            }
          }
          n.exports = a;
        } }), od = Z({ "src/language-css/embed.js"(e, n) {
          "use strict";
          re();
          var { builders: { hardline: t } } = Oe(), s = Xn();
          function a(r, u, i) {
            let o = r.getValue();
            if (o.type === "front-matter") {
              let c = s(o, i);
              return c ? [c, t] : "";
            }
          }
          n.exports = a;
        } }), mo = Z({ "src/utils/front-matter/parse.js"(e, n) {
          "use strict";
          re();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(a) {
            let r = a.match(t);
            if (!r)
              return { content: a };
            let { startDelimiter: u, language: i, value: o = "", endDelimiter: c } = r.groups, v = i.trim() || "yaml";
            if (u === "+++" && (v = "toml"), v !== "yaml" && u !== c)
              return { content: a };
            let [m2] = r;
            return { frontMatter: { type: "front-matter", lang: v, value: o, startDelimiter: u, endDelimiter: c, raw: m2.replace(/\n$/, "") }, content: m2.replace(/[^\n]/g, " ") + a.slice(m2.length) };
          }
          n.exports = s;
        } }), ld = Z({ "src/language-css/pragma.js"(e, n) {
          "use strict";
          re();
          var t = no(), s = mo();
          function a(u) {
            return t.hasPragma(s(u).content);
          }
          function r(u) {
            let { frontMatter: i, content: o } = s(u);
            return (i ? i.raw + `

` : "") + t.insertPragma(o);
          }
          n.exports = { hasPragma: a, insertPragma: r };
        } }), cd = Z({ "src/language-css/utils/index.js"(e, n) {
          "use strict";
          re();
          var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
          function s(G, z) {
            let U = Array.isArray(z) ? z : [z], le = -1, ge;
            for (; ge = G.getParentNode(++le); )
              if (U.includes(ge.type))
                return le;
            return -1;
          }
          function a(G, z) {
            let U = s(G, z);
            return U === -1 ? null : G.getParentNode(U);
          }
          function r(G) {
            var z;
            let U = a(G, "css-decl");
            return U == null || (z = U.prop) === null || z === void 0 ? void 0 : z.toLowerCase();
          }
          var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
          function i(G) {
            return u.has(G.toLowerCase());
          }
          function o(G, z) {
            let U = a(G, "css-atrule");
            return (U == null ? void 0 : U.name) && U.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(z.toLowerCase());
          }
          function c(G) {
            return G.includes("$") || G.includes("@") || G.includes("#") || G.startsWith("%") || G.startsWith("--") || G.startsWith(":--") || G.includes("(") && G.includes(")") ? G : G.toLowerCase();
          }
          function v(G, z) {
            var U;
            let le = a(G, "value-func");
            return (le == null || (U = le.value) === null || U === void 0 ? void 0 : U.toLowerCase()) === z;
          }
          function m2(G) {
            var z;
            let U = a(G, "css-rule"), le = U == null || (z = U.raws) === null || z === void 0 ? void 0 : z.selector;
            return le && (le.startsWith(":import") || le.startsWith(":export"));
          }
          function d(G, z) {
            let U = Array.isArray(z) ? z : [z], le = a(G, "css-atrule");
            return le && U.includes(le.name.toLowerCase());
          }
          function p2(G) {
            let z = G.getValue(), U = a(G, "css-atrule");
            return (U == null ? void 0 : U.name) === "import" && z.groups[0].value === "url" && z.groups.length === 2;
          }
          function f(G) {
            return G.type === "value-func" && G.value.toLowerCase() === "url";
          }
          function h3(G, z) {
            var U;
            let le = (U = G.getParentNode()) === null || U === void 0 ? void 0 : U.nodes;
            return le && le.indexOf(z) === le.length - 1;
          }
          function w(G) {
            let { selector: z } = G;
            return z ? typeof z == "string" && /^@.+:.*$/.test(z) || z.value && /^@.+:.*$/.test(z.value) : false;
          }
          function T(G) {
            return G.type === "value-word" && ["from", "through", "end"].includes(G.value);
          }
          function A(G) {
            return G.type === "value-word" && ["and", "or", "not"].includes(G.value);
          }
          function S(G) {
            return G.type === "value-word" && G.value === "in";
          }
          function B(G) {
            return G.type === "value-operator" && G.value === "*";
          }
          function I(G) {
            return G.type === "value-operator" && G.value === "/";
          }
          function k(G) {
            return G.type === "value-operator" && G.value === "+";
          }
          function P(G) {
            return G.type === "value-operator" && G.value === "-";
          }
          function C(G) {
            return G.type === "value-operator" && G.value === "%";
          }
          function D(G) {
            return B(G) || I(G) || k(G) || P(G) || C(G);
          }
          function g(G) {
            return G.type === "value-word" && ["==", "!="].includes(G.value);
          }
          function F(G) {
            return G.type === "value-word" && ["<", ">", "<=", ">="].includes(G.value);
          }
          function l(G) {
            return G.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(G.name);
          }
          function E(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.params) && /^\(\s*\)$/.test(G.raws.params);
          }
          function y(G) {
            return G.name.startsWith("prettier-placeholder");
          }
          function N(G) {
            return G.prop.startsWith("@prettier-placeholder");
          }
          function x(G, z) {
            return G.value === "$$" && G.type === "value-func" && (z == null ? void 0 : z.type) === "value-word" && !z.raws.before;
          }
          function b(G) {
            var z, U;
            return ((z = G.value) === null || z === void 0 ? void 0 : z.type) === "value-root" && ((U = G.value.group) === null || U === void 0 ? void 0 : U.type) === "value-value" && G.prop.toLowerCase() === "composes";
          }
          function L(G) {
            var z, U, le;
            return ((z = G.value) === null || z === void 0 || (U = z.group) === null || U === void 0 || (le = U.group) === null || le === void 0 ? void 0 : le.type) === "value-paren_group" && G.value.group.group.open !== null && G.value.group.group.close !== null;
          }
          function M(G) {
            var z;
            return ((z = G.raws) === null || z === void 0 ? void 0 : z.before) === "";
          }
          function j(G) {
            var z, U;
            return G.type === "value-comma_group" && ((z = G.groups) === null || z === void 0 || (U = z[1]) === null || U === void 0 ? void 0 : U.type) === "value-colon";
          }
          function $2(G) {
            var z;
            return G.type === "value-paren_group" && ((z = G.groups) === null || z === void 0 ? void 0 : z[0]) && j(G.groups[0]);
          }
          function V(G) {
            var z;
            let U = G.getValue();
            if (U.groups.length === 0)
              return false;
            let le = G.getParentNode(1);
            if (!$2(U) && !(le && $2(le)))
              return false;
            let ge = a(G, "css-decl");
            return !!(ge != null && (z = ge.prop) !== null && z !== void 0 && z.startsWith("$") || $2(le) || le.type === "value-func");
          }
          function q(G) {
            return G.type === "value-comment" && G.inline;
          }
          function Y(G) {
            return G.type === "value-word" && G.value === "#";
          }
          function H(G) {
            return G.type === "value-word" && G.value === "{";
          }
          function R(G) {
            return G.type === "value-word" && G.value === "}";
          }
          function Q(G) {
            return ["value-word", "value-atword"].includes(G.type);
          }
          function ee(G) {
            return (G == null ? void 0 : G.type) === "value-colon";
          }
          function te(G, z) {
            if (!j(z))
              return false;
            let { groups: U } = z, le = U.indexOf(G);
            return le === -1 ? false : ee(U[le + 1]);
          }
          function oe(G) {
            return G.value && ["not", "and", "or"].includes(G.value.toLowerCase());
          }
          function W(G) {
            return G.type !== "value-func" ? false : t.has(G.value.toLowerCase());
          }
          function X(G) {
            return /\/\//.test(G.split(/[\n\r]/).pop());
          }
          function ue(G) {
            return (G == null ? void 0 : G.type) === "value-atword" && G.value.startsWith("prettier-placeholder-");
          }
          function De(G, z) {
            var U, le;
            if (((U = G.open) === null || U === void 0 ? void 0 : U.value) !== "(" || ((le = G.close) === null || le === void 0 ? void 0 : le.value) !== ")" || G.groups.some((ge) => ge.type !== "value-comma_group"))
              return false;
            if (z.type === "value-comma_group") {
              let ge = z.groups.indexOf(G) - 1, Ae = z.groups[ge];
              if ((Ae == null ? void 0 : Ae.type) === "value-word" && Ae.value === "with")
                return true;
            }
            return false;
          }
          function ie(G) {
            var z, U;
            return G.type === "value-paren_group" && ((z = G.open) === null || z === void 0 ? void 0 : z.value) === "(" && ((U = G.close) === null || U === void 0 ? void 0 : U.value) === ")";
          }
          n.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: r, maybeToLowerCase: c, insideValueFunctionNode: v, insideICSSRuleNode: m2, insideAtRuleNode: d, insideURLFunctionInImportAtRuleNode: p2, isKeyframeAtRuleKeywords: o, isWideKeywords: i, isLastNode: h3, isSCSSControlDirectiveNode: l, isDetachedRulesetDeclarationNode: w, isRelationalOperatorNode: F, isEqualityOperatorNode: g, isMultiplicationNode: B, isDivisionNode: I, isAdditionNode: k, isSubtractionNode: P, isModuloNode: C, isMathOperatorNode: D, isEachKeywordNode: S, isForKeywordNode: T, isURLFunctionNode: f, isIfElseKeywordNode: A, hasComposesNode: b, hasParensAroundNode: L, hasEmptyRawBefore: M, isDetachedRulesetCallNode: E, isTemplatePlaceholderNode: y, isTemplatePropNode: N, isPostcssSimpleVarNode: x, isKeyValuePairNode: j, isKeyValuePairInParenGroupNode: $2, isKeyInValuePairNode: te, isSCSSMapItemNode: V, isInlineValueCommentNode: q, isHashNode: Y, isLeftCurlyBraceNode: H, isRightCurlyBraceNode: R, isWordNode: Q, isColonNode: ee, isMediaAndSupportsKeywords: oe, isColorAdjusterFuncNode: W, lastLineHasInlineComment: X, isAtWordPlaceholderNode: ue, isConfigurationNode: De, isParenGroupNode: ie };
        } }), pd = Z({ "src/utils/line-column-to-index.js"(e, n) {
          "use strict";
          re(), n.exports = function(t, s) {
            let a = 0;
            for (let r = 0; r < t.line - 1; ++r)
              a = s.indexOf(`
`, a) + 1;
            return a + t.column;
          };
        } }), fd = Z({ "src/language-css/loc.js"(e, n) {
          "use strict";
          re();
          var { skipEverythingButNewLine: t } = Nr(), s = it(), a = pd();
          function r(p2, f) {
            return typeof p2.sourceIndex == "number" ? p2.sourceIndex : p2.source ? a(p2.source.start, f) - 1 : null;
          }
          function u(p2, f) {
            if (p2.type === "css-comment" && p2.inline)
              return t(f, p2.source.startOffset);
            let h3 = p2.nodes && s(p2.nodes);
            return h3 && p2.source && !p2.source.end && (p2 = h3), p2.source && p2.source.end ? a(p2.source.end, f) : null;
          }
          function i(p2, f) {
            p2.source && (p2.source.startOffset = r(p2, f), p2.source.endOffset = u(p2, f));
            for (let h3 in p2) {
              let w = p2[h3];
              h3 === "source" || !w || typeof w != "object" || (w.type === "value-root" || w.type === "value-unknown" ? o(w, c(p2), w.text || w.value) : i(w, f));
            }
          }
          function o(p2, f, h3) {
            p2.source && (p2.source.startOffset = r(p2, h3) + f, p2.source.endOffset = u(p2, h3) + f);
            for (let w in p2) {
              let T = p2[w];
              w === "source" || !T || typeof T != "object" || o(T, f, h3);
            }
          }
          function c(p2) {
            let f = p2.source.startOffset;
            return typeof p2.prop == "string" && (f += p2.prop.length), p2.type === "css-atrule" && typeof p2.name == "string" && (f += 1 + p2.name.length + p2.raws.afterName.match(/^\s*:?\s*/)[0].length), p2.type !== "css-atrule" && p2.raws && typeof p2.raws.between == "string" && (f += p2.raws.between.length), f;
          }
          function v(p2) {
            let f = "initial", h3 = "initial", w, T = false, A = [];
            for (let S = 0; S < p2.length; S++) {
              let B = p2[S];
              switch (f) {
                case "initial":
                  if (B === "'") {
                    f = "single-quotes";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes";
                    continue;
                  }
                  if ((B === "u" || B === "U") && p2.slice(S, S + 4).toLowerCase() === "url(") {
                    f = "url", S += 3;
                    continue;
                  }
                  if (B === "*" && p2[S - 1] === "/") {
                    f = "comment-block";
                    continue;
                  }
                  if (B === "/" && p2[S - 1] === "/") {
                    f = "comment-inline", w = S - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (B === "'" && p2[S - 1] !== "\\" && (f = h3, h3 = "initial"), B === `
` || B === "\r")
                    return p2;
                  continue;
                case "double-quotes":
                  if (B === '"' && p2[S - 1] !== "\\" && (f = h3, h3 = "initial"), B === `
` || B === "\r")
                    return p2;
                  continue;
                case "url":
                  if (B === ")" && (f = "initial"), B === `
` || B === "\r")
                    return p2;
                  if (B === "'") {
                    f = "single-quotes", h3 = "url";
                    continue;
                  }
                  if (B === '"') {
                    f = "double-quotes", h3 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  B === "/" && p2[S - 1] === "*" && (f = "initial");
                  continue;
                case "comment-inline":
                  (B === '"' || B === "'" || B === "*") && (T = true), (B === `
` || B === "\r") && (T && A.push([w, S]), f = "initial", T = false);
                  continue;
              }
            }
            for (let [S, B] of A)
              p2 = p2.slice(0, S) + p2.slice(S, B).replace(/["'*]/g, " ") + p2.slice(B);
            return p2;
          }
          function m2(p2) {
            return p2.source.startOffset;
          }
          function d(p2) {
            return p2.source.endOffset;
          }
          n.exports = { locStart: m2, locEnd: d, calculateLoc: i, replaceQuotesInInlineComments: v };
        } }), Dd = Z({ "src/language-css/utils/is-less-parser.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return s.parser === "css" || s.parser === "less";
          }
          n.exports = t;
        } }), md = Z({ "src/language-css/utils/is-scss.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
          }
          n.exports = t;
        } }), dd = Z({ "src/language-css/utils/css-units.evaluate.js"(e, n) {
          n.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
        } }), gd = Z({ "src/language-css/utils/print-unit.js"(e, n) {
          "use strict";
          re();
          var t = dd();
          function s(a) {
            let r = a.toLowerCase();
            return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : a;
          }
          n.exports = s;
        } }), yd = Z({ "src/language-css/printer-postcss.js"(e, n) {
          "use strict";
          re();
          var t = it(), { printNumber: s, printString: a, hasNewline: r, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: o } = Ue(), { builders: { join: c, line: v, hardline: m2, softline: d, group: p2, fill: f, indent: h3, dedent: w, ifBreak: T, breakParent: A }, utils: { removeLines: S, getDocParts: B } } = Oe(), I = ad(), k = od(), { insertPragma: P } = ld(), { getAncestorNode: C, getPropOfDeclNode: D, maybeToLowerCase: g, insideValueFunctionNode: F, insideICSSRuleNode: l, insideAtRuleNode: E, insideURLFunctionInImportAtRuleNode: y, isKeyframeAtRuleKeywords: N, isWideKeywords: x, isLastNode: b, isSCSSControlDirectiveNode: L, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: j, isEqualityOperatorNode: $2, isMultiplicationNode: V, isDivisionNode: q, isAdditionNode: Y, isSubtractionNode: H, isMathOperatorNode: R, isEachKeywordNode: Q, isForKeywordNode: ee, isURLFunctionNode: te, isIfElseKeywordNode: oe, hasComposesNode: W, hasParensAroundNode: X, hasEmptyRawBefore: ue, isKeyValuePairNode: De, isKeyInValuePairNode: ie, isDetachedRulesetCallNode: G, isTemplatePlaceholderNode: z, isTemplatePropNode: U, isPostcssSimpleVarNode: le, isSCSSMapItemNode: ge, isInlineValueCommentNode: Ae, isHashNode: Ne, isLeftCurlyBraceNode: ke, isRightCurlyBraceNode: ce, isWordNode: pe, isColonNode: de, isMediaAndSupportsKeywords: ae, isColorAdjusterFuncNode: ve, lastLineHasInlineComment: K, isAtWordPlaceholderNode: he, isConfigurationNode: ye, isParenGroupNode: Ce } = cd(), { locStart: Ie, locEnd: Fe } = fd(), me = Dd(), _ = md(), J = gd();
          function ne(be) {
            return be.trailingComma === "es5" || be.trailingComma === "all";
          }
          function Ee(be, Le, qe) {
            let se = be.getValue();
            if (!se)
              return "";
            if (typeof se == "string")
              return se;
            switch (se.type) {
              case "front-matter":
                return [se.raw, m2];
              case "css-root": {
                let He = We(be, Le, qe), Me = se.raws.after.trim();
                return [He, Me ? " ".concat(Me) : "", B(He).length > 0 ? m2 : ""];
              }
              case "css-comment": {
                let He = se.inline || se.raws.inline, Me = Le.originalText.slice(Ie(se), Fe(se));
                return He ? Me.trimEnd() : Me;
              }
              case "css-rule":
                return [qe("selector"), se.important ? " !important" : "", se.nodes ? [se.selector && se.selector.type === "selector-unknown" && K(se.selector.value) ? v : " ", "{", se.nodes.length > 0 ? h3([m2, We(be, Le, qe)]) : "", m2, "}", M(se) ? ";" : ""] : ";"];
              case "css-decl": {
                let He = be.getParentNode(), { between: Me } = se.raws, ze = Me.trim(), nt = ze === ":", tt = W(se) ? S(qe("value")) : qe("value");
                return !nt && K(ze) && (tt = h3([m2, w(tt)])), [se.raws.before.replace(/[\s;]/g, ""), l(be) ? se.prop : g(se.prop), ze.startsWith("//") ? " " : "", ze, se.extend ? "" : " ", me(Le) && se.extend && se.selector ? ["extend(", qe("selector"), ")"] : "", tt, se.raws.important ? se.raws.important.replace(/\s*!\s*important/i, " !important") : se.important ? " !important" : "", se.raws.scssDefault ? se.raws.scssDefault.replace(/\s*!default/i, " !default") : se.scssDefault ? " !default" : "", se.raws.scssGlobal ? se.raws.scssGlobal.replace(/\s*!global/i, " !global") : se.scssGlobal ? " !global" : "", se.nodes ? [" {", h3([d, We(be, Le, qe)]), d, "}"] : U(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";" ? "" : Le.__isHTMLStyleAttribute && b(be, se) ? T(";") : ";"];
              }
              case "css-atrule": {
                let He = be.getParentNode(), Me = z(se) && !He.raws.semicolon && Le.originalText[Fe(se) - 1] !== ";";
                if (me(Le)) {
                  if (se.mixin)
                    return [qe("selector"), se.important ? " !important" : "", Me ? "" : ";"];
                  if (se.function)
                    return [se.name, qe("params"), Me ? "" : ";"];
                  if (se.variable)
                    return ["@", se.name, ": ", se.value ? qe("value") : "", se.raws.between.trim() ? se.raws.between.trim() + " " : "", se.nodes ? ["{", h3([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : "", Me ? "" : ";"];
                }
                return ["@", G(se) || se.name.endsWith(":") ? se.name : g(se.name), se.params ? [G(se) ? "" : z(se) ? se.raws.afterName === "" ? "" : se.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(se.raws.afterName) ? [m2, m2] : /^\s*\n/.test(se.raws.afterName) ? m2 : " " : " ", qe("params")] : "", se.selector ? h3([" ", qe("selector")]) : "", se.value ? p2([" ", qe("value"), L(se) ? X(se) ? " " : v : ""]) : se.name === "else" ? " " : "", se.nodes ? [L(se) ? "" : se.selector && !se.selector.nodes && typeof se.selector.value == "string" && K(se.selector.value) || !se.selector && typeof se.params == "string" && K(se.params) ? v : " ", "{", h3([se.nodes.length > 0 ? d : "", We(be, Le, qe)]), d, "}"] : Me ? "" : ";"];
              }
              case "media-query-list": {
                let He = [];
                return be.each((Me) => {
                  let ze = Me.getValue();
                  ze.type === "media-query" && ze.value === "" || He.push(qe());
                }, "nodes"), p2(h3(c(v, He)));
              }
              case "media-query":
                return [c(" ", be.map(qe, "nodes")), b(be, se) ? "" : ","];
              case "media-type":
                return je(Xe(se.value, Le));
              case "media-feature-expression":
                return se.nodes ? ["(", ...be.map(qe, "nodes"), ")"] : se.value;
              case "media-feature":
                return g(Xe(se.value.replace(/ +/g, " "), Le));
              case "media-colon":
                return [se.value, " "];
              case "media-value":
                return je(Xe(se.value, Le));
              case "media-keyword":
                return Xe(se.value, Le);
              case "media-url":
                return Xe(se.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), Le);
              case "media-unknown":
                return se.value;
              case "selector-root":
                return p2([E(be, "custom-selector") ? [C(be, "css-atrule").customSelector, v] : "", c([",", E(be, ["extend", "custom-selector", "nest"]) ? v : m2], be.map(qe, "nodes"))]);
              case "selector-selector":
                return p2(h3(be.map(qe, "nodes")));
              case "selector-comment":
                return se.value;
              case "selector-string":
                return Xe(se.value, Le);
              case "selector-tag": {
                let He = be.getParentNode(), Me = He && He.nodes.indexOf(se), ze = Me && He.nodes[Me - 1];
                return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", ze.type === "selector-nesting" ? se.value : je(N(be, se.value) ? se.value.toLowerCase() : se.value)];
              }
              case "selector-id":
                return ["#", se.value];
              case "selector-class":
                return [".", je(Xe(se.value, Le))];
              case "selector-attribute":
                return ["[", se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.attribute.trim(), se.operator ? se.operator : "", se.value ? _e(Xe(se.value.trim(), Le), Le) : "", se.insensitive ? " i" : "", "]"];
              case "selector-combinator": {
                if (se.value === "+" || se.value === ">" || se.value === "~" || se.value === ">>>") {
                  let ze = be.getParentNode();
                  return [ze.type === "selector-selector" && ze.nodes[0] === se ? "" : v, se.value, b(be, se) ? "" : " "];
                }
                let He = se.value.trim().startsWith("(") ? v : "", Me = je(Xe(se.value.trim(), Le)) || v;
                return [He, Me];
              }
              case "selector-universal":
                return [se.namespace ? [se.namespace === true ? "" : se.namespace.trim(), "|"] : "", se.value];
              case "selector-pseudo":
                return [g(se.value), o(se.nodes) ? ["(", c(", ", be.map(qe, "nodes")), ")"] : ""];
              case "selector-nesting":
                return se.value;
              case "selector-unknown": {
                let He = C(be, "css-rule");
                if (He && He.isSCSSNesterProperty)
                  return je(Xe(g(se.value), Le));
                let Me = be.getParentNode();
                if (Me.raws && Me.raws.selector) {
                  let nt = Ie(Me), tt = nt + Me.raws.selector.length;
                  return Le.originalText.slice(nt, tt).trim();
                }
                let ze = be.getParentNode(1);
                if (Me.type === "value-paren_group" && ze && ze.type === "value-func" && ze.value === "selector") {
                  let nt = Fe(Me.open) + 1, tt = Ie(Me.close), pt = Le.originalText.slice(nt, tt).trim();
                  return K(pt) ? [A, pt] : pt;
                }
                return se.value;
              }
              case "value-value":
              case "value-root":
                return qe("group");
              case "value-comment":
                return Le.originalText.slice(Ie(se), Fe(se));
              case "value-comma_group": {
                let He = be.getParentNode(), Me = be.getParentNode(1), ze = D(be), nt = ze && He.type === "value-value" && (ze === "grid" || ze.startsWith("grid-template")), tt = C(be, "css-atrule"), pt = tt && L(tt), O = se.groups.some((ut) => Ae(ut)), fe = be.map(qe, "groups"), Te = [], $e = F(be, "url"), Je = false, Ze = false;
                for (let ut = 0; ut < se.groups.length; ++ut) {
                  Te.push(fe[ut]);
                  let rt = se.groups[ut - 1], Ve = se.groups[ut], Ge = se.groups[ut + 1], tr = se.groups[ut + 2];
                  if ($e) {
                    (Ge && Y(Ge) || Y(Ve)) && Te.push(" ");
                    continue;
                  }
                  if (E(be, "forward") && Ve.type === "value-word" && Ve.value && rt !== void 0 && rt.type === "value-word" && rt.value === "as" && Ge.type === "value-operator" && Ge.value === "*" || !Ge || Ve.type === "value-word" && Ve.value.endsWith("-") && he(Ge))
                    continue;
                  let Eo = Ve.type === "value-string" && Ve.value.startsWith("#{"), Fo = Je && Ge.type === "value-string" && Ge.value.endsWith("}");
                  if (Eo || Fo) {
                    Je = !Je;
                    continue;
                  }
                  if (Je || de(Ve) || de(Ge) || Ve.type === "value-atword" && Ve.value === "" || Ve.value === "~" || Ve.value && Ve.value.includes("\\") && Ge && Ge.type !== "value-comment" || rt && rt.value && rt.value.indexOf("\\") === rt.value.length - 1 && Ve.type === "value-operator" && Ve.value === "/" || Ve.value === "\\" || le(Ve, Ge) || Ne(Ve) || ke(Ve) || ce(Ge) || ke(Ge) && ue(Ge) || ce(Ve) && ue(Ge) || Ve.value === "--" && Ne(Ge))
                    continue;
                  let Qn = R(Ve), Zn = R(Ge);
                  if ((Qn && Ne(Ge) || Zn && ce(Ve)) && ue(Ge) || !rt && q(Ve) || F(be, "calc") && (Y(Ve) || Y(Ge) || H(Ve) || H(Ge)) && ue(Ge))
                    continue;
                  let Ao = (Y(Ve) || H(Ve)) && ut === 0 && (Ge.type === "value-number" || Ge.isHex) && Me && ve(Me) && !ue(Ge), eu = tr && tr.type === "value-func" || tr && pe(tr) || Ve.type === "value-func" || pe(Ve), tu = Ge.type === "value-func" || pe(Ge) || rt && rt.type === "value-func" || rt && pe(rt);
                  if (!(!(V(Ge) || V(Ve)) && !F(be, "calc") && !Ao && (q(Ge) && !eu || q(Ve) && !tu || Y(Ge) && !eu || Y(Ve) && !tu || H(Ge) || H(Ve)) && (ue(Ge) || Qn && (!rt || rt && R(rt))))) {
                    if (Ae(Ve)) {
                      if (He.type === "value-paren_group") {
                        Te.push(w(m2));
                        continue;
                      }
                      Te.push(m2);
                      continue;
                    }
                    if (pt && ($2(Ge) || j(Ge) || oe(Ge) || Q(Ve) || ee(Ve))) {
                      Te.push(" ");
                      continue;
                    }
                    if (tt && tt.name.toLowerCase() === "namespace") {
                      Te.push(" ");
                      continue;
                    }
                    if (nt) {
                      Ve.source && Ge.source && Ve.source.start.line !== Ge.source.start.line ? (Te.push(m2), Ze = true) : Te.push(" ");
                      continue;
                    }
                    if (Zn) {
                      Te.push(" ");
                      continue;
                    }
                    if (!(Ge && Ge.value === "...") && !(he(Ve) && he(Ge) && Fe(Ve) === Ie(Ge))) {
                      if (he(Ve) && Ce(Ge) && Fe(Ve) === Ie(Ge.open)) {
                        Te.push(d);
                        continue;
                      }
                      if (Ve.value === "with" && Ce(Ge)) {
                        Te.push(" ");
                        continue;
                      }
                      Te.push(v);
                    }
                  }
                }
                return O && Te.push(A), Ze && Te.unshift(m2), pt ? p2(h3(Te)) : y(be) ? p2(f(Te)) : p2(h3(f(Te)));
              }
              case "value-paren_group": {
                let He = be.getParentNode();
                if (He && te(He) && (se.groups.length === 1 || se.groups.length > 0 && se.groups[0].type === "value-comma_group" && se.groups[0].groups.length > 0 && se.groups[0].groups[0].type === "value-word" && se.groups[0].groups[0].value.startsWith("data:")))
                  return [se.open ? qe("open") : "", c(",", be.map(qe, "groups")), se.close ? qe("close") : ""];
                if (!se.open) {
                  let $e = be.map(qe, "groups"), Je = [];
                  for (let Ze = 0; Ze < $e.length; Ze++)
                    Ze !== 0 && Je.push([",", v]), Je.push($e[Ze]);
                  return p2(h3(f(Je)));
                }
                let Me = ge(be), ze = t(se.groups), nt = ze && ze.type === "value-comment", tt = ie(se, He), pt = ye(se, He), O = pt || Me && !tt, fe = pt || tt, Te = p2([se.open ? qe("open") : "", h3([d, c([v], be.map(($e, Je) => {
                  let Ze = $e.getValue(), ut = Je === se.groups.length - 1, rt = [qe(), ut ? "" : ","];
                  if (De(Ze) && Ze.type === "value-comma_group" && Ze.groups && Ze.groups[0].type !== "value-paren_group" && Ze.groups[2] && Ze.groups[2].type === "value-paren_group") {
                    let Ve = B(rt[0].contents.contents);
                    return Ve[1] = p2(Ve[1]), p2(w(rt));
                  }
                  if (!ut && Ze.type === "value-comma_group" && o(Ze.groups)) {
                    let Ve = t(Ze.groups);
                    Ve.source && i(Le.originalText, Ve, Fe) && rt.push(m2);
                  }
                  return rt;
                }, "groups"))]), T(!nt && _(Le.parser, Le.originalText) && Me && ne(Le) ? "," : ""), d, se.close ? qe("close") : ""], { shouldBreak: O });
                return fe ? w(Te) : Te;
              }
              case "value-func":
                return [se.value, E(be, "supports") && ae(se) ? " " : "", qe("group")];
              case "value-paren":
                return se.value;
              case "value-number":
                return [Re(se.value), J(se.unit)];
              case "value-operator":
                return se.value;
              case "value-word":
                return se.isColor && se.isHex || x(se.value) ? se.value.toLowerCase() : se.value;
              case "value-colon": {
                let He = be.getParentNode(), Me = He && He.groups.indexOf(se), ze = Me && He.groups[Me - 1];
                return [se.value, ze && typeof ze.value == "string" && t(ze.value) === "\\" || F(be, "url") ? "" : v];
              }
              case "value-comma":
                return [se.value, " "];
              case "value-string":
                return a(se.raws.quote + se.value + se.raws.quote, Le);
              case "value-atword":
                return ["@", se.value];
              case "value-unicode-range":
                return se.value;
              case "value-unknown":
                return se.value;
              default:
                throw new Error("Unknown postcss type ".concat(JSON.stringify(se.type)));
            }
          }
          function We(be, Le, qe) {
            let se = [];
            return be.each((He, Me, ze) => {
              let nt = ze[Me - 1];
              if (nt && nt.type === "css-comment" && nt.text.trim() === "prettier-ignore") {
                let tt = He.getValue();
                se.push(Le.originalText.slice(Ie(tt), Fe(tt)));
              } else
                se.push(qe());
              Me !== ze.length - 1 && (ze[Me + 1].type === "css-comment" && !r(Le.originalText, Ie(ze[Me + 1]), { backwards: true }) && !u(ze[Me]) || ze[Me + 1].type === "css-atrule" && ze[Me + 1].name === "else" && ze[Me].type !== "css-comment" ? se.push(" ") : (se.push(Le.__isHTMLStyleAttribute ? v : m2), i(Le.originalText, He.getValue(), Fe) && !u(ze[Me]) && se.push(m2)));
            }, "nodes"), se;
          }
          var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, Pe = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, Se = /[A-Za-z]+/g, Qe = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, xe = new RegExp(Be.source + "|(".concat(Qe.source, ")?(").concat(Pe.source, ")(").concat(Se.source, ")?"), "g");
          function Xe(be, Le) {
            return be.replace(Be, (qe) => a(qe, Le));
          }
          function _e(be, Le) {
            let qe = Le.singleQuote ? "'" : '"';
            return be.includes('"') || be.includes("'") ? be : qe + be + qe;
          }
          function je(be) {
            return be.replace(xe, (Le, qe, se, He, Me) => !se && He ? Re(He) + g(Me || "") : Le);
          }
          function Re(be) {
            return s(be).replace(/\.0(?=$|e)/, "");
          }
          n.exports = { print: Ee, embed: k, insertPragma: P, massageAstNode: I };
        } }), hd = Z({ "src/language-css/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot();
          n.exports = { singleQuote: t.singleQuote };
        } }), vd = Z({ "src/language-css/parsers.js"() {
          re();
        } }), Cd = Z({ "node_modules/linguist-languages/data/CSS.json"(e, n) {
          n.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
        } }), Ed = Z({ "node_modules/linguist-languages/data/PostCSS.json"(e, n) {
          n.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
        } }), Fd = Z({ "node_modules/linguist-languages/data/Less.json"(e, n) {
          n.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
        } }), Ad = Z({ "node_modules/linguist-languages/data/SCSS.json"(e, n) {
          n.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
        } }), Sd = Z({ "src/language-css/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = yd(), a = hd(), r = vd(), u = [t(Cd(), (o) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...o.extensions, ".wxss"] })), t(Ed(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Fd(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Ad(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), xd = Z({ "src/language-handlebars/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.loc.start.offset;
          }
          function s(a) {
            return a.loc.end.offset;
          }
          n.exports = { locStart: t, locEnd: s };
        } }), bd = Z({ "src/language-handlebars/clean.js"(e, n) {
          "use strict";
          re();
          function t(s, a) {
            if (s.type === "TextNode") {
              let r = s.chars.trim();
              if (!r)
                return null;
              a.chars = r.replace(/[\t\n\f\r ]+/g, " ");
            }
            s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
          }
          t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), n.exports = t;
        } }), Td = Z({ "vendors/html-void-elements.json"(e, n) {
          n.exports = { htmlVoidElements: ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "isindex", "keygen", "link", "menuitem", "meta", "nextid", "param", "source", "track", "wbr"] };
        } }), Bd = Z({ "src/language-handlebars/utils.js"(e, n) {
          "use strict";
          re();
          var { htmlVoidElements: t } = Td(), s = it();
          function a(S) {
            let B = S.getValue(), I = S.getParentNode(0);
            return !!(m2(S, ["ElementNode"]) && s(I.children) === B || m2(S, ["Block"]) && s(I.body) === B);
          }
          function r(S) {
            return S.toUpperCase() === S;
          }
          function u(S) {
            return v(S, ["ElementNode"]) && typeof S.tag == "string" && !S.tag.startsWith(":") && (r(S.tag[0]) || S.tag.includes("."));
          }
          var i = new Set(t);
          function o(S) {
            return i.has(S.tag) || u(S) && S.children.every((B) => c(B));
          }
          function c(S) {
            return v(S, ["TextNode"]) && !/\S/.test(S.chars);
          }
          function v(S, B) {
            return S && B.includes(S.type);
          }
          function m2(S, B) {
            let I = S.getParentNode(0);
            return v(I, B);
          }
          function d(S, B) {
            let I = h3(S);
            return v(I, B);
          }
          function p2(S, B) {
            let I = w(S);
            return v(I, B);
          }
          function f(S, B) {
            var I, k, P, C;
            let D = S.getValue(), g = (I = S.getParentNode(0)) !== null && I !== void 0 ? I : {}, F = (k = (P = (C = g.children) !== null && C !== void 0 ? C : g.body) !== null && P !== void 0 ? P : g.parts) !== null && k !== void 0 ? k : [], l = F.indexOf(D);
            return l !== -1 && F[l + B];
          }
          function h3(S) {
            let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
            return f(S, -B);
          }
          function w(S) {
            return f(S, 1);
          }
          function T(S) {
            return v(S, ["MustacheCommentStatement"]) && typeof S.value == "string" && S.value.trim() === "prettier-ignore";
          }
          function A(S) {
            let B = S.getValue(), I = h3(S, 2);
            return T(B) || T(I);
          }
          n.exports = { getNextNode: w, getPreviousNode: h3, hasPrettierIgnore: A, isLastNodeOfSiblings: a, isNextNodeOfSomeType: p2, isNodeOfSomeType: v, isParentOfSomeType: m2, isPreviousNodeOfSomeType: d, isVoid: o, isWhitespaceNode: c };
        } }), Nd = Z({ "src/language-handlebars/printer-glimmer.js"(e, n) {
          "use strict";
          re();
          var { builders: { dedent: t, fill: s, group: a, hardline: r, ifBreak: u, indent: i, join: o, line: c, softline: v }, utils: { getDocParts: m2, replaceTextEndOfLine: d } } = Oe(), { getPreferredQuote: p2, isNonEmptyArray: f } = Ue(), { locStart: h3, locEnd: w } = xd(), T = bd(), { getNextNode: A, getPreviousNode: S, hasPrettierIgnore: B, isLastNodeOfSiblings: I, isNextNodeOfSomeType: k, isNodeOfSomeType: P, isParentOfSomeType: C, isPreviousNodeOfSomeType: D, isVoid: g, isWhitespaceNode: F } = Bd(), l = 2;
          function E(K, he, ye) {
            let Ce = K.getValue();
            if (!Ce)
              return "";
            if (B(K))
              return he.originalText.slice(h3(Ce), w(Ce));
            let Ie = he.singleQuote ? "'" : '"';
            switch (Ce.type) {
              case "Block":
              case "Program":
              case "Template":
                return a(K.map(ye, "body"));
              case "ElementNode": {
                let Fe = a(N(K, ye)), me = he.htmlWhitespaceSensitivity === "ignore" && k(K, ["ElementNode"]) ? v : "";
                if (g(Ce))
                  return [Fe, me];
                let _ = ["</", Ce.tag, ">"];
                return Ce.children.length === 0 ? [Fe, i(_), me] : he.htmlWhitespaceSensitivity === "ignore" ? [Fe, i(x(K, he, ye)), r, i(_), me] : [Fe, i(a(x(K, he, ye))), i(_), me];
              }
              case "BlockStatement": {
                let Fe = K.getParentNode(1);
                return Fe && Fe.inverse && Fe.inverse.body.length === 1 && Fe.inverse.body[0] === Ce && Fe.inverse.body[0].path.parts[0] === "if" ? [ee(K, ye), ue(K, ye, he), De(K, ye, he)] : [R(K, ye), a([ue(K, ye, he), De(K, ye, he), te(K, ye, he)])];
              }
              case "ElementModifierStatement":
                return a(["{{", pe(K, ye), "}}"]);
              case "MustacheStatement":
                return a([L(Ce), pe(K, ye), M(Ce)]);
              case "SubExpression":
                return a(["(", ce(K, ye), v, ")"]);
              case "AttrNode": {
                let Fe = Ce.value.type === "TextNode";
                if (Fe && Ce.value.chars === "" && h3(Ce.value) === w(Ce.value))
                  return Ce.name;
                let _ = Fe ? p2(Ce.value.chars, Ie).quote : Ce.value.type === "ConcatStatement" ? p2(Ce.value.parts.filter((ne) => ne.type === "TextNode").map((ne) => ne.chars).join(""), Ie).quote : "", J = ye("value");
                return [Ce.name, "=", _, Ce.name === "class" && _ ? a(i(J)) : J, _];
              }
              case "ConcatStatement":
                return K.map(ye, "parts");
              case "Hash":
                return o(c, K.map(ye, "pairs"));
              case "HashPair":
                return [Ce.key, "=", ye("value")];
              case "TextNode": {
                let Fe = Ce.chars.replace(/{{/g, "\\{{"), me = z(K);
                if (me) {
                  if (me === "class") {
                    let xe = Fe.trim().split(/\s+/).join(" "), Xe = false, _e = false;
                    return C(K, ["ConcatStatement"]) && (D(K, ["MustacheStatement"]) && /^\s/.test(Fe) && (Xe = true), k(K, ["MustacheStatement"]) && /\s$/.test(Fe) && xe !== "" && (_e = true)), [Xe ? c : "", xe, _e ? c : ""];
                  }
                  return d(Fe);
                }
                let J = /^[\t\n\f\r ]*$/.test(Fe), ne = !S(K), Ee = !A(K);
                if (he.htmlWhitespaceSensitivity !== "ignore") {
                  let xe = /^[\t\n\f\r ]*/, Xe = /[\t\n\f\r ]*$/, _e = Ee && C(K, ["Template"]), je = ne && C(K, ["Template"]);
                  if (J) {
                    if (je || _e)
                      return "";
                    let se = [c], He = U(Fe);
                    return He && (se = Ae(He)), I(K) && (se = se.map((Me) => t(Me))), se;
                  }
                  let [Re] = Fe.match(xe), [be] = Fe.match(Xe), Le = [];
                  if (Re) {
                    Le = [c];
                    let se = U(Re);
                    se && (Le = Ae(se)), Fe = Fe.replace(xe, "");
                  }
                  let qe = [];
                  if (be) {
                    if (!_e) {
                      qe = [c];
                      let se = U(be);
                      se && (qe = Ae(se)), I(K) && (qe = qe.map((He) => t(He)));
                    }
                    Fe = Fe.replace(Xe, "");
                  }
                  return [...Le, s(ie(Fe)), ...qe];
                }
                let We = U(Fe), Be = le(Fe), Pe = ge(Fe);
                if ((ne || Ee) && J && C(K, ["Block", "ElementNode", "Template"]))
                  return "";
                J && We ? (Be = Math.min(We, l), Pe = 0) : (k(K, ["BlockStatement", "ElementNode"]) && (Pe = Math.max(Pe, 1)), D(K, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
                let Se = "", Qe = "";
                return Pe === 0 && k(K, ["MustacheStatement"]) && (Qe = " "), Be === 0 && D(K, ["MustacheStatement"]) && (Se = " "), ne && (Be = 0, Se = ""), Ee && (Pe = 0, Qe = ""), Fe = Fe.replace(/^[\t\n\f\r ]+/g, Se).replace(/[\t\n\f\r ]+$/, Qe), [...Ae(Be), s(ie(Fe)), ...Ae(Pe)];
              }
              case "MustacheCommentStatement": {
                let Fe = h3(Ce), me = w(Ce), _ = he.originalText.charAt(Fe + 2) === "~", J = he.originalText.charAt(me - 3) === "~", ne = Ce.value.includes("}}") ? "--" : "";
                return ["{{", _ ? "~" : "", "!", ne, Ce.value, ne, J ? "~" : "", "}}"];
              }
              case "PathExpression":
                return Ce.original;
              case "BooleanLiteral":
                return String(Ce.value);
              case "CommentStatement":
                return ["<!--", Ce.value, "-->"];
              case "StringLiteral": {
                if (ke(K)) {
                  let Fe = he.singleQuote ? '"' : "'";
                  return Ne(Ce.value, Fe);
                }
                return Ne(Ce.value, Ie);
              }
              case "NumberLiteral":
                return String(Ce.value);
              case "UndefinedLiteral":
                return "undefined";
              case "NullLiteral":
                return "null";
              default:
                throw new Error("unknown glimmer type: " + JSON.stringify(Ce.type));
            }
          }
          function y(K, he) {
            return h3(K) - h3(he);
          }
          function N(K, he) {
            let ye = K.getValue(), Ce = ["attributes", "modifiers", "comments"].filter((Fe) => f(ye[Fe])), Ie = Ce.flatMap((Fe) => ye[Fe]).sort(y);
            for (let Fe of Ce)
              K.each((me) => {
                let _ = Ie.indexOf(me.getValue());
                Ie.splice(_, 1, [c, he()]);
              }, Fe);
            return f(ye.blockParams) && Ie.push(c, ve(ye)), ["<", ye.tag, i(Ie), b(ye)];
          }
          function x(K, he, ye) {
            let Ie = K.getValue().children.every((Fe) => F(Fe));
            return he.htmlWhitespaceSensitivity === "ignore" && Ie ? "" : K.map((Fe, me) => {
              let _ = ye();
              return me === 0 && he.htmlWhitespaceSensitivity === "ignore" ? [v, _] : _;
            }, "children");
          }
          function b(K) {
            return g(K) ? u([v, "/>"], [" />", v]) : u([v, ">"], ">");
          }
          function L(K) {
            let he = K.escaped === false ? "{{{" : "{{", ye = K.strip && K.strip.open ? "~" : "";
            return [he, ye];
          }
          function M(K) {
            let he = K.escaped === false ? "}}}" : "}}";
            return [K.strip && K.strip.close ? "~" : "", he];
          }
          function j(K) {
            let he = L(K), ye = K.openStrip.open ? "~" : "";
            return [he, ye, "#"];
          }
          function $2(K) {
            let he = M(K);
            return [K.openStrip.close ? "~" : "", he];
          }
          function V(K) {
            let he = L(K), ye = K.closeStrip.open ? "~" : "";
            return [he, ye, "/"];
          }
          function q(K) {
            let he = M(K);
            return [K.closeStrip.close ? "~" : "", he];
          }
          function Y(K) {
            let he = L(K), ye = K.inverseStrip.open ? "~" : "";
            return [he, ye];
          }
          function H(K) {
            let he = M(K);
            return [K.inverseStrip.close ? "~" : "", he];
          }
          function R(K, he) {
            let ye = K.getValue(), Ce = j(ye), Ie = $2(ye), Fe = [de(K, he)], me = ae(K, he);
            if (me && Fe.push(c, me), f(ye.program.blockParams)) {
              let _ = ve(ye.program);
              Fe.push(c, _);
            }
            return a([Ce, i(Fe), v, Ie]);
          }
          function Q(K, he) {
            return [he.htmlWhitespaceSensitivity === "ignore" ? r : "", Y(K), "else", H(K)];
          }
          function ee(K, he) {
            let ye = K.getParentNode(1);
            return [Y(ye), "else if ", ae(K, he), H(ye)];
          }
          function te(K, he, ye) {
            let Ce = K.getValue();
            return ye.htmlWhitespaceSensitivity === "ignore" ? [oe(Ce) ? v : r, V(Ce), he("path"), q(Ce)] : [V(Ce), he("path"), q(Ce)];
          }
          function oe(K) {
            return P(K, ["BlockStatement"]) && K.program.body.every((he) => F(he));
          }
          function W(K) {
            return X(K) && K.inverse.body.length === 1 && P(K.inverse.body[0], ["BlockStatement"]) && K.inverse.body[0].path.parts[0] === "if";
          }
          function X(K) {
            return P(K, ["BlockStatement"]) && K.inverse;
          }
          function ue(K, he, ye) {
            let Ce = K.getValue();
            if (oe(Ce))
              return "";
            let Ie = he("program");
            return ye.htmlWhitespaceSensitivity === "ignore" ? i([r, Ie]) : i(Ie);
          }
          function De(K, he, ye) {
            let Ce = K.getValue(), Ie = he("inverse"), Fe = ye.htmlWhitespaceSensitivity === "ignore" ? [r, Ie] : Ie;
            return W(Ce) ? Fe : X(Ce) ? [Q(Ce, ye), i(Fe)] : "";
          }
          function ie(K) {
            return m2(o(c, G(K)));
          }
          function G(K) {
            return K.split(/[\t\n\f\r ]+/);
          }
          function z(K) {
            for (let he = 0; he < 2; he++) {
              let ye = K.getParentNode(he);
              if (ye && ye.type === "AttrNode")
                return ye.name.toLowerCase();
            }
          }
          function U(K) {
            return K = typeof K == "string" ? K : "", K.split(`
`).length - 1;
          }
          function le(K) {
            K = typeof K == "string" ? K : "";
            let he = (K.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
            return U(he);
          }
          function ge(K) {
            K = typeof K == "string" ? K : "";
            let he = (K.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
            return U(he);
          }
          function Ae() {
            let K = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            return Array.from({ length: Math.min(K, l) }).fill(r);
          }
          function Ne(K, he) {
            let { quote: ye, regex: Ce } = p2(K, he);
            return [ye, K.replace(Ce, "\\".concat(ye)), ye];
          }
          function ke(K) {
            let he = 0, ye = K.getParentNode(he);
            for (; ye && P(ye, ["SubExpression"]); )
              he++, ye = K.getParentNode(he);
            return !!(ye && P(K.getParentNode(he + 1), ["ConcatStatement"]) && P(K.getParentNode(he + 2), ["AttrNode"]));
          }
          function ce(K, he) {
            let ye = de(K, he), Ce = ae(K, he);
            return Ce ? i([ye, c, a(Ce)]) : ye;
          }
          function pe(K, he) {
            let ye = de(K, he), Ce = ae(K, he);
            return Ce ? [i([ye, c, Ce]), v] : ye;
          }
          function de(K, he) {
            return he("path");
          }
          function ae(K, he) {
            let ye = K.getValue(), Ce = [];
            if (ye.params.length > 0) {
              let Ie = K.map(he, "params");
              Ce.push(...Ie);
            }
            if (ye.hash && ye.hash.pairs.length > 0) {
              let Ie = he("hash");
              Ce.push(Ie);
            }
            return Ce.length === 0 ? "" : o(c, Ce);
          }
          function ve(K) {
            return ["as |", K.blockParams.join(" "), "|"];
          }
          n.exports = { print: E, massageAstNode: T };
        } }), wd = Z({ "src/language-handlebars/parsers.js"() {
          re();
        } }), _d = Z({ "node_modules/linguist-languages/data/Handlebars.json"(e, n) {
          n.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
        } }), Pd = Z({ "src/language-handlebars/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = Nd(), a = wd(), r = [t(_d(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
          n.exports = { languages: r, printers: u, parsers: a };
        } }), kd = Z({ "src/language-graphql/pragma.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
          }
          function s(a) {
            return `# @format

` + a;
          }
          n.exports = { hasPragma: t, insertPragma: s };
        } }), Id = Z({ "src/language-graphql/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
          }
          function s(a) {
            return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
          }
          n.exports = { locStart: t, locEnd: s };
        } }), Ld = Z({ "src/language-graphql/printer-graphql.js"(e, n) {
          "use strict";
          re();
          var { builders: { join: t, hardline: s, line: a, softline: r, group: u, indent: i, ifBreak: o } } = Oe(), { isNextLineEmpty: c, isNonEmptyArray: v } = Ue(), { insertPragma: m2 } = kd(), { locStart: d, locEnd: p2 } = Id();
          function f(k, P, C) {
            let D = k.getValue();
            if (!D)
              return "";
            if (typeof D == "string")
              return D;
            switch (D.kind) {
              case "Document": {
                let g = [];
                return k.each((F, l, E) => {
                  g.push(C()), l !== E.length - 1 && (g.push(s), c(P.originalText, F.getValue(), p2) && g.push(s));
                }, "definitions"), [...g, s];
              }
              case "OperationDefinition": {
                let g = P.originalText[d(D)] !== "{", F = Boolean(D.name);
                return [g ? D.operation : "", g && F ? [" ", C("name")] : "", g && !F && v(D.variableDefinitions) ? " " : "", v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", h3(k, C, D), D.selectionSet ? !g && !F ? "" : " " : "", C("selectionSet")];
              }
              case "FragmentDefinition":
                return ["fragment ", C("name"), v(D.variableDefinitions) ? u(["(", i([r, t([o("", ", "), r], k.map(C, "variableDefinitions"))]), r, ")"]) : "", " on ", C("typeCondition"), h3(k, C, D), " ", C("selectionSet")];
              case "SelectionSet":
                return ["{", i([s, t(s, w(k, P, C, "selections"))]), s, "}"];
              case "Field":
                return u([D.alias ? [C("alias"), ": "] : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", h3(k, C, D), D.selectionSet ? " " : "", C("selectionSet")]);
              case "Name":
                return D.value;
              case "StringValue": {
                if (D.block) {
                  let g = D.value.replace(/"""/g, "\\$&").split(`
`);
                  return g.length === 1 && (g[0] = g[0].trim()), g.every((F) => F === "") && (g.length = 0), t(s, ['"""', ...g, '"""']);
                }
                return ['"', D.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
              }
              case "IntValue":
              case "FloatValue":
              case "EnumValue":
                return D.value;
              case "BooleanValue":
                return D.value ? "true" : "false";
              case "NullValue":
                return "null";
              case "Variable":
                return ["$", C("name")];
              case "ListValue":
                return u(["[", i([r, t([o("", ", "), r], k.map(C, "values"))]), r, "]"]);
              case "ObjectValue":
                return u(["{", P.bracketSpacing && D.fields.length > 0 ? " " : "", i([r, t([o("", ", "), r], k.map(C, "fields"))]), r, o("", P.bracketSpacing && D.fields.length > 0 ? " " : ""), "}"]);
              case "ObjectField":
              case "Argument":
                return [C("name"), ": ", C("value")];
              case "Directive":
                return ["@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : ""];
              case "NamedType":
                return C("name");
              case "VariableDefinition":
                return [C("variable"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h3(k, C, D)];
              case "ObjectTypeExtension":
              case "ObjectTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "ObjectTypeExtension" ? "extend " : "", "type ", C("name"), D.interfaces.length > 0 ? [" implements ", ...S(k, P, C)] : "", h3(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "FieldDefinition":
                return [C("description"), D.description ? s : "", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", ": ", C("type"), h3(k, C, D)];
              case "DirectiveDefinition":
                return [C("description"), D.description ? s : "", "directive ", "@", C("name"), D.arguments.length > 0 ? u(["(", i([r, t([o("", ", "), r], w(k, P, C, "arguments"))]), r, ")"]) : "", D.repeatable ? " repeatable" : "", " on ", t(" | ", k.map(C, "locations"))];
              case "EnumTypeExtension":
              case "EnumTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "EnumTypeExtension" ? "extend " : "", "enum ", C("name"), h3(k, C, D), D.values.length > 0 ? [" {", i([s, t(s, w(k, P, C, "values"))]), s, "}"] : ""];
              case "EnumValueDefinition":
                return [C("description"), D.description ? s : "", C("name"), h3(k, C, D)];
              case "InputValueDefinition":
                return [C("description"), D.description ? D.description.block ? s : a : "", C("name"), ": ", C("type"), D.defaultValue ? [" = ", C("defaultValue")] : "", h3(k, C, D)];
              case "InputObjectTypeExtension":
              case "InputObjectTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", C("name"), h3(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "SchemaExtension":
                return ["extend schema", h3(k, C, D), ...D.operationTypes.length > 0 ? [" {", i([s, t(s, w(k, P, C, "operationTypes"))]), s, "}"] : []];
              case "SchemaDefinition":
                return [C("description"), D.description ? s : "", "schema", h3(k, C, D), " {", D.operationTypes.length > 0 ? i([s, t(s, w(k, P, C, "operationTypes"))]) : "", s, "}"];
              case "OperationTypeDefinition":
                return [C("operation"), ": ", C("type")];
              case "InterfaceTypeExtension":
              case "InterfaceTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", C("name"), D.interfaces.length > 0 ? [" implements ", ...S(k, P, C)] : "", h3(k, C, D), D.fields.length > 0 ? [" {", i([s, t(s, w(k, P, C, "fields"))]), s, "}"] : ""];
              case "FragmentSpread":
                return ["...", C("name"), h3(k, C, D)];
              case "InlineFragment":
                return ["...", D.typeCondition ? [" on ", C("typeCondition")] : "", h3(k, C, D), " ", C("selectionSet")];
              case "UnionTypeExtension":
              case "UnionTypeDefinition":
                return u([C("description"), D.description ? s : "", u([D.kind === "UnionTypeExtension" ? "extend " : "", "union ", C("name"), h3(k, C, D), D.types.length > 0 ? [" =", o("", " "), i([o([a, "  "]), t([a, "| "], k.map(C, "types"))])] : ""])]);
              case "ScalarTypeExtension":
              case "ScalarTypeDefinition":
                return [C("description"), D.description ? s : "", D.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", C("name"), h3(k, C, D)];
              case "NonNullType":
                return [C("type"), "!"];
              case "ListType":
                return ["[", C("type"), "]"];
              default:
                throw new Error("unknown graphql type: " + JSON.stringify(D.kind));
            }
          }
          function h3(k, P, C) {
            if (C.directives.length === 0)
              return "";
            let D = t(a, k.map(P, "directives"));
            return C.kind === "FragmentDefinition" || C.kind === "OperationDefinition" ? u([a, D]) : [" ", u(i([r, D]))];
          }
          function w(k, P, C, D) {
            return k.map((g, F, l) => {
              let E = C();
              return F < l.length - 1 && c(P.originalText, g.getValue(), p2) ? [E, s] : E;
            }, D);
          }
          function T(k) {
            return k.kind && k.kind !== "Comment";
          }
          function A(k) {
            let P = k.getValue();
            if (P.kind === "Comment")
              return "#" + P.value.trimEnd();
            throw new Error("Not a comment: " + JSON.stringify(P));
          }
          function S(k, P, C) {
            let D = k.getNode(), g = [], { interfaces: F } = D, l = k.map((E) => C(E), "interfaces");
            for (let E = 0; E < F.length; E++) {
              let y = F[E];
              g.push(l[E]);
              let N = F[E + 1];
              if (N) {
                let x = P.originalText.slice(y.loc.end, N.loc.start), b = x.includes("#"), L = x.replace(/#.*/g, "").trim();
                g.push(L === "," ? "," : " &", b ? a : " ");
              }
            }
            return g;
          }
          function B(k, P) {
            k.kind === "StringValue" && k.block && !k.value.includes(`
`) && (P.value = P.value.trim());
          }
          B.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
          function I(k) {
            var P;
            let C = k.getValue();
            return C == null || (P = C.comments) === null || P === void 0 ? void 0 : P.some((D) => D.value.trim() === "prettier-ignore");
          }
          n.exports = { print: f, massageAstNode: B, hasPrettierIgnore: I, insertPragma: m2, printComment: A, canAttachComment: T };
        } }), jd = Z({ "src/language-graphql/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot();
          n.exports = { bracketSpacing: t.bracketSpacing };
        } }), Od = Z({ "src/language-graphql/parsers.js"() {
          re();
        } }), qd = Z({ "node_modules/linguist-languages/data/GraphQL.json"(e, n) {
          n.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
        } }), Md = Z({ "src/language-graphql/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = Ld(), a = jd(), r = Od(), u = [t(qd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), go = Z({ "src/language-markdown/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          n.exports = { locStart: t, locEnd: s };
        } }), Rd = Z({ "src/language-markdown/constants.evaluate.js"(e, n) {
          n.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
        } }), Kn = Z({ "src/language-markdown/utils.js"(e, n) {
          "use strict";
          re();
          var { getLast: t } = Ue(), { locStart: s, locEnd: a } = go(), { cjkPattern: r, kPattern: u, punctuationPattern: i } = Rd(), o = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], c = [...o, "tableCell", "paragraph", "heading"], v = new RegExp(u), m2 = new RegExp(i);
          function d(A, S) {
            let B = "non-cjk", I = "cj-letter", k = "k-letter", P = "cjk-punctuation", C = [], D = (S.proseWrap === "preserve" ? A : A.replace(new RegExp("(".concat(r, `)
(`).concat(r, ")"), "g"), "$1$2")).split(/([\t\n ]+)/);
            for (let [F, l] of D.entries()) {
              if (F % 2 === 1) {
                C.push({ type: "whitespace", value: /\n/.test(l) ? `
` : " " });
                continue;
              }
              if ((F === 0 || F === D.length - 1) && l === "")
                continue;
              let E = l.split(new RegExp("(".concat(r, ")")));
              for (let [y, N] of E.entries())
                if (!((y === 0 || y === E.length - 1) && N === "")) {
                  if (y % 2 === 0) {
                    N !== "" && g({ type: "word", value: N, kind: B, hasLeadingPunctuation: m2.test(N[0]), hasTrailingPunctuation: m2.test(t(N)) });
                    continue;
                  }
                  g(m2.test(N) ? { type: "word", value: N, kind: P, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: N, kind: v.test(N) ? k : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
                }
            }
            return C;
            function g(F) {
              let l = t(C);
              l && l.type === "word" && (l.kind === B && F.kind === I && !l.hasTrailingPunctuation || l.kind === I && F.kind === B && !F.hasLeadingPunctuation ? C.push({ type: "whitespace", value: " " }) : !E(B, P) && ![l.value, F.value].some((y) => /\u3000/.test(y)) && C.push({ type: "whitespace", value: "" })), C.push(F);
              function E(y, N) {
                return l.kind === y && F.kind === N || l.kind === N && F.kind === y;
              }
            }
          }
          function p2(A, S) {
            let [, B, I, k] = S.slice(A.position.start.offset, A.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
            return { numberText: B, marker: I, leadingSpaces: k };
          }
          function f(A, S) {
            if (!A.ordered || A.children.length < 2)
              return false;
            let B = Number(p2(A.children[0], S.originalText).numberText), I = Number(p2(A.children[1], S.originalText).numberText);
            if (B === 0 && A.children.length > 2) {
              let k = Number(p2(A.children[2], S.originalText).numberText);
              return I === 1 && k === 1;
            }
            return I === 1;
          }
          function h3(A, S) {
            let { value: B } = A;
            return A.position.end.offset === S.length && B.endsWith(`
`) && S.endsWith(`
`) ? B.slice(0, -1) : B;
          }
          function w(A, S) {
            return function B(I, k, P) {
              let C = Object.assign({}, S(I, k, P));
              return C.children && (C.children = C.children.map((D, g) => B(D, g, [C, ...P]))), C;
            }(A, null, []);
          }
          function T(A) {
            if ((A == null ? void 0 : A.type) !== "link" || A.children.length !== 1)
              return false;
            let [S] = A.children;
            return s(A) === s(S) && a(A) === a(S);
          }
          n.exports = { mapAst: w, splitText: d, punctuationPattern: i, getFencedCodeBlockValue: h3, getOrderedListItemInfo: p2, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: o, INLINE_NODE_WRAPPER_TYPES: c, isAutolink: T };
        } }), Vd = Z({ "src/language-markdown/embed.js"(e, n) {
          "use strict";
          re();
          var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: r }, utils: { replaceEndOfLine: u } } = Oe(), i = Xn(), { getFencedCodeBlockValue: o } = Kn();
          function c(v, m2, d, p2) {
            let f = v.getValue();
            if (f.type === "code" && f.lang !== null) {
              let h3 = t(f.lang, p2);
              if (h3) {
                let w = p2.__inJsTemplate ? "~" : "`", T = w.repeat(Math.max(3, s(f.value, w) + 1)), A = { parser: h3 };
                f.lang === "tsx" && (A.filepath = "dummy.tsx");
                let S = d(o(f, p2.originalText), A, { stripTrailingHardline: true });
                return r([T, f.lang, f.meta ? " " + f.meta : "", a, u(S), a, T]);
              }
            }
            switch (f.type) {
              case "front-matter":
                return i(f, d);
              case "importExport":
                return [d(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
              case "jsx":
                return d("<$>".concat(f.value, "</$>"), { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
            }
            return null;
          }
          n.exports = c;
        } }), yo = Z({ "src/language-markdown/pragma.js"(e, n) {
          "use strict";
          re();
          var t = mo(), s = ["format", "prettier"];
          function a(r) {
            let u = "@(".concat(s.join("|"), ")"), i = new RegExp(["<!--\\s*".concat(u, "\\s*-->"), "{\\s*\\/\\*\\s*".concat(u, "\\s*\\*\\/\\s*}"), `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*`.concat(u, `[^\\S
]*($|
)[\\s\\S]*
.*-->`)].join("|"), "m"), o = r.match(i);
            return (o == null ? void 0 : o.index) === 0;
          }
          n.exports = { startWithPragma: a, hasPragma: (r) => a(t(r).content.trimStart()), insertPragma: (r) => {
            let u = t(r), i = "<!-- @".concat(s[0], " -->");
            return u.frontMatter ? "".concat(u.frontMatter.raw, `

`).concat(i, `

`).concat(u.content) : "".concat(i, `

`).concat(u.content);
          } };
        } }), Wd = Z({ "src/language-markdown/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var t = it(), { getOrderedListItemInfo: s, mapAst: a, splitText: r } = Kn(), u = /^.$/su;
          function i(T, A) {
            return T = v(T, A), T = p2(T), T = c(T), T = h3(T, A), T = w(T, A), T = f(T, A), T = o(T), T = m2(T), T;
          }
          function o(T) {
            return a(T, (A) => A.type !== "import" && A.type !== "export" ? A : Object.assign(Object.assign({}, A), {}, { type: "importExport" }));
          }
          function c(T) {
            return a(T, (A) => A.type !== "inlineCode" ? A : Object.assign(Object.assign({}, A), {}, { value: A.value.replace(/\s+/g, " ") }));
          }
          function v(T, A) {
            return a(T, (S) => S.type !== "text" || S.value === "*" || S.value === "_" || !u.test(S.value) || S.position.end.offset - S.position.start.offset === S.value.length ? S : Object.assign(Object.assign({}, S), {}, { value: A.originalText.slice(S.position.start.offset, S.position.end.offset) }));
          }
          function m2(T) {
            return d(T, (A, S) => A.type === "importExport" && S.type === "importExport", (A, S) => ({ type: "importExport", value: A.value + `

` + S.value, position: { start: A.position.start, end: S.position.end } }));
          }
          function d(T, A, S) {
            return a(T, (B) => {
              if (!B.children)
                return B;
              let I = B.children.reduce((k, P) => {
                let C = t(k);
                return C && A(C, P) ? k.splice(-1, 1, S(C, P)) : k.push(P), k;
              }, []);
              return Object.assign(Object.assign({}, B), {}, { children: I });
            });
          }
          function p2(T) {
            return d(T, (A, S) => A.type === "text" && S.type === "text", (A, S) => ({ type: "text", value: A.value + S.value, position: { start: A.position.start, end: S.position.end } }));
          }
          function f(T, A) {
            return a(T, (S, B, I) => {
              let [k] = I;
              if (S.type !== "text")
                return S;
              let { value: P } = S;
              return k.type === "paragraph" && (B === 0 && (P = P.trimStart()), B === k.children.length - 1 && (P = P.trimEnd())), { type: "sentence", position: S.position, children: r(P, A) };
            });
          }
          function h3(T, A) {
            return a(T, (S, B, I) => {
              if (S.type === "code") {
                let k = /^\n?(?: {4,}|\t)/.test(A.originalText.slice(S.position.start.offset, S.position.end.offset));
                if (S.isIndented = k, k)
                  for (let P = 0; P < I.length; P++) {
                    let C = I[P];
                    if (C.hasIndentedCodeblock)
                      break;
                    C.type === "list" && (C.hasIndentedCodeblock = true);
                  }
              }
              return S;
            });
          }
          function w(T, A) {
            return a(T, (I, k, P) => {
              if (I.type === "list" && I.children.length > 0) {
                for (let C = 0; C < P.length; C++) {
                  let D = P[C];
                  if (D.type === "list" && !D.isAligned)
                    return I.isAligned = false, I;
                }
                I.isAligned = B(I);
              }
              return I;
            });
            function S(I) {
              return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
            }
            function B(I) {
              if (!I.ordered)
                return true;
              let [k, P] = I.children;
              if (s(k, A.originalText).leadingSpaces.length > 1)
                return true;
              let D = S(k);
              if (D === -1)
                return false;
              if (I.children.length === 1)
                return D % A.tabWidth === 0;
              let g = S(P);
              return D !== g ? false : D % A.tabWidth === 0 ? true : s(P, A.originalText).leadingSpaces.length > 1;
            }
          }
          n.exports = i;
        } }), $d = Z({ "src/language-markdown/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ue(), { startWithPragma: s } = yo(), a = /* @__PURE__ */ new Set(["position", "raw"]);
          function r(u, i, o) {
            if ((u.type === "front-matter" || u.type === "code" || u.type === "yaml" || u.type === "import" || u.type === "export" || u.type === "jsx") && delete i.value, u.type === "list" && delete i.isAligned, (u.type === "list" || u.type === "listItem") && (delete i.spread, delete i.loose), u.type === "text" || (u.type === "inlineCode" && (i.value = u.value.replace(/[\t\n ]+/g, " ")), u.type === "wikiLink" && (i.value = u.value.trim().replace(/[\t\n]+/g, " ")), (u.type === "definition" || u.type === "linkReference") && (i.label = u.label.trim().replace(/[\t\n ]+/g, " ").toLowerCase()), (u.type === "definition" || u.type === "link" || u.type === "image") && u.title && (i.title = u.title.replace(/\\(["')])/g, "$1")), o && o.type === "root" && o.children.length > 0 && (o.children[0] === u || t(o.children[0]) && o.children[1] === u) && u.type === "html" && s(u.value)))
              return null;
          }
          r.ignoredProperties = a, n.exports = r;
        } }), Hd = Z({ "src/language-markdown/printer-markdown.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, getMinNotPresentContinuousCount: s, getMaxContinuousCount: a, getStringWidth: r, isNonEmptyArray: u } = Ue(), { builders: { breakParent: i, join: o, line: c, literalline: v, markAsRoot: m2, hardline: d, softline: p2, ifBreak: f, fill: h3, align: w, indent: T, group: A, hardlineWithoutBreakParent: S }, utils: { normalizeDoc: B, replaceTextEndOfLine: I }, printer: { printDocToString: k } } = Oe(), P = Vd(), { insertPragma: C } = yo(), { locStart: D, locEnd: g } = go(), F = Wd(), l = $d(), { getFencedCodeBlockValue: E, hasGitDiffFriendlyOrderedList: y, splitText: N, punctuationPattern: x, INLINE_NODE_TYPES: b, INLINE_NODE_WRAPPER_TYPES: L, isAutolink: M } = Kn(), j = /* @__PURE__ */ new Set(["importExport"]), $2 = ["heading", "tableCell", "link", "wikiLink"], V = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
          function q(ce, pe, de) {
            let ae = ce.getValue();
            if (le(ce))
              return N(pe.originalText.slice(ae.position.start.offset, ae.position.end.offset), pe).map((ve) => ve.type === "word" ? ve.value : ve.value === "" ? "" : oe(ce, ve.value, pe));
            switch (ae.type) {
              case "front-matter":
                return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
              case "root":
                return ae.children.length === 0 ? "" : [B(X(ce, pe, de)), j.has(De(ae).type) ? "" : d];
              case "paragraph":
                return ue(ce, pe, de, { postprocessor: h3 });
              case "sentence":
                return ue(ce, pe, de);
              case "word": {
                let ve = ae.value.replace(/\*/g, "\\$&").replace(new RegExp(["(^|".concat(x, ")(_+)"), "(_+)(".concat(x, "|$)")].join("|"), "g"), (ye, Ce, Ie, Fe, me) => (Ie ? "".concat(Ce).concat(Ie) : "".concat(Fe).concat(me)).replace(/_/g, "\\_")), K = (ye, Ce, Ie) => ye.type === "sentence" && Ie === 0, he = (ye, Ce, Ie) => M(ye.children[Ie - 1]);
                return ve !== ae.value && (ce.match(void 0, K, he) || ce.match(void 0, K, (ye, Ce, Ie) => ye.type === "emphasis" && Ie === 0, he)) && (ve = ve.replace(/^(\\?[*_])+/, (ye) => ye.replace(/\\/g, ""))), ve;
              }
              case "whitespace": {
                let ve = ce.getParentNode(), K = ve.children.indexOf(ae), he = ve.children[K + 1], ye = he && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(he.value) ? "never" : pe.proseWrap;
                return oe(ce, ae.value, { proseWrap: ye });
              }
              case "emphasis": {
                let ve;
                if (M(ae.children[0]))
                  ve = pe.originalText[ae.position.start.offset];
                else {
                  let K = ce.getParentNode(), he = K.children.indexOf(ae), ye = K.children[he - 1], Ce = K.children[he + 1];
                  ve = ye && ye.type === "sentence" && ye.children.length > 0 && t(ye.children).type === "word" && !t(ye.children).hasTrailingPunctuation || Ce && Ce.type === "sentence" && Ce.children.length > 0 && Ce.children[0].type === "word" && !Ce.children[0].hasLeadingPunctuation || te(ce, "emphasis") ? "*" : "_";
                }
                return [ve, ue(ce, pe, de), ve];
              }
              case "strong":
                return ["**", ue(ce, pe, de), "**"];
              case "delete":
                return ["~~", ue(ce, pe, de), "~~"];
              case "inlineCode": {
                let ve = s(ae.value, "`"), K = "`".repeat(ve || 1), he = ve && !/^\s/.test(ae.value) ? " " : "";
                return [K, he, ae.value, he, K];
              }
              case "wikiLink": {
                let ve = "";
                return pe.proseWrap === "preserve" ? ve = ae.value : ve = ae.value.replace(/[\t\n]+/g, " "), ["[[", ve, "]]"];
              }
              case "link":
                switch (pe.originalText[ae.position.start.offset]) {
                  case "<": {
                    let ve = "mailto:", K = ae.url.startsWith(ve) && pe.originalText.slice(ae.position.start.offset + 1, ae.position.start.offset + 1 + ve.length) !== ve ? ae.url.slice(ve.length) : ae.url;
                    return ["<", K, ">"];
                  }
                  case "[":
                    return ["[", ue(ce, pe, de), "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
                  default:
                    return pe.originalText.slice(ae.position.start.offset, ae.position.end.offset);
                }
              case "image":
                return ["![", ae.alt || "", "](", ge(ae.url, ")"), Ae(ae.title, pe), ")"];
              case "blockquote":
                return ["> ", w("> ", ue(ce, pe, de))];
              case "heading":
                return ["#".repeat(ae.depth) + " ", ue(ce, pe, de)];
              case "code": {
                if (ae.isIndented) {
                  let he = " ".repeat(4);
                  return w(he, [he, ...I(ae.value, d)]);
                }
                let ve = pe.__inJsTemplate ? "~" : "`", K = ve.repeat(Math.max(3, a(ae.value, ve) + 1));
                return [K, ae.lang || "", ae.meta ? " " + ae.meta : "", d, ...I(E(ae, pe.originalText), d), d, K];
              }
              case "html": {
                let ve = ce.getParentNode(), K = ve.type === "root" && t(ve.children) === ae ? ae.value.trimEnd() : ae.value, he = /^<!--.*-->$/s.test(K);
                return I(K, he ? d : m2(v));
              }
              case "list": {
                let ve = R(ae, ce.getParentNode()), K = y(ae, pe);
                return ue(ce, pe, de, { processor: (he, ye) => {
                  let Ce = Fe(), Ie = he.getValue();
                  if (Ie.children.length === 2 && Ie.children[1].type === "html" && Ie.children[0].position.start.column !== Ie.children[1].position.start.column)
                    return [Ce, Y(he, pe, de, Ce)];
                  return [Ce, w(" ".repeat(Ce.length), Y(he, pe, de, Ce))];
                  function Fe() {
                    let me = ae.ordered ? (ye === 0 ? ae.start : K ? 1 : ae.start + ye) + (ve % 2 === 0 ? ". " : ") ") : ve % 2 === 0 ? "- " : "* ";
                    return ae.isAligned || ae.hasIndentedCodeblock ? H(me, pe) : me;
                  }
                } });
              }
              case "thematicBreak": {
                let ve = ee(ce, "list");
                return ve === -1 ? "---" : R(ce.getParentNode(ve), ce.getParentNode(ve + 1)) % 2 === 0 ? "***" : "---";
              }
              case "linkReference":
                return ["[", ue(ce, pe, de), "]", ae.referenceType === "full" ? ["[", ae.identifier, "]"] : ae.referenceType === "collapsed" ? "[]" : ""];
              case "imageReference":
                switch (ae.referenceType) {
                  case "full":
                    return ["![", ae.alt || "", "][", ae.identifier, "]"];
                  default:
                    return ["![", ae.alt, "]", ae.referenceType === "collapsed" ? "[]" : ""];
                }
              case "definition": {
                let ve = pe.proseWrap === "always" ? c : " ";
                return A(["[", ae.identifier, "]:", T([ve, ge(ae.url), ae.title === null ? "" : [ve, Ae(ae.title, pe, false)]])]);
              }
              case "footnote":
                return ["[^", ue(ce, pe, de), "]"];
              case "footnoteReference":
                return ["[^", ae.identifier, "]"];
              case "footnoteDefinition": {
                let ve = ce.getParentNode().children[ce.getName() + 1], K = ae.children.length === 1 && ae.children[0].type === "paragraph" && (pe.proseWrap === "never" || pe.proseWrap === "preserve" && ae.children[0].position.start.line === ae.children[0].position.end.line);
                return ["[^", ae.identifier, "]: ", K ? ue(ce, pe, de) : A([w(" ".repeat(4), ue(ce, pe, de, { processor: (he, ye) => ye === 0 ? A([p2, de()]) : de() })), ve && ve.type === "footnoteDefinition" ? p2 : ""])];
              }
              case "table":
                return W(ce, pe, de);
              case "tableCell":
                return ue(ce, pe, de);
              case "break":
                return /\s/.test(pe.originalText[ae.position.start.offset]) ? ["  ", m2(v)] : ["\\", d];
              case "liquidNode":
                return I(ae.value, d);
              case "importExport":
                return [ae.value, d];
              case "esComment":
                return ["{/* ", ae.value, " */}"];
              case "jsx":
                return ae.value;
              case "math":
                return ["$$", d, ae.value ? [...I(ae.value, d), d] : "", "$$"];
              case "inlineMath":
                return pe.originalText.slice(D(ae), g(ae));
              case "tableRow":
              case "listItem":
              default:
                throw new Error("Unknown markdown type ".concat(JSON.stringify(ae.type)));
            }
          }
          function Y(ce, pe, de, ae) {
            let ve = ce.getValue(), K = ve.checked === null ? "" : ve.checked ? "[x] " : "[ ] ";
            return [K, ue(ce, pe, de, { processor: (he, ye) => {
              if (ye === 0 && he.getValue().type !== "list")
                return w(" ".repeat(K.length), de());
              let Ce = " ".repeat(Ne(pe.tabWidth - ae.length, 0, 3));
              return [Ce, w(Ce, de())];
            } })];
          }
          function H(ce, pe) {
            let de = ae();
            return ce + " ".repeat(de >= 4 ? 0 : de);
            function ae() {
              let ve = ce.length % pe.tabWidth;
              return ve === 0 ? 0 : pe.tabWidth - ve;
            }
          }
          function R(ce, pe) {
            return Q(ce, pe, (de) => de.ordered === ce.ordered);
          }
          function Q(ce, pe, de) {
            let ae = -1;
            for (let ve of pe.children)
              if (ve.type === ce.type && de(ve) ? ae++ : ae = -1, ve === ce)
                return ae;
          }
          function ee(ce, pe) {
            let de = Array.isArray(pe) ? pe : [pe], ae = -1, ve;
            for (; ve = ce.getParentNode(++ae); )
              if (de.includes(ve.type))
                return ae;
            return -1;
          }
          function te(ce, pe) {
            let de = ee(ce, pe);
            return de === -1 ? null : ce.getParentNode(de);
          }
          function oe(ce, pe, de) {
            if (de.proseWrap === "preserve" && pe === `
`)
              return d;
            let ae = de.proseWrap === "always" && !te(ce, $2);
            return pe !== "" ? ae ? c : " " : ae ? p2 : "";
          }
          function W(ce, pe, de) {
            let ae = ce.getValue(), ve = [], K = ce.map((me) => me.map((_, J) => {
              let ne = k(de(), pe).formatted, Ee = r(ne);
              return ve[J] = Math.max(ve[J] || 3, Ee), { text: ne, width: Ee };
            }, "children"), "children"), he = Ce(false);
            if (pe.proseWrap !== "never")
              return [i, he];
            let ye = Ce(true);
            return [i, A(f(ye, he))];
            function Ce(me) {
              let _ = [Fe(K[0], me), Ie(me)];
              return K.length > 1 && _.push(o(S, K.slice(1).map((J) => Fe(J, me)))), o(S, _);
            }
            function Ie(me) {
              let _ = ve.map((J, ne) => {
                let Ee = ae.align[ne], We = Ee === "center" || Ee === "left" ? ":" : "-", Be = Ee === "center" || Ee === "right" ? ":" : "-", Pe = me ? "-" : "-".repeat(J - 2);
                return "".concat(We).concat(Pe).concat(Be);
              });
              return "| ".concat(_.join(" | "), " |");
            }
            function Fe(me, _) {
              let J = me.map((ne, Ee) => {
                let { text: We, width: Be } = ne;
                if (_)
                  return We;
                let Pe = ve[Ee] - Be, Se = ae.align[Ee], Qe = 0;
                Se === "right" ? Qe = Pe : Se === "center" && (Qe = Math.floor(Pe / 2));
                let xe = Pe - Qe;
                return "".concat(" ".repeat(Qe)).concat(We).concat(" ".repeat(xe));
              });
              return "| ".concat(J.join(" | "), " |");
            }
          }
          function X(ce, pe, de) {
            let ae = [], ve = null, { children: K } = ce.getValue();
            for (let [he, ye] of K.entries())
              switch (ie(ye)) {
                case "start":
                  ve === null && (ve = { index: he, offset: ye.position.end.offset });
                  break;
                case "end":
                  ve !== null && (ae.push({ start: ve, end: { index: he, offset: ye.position.start.offset } }), ve = null);
                  break;
                default:
                  break;
              }
            return ue(ce, pe, de, { processor: (he, ye) => {
              if (ae.length > 0) {
                let Ce = ae[0];
                if (ye === Ce.start.index)
                  return [K[Ce.start.index].value, pe.originalText.slice(Ce.start.offset, Ce.end.offset), K[Ce.end.index].value];
                if (Ce.start.index < ye && ye < Ce.end.index)
                  return false;
                if (ye === Ce.end.index)
                  return ae.shift(), false;
              }
              return de();
            } });
          }
          function ue(ce, pe, de) {
            let ae = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: ve } = ae, K = ae.processor || (() => de()), he = ce.getValue(), ye = [], Ce;
            return ce.each((Ie, Fe) => {
              let me = Ie.getValue(), _ = K(Ie, Fe);
              if (_ !== false) {
                let J = { parts: ye, prevNode: Ce, parentNode: he, options: pe };
                G(me, J) && (ye.push(d), Ce && j.has(Ce.type) || (z(me, J) || U(me, J)) && ye.push(d), U(me, J) && ye.push(d)), ye.push(_), Ce = me;
              }
            }, "children"), ve ? ve(ye) : ye;
          }
          function De(ce) {
            let pe = ce;
            for (; u(pe.children); )
              pe = t(pe.children);
            return pe;
          }
          function ie(ce) {
            let pe;
            if (ce.type === "html")
              pe = ce.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
            else {
              let de;
              ce.type === "esComment" ? de = ce : ce.type === "paragraph" && ce.children.length === 1 && ce.children[0].type === "esComment" && (de = ce.children[0]), de && (pe = de.value.match(/^prettier-ignore(?:-(start|end))?$/));
            }
            return pe ? pe[1] || "next" : false;
          }
          function G(ce, pe) {
            let de = pe.parts.length === 0, ae = b.includes(ce.type), ve = ce.type === "html" && L.includes(pe.parentNode.type);
            return !de && !ae && !ve;
          }
          function z(ce, pe) {
            var de, ae, ve;
            let he = (pe.prevNode && pe.prevNode.type) === ce.type && V.has(ce.type), ye = pe.parentNode.type === "listItem" && !pe.parentNode.loose, Ce = ((de = pe.prevNode) === null || de === void 0 ? void 0 : de.type) === "listItem" && pe.prevNode.loose, Ie = ie(pe.prevNode) === "next", Fe = ce.type === "html" && ((ae = pe.prevNode) === null || ae === void 0 ? void 0 : ae.type) === "html" && pe.prevNode.position.end.line + 1 === ce.position.start.line, me = ce.type === "html" && pe.parentNode.type === "listItem" && ((ve = pe.prevNode) === null || ve === void 0 ? void 0 : ve.type) === "paragraph" && pe.prevNode.position.end.line + 1 === ce.position.start.line;
            return Ce || !(he || ye || Ie || Fe || me);
          }
          function U(ce, pe) {
            let de = pe.prevNode && pe.prevNode.type === "list", ae = ce.type === "code" && ce.isIndented;
            return de && ae;
          }
          function le(ce) {
            let pe = te(ce, ["linkReference", "imageReference"]);
            return pe && (pe.type !== "linkReference" || pe.referenceType !== "full");
          }
          function ge(ce) {
            let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], de = [" ", ...Array.isArray(pe) ? pe : [pe]];
            return new RegExp(de.map((ae) => "\\".concat(ae)).join("|")).test(ce) ? "<".concat(ce, ">") : ce;
          }
          function Ae(ce, pe) {
            let de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            if (!ce)
              return "";
            if (de)
              return " " + Ae(ce, pe, false);
            if (ce = ce.replace(/\\(["')])/g, "$1"), ce.includes('"') && ce.includes("'") && !ce.includes(")"))
              return "(".concat(ce, ")");
            let ae = ce.split("'").length - 1, ve = ce.split('"').length - 1, K = ae > ve ? '"' : ve > ae || pe.singleQuote ? "'" : '"';
            return ce = ce.replace(/\\/, "\\\\"), ce = ce.replace(new RegExp("(".concat(K, ")"), "g"), "\\$1"), "".concat(K).concat(ce).concat(K);
          }
          function Ne(ce, pe, de) {
            return ce < pe ? pe : ce > de ? de : ce;
          }
          function ke(ce) {
            let pe = Number(ce.getName());
            if (pe === 0)
              return false;
            let de = ce.getParentNode().children[pe - 1];
            return ie(de) === "next";
          }
          n.exports = { preprocess: F, print: q, embed: P, massageAstNode: l, hasPrettierIgnore: ke, insertPragma: C };
        } }), Gd = Z({ "src/language-markdown/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot();
          n.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
        } }), Jd = Z({ "src/language-markdown/parsers.js"() {
          re();
        } }), da = Z({ "node_modules/linguist-languages/data/Markdown.json"(e, n) {
          n.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
        } }), Ud = Z({ "src/language-markdown/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = Hd(), a = Gd(), r = Jd(), u = [t(da(), (o) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...o.filenames, "README"], extensions: o.extensions.filter((c) => c !== ".mdx") })), t(da(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
          n.exports = { languages: u, options: a, printers: i, parsers: r };
        } }), zd = Z({ "src/language-html/clean.js"(e, n) {
          "use strict";
          re();
          var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
          function a(r, u) {
            if (r.type === "text" || r.type === "comment" || t(r) || r.type === "yaml" || r.type === "toml")
              return null;
            r.type === "attribute" && delete u.value, r.type === "docType" && delete u.value;
          }
          a.ignoredProperties = s, n.exports = a;
        } }), Xd = Z({ "src/language-html/constants.evaluate.js"(e, n) {
          n.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
        } }), Kd = Z({ "src/language-html/utils/is-unknown-namespace.js"(e, n) {
          "use strict";
          re();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          n.exports = t;
        } }), qt = Z({ "src/language-html/utils/index.js"(e, n) {
          "use strict";
          re();
          var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: r, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: o } } = Oe(), { CSS_DISPLAY_TAGS: c, CSS_DISPLAY_DEFAULT: v, CSS_WHITE_SPACE_TAGS: m2, CSS_WHITE_SPACE_DEFAULT: d } = Xd(), p2 = Kd(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), h3 = (_) => _.replace(/^[\t\n\f\r ]+/, ""), w = (_) => _.replace(/[\t\n\f\r ]+$/, ""), T = (_) => h3(w(_)), A = (_) => _.replace(/^[\t\f\r ]*\n/g, ""), S = (_) => A(w(_)), B = (_) => _.split(/[\t\n\f\r ]+/), I = (_) => _.match(/^[\t\n\f\r ]*/)[0], k = (_) => {
            let [, J, ne, Ee] = _.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
            return { leadingWhitespace: J, trailingWhitespace: Ee, text: ne };
          }, P = (_) => /[\t\n\f\r ]/.test(_);
          function C(_, J) {
            return !!(_.type === "ieConditionalComment" && _.lastChild && !_.lastChild.isSelfClosing && !_.lastChild.endSourceSpan || _.type === "ieConditionalComment" && !_.complete || le(_) && _.children.some((ne) => ne.type !== "text" && ne.type !== "interpolation") || ye(_, J) && !l(_) && _.type !== "interpolation");
          }
          function D(_) {
            return _.type === "attribute" || !_.parent || !_.prev ? false : g(_.prev);
          }
          function g(_) {
            return _.type === "comment" && _.value.trim() === "prettier-ignore";
          }
          function F(_) {
            return _.type === "text" || _.type === "comment";
          }
          function l(_) {
            return _.type === "element" && (_.fullName === "script" || _.fullName === "style" || _.fullName === "svg:style" || p2(_) && (_.name === "script" || _.name === "style"));
          }
          function E(_) {
            return _.children && !l(_);
          }
          function y(_) {
            return l(_) || _.type === "interpolation" || N(_);
          }
          function N(_) {
            return ke(_).startsWith("pre");
          }
          function x(_, J) {
            let ne = Ee();
            if (ne && !_.prev && _.parent && _.parent.tagDefinition && _.parent.tagDefinition.ignoreFirstLf)
              return _.type === "interpolation";
            return ne;
            function Ee() {
              return s(_) ? false : (_.type === "text" || _.type === "interpolation") && _.prev && (_.prev.type === "text" || _.prev.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le(_.parent) ? true : !(!_.prev && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !De(_.parent.cssDisplay)) || _.prev && !z(_.prev.cssDisplay));
            }
          }
          function b(_, J) {
            return s(_) ? false : (_.type === "text" || _.type === "interpolation") && _.next && (_.next.type === "text" || _.next.type === "interpolation") ? true : !_.parent || _.parent.cssDisplay === "none" ? false : le(_.parent) ? true : !(!_.next && (_.parent.type === "root" || le(_) && _.parent || l(_.parent) || K(_.parent, J) || !ie(_.parent.cssDisplay)) || _.next && !G(_.next.cssDisplay));
          }
          function L(_) {
            return U(_.cssDisplay) && !l(_);
          }
          function M(_) {
            return s(_) || _.next && _.sourceSpan.end && _.sourceSpan.end.line + 1 < _.next.sourceSpan.start.line;
          }
          function j(_) {
            return $2(_) || _.type === "element" && _.children.length > 0 && (["body", "script", "style"].includes(_.name) || _.children.some((J) => te(J))) || _.firstChild && _.firstChild === _.lastChild && _.firstChild.type !== "text" && H(_.firstChild) && (!_.lastChild.isTrailingSpaceSensitive || R(_.lastChild));
          }
          function $2(_) {
            return _.type === "element" && _.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(_.name) || _.cssDisplay.startsWith("table") && _.cssDisplay !== "table-cell");
          }
          function V(_) {
            return Q(_) || _.prev && q(_.prev) || Y(_);
          }
          function q(_) {
            return Q(_) || _.type === "element" && _.fullName === "br" || Y(_);
          }
          function Y(_) {
            return H(_) && R(_);
          }
          function H(_) {
            return _.hasLeadingSpaces && (_.prev ? _.prev.sourceSpan.end.line < _.sourceSpan.start.line : _.parent.type === "root" || _.parent.startSourceSpan.end.line < _.sourceSpan.start.line);
          }
          function R(_) {
            return _.hasTrailingSpaces && (_.next ? _.next.sourceSpan.start.line > _.sourceSpan.end.line : _.parent.type === "root" || _.parent.endSourceSpan && _.parent.endSourceSpan.start.line > _.sourceSpan.end.line);
          }
          function Q(_) {
            switch (_.type) {
              case "ieConditionalComment":
              case "comment":
              case "directive":
                return true;
              case "element":
                return ["script", "select"].includes(_.name);
            }
            return false;
          }
          function ee(_) {
            return _.lastChild ? ee(_.lastChild) : _;
          }
          function te(_) {
            return _.children && _.children.some((J) => J.type !== "text");
          }
          function oe(_) {
            let { type: J, lang: ne } = _.attrMap;
            if (J === "module" || J === "text/javascript" || J === "text/babel" || J === "application/javascript" || ne === "jsx")
              return "babel";
            if (J === "application/x-typescript" || ne === "ts" || ne === "tsx")
              return "typescript";
            if (J === "text/markdown")
              return "markdown";
            if (J === "text/html")
              return "html";
            if (J && (J.endsWith("json") || J.endsWith("importmap")) || J === "speculationrules")
              return "json";
            if (J === "text/x-handlebars-template")
              return "glimmer";
          }
          function W(_, J) {
            let { lang: ne } = _.attrMap;
            if (!ne || ne === "postcss" || ne === "css")
              return "css";
            if (ne === "scss")
              return "scss";
            if (ne === "less")
              return "less";
            if (ne === "stylus")
              return t("stylus", J);
          }
          function X(_, J) {
            if (_.name === "script" && !_.attrMap.src)
              return !_.attrMap.lang && !_.attrMap.type ? "babel" : oe(_);
            if (_.name === "style")
              return W(_, J);
            if (J && ye(_, J))
              return oe(_) || !("src" in _.attrMap) && t(_.attrMap.lang, J);
          }
          function ue(_) {
            return _ === "block" || _ === "list-item" || _.startsWith("table");
          }
          function De(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function ie(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function G(_) {
            return !ue(_);
          }
          function z(_) {
            return !ue(_);
          }
          function U(_) {
            return !ue(_) && _ !== "inline-block";
          }
          function le(_) {
            return ke(_).startsWith("pre");
          }
          function ge(_, J) {
            let ne = 0;
            for (let Ee = _.stack.length - 1; Ee >= 0; Ee--) {
              let We = _.stack[Ee];
              We && typeof We == "object" && !Array.isArray(We) && J(We) && ne++;
            }
            return ne;
          }
          function Ae(_, J) {
            let ne = _;
            for (; ne; ) {
              if (J(ne))
                return true;
              ne = ne.parent;
            }
            return false;
          }
          function Ne(_, J) {
            if (_.prev && _.prev.type === "comment") {
              let Ee = _.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
              if (Ee)
                return Ee[1];
            }
            let ne = false;
            if (_.type === "element" && _.namespace === "svg")
              if (Ae(_, (Ee) => Ee.fullName === "svg:foreignObject"))
                ne = true;
              else
                return _.name === "svg" ? "inline-block" : "block";
            switch (J.htmlWhitespaceSensitivity) {
              case "strict":
                return "inline";
              case "ignore":
                return "block";
              default:
                return J.parser === "vue" && _.parent && _.parent.type === "root" ? "block" : _.type === "element" && (!_.namespace || ne || p2(_)) && c[_.name] || v;
            }
          }
          function ke(_) {
            return _.type === "element" && (!_.namespace || p2(_)) && m2[_.name] || d;
          }
          function ce(_) {
            let J = Number.POSITIVE_INFINITY;
            for (let ne of _.split(`
`)) {
              if (ne.length === 0)
                continue;
              if (!f.has(ne[0]))
                return 0;
              let Ee = I(ne).length;
              ne.length !== Ee && Ee < J && (J = Ee);
            }
            return J === Number.POSITIVE_INFINITY ? 0 : J;
          }
          function pe(_) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ce(_);
            return J === 0 ? _ : _.split(`
`).map((ne) => ne.slice(J)).join(`
`);
          }
          function de(_, J) {
            let ne = 0;
            for (let Ee = 0; Ee < _.length; Ee++)
              _[Ee] === J && ne++;
            return ne;
          }
          function ae(_) {
            return _.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
          }
          var ve = /* @__PURE__ */ new Set(["template", "style", "script"]);
          function K(_, J) {
            return he(_, J) && !ve.has(_.fullName);
          }
          function he(_, J) {
            return J.parser === "vue" && _.type === "element" && _.parent.type === "root" && _.fullName.toLowerCase() !== "html";
          }
          function ye(_, J) {
            return he(_, J) && (K(_, J) || _.attrMap.lang && _.attrMap.lang !== "html");
          }
          function Ce(_) {
            let J = _.fullName;
            return J.charAt(0) === "#" || J === "slot-scope" || J === "v-slot" || J.startsWith("v-slot:");
          }
          function Ie(_, J) {
            let ne = _.parent;
            if (!he(ne, J))
              return false;
            let Ee = ne.fullName, We = _.fullName;
            return Ee === "script" && We === "setup" || Ee === "style" && We === "vars";
          }
          function Fe(_) {
            let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _.value;
            return _.parent.isWhitespaceSensitive ? _.parent.isIndentationSensitive ? o(J) : o(pe(S(J)), r) : i(u(a, B(J)));
          }
          function me(_, J) {
            return he(_, J) && _.name === "script";
          }
          n.exports = { htmlTrim: T, htmlTrimPreserveIndentation: S, hasHtmlWhitespace: P, getLeadingAndTrailingHtmlWhitespace: k, canHaveInterpolation: E, countChars: de, countParents: ge, dedentString: pe, forceBreakChildren: $2, forceBreakContent: j, forceNextEmptyLine: M, getLastDescendant: ee, getNodeCssStyleDisplay: Ne, getNodeCssStyleWhiteSpace: ke, hasPrettierIgnore: D, inferScriptParser: X, isVueCustomBlock: K, isVueNonHtmlBlock: ye, isVueScriptTag: me, isVueSlotAttribute: Ce, isVueSfcBindingsAttribute: Ie, isVueSfcBlock: he, isDanglingSpaceSensitiveNode: L, isIndentationSensitiveNode: N, isLeadingSpaceSensitiveNode: x, isPreLikeNode: le, isScriptLikeTag: l, isTextLikeNode: F, isTrailingSpaceSensitiveNode: b, isWhitespaceSensitiveNode: y, isUnknownNamespace: p2, preferHardlineAsLeadingSpaces: V, preferHardlineAsTrailingSpaces: q, shouldPreserveContent: C, unescapeQuoteEntities: ae, getTextValueParts: Fe };
        } }), Yd = Z({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function n(i) {
            return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
          }
          e.isWhitespace = n;
          function t(i) {
            return e.$0 <= i && i <= e.$9;
          }
          e.isDigit = t;
          function s(i) {
            return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
          }
          e.isAsciiLetter = s;
          function a(i) {
            return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
          }
          e.isAsciiHexDigit = a;
          function r(i) {
            return i === e.$LF || i === e.$CR;
          }
          e.isNewLine = r;
          function u(i) {
            return e.$0 <= i && i <= e.$7;
          }
          e.isOctalDigit = u;
        } }), Qd = Z({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = class {
            constructor(s, a, r) {
              this.filePath = s, this.name = a, this.members = r;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
            }
          };
          e.StaticSymbol = n;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, a, r) {
              r = r || [];
              let u = r.length ? ".".concat(r.join(".")) : "", i = '"'.concat(s, '".').concat(a).concat(u), o = this.cache.get(i);
              return o || (o = new n(s, a, r), this.cache.set(i, o)), o;
            }
          };
          e.StaticSymbolCache = t;
        } }), Zd = Z({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = /-+([a-z0-9])/g;
          function t(l) {
            return l.replace(n, function() {
              for (var E = arguments.length, y = new Array(E), N = 0; N < E; N++)
                y[N] = arguments[N];
              return y[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s(l, E) {
            return r(l, ":", E);
          }
          e.splitAtColon = s;
          function a(l, E) {
            return r(l, ".", E);
          }
          e.splitAtPeriod = a;
          function r(l, E, y) {
            let N = l.indexOf(E);
            return N == -1 ? y : [l.slice(0, N).trim(), l.slice(N + 1).trim()];
          }
          function u(l, E, y) {
            return Array.isArray(l) ? E.visitArray(l, y) : A(l) ? E.visitStringMap(l, y) : l == null || typeof l == "string" || typeof l == "number" || typeof l == "boolean" ? E.visitPrimitive(l, y) : E.visitOther(l, y);
          }
          e.visitValue = u;
          function i(l) {
            return l != null;
          }
          e.isDefined = i;
          function o(l) {
            return l === void 0 ? null : l;
          }
          e.noUndefined = o;
          var c = class {
            visitArray(l, E) {
              return l.map((y) => u(y, this, E));
            }
            visitStringMap(l, E) {
              let y = {};
              return Object.keys(l).forEach((N) => {
                y[N] = u(l[N], this, E);
              }), y;
            }
            visitPrimitive(l, E) {
              return l;
            }
            visitOther(l, E) {
              return l;
            }
          };
          e.ValueTransformer = c, e.SyncAsync = { assertSync: (l) => {
            if (k(l))
              throw new Error("Illegal state: value cannot be a promise");
            return l;
          }, then: (l, E) => k(l) ? l.then(E) : E(l), all: (l) => l.some(k) ? Promise.all(l) : l };
          function v(l) {
            throw new Error("Internal Error: ".concat(l));
          }
          e.error = v;
          function m2(l, E) {
            let y = Error(l);
            return y[d] = true, E && (y[p2] = E), y;
          }
          e.syntaxError = m2;
          var d = "ngSyntaxError", p2 = "ngParseErrors";
          function f(l) {
            return l[d];
          }
          e.isSyntaxError = f;
          function h3(l) {
            return l[p2] || [];
          }
          e.getParseErrors = h3;
          function w(l) {
            return l.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = w;
          var T = Object.getPrototypeOf({});
          function A(l) {
            return typeof l == "object" && l !== null && Object.getPrototypeOf(l) === T;
          }
          function S(l) {
            let E = "";
            for (let y = 0; y < l.length; y++) {
              let N = l.charCodeAt(y);
              if (N >= 55296 && N <= 56319 && l.length > y + 1) {
                let x = l.charCodeAt(y + 1);
                x >= 56320 && x <= 57343 && (y++, N = (N - 55296 << 10) + x - 56320 + 65536);
              }
              N <= 127 ? E += String.fromCharCode(N) : N <= 2047 ? E += String.fromCharCode(N >> 6 & 31 | 192, N & 63 | 128) : N <= 65535 ? E += String.fromCharCode(N >> 12 | 224, N >> 6 & 63 | 128, N & 63 | 128) : N <= 2097151 && (E += String.fromCharCode(N >> 18 & 7 | 240, N >> 12 & 63 | 128, N >> 6 & 63 | 128, N & 63 | 128));
            }
            return E;
          }
          e.utf8Encode = S;
          function B(l) {
            if (typeof l == "string")
              return l;
            if (l instanceof Array)
              return "[" + l.map(B).join(", ") + "]";
            if (l == null)
              return "" + l;
            if (l.overriddenName)
              return "".concat(l.overriddenName);
            if (l.name)
              return "".concat(l.name);
            if (!l.toString)
              return "object";
            let E = l.toString();
            if (E == null)
              return "" + E;
            let y = E.indexOf(`
`);
            return y === -1 ? E : E.substring(0, y);
          }
          e.stringify = B;
          function I(l) {
            return typeof l == "function" && l.hasOwnProperty("__forward_ref__") ? l() : l;
          }
          e.resolveForwardRef = I;
          function k(l) {
            return !!l && typeof l.then == "function";
          }
          e.isPromise = k;
          var P = class {
            constructor(l) {
              this.full = l;
              let E = l.split(".");
              this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
            }
          };
          e.Version = P;
          var C = typeof window < "u" && window, D = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, g = typeof globalThis < "u" && globalThis, F = g || C || D;
          e.global = F;
        } }), eg = Z({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Qd(), t = Zd(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function a(y) {
            return y.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = a;
          var r = 0;
          function u(y) {
            if (!y || !y.reference)
              return null;
            let N = y.reference;
            if (N instanceof n.StaticSymbol)
              return N.name;
            if (N.__anonymousType)
              return N.__anonymousType;
            let x = t.stringify(N);
            return x.indexOf("(") >= 0 ? (x = "anonymous_".concat(r++), N.__anonymousType = x) : x = a(x), x;
          }
          e.identifierName = u;
          function i(y) {
            let N = y.reference;
            return N instanceof n.StaticSymbol ? N.filePath : "./".concat(t.stringify(N));
          }
          e.identifierModuleUrl = i;
          function o(y, N) {
            return "View_".concat(u({ reference: y }), "_").concat(N);
          }
          e.viewClassName = o;
          function c(y) {
            return "RenderType_".concat(u({ reference: y }));
          }
          e.rendererTypeName = c;
          function v(y) {
            return "HostView_".concat(u({ reference: y }));
          }
          e.hostViewClassName = v;
          function m2(y) {
            return "".concat(u({ reference: y }), "NgFactory");
          }
          e.componentFactoryName = m2;
          var d;
          (function(y) {
            y[y.Pipe = 0] = "Pipe", y[y.Directive = 1] = "Directive", y[y.NgModule = 2] = "NgModule", y[y.Injectable = 3] = "Injectable";
          })(d = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function p2(y) {
            return y.value != null ? a(y.value) : u(y.identifier);
          }
          e.tokenName = p2;
          function f(y) {
            return y.identifier != null ? y.identifier.reference : y.value;
          }
          e.tokenReference = f;
          var h3 = class {
            constructor() {
              let { moduleUrl: y, styles: N, styleUrls: x } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = y || null, this.styles = k(N), this.styleUrls = k(x);
            }
          };
          e.CompileStylesheetMetadata = h3;
          var w = class {
            constructor(y) {
              let { encapsulation: N, template: x, templateUrl: b, htmlAst: L, styles: M, styleUrls: j, externalStylesheets: $2, animations: V, ngContentSelectors: q, interpolation: Y, isInline: H, preserveWhitespaces: R } = y;
              if (this.encapsulation = N, this.template = x, this.templateUrl = b, this.htmlAst = L, this.styles = k(M), this.styleUrls = k(j), this.externalStylesheets = k($2), this.animations = V ? C(V) : [], this.ngContentSelectors = q || [], Y && Y.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = Y, this.isInline = H, this.preserveWhitespaces = R;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = w;
          var T = class {
            static create(y) {
              let { isHost: N, type: x, isComponent: b, selector: L, exportAs: M, changeDetection: j, inputs: $2, outputs: V, host: q, providers: Y, viewProviders: H, queries: R, guards: Q, viewQueries: ee, entryComponents: te, template: oe, componentViewType: W, rendererType: X, componentFactory: ue } = y, De = {}, ie = {}, G = {};
              q != null && Object.keys(q).forEach((le) => {
                let ge = q[le], Ae = le.match(s);
                Ae === null ? G[le] = ge : Ae[1] != null ? ie[Ae[1]] = ge : Ae[2] != null && (De[Ae[2]] = ge);
              });
              let z = {};
              $2 != null && $2.forEach((le) => {
                let ge = t.splitAtColon(le, [le, le]);
                z[ge[0]] = ge[1];
              });
              let U = {};
              return V != null && V.forEach((le) => {
                let ge = t.splitAtColon(le, [le, le]);
                U[ge[0]] = ge[1];
              }), new T({ isHost: N, type: x, isComponent: !!b, selector: L, exportAs: M, changeDetection: j, inputs: z, outputs: U, hostListeners: De, hostProperties: ie, hostAttributes: G, providers: Y, viewProviders: H, queries: R, guards: Q, viewQueries: ee, entryComponents: te, template: oe, componentViewType: W, rendererType: X, componentFactory: ue });
            }
            constructor(y) {
              let { isHost: N, type: x, isComponent: b, selector: L, exportAs: M, changeDetection: j, inputs: $2, outputs: V, hostListeners: q, hostProperties: Y, hostAttributes: H, providers: R, viewProviders: Q, queries: ee, guards: te, viewQueries: oe, entryComponents: W, template: X, componentViewType: ue, rendererType: De, componentFactory: ie } = y;
              this.isHost = !!N, this.type = x, this.isComponent = b, this.selector = L, this.exportAs = M, this.changeDetection = j, this.inputs = $2, this.outputs = V, this.hostListeners = q, this.hostProperties = Y, this.hostAttributes = H, this.providers = k(R), this.viewProviders = k(Q), this.queries = k(ee), this.guards = te, this.viewQueries = k(oe), this.entryComponents = k(W), this.template = X, this.componentViewType = ue, this.rendererType = De, this.componentFactory = ie;
            }
            toSummary() {
              return { summaryKind: d.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = T;
          var A = class {
            constructor(y) {
              let { type: N, name: x, pure: b } = y;
              this.type = N, this.name = x, this.pure = !!b;
            }
            toSummary() {
              return { summaryKind: d.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = A;
          var S = class {
          };
          e.CompileShallowModuleMetadata = S;
          var B = class {
            constructor(y) {
              let { type: N, providers: x, declaredDirectives: b, exportedDirectives: L, declaredPipes: M, exportedPipes: j, entryComponents: $2, bootstrapComponents: V, importedModules: q, exportedModules: Y, schemas: H, transitiveModule: R, id: Q } = y;
              this.type = N || null, this.declaredDirectives = k(b), this.exportedDirectives = k(L), this.declaredPipes = k(M), this.exportedPipes = k(j), this.providers = k(x), this.entryComponents = k($2), this.bootstrapComponents = k(V), this.importedModules = k(q), this.exportedModules = k(Y), this.schemas = k(H), this.id = Q || null, this.transitiveModule = R || null;
            }
            toSummary() {
              let y = this.transitiveModule;
              return { summaryKind: d.NgModule, type: this.type, entryComponents: y.entryComponents, providers: y.providers, modules: y.modules, exportedDirectives: y.exportedDirectives, exportedPipes: y.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = B;
          var I = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(y, N) {
              this.providers.push({ provider: y, module: N });
            }
            addDirective(y) {
              this.directivesSet.has(y.reference) || (this.directivesSet.add(y.reference), this.directives.push(y));
            }
            addExportedDirective(y) {
              this.exportedDirectivesSet.has(y.reference) || (this.exportedDirectivesSet.add(y.reference), this.exportedDirectives.push(y));
            }
            addPipe(y) {
              this.pipesSet.has(y.reference) || (this.pipesSet.add(y.reference), this.pipes.push(y));
            }
            addExportedPipe(y) {
              this.exportedPipesSet.has(y.reference) || (this.exportedPipesSet.add(y.reference), this.exportedPipes.push(y));
            }
            addModule(y) {
              this.modulesSet.has(y.reference) || (this.modulesSet.add(y.reference), this.modules.push(y));
            }
            addEntryComponent(y) {
              this.entryComponentsSet.has(y.componentType) || (this.entryComponentsSet.add(y.componentType), this.entryComponents.push(y));
            }
          };
          e.TransitiveCompileNgModuleMetadata = I;
          function k(y) {
            return y || [];
          }
          var P = class {
            constructor(y, N) {
              let { useClass: x, useValue: b, useExisting: L, useFactory: M, deps: j, multi: $2 } = N;
              this.token = y, this.useClass = x || null, this.useValue = b, this.useExisting = L, this.useFactory = M || null, this.dependencies = j || null, this.multi = !!$2;
            }
          };
          e.ProviderMeta = P;
          function C(y) {
            return y.reduce((N, x) => {
              let b = Array.isArray(x) ? C(x) : x;
              return N.concat(b);
            }, []);
          }
          e.flatten = C;
          function D(y) {
            return y.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function g(y, N, x) {
            let b;
            return x.isInline ? N.type.reference instanceof n.StaticSymbol ? b = "".concat(N.type.reference.filePath, ".").concat(N.type.reference.name, ".html") : b = "".concat(u(y), "/").concat(u(N.type), ".html") : b = x.templateUrl, N.type.reference instanceof n.StaticSymbol ? b : D(b);
          }
          e.templateSourceUrl = g;
          function F(y, N) {
            let x = y.moduleUrl.split(/\/\\/g), b = x[x.length - 1];
            return D("css/".concat(N).concat(b, ".ngstyle.js"));
          }
          e.sharedStylesheetJitUrl = F;
          function l(y) {
            return D("".concat(u(y.type), "/module.ngfactory.js"));
          }
          e.ngModuleJitUrl = l;
          function E(y, N) {
            return D("".concat(u(y), "/").concat(u(N.type), ".ngfactory.js"));
          }
          e.templateJitUrl = E;
        } }), tg = Z({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          "use strict";
          re(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Yd(), t = eg(), s = class {
            constructor(v, m2, d, p2) {
              this.file = v, this.offset = m2, this.line = d, this.col = p2;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(v) {
              let m2 = this.file.content, d = m2.length, p2 = this.offset, f = this.line, h3 = this.col;
              for (; p2 > 0 && v < 0; )
                if (p2--, v++, m2.charCodeAt(p2) == n.$LF) {
                  f--;
                  let T = m2.substr(0, p2 - 1).lastIndexOf(String.fromCharCode(n.$LF));
                  h3 = T > 0 ? p2 - T : p2;
                } else
                  h3--;
              for (; p2 < d && v > 0; ) {
                let w = m2.charCodeAt(p2);
                p2++, v--, w == n.$LF ? (f++, h3 = 0) : h3++;
              }
              return new s(this.file, p2, f, h3);
            }
            getContext(v, m2) {
              let d = this.file.content, p2 = this.offset;
              if (p2 != null) {
                p2 > d.length - 1 && (p2 = d.length - 1);
                let f = p2, h3 = 0, w = 0;
                for (; h3 < v && p2 > 0 && (p2--, h3++, !(d[p2] == `
` && ++w == m2)); )
                  ;
                for (h3 = 0, w = 0; h3 < v && f < d.length - 1 && (f++, h3++, !(d[f] == `
` && ++w == m2)); )
                  ;
                return { before: d.substring(p2, this.offset), after: d.substring(this.offset, f + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s;
          var a = class {
            constructor(v, m2) {
              this.content = v, this.url = m2;
            }
          };
          e.ParseSourceFile = a;
          var r = class {
            constructor(v, m2) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = v, this.end = m2, this.details = d;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = r, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new r(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var u;
          (function(v) {
            v[v.WARNING = 0] = "WARNING", v[v.ERROR = 1] = "ERROR";
          })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var i = class {
            constructor(v, m2) {
              let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
              this.span = v, this.msg = m2, this.level = d;
            }
            contextualMessage() {
              let v = this.span.start.getContext(100, 3);
              return v ? "".concat(this.msg, ' ("').concat(v.before, "[").concat(u[this.level], " ->]").concat(v.after, '")') : this.msg;
            }
            toString() {
              let v = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(v);
            }
          };
          e.ParseError = i;
          function o(v, m2) {
            let d = t.identifierModuleUrl(m2), p2 = d != null ? "in ".concat(v, " ").concat(t.identifierName(m2), " in ").concat(d) : "in ".concat(v, " ").concat(t.identifierName(m2)), f = new a("", p2);
            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.typeSourceSpan = o;
          function c(v, m2, d) {
            let p2 = "in ".concat(v, " ").concat(m2, " in ").concat(d), f = new a("", p2);
            return new r(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = c;
        } }), rg = Z({ "src/language-html/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var { ParseSourceSpan: t } = tg(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: r, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: o, isIndentationSensitiveNode: c, isLeadingSpaceSensitiveNode: v, isTrailingSpaceSensitiveNode: m2, isWhitespaceSensitiveNode: d, isVueScriptTag: p2 } = qt(), f = [w, T, S, I, k, D, P, C, g, B, F];
          function h3(l, E) {
            for (let y of f)
              y(l, E);
            return l;
          }
          function w(l) {
            l.walk((E) => {
              if (E.type === "element" && E.tagDefinition.ignoreFirstLf && E.children.length > 0 && E.children[0].type === "text" && E.children[0].value[0] === `
`) {
                let y = E.children[0];
                y.value.length === 1 ? E.removeChild(y) : y.value = y.value.slice(1);
              }
            });
          }
          function T(l) {
            let E = (y) => y.type === "element" && y.prev && y.prev.type === "ieConditionalStartComment" && y.prev.sourceSpan.end.offset === y.startSourceSpan.start.offset && y.firstChild && y.firstChild.type === "ieConditionalEndComment" && y.firstChild.sourceSpan.start.offset === y.startSourceSpan.end.offset;
            l.walk((y) => {
              if (y.children)
                for (let N = 0; N < y.children.length; N++) {
                  let x = y.children[N];
                  if (!E(x))
                    continue;
                  let b = x.prev, L = x.firstChild;
                  y.removeChild(b), N--;
                  let M = new t(b.sourceSpan.start, L.sourceSpan.end), j = new t(M.start, x.sourceSpan.end);
                  x.condition = b.condition, x.sourceSpan = j, x.startSourceSpan = M, x.removeChild(L);
                }
            });
          }
          function A(l, E, y) {
            l.walk((N) => {
              if (N.children)
                for (let x = 0; x < N.children.length; x++) {
                  let b = N.children[x];
                  if (b.type !== "text" && !E(b))
                    continue;
                  b.type !== "text" && (b.type = "text", b.value = y(b));
                  let L = b.prev;
                  !L || L.type !== "text" || (L.value += b.value, L.sourceSpan = new t(L.sourceSpan.start, b.sourceSpan.end), N.removeChild(b), x--);
                }
            });
          }
          function S(l) {
            return A(l, (E) => E.type === "cdata", (E) => "<![CDATA[".concat(E.value, "]]>"));
          }
          function B(l) {
            let E = (y) => y.type === "element" && y.attrs.length === 0 && y.children.length === 1 && y.firstChild.type === "text" && !r(y.children[0].value) && !y.firstChild.hasLeadingSpaces && !y.firstChild.hasTrailingSpaces && y.isLeadingSpaceSensitive && !y.hasLeadingSpaces && y.isTrailingSpaceSensitive && !y.hasTrailingSpaces && y.prev && y.prev.type === "text" && y.next && y.next.type === "text";
            l.walk((y) => {
              if (y.children)
                for (let N = 0; N < y.children.length; N++) {
                  let x = y.children[N];
                  if (!E(x))
                    continue;
                  let b = x.prev, L = x.next;
                  b.value += "<".concat(x.rawName, ">") + x.firstChild.value + "</".concat(x.rawName, ">") + L.value, b.sourceSpan = new t(b.sourceSpan.start, L.sourceSpan.end), b.isTrailingSpaceSensitive = L.isTrailingSpaceSensitive, b.hasTrailingSpaces = L.hasTrailingSpaces, y.removeChild(x), N--, y.removeChild(L);
                }
            });
          }
          function I(l, E) {
            if (E.parser === "html")
              return;
            let y = /{{(.+?)}}/s;
            l.walk((N) => {
              if (!!u(N))
                for (let x of N.children) {
                  if (x.type !== "text")
                    continue;
                  let b = x.sourceSpan.start, L = null, M = x.value.split(y);
                  for (let j = 0; j < M.length; j++, b = L) {
                    let $2 = M[j];
                    if (j % 2 === 0) {
                      L = b.moveBy($2.length), $2.length > 0 && N.insertChildBefore(x, { type: "text", value: $2, sourceSpan: new t(b, L) });
                      continue;
                    }
                    L = b.moveBy($2.length + 4), N.insertChildBefore(x, { type: "interpolation", sourceSpan: new t(b, L), children: $2.length === 0 ? [] : [{ type: "text", value: $2, sourceSpan: new t(b.moveBy(2), L.moveBy(-2)) }] });
                  }
                  N.removeChild(x);
                }
            });
          }
          function k(l) {
            l.walk((E) => {
              if (!E.children)
                return;
              if (E.children.length === 0 || E.children.length === 1 && E.children[0].type === "text" && s(E.children[0].value).length === 0) {
                E.hasDanglingSpaces = E.children.length > 0, E.children = [];
                return;
              }
              let y = d(E), N = c(E);
              if (!y)
                for (let x = 0; x < E.children.length; x++) {
                  let b = E.children[x];
                  if (b.type !== "text")
                    continue;
                  let { leadingWhitespace: L, text: M, trailingWhitespace: j } = a(b.value), $2 = b.prev, V = b.next;
                  M ? (b.value = M, b.sourceSpan = new t(b.sourceSpan.start.moveBy(L.length), b.sourceSpan.end.moveBy(-j.length)), L && ($2 && ($2.hasTrailingSpaces = true), b.hasLeadingSpaces = true), j && (b.hasTrailingSpaces = true, V && (V.hasLeadingSpaces = true))) : (E.removeChild(b), x--, (L || j) && ($2 && ($2.hasTrailingSpaces = true), V && (V.hasLeadingSpaces = true)));
                }
              E.isWhitespaceSensitive = y, E.isIndentationSensitive = N;
            });
          }
          function P(l) {
            l.walk((E) => {
              E.isSelfClosing = !E.children || E.type === "element" && (E.tagDefinition.isVoid || E.startSourceSpan === E.endSourceSpan);
            });
          }
          function C(l, E) {
            l.walk((y) => {
              y.type === "element" && (y.hasHtmComponentClosingTag = y.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(E.originalText.slice(y.endSourceSpan.start.offset, y.endSourceSpan.end.offset)));
            });
          }
          function D(l, E) {
            l.walk((y) => {
              y.cssDisplay = i(y, E);
            });
          }
          function g(l, E) {
            l.walk((y) => {
              let { children: N } = y;
              if (!!N) {
                if (N.length === 0) {
                  y.isDanglingSpaceSensitive = o(y);
                  return;
                }
                for (let x of N)
                  x.isLeadingSpaceSensitive = v(x, E), x.isTrailingSpaceSensitive = m2(x, E);
                for (let x = 0; x < N.length; x++) {
                  let b = N[x];
                  b.isLeadingSpaceSensitive = (x === 0 || b.prev.isTrailingSpaceSensitive) && b.isLeadingSpaceSensitive, b.isTrailingSpaceSensitive = (x === N.length - 1 || b.next.isLeadingSpaceSensitive) && b.isTrailingSpaceSensitive;
                }
              }
            });
          }
          function F(l, E) {
            if (E.parser === "vue") {
              let y = l.children.find((x) => p2(x, E));
              if (!y)
                return;
              let { lang: N } = y.attrMap;
              (N === "ts" || N === "typescript") && (E.__should_parse_vue_template_with_ts = true);
            }
          }
          n.exports = h3;
        } }), ng = Z({ "src/language-html/pragma.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
          }
          function s(a) {
            return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
          }
          n.exports = { hasPragma: t, insertPragma: s };
        } }), Yn = Z({ "src/language-html/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.sourceSpan.start.offset;
          }
          function s(a) {
            return a.sourceSpan.end.offset;
          }
          n.exports = { locStart: t, locEnd: s };
        } }), er = Z({ "src/language-html/print/tag.js"(e, n) {
          "use strict";
          re();
          var t = Xt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: r, line: u, softline: i, hardline: o }, utils: { replaceTextEndOfLine: c } } = Oe(), { locStart: v, locEnd: m2 } = Yn(), { isTextLikeNode: d, getLastDescendant: p2, isPreLikeNode: f, hasPrettierIgnore: h3, shouldPreserveContent: w, isVueSfcBlock: T } = qt();
          function A(q, Y) {
            return [q.isSelfClosing ? "" : S(q, Y), B(q, Y)];
          }
          function S(q, Y) {
            return q.lastChild && l(q.lastChild) ? "" : [I(q, Y), P(q, Y)];
          }
          function B(q, Y) {
            return (q.next ? g(q.next) : F(q.parent)) ? "" : [C(q, Y), k(q, Y)];
          }
          function I(q, Y) {
            return F(q) ? C(q.lastChild, Y) : "";
          }
          function k(q, Y) {
            return l(q) ? P(q.parent, Y) : E(q) ? $2(q.next) : "";
          }
          function P(q, Y) {
            if (t(!q.isSelfClosing), D(q, Y))
              return "";
            switch (q.type) {
              case "ieConditionalComment":
                return "<!";
              case "element":
                if (q.hasHtmComponentClosingTag)
                  return "<//";
              default:
                return "</".concat(q.rawName);
            }
          }
          function C(q, Y) {
            if (D(q, Y))
              return "";
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalEndComment":
                return "[endif]-->";
              case "ieConditionalStartComment":
                return "]><!-->";
              case "interpolation":
                return "}}";
              case "element":
                if (q.isSelfClosing)
                  return "/>";
              default:
                return ">";
            }
          }
          function D(q, Y) {
            return !q.isSelfClosing && !q.endSourceSpan && (h3(q) || w(q.parent, Y));
          }
          function g(q) {
            return q.prev && q.prev.type !== "docType" && !d(q.prev) && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function F(q) {
            return q.lastChild && q.lastChild.isTrailingSpaceSensitive && !q.lastChild.hasTrailingSpaces && !d(p2(q.lastChild)) && !f(q);
          }
          function l(q) {
            return !q.next && !q.hasTrailingSpaces && q.isTrailingSpaceSensitive && d(p2(q));
          }
          function E(q) {
            return q.next && !d(q.next) && d(q) && q.isTrailingSpaceSensitive && !q.hasTrailingSpaces;
          }
          function y(q) {
            let Y = q.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
            return Y ? Y[1] ? Y[1].split(/\s+/) : true : false;
          }
          function N(q) {
            return !q.prev && q.isLeadingSpaceSensitive && !q.hasLeadingSpaces;
          }
          function x(q, Y, H) {
            let R = q.getValue();
            if (!s(R.attrs))
              return R.isSelfClosing ? " " : "";
            let Q = R.prev && R.prev.type === "comment" && y(R.prev.value), ee = typeof Q == "boolean" ? () => Q : Array.isArray(Q) ? (De) => Q.includes(De.rawName) : () => false, te = q.map((De) => {
              let ie = De.getValue();
              return ee(ie) ? c(Y.originalText.slice(v(ie), m2(ie))) : H();
            }, "attrs"), oe = R.type === "element" && R.fullName === "script" && R.attrs.length === 1 && R.attrs[0].fullName === "src" && R.children.length === 0, X = Y.singleAttributePerLine && R.attrs.length > 1 && !T(R, Y) ? o : u, ue = [a([oe ? " " : u, r(X, te)])];
            return R.firstChild && N(R.firstChild) || R.isSelfClosing && F(R.parent) || oe ? ue.push(R.isSelfClosing ? " " : "") : ue.push(Y.bracketSameLine ? R.isSelfClosing ? " " : "" : R.isSelfClosing ? u : i), ue;
          }
          function b(q) {
            return q.firstChild && N(q.firstChild) ? "" : V(q);
          }
          function L(q, Y, H) {
            let R = q.getValue();
            return [M(R, Y), x(q, Y, H), R.isSelfClosing ? "" : b(R)];
          }
          function M(q, Y) {
            return q.prev && E(q.prev) ? "" : [j(q, Y), $2(q)];
          }
          function j(q, Y) {
            return N(q) ? V(q.parent) : g(q) ? C(q.prev, Y) : "";
          }
          function $2(q) {
            switch (q.type) {
              case "ieConditionalComment":
              case "ieConditionalStartComment":
                return "<!--[if ".concat(q.condition);
              case "ieConditionalEndComment":
                return "<!--<!";
              case "interpolation":
                return "{{";
              case "docType":
                return "<!DOCTYPE";
              case "element":
                if (q.condition)
                  return "<!--[if ".concat(q.condition, "]><!--><").concat(q.rawName);
              default:
                return "<".concat(q.rawName);
            }
          }
          function V(q) {
            switch (t(!q.isSelfClosing), q.type) {
              case "ieConditionalComment":
                return "]>";
              case "element":
                if (q.condition)
                  return "><!--<![endif]-->";
              default:
                return ">";
            }
          }
          n.exports = { printClosingTag: A, printClosingTagStart: S, printClosingTagStartMarker: P, printClosingTagEndMarker: C, printClosingTagSuffix: k, printClosingTagEnd: B, needsToBorrowLastChildClosingTagEndMarker: F, needsToBorrowParentClosingTagStartMarker: l, needsToBorrowPrevClosingTagEndMarker: g, printOpeningTag: L, printOpeningTagStart: M, printOpeningTagPrefix: j, printOpeningTagStartMarker: $2, printOpeningTagEndMarker: V, needsToBorrowNextOpeningTagStartMarker: E, needsToBorrowParentOpeningTagEndMarker: N };
        } }), ug = Z({ "node_modules/parse-srcset/src/parse-srcset.js"(e, n) {
          re(), function(t, s) {
            typeof define == "function" && define.amd ? define([], s) : typeof n == "object" && n.exports ? n.exports = s() : t.parseSrcset = s();
          }(e, function() {
            return function(t, s) {
              var a = s && s.logger || console;
              function r(P) {
                return P === " " || P === "	" || P === `
` || P === "\f" || P === "\r";
              }
              function u(P) {
                var C, D = P.exec(t.substring(S));
                if (D)
                  return C = D[0], S += C.length, C;
              }
              for (var i = t.length, o = /^[ \t\n\r\u000c]+/, c = /^[, \t\n\r\u000c]+/, v = /^[^ \t\n\r\u000c]+/, m2 = /[,]+$/, d = /^\d+$/, p2 = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, h3, w, T, A, S = 0, B = []; ; ) {
                if (u(c), S >= i)
                  return B;
                f = u(v), h3 = [], f.slice(-1) === "," ? (f = f.replace(m2, ""), k()) : I();
              }
              function I() {
                for (u(o), w = "", T = "in descriptor"; ; ) {
                  if (A = t.charAt(S), T === "in descriptor")
                    if (r(A))
                      w && (h3.push(w), w = "", T = "after descriptor");
                    else if (A === ",") {
                      S += 1, w && h3.push(w), k();
                      return;
                    } else if (A === "(")
                      w = w + A, T = "in parens";
                    else if (A === "") {
                      w && h3.push(w), k();
                      return;
                    } else
                      w = w + A;
                  else if (T === "in parens")
                    if (A === ")")
                      w = w + A, T = "in descriptor";
                    else if (A === "") {
                      h3.push(w), k();
                      return;
                    } else
                      w = w + A;
                  else if (T === "after descriptor" && !r(A))
                    if (A === "") {
                      k();
                      return;
                    } else
                      T = "in descriptor", S -= 1;
                  S += 1;
                }
              }
              function k() {
                var P = false, C, D, g, F, l = {}, E, y, N, x, b;
                for (F = 0; F < h3.length; F++)
                  E = h3[F], y = E[E.length - 1], N = E.substring(0, E.length - 1), x = parseInt(N, 10), b = parseFloat(N), d.test(N) && y === "w" ? ((C || D) && (P = true), x === 0 ? P = true : C = x) : p2.test(N) && y === "x" ? ((C || D || g) && (P = true), b < 0 ? P = true : D = b) : d.test(N) && y === "h" ? ((g || D) && (P = true), x === 0 ? P = true : g = x) : P = true;
                P ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + E + "'.") : (l.url = f, C && (l.w = C), D && (l.d = D), g && (l.h = g), B.push(l));
              }
            };
          });
        } }), sg = Z({ "src/language-html/syntax-attribute.js"(e, n) {
          "use strict";
          re();
          var t = ug(), { builders: { ifBreak: s, join: a, line: r } } = Oe();
          function u(o) {
            let c = t(o, { logger: { error(I) {
              throw new Error(I);
            } } }), v = c.some((I) => {
              let { w: k } = I;
              return k;
            }), m2 = c.some((I) => {
              let { h: k } = I;
              return k;
            }), d = c.some((I) => {
              let { d: k } = I;
              return k;
            });
            if (v + m2 + d > 1)
              throw new Error("Mixed descriptor in srcset is not supported");
            let p2 = v ? "w" : m2 ? "h" : "d", f = v ? "w" : m2 ? "h" : "x", h3 = (I) => Math.max(...I), w = c.map((I) => I.url), T = h3(w.map((I) => I.length)), A = c.map((I) => I[p2]).map((I) => I ? I.toString() : ""), S = A.map((I) => {
              let k = I.indexOf(".");
              return k === -1 ? I.length : k;
            }), B = h3(S);
            return a([",", r], w.map((I, k) => {
              let P = [I], C = A[k];
              if (C) {
                let D = T - I.length + 1, g = B - S[k], F = " ".repeat(D + g);
                P.push(s(F, " "), C + f);
              }
              return P;
            }));
          }
          function i(o) {
            return o.trim().split(/\s+/).join(" ");
          }
          n.exports = { printImgSrcset: u, printClassNames: i };
        } }), ig = Z({ "src/language-html/syntax-vue.js"(e, n) {
          "use strict";
          re();
          var { builders: { group: t } } = Oe();
          function s(i, o) {
            let { left: c, operator: v, right: m2 } = a(i);
            return [t(o("function _(".concat(c, ") {}"), { parser: "babel", __isVueForBindingLeft: true })), " ", v, " ", o(m2, { parser: "__js_expression" }, { stripTrailingHardline: true })];
          }
          function a(i) {
            let o = /(.*?)\s+(in|of)\s+(.*)/s, c = /,([^,\]}]*)(?:,([^,\]}]*))?$/, v = /^\(|\)$/g, m2 = i.match(o);
            if (!m2)
              return;
            let d = {};
            if (d.for = m2[3].trim(), !d.for)
              return;
            let p2 = m2[1].trim().replace(v, ""), f = p2.match(c);
            f ? (d.alias = p2.replace(c, ""), d.iterator1 = f[1].trim(), f[2] && (d.iterator2 = f[2].trim())) : d.alias = p2;
            let h3 = [d.alias, d.iterator1, d.iterator2];
            if (!h3.some((w, T) => !w && (T === 0 || h3.slice(T + 1).some(Boolean))))
              return { left: h3.filter(Boolean).join(","), operator: m2[2], right: d.for };
          }
          function r(i, o) {
            return o("function _(".concat(i, ") {}"), { parser: "babel", __isVueBindings: true });
          }
          function u(i) {
            let o = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, c = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, v = i.trim();
            return o.test(v) || c.test(v);
          }
          n.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: r };
        } }), ho = Z({ "src/language-html/get-node-content.js"(e, n) {
          "use strict";
          re();
          var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: r, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = er();
          function o(c, v) {
            let m2 = c.startSourceSpan.end.offset;
            c.firstChild && u(c.firstChild) && (m2 -= i(c).length);
            let d = c.endSourceSpan.start.offset;
            return c.lastChild && t(c.lastChild) ? d += s(c, v).length : a(c) && (d -= r(c.lastChild, v).length), v.originalText.slice(m2, d);
          }
          n.exports = o;
        } }), ag = Z({ "src/language-html/embed.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, group: s, hardline: a, indent: r, line: u, fill: i, softline: o }, utils: { mapDoc: c, replaceTextEndOfLine: v } } = Oe(), m2 = Xn(), { printClosingTag: d, printClosingTagSuffix: p2, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: h3, printOpeningTag: w } = er(), { printImgSrcset: T, printClassNames: A } = sg(), { printVueFor: S, printVueBindings: B, isVueEventBindingExpression: I } = ig(), { isScriptLikeTag: k, isVueNonHtmlBlock: P, inferScriptParser: C, htmlTrimPreserveIndentation: D, dedentString: g, unescapeQuoteEntities: F, isVueSlotAttribute: l, isVueSfcBindingsAttribute: E, getTextValueParts: y } = qt(), N = ho();
          function x(L, M, j) {
            let $2 = (te) => new RegExp(te.join("|")).test(L.fullName), V = () => F(L.value), q = false, Y = (te, oe) => {
              let W = te.type === "NGRoot" ? te.node.type === "NGMicrosyntax" && te.node.body.length === 1 && te.node.body[0].type === "NGMicrosyntaxExpression" ? te.node.body[0].expression : te.node : te.type === "JsExpressionRoot" ? te.node : te;
              W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || oe.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (q = true);
            }, H = (te) => s(te), R = function(te) {
              let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return s([r([o, te]), oe ? o : ""]);
            }, Q = (te) => q ? H(te) : R(te), ee = (te, oe) => M(te, Object.assign({ __onHtmlBindingRoot: Y, __embeddedInHtml: true }, oe));
            if (L.fullName === "srcset" && (L.parent.fullName === "img" || L.parent.fullName === "source"))
              return R(T(V()));
            if (L.fullName === "class" && !j.parentParser) {
              let te = V();
              if (!te.includes("{{"))
                return A(te);
            }
            if (L.fullName === "style" && !j.parentParser) {
              let te = V();
              if (!te.includes("{{"))
                return R(ee(te, { parser: "css", __isHTMLStyleAttribute: true }));
            }
            if (j.parser === "vue") {
              if (L.fullName === "v-for")
                return S(V(), ee);
              if (l(L) || E(L, j))
                return B(V(), ee);
              let te = ["^@", "^v-on:"], oe = ["^:", "^v-bind:"], W = ["^v-"];
              if ($2(te)) {
                let X = V(), ue = I(X) ? "__js_expression" : j.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
                return Q(ee(X, { parser: ue }));
              }
              if ($2(oe))
                return Q(ee(V(), { parser: "__vue_expression" }));
              if ($2(W))
                return Q(ee(V(), { parser: "__js_expression" }));
            }
            if (j.parser === "angular") {
              let te = (G, z) => ee(G, Object.assign(Object.assign({}, z), {}, { trailingComma: "none" })), oe = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], X = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], ue = ["^i18n(-.+)?$"];
              if ($2(W))
                return Q(te(V(), { parser: "__ng_action" }));
              if ($2(X))
                return Q(te(V(), { parser: "__ng_binding" }));
              if ($2(ue)) {
                let G = V().trim();
                return R(i(y(L, G)), !G.includes("@@"));
              }
              if ($2(oe))
                return Q(te(V(), { parser: "__ng_directive" }));
              let De = /{{(.+?)}}/s, ie = V();
              if (De.test(ie)) {
                let G = [];
                for (let [z, U] of ie.split(De).entries())
                  if (z % 2 === 0)
                    G.push(v(U));
                  else
                    try {
                      G.push(s(["{{", r([u, te(U, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
                    } catch {
                      G.push("{{", v(U), "}}");
                    }
                return s(G);
              }
            }
            return null;
          }
          function b(L, M, j, $2) {
            let V = L.getValue();
            switch (V.type) {
              case "element": {
                if (k(V) || V.type === "interpolation")
                  return;
                if (!V.isSelfClosing && P(V, $2)) {
                  let q = C(V, $2);
                  if (!q)
                    return;
                  let Y = N(V, $2), H = /^\s*$/.test(Y), R = "";
                  return H || (R = j(D(Y), { parser: q, __embeddedInHtml: true }, { stripTrailingHardline: true }), H = R === ""), [h3(V, $2), s(w(L, $2, M)), H ? "" : a, R, H ? "" : a, d(V, $2), p2(V, $2)];
                }
                break;
              }
              case "text": {
                if (k(V.parent)) {
                  let q = C(V.parent, $2);
                  if (q) {
                    let Y = q === "markdown" ? g(V.value.replace(/^[^\S\n]*\n/, "")) : V.value, H = { parser: q, __embeddedInHtml: true };
                    if ($2.parser === "html" && q === "babel") {
                      let R = "script", { attrMap: Q } = V.parent;
                      Q && (Q.type === "module" || Q.type === "text/babel" && Q["data-type"] === "module") && (R = "module"), H.__babelSourceType = R;
                    }
                    return [t, h3(V, $2), j(Y, H, { stripTrailingHardline: true }), p2(V, $2)];
                  }
                } else if (V.parent.type === "interpolation") {
                  let q = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
                  return $2.parser === "angular" ? (q.parser = "__ng_interpolation", q.trailingComma = "none") : $2.parser === "vue" ? q.parser = $2.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : q.parser = "__js_expression", [r([u, j(V.value, q, { stripTrailingHardline: true })]), V.parent.next && f(V.parent.next) ? " " : u];
                }
                break;
              }
              case "attribute": {
                if (!V.value)
                  break;
                if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test($2.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                  return [V.rawName, "=", V.value];
                if ($2.parser === "lwc" && /^{.*}$/s.test($2.originalText.slice(V.valueSpan.start.offset, V.valueSpan.end.offset)))
                  return [V.rawName, "=", V.value];
                let q = x(V, (Y, H) => j(Y, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, H), { stripTrailingHardline: true }), $2);
                if (q)
                  return [V.rawName, '="', s(c(q, (Y) => typeof Y == "string" ? Y.replace(/"/g, "&quot;") : Y)), '"'];
                break;
              }
              case "front-matter":
                return m2(V, j);
            }
          }
          n.exports = b;
        } }), vo = Z({ "src/language-html/print/children.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, group: s, ifBreak: a, line: r, softline: u, hardline: i }, utils: { replaceTextEndOfLine: o } } = Oe(), { locStart: c, locEnd: v } = Yn(), { forceBreakChildren: m2, forceNextEmptyLine: d, isTextLikeNode: p2, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: h3 } = qt(), { printOpeningTagPrefix: w, needsToBorrowNextOpeningTagStartMarker: T, printOpeningTagStartMarker: A, needsToBorrowPrevClosingTagEndMarker: S, printClosingTagEndMarker: B, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: k } = er();
          function P(g, F, l) {
            let E = g.getValue();
            return f(E) ? [w(E, F), ...o(F.originalText.slice(c(E) + (E.prev && T(E.prev) ? A(E).length : 0), v(E) - (E.next && S(E.next) ? B(E, F).length : 0))), I(E, F)] : l();
          }
          function C(g, F) {
            return p2(g) && p2(F) ? g.isTrailingSpaceSensitive ? g.hasTrailingSpaces ? h3(F) ? i : r : "" : h3(F) ? i : u : T(g) && (f(F) || F.firstChild || F.isSelfClosing || F.type === "element" && F.attrs.length > 0) || g.type === "element" && g.isSelfClosing && S(F) ? "" : !F.isLeadingSpaceSensitive || h3(F) || S(F) && g.lastChild && k(g.lastChild) && g.lastChild.lastChild && k(g.lastChild.lastChild) ? i : F.hasLeadingSpaces ? r : u;
          }
          function D(g, F, l) {
            let E = g.getValue();
            if (m2(E))
              return [t, ...g.map((N) => {
                let x = N.getValue(), b = x.prev ? C(x.prev, x) : "";
                return [b ? [b, d(x.prev) ? i : ""] : "", P(N, F, l)];
              }, "children")];
            let y = E.children.map(() => Symbol(""));
            return g.map((N, x) => {
              let b = N.getValue();
              if (p2(b)) {
                if (b.prev && p2(b.prev)) {
                  let Y = C(b.prev, b);
                  if (Y)
                    return d(b.prev) ? [i, i, P(N, F, l)] : [Y, P(N, F, l)];
                }
                return P(N, F, l);
              }
              let L = [], M = [], j = [], $2 = [], V = b.prev ? C(b.prev, b) : "", q = b.next ? C(b, b.next) : "";
              return V && (d(b.prev) ? L.push(i, i) : V === i ? L.push(i) : p2(b.prev) ? M.push(V) : M.push(a("", u, { groupId: y[x - 1] }))), q && (d(b) ? p2(b.next) && $2.push(i, i) : q === i ? p2(b.next) && $2.push(i) : j.push(q)), [...L, s([...M, s([P(N, F, l), ...j], { id: y[x] })]), ...$2];
            }, "children");
          }
          n.exports = { printChildren: D };
        } }), og = Z({ "src/language-html/print/element.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: r, indentIfBreak: u, indent: i, line: o, softline: c }, utils: { replaceTextEndOfLine: v } } = Oe(), m2 = ho(), { shouldPreserveContent: d, isScriptLikeTag: p2, isVueCustomBlock: f, countParents: h3, forceBreakContent: w } = qt(), { printOpeningTagPrefix: T, printOpeningTag: A, printClosingTagSuffix: S, printClosingTag: B, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: k } = er(), { printChildren: P } = vo();
          function C(D, g, F) {
            let l = D.getValue();
            if (d(l, g))
              return [T(l, g), a(A(D, g, F)), ...v(m2(l, g)), ...B(l, g), S(l, g)];
            let E = l.children.length === 1 && l.firstChild.type === "interpolation" && l.firstChild.isLeadingSpaceSensitive && !l.firstChild.hasLeadingSpaces && l.lastChild.isTrailingSpaceSensitive && !l.lastChild.hasTrailingSpaces, y = Symbol("element-attr-group-id"), N = (M) => a([a(A(D, g, F), { id: y }), M, B(l, g)]), x = (M) => E ? u(M, { groupId: y }) : (p2(l) || f(l, g)) && l.parent.type === "root" && g.parser === "vue" && !g.vueIndentScriptAndStyle ? M : i(M), b = () => E ? r(c, "", { groupId: y }) : l.firstChild.hasLeadingSpaces && l.firstChild.isLeadingSpaceSensitive ? o : l.firstChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive ? s(c) : c, L = () => (l.next ? I(l.next) : k(l.parent)) ? l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? " " : "" : E ? r(c, "", { groupId: y }) : l.lastChild.hasTrailingSpaces && l.lastChild.isTrailingSpaceSensitive ? o : (l.lastChild.type === "comment" || l.lastChild.type === "text" && l.isWhitespaceSensitive && l.isIndentationSensitive) && new RegExp("\\n[\\t ]{".concat(g.tabWidth * h3(D, (j) => j.parent && j.parent.type !== "root"), "}$")).test(l.lastChild.value) ? "" : c;
            return l.children.length === 0 ? N(l.hasDanglingSpaces && l.isDanglingSpaceSensitive ? o : "") : N([w(l) ? t : "", x([b(), P(D, g, F)]), L()]);
          }
          n.exports = { printElement: C };
        } }), lg = Z({ "src/language-html/printer-html.js"(e, n) {
          "use strict";
          re();
          var { builders: { fill: t, group: s, hardline: a, literalline: r }, utils: { cleanDoc: u, getDocParts: i, isConcat: o, replaceTextEndOfLine: c } } = Oe(), v = zd(), { countChars: m2, unescapeQuoteEntities: d, getTextValueParts: p2 } = qt(), f = rg(), { insertPragma: h3 } = ng(), { locStart: w, locEnd: T } = Yn(), A = ag(), { printClosingTagSuffix: S, printClosingTagEnd: B, printOpeningTagPrefix: I, printOpeningTagStart: k } = er(), { printElement: P } = og(), { printChildren: C } = vo();
          function D(g, F, l) {
            let E = g.getValue();
            switch (E.type) {
              case "front-matter":
                return c(E.raw);
              case "root":
                return F.__onHtmlRoot && F.__onHtmlRoot(E), [s(C(g, F, l)), a];
              case "element":
              case "ieConditionalComment":
                return P(g, F, l);
              case "ieConditionalStartComment":
              case "ieConditionalEndComment":
                return [k(E), B(E)];
              case "interpolation":
                return [k(E, F), ...g.map(l, "children"), B(E, F)];
              case "text": {
                if (E.parent.type === "interpolation") {
                  let N = /\n[^\S\n]*$/, x = N.test(E.value), b = x ? E.value.replace(N, "") : E.value;
                  return [...c(b), x ? a : ""];
                }
                let y = u([I(E, F), ...p2(E), S(E, F)]);
                return o(y) || y.type === "fill" ? t(i(y)) : y;
              }
              case "docType":
                return [s([k(E, F), " ", E.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), B(E, F)];
              case "comment":
                return [I(E, F), ...c(F.originalText.slice(w(E), T(E)), r), S(E, F)];
              case "attribute": {
                if (E.value === null)
                  return E.rawName;
                let y = d(E.value), N = m2(y, "'"), x = m2(y, '"'), b = N < x ? "'" : '"';
                return [E.rawName, "=", b, ...c(b === '"' ? y.replace(/"/g, "&quot;") : y.replace(/'/g, "&apos;")), b];
              }
              default:
                throw new Error("Unexpected node type ".concat(E.type));
            }
          }
          n.exports = { preprocess: f, print: D, insertPragma: h3, massageAstNode: v, embed: A };
        } }), cg = Z({ "src/language-html/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot(), s = "HTML";
          n.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
        } }), pg = Z({ "src/language-html/parsers.js"() {
          re();
        } }), xn = Z({ "node_modules/linguist-languages/data/HTML.json"(e, n) {
          n.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
        } }), fg = Z({ "node_modules/linguist-languages/data/Vue.json"(e, n) {
          n.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
        } }), Dg = Z({ "src/language-html/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = lg(), a = cg(), r = pg(), u = [t(xn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(xn(), (o) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...o.extensions, ".mjml"] })), t(xn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(fg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
          n.exports = { languages: u, printers: i, options: a, parsers: r };
        } }), mg = Z({ "src/language-yaml/pragma.js"(e, n) {
          "use strict";
          re();
          function t(r) {
            return /^\s*@(?:prettier|format)\s*$/.test(r);
          }
          function s(r) {
            return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(r);
          }
          function a(r) {
            return `# @format

`.concat(r);
          }
          n.exports = { isPragma: t, hasPragma: s, insertPragma: a };
        } }), dg = Z({ "src/language-yaml/loc.js"(e, n) {
          "use strict";
          re();
          function t(a) {
            return a.position.start.offset;
          }
          function s(a) {
            return a.position.end.offset;
          }
          n.exports = { locStart: t, locEnd: s };
        } }), gg = Z({ "src/language-yaml/embed.js"(e, n) {
          "use strict";
          re();
          function t(s, a, r, u) {
            if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint)rc$/.test(u.filepath))
              return r(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
          }
          n.exports = t;
        } }), Mt = Z({ "src/language-yaml/utils.js"(e, n) {
          "use strict";
          re();
          var { getLast: t, isNonEmptyArray: s } = Ue();
          function a(C, D) {
            let g = 0, F = C.stack.length - 1;
            for (let l = 0; l < F; l++) {
              let E = C.stack[l];
              r(E) && D(E) && g++;
            }
            return g;
          }
          function r(C, D) {
            return C && typeof C.type == "string" && (!D || D.includes(C.type));
          }
          function u(C, D, g) {
            return D("children" in C ? Object.assign(Object.assign({}, C), {}, { children: C.children.map((F) => u(F, D, C)) }) : C, g);
          }
          function i(C, D, g) {
            Object.defineProperty(C, D, { get: g, enumerable: false });
          }
          function o(C, D) {
            let g = 0, F = D.length;
            for (let l = C.position.end.offset - 1; l < F; l++) {
              let E = D[l];
              if (E === `
` && g++, g === 1 && /\S/.test(E))
                return false;
              if (g === 2)
                return true;
            }
            return false;
          }
          function c(C) {
            switch (C.getValue().type) {
              case "tag":
              case "anchor":
              case "comment":
                return false;
            }
            let g = C.stack.length;
            for (let F = 1; F < g; F++) {
              let l = C.stack[F], E = C.stack[F - 1];
              if (Array.isArray(E) && typeof l == "number" && l !== E.length - 1)
                return false;
            }
            return true;
          }
          function v(C) {
            return s(C.children) ? v(t(C.children)) : C;
          }
          function m2(C) {
            return C.value.trim() === "prettier-ignore";
          }
          function d(C) {
            let D = C.getValue();
            if (D.type === "documentBody") {
              let g = C.getParentNode();
              return S(g.head) && m2(t(g.head.endComments));
            }
            return h3(D) && m2(t(D.leadingComments));
          }
          function p2(C) {
            return !s(C.children) && !f(C);
          }
          function f(C) {
            return h3(C) || w(C) || T(C) || A(C) || S(C);
          }
          function h3(C) {
            return s(C == null ? void 0 : C.leadingComments);
          }
          function w(C) {
            return s(C == null ? void 0 : C.middleComments);
          }
          function T(C) {
            return C == null ? void 0 : C.indicatorComment;
          }
          function A(C) {
            return C == null ? void 0 : C.trailingComment;
          }
          function S(C) {
            return s(C == null ? void 0 : C.endComments);
          }
          function B(C) {
            let D = [], g;
            for (let F of C.split(/( +)/))
              F !== " " ? g === " " ? D.push(F) : D.push((D.pop() || "") + F) : g === void 0 && D.unshift(""), g = F;
            return g === " " && D.push((D.pop() || "") + " "), D[0] === "" && (D.shift(), D.unshift(" " + (D.shift() || ""))), D;
          }
          function I(C, D, g) {
            let F = D.split(`
`).map((l, E, y) => E === 0 && E === y.length - 1 ? l : E !== 0 && E !== y.length - 1 ? l.trim() : E === 0 ? l.trimEnd() : l.trimStart());
            return g.proseWrap === "preserve" ? F.map((l) => l.length === 0 ? [] : [l]) : F.map((l) => l.length === 0 ? [] : B(l)).reduce((l, E, y) => y !== 0 && F[y - 1].length > 0 && E.length > 0 && !(C === "quoteDouble" && t(t(l)).endsWith("\\")) ? [...l.slice(0, -1), [...t(l), ...E]] : [...l, E], []).map((l) => g.proseWrap === "never" ? [l.join(" ")] : l);
          }
          function k(C, D) {
            let { parentIndent: g, isLastDescendant: F, options: l } = D, E = C.position.start.line === C.position.end.line ? "" : l.originalText.slice(C.position.start.offset, C.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], y;
            if (C.indent === null) {
              let b = E.match(/^(?<leadingSpace> *)[^\n\r ]/m);
              y = b ? b.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
            } else
              y = C.indent - 1 + g;
            let N = E.split(`
`).map((b) => b.slice(y));
            if (l.proseWrap === "preserve" || C.type === "blockLiteral")
              return x(N.map((b) => b.length === 0 ? [] : [b]));
            return x(N.map((b) => b.length === 0 ? [] : B(b)).reduce((b, L, M) => M !== 0 && N[M - 1].length > 0 && L.length > 0 && !/^\s/.test(L[0]) && !/^\s|\s$/.test(t(b)) ? [...b.slice(0, -1), [...t(b), ...L]] : [...b, L], []).map((b) => b.reduce((L, M) => L.length > 0 && /\s$/.test(t(L)) ? [...L.slice(0, -1), t(L) + " " + M] : [...L, M], [])).map((b) => l.proseWrap === "never" ? [b.join(" ")] : b));
            function x(b) {
              if (C.chomping === "keep")
                return t(b).length === 0 ? b.slice(0, -1) : b;
              let L = 0;
              for (let M = b.length - 1; M >= 0 && b[M].length === 0; M--)
                L++;
              return L === 0 ? b : L >= 2 && !F ? b.slice(0, -(L - 1)) : b.slice(0, -L);
            }
          }
          function P(C) {
            if (!C)
              return true;
            switch (C.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
              case "alias":
              case "flowMapping":
              case "flowSequence":
                return true;
              default:
                return false;
            }
          }
          n.exports = { getLast: t, getAncestorCount: a, isNode: r, isEmptyNode: p2, isInlineNode: P, mapNode: u, defineShortcut: i, isNextLineEmpty: o, isLastDescendantNode: c, getBlockValueLineContents: k, getFlowScalarLineContents: I, getLastDescendantNode: v, hasPrettierIgnore: d, hasLeadingComments: h3, hasMiddleComments: w, hasIndicatorComment: T, hasTrailingComment: A, hasEndComments: S };
        } }), yg = Z({ "src/language-yaml/print-preprocess.js"(e, n) {
          "use strict";
          re();
          var { defineShortcut: t, mapNode: s } = Mt();
          function a(u) {
            return s(u, r);
          }
          function r(u) {
            switch (u.type) {
              case "document":
                t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
                break;
              case "documentBody":
              case "sequenceItem":
              case "flowSequenceItem":
              case "mappingKey":
              case "mappingValue":
                t(u, "content", () => u.children[0]);
                break;
              case "mappingItem":
              case "flowMappingItem":
                t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
                break;
            }
            return u;
          }
          n.exports = a;
        } }), jr = Z({ "src/language-yaml/print/misc.js"(e, n) {
          "use strict";
          re();
          var { builders: { softline: t, align: s } } = Oe(), { hasEndComments: a, isNextLineEmpty: r, isNode: u } = Mt(), i = /* @__PURE__ */ new WeakMap();
          function o(m2, d) {
            let p2 = m2.getValue(), f = m2.stack[0], h3;
            return i.has(f) ? h3 = i.get(f) : (h3 = /* @__PURE__ */ new Set(), i.set(f, h3)), !h3.has(p2.position.end.line) && (h3.add(p2.position.end.line), r(p2, d) && !c(m2.getParentNode())) ? t : "";
          }
          function c(m2) {
            return a(m2) && !u(m2, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
          }
          function v(m2, d) {
            return s(" ".repeat(m2), d);
          }
          n.exports = { alignWithSpaces: v, shouldPrintEndComments: c, printNextEmptyLine: o };
        } }), hg = Z({ "src/language-yaml/print/flow-mapping-sequence.js"(e, n) {
          "use strict";
          re();
          var { builders: { ifBreak: t, line: s, softline: a, hardline: r, join: u } } = Oe(), { isEmptyNode: i, getLast: o, hasEndComments: c } = Mt(), { printNextEmptyLine: v, alignWithSpaces: m2 } = jr();
          function d(f, h3, w) {
            let T = f.getValue(), A = T.type === "flowMapping", S = A ? "{" : "[", B = A ? "}" : "]", I = a;
            A && T.children.length > 0 && w.bracketSpacing && (I = s);
            let k = o(T.children), P = k && k.type === "flowMappingItem" && i(k.key) && i(k.value);
            return [S, m2(w.tabWidth, [I, p2(f, h3, w), w.trailingComma === "none" ? "" : t(","), c(T) ? [r, u(r, f.map(h3, "endComments"))] : ""]), P ? "" : I, B];
          }
          function p2(f, h3, w) {
            let T = f.getValue();
            return f.map((S, B) => [h3(), B === T.children.length - 1 ? "" : [",", s, T.children[B].position.start.line !== T.children[B + 1].position.start.line ? v(S, w.originalText) : ""]], "children");
          }
          n.exports = { printFlowMapping: d, printFlowSequence: d };
        } }), vg = Z({ "src/language-yaml/print/mapping-item.js"(e, n) {
          "use strict";
          re();
          var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: r, join: u, line: i } } = Oe(), { hasLeadingComments: o, hasMiddleComments: c, hasTrailingComment: v, hasEndComments: m2, isNode: d, isEmptyNode: p2, isInlineNode: f } = Mt(), { alignWithSpaces: h3 } = jr();
          function w(B, I, k, P, C) {
            let { key: D, value: g } = B, F = p2(D), l = p2(g);
            if (F && l)
              return ": ";
            let E = P("key"), y = A(B) ? " " : "";
            if (l)
              return B.type === "flowMappingItem" && I.type === "flowMapping" ? E : B.type === "mappingItem" && T(D.content, C) && !v(D.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [E, y, ":"] : ["? ", h3(2, E)];
            let N = P("value");
            if (F)
              return [": ", h3(2, N)];
            if (o(g) || !f(D.content))
              return ["? ", h3(2, E), a, u("", k.map(P, "value", "leadingComments").map(($2) => [$2, a])), ": ", h3(2, N)];
            if (S(D.content) && !o(D.content) && !c(D.content) && !v(D.content) && !m2(D) && !o(g.content) && !c(g.content) && !m2(g) && T(g.content, C))
              return [E, y, ": ", N];
            let x = Symbol("mappingKey"), b = s([r("? "), s(h3(2, E), { id: x })]), L = [a, ": ", h3(2, N)], M = [y, ":"];
            o(g.content) || m2(g) && g.content && !d(g.content, ["mapping", "sequence"]) || I.type === "mapping" && v(D.content) && f(g.content) || d(g.content, ["mapping", "sequence"]) && g.content.tag === null && g.content.anchor === null ? M.push(a) : g.content && M.push(i), M.push(N);
            let j = h3(C.tabWidth, M);
            return T(D.content, C) && !o(D.content) && !c(D.content) && !m2(D) ? t([[E, j]]) : t([[b, r(L, j, { groupId: x })]]);
          }
          function T(B, I) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteSingle":
              case "quoteDouble":
                break;
              case "alias":
                return true;
              default:
                return false;
            }
            if (I.proseWrap === "preserve")
              return B.position.start.line === B.position.end.line;
            if (/\\$/m.test(I.originalText.slice(B.position.start.offset, B.position.end.offset)))
              return false;
            switch (I.proseWrap) {
              case "never":
                return !B.value.includes(`
`);
              case "always":
                return !/[\n ]/.test(B.value);
              default:
                return false;
            }
          }
          function A(B) {
            return B.key.content && B.key.content.type === "alias";
          }
          function S(B) {
            if (!B)
              return true;
            switch (B.type) {
              case "plain":
              case "quoteDouble":
              case "quoteSingle":
                return B.position.start.line === B.position.end.line;
              case "alias":
                return true;
              default:
                return false;
            }
          }
          n.exports = w;
        } }), Cg = Z({ "src/language-yaml/print/block.js"(e, n) {
          "use strict";
          re();
          var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: r, join: u, line: i, literalline: o, markAsRoot: c }, utils: { getDocParts: v } } = Oe(), { getAncestorCount: m2, getBlockValueLineContents: d, hasIndicatorComment: p2, isLastDescendantNode: f, isNode: h3 } = Mt(), { alignWithSpaces: w } = jr();
          function T(A, S, B) {
            let I = A.getValue(), k = m2(A, (F) => h3(F, ["sequence", "mapping"])), P = f(A), C = [I.type === "blockFolded" ? ">" : "|"];
            I.indent !== null && C.push(I.indent.toString()), I.chomping !== "clip" && C.push(I.chomping === "keep" ? "+" : "-"), p2(I) && C.push(" ", S("indicatorComment"));
            let D = d(I, { parentIndent: k, isLastDescendant: P, options: B }), g = [];
            for (let [F, l] of D.entries())
              F === 0 && g.push(r), g.push(a(v(u(i, l)))), F !== D.length - 1 ? g.push(l.length === 0 ? r : c(o)) : I.chomping === "keep" && P && g.push(s(l.length === 0 ? r : o));
            return I.indent === null ? C.push(t(w(B.tabWidth, g))) : C.push(s(w(I.indent - 1 + k, g))), C;
          }
          n.exports = T;
        } }), Eg = Z({ "src/language-yaml/printer-yaml.js"(e, n) {
          "use strict";
          re();
          var { builders: { breakParent: t, fill: s, group: a, hardline: r, join: u, line: i, lineSuffix: o, literalline: c }, utils: { getDocParts: v, replaceTextEndOfLine: m2 } } = Oe(), { isPreviousLineEmpty: d } = Ue(), { insertPragma: p2, isPragma: f } = mg(), { locStart: h3 } = dg(), w = gg(), { getFlowScalarLineContents: T, getLastDescendantNode: A, hasLeadingComments: S, hasMiddleComments: B, hasTrailingComment: I, hasEndComments: k, hasPrettierIgnore: P, isLastDescendantNode: C, isNode: D, isInlineNode: g } = Mt(), F = yg(), { alignWithSpaces: l, printNextEmptyLine: E, shouldPrintEndComments: y } = jr(), { printFlowMapping: N, printFlowSequence: x } = hg(), b = vg(), L = Cg();
          function M(R, Q, ee) {
            let te = R.getValue(), oe = [];
            te.type !== "mappingValue" && S(te) && oe.push([u(r, R.map(ee, "leadingComments")), r]);
            let { tag: W, anchor: X } = te;
            W && oe.push(ee("tag")), W && X && oe.push(" "), X && oe.push(ee("anchor"));
            let ue = "";
            D(te, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !C(R) && (ue = E(R, Q.originalText)), (W || X) && (D(te, ["sequence", "mapping"]) && !B(te) ? oe.push(r) : oe.push(" ")), B(te) && oe.push([te.middleComments.length === 1 ? "" : r, u(r, R.map(ee, "middleComments")), r]);
            let De = R.getParentNode();
            return P(R) ? oe.push(m2(Q.originalText.slice(te.position.start.offset, te.position.end.offset).trimEnd(), c)) : oe.push(a(j(te, De, R, Q, ee))), I(te) && !D(te, ["document", "documentHead"]) && oe.push(o([te.type === "mappingValue" && !te.content ? "" : " ", De.type === "mappingKey" && R.getParentNode(2).type === "mapping" && g(te) ? "" : t, ee("trailingComment")])), y(te) && oe.push(l(te.type === "sequenceItem" ? 2 : 0, [r, u(r, R.map((ie) => [d(Q.originalText, ie.getValue(), h3) ? r : "", ee()], "endComments"))])), oe.push(ue), oe;
          }
          function j(R, Q, ee, te, oe) {
            switch (R.type) {
              case "root": {
                let { children: W } = R, X = [];
                ee.each((De, ie) => {
                  let G = W[ie], z = W[ie + 1];
                  ie !== 0 && X.push(r), X.push(oe()), V(G, z) ? (X.push(r, "..."), I(G) && X.push(" ", oe("trailingComment"))) : z && !I(z.head) && X.push(r, "---");
                }, "children");
                let ue = A(R);
                return (!D(ue, ["blockLiteral", "blockFolded"]) || ue.chomping !== "keep") && X.push(r), X;
              }
              case "document": {
                let W = Q.children[ee.getName() + 1], X = [];
                return q(R, W, Q, te) === "head" && ((R.head.children.length > 0 || R.head.endComments.length > 0) && X.push(oe("head")), I(R.head) ? X.push(["---", " ", oe(["head", "trailingComment"])]) : X.push("---")), $2(R) && X.push(oe("body")), u(r, X);
              }
              case "documentHead":
                return u(r, [...ee.map(oe, "children"), ...ee.map(oe, "endComments")]);
              case "documentBody": {
                let { children: W, endComments: X } = R, ue = "";
                if (W.length > 0 && X.length > 0) {
                  let De = A(R);
                  D(De, ["blockFolded", "blockLiteral"]) ? De.chomping !== "keep" && (ue = [r, r]) : ue = r;
                }
                return [u(r, ee.map(oe, "children")), ue, u(r, ee.map(oe, "endComments"))];
              }
              case "directive":
                return ["%", u(" ", [R.name, ...R.parameters])];
              case "comment":
                return ["#", R.value];
              case "alias":
                return ["*", R.value];
              case "tag":
                return te.originalText.slice(R.position.start.offset, R.position.end.offset);
              case "anchor":
                return ["&", R.value];
              case "plain":
                return Y(R.type, te.originalText.slice(R.position.start.offset, R.position.end.offset), te);
              case "quoteDouble":
              case "quoteSingle": {
                let W = "'", X = '"', ue = te.originalText.slice(R.position.start.offset + 1, R.position.end.offset - 1);
                if (R.type === "quoteSingle" && ue.includes("\\") || R.type === "quoteDouble" && /\\[^"]/.test(ue)) {
                  let ie = R.type === "quoteDouble" ? X : W;
                  return [ie, Y(R.type, ue, te), ie];
                }
                if (ue.includes(X))
                  return [W, Y(R.type, R.type === "quoteDouble" ? ue.replace(/\\"/g, X).replace(/'/g, W.repeat(2)) : ue, te), W];
                if (ue.includes(W))
                  return [X, Y(R.type, R.type === "quoteSingle" ? ue.replace(/''/g, W) : ue, te), X];
                let De = te.singleQuote ? W : X;
                return [De, Y(R.type, ue, te), De];
              }
              case "blockFolded":
              case "blockLiteral":
                return L(ee, oe, te);
              case "mapping":
              case "sequence":
                return u(r, ee.map(oe, "children"));
              case "sequenceItem":
                return ["- ", l(2, R.content ? oe("content") : "")];
              case "mappingKey":
              case "mappingValue":
                return R.content ? oe("content") : "";
              case "mappingItem":
              case "flowMappingItem":
                return b(R, Q, ee, oe, te);
              case "flowMapping":
                return N(ee, oe, te);
              case "flowSequence":
                return x(ee, oe, te);
              case "flowSequenceItem":
                return oe("content");
              default:
                throw new Error("Unexpected node type ".concat(R.type));
            }
          }
          function $2(R) {
            return R.body.children.length > 0 || k(R.body);
          }
          function V(R, Q) {
            return I(R) || Q && (Q.head.children.length > 0 || k(Q.head));
          }
          function q(R, Q, ee, te) {
            return ee.children[0] === R && /---(?:\s|$)/.test(te.originalText.slice(h3(R), h3(R) + 4)) || R.head.children.length > 0 || k(R.head) || I(R.head) ? "head" : V(R, Q) ? false : Q ? "root" : false;
          }
          function Y(R, Q, ee) {
            let te = T(R, Q, ee);
            return u(r, te.map((oe) => s(v(u(i, oe)))));
          }
          function H(R, Q) {
            if (D(Q))
              switch (delete Q.position, Q.type) {
                case "comment":
                  if (f(Q.value))
                    return null;
                  break;
                case "quoteDouble":
                case "quoteSingle":
                  Q.type = "quote";
                  break;
              }
          }
          n.exports = { preprocess: F, embed: w, print: M, massageAstNode: H, insertPragma: p2 };
        } }), Fg = Z({ "src/language-yaml/options.js"(e, n) {
          "use strict";
          re();
          var t = Ot();
          n.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
        } }), Ag = Z({ "src/language-yaml/parsers.js"() {
          re();
        } }), Sg = Z({ "node_modules/linguist-languages/data/YAML.json"(e, n) {
          n.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
        } }), xg = Z({ "src/language-yaml/index.js"(e, n) {
          "use strict";
          re();
          var t = Bt(), s = Eg(), a = Fg(), r = Ag(), u = [t(Sg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((o) => o !== "yarn.lock"), ".prettierrc", ".stylelintrc"] }))];
          n.exports = { languages: u, printers: { yaml: s }, options: a, parsers: r };
        } }), bg2 = Z({ "src/languages.js"(e, n) {
          "use strict";
          re(), n.exports = [id(), Sd(), Pd(), Md(), Ud(), Dg(), xg()];
        } });
        re();
        var { version: Tg } = ya(), kt = Sm(), { getSupportInfo: Bg } = Mn(), Ng = xm(), wg = bg2(), _g = Oe();
        function bt(e) {
          let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return function() {
            for (var t = arguments.length, s = new Array(t), a = 0; a < t; a++)
              s[a] = arguments[a];
            let r = s[n] || {}, u = r.plugins || [];
            return s[n] = Object.assign(Object.assign({}, r), {}, { plugins: [...wg, ...Array.isArray(u) ? u : Object.values(u)] }), e(...s);
          };
        }
        var bn = bt(kt.formatWithCursor);
        Co.exports = { formatWithCursor: bn, format(e, n) {
          return bn(e, n).formatted;
        }, check(e, n) {
          let { formatted: t } = bn(e, n);
          return t === e;
        }, doc: _g, getSupportInfo: bt(Bg, 0), version: Tg, util: Ng, __debug: { parse: bt(kt.parse), formatAST: bt(kt.formatAST), formatDoc: bt(kt.formatDoc), printToDoc: bt(kt.printToDoc), printDocToString: bt(kt.printDocToString) } };
      });
      return Pg();
    });
  }
});

// ../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-babel.js
var require_parser_babel = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-babel.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.babel = e();
      }
    })(function() {
      "use strict";
      var b = (h3, l) => () => (l || h3((l = { exports: {} }).exports, l), l.exports);
      var G = b((zf, Jr) => {
        var Tt = function(h3) {
          return h3 && h3.Math == Math && h3;
        };
        Jr.exports = Tt(typeof globalThis == "object" && globalThis) || Tt(typeof window == "object" && window) || Tt(typeof self == "object" && self) || Tt(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var Ae = b((Kf, Yr) => {
        Yr.exports = function(h3) {
          try {
            return !!h3();
          } catch {
            return true;
          }
        };
      });
      var ke = b((Vf, $r) => {
        var hl = Ae();
        $r.exports = !hl(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Et = b((Hf, Qr) => {
        var ll = Ae();
        Qr.exports = !ll(function() {
          var h3 = function() {
          }.bind();
          return typeof h3 != "function" || h3.hasOwnProperty("prototype");
        });
      });
      var bt = b((Wf, Zr) => {
        var ul = Et(), Ct = Function.prototype.call;
        Zr.exports = ul ? Ct.bind(Ct) : function() {
          return Ct.apply(Ct, arguments);
        };
      });
      var ri = b((si) => {
        "use strict";
        var ei = {}.propertyIsEnumerable, ti = Object.getOwnPropertyDescriptor, cl = ti && !ei.call({ 1: 2 }, 1);
        si.f = cl ? function(l) {
          var p2 = ti(this, l);
          return !!p2 && p2.enumerable;
        } : ei;
      });
      var ms = b((Xf, ii) => {
        ii.exports = function(h3, l) {
          return { enumerable: !(h3 & 1), configurable: !(h3 & 2), writable: !(h3 & 4), value: l };
        };
      });
      var ie = b((Jf, oi) => {
        var ai = Et(), ni = Function.prototype, pl = ni.bind, ys = ni.call, fl = ai && pl.bind(ys, ys);
        oi.exports = ai ? function(h3) {
          return h3 && fl(h3);
        } : function(h3) {
          return h3 && function() {
            return ys.apply(h3, arguments);
          };
        };
      });
      var vt = b((Yf, li) => {
        var hi = ie(), dl = hi({}.toString), ml = hi("".slice);
        li.exports = function(h3) {
          return ml(dl(h3), 8, -1);
        };
      });
      var ci = b(($f, ui) => {
        var yl = G(), xl = ie(), gl = Ae(), Al = vt(), xs = yl.Object, Pl = xl("".split);
        ui.exports = gl(function() {
          return !xs("z").propertyIsEnumerable(0);
        }) ? function(h3) {
          return Al(h3) == "String" ? Pl(h3, "") : xs(h3);
        } : xs;
      });
      var gs = b((Qf, pi) => {
        var Tl = G(), El = Tl.TypeError;
        pi.exports = function(h3) {
          if (h3 == null)
            throw El("Can't call method on " + h3);
          return h3;
        };
      });
      var St = b((Zf, fi) => {
        var Cl = ci(), bl = gs();
        fi.exports = function(h3) {
          return Cl(bl(h3));
        };
      });
      var ae = b((ed, di) => {
        di.exports = function(h3) {
          return typeof h3 == "function";
        };
      });
      var De = b((td, mi) => {
        var vl = ae();
        mi.exports = function(h3) {
          return typeof h3 == "object" ? h3 !== null : vl(h3);
        };
      });
      var Qe = b((sd, yi) => {
        var As = G(), Sl = ae(), wl = function(h3) {
          return Sl(h3) ? h3 : void 0;
        };
        yi.exports = function(h3, l) {
          return arguments.length < 2 ? wl(As[h3]) : As[h3] && As[h3][l];
        };
      });
      var gi = b((rd, xi) => {
        var Nl = ie();
        xi.exports = Nl({}.isPrototypeOf);
      });
      var Pi = b((id, Ai) => {
        var Il = Qe();
        Ai.exports = Il("navigator", "userAgent") || "";
      });
      var wi = b((ad, Si) => {
        var vi = G(), Ps = Pi(), Ti = vi.process, Ei = vi.Deno, Ci = Ti && Ti.versions || Ei && Ei.version, bi = Ci && Ci.v8, oe, wt;
        bi && (oe = bi.split("."), wt = oe[0] > 0 && oe[0] < 4 ? 1 : +(oe[0] + oe[1]));
        !wt && Ps && (oe = Ps.match(/Edge\/(\d+)/), (!oe || oe[1] >= 74) && (oe = Ps.match(/Chrome\/(\d+)/), oe && (wt = +oe[1])));
        Si.exports = wt;
      });
      var Ts = b((nd, Ii) => {
        var Ni = wi(), kl = Ae();
        Ii.exports = !!Object.getOwnPropertySymbols && !kl(function() {
          var h3 = Symbol();
          return !String(h3) || !(Object(h3) instanceof Symbol) || !Symbol.sham && Ni && Ni < 41;
        });
      });
      var Es = b((od, ki) => {
        var Dl = Ts();
        ki.exports = Dl && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Cs = b((hd, Di) => {
        var Fl = G(), Ll = Qe(), Ol = ae(), Bl = gi(), Ml = Es(), Rl = Fl.Object;
        Di.exports = Ml ? function(h3) {
          return typeof h3 == "symbol";
        } : function(h3) {
          var l = Ll("Symbol");
          return Ol(l) && Bl(l.prototype, Rl(h3));
        };
      });
      var Li = b((ld, Fi) => {
        var jl = G(), ql = jl.String;
        Fi.exports = function(h3) {
          try {
            return ql(h3);
          } catch {
            return "Object";
          }
        };
      });
      var Nt = b((ud, Oi) => {
        var Ul = G(), _l = ae(), zl = Li(), Kl = Ul.TypeError;
        Oi.exports = function(h3) {
          if (_l(h3))
            return h3;
          throw Kl(zl(h3) + " is not a function");
        };
      });
      var Mi = b((cd, Bi) => {
        var Vl = Nt();
        Bi.exports = function(h3, l) {
          var p2 = h3[l];
          return p2 == null ? void 0 : Vl(p2);
        };
      });
      var ji = b((pd, Ri) => {
        var Hl = G(), bs = bt(), vs = ae(), Ss = De(), Wl = Hl.TypeError;
        Ri.exports = function(h3, l) {
          var p2, d;
          if (l === "string" && vs(p2 = h3.toString) && !Ss(d = bs(p2, h3)) || vs(p2 = h3.valueOf) && !Ss(d = bs(p2, h3)) || l !== "string" && vs(p2 = h3.toString) && !Ss(d = bs(p2, h3)))
            return d;
          throw Wl("Can't convert object to primitive value");
        };
      });
      var Ui = b((fd, qi) => {
        qi.exports = false;
      });
      var It = b((dd, zi) => {
        var _i = G(), Gl = Object.defineProperty;
        zi.exports = function(h3, l) {
          try {
            Gl(_i, h3, { value: l, configurable: true, writable: true });
          } catch {
            _i[h3] = l;
          }
          return l;
        };
      });
      var kt = b((md, Vi) => {
        var Xl = G(), Jl = It(), Ki = "__core-js_shared__", Yl = Xl[Ki] || Jl(Ki, {});
        Vi.exports = Yl;
      });
      var ws2 = b((yd, Wi) => {
        var $l = Ui(), Hi = kt();
        (Wi.exports = function(h3, l) {
          return Hi[h3] || (Hi[h3] = l !== void 0 ? l : {});
        })("versions", []).push({ version: "3.22.2", mode: $l ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var Ns = b((xd, Gi) => {
        var Ql = G(), Zl = gs(), eu = Ql.Object;
        Gi.exports = function(h3) {
          return eu(Zl(h3));
        };
      });
      var be = b((gd, Xi) => {
        var tu = ie(), su = Ns(), ru = tu({}.hasOwnProperty);
        Xi.exports = Object.hasOwn || function(l, p2) {
          return ru(su(l), p2);
        };
      });
      var Is = b((Ad, Ji) => {
        var iu = ie(), au = 0, nu = Math.random(), ou = iu(1 .toString);
        Ji.exports = function(h3) {
          return "Symbol(" + (h3 === void 0 ? "" : h3) + ")_" + ou(++au + nu, 36);
        };
      });
      var Ze = b((Pd, ea) => {
        var hu = G(), lu = ws2(), Yi = be(), uu = Is(), $i = Ts(), Zi = Es(), _e = lu("wks"), Fe = hu.Symbol, Qi = Fe && Fe.for, cu = Zi ? Fe : Fe && Fe.withoutSetter || uu;
        ea.exports = function(h3) {
          if (!Yi(_e, h3) || !($i || typeof _e[h3] == "string")) {
            var l = "Symbol." + h3;
            $i && Yi(Fe, h3) ? _e[h3] = Fe[h3] : Zi && Qi ? _e[h3] = Qi(l) : _e[h3] = cu(l);
          }
          return _e[h3];
        };
      });
      var ia = b((Td, ra) => {
        var pu = G(), fu = bt(), ta = De(), sa = Cs(), du = Mi(), mu = ji(), yu = Ze(), xu = pu.TypeError, gu = yu("toPrimitive");
        ra.exports = function(h3, l) {
          if (!ta(h3) || sa(h3))
            return h3;
          var p2 = du(h3, gu), d;
          if (p2) {
            if (l === void 0 && (l = "default"), d = fu(p2, h3, l), !ta(d) || sa(d))
              return d;
            throw xu("Can't convert object to primitive value");
          }
          return l === void 0 && (l = "number"), mu(h3, l);
        };
      });
      var ks = b((Ed, aa) => {
        var Au = ia(), Pu = Cs();
        aa.exports = function(h3) {
          var l = Au(h3, "string");
          return Pu(l) ? l : l + "";
        };
      });
      var ha = b((Cd, oa) => {
        var Tu = G(), na = De(), Ds = Tu.document, Eu = na(Ds) && na(Ds.createElement);
        oa.exports = function(h3) {
          return Eu ? Ds.createElement(h3) : {};
        };
      });
      var Fs = b((bd, la) => {
        var Cu = ke(), bu = Ae(), vu = ha();
        la.exports = !Cu && !bu(function() {
          return Object.defineProperty(vu("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Ls = b((ca) => {
        var Su = ke(), wu = bt(), Nu = ri(), Iu = ms(), ku = St(), Du = ks(), Fu = be(), Lu = Fs(), ua = Object.getOwnPropertyDescriptor;
        ca.f = Su ? ua : function(l, p2) {
          if (l = ku(l), p2 = Du(p2), Lu)
            try {
              return ua(l, p2);
            } catch {
            }
          if (Fu(l, p2))
            return Iu(!wu(Nu.f, l, p2), l[p2]);
        };
      });
      var fa = b((Sd, pa) => {
        var Ou = ke(), Bu = Ae();
        pa.exports = Ou && Bu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Os = b((wd, ma) => {
        var da = G(), Mu = De(), Ru = da.String, ju = da.TypeError;
        ma.exports = function(h3) {
          if (Mu(h3))
            return h3;
          throw ju(Ru(h3) + " is not an object");
        };
      });
      var qs = b((xa) => {
        var qu = G(), Uu = ke(), _u = Fs(), zu = fa(), Dt = Os(), ya = ks(), Ku = qu.TypeError, Bs = Object.defineProperty, Vu = Object.getOwnPropertyDescriptor, Ms = "enumerable", Rs = "configurable", js = "writable";
        xa.f = Uu ? zu ? function(l, p2, d) {
          if (Dt(l), p2 = ya(p2), Dt(d), typeof l == "function" && p2 === "prototype" && "value" in d && js in d && !d[js]) {
            var m2 = Vu(l, p2);
            m2 && m2[js] && (l[p2] = d.value, d = { configurable: Rs in d ? d[Rs] : m2[Rs], enumerable: Ms in d ? d[Ms] : m2[Ms], writable: false });
          }
          return Bs(l, p2, d);
        } : Bs : function(l, p2, d) {
          if (Dt(l), p2 = ya(p2), Dt(d), _u)
            try {
              return Bs(l, p2, d);
            } catch {
            }
          if ("get" in d || "set" in d)
            throw Ku("Accessors not supported");
          return "value" in d && (l[p2] = d.value), l;
        };
      });
      var Ft = b((Id, ga) => {
        var Hu = ke(), Wu = qs(), Gu = ms();
        ga.exports = Hu ? function(h3, l, p2) {
          return Wu.f(h3, l, Gu(1, p2));
        } : function(h3, l, p2) {
          return h3[l] = p2, h3;
        };
      });
      var Lt = b((kd, Aa) => {
        var Xu = ie(), Ju = ae(), Us = kt(), Yu = Xu(Function.toString);
        Ju(Us.inspectSource) || (Us.inspectSource = function(h3) {
          return Yu(h3);
        });
        Aa.exports = Us.inspectSource;
      });
      var Ea = b((Dd, Ta) => {
        var $u = G(), Qu = ae(), Zu = Lt(), Pa = $u.WeakMap;
        Ta.exports = Qu(Pa) && /native code/.test(Zu(Pa));
      });
      var va = b((Fd, ba) => {
        var ec = ws2(), tc = Is(), Ca = ec("keys");
        ba.exports = function(h3) {
          return Ca[h3] || (Ca[h3] = tc(h3));
        };
      });
      var _s = b((Ld, Sa) => {
        Sa.exports = {};
      });
      var Fa = b((Od, Da) => {
        var sc = Ea(), ka = G(), zs = ie(), rc = De(), ic = Ft(), Ks = be(), Vs = kt(), ac = va(), nc = _s(), wa = "Object already initialized", Ws = ka.TypeError, oc = ka.WeakMap, Ot, et, Bt, hc = function(h3) {
          return Bt(h3) ? et(h3) : Ot(h3, {});
        }, lc = function(h3) {
          return function(l) {
            var p2;
            if (!rc(l) || (p2 = et(l)).type !== h3)
              throw Ws("Incompatible receiver, " + h3 + " required");
            return p2;
          };
        };
        sc || Vs.state ? (ve = Vs.state || (Vs.state = new oc()), Na = zs(ve.get), Hs = zs(ve.has), Ia = zs(ve.set), Ot = function(h3, l) {
          if (Hs(ve, h3))
            throw new Ws(wa);
          return l.facade = h3, Ia(ve, h3, l), l;
        }, et = function(h3) {
          return Na(ve, h3) || {};
        }, Bt = function(h3) {
          return Hs(ve, h3);
        }) : (Le = ac("state"), nc[Le] = true, Ot = function(h3, l) {
          if (Ks(h3, Le))
            throw new Ws(wa);
          return l.facade = h3, ic(h3, Le, l), l;
        }, et = function(h3) {
          return Ks(h3, Le) ? h3[Le] : {};
        }, Bt = function(h3) {
          return Ks(h3, Le);
        });
        var ve, Na, Hs, Ia, Le;
        Da.exports = { set: Ot, get: et, has: Bt, enforce: hc, getterFor: lc };
      });
      var Ba = b((Bd, Oa) => {
        var Gs = ke(), uc = be(), La = Function.prototype, cc = Gs && Object.getOwnPropertyDescriptor, Xs = uc(La, "name"), pc = Xs && function() {
        }.name === "something", fc = Xs && (!Gs || Gs && cc(La, "name").configurable);
        Oa.exports = { EXISTS: Xs, PROPER: pc, CONFIGURABLE: fc };
      });
      var Ua = b((Md, qa) => {
        var dc = G(), Ma = ae(), mc = be(), Ra = Ft(), yc = It(), xc = Lt(), ja = Fa(), gc = Ba().CONFIGURABLE, Ac = ja.get, Pc = ja.enforce, Tc = String(String).split("String");
        (qa.exports = function(h3, l, p2, d) {
          var m2 = d ? !!d.unsafe : false, A = d ? !!d.enumerable : false, g = d ? !!d.noTargetGet : false, x = d && d.name !== void 0 ? d.name : l, T;
          if (Ma(p2) && (String(x).slice(0, 7) === "Symbol(" && (x = "[" + String(x).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!mc(p2, "name") || gc && p2.name !== x) && Ra(p2, "name", x), T = Pc(p2), T.source || (T.source = Tc.join(typeof x == "string" ? x : ""))), h3 === dc) {
            A ? h3[l] = p2 : yc(l, p2);
            return;
          } else
            m2 ? !g && h3[l] && (A = true) : delete h3[l];
          A ? h3[l] = p2 : Ra(h3, l, p2);
        })(Function.prototype, "toString", function() {
          return Ma(this) && Ac(this).source || xc(this);
        });
      });
      var Js = b((Rd, _a) => {
        var Ec = Math.ceil, Cc = Math.floor;
        _a.exports = function(h3) {
          var l = +h3;
          return l !== l || l === 0 ? 0 : (l > 0 ? Cc : Ec)(l);
        };
      });
      var Ka = b((jd, za) => {
        var bc2 = Js(), vc = Math.max, Sc = Math.min;
        za.exports = function(h3, l) {
          var p2 = bc2(h3);
          return p2 < 0 ? vc(p2 + l, 0) : Sc(p2, l);
        };
      });
      var Ha = b((qd, Va) => {
        var wc = Js(), Nc = Math.min;
        Va.exports = function(h3) {
          return h3 > 0 ? Nc(wc(h3), 9007199254740991) : 0;
        };
      });
      var Mt = b((Ud, Wa) => {
        var Ic = Ha();
        Wa.exports = function(h3) {
          return Ic(h3.length);
        };
      });
      var Ja = b((_d, Xa) => {
        var kc = St(), Dc = Ka(), Fc = Mt(), Ga = function(h3) {
          return function(l, p2, d) {
            var m2 = kc(l), A = Fc(m2), g = Dc(d, A), x;
            if (h3 && p2 != p2) {
              for (; A > g; )
                if (x = m2[g++], x != x)
                  return true;
            } else
              for (; A > g; g++)
                if ((h3 || g in m2) && m2[g] === p2)
                  return h3 || g || 0;
            return !h3 && -1;
          };
        };
        Xa.exports = { includes: Ga(true), indexOf: Ga(false) };
      });
      var Qa = b((zd, $a) => {
        var Lc = ie(), Ys = be(), Oc = St(), Bc = Ja().indexOf, Mc = _s(), Ya = Lc([].push);
        $a.exports = function(h3, l) {
          var p2 = Oc(h3), d = 0, m2 = [], A;
          for (A in p2)
            !Ys(Mc, A) && Ys(p2, A) && Ya(m2, A);
          for (; l.length > d; )
            Ys(p2, A = l[d++]) && (~Bc(m2, A) || Ya(m2, A));
          return m2;
        };
      });
      var en = b((Kd, Za) => {
        Za.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var sn = b((tn) => {
        var Rc = Qa(), jc = en(), qc = jc.concat("length", "prototype");
        tn.f = Object.getOwnPropertyNames || function(l) {
          return Rc(l, qc);
        };
      });
      var an = b((rn) => {
        rn.f = Object.getOwnPropertySymbols;
      });
      var on = b((Wd, nn) => {
        var Uc = Qe(), _c = ie(), zc = sn(), Kc = an(), Vc = Os(), Hc = _c([].concat);
        nn.exports = Uc("Reflect", "ownKeys") || function(l) {
          var p2 = zc.f(Vc(l)), d = Kc.f;
          return d ? Hc(p2, d(l)) : p2;
        };
      });
      var un = b((Gd, ln) => {
        var hn = be(), Wc = on(), Gc = Ls(), Xc = qs();
        ln.exports = function(h3, l, p2) {
          for (var d = Wc(l), m2 = Xc.f, A = Gc.f, g = 0; g < d.length; g++) {
            var x = d[g];
            !hn(h3, x) && !(p2 && hn(p2, x)) && m2(h3, x, A(l, x));
          }
        };
      });
      var pn = b((Xd, cn) => {
        var Jc = Ae(), Yc = ae(), $c = /#|\.prototype\./, tt = function(h3, l) {
          var p2 = Zc[Qc(h3)];
          return p2 == tp ? true : p2 == ep ? false : Yc(l) ? Jc(l) : !!l;
        }, Qc = tt.normalize = function(h3) {
          return String(h3).replace($c, ".").toLowerCase();
        }, Zc = tt.data = {}, ep = tt.NATIVE = "N", tp = tt.POLYFILL = "P";
        cn.exports = tt;
      });
      var Qs = b((Jd, fn) => {
        var $s = G(), sp = Ls().f, rp = Ft(), ip = Ua(), ap = It(), np = un(), op = pn();
        fn.exports = function(h3, l) {
          var p2 = h3.target, d = h3.global, m2 = h3.stat, A, g, x, T, k, D;
          if (d ? g = $s : m2 ? g = $s[p2] || ap(p2, {}) : g = ($s[p2] || {}).prototype, g)
            for (x in l) {
              if (k = l[x], h3.noTargetGet ? (D = sp(g, x), T = D && D.value) : T = g[x], A = op(d ? x : p2 + (m2 ? "." : "#") + x, h3.forced), !A && T !== void 0) {
                if (typeof k == typeof T)
                  continue;
                np(k, T);
              }
              (h3.sham || T && T.sham) && rp(k, "sham", true), ip(g, x, k, h3);
            }
        };
      });
      var dn = b(() => {
        var hp = Qs(), lp = G();
        hp({ global: true }, { globalThis: lp });
      });
      var mn = b(() => {
        dn();
      });
      var Zs = b((em, yn) => {
        var up = vt();
        yn.exports = Array.isArray || function(l) {
          return up(l) == "Array";
        };
      });
      var An = b((tm, gn) => {
        var xn = ie(), cp = Nt(), pp = Et(), fp = xn(xn.bind);
        gn.exports = function(h3, l) {
          return cp(h3), l === void 0 ? h3 : pp ? fp(h3, l) : function() {
            return h3.apply(l, arguments);
          };
        };
      });
      var En = b((sm, Tn) => {
        "use strict";
        var dp = G(), mp = Zs(), yp = Mt(), xp = An(), gp = dp.TypeError, Pn = function(h3, l, p2, d, m2, A, g, x) {
          for (var T = m2, k = 0, D = g ? xp(g, x) : false, E, L; k < d; ) {
            if (k in p2) {
              if (E = D ? D(p2[k], k, l) : p2[k], A > 0 && mp(E))
                L = yp(E), T = Pn(h3, l, E, L, T, A - 1) - 1;
              else {
                if (T >= 9007199254740991)
                  throw gp("Exceed the acceptable array length");
                h3[T] = E;
              }
              T++;
            }
            k++;
          }
          return T;
        };
        Tn.exports = Pn;
      });
      var vn = b((rm, bn) => {
        var Ap = Ze(), Pp = Ap("toStringTag"), Cn = {};
        Cn[Pp] = "z";
        bn.exports = String(Cn) === "[object z]";
      });
      var wn = b((im, Sn) => {
        var Tp = G(), Ep = vn(), Cp = ae(), Rt = vt(), bp = Ze(), vp = bp("toStringTag"), Sp = Tp.Object, wp = Rt(function() {
          return arguments;
        }()) == "Arguments", Np = function(h3, l) {
          try {
            return h3[l];
          } catch {
          }
        };
        Sn.exports = Ep ? Rt : function(h3) {
          var l, p2, d;
          return h3 === void 0 ? "Undefined" : h3 === null ? "Null" : typeof (p2 = Np(l = Sp(h3), vp)) == "string" ? p2 : wp ? Rt(l) : (d = Rt(l)) == "Object" && Cp(l.callee) ? "Arguments" : d;
        };
      });
      var Ln = b((am, Fn) => {
        var Ip = ie(), kp = Ae(), Nn = ae(), Dp = wn(), Fp = Qe(), Lp = Lt(), In = function() {
        }, Op = [], kn = Fp("Reflect", "construct"), er = /^\s*(?:class|function)\b/, Bp = Ip(er.exec), Mp = !er.exec(In), st = function(l) {
          if (!Nn(l))
            return false;
          try {
            return kn(In, Op, l), true;
          } catch {
            return false;
          }
        }, Dn = function(l) {
          if (!Nn(l))
            return false;
          switch (Dp(l)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return Mp || !!Bp(er, Lp(l));
          } catch {
            return true;
          }
        };
        Dn.sham = true;
        Fn.exports = !kn || kp(function() {
          var h3;
          return st(st.call) || !st(Object) || !st(function() {
            h3 = true;
          }) || h3;
        }) ? Dn : st;
      });
      var Rn = b((nm, Mn) => {
        var Rp = G(), On = Zs(), jp = Ln(), qp = De(), Up = Ze(), _p = Up("species"), Bn = Rp.Array;
        Mn.exports = function(h3) {
          var l;
          return On(h3) && (l = h3.constructor, jp(l) && (l === Bn || On(l.prototype)) ? l = void 0 : qp(l) && (l = l[_p], l === null && (l = void 0))), l === void 0 ? Bn : l;
        };
      });
      var qn = b((om, jn) => {
        var zp = Rn();
        jn.exports = function(h3, l) {
          return new (zp(h3))(l === 0 ? 0 : l);
        };
      });
      var Un = b(() => {
        "use strict";
        var Kp = Qs(), Vp = En(), Hp = Nt(), Wp = Ns(), Gp = Mt(), Xp = qn();
        Kp({ target: "Array", proto: true }, { flatMap: function(l) {
          var p2 = Wp(this), d = Gp(p2), m2;
          return Hp(l), m2 = Xp(p2, 0), m2.length = Vp(m2, p2, p2, d, 0, 1, l, arguments.length > 1 ? arguments[1] : void 0), m2;
        } });
      });
      var qf = b((um, Eo) => {
        var _n2, zn, Kn, Vn, Hn;
        function rt(h3, l) {
          return l || (l = h3.slice(0)), Object.freeze(Object.defineProperties(h3, { raw: { value: Object.freeze(l) } }));
        }
        mn();
        Un();
        var ir = Object.defineProperty, Jp = Object.getOwnPropertyDescriptor, ar = Object.getOwnPropertyNames, Yp = Object.prototype.hasOwnProperty, $n = (h3, l) => function() {
          return h3 && (l = (0, h3[ar(h3)[0]])(h3 = 0)), l;
        }, H = (h3, l) => function() {
          return l || (0, h3[ar(h3)[0]])((l = { exports: {} }).exports, l), l.exports;
        }, $p = (h3, l) => {
          for (var p2 in l)
            ir(h3, p2, { get: l[p2], enumerable: true });
        }, Qp = (h3, l, p2, d) => {
          if (l && typeof l == "object" || typeof l == "function")
            for (let m2 of ar(l))
              !Yp.call(h3, m2) && m2 !== p2 && ir(h3, m2, { get: () => l[m2], enumerable: !(d = Jp(l, m2)) || d.enumerable });
          return h3;
        }, Zp = (h3) => Qp(ir({}, "__esModule", { value: true }), h3), V = $n({ "<define:process>"() {
        } }), ef = H({ "src/utils/try-combinations.js"(h3, l) {
          "use strict";
          V();
          function p2() {
            let d;
            for (var m2 = arguments.length, A = new Array(m2), g = 0; g < m2; g++)
              A[g] = arguments[g];
            for (let [x, T] of A.entries())
              try {
                return { result: T() };
              } catch (k) {
                x === 0 && (d = k);
              }
            return { error: d };
          }
          l.exports = p2;
        } }), Qn = H({ "src/language-js/utils/get-shebang.js"(h3, l) {
          "use strict";
          V();
          function p2(d) {
            if (!d.startsWith("#!"))
              return "";
            let m2 = d.indexOf(`
`);
            return m2 === -1 ? d : d.slice(0, m2);
          }
          l.exports = p2;
        } }), tf = H({ "src/utils/text/skip-inline-comment.js"(h3, l) {
          "use strict";
          V();
          function p2(d, m2) {
            if (m2 === false)
              return false;
            if (d.charAt(m2) === "/" && d.charAt(m2 + 1) === "*") {
              for (let A = m2 + 2; A < d.length; ++A)
                if (d.charAt(A) === "*" && d.charAt(A + 1) === "/")
                  return A + 2;
            }
            return m2;
          }
          l.exports = p2;
        } }), sf = H({ "src/utils/text/skip-newline.js"(h3, l) {
          "use strict";
          V();
          function p2(d, m2, A) {
            let g = A && A.backwards;
            if (m2 === false)
              return false;
            let x = d.charAt(m2);
            if (g) {
              if (d.charAt(m2 - 1) === "\r" && x === `
`)
                return m2 - 2;
              if (x === `
` || x === "\r" || x === "\u2028" || x === "\u2029")
                return m2 - 1;
            } else {
              if (x === "\r" && d.charAt(m2 + 1) === `
`)
                return m2 + 2;
              if (x === `
` || x === "\r" || x === "\u2028" || x === "\u2029")
                return m2 + 1;
            }
            return m2;
          }
          l.exports = p2;
        } }), Zn = H({ "src/utils/text/skip.js"(h3, l) {
          "use strict";
          V();
          function p2(x) {
            return (T, k, D) => {
              let E = D && D.backwards;
              if (k === false)
                return false;
              let { length: L } = T, R = k;
              for (; R >= 0 && R < L; ) {
                let F = T.charAt(R);
                if (x instanceof RegExp) {
                  if (!x.test(F))
                    return R;
                } else if (!x.includes(F))
                  return R;
                E ? R-- : R++;
              }
              return R === -1 || R === L ? R : false;
            };
          }
          var d = p2(/\s/), m2 = p2(" 	"), A = p2(",; 	"), g = p2(/[^\n\r]/);
          l.exports = { skipWhitespace: d, skipSpaces: m2, skipToLineEnd: A, skipEverythingButNewLine: g };
        } }), rf = H({ "src/utils/text/skip-trailing-comment.js"(h3, l) {
          "use strict";
          V();
          var { skipEverythingButNewLine: p2 } = Zn();
          function d(m2, A) {
            return A === false ? false : m2.charAt(A) === "/" && m2.charAt(A + 1) === "/" ? p2(m2, A) : A;
          }
          l.exports = d;
        } }), af = H({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(h3, l) {
          "use strict";
          V();
          var p2 = tf(), d = sf(), m2 = rf(), { skipSpaces: A } = Zn();
          function g(x, T) {
            let k = null, D = T;
            for (; D !== k; )
              k = D, D = A(x, D), D = p2(x, D), D = m2(x, D), D = d(x, D);
            return D;
          }
          l.exports = g;
        } }), eo = {};
        $p(eo, { EOL: () => rr, arch: () => nf, cpus: () => oo, default: () => po, endianness: () => to, freemem: () => ao, getNetworkInterfaces: () => co, hostname: () => so, loadavg: () => ro, networkInterfaces: () => uo, platform: () => of, release: () => lo, tmpDir: () => tr, tmpdir: () => sr, totalmem: () => no, type: () => ho, uptime: () => io });
        function to() {
          if (typeof jt > "u") {
            var h3 = new ArrayBuffer(2), l = new Uint8Array(h3), p2 = new Uint16Array(h3);
            if (l[0] = 1, l[1] = 2, p2[0] === 258)
              jt = "BE";
            else if (p2[0] === 513)
              jt = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return jt;
        }
        function so() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function ro() {
          return [];
        }
        function io() {
          return 0;
        }
        function ao() {
          return Number.MAX_VALUE;
        }
        function no() {
          return Number.MAX_VALUE;
        }
        function oo() {
          return [];
        }
        function ho() {
          return "Browser";
        }
        function lo() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function uo() {
        }
        function co() {
        }
        function nf() {
          return "javascript";
        }
        function of() {
          return "browser";
        }
        function tr() {
          return "/tmp";
        }
        var jt, sr, rr, po, hf = $n({ "node-modules-polyfills:os"() {
          V(), sr = tr, rr = `
`, po = { EOL: rr, tmpdir: sr, tmpDir: tr, networkInterfaces: uo, getNetworkInterfaces: co, release: lo, type: ho, cpus: oo, totalmem: no, freemem: ao, uptime: io, loadavg: ro, hostname: so, endianness: to };
        } }), lf = H({ "node-modules-polyfills-commonjs:os"(h3, l) {
          V();
          var p2 = (hf(), Zp(eo));
          if (p2 && p2.default) {
            l.exports = p2.default;
            for (let d in p2)
              l.exports[d] = p2[d];
          } else
            p2 && (l.exports = p2);
        } }), uf = H({ "node_modules/detect-newline/index.js"(h3, l) {
          "use strict";
          V();
          var p2 = (d) => {
            if (typeof d != "string")
              throw new TypeError("Expected a string");
            let m2 = d.match(/(?:\r?\n)/g) || [];
            if (m2.length === 0)
              return;
            let A = m2.filter((x) => x === `\r
`).length, g = m2.length - A;
            return A > g ? `\r
` : `
`;
          };
          l.exports = p2, l.exports.graceful = (d) => typeof d == "string" && p2(d) || `
`;
        } }), cf = H({ "node_modules/jest-docblock/build/index.js"(h3) {
          "use strict";
          V(), Object.defineProperty(h3, "__esModule", { value: true }), h3.extract = R, h3.parse = W, h3.parseWithComments = Y, h3.print = M, h3.strip = F;
          function l() {
            let u = lf();
            return l = function() {
              return u;
            }, u;
          }
          function p2() {
            let u = d(uf());
            return p2 = function() {
              return u;
            }, u;
          }
          function d(u) {
            return u && u.__esModule ? u : { default: u };
          }
          var m2 = /\*\/$/, A = /^\/\*\*/, g = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, x = /(^|\s+)\/\/([^\r\n]*)/g, T = /^(\r?\n)+/, k = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, D = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, E = /(\r?\n|^) *\* ?/g, L = [];
          function R(u) {
            let X = u.match(g);
            return X ? X[0].trimLeft() : "";
          }
          function F(u) {
            let X = u.match(g);
            return X && X[0] ? u.substring(X[0].length) : u;
          }
          function W(u) {
            return Y(u).pragmas;
          }
          function Y(u) {
            let X = (0, p2().default)(u) || l().EOL;
            u = u.replace(A, "").replace(m2, "").replace(E, "$1");
            let se = "";
            for (; se !== u; )
              se = u, u = u.replace(k, "".concat(X, "$1 $2").concat(X));
            u = u.replace(T, "").trimRight();
            let J = /* @__PURE__ */ Object.create(null), Oe = u.replace(D, "").replace(T, "").trimRight(), $2;
            for (; $2 = D.exec(u); ) {
              let z = $2[2].replace(x, "");
              typeof J[$2[1]] == "string" || Array.isArray(J[$2[1]]) ? J[$2[1]] = L.concat(J[$2[1]], z) : J[$2[1]] = z;
            }
            return { comments: Oe, pragmas: J };
          }
          function M(u) {
            let { comments: X = "", pragmas: se = {} } = u, J = (0, p2().default)(X) || l().EOL, Oe = "/**", $2 = " *", z = " */", O = Object.keys(se), C = O.map((Z) => j(Z, se[Z])).reduce((Z, he) => Z.concat(he), []).map((Z) => $2 + " " + Z + J).join("");
            if (!X) {
              if (O.length === 0)
                return "";
              if (O.length === 1 && !Array.isArray(se[O[0]])) {
                let Z = se[O[0]];
                return "".concat(Oe, " ").concat(j(O[0], Z)[0]).concat(z);
              }
            }
            let Ve = X.split(J).map((Z) => "".concat($2, " ").concat(Z)).join(J) + J;
            return Oe + J + (X ? Ve : "") + (X && O.length ? $2 + J : "") + C + z;
          }
          function j(u, X) {
            return L.concat(X).map((se) => "@".concat(u, " ").concat(se).trim());
          }
        } }), pf = H({ "src/common/end-of-line.js"(h3, l) {
          "use strict";
          V();
          function p2(g) {
            let x = g.indexOf("\r");
            return x >= 0 ? g.charAt(x + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function d(g) {
            switch (g) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function m2(g, x) {
            let T;
            switch (x) {
              case `
`:
                T = /\n/g;
                break;
              case "\r":
                T = /\r/g;
                break;
              case `\r
`:
                T = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(x), "."));
            }
            let k = g.match(T);
            return k ? k.length : 0;
          }
          function A(g) {
            return g.replace(/\r\n?/g, `
`);
          }
          l.exports = { guessEndOfLine: p2, convertEndOfLineToChars: d, countEndOfLineChars: m2, normalizeEndOfLine: A };
        } }), ff = H({ "src/language-js/pragma.js"(h3, l) {
          "use strict";
          V();
          var { parseWithComments: p2, strip: d, extract: m2, print: A } = cf(), { normalizeEndOfLine: g } = pf(), x = Qn();
          function T(E) {
            let L = x(E);
            L && (E = E.slice(L.length + 1));
            let R = m2(E), { pragmas: F, comments: W } = p2(R);
            return { shebang: L, text: E, pragmas: F, comments: W };
          }
          function k(E) {
            let L = Object.keys(T(E).pragmas);
            return L.includes("prettier") || L.includes("format");
          }
          function D(E) {
            let { shebang: L, text: R, pragmas: F, comments: W } = T(E), Y = d(R), M = A({ pragmas: Object.assign({ format: "" }, F), comments: W.trimStart() });
            return (L ? "".concat(L, `
`) : "") + g(M) + (Y.startsWith(`
`) ? `
` : `

`) + Y;
          }
          l.exports = { hasPragma: k, insertPragma: D };
        } }), fo = H({ "src/utils/is-non-empty-array.js"(h3, l) {
          "use strict";
          V();
          function p2(d) {
            return Array.isArray(d) && d.length > 0;
          }
          l.exports = p2;
        } }), mo = H({ "src/language-js/loc.js"(h3, l) {
          "use strict";
          V();
          var p2 = fo();
          function d(T, k) {
            let { ignoreDecorators: D } = k || {};
            if (!D) {
              let E = T.declaration && T.declaration.decorators || T.decorators;
              if (p2(E))
                return d(E[0]);
            }
            return T.range ? T.range[0] : T.start;
          }
          function m2(T) {
            return T.range ? T.range[1] : T.end;
          }
          function A(T, k) {
            let D = d(T);
            return Number.isInteger(D) && D === d(k);
          }
          function g(T, k) {
            let D = m2(T);
            return Number.isInteger(D) && D === m2(k);
          }
          function x(T, k) {
            return A(T, k) && g(T, k);
          }
          l.exports = { locStart: d, locEnd: m2, hasSameLocStart: A, hasSameLoc: x };
        } }), yo = H({ "src/language-js/parse/utils/create-parser.js"(h3, l) {
          "use strict";
          V();
          var { hasPragma: p2 } = ff(), { locStart: d, locEnd: m2 } = mo();
          function A(g) {
            return g = typeof g == "function" ? { parse: g } : g, Object.assign({ astFormat: "estree", hasPragma: p2, locStart: d, locEnd: m2 }, g);
          }
          l.exports = A;
        } }), nr = H({ "src/common/parser-create-error.js"(h3, l) {
          "use strict";
          V();
          function p2(d, m2) {
            let A = new SyntaxError(d + " (" + m2.start.line + ":" + m2.start.column + ")");
            return A.loc = m2, A;
          }
          l.exports = p2;
        } }), xo = H({ "src/language-js/parse/utils/create-babel-parse-error.js"(h3, l) {
          "use strict";
          V();
          var p2 = nr();
          function d(m2) {
            let { message: A, loc: g } = m2;
            return p2(A.replace(/ \(.*\)/, ""), { start: { line: g ? g.line : 0, column: g ? g.column + 1 : 0 } });
          }
          l.exports = d;
        } }), df = H({ "src/language-js/utils/is-ts-keyword-type.js"(h3, l) {
          "use strict";
          V();
          function p2(d) {
            let { type: m2 } = d;
            return m2.startsWith("TS") && m2.endsWith("Keyword");
          }
          l.exports = p2;
        } }), mf = H({ "src/language-js/utils/is-block-comment.js"(h3, l) {
          "use strict";
          V();
          var p2 = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), d = (m2) => p2.has(m2 == null ? void 0 : m2.type);
          l.exports = d;
        } }), yf = H({ "src/language-js/utils/is-type-cast-comment.js"(h3, l) {
          "use strict";
          V();
          var p2 = mf();
          function d(m2) {
            return p2(m2) && m2.value[0] === "*" && /@type\b/.test(m2.value);
          }
          l.exports = d;
        } }), xf = H({ "src/utils/get-last.js"(h3, l) {
          "use strict";
          V();
          var p2 = (d) => d[d.length - 1];
          l.exports = p2;
        } }), go = H({ "src/language-js/parse/postprocess/visit-node.js"(h3, l) {
          "use strict";
          V();
          function p2(d, m2) {
            if (Array.isArray(d)) {
              for (let A = 0; A < d.length; A++)
                d[A] = p2(d[A], m2);
              return d;
            }
            if (d && typeof d == "object" && typeof d.type == "string") {
              let A = Object.keys(d);
              for (let g = 0; g < A.length; g++)
                d[A[g]] = p2(d[A[g]], m2);
              return m2(d) || d;
            }
            return d;
          }
          l.exports = p2;
        } }), Ao = H({ "src/language-js/parse/postprocess/throw-syntax-error.js"(h3, l) {
          "use strict";
          V();
          var p2 = nr();
          function d(m2, A) {
            let { start: g, end: x } = m2.loc;
            throw p2(A, { start: { line: g.line, column: g.column + 1 }, end: { line: x.line, column: x.column + 1 } });
          }
          l.exports = d;
        } }), gf = H({ "src/language-js/parse/postprocess/typescript.js"(h3, l) {
          "use strict";
          V();
          var p2 = go(), d = Ao();
          function m2(x, T, k) {
            let D = x.decorators;
            if (!Array.isArray(D))
              return;
            let E = T.decorators;
            (!Array.isArray(E) || E.length !== D.length || D.some((L) => {
              let R = k.get(L);
              return !R || !E.includes(R);
            })) && d(T, "Leading decorators must be attached to a class declaration");
          }
          function A(x, T) {
            x.kind !== 167 || x.modifiers && !x.modifiers.some((E) => E.kind === 126) || x.initializer && T.value === null && d(T, "Abstract property cannot have an initializer");
          }
          function g(x, T) {
            let { esTreeNodeToTSNodeMap: k, tsNodeToESTreeNodeMap: D } = T.tsParseResult;
            p2(x, (E) => {
              let L = k.get(E);
              if (!L)
                return;
              let R = D.get(L);
              R === E && (m2(L, R, D), A(L, R));
            });
          }
          l.exports = { throwErrorForInvalidNodes: g };
        } }), Af = H({ "src/language-js/parse/postprocess/index.js"(h3, l) {
          "use strict";
          V();
          var { locStart: p2, locEnd: d } = mo(), m2 = df(), A = yf(), g = xf(), x = go(), { throwErrorForInvalidNodes: T } = gf(), k = Ao();
          function D(F, W) {
            if (W.parser === "typescript" && /@|abstract/.test(W.originalText) && T(F, W), W.parser !== "typescript" && W.parser !== "flow" && W.parser !== "acorn" && W.parser !== "espree" && W.parser !== "meriyah") {
              let M = /* @__PURE__ */ new Set();
              F = x(F, (j) => {
                j.leadingComments && j.leadingComments.some(A) && M.add(p2(j));
              }), F = x(F, (j) => {
                if (j.type === "ParenthesizedExpression") {
                  let { expression: u } = j;
                  if (u.type === "TypeCastExpression")
                    return u.range = j.range, u;
                  let X = p2(j);
                  if (!M.has(X))
                    return u.extra = Object.assign(Object.assign({}, u.extra), {}, { parenthesized: true }), u;
                }
              });
            }
            return F = x(F, (M) => {
              switch (M.type) {
                case "ChainExpression":
                  return E(M.expression);
                case "LogicalExpression": {
                  if (L(M))
                    return R(M);
                  break;
                }
                case "VariableDeclaration": {
                  let j = g(M.declarations);
                  j && j.init && Y(M, j);
                  break;
                }
                case "TSParenthesizedType":
                  return m2(M.typeAnnotation) || M.typeAnnotation.type === "TSThisType" || (M.typeAnnotation.range = [p2(M), d(M)]), M.typeAnnotation;
                case "TSTypeParameter":
                  if (typeof M.name == "string") {
                    let j = p2(M);
                    M.name = { type: "Identifier", name: M.name, range: [j, j + M.name.length] };
                  }
                  break;
                case "ObjectExpression":
                  if (W.parser === "typescript") {
                    let j = M.properties.find((u) => u.type === "Property" && u.value.type === "TSEmptyBodyFunctionExpression");
                    j && k(j.value, "Unexpected token.");
                  }
                  break;
                case "SequenceExpression": {
                  let j = g(M.expressions);
                  M.range = [p2(M), Math.min(d(j), d(M))];
                  break;
                }
                case "TopicReference":
                  W.__isUsingHackPipeline = true;
                  break;
                case "ExportAllDeclaration": {
                  let { exported: j } = M;
                  if (W.parser === "meriyah" && j && j.type === "Identifier") {
                    let u = W.originalText.slice(p2(j), d(j));
                    (u.startsWith('"') || u.startsWith("'")) && (M.exported = Object.assign(Object.assign({}, M.exported), {}, { type: "Literal", value: M.exported.name, raw: u }));
                  }
                  break;
                }
              }
            }), F;
            function Y(M, j) {
              W.originalText[d(j)] !== ";" && (M.range = [p2(M), d(j)]);
            }
          }
          function E(F) {
            switch (F.type) {
              case "CallExpression":
                F.type = "OptionalCallExpression", F.callee = E(F.callee);
                break;
              case "MemberExpression":
                F.type = "OptionalMemberExpression", F.object = E(F.object);
                break;
              case "TSNonNullExpression":
                F.expression = E(F.expression);
                break;
            }
            return F;
          }
          function L(F) {
            return F.type === "LogicalExpression" && F.right.type === "LogicalExpression" && F.operator === F.right.operator;
          }
          function R(F) {
            return L(F) ? R({ type: "LogicalExpression", operator: F.operator, left: R({ type: "LogicalExpression", operator: F.operator, left: F.left, right: F.right.left, range: [p2(F.left), d(F.right.left)] }), right: F.right.right, range: [p2(F), d(F)] }) : F;
          }
          l.exports = D;
        } }), Po = H({ "node_modules/@babel/parser/lib/index.js"(h3) {
          "use strict";
          V(), Object.defineProperty(h3, "__esModule", { value: true });
          function l(t, e) {
            if (t == null)
              return {};
            var s = {}, r = Object.keys(t), i, a;
            for (a = 0; a < r.length; a++)
              i = r[a], !(e.indexOf(i) >= 0) && (s[i] = t[i]);
            return s;
          }
          var p2 = class {
            constructor(t, e, s) {
              this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = e, this.index = s;
            }
          }, d = class {
            constructor(t, e) {
              this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = e;
            }
          };
          function m2(t, e) {
            let { line: s, column: r, index: i } = t;
            return new p2(s, r + e, i + e);
          }
          var A = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), g = function(t) {
            let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t.length - 1;
            return { get() {
              return t.reduce((s, r) => s[r], this);
            }, set(s) {
              t.reduce((r, i, a) => a === e ? r[i] = s : r[i], this);
            } };
          }, x = (t, e, s) => Object.keys(s).map((r) => [r, s[r]]).filter((r) => {
            let [, i] = r;
            return !!i;
          }).map((r) => {
            let [i, a] = r;
            return [i, typeof a == "function" ? { value: a, enumerable: false } : typeof a.reflect == "string" ? Object.assign({}, a, g(a.reflect.split("."))) : a];
          }).reduce((r, i) => {
            let [a, n] = i;
            return Object.defineProperty(r, a, Object.assign({ configurable: true }, n));
          }, Object.assign(new t(), e)), T = (t) => ({ ImportMetaOutsideModule: t(`import.meta may appear only with 'sourceType: "module"'`, { code: A.SourceTypeModuleError }), ImportOutsideModule: t(`'import' and 'export' may appear only with 'sourceType: "module"'`, { code: A.SourceTypeModuleError }) }), k = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, D = (t) => {
            let { type: e, prefix: s } = t;
            return e === "UpdateExpression" ? k.UpdateExpression[String(s)] : k[e];
          }, E = (t) => ({ AccessorIsGenerator: t((e) => {
            let { kind: s } = e;
            return "A ".concat(s, "ter cannot be a generator.");
          }), ArgumentsInClass: t("'arguments' is only allowed in functions and class methods."), AsyncFunctionInSingleStatementContext: t("Async functions can only be declared at the top level or inside a block."), AwaitBindingIdentifier: t("Can not use 'await' as identifier inside an async function."), AwaitBindingIdentifierInStaticBlock: t("Can not use 'await' as identifier inside a static block."), AwaitExpressionFormalParameter: t("'await' is not allowed in async function parameters."), AwaitNotInAsyncContext: t("'await' is only allowed within async functions and at the top levels of modules."), AwaitNotInAsyncFunction: t("'await' is only allowed within async functions."), BadGetterArity: t("A 'get' accesor must not have any formal parameters."), BadSetterArity: t("A 'set' accesor must have exactly one formal parameter."), BadSetterRestParameter: t("A 'set' accesor function argument must not be a rest parameter."), ConstructorClassField: t("Classes may not have a field named 'constructor'."), ConstructorClassPrivateField: t("Classes may not have a private field named '#constructor'."), ConstructorIsAccessor: t("Class constructor may not be an accessor."), ConstructorIsAsync: t("Constructor can't be an async function."), ConstructorIsGenerator: t("Constructor can't be a generator."), DeclarationMissingInitializer: t((e) => {
            let { kind: s } = e;
            return "Missing initializer in ".concat(s, " declaration.");
          }), DecoratorBeforeExport: t("Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax."), DecoratorConstructor: t("Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?"), DecoratorExportClass: t("Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead."), DecoratorSemicolon: t("Decorators must not be followed by a semicolon."), DecoratorStaticBlock: t("Decorators can't be used with a static block."), DeletePrivateField: t("Deleting a private field is not allowed."), DestructureNamedImport: t("ES2015 named imports do not destructure. Use another statement for destructuring after the import."), DuplicateConstructor: t("Duplicate constructor in the same class."), DuplicateDefaultExport: t("Only one default export allowed per module."), DuplicateExport: t((e) => {
            let { exportName: s } = e;
            return "`".concat(s, "` has already been exported. Exported identifiers must be unique.");
          }), DuplicateProto: t("Redefinition of __proto__ property."), DuplicateRegExpFlags: t("Duplicate regular expression flag."), ElementAfterRest: t("Rest element must be last element."), EscapedCharNotAnIdentifier: t("Invalid Unicode escape."), ExportBindingIsString: t((e) => {
            let { localName: s, exportName: r } = e;
            return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '".concat(s, "' as '").concat(r, "' } from 'some-module'`?");
          }), ExportDefaultFromAsIdentifier: t("'from' is not allowed as an identifier after 'export default'."), ForInOfLoopInitializer: t((e) => {
            let { type: s } = e;
            return "'".concat(s === "ForInStatement" ? "for-in" : "for-of", "' loop variable declaration may not have an initializer.");
          }), ForOfAsync: t("The left-hand side of a for-of loop may not be 'async'."), ForOfLet: t("The left-hand side of a for-of loop may not start with 'let'."), GeneratorInSingleStatementContext: t("Generators can only be declared at the top level or inside a block."), IllegalBreakContinue: t((e) => {
            let { type: s } = e;
            return "Unsyntactic ".concat(s === "BreakStatement" ? "break" : "continue", ".");
          }), IllegalLanguageModeDirective: t("Illegal 'use strict' directive in function with non-simple parameter list."), IllegalReturn: t("'return' outside of function."), ImportBindingIsString: t((e) => {
            let { importName: s } = e;
            return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(s, '" as foo }`?');
          }), ImportCallArgumentTrailingComma: t("Trailing comma is disallowed inside import(...) arguments."), ImportCallArity: t((e) => {
            let { maxArgumentCount: s } = e;
            return "`import()` requires exactly ".concat(s === 1 ? "one argument" : "one or two arguments", ".");
          }), ImportCallNotNewExpression: t("Cannot use new with import(...)."), ImportCallSpreadArgument: t("`...` is not allowed in `import()`."), IncompatibleRegExpUVFlags: t("The 'u' and 'v' regular expression flags cannot be enabled at the same time."), InvalidBigIntLiteral: t("Invalid BigIntLiteral."), InvalidCodePoint: t("Code point out of bounds."), InvalidCoverInitializedName: t("Invalid shorthand property initializer."), InvalidDecimal: t("Invalid decimal."), InvalidDigit: t((e) => {
            let { radix: s } = e;
            return "Expected number in radix ".concat(s, ".");
          }), InvalidEscapeSequence: t("Bad character escape sequence."), InvalidEscapeSequenceTemplate: t("Invalid escape sequence in template."), InvalidEscapedReservedWord: t((e) => {
            let { reservedWord: s } = e;
            return "Escape sequence in keyword ".concat(s, ".");
          }), InvalidIdentifier: t((e) => {
            let { identifierName: s } = e;
            return "Invalid identifier ".concat(s, ".");
          }), InvalidLhs: t((e) => {
            let { ancestor: s } = e;
            return "Invalid left-hand side in ".concat(D(s), ".");
          }), InvalidLhsBinding: t((e) => {
            let { ancestor: s } = e;
            return "Binding invalid left-hand side in ".concat(D(s), ".");
          }), InvalidNumber: t("Invalid number."), InvalidOrMissingExponent: t("Floating-point numbers require a valid exponent after the 'e'."), InvalidOrUnexpectedToken: t((e) => {
            let { unexpected: s } = e;
            return "Unexpected character '".concat(s, "'.");
          }), InvalidParenthesizedAssignment: t("Invalid parenthesized assignment pattern."), InvalidPrivateFieldResolution: t((e) => {
            let { identifierName: s } = e;
            return "Private name #".concat(s, " is not defined.");
          }), InvalidPropertyBindingPattern: t("Binding member expression."), InvalidRecordProperty: t("Only properties and spread elements are allowed in record definitions."), InvalidRestAssignmentPattern: t("Invalid rest operator's argument."), LabelRedeclaration: t((e) => {
            let { labelName: s } = e;
            return "Label '".concat(s, "' is already declared.");
          }), LetInLexicalBinding: t("'let' is not allowed to be used as a name in 'let' or 'const' declarations."), LineTerminatorBeforeArrow: t("No line break is allowed before '=>'."), MalformedRegExpFlags: t("Invalid regular expression flag."), MissingClassName: t("A class name is required."), MissingEqInAssignment: t("Only '=' operator can be used for specifying default value."), MissingSemicolon: t("Missing semicolon."), MissingPlugin: t((e) => {
            let { missingPlugin: s } = e;
            return "This experimental syntax requires enabling the parser plugin: ".concat(s.map((r) => JSON.stringify(r)).join(", "), ".");
          }), MissingOneOfPlugins: t((e) => {
            let { missingPlugin: s } = e;
            return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(s.map((r) => JSON.stringify(r)).join(", "), ".");
          }), MissingUnicodeEscape: t("Expecting Unicode escape sequence \\uXXXX."), MixingCoalesceWithLogical: t("Nullish coalescing operator(??) requires parens when mixing with logical operators."), ModuleAttributeDifferentFromType: t("The only accepted module attribute is `type`."), ModuleAttributeInvalidValue: t("Only string literals are allowed as module attribute values."), ModuleAttributesWithDuplicateKeys: t((e) => {
            let { key: s } = e;
            return 'Duplicate key "'.concat(s, '" is not allowed in module attributes.');
          }), ModuleExportNameHasLoneSurrogate: t((e) => {
            let { surrogateCharCode: s } = e;
            return "An export name cannot include a lone surrogate, found '\\u".concat(s.toString(16), "'.");
          }), ModuleExportUndefined: t((e) => {
            let { localName: s } = e;
            return "Export '".concat(s, "' is not defined.");
          }), MultipleDefaultsInSwitch: t("Multiple default clauses."), NewlineAfterThrow: t("Illegal newline after throw."), NoCatchOrFinally: t("Missing catch or finally clause."), NumberIdentifier: t("Identifier directly after number."), NumericSeparatorInEscapeSequence: t("Numeric separators are not allowed inside unicode escape sequences or hex escape sequences."), ObsoleteAwaitStar: t("'await*' has been removed from the async functions proposal. Use Promise.all() instead."), OptionalChainingNoNew: t("Constructors in/after an Optional Chain are not allowed."), OptionalChainingNoTemplate: t("Tagged Template Literals are not allowed in optionalChain."), OverrideOnConstructor: t("'override' modifier cannot appear on a constructor declaration."), ParamDupe: t("Argument name clash."), PatternHasAccessor: t("Object pattern can't contain getter or setter."), PatternHasMethod: t("Object pattern can't contain methods."), PrivateInExpectedIn: t((e) => {
            let { identifierName: s } = e;
            return "Private names are only allowed in property accesses (`obj.#".concat(s, "`) or in `in` expressions (`#").concat(s, " in obj`).");
          }), PrivateNameRedeclaration: t((e) => {
            let { identifierName: s } = e;
            return "Duplicate private name #".concat(s, ".");
          }), RecordExpressionBarIncorrectEndSyntaxType: t("Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), RecordExpressionBarIncorrectStartSyntaxType: t("Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), RecordExpressionHashIncorrectStartSyntaxType: t("Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."), RecordNoProto: t("'__proto__' is not allowed in Record expressions."), RestTrailingComma: t("Unexpected trailing comma after rest element."), SloppyFunction: t("In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement."), StaticPrototype: t("Classes may not have static property named prototype."), SuperNotAllowed: t("`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?"), SuperPrivateField: t("Private fields can't be accessed on super."), TrailingDecorator: t("Decorators must be attached to a class element."), TupleExpressionBarIncorrectEndSyntaxType: t("Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), TupleExpressionBarIncorrectStartSyntaxType: t("Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'."), TupleExpressionHashIncorrectStartSyntaxType: t("Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'."), UnexpectedArgumentPlaceholder: t("Unexpected argument placeholder."), UnexpectedAwaitAfterPipelineBody: t('Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.'), UnexpectedDigitAfterHash: t("Unexpected digit after hash token."), UnexpectedImportExport: t("'import' and 'export' may only appear at the top level."), UnexpectedKeyword: t((e) => {
            let { keyword: s } = e;
            return "Unexpected keyword '".concat(s, "'.");
          }), UnexpectedLeadingDecorator: t("Leading decorators must be attached to a class declaration."), UnexpectedLexicalDeclaration: t("Lexical declaration cannot appear in a single-statement context."), UnexpectedNewTarget: t("`new.target` can only be used in functions or class properties."), UnexpectedNumericSeparator: t("A numeric separator is only allowed between two digits."), UnexpectedPrivateField: t("Unexpected private name."), UnexpectedReservedWord: t((e) => {
            let { reservedWord: s } = e;
            return "Unexpected reserved word '".concat(s, "'.");
          }), UnexpectedSuper: t("'super' is only allowed in object methods and classes."), UnexpectedToken: t((e) => {
            let { expected: s, unexpected: r } = e;
            return "Unexpected token".concat(r ? " '".concat(r, "'.") : "").concat(s ? ', expected "'.concat(s, '"') : "");
          }), UnexpectedTokenUnaryExponentiation: t("Illegal expression. Wrap left hand side or entire exponentiation in parentheses."), UnsupportedBind: t("Binding should be performed on object property."), UnsupportedDecoratorExport: t("A decorated export must export a class declaration."), UnsupportedDefaultExport: t("Only expressions, functions or classes are allowed as the `default` export."), UnsupportedImport: t("`import` can only be used in `import()` or `import.meta`."), UnsupportedMetaProperty: t((e) => {
            let { target: s, onlyValidPropertyName: r } = e;
            return "The only valid meta property for ".concat(s, " is ").concat(s, ".").concat(r, ".");
          }), UnsupportedParameterDecorator: t("Decorators cannot be used to decorate parameters."), UnsupportedPropertyDecorator: t("Decorators cannot be used to decorate object literal properties."), UnsupportedSuper: t("'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])."), UnterminatedComment: t("Unterminated comment."), UnterminatedRegExp: t("Unterminated regular expression."), UnterminatedString: t("Unterminated string constant."), UnterminatedTemplate: t("Unterminated template."), VarRedeclaration: t((e) => {
            let { identifierName: s } = e;
            return "Identifier '".concat(s, "' has already been declared.");
          }), YieldBindingIdentifier: t("Can not use 'yield' as identifier inside a generator."), YieldInParameter: t("Yield expression is not allowed in formal parameters."), ZeroDigitNumericSeparator: t("Numeric separator can not be used after leading 0.") }), L = (t) => ({ StrictDelete: t("Deleting local variable in strict mode."), StrictEvalArguments: t((e) => {
            let { referenceName: s } = e;
            return "Assigning to '".concat(s, "' in strict mode.");
          }), StrictEvalArgumentsBinding: t((e) => {
            let { bindingName: s } = e;
            return "Binding '".concat(s, "' in strict mode.");
          }), StrictFunction: t("In strict mode code, functions can only be declared at top level or inside a block."), StrictNumericEscape: t("The only valid numeric escape in strict mode is '\\0'."), StrictOctalLiteral: t("Legacy octal literals are not allowed in strict mode."), StrictWith: t("'with' in strict mode.") }), R = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), F = (t) => ({ PipeBodyIsTighter: t("Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence."), PipeTopicRequiresHackPipes: t('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'), PipeTopicUnbound: t("Topic reference is unbound; it must be inside a pipe body."), PipeTopicUnconfiguredToken: t((e) => {
            let { token: s } = e;
            return "Invalid topic token ".concat(s, ". In order to use ").concat(s, ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "').concat(s, '" }.');
          }), PipeTopicUnused: t("Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once."), PipeUnparenthesizedBody: t((e) => {
            let { type: s } = e;
            return "Hack-style pipe body cannot be an unparenthesized ".concat(D({ type: s }), "; please wrap it in parentheses.");
          }), PipelineBodyNoArrow: t('Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.'), PipelineBodySequenceExpression: t("Pipeline body may not be a comma-separated sequence expression."), PipelineHeadSequenceExpression: t("Pipeline head should not be a comma-separated sequence expression."), PipelineTopicUnused: t("Pipeline is in topic style but does not use topic reference."), PrimaryTopicNotAllowed: t("Topic reference was used in a lexical context without topic binding."), PrimaryTopicRequiresSmartPipeline: t('Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.') }), W = ["toMessage"];
          function Y(t) {
            let { toMessage: e } = t, s = l(t, W);
            return function r(i) {
              let { loc: a, details: n } = i;
              return x(SyntaxError, Object.assign({}, s, { loc: a }), { clone() {
                let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o.loc || {};
                return r({ loc: new p2("line" in c ? c.line : this.loc.line, "column" in c ? c.column : this.loc.column, "index" in c ? c.index : this.loc.index), details: Object.assign({}, this.details, o.details) });
              }, details: { value: n, enumerable: false }, message: { get() {
                return "".concat(e(this.details), " (").concat(this.loc.line, ":").concat(this.loc.column, ")");
              }, set(o) {
                Object.defineProperty(this, "message", { value: o });
              } }, pos: { reflect: "loc.index", enumerable: true }, missingPlugin: "missingPlugin" in n && { reflect: "details.missingPlugin", enumerable: true } });
            };
          }
          function M(t, e) {
            return Object.assign({ toMessage: typeof t == "string" ? () => t : t }, e);
          }
          function j(t, e) {
            if (Array.isArray(t))
              return (i) => j(i, t[0]);
            let s = t(M), r = {};
            for (let i of Object.keys(s))
              r[i] = Y(Object.assign({ code: A.SyntaxError, reasonCode: i }, e ? { syntaxPlugin: e } : {}, s[i]));
            return r;
          }
          var u = Object.assign({}, j(T), j(E), j(L), j(_n2 || (_n2 = rt(["pipelineOperator"])))(F)), { defineProperty: X } = Object, se = (t, e) => X(t, e, { enumerable: false, value: t[e] });
          function J(t) {
            return se(t.loc.start, "index"), se(t.loc.end, "index"), t;
          }
          var Oe = (t) => class extends t {
            parse() {
              let e = J(super.parse());
              return this.options.tokens && (e.tokens = e.tokens.map(J)), e;
            }
            parseRegExpLiteral(e) {
              let { pattern: s, flags: r } = e, i = null;
              try {
                i = new RegExp(s, r);
              } catch {
              }
              let a = this.estreeParseLiteral(i);
              return a.regex = { pattern: s, flags: r }, a;
            }
            parseBigIntLiteral(e) {
              let s;
              try {
                s = BigInt(e);
              } catch {
                s = null;
              }
              let r = this.estreeParseLiteral(s);
              return r.bigint = String(r.value || e), r;
            }
            parseDecimalLiteral(e) {
              let r = this.estreeParseLiteral(null);
              return r.decimal = String(r.value || e), r;
            }
            estreeParseLiteral(e) {
              return this.parseLiteral(e, "Literal");
            }
            parseStringLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNumericLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            parseNullLiteral() {
              return this.estreeParseLiteral(null);
            }
            parseBooleanLiteral(e) {
              return this.estreeParseLiteral(e);
            }
            directiveToStmt(e) {
              let s = e.value, r = this.startNodeAt(e.start, e.loc.start), i = this.startNodeAt(s.start, s.loc.start);
              return i.value = s.extra.expressionValue, i.raw = s.extra.raw, r.expression = this.finishNodeAt(i, "Literal", s.loc.end), r.directive = s.extra.raw.slice(1, -1), this.finishNodeAt(r, "ExpressionStatement", e.loc.end);
            }
            initFunction(e, s) {
              super.initFunction(e, s), e.expression = false;
            }
            checkDeclaration(e) {
              e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
            }
            getObjectOrClassMethodParams(e) {
              return e.value.params;
            }
            isValidDirective(e) {
              var s;
              return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
            }
            parseBlockBody(e) {
              for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
                r[i - 1] = arguments[i];
              super.parseBlockBody(e, ...r);
              let a = e.directives.map((n) => this.directiveToStmt(n));
              e.body = a.concat(e.body), delete e.directives;
            }
            pushClassMethod(e, s, r, i, a, n) {
              this.parseMethod(s, r, i, a, n, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
            }
            parsePrivateName() {
              let e = super.parsePrivateName();
              return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
            }
            convertPrivateNameToPrivateIdentifier(e) {
              let s = super.getPrivateNameSV(e);
              return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
            }
            isPrivateName(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
            }
            getPrivateNameSV(e) {
              return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
            }
            parseLiteral(e, s) {
              let r = super.parseLiteral(e, s);
              return r.raw = r.extra.raw, delete r.extra, r;
            }
            parseFunctionBody(e, s) {
              let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              super.parseFunctionBody(e, s, r), e.expression = e.body.type !== "BlockStatement";
            }
            parseMethod(e, s, r, i, a, n) {
              let o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false, c = this.startNode();
              return c.kind = e.kind, c = super.parseMethod(c, s, r, i, a, n, o), c.type = "FunctionExpression", delete c.kind, e.value = c, n === "ClassPrivateMethod" && (e.computed = false), n = "MethodDefinition", this.finishNode(e, n);
            }
            parseClassProperty() {
              let e = super.parseClassProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition"), e;
            }
            parseClassPrivateProperty() {
              let e = super.parseClassPrivateProperty(...arguments);
              return this.getPluginOption("estree", "classFeatures") && (e.type = "PropertyDefinition", e.computed = false), e;
            }
            parseObjectMethod(e, s, r, i, a) {
              let n = super.parseObjectMethod(e, s, r, i, a);
              return n && (n.type = "Property", n.kind === "method" && (n.kind = "init"), n.shorthand = false), n;
            }
            parseObjectProperty(e, s, r, i, a) {
              let n = super.parseObjectProperty(e, s, r, i, a);
              return n && (n.kind = "init", n.type = "Property"), n;
            }
            isValidLVal(e) {
              for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
                r[i - 1] = arguments[i];
              return e === "Property" ? "value" : super.isValidLVal(e, ...r);
            }
            isAssignable(e, s) {
              return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
            }
            toAssignable(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e != null && this.isObjectProperty(e)) {
                let { key: r, value: i } = e;
                this.isPrivateName(r) && this.classScope.usePrivateName(this.getPrivateNameSV(r), r.loc.start), this.toAssignable(i, s);
              } else
                super.toAssignable(e, s);
            }
            toAssignableObjectExpressionProp(e) {
              e.kind === "get" || e.kind === "set" ? this.raise(u.PatternHasAccessor, { at: e.key }) : e.method ? this.raise(u.PatternHasMethod, { at: e.key }) : super.toAssignableObjectExpressionProp(...arguments);
            }
            finishCallExpression(e, s) {
              if (super.finishCallExpression(e, s), e.callee.type === "Import") {
                if (e.type = "ImportExpression", e.source = e.arguments[0], this.hasPlugin("importAssertions")) {
                  var r;
                  e.attributes = (r = e.arguments[1]) != null ? r : null;
                }
                delete e.arguments, delete e.callee;
              }
              return e;
            }
            toReferencedArguments(e) {
              e.type !== "ImportExpression" && super.toReferencedArguments(e);
            }
            parseExport(e) {
              switch (super.parseExport(e), e.type) {
                case "ExportAllDeclaration":
                  e.exported = null;
                  break;
                case "ExportNamedDeclaration":
                  e.specifiers.length === 1 && e.specifiers[0].type === "ExportNamespaceSpecifier" && (e.type = "ExportAllDeclaration", e.exported = e.specifiers[0].exported, delete e.specifiers);
                  break;
              }
              return e;
            }
            parseSubscript(e, s, r, i, a) {
              let n = super.parseSubscript(e, s, r, i, a);
              if (a.optionalChainMember) {
                if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), a.stop) {
                  let o = this.startNodeAtNode(n);
                  return o.expression = n, this.finishNode(o, "ChainExpression");
                }
              } else
                (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
              return n;
            }
            hasPropertyAsPrivateName(e) {
              return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
            }
            isOptionalChain(e) {
              return e.type === "ChainExpression";
            }
            isObjectProperty(e) {
              return e.type === "Property" && e.kind === "init" && !e.method;
            }
            isObjectMethod(e) {
              return e.method || e.kind === "get" || e.kind === "set";
            }
            finishNodeAt(e, s, r) {
              return J(super.finishNodeAt(e, s, r));
            }
            resetEndLocation(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              super.resetEndLocation(e, s), J(e);
            }
          }, $2 = class {
            constructor(t, e) {
              this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!e;
            }
          }, z = { brace: new $2("{"), j_oTag: new $2("<tag"), j_cTag: new $2("</tag"), j_expr: new $2("<tag>...</tag>", true) };
          z.template = new $2("`", true);
          var O = true, C = true, Ve = true, Z = true, he = true, Co = true, or = class {
            constructor(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null, this.updateContext = null;
            }
          }, qt = /* @__PURE__ */ new Map();
          function q(t) {
            let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            e.keyword = t;
            let s = w(t, e);
            return qt.set(t, s), s;
          }
          function te(t, e) {
            return w(t, { beforeExpr: O, binop: e });
          }
          var He = -1, ce = [], Ut = [], it = [], _t = [], zt = [], Kt = [];
          function w(t) {
            let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var s, r, i, a;
            return ++He, Ut.push(t), it.push((s = e.binop) != null ? s : -1), _t.push((r = e.beforeExpr) != null ? r : false), zt.push((i = e.startsExpr) != null ? i : false), Kt.push((a = e.prefix) != null ? a : false), ce.push(new or(t, e)), He;
          }
          function U(t) {
            let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var s, r, i, a;
            return ++He, qt.set(t, He), Ut.push(t), it.push((s = e.binop) != null ? s : -1), _t.push((r = e.beforeExpr) != null ? r : false), zt.push((i = e.startsExpr) != null ? i : false), Kt.push((a = e.prefix) != null ? a : false), ce.push(new or("name", e)), He;
          }
          var bo = { bracketL: w("[", { beforeExpr: O, startsExpr: C }), bracketHashL: w("#[", { beforeExpr: O, startsExpr: C }), bracketBarL: w("[|", { beforeExpr: O, startsExpr: C }), bracketR: w("]"), bracketBarR: w("|]"), braceL: w("{", { beforeExpr: O, startsExpr: C }), braceBarL: w("{|", { beforeExpr: O, startsExpr: C }), braceHashL: w("#{", { beforeExpr: O, startsExpr: C }), braceR: w("}"), braceBarR: w("|}"), parenL: w("(", { beforeExpr: O, startsExpr: C }), parenR: w(")"), comma: w(",", { beforeExpr: O }), semi: w(";", { beforeExpr: O }), colon: w(":", { beforeExpr: O }), doubleColon: w("::", { beforeExpr: O }), dot: w("."), question: w("?", { beforeExpr: O }), questionDot: w("?."), arrow: w("=>", { beforeExpr: O }), template: w("template"), ellipsis: w("...", { beforeExpr: O }), backQuote: w("`", { startsExpr: C }), dollarBraceL: w("${", { beforeExpr: O, startsExpr: C }), templateTail: w("...`", { startsExpr: C }), templateNonTail: w("...${", { beforeExpr: O, startsExpr: C }), at: w("@"), hash: w("#", { startsExpr: C }), interpreterDirective: w("#!..."), eq: w("=", { beforeExpr: O, isAssign: Z }), assign: w("_=", { beforeExpr: O, isAssign: Z }), slashAssign: w("_=", { beforeExpr: O, isAssign: Z }), xorAssign: w("_=", { beforeExpr: O, isAssign: Z }), moduloAssign: w("_=", { beforeExpr: O, isAssign: Z }), incDec: w("++/--", { prefix: he, postfix: Co, startsExpr: C }), bang: w("!", { beforeExpr: O, prefix: he, startsExpr: C }), tilde: w("~", { beforeExpr: O, prefix: he, startsExpr: C }), doubleCaret: w("^^", { startsExpr: C }), doubleAt: w("@@", { startsExpr: C }), pipeline: te("|>", 0), nullishCoalescing: te("??", 1), logicalOR: te("||", 1), logicalAND: te("&&", 2), bitwiseOR: te("|", 3), bitwiseXOR: te("^", 4), bitwiseAND: te("&", 5), equality: te("==/!=/===/!==", 6), lt: te("</>/<=/>=", 7), gt: te("</>/<=/>=", 7), relational: te("</>/<=/>=", 7), bitShift: te("<</>>/>>>", 8), bitShiftL: te("<</>>/>>>", 8), bitShiftR: te("<</>>/>>>", 8), plusMin: w("+/-", { beforeExpr: O, binop: 9, prefix: he, startsExpr: C }), modulo: w("%", { binop: 10, startsExpr: C }), star: w("*", { binop: 10 }), slash: te("/", 10), exponent: w("**", { beforeExpr: O, binop: 11, rightAssociative: true }), _in: q("in", { beforeExpr: O, binop: 7 }), _instanceof: q("instanceof", { beforeExpr: O, binop: 7 }), _break: q("break"), _case: q("case", { beforeExpr: O }), _catch: q("catch"), _continue: q("continue"), _debugger: q("debugger"), _default: q("default", { beforeExpr: O }), _else: q("else", { beforeExpr: O }), _finally: q("finally"), _function: q("function", { startsExpr: C }), _if: q("if"), _return: q("return", { beforeExpr: O }), _switch: q("switch"), _throw: q("throw", { beforeExpr: O, prefix: he, startsExpr: C }), _try: q("try"), _var: q("var"), _const: q("const"), _with: q("with"), _new: q("new", { beforeExpr: O, startsExpr: C }), _this: q("this", { startsExpr: C }), _super: q("super", { startsExpr: C }), _class: q("class", { startsExpr: C }), _extends: q("extends", { beforeExpr: O }), _export: q("export"), _import: q("import", { startsExpr: C }), _null: q("null", { startsExpr: C }), _true: q("true", { startsExpr: C }), _false: q("false", { startsExpr: C }), _typeof: q("typeof", { beforeExpr: O, prefix: he, startsExpr: C }), _void: q("void", { beforeExpr: O, prefix: he, startsExpr: C }), _delete: q("delete", { beforeExpr: O, prefix: he, startsExpr: C }), _do: q("do", { isLoop: Ve, beforeExpr: O }), _for: q("for", { isLoop: Ve }), _while: q("while", { isLoop: Ve }), _as: U("as", { startsExpr: C }), _assert: U("assert", { startsExpr: C }), _async: U("async", { startsExpr: C }), _await: U("await", { startsExpr: C }), _from: U("from", { startsExpr: C }), _get: U("get", { startsExpr: C }), _let: U("let", { startsExpr: C }), _meta: U("meta", { startsExpr: C }), _of: U("of", { startsExpr: C }), _sent: U("sent", { startsExpr: C }), _set: U("set", { startsExpr: C }), _static: U("static", { startsExpr: C }), _yield: U("yield", { startsExpr: C }), _asserts: U("asserts", { startsExpr: C }), _checks: U("checks", { startsExpr: C }), _exports: U("exports", { startsExpr: C }), _global: U("global", { startsExpr: C }), _implements: U("implements", { startsExpr: C }), _intrinsic: U("intrinsic", { startsExpr: C }), _infer: U("infer", { startsExpr: C }), _is: U("is", { startsExpr: C }), _mixins: U("mixins", { startsExpr: C }), _proto: U("proto", { startsExpr: C }), _require: U("require", { startsExpr: C }), _keyof: U("keyof", { startsExpr: C }), _readonly: U("readonly", { startsExpr: C }), _unique: U("unique", { startsExpr: C }), _abstract: U("abstract", { startsExpr: C }), _declare: U("declare", { startsExpr: C }), _enum: U("enum", { startsExpr: C }), _module: U("module", { startsExpr: C }), _namespace: U("namespace", { startsExpr: C }), _interface: U("interface", { startsExpr: C }), _type: U("type", { startsExpr: C }), _opaque: U("opaque", { startsExpr: C }), name: w("name", { startsExpr: C }), string: w("string", { startsExpr: C }), num: w("num", { startsExpr: C }), bigint: w("bigint", { startsExpr: C }), decimal: w("decimal", { startsExpr: C }), regexp: w("regexp", { startsExpr: C }), privateName: w("#name", { startsExpr: C }), eof: w("eof"), jsxName: w("jsxName"), jsxText: w("jsxText", { beforeExpr: true }), jsxTagStart: w("jsxTagStart", { startsExpr: true }), jsxTagEnd: w("jsxTagEnd"), placeholder: w("%%", { startsExpr: true }) };
          function K(t) {
            return t >= 93 && t <= 128;
          }
          function vo(t) {
            return t <= 92;
          }
          function pe(t) {
            return t >= 58 && t <= 128;
          }
          function hr(t) {
            return t >= 58 && t <= 132;
          }
          function So(t) {
            return _t[t];
          }
          function Vt(t) {
            return zt[t];
          }
          function wo(t) {
            return t >= 29 && t <= 33;
          }
          function lr(t) {
            return t >= 125 && t <= 127;
          }
          function No(t) {
            return t >= 90 && t <= 92;
          }
          function Ht(t) {
            return t >= 58 && t <= 92;
          }
          function Io(t) {
            return t >= 39 && t <= 59;
          }
          function ko(t) {
            return t === 34;
          }
          function Do(t) {
            return Kt[t];
          }
          function Fo(t) {
            return t >= 117 && t <= 119;
          }
          function Lo(t) {
            return t >= 120 && t <= 126;
          }
          function Pe(t) {
            return Ut[t];
          }
          function at(t) {
            return it[t];
          }
          function Oo(t) {
            return it[t] !== -1;
          }
          function Bo(t) {
            return t === 57;
          }
          function nt(t) {
            return t >= 24 && t <= 25;
          }
          function fe(t) {
            return ce[t];
          }
          ce[8].updateContext = (t) => {
            t.pop();
          }, ce[5].updateContext = ce[7].updateContext = ce[23].updateContext = (t) => {
            t.push(z.brace);
          }, ce[22].updateContext = (t) => {
            t[t.length - 1] === z.template ? t.pop() : t.push(z.template);
          }, ce[138].updateContext = (t) => {
            t.push(z.j_expr, z.j_oTag);
          };
          var Wt = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", ur = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", Mo = new RegExp("[" + Wt + "]"), Ro = new RegExp("[" + Wt + ur + "]");
          Wt = ur = null;
          var cr = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], jo = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
          function Gt(t, e) {
            let s = 65536;
            for (let r = 0, i = e.length; r < i; r += 2) {
              if (s += e[r], s > t)
                return false;
              if (s += e[r + 1], s >= t)
                return true;
            }
            return false;
          }
          function de(t) {
            return t < 65 ? t === 36 : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && Mo.test(String.fromCharCode(t)) : Gt(t, cr);
          }
          function Be(t) {
            return t < 48 ? t === 36 : t < 58 ? true : t < 65 ? false : t <= 90 ? true : t < 97 ? t === 95 : t <= 122 ? true : t <= 65535 ? t >= 170 && Ro.test(String.fromCharCode(t)) : Gt(t, cr) || Gt(t, jo);
          }
          var Xt = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, qo = new Set(Xt.keyword), Uo = new Set(Xt.strict), _o = new Set(Xt.strictBind);
          function pr(t, e) {
            return e && t === "await" || t === "enum";
          }
          function fr(t, e) {
            return pr(t, e) || Uo.has(t);
          }
          function dr(t) {
            return _o.has(t);
          }
          function mr(t, e) {
            return fr(t, e) || dr(t);
          }
          function zo(t) {
            return qo.has(t);
          }
          function Ko(t, e, s) {
            return t === 64 && e === 64 && de(s);
          }
          var Vo = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
          function Ho(t) {
            return Vo.has(t);
          }
          var Me = 0, We = 1, me = 2, Jt = 4, yr = 8, ot = 16, xr = 32, Se = 64, Yt = 128, ht = 256, lt = We | me | ht, ye = 1, Re = 2, gr = 4, Te = 8, ut = 16, Ar = 64, ct = 128, $t = 256, Qt = 512, Zt = 1024, es = 2048, Pr = ye | Re | Te | ct, xe = ye | 0 | Te | 0, pt = ye | 0 | gr | 0, Tr = ye | 0 | ut | 0, Wo = 0 | Re | 0 | ct, Go = 0 | Re | 0 | 0, Er = ye | Re | Te | $t, Cr = 0 | Zt, we = 0 | Ar, Xo = ye | 0 | 0 | Ar, Jo = Er | Qt, Yo = 0 | Zt, $o = es, ft = 4, ts = 2, ss = 1, rs = ts | ss, Qo = ts | ft, Zo = ss | ft, eh = ts, th = ss, is = 0, sh = class {
            constructor() {
              this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
            }
            hasPlugin(t) {
              if (typeof t == "string")
                return this.plugins.has(t);
              {
                let [e, s] = t;
                if (!this.hasPlugin(e))
                  return false;
                let r = this.plugins.get(e);
                for (let i of Object.keys(s))
                  if ((r == null ? void 0 : r[i]) !== s[i])
                    return false;
                return true;
              }
            }
            getPluginOption(t, e) {
              var s;
              return (s = this.plugins.get(t)) == null ? void 0 : s[e];
            }
          };
          function br(t, e) {
            t.trailingComments === void 0 ? t.trailingComments = e : t.trailingComments.unshift(...e);
          }
          function rh(t, e) {
            t.leadingComments === void 0 ? t.leadingComments = e : t.leadingComments.unshift(...e);
          }
          function Ge(t, e) {
            t.innerComments === void 0 ? t.innerComments = e : t.innerComments.unshift(...e);
          }
          function Xe(t, e, s) {
            let r = null, i = e.length;
            for (; r === null && i > 0; )
              r = e[--i];
            r === null || r.start > s.start ? Ge(t, s.comments) : br(r, s.comments);
          }
          var ih = class extends sh {
            addComment(t) {
              this.filename && (t.loc.filename = this.filename), this.state.comments.push(t);
            }
            processComment(t) {
              let { commentStack: e } = this.state, s = e.length;
              if (s === 0)
                return;
              let r = s - 1, i = e[r];
              i.start === t.end && (i.leadingNode = t, r--);
              let { start: a } = t;
              for (; r >= 0; r--) {
                let n = e[r], o = n.end;
                if (o > a)
                  n.containingNode = t, this.finalizeComment(n), e.splice(r, 1);
                else {
                  o === a && (n.trailingNode = t);
                  break;
                }
              }
            }
            finalizeComment(t) {
              let { comments: e } = t;
              if (t.leadingNode !== null || t.trailingNode !== null)
                t.leadingNode !== null && br(t.leadingNode, e), t.trailingNode !== null && rh(t.trailingNode, e);
              else {
                let { containingNode: s, start: r } = t;
                if (this.input.charCodeAt(r - 1) === 44)
                  switch (s.type) {
                    case "ObjectExpression":
                    case "ObjectPattern":
                    case "RecordExpression":
                      Xe(s, s.properties, t);
                      break;
                    case "CallExpression":
                    case "OptionalCallExpression":
                      Xe(s, s.arguments, t);
                      break;
                    case "FunctionDeclaration":
                    case "FunctionExpression":
                    case "ArrowFunctionExpression":
                    case "ObjectMethod":
                    case "ClassMethod":
                    case "ClassPrivateMethod":
                      Xe(s, s.params, t);
                      break;
                    case "ArrayExpression":
                    case "ArrayPattern":
                    case "TupleExpression":
                      Xe(s, s.elements, t);
                      break;
                    case "ExportNamedDeclaration":
                    case "ImportDeclaration":
                      Xe(s, s.specifiers, t);
                      break;
                    default:
                      Ge(s, e);
                  }
                else
                  Ge(s, e);
              }
            }
            finalizeRemainingComments() {
              let { commentStack: t } = this.state;
              for (let e = t.length - 1; e >= 0; e--)
                this.finalizeComment(t[e]);
              this.state.commentStack = [];
            }
            resetPreviousNodeTrailingComments(t) {
              let { commentStack: e } = this.state, { length: s } = e;
              if (s === 0)
                return;
              let r = e[s - 1];
              r.leadingNode === t && (r.leadingNode = null);
            }
            takeSurroundingComments(t, e, s) {
              let { commentStack: r } = this.state, i = r.length;
              if (i === 0)
                return;
              let a = i - 1;
              for (; a >= 0; a--) {
                let n = r[a], o = n.end;
                if (n.start === s)
                  n.leadingNode = t;
                else if (o === e)
                  n.trailingNode = t;
                else if (o < e)
                  break;
              }
            }
          }, as = /\r\n?|[\n\u2028\u2029]/, dt = new RegExp(as.source, "g");
          function Ne(t) {
            switch (t) {
              case 10:
              case 13:
              case 8232:
              case 8233:
                return true;
              default:
                return false;
            }
          }
          var ns = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ah = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/y, vr = new RegExp("(?=(" + ah.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
          function nh(t) {
            switch (t) {
              case 9:
              case 11:
              case 12:
              case 32:
              case 160:
              case 5760:
              case 8192:
              case 8193:
              case 8194:
              case 8195:
              case 8196:
              case 8197:
              case 8198:
              case 8199:
              case 8200:
              case 8201:
              case 8202:
              case 8239:
              case 8287:
              case 12288:
              case 65279:
                return true;
              default:
                return false;
            }
          }
          var Sr = class {
            constructor() {
              this.strict = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inType = false, this.noAnonFunctionType = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.inDisallowConditionalTypesContext = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.commentStack = [], this.pos = 0, this.type = 135, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.context = [z.brace], this.canStartJSXElement = true, this.containsEsc = false, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
            }
            init(t) {
              let { strictMode: e, sourceType: s, startLine: r, startColumn: i } = t;
              this.strict = e === false ? false : e === true ? true : s === "module", this.curLine = r, this.lineStart = -i, this.startLoc = this.endLoc = new p2(r, i, 0);
            }
            curPosition() {
              return new p2(this.curLine, this.pos - this.lineStart, this.pos);
            }
            clone(t) {
              let e = new Sr(), s = Object.keys(this);
              for (let r = 0, i = s.length; r < i; r++) {
                let a = s[r], n = this[a];
                !t && Array.isArray(n) && (n = n.slice()), e[a] = n;
              }
              return e;
            }
          }, oh = ["at"], hh = ["at"], lh = function(e) {
            return e >= 48 && e <= 57;
          }, uh = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), wr = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, mt = { bin: (t) => t === 48 || t === 49, oct: (t) => t >= 48 && t <= 55, dec: (t) => t >= 48 && t <= 57, hex: (t) => t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102 }, Ee = class {
            constructor(t) {
              this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new d(t.startLoc, t.endLoc);
            }
          }, ch = class extends ih {
            constructor(t, e) {
              super(), this.isLookahead = void 0, this.tokens = [], this.state = new Sr(), this.state.init(t), this.input = e, this.length = e.length, this.isLookahead = false;
            }
            pushToken(t) {
              this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
            }
            next() {
              this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Ee(this.state)), this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
            }
            eat(t) {
              return this.match(t) ? (this.next(), true) : false;
            }
            match(t) {
              return this.state.type === t;
            }
            createLookaheadState(t) {
              return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
            }
            lookahead() {
              let t = this.state;
              this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
              let e = this.state;
              return this.state = t, e;
            }
            nextTokenStart() {
              return this.nextTokenStartSince(this.state.pos);
            }
            nextTokenStartSince(t) {
              return ns.lastIndex = t, ns.test(this.input) ? ns.lastIndex : t;
            }
            lookaheadCharCode() {
              return this.input.charCodeAt(this.nextTokenStart());
            }
            codePointAtPos(t) {
              let e = this.input.charCodeAt(t);
              if ((e & 64512) === 55296 && ++t < this.input.length) {
                let s = this.input.charCodeAt(t);
                (s & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s & 1023));
              }
              return e;
            }
            setStrict(t) {
              this.state.strict = t, t && (this.state.strictErrors.forEach((e) => {
                let [s, r] = e;
                return this.raise(s, { at: r });
              }), this.state.strictErrors.clear());
            }
            curContext() {
              return this.state.context[this.state.context.length - 1];
            }
            nextToken() {
              if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
                this.finishToken(135);
                return;
              }
              this.getTokenFromCode(this.codePointAtPos(this.state.pos));
            }
            skipBlockComment() {
              let t;
              this.isLookahead || (t = this.state.curPosition());
              let e = this.state.pos, s = this.input.indexOf("*/", e + 2);
              if (s === -1)
                throw this.raise(u.UnterminatedComment, { at: this.state.curPosition() });
              for (this.state.pos = s + 2, dt.lastIndex = e + 2; dt.test(this.input) && dt.lastIndex <= s; )
                ++this.state.curLine, this.state.lineStart = dt.lastIndex;
              if (this.isLookahead)
                return;
              let r = { type: "CommentBlock", value: this.input.slice(e + 2, s), start: e, end: s + 2, loc: new d(t, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(r), r;
            }
            skipLineComment(t) {
              let e = this.state.pos, s;
              this.isLookahead || (s = this.state.curPosition());
              let r = this.input.charCodeAt(this.state.pos += t);
              if (this.state.pos < this.length)
                for (; !Ne(r) && ++this.state.pos < this.length; )
                  r = this.input.charCodeAt(this.state.pos);
              if (this.isLookahead)
                return;
              let i = this.state.pos, a = this.input.slice(e + t, i), n = { type: "CommentLine", value: a, start: e, end: i, loc: new d(s, this.state.curPosition()) };
              return this.options.tokens && this.pushToken(n), n;
            }
            skipSpace() {
              let t = this.state.pos, e = [];
              e:
                for (; this.state.pos < this.length; ) {
                  let s = this.input.charCodeAt(this.state.pos);
                  switch (s) {
                    case 32:
                    case 160:
                    case 9:
                      ++this.state.pos;
                      break;
                    case 13:
                      this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                    case 10:
                    case 8232:
                    case 8233:
                      ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                      break;
                    case 47:
                      switch (this.input.charCodeAt(this.state.pos + 1)) {
                        case 42: {
                          let r = this.skipBlockComment();
                          r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                          break;
                        }
                        case 47: {
                          let r = this.skipLineComment(2);
                          r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                          break;
                        }
                        default:
                          break e;
                      }
                      break;
                    default:
                      if (nh(s))
                        ++this.state.pos;
                      else if (s === 45 && !this.inModule) {
                        let r = this.state.pos;
                        if (this.input.charCodeAt(r + 1) === 45 && this.input.charCodeAt(r + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                          let i = this.skipLineComment(3);
                          i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                        } else
                          break e;
                      } else if (s === 60 && !this.inModule) {
                        let r = this.state.pos;
                        if (this.input.charCodeAt(r + 1) === 33 && this.input.charCodeAt(r + 2) === 45 && this.input.charCodeAt(r + 3) === 45) {
                          let i = this.skipLineComment(4);
                          i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                        } else
                          break e;
                      } else
                        break e;
                  }
                }
              if (e.length > 0) {
                let s = this.state.pos, r = { start: t, end: s, comments: e, leadingNode: null, trailingNode: null, containingNode: null };
                this.state.commentStack.push(r);
              }
            }
            finishToken(t, e) {
              this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
              let s = this.state.type;
              this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);
            }
            replaceToken(t) {
              this.state.type = t, this.updateContext();
            }
            readToken_numberSign() {
              if (this.state.pos === 0 && this.readToken_interpreter())
                return;
              let t = this.state.pos + 1, e = this.codePointAtPos(t);
              if (e >= 48 && e <= 57)
                throw this.raise(u.UnexpectedDigitAfterHash, { at: this.state.curPosition() });
              if (e === 123 || e === 91 && this.hasPlugin("recordAndTuple")) {
                if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
                  throw this.raise(e === 123 ? u.RecordExpressionHashIncorrectStartSyntaxType : u.TupleExpressionHashIncorrectStartSyntaxType, { at: this.state.curPosition() });
                this.state.pos += 2, e === 123 ? this.finishToken(7) : this.finishToken(1);
              } else
                de(e) ? (++this.state.pos, this.finishToken(134, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(134, this.readWord1())) : this.finishOp(27, 1);
            }
            readToken_dot() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t >= 48 && t <= 57) {
                this.readNumber(true);
                return;
              }
              t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
            }
            readToken_slash() {
              this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
            }
            readToken_interpreter() {
              if (this.state.pos !== 0 || this.length < 2)
                return false;
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t !== 33)
                return false;
              let e = this.state.pos;
              for (this.state.pos += 1; !Ne(t) && ++this.state.pos < this.length; )
                t = this.input.charCodeAt(this.state.pos);
              let s = this.input.slice(e + 2, this.state.pos);
              return this.finishToken(28, s), true;
            }
            readToken_mult_modulo(t) {
              let e = t === 42 ? 55 : 54, s = 1, r = this.input.charCodeAt(this.state.pos + 1);
              t === 42 && r === 42 && (s++, r = this.input.charCodeAt(this.state.pos + 2), e = 57), r === 61 && !this.state.inType && (s++, e = t === 37 ? 33 : 30), this.finishOp(e, s);
            }
            readToken_pipe_amp(t) {
              let e = this.input.charCodeAt(this.state.pos + 1);
              if (e === t) {
                this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
                return;
              }
              if (t === 124) {
                if (e === 62) {
                  this.finishOp(39, 2);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && e === 125) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(u.RecordExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(9);
                  return;
                }
                if (this.hasPlugin("recordAndTuple") && e === 93) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                    throw this.raise(u.TupleExpressionBarIncorrectEndSyntaxType, { at: this.state.curPosition() });
                  this.state.pos += 2, this.finishToken(4);
                  return;
                }
              }
              if (e === 61) {
                this.finishOp(30, 2);
                return;
              }
              this.finishOp(t === 124 ? 43 : 45, 1);
            }
            readToken_caret() {
              let t = this.input.charCodeAt(this.state.pos + 1);
              if (t === 61 && !this.state.inType)
                this.finishOp(32, 2);
              else if (t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }])) {
                if (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94)
                  throw this.unexpected();
              } else
                this.finishOp(44, 1);
            }
            readToken_atSign() {
              this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
            }
            readToken_plus_min(t) {
              let e = this.input.charCodeAt(this.state.pos + 1);
              if (e === t) {
                this.finishOp(34, 2);
                return;
              }
              e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
            }
            readToken_lt() {
              let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
              if (e === 60) {
                if (this.input.charCodeAt(t + 2) === 61) {
                  this.finishOp(30, 3);
                  return;
                }
                this.finishOp(51, 2);
                return;
              }
              if (e === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(47, 1);
            }
            readToken_gt() {
              let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
              if (e === 62) {
                let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
                if (this.input.charCodeAt(t + s) === 61) {
                  this.finishOp(30, s + 1);
                  return;
                }
                this.finishOp(52, s);
                return;
              }
              if (e === 61) {
                this.finishOp(49, 2);
                return;
              }
              this.finishOp(48, 1);
            }
            readToken_eq_excl(t) {
              let e = this.input.charCodeAt(this.state.pos + 1);
              if (e === 61) {
                this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
                return;
              }
              if (t === 61 && e === 62) {
                this.state.pos += 2, this.finishToken(19);
                return;
              }
              this.finishOp(t === 61 ? 29 : 35, 1);
            }
            readToken_question() {
              let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
              t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
            }
            getTokenFromCode(t) {
              switch (t) {
                case 46:
                  this.readToken_dot();
                  return;
                case 40:
                  ++this.state.pos, this.finishToken(10);
                  return;
                case 41:
                  ++this.state.pos, this.finishToken(11);
                  return;
                case 59:
                  ++this.state.pos, this.finishToken(13);
                  return;
                case 44:
                  ++this.state.pos, this.finishToken(12);
                  return;
                case 91:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(u.TupleExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(2);
                  } else
                    ++this.state.pos, this.finishToken(0);
                  return;
                case 93:
                  ++this.state.pos, this.finishToken(3);
                  return;
                case 123:
                  if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                    if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                      throw this.raise(u.RecordExpressionBarIncorrectStartSyntaxType, { at: this.state.curPosition() });
                    this.state.pos += 2, this.finishToken(6);
                  } else
                    ++this.state.pos, this.finishToken(5);
                  return;
                case 125:
                  ++this.state.pos, this.finishToken(8);
                  return;
                case 58:
                  this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                  return;
                case 63:
                  this.readToken_question();
                  return;
                case 96:
                  this.readTemplateToken();
                  return;
                case 48: {
                  let e = this.input.charCodeAt(this.state.pos + 1);
                  if (e === 120 || e === 88) {
                    this.readRadixNumber(16);
                    return;
                  }
                  if (e === 111 || e === 79) {
                    this.readRadixNumber(8);
                    return;
                  }
                  if (e === 98 || e === 66) {
                    this.readRadixNumber(2);
                    return;
                  }
                }
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  this.readNumber(false);
                  return;
                case 34:
                case 39:
                  this.readString(t);
                  return;
                case 47:
                  this.readToken_slash();
                  return;
                case 37:
                case 42:
                  this.readToken_mult_modulo(t);
                  return;
                case 124:
                case 38:
                  this.readToken_pipe_amp(t);
                  return;
                case 94:
                  this.readToken_caret();
                  return;
                case 43:
                case 45:
                  this.readToken_plus_min(t);
                  return;
                case 60:
                  this.readToken_lt();
                  return;
                case 62:
                  this.readToken_gt();
                  return;
                case 61:
                case 33:
                  this.readToken_eq_excl(t);
                  return;
                case 126:
                  this.finishOp(36, 1);
                  return;
                case 64:
                  this.readToken_atSign();
                  return;
                case 35:
                  this.readToken_numberSign();
                  return;
                case 92:
                  this.readWord();
                  return;
                default:
                  if (de(t)) {
                    this.readWord(t);
                    return;
                  }
              }
              throw this.raise(u.InvalidOrUnexpectedToken, { at: this.state.curPosition(), unexpected: String.fromCodePoint(t) });
            }
            finishOp(t, e) {
              let s = this.input.slice(this.state.pos, this.state.pos + e);
              this.state.pos += e, this.finishToken(t, s);
            }
            readRegexp() {
              let t = this.state.startLoc, e = this.state.start + 1, s, r, { pos: i } = this.state;
              for (; ; ++i) {
                if (i >= this.length)
                  throw this.raise(u.UnterminatedRegExp, { at: m2(t, 1) });
                let c = this.input.charCodeAt(i);
                if (Ne(c))
                  throw this.raise(u.UnterminatedRegExp, { at: m2(t, 1) });
                if (s)
                  s = false;
                else {
                  if (c === 91)
                    r = true;
                  else if (c === 93 && r)
                    r = false;
                  else if (c === 47 && !r)
                    break;
                  s = c === 92;
                }
              }
              let a = this.input.slice(e, i);
              ++i;
              let n = "", o = () => m2(t, i + 2 - e);
              for (; i < this.length; ) {
                let c = this.codePointAtPos(i), f = String.fromCharCode(c);
                if (uh.has(c))
                  c === 118 ? (this.expectPlugin("regexpUnicodeSets", o()), n.includes("u") && this.raise(u.IncompatibleRegExpUVFlags, { at: o() })) : c === 117 && n.includes("v") && this.raise(u.IncompatibleRegExpUVFlags, { at: o() }), n.includes(f) && this.raise(u.DuplicateRegExpFlags, { at: o() });
                else if (Be(c) || c === 92)
                  this.raise(u.MalformedRegExpFlags, { at: o() });
                else
                  break;
                ++i, n += f;
              }
              this.state.pos = i, this.finishToken(133, { pattern: a, flags: n });
            }
            readInt(t, e, s) {
              let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = this.state.pos, a = t === 16 ? wr.hex : wr.decBinOct, n = t === 16 ? mt.hex : t === 10 ? mt.dec : t === 8 ? mt.oct : mt.bin, o = false, c = 0;
              for (let f = 0, y = e == null ? 1 / 0 : e; f < y; ++f) {
                let P = this.input.charCodeAt(this.state.pos), v;
                if (P === 95 && r !== "bail") {
                  let N = this.input.charCodeAt(this.state.pos - 1), B = this.input.charCodeAt(this.state.pos + 1);
                  r ? (Number.isNaN(B) || !n(B) || a.has(N) || a.has(B)) && this.raise(u.UnexpectedNumericSeparator, { at: this.state.curPosition() }) : this.raise(u.NumericSeparatorInEscapeSequence, { at: this.state.curPosition() }), ++this.state.pos;
                  continue;
                }
                if (P >= 97 ? v = P - 97 + 10 : P >= 65 ? v = P - 65 + 10 : lh(P) ? v = P - 48 : v = 1 / 0, v >= t)
                  if (this.options.errorRecovery && v <= 9)
                    v = 0, this.raise(u.InvalidDigit, { at: this.state.curPosition(), radix: t });
                  else if (s)
                    v = 0, o = true;
                  else
                    break;
                ++this.state.pos, c = c * t + v;
              }
              return this.state.pos === i || e != null && this.state.pos - i !== e || o ? null : c;
            }
            readRadixNumber(t) {
              let e = this.state.curPosition(), s = false;
              this.state.pos += 2;
              let r = this.readInt(t);
              r == null && this.raise(u.InvalidDigit, { at: m2(e, 2), radix: t });
              let i = this.input.charCodeAt(this.state.pos);
              if (i === 110)
                ++this.state.pos, s = true;
              else if (i === 109)
                throw this.raise(u.InvalidDecimal, { at: e });
              if (de(this.codePointAtPos(this.state.pos)))
                throw this.raise(u.NumberIdentifier, { at: this.state.curPosition() });
              if (s) {
                let a = this.input.slice(e.index, this.state.pos).replace(/[_n]/g, "");
                this.finishToken(131, a);
                return;
              }
              this.finishToken(130, r);
            }
            readNumber(t) {
              let e = this.state.pos, s = this.state.curPosition(), r = false, i = false, a = false, n = false, o = false;
              !t && this.readInt(10) === null && this.raise(u.InvalidNumber, { at: this.state.curPosition() });
              let c = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
              if (c) {
                let v = this.input.slice(e, this.state.pos);
                if (this.recordStrictModeErrors(u.StrictOctalLiteral, { at: s }), !this.state.strict) {
                  let N = v.indexOf("_");
                  N > 0 && this.raise(u.ZeroDigitNumericSeparator, { at: m2(s, N) });
                }
                o = c && !/[89]/.test(v);
              }
              let f = this.input.charCodeAt(this.state.pos);
              if (f === 46 && !o && (++this.state.pos, this.readInt(10), r = true, f = this.input.charCodeAt(this.state.pos)), (f === 69 || f === 101) && !o && (f = this.input.charCodeAt(++this.state.pos), (f === 43 || f === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(u.InvalidOrMissingExponent, { at: s }), r = true, n = true, f = this.input.charCodeAt(this.state.pos)), f === 110 && ((r || c) && this.raise(u.InvalidBigIntLiteral, { at: s }), ++this.state.pos, i = true), f === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (n || c) && this.raise(u.InvalidDecimal, { at: s }), ++this.state.pos, a = true), de(this.codePointAtPos(this.state.pos)))
                throw this.raise(u.NumberIdentifier, { at: this.state.curPosition() });
              let y = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
              if (i) {
                this.finishToken(131, y);
                return;
              }
              if (a) {
                this.finishToken(132, y);
                return;
              }
              let P = o ? parseInt(y, 8) : parseFloat(y);
              this.finishToken(130, P);
            }
            readCodePoint(t) {
              let e = this.input.charCodeAt(this.state.pos), s;
              if (e === 123) {
                if (++this.state.pos, s = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, t), ++this.state.pos, s !== null && s > 1114111)
                  if (t)
                    this.raise(u.InvalidCodePoint, { at: this.state.curPosition() });
                  else
                    return null;
              } else
                s = this.readHexChar(4, false, t);
              return s;
            }
            readString(t) {
              let e = "", s = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(u.UnterminatedString, { at: this.state.startLoc });
                let r = this.input.charCodeAt(this.state.pos);
                if (r === t)
                  break;
                if (r === 92)
                  e += this.input.slice(s, this.state.pos), e += this.readEscapedChar(false), s = this.state.pos;
                else if (r === 8232 || r === 8233)
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                else {
                  if (Ne(r))
                    throw this.raise(u.UnterminatedString, { at: this.state.startLoc });
                  ++this.state.pos;
                }
              }
              e += this.input.slice(s, this.state.pos++), this.finishToken(129, e);
            }
            readTemplateContinuation() {
              this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
            }
            readTemplateToken() {
              let t = "", e = this.state.pos, s = false;
              for (++this.state.pos; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(u.UnterminatedTemplate, { at: m2(this.state.startLoc, 1) });
                let r = this.input.charCodeAt(this.state.pos);
                if (r === 96) {
                  ++this.state.pos, t += this.input.slice(e, this.state.pos), this.finishToken(24, s ? null : t);
                  return;
                }
                if (r === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
                  this.state.pos += 2, t += this.input.slice(e, this.state.pos), this.finishToken(25, s ? null : t);
                  return;
                }
                if (r === 92) {
                  t += this.input.slice(e, this.state.pos);
                  let i = this.readEscapedChar(true);
                  i === null ? s = true : t += i, e = this.state.pos;
                } else if (Ne(r)) {
                  switch (t += this.input.slice(e, this.state.pos), ++this.state.pos, r) {
                    case 13:
                      this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                    case 10:
                      t += `
`;
                      break;
                    default:
                      t += String.fromCharCode(r);
                      break;
                  }
                  ++this.state.curLine, this.state.lineStart = this.state.pos, e = this.state.pos;
                } else
                  ++this.state.pos;
              }
            }
            recordStrictModeErrors(t, e) {
              let { at: s } = e, r = s.index;
              this.state.strict && !this.state.strictErrors.has(r) ? this.raise(t, { at: s }) : this.state.strictErrors.set(r, [t, s]);
            }
            readEscapedChar(t) {
              let e = !t, s = this.input.charCodeAt(++this.state.pos);
              switch (++this.state.pos, s) {
                case 110:
                  return `
`;
                case 114:
                  return "\r";
                case 120: {
                  let r = this.readHexChar(2, false, e);
                  return r === null ? null : String.fromCharCode(r);
                }
                case 117: {
                  let r = this.readCodePoint(e);
                  return r === null ? null : String.fromCodePoint(r);
                }
                case 116:
                  return "	";
                case 98:
                  return "\b";
                case 118:
                  return "\v";
                case 102:
                  return "\f";
                case 13:
                  this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                case 10:
                  this.state.lineStart = this.state.pos, ++this.state.curLine;
                case 8232:
                case 8233:
                  return "";
                case 56:
                case 57:
                  if (t)
                    return null;
                  this.recordStrictModeErrors(u.StrictNumericEscape, { at: m2(this.state.curPosition(), -1) });
                default:
                  if (s >= 48 && s <= 55) {
                    let r = m2(this.state.curPosition(), -1), a = this.input.slice(this.state.pos - 1, this.state.pos + 2).match(/^[0-7]+/)[0], n = parseInt(a, 8);
                    n > 255 && (a = a.slice(0, -1), n = parseInt(a, 8)), this.state.pos += a.length - 1;
                    let o = this.input.charCodeAt(this.state.pos);
                    if (a !== "0" || o === 56 || o === 57) {
                      if (t)
                        return null;
                      this.recordStrictModeErrors(u.StrictNumericEscape, { at: r });
                    }
                    return String.fromCharCode(n);
                  }
                  return String.fromCharCode(s);
              }
            }
            readHexChar(t, e, s) {
              let r = this.state.curPosition(), i = this.readInt(16, t, e, false);
              return i === null && (s ? this.raise(u.InvalidEscapeSequence, { at: r }) : this.state.pos = r.index - 1), i;
            }
            readWord1(t) {
              this.state.containsEsc = false;
              let e = "", s = this.state.pos, r = this.state.pos;
              for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                let i = this.codePointAtPos(this.state.pos);
                if (Be(i))
                  this.state.pos += i <= 65535 ? 1 : 2;
                else if (i === 92) {
                  this.state.containsEsc = true, e += this.input.slice(r, this.state.pos);
                  let a = this.state.curPosition(), n = this.state.pos === s ? de : Be;
                  if (this.input.charCodeAt(++this.state.pos) !== 117) {
                    this.raise(u.MissingUnicodeEscape, { at: this.state.curPosition() }), r = this.state.pos - 1;
                    continue;
                  }
                  ++this.state.pos;
                  let o = this.readCodePoint(true);
                  o !== null && (n(o) || this.raise(u.EscapedCharNotAnIdentifier, { at: a }), e += String.fromCodePoint(o)), r = this.state.pos;
                } else
                  break;
              }
              return e + this.input.slice(r, this.state.pos);
            }
            readWord(t) {
              let e = this.readWord1(t), s = qt.get(e);
              s !== void 0 ? this.finishToken(s, Pe(s)) : this.finishToken(128, e);
            }
            checkKeywordEscapes() {
              let { type: t } = this.state;
              Ht(t) && this.state.containsEsc && this.raise(u.InvalidEscapedReservedWord, { at: this.state.startLoc, reservedWord: Pe(t) });
            }
            raise(t, e) {
              let { at: s } = e, r = l(e, oh), i = s instanceof p2 ? s : s.loc.start, a = t({ loc: i, details: r });
              if (!this.options.errorRecovery)
                throw a;
              return this.isLookahead || this.state.errors.push(a), a;
            }
            raiseOverwrite(t, e) {
              let { at: s } = e, r = l(e, hh), i = s instanceof p2 ? s : s.loc.start, a = i.index, n = this.state.errors;
              for (let o = n.length - 1; o >= 0; o--) {
                let c = n[o];
                if (c.loc.index === a)
                  return n[o] = t({ loc: i, details: r });
                if (c.loc.index < a)
                  break;
              }
              return this.raise(t, e);
            }
            updateContext(t) {
            }
            unexpected(t, e) {
              throw this.raise(u.UnexpectedToken, { expected: e ? Pe(e) : null, at: t != null ? t : this.state.startLoc });
            }
            expectPlugin(t, e) {
              if (this.hasPlugin(t))
                return true;
              throw this.raise(u.MissingPlugin, { at: e != null ? e : this.state.startLoc, missingPlugin: [t] });
            }
            expectOnePlugin(t) {
              if (!t.some((e) => this.hasPlugin(e)))
                throw this.raise(u.MissingOneOfPlugins, { at: this.state.startLoc, missingPlugin: t });
            }
          }, os = class {
            constructor(t) {
              this.var = /* @__PURE__ */ new Set(), this.lexical = /* @__PURE__ */ new Set(), this.functions = /* @__PURE__ */ new Set(), this.flags = t;
            }
          }, hs = class {
            constructor(t, e) {
              this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = e;
            }
            get inFunction() {
              return (this.currentVarScopeFlags() & me) > 0;
            }
            get allowSuper() {
              return (this.currentThisScopeFlags() & ot) > 0;
            }
            get allowDirectSuper() {
              return (this.currentThisScopeFlags() & xr) > 0;
            }
            get inClass() {
              return (this.currentThisScopeFlags() & Se) > 0;
            }
            get inClassAndNotInNonArrowFunction() {
              let t = this.currentThisScopeFlags();
              return (t & Se) > 0 && (t & me) === 0;
            }
            get inStaticBlock() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: e } = this.scopeStack[t];
                if (e & Yt)
                  return true;
                if (e & (lt | Se))
                  return false;
              }
            }
            get inNonArrowFunction() {
              return (this.currentThisScopeFlags() & me) > 0;
            }
            get treatFunctionsAsVar() {
              return this.treatFunctionsAsVarInScope(this.currentScope());
            }
            createScope(t) {
              return new os(t);
            }
            enter(t) {
              this.scopeStack.push(this.createScope(t));
            }
            exit() {
              this.scopeStack.pop();
            }
            treatFunctionsAsVarInScope(t) {
              return !!(t.flags & (me | Yt) || !this.parser.inModule && t.flags & We);
            }
            declareName(t, e, s) {
              let r = this.currentScope();
              if (e & Te || e & ut)
                this.checkRedeclarationInScope(r, t, e, s), e & ut ? r.functions.add(t) : r.lexical.add(t), e & Te && this.maybeExportDefined(r, t);
              else if (e & gr)
                for (let i = this.scopeStack.length - 1; i >= 0 && (r = this.scopeStack[i], this.checkRedeclarationInScope(r, t, e, s), r.var.add(t), this.maybeExportDefined(r, t), !(r.flags & lt)); --i)
                  ;
              this.parser.inModule && r.flags & We && this.undefinedExports.delete(t);
            }
            maybeExportDefined(t, e) {
              this.parser.inModule && t.flags & We && this.undefinedExports.delete(e);
            }
            checkRedeclarationInScope(t, e, s, r) {
              this.isRedeclaredInScope(t, e, s) && this.parser.raise(u.VarRedeclaration, { at: r, identifierName: e });
            }
            isRedeclaredInScope(t, e, s) {
              return s & ye ? s & Te ? t.lexical.has(e) || t.functions.has(e) || t.var.has(e) : s & ut ? t.lexical.has(e) || !this.treatFunctionsAsVarInScope(t) && t.var.has(e) : t.lexical.has(e) && !(t.flags & yr && t.lexical.values().next().value === e) || !this.treatFunctionsAsVarInScope(t) && t.functions.has(e) : false;
            }
            checkLocalExport(t) {
              let { name: e } = t, s = this.scopeStack[0];
              !s.lexical.has(e) && !s.var.has(e) && !s.functions.has(e) && this.undefinedExports.set(e, t.loc.start);
            }
            currentScope() {
              return this.scopeStack[this.scopeStack.length - 1];
            }
            currentVarScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: e } = this.scopeStack[t];
                if (e & lt)
                  return e;
              }
            }
            currentThisScopeFlags() {
              for (let t = this.scopeStack.length - 1; ; t--) {
                let { flags: e } = this.scopeStack[t];
                if (e & (lt | Se) && !(e & Jt))
                  return e;
              }
            }
          }, ph = class extends os {
            constructor() {
              super(...arguments), this.declareFunctions = /* @__PURE__ */ new Set();
            }
          }, fh = class extends hs {
            createScope(t) {
              return new ph(t);
            }
            declareName(t, e, s) {
              let r = this.currentScope();
              if (e & es) {
                this.checkRedeclarationInScope(r, t, e, s), this.maybeExportDefined(r, t), r.declareFunctions.add(t);
                return;
              }
              super.declareName(...arguments);
            }
            isRedeclaredInScope(t, e, s) {
              return super.isRedeclaredInScope(...arguments) ? true : s & es ? !t.declareFunctions.has(e) && (t.lexical.has(e) || t.functions.has(e)) : false;
            }
            checkLocalExport(t) {
              this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
            }
          }, dh = class {
            constructor() {
              this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
            }
          }, mh = class {
            constructor(t) {
              this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
            }
            current() {
              return this.stack[this.stack.length - 1];
            }
            enter() {
              this.stack.push(new dh());
            }
            exit() {
              let t = this.stack.pop(), e = this.current();
              for (let [s, r] of Array.from(t.undefinedPrivateNames))
                e ? e.undefinedPrivateNames.has(s) || e.undefinedPrivateNames.set(s, r) : this.parser.raise(u.InvalidPrivateFieldResolution, { at: r, identifierName: s });
            }
            declarePrivateName(t, e, s) {
              let { privateNames: r, loneAccessors: i, undefinedPrivateNames: a } = this.current(), n = r.has(t);
              if (e & rs) {
                let o = n && i.get(t);
                if (o) {
                  let c = o & ft, f = e & ft, y = o & rs, P = e & rs;
                  n = y === P || c !== f, n || i.delete(t);
                } else
                  n || i.set(t, e);
              }
              n && this.parser.raise(u.PrivateNameRedeclaration, { at: s, identifierName: t }), r.add(t), a.delete(t);
            }
            usePrivateName(t, e) {
              let s;
              for (s of this.stack)
                if (s.privateNames.has(t))
                  return;
              s ? s.undefinedPrivateNames.set(t, e) : this.parser.raise(u.InvalidPrivateFieldResolution, { at: e, identifierName: t });
            }
          }, yh = 0, Nr = 1, ls = 2, Ir = 3, yt = class {
            constructor() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yh;
              this.type = void 0, this.type = t;
            }
            canBeArrowParameterDeclaration() {
              return this.type === ls || this.type === Nr;
            }
            isCertainlyParameterDeclaration() {
              return this.type === Ir;
            }
          }, kr = class extends yt {
            constructor(t) {
              super(t), this.declarationErrors = /* @__PURE__ */ new Map();
            }
            recordDeclarationError(t, e) {
              let { at: s } = e, r = s.index;
              this.declarationErrors.set(r, [t, s]);
            }
            clearDeclarationError(t) {
              this.declarationErrors.delete(t);
            }
            iterateErrors(t) {
              this.declarationErrors.forEach(t);
            }
          }, xh = class {
            constructor(t) {
              this.parser = void 0, this.stack = [new yt()], this.parser = t;
            }
            enter(t) {
              this.stack.push(t);
            }
            exit() {
              this.stack.pop();
            }
            recordParameterInitializerError(t, e) {
              let { at: s } = e, r = { at: s.loc.start }, { stack: i } = this, a = i.length - 1, n = i[a];
              for (; !n.isCertainlyParameterDeclaration(); ) {
                if (n.canBeArrowParameterDeclaration())
                  n.recordDeclarationError(t, r);
                else
                  return;
                n = i[--a];
              }
              this.parser.raise(t, r);
            }
            recordArrowParemeterBindingError(t, e) {
              let { at: s } = e, { stack: r } = this, i = r[r.length - 1], a = { at: s.loc.start };
              if (i.isCertainlyParameterDeclaration())
                this.parser.raise(t, a);
              else if (i.canBeArrowParameterDeclaration())
                i.recordDeclarationError(t, a);
              else
                return;
            }
            recordAsyncArrowParametersError(t) {
              let { at: e } = t, { stack: s } = this, r = s.length - 1, i = s[r];
              for (; i.canBeArrowParameterDeclaration(); )
                i.type === ls && i.recordDeclarationError(u.AwaitBindingIdentifier, { at: e }), i = s[--r];
            }
            validateAsPattern() {
              let { stack: t } = this, e = t[t.length - 1];
              !e.canBeArrowParameterDeclaration() || e.iterateErrors((s) => {
                let [r, i] = s;
                this.parser.raise(r, { at: i });
                let a = t.length - 2, n = t[a];
                for (; n.canBeArrowParameterDeclaration(); )
                  n.clearDeclarationError(i.index), n = t[--a];
              });
            }
          };
          function gh() {
            return new yt(Ir);
          }
          function Ah() {
            return new kr(Nr);
          }
          function Ph() {
            return new kr(ls);
          }
          function Dr() {
            return new yt();
          }
          var je = 0, Fr = 1, xt = 2, Lr = 4, qe = 8, Th = class {
            constructor() {
              this.stacks = [];
            }
            enter(t) {
              this.stacks.push(t);
            }
            exit() {
              this.stacks.pop();
            }
            currentFlags() {
              return this.stacks[this.stacks.length - 1];
            }
            get hasAwait() {
              return (this.currentFlags() & xt) > 0;
            }
            get hasYield() {
              return (this.currentFlags() & Fr) > 0;
            }
            get hasReturn() {
              return (this.currentFlags() & Lr) > 0;
            }
            get hasIn() {
              return (this.currentFlags() & qe) > 0;
            }
          };
          function gt(t, e) {
            return (t ? xt : 0) | (e ? Fr : 0);
          }
          var Eh = class extends ch {
            addExtra(t, e, s) {
              let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              if (!t)
                return;
              let i = t.extra = t.extra || {};
              r ? i[e] = s : Object.defineProperty(i, e, { enumerable: r, value: s });
            }
            isContextual(t) {
              return this.state.type === t && !this.state.containsEsc;
            }
            isUnparsedContextual(t, e) {
              let s = t + e.length;
              if (this.input.slice(t, s) === e) {
                let r = this.input.charCodeAt(s);
                return !(Be(r) || (r & 64512) === 55296);
              }
              return false;
            }
            isLookaheadContextual(t) {
              let e = this.nextTokenStart();
              return this.isUnparsedContextual(e, t);
            }
            eatContextual(t) {
              return this.isContextual(t) ? (this.next(), true) : false;
            }
            expectContextual(t, e) {
              if (!this.eatContextual(t))
                throw e != null ? this.raise(e, { at: this.state.startLoc }) : this.unexpected(null, t);
            }
            canInsertSemicolon() {
              return this.match(135) || this.match(8) || this.hasPrecedingLineBreak();
            }
            hasPrecedingLineBreak() {
              return as.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
            }
            hasFollowingLineBreak() {
              return vr.lastIndex = this.state.end, vr.test(this.input);
            }
            isLineTerminator() {
              return this.eat(13) || this.canInsertSemicolon();
            }
            semicolon() {
              ((arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true) ? this.isLineTerminator() : this.eat(13)) || this.raise(u.MissingSemicolon, { at: this.state.lastTokEndLoc });
            }
            expect(t, e) {
              this.eat(t) || this.unexpected(e, t);
            }
            tryParse(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.clone(), s = { node: null };
              try {
                let r = t(function() {
                  let i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                  throw s.node = i, s;
                });
                if (this.state.errors.length > e.errors.length) {
                  let i = this.state;
                  return this.state = e, this.state.tokensLength = i.tokensLength, { node: r, error: i.errors[e.errors.length], thrown: false, aborted: false, failState: i };
                }
                return { node: r, error: null, thrown: false, aborted: false, failState: null };
              } catch (r) {
                let i = this.state;
                if (this.state = e, r instanceof SyntaxError)
                  return { node: null, error: r, thrown: true, aborted: false, failState: i };
                if (r === s)
                  return { node: s.node, error: null, thrown: false, aborted: true, failState: i };
                throw r;
              }
            }
            checkExpressionErrors(t, e) {
              if (!t)
                return false;
              let { shorthandAssignLoc: s, doubleProtoLoc: r, privateKeyLoc: i, optionalParametersLoc: a } = t, n = !!s || !!r || !!a || !!i;
              if (!e)
                return n;
              s != null && this.raise(u.InvalidCoverInitializedName, { at: s }), r != null && this.raise(u.DuplicateProto, { at: r }), i != null && this.raise(u.UnexpectedPrivateField, { at: i }), a != null && this.unexpected(a);
            }
            isLiteralPropertyName() {
              return hr(this.state.type);
            }
            isPrivateName(t) {
              return t.type === "PrivateName";
            }
            getPrivateNameSV(t) {
              return t.id.name;
            }
            hasPropertyAsPrivateName(t) {
              return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
            }
            isOptionalChain(t) {
              return t.type === "OptionalMemberExpression" || t.type === "OptionalCallExpression";
            }
            isObjectProperty(t) {
              return t.type === "ObjectProperty";
            }
            isObjectMethod(t) {
              return t.type === "ObjectMethod";
            }
            initializeScopes() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.sourceType === "module", e = this.state.labels;
              this.state.labels = [];
              let s = this.exportedIdentifiers;
              this.exportedIdentifiers = /* @__PURE__ */ new Set();
              let r = this.inModule;
              this.inModule = t;
              let i = this.scope, a = this.getScopeHandler();
              this.scope = new a(this, t);
              let n = this.prodParam;
              this.prodParam = new Th();
              let o = this.classScope;
              this.classScope = new mh(this);
              let c = this.expressionScope;
              return this.expressionScope = new xh(this), () => {
                this.state.labels = e, this.exportedIdentifiers = s, this.inModule = r, this.scope = i, this.prodParam = n, this.classScope = o, this.expressionScope = c;
              };
            }
            enterInitialScopes() {
              let t = je;
              this.inModule && (t |= xt), this.scope.enter(We), this.prodParam.enter(t);
            }
            checkDestructuringPrivate(t) {
              let { privateKeyLoc: e } = t;
              e !== null && this.expectPlugin("destructuringPrivate", e);
            }
          }, At = class {
            constructor() {
              this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
            }
          }, Pt = class {
            constructor(t, e, s) {
              this.type = "", this.start = e, this.end = 0, this.loc = new d(s), t != null && t.options.ranges && (this.range = [e, 0]), t != null && t.filename && (this.loc.filename = t.filename);
            }
          }, us = Pt.prototype;
          us.__clone = function() {
            let t = new Pt(), e = Object.keys(this);
            for (let s = 0, r = e.length; s < r; s++) {
              let i = e[s];
              i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (t[i] = this[i]);
            }
            return t;
          };
          function Ch(t) {
            return ge(t);
          }
          function ge(t) {
            let { type: e, start: s, end: r, loc: i, range: a, extra: n, name: o } = t, c = Object.create(us);
            return c.type = e, c.start = s, c.end = r, c.loc = i, c.range = a, c.extra = n, c.name = o, e === "Placeholder" && (c.expectedNode = t.expectedNode), c;
          }
          function bh(t) {
            let { type: e, start: s, end: r, loc: i, range: a, extra: n } = t;
            if (e === "Placeholder")
              return Ch(t);
            let o = Object.create(us);
            return o.type = e, o.start = s, o.end = r, o.loc = i, o.range = a, t.raw !== void 0 ? o.raw = t.raw : o.extra = n, o.value = t.value, o;
          }
          var vh = class extends Eh {
            startNode() {
              return new Pt(this, this.state.start, this.state.startLoc);
            }
            startNodeAt(t, e) {
              return new Pt(this, t, e);
            }
            startNodeAtNode(t) {
              return this.startNodeAt(t.start, t.loc.start);
            }
            finishNode(t, e) {
              return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
            }
            finishNodeAt(t, e, s) {
              return t.type = e, t.end = s.index, t.loc.end = s, this.options.ranges && (t.range[1] = s.index), this.options.attachComment && this.processComment(t), t;
            }
            resetStartLocation(t, e, s) {
              t.start = e, t.loc.start = s, this.options.ranges && (t.range[0] = e);
            }
            resetEndLocation(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state.lastTokEndLoc;
              t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index);
            }
            resetStartLocationFromNode(t, e) {
              this.resetStartLocation(t, e.start, e.loc.start);
            }
          }, Sh = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), I = j(zn || (zn = rt(["flow"])))((t) => ({ AmbiguousConditionalArrow: t("Ambiguous expression: wrap the arrow functions in parentheses to disambiguate."), AmbiguousDeclareModuleKind: t("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module."), AssignReservedType: t((e) => {
            let { reservedType: s } = e;
            return "Cannot overwrite reserved type ".concat(s, ".");
          }), DeclareClassElement: t("The `declare` modifier can only appear on class fields."), DeclareClassFieldInitializer: t("Initializers are not allowed in fields with the `declare` modifier."), DuplicateDeclareModuleExports: t("Duplicate `declare module.exports` statement."), EnumBooleanMemberNotInitialized: t((e) => {
            let { memberName: s, enumName: r } = e;
            return "Boolean enum members need to be initialized. Use either `".concat(s, " = true,` or `").concat(s, " = false,` in enum `").concat(r, "`.");
          }), EnumDuplicateMemberName: t((e) => {
            let { memberName: s, enumName: r } = e;
            return "Enum member names need to be unique, but the name `".concat(s, "` has already been used before in enum `").concat(r, "`.");
          }), EnumInconsistentMemberValues: t((e) => {
            let { enumName: s } = e;
            return "Enum `".concat(s, "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.");
          }), EnumInvalidExplicitType: t((e) => {
            let { invalidEnumType: s, enumName: r } = e;
            return "Enum type `".concat(s, "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `").concat(r, "`.");
          }), EnumInvalidExplicitTypeUnknownSupplied: t((e) => {
            let { enumName: s } = e;
            return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(s, "`.");
          }), EnumInvalidMemberInitializerPrimaryType: t((e) => {
            let { enumName: s, memberName: r, explicitType: i } = e;
            return "Enum `".concat(s, "` has type `").concat(i, "`, so the initializer of `").concat(r, "` needs to be a ").concat(i, " literal.");
          }), EnumInvalidMemberInitializerSymbolType: t((e) => {
            let { enumName: s, memberName: r } = e;
            return "Symbol enum members cannot be initialized. Use `".concat(r, ",` in enum `").concat(s, "`.");
          }), EnumInvalidMemberInitializerUnknownType: t((e) => {
            let { enumName: s, memberName: r } = e;
            return "The enum member initializer for `".concat(r, "` needs to be a literal (either a boolean, number, or string) in enum `").concat(s, "`.");
          }), EnumInvalidMemberName: t((e) => {
            let { enumName: s, memberName: r, suggestion: i } = e;
            return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `".concat(r, "`, consider using `").concat(i, "`, in enum `").concat(s, "`.");
          }), EnumNumberMemberNotInitialized: t((e) => {
            let { enumName: s, memberName: r } = e;
            return "Number enum members need to be initialized, e.g. `".concat(r, " = 1` in enum `").concat(s, "`.");
          }), EnumStringMemberInconsistentlyInitailized: t((e) => {
            let { enumName: s } = e;
            return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(s, "`.");
          }), GetterMayNotHaveThisParam: t("A getter cannot have a `this` parameter."), ImportTypeShorthandOnlyInPureImport: t("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements."), InexactInsideExact: t("Explicit inexact syntax cannot appear inside an explicit exact object type."), InexactInsideNonObject: t("Explicit inexact syntax cannot appear in class or interface definitions."), InexactVariance: t("Explicit inexact syntax cannot have variance."), InvalidNonTypeImportInDeclareModule: t("Imports within a `declare module` body must always be `import type` or `import typeof`."), MissingTypeParamDefault: t("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."), NestedDeclareModule: t("`declare module` cannot be used inside another `declare module`."), NestedFlowComment: t("Cannot have a flow comment inside another flow comment."), PatternIsOptional: t("A binding pattern parameter cannot be optional in an implementation signature.", { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: t("A setter cannot have a `this` parameter."), SpreadVariance: t("Spread properties cannot have variance."), ThisParamAnnotationRequired: t("A type annotation is required for the `this` parameter."), ThisParamBannedInConstructor: t("Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions."), ThisParamMayNotBeOptional: t("The `this` parameter cannot be optional."), ThisParamMustBeFirst: t("The `this` parameter must be the first function parameter."), ThisParamNoDefault: t("The `this` parameter may not have a default value."), TypeBeforeInitializer: t("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."), TypeCastInPattern: t("The type cast expression is expected to be wrapped with parenthesis."), UnexpectedExplicitInexactInObject: t("Explicit inexact syntax must appear at the end of an inexact object."), UnexpectedReservedType: t((e) => {
            let { reservedType: s } = e;
            return "Unexpected reserved type ".concat(s, ".");
          }), UnexpectedReservedUnderscore: t("`_` is only allowed as a type argument to call or new."), UnexpectedSpaceBetweenModuloChecks: t("Spaces between `%` and `checks` are not allowed here."), UnexpectedSpreadType: t("Spread operator cannot appear in class or interface definitions."), UnexpectedSubtractionOperand: t('Unexpected token, expected "number" or "bigint".'), UnexpectedTokenAfterTypeParameter: t("Expected an arrow function after this type parameter declaration."), UnexpectedTypeParameterBeforeAsyncArrowFunction: t("Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`."), UnsupportedDeclareExportKind: t((e) => {
            let { unsupportedExportKind: s, suggestion: r } = e;
            return "`declare export ".concat(s, "` is not supported. Use `").concat(r, "` instead.");
          }), UnsupportedStatementInDeclareModule: t("Only declares and type imports are allowed inside declare module."), UnterminatedFlowComment: t("Unterminated flow-comment.") }));
          function wh(t) {
            return t.type === "DeclareExportAllDeclaration" || t.type === "DeclareExportDeclaration" && (!t.declaration || t.declaration.type !== "TypeAlias" && t.declaration.type !== "InterfaceDeclaration");
          }
          function cs(t) {
            return t.importKind === "type" || t.importKind === "typeof";
          }
          function Or(t) {
            return pe(t) && t !== 97;
          }
          var Nh = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
          function Ih(t, e) {
            let s = [], r = [];
            for (let i = 0; i < t.length; i++)
              (e(t[i], i, t) ? s : r).push(t[i]);
            return [s, r];
          }
          var kh = /\*?\s*@((?:no)?flow)\b/, Dh = (t) => class extends t {
            constructor() {
              super(...arguments), this.flowPragma = void 0;
            }
            getScopeHandler() {
              return fh;
            }
            shouldParseTypes() {
              return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
            }
            shouldParseEnums() {
              return !!this.getPluginOption("flow", "enums");
            }
            finishToken(e, s) {
              return e !== 129 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
            }
            addComment(e) {
              if (this.flowPragma === void 0) {
                let s = kh.exec(e.value);
                if (s)
                  if (s[1] === "flow")
                    this.flowPragma = "flow";
                  else if (s[1] === "noflow")
                    this.flowPragma = "noflow";
                  else
                    throw new Error("Unexpected flow pragma");
              }
              return super.addComment(e);
            }
            flowParseTypeInitialiser(e) {
              let s = this.state.inType;
              this.state.inType = true, this.expect(e || 14);
              let r = this.flowParseType();
              return this.state.inType = s, r;
            }
            flowParsePredicate() {
              let e = this.startNode(), s = this.state.startLoc;
              return this.next(), this.expectContextual(107), this.state.lastTokStart > s.index + 1 && this.raise(I.UnexpectedSpaceBetweenModuloChecks, { at: s }), this.eat(10) ? (e.value = this.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
            }
            flowParseTypeAndPredicateInitialiser() {
              let e = this.state.inType;
              this.state.inType = true, this.expect(14);
              let s = null, r = null;
              return this.match(54) ? (this.state.inType = e, r = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (r = this.flowParsePredicate())), [s, r];
            }
            flowParseDeclareClass(e) {
              return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
            }
            flowParseDeclareFunction(e) {
              this.next();
              let s = e.id = this.parseIdentifier(), r = this.startNode(), i = this.startNode();
              this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, this.expect(10);
              let a = this.flowParseFunctionTypeParams();
              return r.params = a.params, r.rest = a.rest, r.this = a._this, this.expect(11), [r.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), i.typeAnnotation = this.finishNode(r, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(i, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, $o, e.id.loc.start), this.finishNode(e, "DeclareFunction");
            }
            flowParseDeclare(e, s) {
              if (this.match(80))
                return this.flowParseDeclareClass(e);
              if (this.match(68))
                return this.flowParseDeclareFunction(e);
              if (this.match(74))
                return this.flowParseDeclareVariable(e);
              if (this.eatContextual(123))
                return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(I.NestedDeclareModule, { at: this.state.lastTokStartLoc }), this.flowParseDeclareModule(e));
              if (this.isContextual(126))
                return this.flowParseDeclareTypeAlias(e);
              if (this.isContextual(127))
                return this.flowParseDeclareOpaqueType(e);
              if (this.isContextual(125))
                return this.flowParseDeclareInterface(e);
              if (this.match(82))
                return this.flowParseDeclareExportDeclaration(e, s);
              throw this.unexpected();
            }
            flowParseDeclareVariable(e) {
              return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, pt, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
            }
            flowParseDeclareModule(e) {
              this.scope.enter(Me), this.match(129) ? e.id = this.parseExprAtom() : e.id = this.parseIdentifier();
              let s = e.body = this.startNode(), r = s.body = [];
              for (this.expect(5); !this.match(8); ) {
                let n = this.startNode();
                this.match(83) ? (this.next(), !this.isContextual(126) && !this.match(87) && this.raise(I.InvalidNonTypeImportInDeclareModule, { at: this.state.lastTokStartLoc }), this.parseImport(n)) : (this.expectContextual(121, I.UnsupportedStatementInDeclareModule), n = this.flowParseDeclare(n, true)), r.push(n);
              }
              this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
              let i = null, a = false;
              return r.forEach((n) => {
                wh(n) ? (i === "CommonJS" && this.raise(I.AmbiguousDeclareModuleKind, { at: n }), i = "ES") : n.type === "DeclareModuleExports" && (a && this.raise(I.DuplicateDeclareModuleExports, { at: n }), i === "ES" && this.raise(I.AmbiguousDeclareModuleKind, { at: n }), i = "CommonJS", a = true);
              }), e.kind = i || "CommonJS", this.finishNode(e, "DeclareModule");
            }
            flowParseDeclareExportDeclaration(e, s) {
              if (this.expect(82), this.eat(65))
                return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(75) || this.isLet() || (this.isContextual(126) || this.isContextual(125)) && !s) {
                let r = this.state.value;
                throw this.raise(I.UnsupportedDeclareExportKind, { at: this.state.startLoc, unsupportedExportKind: r, suggestion: Nh[r] });
              }
              if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(127))
                return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
              if (this.match(55) || this.match(5) || this.isContextual(125) || this.isContextual(126) || this.isContextual(127))
                return e = this.parseExport(e), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
              throw this.unexpected();
            }
            flowParseDeclareModuleExports(e) {
              return this.next(), this.expectContextual(108), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
            }
            flowParseDeclareTypeAlias(e) {
              return this.next(), this.flowParseTypeAlias(e), e.type = "DeclareTypeAlias", e;
            }
            flowParseDeclareOpaqueType(e) {
              return this.next(), this.flowParseOpaqueType(e, true), e.type = "DeclareOpaqueType", e;
            }
            flowParseDeclareInterface(e) {
              return this.next(), this.flowParseInterfaceish(e), this.finishNode(e, "DeclareInterface");
            }
            flowParseInterfaceish(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? Tr : xe, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], e.implements = [], e.mixins = [], this.eat(81))
                do
                  e.extends.push(this.flowParseInterfaceExtends());
                while (!s && this.eat(12));
              if (this.isContextual(114)) {
                this.next();
                do
                  e.mixins.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              }
              if (this.isContextual(110)) {
                this.next();
                do
                  e.implements.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              }
              e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
            }
            flowParseInterfaceExtends() {
              let e = this.startNode();
              return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
            }
            flowParseInterface(e) {
              return this.flowParseInterfaceish(e), this.finishNode(e, "InterfaceDeclaration");
            }
            checkNotUnderscore(e) {
              e === "_" && this.raise(I.UnexpectedReservedUnderscore, { at: this.state.startLoc });
            }
            checkReservedType(e, s, r) {
              !Sh.has(e) || this.raise(r ? I.AssignReservedType : I.UnexpectedReservedType, { at: s, reservedType: e });
            }
            flowParseRestrictedIdentifier(e, s) {
              return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
            }
            flowParseTypeAlias(e) {
              return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, xe, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
            }
            flowParseOpaqueType(e, s) {
              return this.expectContextual(126), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, xe, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
            }
            flowParseTypeParameter() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, s = this.state.startLoc, r = this.startNode(), i = this.flowParseVariance(), a = this.flowParseTypeAnnotatableIdentifier();
              return r.name = a.name, r.variance = i, r.bound = a.typeAnnotation, this.match(29) ? (this.eat(29), r.default = this.flowParseType()) : e && this.raise(I.MissingTypeParamDefault, { at: s }), this.finishNode(r, "TypeParameter");
            }
            flowParseTypeParameterDeclaration() {
              let e = this.state.inType, s = this.startNode();
              s.params = [], this.state.inType = true, this.match(47) || this.match(138) ? this.next() : this.unexpected();
              let r = false;
              do {
                let i = this.flowParseTypeParameter(r);
                s.params.push(i), i.default && (r = true), this.match(48) || this.expect(12);
              } while (!this.match(48));
              return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
            }
            flowParseTypeParameterInstantiation() {
              let e = this.startNode(), s = this.state.inType;
              e.params = [], this.state.inType = true, this.expect(47);
              let r = this.state.noAnonFunctionType;
              for (this.state.noAnonFunctionType = false; !this.match(48); )
                e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
              return this.state.noAnonFunctionType = r, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseTypeParameterInstantiationCallOrNew() {
              let e = this.startNode(), s = this.state.inType;
              for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); )
                e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
              return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
            }
            flowParseInterfaceType() {
              let e = this.startNode();
              if (this.expectContextual(125), e.extends = [], this.eat(81))
                do
                  e.extends.push(this.flowParseInterfaceExtends());
                while (this.eat(12));
              return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
            }
            flowParseObjectPropertyKey() {
              return this.match(130) || this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true);
            }
            flowParseObjectTypeIndexer(e, s, r) {
              return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = r, this.finishNode(e, "ObjectTypeIndexer");
            }
            flowParseObjectTypeInternalSlot(e, s) {
              return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
            }
            flowParseObjectTypeMethodish(e) {
              for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
            }
            flowParseObjectTypeCallProperty(e, s) {
              let r = this.startNode();
              return e.static = s, e.value = this.flowParseObjectTypeMethodish(r), this.finishNode(e, "ObjectTypeCallProperty");
            }
            flowParseObjectType(e) {
              let { allowStatic: s, allowExact: r, allowSpread: i, allowProto: a, allowInexact: n } = e, o = this.state.inType;
              this.state.inType = true;
              let c = this.startNode();
              c.callProperties = [], c.properties = [], c.indexers = [], c.internalSlots = [];
              let f, y, P = false;
              for (r && this.match(6) ? (this.expect(6), f = 9, y = true) : (this.expect(5), f = 8, y = false), c.exact = y; !this.match(f); ) {
                let N = false, B = null, _ = null, Q = this.startNode();
                if (a && this.isContextual(115)) {
                  let ne = this.lookahead();
                  ne.type !== 14 && ne.type !== 17 && (this.next(), B = this.state.startLoc, s = false);
                }
                if (s && this.isContextual(104)) {
                  let ne = this.lookahead();
                  ne.type !== 14 && ne.type !== 17 && (this.next(), N = true);
                }
                let re = this.flowParseVariance();
                if (this.eat(0))
                  B != null && this.unexpected(B), this.eat(0) ? (re && this.unexpected(re.loc.start), c.internalSlots.push(this.flowParseObjectTypeInternalSlot(Q, N))) : c.indexers.push(this.flowParseObjectTypeIndexer(Q, N, re));
                else if (this.match(10) || this.match(47))
                  B != null && this.unexpected(B), re && this.unexpected(re.loc.start), c.callProperties.push(this.flowParseObjectTypeCallProperty(Q, N));
                else {
                  let ne = "init";
                  if (this.isContextual(98) || this.isContextual(103)) {
                    let le = this.lookahead();
                    hr(le.type) && (ne = this.state.value, this.next());
                  }
                  let $e = this.flowParseObjectTypeProperty(Q, N, B, re, ne, i, n != null ? n : !y);
                  $e === null ? (P = true, _ = this.state.lastTokStartLoc) : c.properties.push($e);
                }
                this.flowObjectTypeSemicolon(), _ && !this.match(8) && !this.match(9) && this.raise(I.UnexpectedExplicitInexactInObject, { at: _ });
              }
              this.expect(f), i && (c.inexact = P);
              let v = this.finishNode(c, "ObjectTypeAnnotation");
              return this.state.inType = o, v;
            }
            flowParseObjectTypeProperty(e, s, r, i, a, n, o) {
              if (this.eat(21))
                return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (n ? o || this.raise(I.InexactInsideExact, { at: this.state.lastTokStartLoc }) : this.raise(I.InexactInsideNonObject, { at: this.state.lastTokStartLoc }), i && this.raise(I.InexactVariance, { at: i }), null) : (n || this.raise(I.UnexpectedSpreadType, { at: this.state.lastTokStartLoc }), r != null && this.unexpected(r), i && this.raise(I.SpreadVariance, { at: i }), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
              {
                e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = r != null, e.kind = a;
                let c = false;
                return this.match(47) || this.match(10) ? (e.method = true, r != null && this.unexpected(r), i && this.unexpected(i.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.start, e.loc.start)), (a === "get" || a === "set") && this.flowCheckGetterSetterParams(e), !n && e.key.name === "constructor" && e.value.this && this.raise(I.ThisParamBannedInConstructor, { at: e.value.this })) : (a !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c = true), e.value = this.flowParseTypeInitialiser(), e.variance = i), e.optional = c, this.finishNode(e, "ObjectTypeProperty");
              }
            }
            flowCheckGetterSetterParams(e) {
              let s = e.kind === "get" ? 0 : 1, r = e.value.params.length + (e.value.rest ? 1 : 0);
              e.value.this && this.raise(e.kind === "get" ? I.GetterMayNotHaveThisParam : I.SetterMayNotHaveThisParam, { at: e.value.this }), r !== s && this.raise(e.kind === "get" ? u.BadGetterArity : u.BadSetterArity, { at: e }), e.kind === "set" && e.value.rest && this.raise(u.BadSetterRestParameter, { at: e });
            }
            flowObjectTypeSemicolon() {
              !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
            }
            flowParseQualifiedTypeIdentifier(e, s, r) {
              e = e || this.state.start, s = s || this.state.startLoc;
              let i = r || this.flowParseRestrictedIdentifier(true);
              for (; this.eat(16); ) {
                let a = this.startNodeAt(e, s);
                a.qualification = i, a.id = this.flowParseRestrictedIdentifier(true), i = this.finishNode(a, "QualifiedTypeIdentifier");
              }
              return i;
            }
            flowParseGenericType(e, s, r) {
              let i = this.startNodeAt(e, s);
              return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s, r), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
            }
            flowParseTypeofType() {
              let e = this.startNode();
              return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
            }
            flowParseTupleType() {
              let e = this.startNode();
              for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); )
                this.expect(12);
              return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
            }
            flowParseFunctionTypeParam(e) {
              let s = null, r = false, i = null, a = this.startNode(), n = this.lookahead(), o = this.state.type === 78;
              return n.type === 14 || n.type === 17 ? (o && !e && this.raise(I.ThisParamMustBeFirst, { at: a }), s = this.parseIdentifier(o), this.eat(17) && (r = true, o && this.raise(I.ThisParamMayNotBeOptional, { at: a })), i = this.flowParseTypeInitialiser()) : i = this.flowParseType(), a.name = s, a.optional = r, a.typeAnnotation = i, this.finishNode(a, "FunctionTypeParam");
            }
            reinterpretTypeAsFunctionTypeParam(e) {
              let s = this.startNodeAt(e.start, e.loc.start);
              return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
            }
            flowParseFunctionTypeParams() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = null, r = null;
              for (this.match(78) && (r = this.flowParseFunctionTypeParam(true), r.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); )
                e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
              return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: r };
            }
            flowIdentToTypeAnnotation(e, s, r, i) {
              switch (i.name) {
                case "any":
                  return this.finishNode(r, "AnyTypeAnnotation");
                case "bool":
                case "boolean":
                  return this.finishNode(r, "BooleanTypeAnnotation");
                case "mixed":
                  return this.finishNode(r, "MixedTypeAnnotation");
                case "empty":
                  return this.finishNode(r, "EmptyTypeAnnotation");
                case "number":
                  return this.finishNode(r, "NumberTypeAnnotation");
                case "string":
                  return this.finishNode(r, "StringTypeAnnotation");
                case "symbol":
                  return this.finishNode(r, "SymbolTypeAnnotation");
                default:
                  return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, s, i);
              }
            }
            flowParsePrimaryType() {
              let e = this.state.start, s = this.state.startLoc, r = this.startNode(), i, a, n = false, o = this.state.noAnonFunctionType;
              switch (this.state.type) {
                case 5:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                case 6:
                  return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                case 0:
                  return this.state.noAnonFunctionType = false, a = this.flowParseTupleType(), this.state.noAnonFunctionType = o, a;
                case 47:
                  return r.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), this.finishNode(r, "FunctionTypeAnnotation");
                case 10:
                  if (this.next(), !this.match(11) && !this.match(21))
                    if (K(this.state.type) || this.match(78)) {
                      let c = this.lookahead().type;
                      n = c !== 17 && c !== 14;
                    } else
                      n = true;
                  if (n) {
                    if (this.state.noAnonFunctionType = false, a = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19))
                      return this.expect(11), a;
                    this.eat(12);
                  }
                  return a ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : i = this.flowParseFunctionTypeParams(), r.params = i.params, r.rest = i.rest, r.this = i._this, this.expect(11), this.expect(19), r.returnType = this.flowParseType(), r.typeParameters = null, this.finishNode(r, "FunctionTypeAnnotation");
                case 129:
                  return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                case 85:
                case 86:
                  return r.value = this.match(85), this.next(), this.finishNode(r, "BooleanLiteralTypeAnnotation");
                case 53:
                  if (this.state.value === "-") {
                    if (this.next(), this.match(130))
                      return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r);
                    if (this.match(131))
                      return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r);
                    throw this.raise(I.UnexpectedSubtractionOperand, { at: this.state.startLoc });
                  }
                  throw this.unexpected();
                case 130:
                  return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                case 131:
                  return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                case 88:
                  return this.next(), this.finishNode(r, "VoidTypeAnnotation");
                case 84:
                  return this.next(), this.finishNode(r, "NullLiteralTypeAnnotation");
                case 78:
                  return this.next(), this.finishNode(r, "ThisTypeAnnotation");
                case 55:
                  return this.next(), this.finishNode(r, "ExistsTypeAnnotation");
                case 87:
                  return this.flowParseTypeofType();
                default:
                  if (Ht(this.state.type)) {
                    let c = Pe(this.state.type);
                    return this.next(), super.createIdentifier(r, c);
                  } else if (K(this.state.type))
                    return this.isContextual(125) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, r, this.parseIdentifier());
              }
              throw this.unexpected();
            }
            flowParsePostfixType() {
              let e = this.state.start, s = this.state.startLoc, r = this.flowParsePrimaryType(), i = false;
              for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
                let a = this.startNodeAt(e, s), n = this.eat(18);
                i = i || n, this.expect(0), !n && this.match(3) ? (a.elementType = r, this.next(), r = this.finishNode(a, "ArrayTypeAnnotation")) : (a.objectType = r, a.indexType = this.flowParseType(), this.expect(3), i ? (a.optional = n, r = this.finishNode(a, "OptionalIndexedAccessType")) : r = this.finishNode(a, "IndexedAccessType"));
              }
              return r;
            }
            flowParsePrefixType() {
              let e = this.startNode();
              return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
            }
            flowParseAnonFunctionWithoutParens() {
              let e = this.flowParsePrefixType();
              if (!this.state.noAnonFunctionType && this.eat(19)) {
                let s = this.startNodeAt(e.start, e.loc.start);
                return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
              }
              return e;
            }
            flowParseIntersectionType() {
              let e = this.startNode();
              this.eat(45);
              let s = this.flowParseAnonFunctionWithoutParens();
              for (e.types = [s]; this.eat(45); )
                e.types.push(this.flowParseAnonFunctionWithoutParens());
              return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
            }
            flowParseUnionType() {
              let e = this.startNode();
              this.eat(43);
              let s = this.flowParseIntersectionType();
              for (e.types = [s]; this.eat(43); )
                e.types.push(this.flowParseIntersectionType());
              return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
            }
            flowParseType() {
              let e = this.state.inType;
              this.state.inType = true;
              let s = this.flowParseUnionType();
              return this.state.inType = e, s;
            }
            flowParseTypeOrImplicitInstantiation() {
              if (this.state.type === 128 && this.state.value === "_") {
                let e = this.state.start, s = this.state.startLoc, r = this.parseIdentifier();
                return this.flowParseGenericType(e, s, r);
              } else
                return this.flowParseType();
            }
            flowParseTypeAnnotation() {
              let e = this.startNode();
              return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
            }
            flowParseTypeAnnotatableIdentifier(e) {
              let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
              return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            flowParseVariance() {
              let e = null;
              return this.match(53) && (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")), e;
            }
            parseFunctionBody(e, s) {
              let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return s ? this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, r)) : super.parseFunctionBody(e, false, r);
            }
            parseFunctionBodyAndFinish(e, s) {
              let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (this.match(14)) {
                let i = this.startNode();
                [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = i.typeAnnotation ? this.finishNode(i, "TypeAnnotation") : null;
              }
              super.parseFunctionBodyAndFinish(e, s, r);
            }
            parseStatement(e, s) {
              if (this.state.strict && this.isContextual(125)) {
                let i = this.lookahead();
                if (pe(i.type)) {
                  let a = this.startNode();
                  return this.next(), this.flowParseInterface(a);
                }
              } else if (this.shouldParseEnums() && this.isContextual(122)) {
                let i = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(i);
              }
              let r = super.parseStatement(e, s);
              return this.flowPragma === void 0 && !this.isValidDirective(r) && (this.flowPragma = null), r;
            }
            parseExpressionStatement(e, s) {
              if (s.type === "Identifier") {
                if (s.name === "declare") {
                  if (this.match(80) || K(this.state.type) || this.match(68) || this.match(74) || this.match(82))
                    return this.flowParseDeclare(e);
                } else if (K(this.state.type)) {
                  if (s.name === "interface")
                    return this.flowParseInterface(e);
                  if (s.name === "type")
                    return this.flowParseTypeAlias(e);
                  if (s.name === "opaque")
                    return this.flowParseOpaqueType(e, false);
                }
              }
              return super.parseExpressionStatement(e, s);
            }
            shouldParseExportDeclaration() {
              let { type: e } = this.state;
              return lr(e) || this.shouldParseEnums() && e === 122 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
            }
            isExportDefaultSpecifier() {
              let { type: e } = this.state;
              return lr(e) || this.shouldParseEnums() && e === 122 ? this.state.containsEsc : super.isExportDefaultSpecifier();
            }
            parseExportDefaultExpression() {
              if (this.shouldParseEnums() && this.isContextual(122)) {
                let e = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(e);
              }
              return super.parseExportDefaultExpression();
            }
            parseConditional(e, s, r, i) {
              if (!this.match(17))
                return e;
              if (this.state.maybeInArrowParameters) {
                let v = this.lookaheadCharCode();
                if (v === 44 || v === 61 || v === 58 || v === 41)
                  return this.setOptionalParametersError(i), e;
              }
              this.expect(17);
              let a = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s, r), { consequent: c, failed: f } = this.tryParseConditionalConsequent(), [y, P] = this.getArrowLikeExpressions(c);
              if (f || P.length > 0) {
                let v = [...n];
                if (P.length > 0) {
                  this.state = a, this.state.noArrowAt = v;
                  for (let N = 0; N < P.length; N++)
                    v.push(P[N].start);
                  ({ consequent: c, failed: f } = this.tryParseConditionalConsequent()), [y, P] = this.getArrowLikeExpressions(c);
                }
                f && y.length > 1 && this.raise(I.AmbiguousConditionalArrow, { at: a.startLoc }), f && y.length === 1 && (this.state = a, v.push(y[0].start), this.state.noArrowAt = v, { consequent: c, failed: f } = this.tryParseConditionalConsequent());
              }
              return this.getArrowLikeExpressions(c, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = c, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
            }
            tryParseConditionalConsequent() {
              this.state.noArrowParamsConversionAt.push(this.state.start);
              let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
              return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
            }
            getArrowLikeExpressions(e, s) {
              let r = [e], i = [];
              for (; r.length !== 0; ) {
                let a = r.pop();
                a.type === "ArrowFunctionExpression" ? (a.typeParameters || !a.returnType ? this.finishArrowValidation(a) : i.push(a), r.push(a.body)) : a.type === "ConditionalExpression" && (r.push(a.consequent), r.push(a.alternate));
              }
              return s ? (i.forEach((a) => this.finishArrowValidation(a)), [i, []]) : Ih(i, (a) => a.params.every((n) => this.isAssignable(n, true)));
            }
            finishArrowValidation(e) {
              var s;
              this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(me | Jt), super.checkParams(e, false, true), this.scope.exit();
            }
            forwardNoArrowParamsConversionAt(e, s) {
              let r;
              return this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r = s(), this.state.noArrowParamsConversionAt.pop()) : r = s(), r;
            }
            parseParenItem(e, s, r) {
              if (e = super.parseParenItem(e, s, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s, r);
                return i.expression = e, i.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(i, "TypeCastExpression");
              }
              return e;
            }
            assertModuleNodeAllowed(e) {
              e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
            }
            parseExport(e) {
              let s = super.parseExport(e);
              return (s.type === "ExportNamedDeclaration" || s.type === "ExportAllDeclaration") && (s.exportKind = s.exportKind || "value"), s;
            }
            parseExportDeclaration(e) {
              if (this.isContextual(126)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), this.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
              } else if (this.isContextual(127)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.flowParseOpaqueType(s, false);
              } else if (this.isContextual(125)) {
                e.exportKind = "type";
                let s = this.startNode();
                return this.next(), this.flowParseInterface(s);
              } else if (this.shouldParseEnums() && this.isContextual(122)) {
                e.exportKind = "value";
                let s = this.startNode();
                return this.next(), this.flowParseEnumDeclaration(s);
              } else
                return super.parseExportDeclaration(e);
            }
            eatExportStar(e) {
              return super.eatExportStar(...arguments) ? true : this.isContextual(126) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
            }
            maybeParseExportNamespaceSpecifier(e) {
              let { startLoc: s } = this.state, r = super.maybeParseExportNamespaceSpecifier(e);
              return r && e.exportKind === "type" && this.unexpected(s), r;
            }
            parseClassId(e, s, r) {
              super.parseClassId(e, s, r), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
            }
            parseClassMember(e, s, r) {
              let { startLoc: i } = this.state;
              if (this.isContextual(121)) {
                if (this.parseClassMemberFromModifier(e, s))
                  return;
                s.declare = true;
              }
              super.parseClassMember(e, s, r), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(I.DeclareClassElement, { at: i }) : s.value && this.raise(I.DeclareClassFieldInitializer, { at: s.value }));
            }
            isIterator(e) {
              return e === "iterator" || e === "asyncIterator";
            }
            readIterator() {
              let e = super.readWord1(), s = "@@" + e;
              (!this.isIterator(e) || !this.state.inType) && this.raise(u.InvalidIdentifier, { at: this.state.curPosition(), identifierName: s }), this.finishToken(128, s);
            }
            getTokenFromCode(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              return e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : Ko(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
            }
            isAssignable(e, s) {
              return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
            }
            toAssignable(e) {
              !(arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false) && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(...arguments);
            }
            toAssignableList(e, s, r) {
              for (let i = 0; i < e.length; i++) {
                let a = e[i];
                (a == null ? void 0 : a.type) === "TypeCastExpression" && (e[i] = this.typeCastToParameter(a));
              }
              super.toAssignableList(e, s, r);
            }
            toReferencedList(e, s) {
              for (let i = 0; i < e.length; i++) {
                var r;
                let a = e[i];
                a && a.type === "TypeCastExpression" && !((r = a.extra) != null && r.parenthesized) && (e.length > 1 || !s) && this.raise(I.TypeCastInPattern, { at: a.typeAnnotation });
              }
              return e;
            }
            parseArrayLike(e, s, r, i) {
              let a = super.parseArrayLike(e, s, r, i);
              return s && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
            }
            isValidLVal(e) {
              for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
                r[i - 1] = arguments[i];
              return e === "TypeCastExpression" || super.isValidLVal(e, ...r);
            }
            parseClassProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(14) || super.isClassProperty();
            }
            isNonstaticConstructor(e) {
              return !this.match(14) && super.isNonstaticConstructor(e);
            }
            pushClassMethod(e, s, r, i, a, n) {
              if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, r, i, a, n), s.params && a) {
                let o = s.params;
                o.length > 0 && this.isThisParam(o[0]) && this.raise(I.ThisParamBannedInConstructor, { at: s });
              } else if (s.type === "MethodDefinition" && a && s.value.params) {
                let o = s.value.params;
                o.length > 0 && this.isThisParam(o[0]) && this.raise(I.ThisParamBannedInConstructor, { at: s });
              }
            }
            pushClassPrivateMethod(e, s, r, i) {
              s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, r, i);
            }
            parseClassSuper(e) {
              if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(110)) {
                this.next();
                let s = e.implements = [];
                do {
                  let r = this.startNode();
                  r.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() : r.typeParameters = null, s.push(this.finishNode(r, "ClassImplements"));
                } while (this.eat(12));
              }
            }
            checkGetterSetterParams(e) {
              super.checkGetterSetterParams(e);
              let s = this.getObjectOrClassMethodParams(e);
              if (s.length > 0) {
                let r = s[0];
                this.isThisParam(r) && e.kind === "get" ? this.raise(I.GetterMayNotHaveThisParam, { at: r }) : this.isThisParam(r) && this.raise(I.SetterMayNotHaveThisParam, { at: r });
              }
            }
            parsePropertyNamePrefixOperator(e) {
              e.variance = this.flowParseVariance();
            }
            parseObjPropValue(e, s, r, i, a, n, o, c) {
              e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
              let f;
              this.match(47) && !o && (f = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected()), super.parseObjPropValue(e, s, r, i, a, n, o, c), f && ((e.value || e).typeParameters = f);
            }
            parseAssignableListItemTypes(e) {
              return this.eat(17) && (e.type !== "Identifier" && this.raise(I.PatternIsOptional, { at: e }), this.isThisParam(e) && this.raise(I.ThisParamMayNotBeOptional, { at: e }), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(I.ThisParamAnnotationRequired, { at: e }), this.match(29) && this.isThisParam(e) && this.raise(I.ThisParamNoDefault, { at: e }), this.resetEndLocation(e), e;
            }
            parseMaybeDefault(e, s, r) {
              let i = super.parseMaybeDefault(e, s, r);
              return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(I.TypeBeforeInitializer, { at: i.typeAnnotation }), i;
            }
            shouldParseDefaultImport(e) {
              return cs(e) ? Or(this.state.type) : super.shouldParseDefaultImport(e);
            }
            parseImportSpecifierLocal(e, s, r) {
              s.local = cs(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, r));
            }
            maybeParseDefaultImportSpecifier(e) {
              e.importKind = "value";
              let s = null;
              if (this.match(87) ? s = "typeof" : this.isContextual(126) && (s = "type"), s) {
                let r = this.lookahead(), { type: i } = r;
                s === "type" && i === 55 && this.unexpected(null, r.type), (Or(i) || i === 5 || i === 55) && (this.next(), e.importKind = s);
              }
              return super.maybeParseDefaultImportSpecifier(e);
            }
            parseImportSpecifier(e, s, r, i) {
              let a = e.imported, n = null;
              a.type === "Identifier" && (a.name === "type" ? n = "type" : a.name === "typeof" && (n = "typeof"));
              let o = false;
              if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
                let f = this.parseIdentifier(true);
                n !== null && !pe(this.state.type) ? (e.imported = f, e.importKind = n, e.local = ge(f)) : (e.imported = a, e.importKind = null, e.local = this.parseIdentifier());
              } else {
                if (n !== null && pe(this.state.type))
                  e.imported = this.parseIdentifier(true), e.importKind = n;
                else {
                  if (s)
                    throw this.raise(u.ImportBindingIsString, { at: e, importName: a.value });
                  e.imported = a, e.importKind = null;
                }
                this.eatContextual(93) ? e.local = this.parseIdentifier() : (o = true, e.local = ge(e.imported));
              }
              let c = cs(e);
              return r && c && this.raise(I.ImportTypeShorthandOnlyInPureImport, { at: e }), (r || c) && this.checkReservedType(e.local.name, e.local.loc.start, true), o && !r && !c && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseFunctionParams(e, s) {
              let r = e.kind;
              r !== "get" && r !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
            }
            parseVarId(e, s) {
              super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s) {
              if (this.match(14)) {
                let r = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = r;
              }
              return super.parseAsyncArrowFromCallExpression(e, s);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            parseMaybeAssign(e, s) {
              var r;
              let i = null, a;
              if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
                if (i = this.state.clone(), a = this.tryParse(() => super.parseMaybeAssign(e, s), i), !a.error)
                  return a.node;
                let { context: c } = this.state, f = c[c.length - 1];
                (f === z.j_oTag || f === z.j_expr) && c.pop();
              }
              if ((r = a) != null && r.error || this.match(47)) {
                var n, o;
                i = i || this.state.clone();
                let c, f = this.tryParse((P) => {
                  var v;
                  c = this.flowParseTypeParameterDeclaration();
                  let N = this.forwardNoArrowParamsConversionAt(c, () => {
                    let _ = super.parseMaybeAssign(e, s);
                    return this.resetStartLocationFromNode(_, c), _;
                  });
                  (v = N.extra) != null && v.parenthesized && P();
                  let B = this.maybeUnwrapTypeCastExpression(N);
                  return B.type !== "ArrowFunctionExpression" && P(), B.typeParameters = c, this.resetStartLocationFromNode(B, c), N;
                }, i), y = null;
                if (f.node && this.maybeUnwrapTypeCastExpression(f.node).type === "ArrowFunctionExpression") {
                  if (!f.error && !f.aborted)
                    return f.node.async && this.raise(I.UnexpectedTypeParameterBeforeAsyncArrowFunction, { at: c }), f.node;
                  y = f.node;
                }
                if ((n = a) != null && n.node)
                  return this.state = a.failState, a.node;
                if (y)
                  return this.state = f.failState, y;
                throw (o = a) != null && o.thrown ? a.error : f.thrown ? f.error : this.raise(I.UnexpectedTokenAfterTypeParameter, { at: c });
              }
              return super.parseMaybeAssign(e, s);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s = this.tryParse(() => {
                  let r = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true;
                  let i = this.startNode();
                  return [i.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = r, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), i;
                });
                if (s.thrown)
                  return null;
                s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
              }
              return super.parseArrow(e);
            }
            shouldParseArrow(e) {
              return this.match(14) || super.shouldParseArrow(e);
            }
            setArrowFunctionParameters(e, s) {
              this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1 ? e.params = s : super.setArrowFunctionParameters(e, s);
            }
            checkParams(e, s, r) {
              if (!(r && this.state.noArrowParamsConversionAt.indexOf(e.start) !== -1)) {
                for (let i = 0; i < e.params.length; i++)
                  this.isThisParam(e.params[i]) && i > 0 && this.raise(I.ThisParamMustBeFirst, { at: e.params[i] });
                return super.checkParams(...arguments);
              }
            }
            parseParenAndDistinguishExpression(e) {
              return super.parseParenAndDistinguishExpression(e && this.state.noArrowAt.indexOf(this.state.start) === -1);
            }
            parseSubscripts(e, s, r, i) {
              if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.indexOf(s) !== -1) {
                this.next();
                let a = this.startNodeAt(s, r);
                a.callee = e, a.arguments = this.parseCallExpressionArguments(11, false), e = this.finishNode(a, "CallExpression");
              } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
                let a = this.state.clone(), n = this.tryParse((c) => this.parseAsyncArrowWithTypeParameters(s, r) || c(), a);
                if (!n.error && !n.aborted)
                  return n.node;
                let o = this.tryParse(() => super.parseSubscripts(e, s, r, i), a);
                if (o.node && !o.error)
                  return o.node;
                if (n.node)
                  return this.state = n.failState, n.node;
                if (o.node)
                  return this.state = o.failState, o.node;
                throw n.error || o.error;
              }
              return super.parseSubscripts(e, s, r, i);
            }
            parseSubscript(e, s, r, i, a) {
              if (this.match(18) && this.isLookaheadToken_lt()) {
                if (a.optionalChainMember = true, i)
                  return a.stop = true, e;
                this.next();
                let n = this.startNodeAt(s, r);
                return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
              } else if (!i && this.shouldParseTypes() && this.match(47)) {
                let n = this.startNodeAt(s, r);
                n.callee = e;
                let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), a.optionalChainMember && (n.optional = false), this.finishCallExpression(n, a.optionalChainMember)));
                if (o.node)
                  return o.error && (this.state = o.failState), o.node;
              }
              return super.parseSubscript(e, s, r, i, a);
            }
            parseNewCallee(e) {
              super.parseNewCallee(e);
              let s = null;
              this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
            }
            parseAsyncArrowWithTypeParameters(e, s) {
              let r = this.startNodeAt(e, s);
              if (this.parseFunctionParams(r), !!this.parseArrow(r))
                return this.parseArrowExpression(r, void 0, true);
            }
            readToken_mult_modulo(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              if (e === 42 && s === 47 && this.state.hasFlowComment) {
                this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
                return;
              }
              super.readToken_mult_modulo(e);
            }
            readToken_pipe_amp(e) {
              let s = this.input.charCodeAt(this.state.pos + 1);
              if (e === 124 && s === 125) {
                this.finishOp(9, 2);
                return;
              }
              super.readToken_pipe_amp(e);
            }
            parseTopLevel(e, s) {
              let r = super.parseTopLevel(e, s);
              return this.state.hasFlowComment && this.raise(I.UnterminatedFlowComment, { at: this.state.curPosition() }), r;
            }
            skipBlockComment() {
              if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
                if (this.state.hasFlowComment)
                  throw this.raise(I.NestedFlowComment, { at: this.state.startLoc });
                this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), this.state.hasFlowComment = true;
                return;
              }
              if (this.state.hasFlowComment) {
                let e = this.input.indexOf("*-/", this.state.pos + 2);
                if (e === -1)
                  throw this.raise(u.UnterminatedComment, { at: this.state.curPosition() });
                this.state.pos = e + 2 + 3;
                return;
              }
              return super.skipBlockComment();
            }
            skipFlowComment() {
              let { pos: e } = this.state, s = 2;
              for (; [32, 9].includes(this.input.charCodeAt(e + s)); )
                s++;
              let r = this.input.charCodeAt(s + e), i = this.input.charCodeAt(s + e + 1);
              return r === 58 && i === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : r === 58 && i !== 58 ? s : false;
            }
            hasFlowCommentCompletion() {
              if (this.input.indexOf("*/", this.state.pos) === -1)
                throw this.raise(u.UnterminatedComment, { at: this.state.curPosition() });
            }
            flowEnumErrorBooleanMemberNotInitialized(e, s) {
              let { enumName: r, memberName: i } = s;
              this.raise(I.EnumBooleanMemberNotInitialized, { at: e, memberName: i, enumName: r });
            }
            flowEnumErrorInvalidMemberInitializer(e, s) {
              return this.raise(s.explicitType ? s.explicitType === "symbol" ? I.EnumInvalidMemberInitializerSymbolType : I.EnumInvalidMemberInitializerPrimaryType : I.EnumInvalidMemberInitializerUnknownType, Object.assign({ at: e }, s));
            }
            flowEnumErrorNumberMemberNotInitialized(e, s) {
              let { enumName: r, memberName: i } = s;
              this.raise(I.EnumNumberMemberNotInitialized, { at: e, enumName: r, memberName: i });
            }
            flowEnumErrorStringMemberInconsistentlyInitailized(e, s) {
              let { enumName: r } = s;
              this.raise(I.EnumStringMemberInconsistentlyInitailized, { at: e, enumName: r });
            }
            flowEnumMemberInit() {
              let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
              switch (this.state.type) {
                case 130: {
                  let r = this.parseNumericLiteral(this.state.value);
                  return s() ? { type: "number", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
                }
                case 129: {
                  let r = this.parseStringLiteral(this.state.value);
                  return s() ? { type: "string", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
                }
                case 85:
                case 86: {
                  let r = this.parseBooleanLiteral(this.match(85));
                  return s() ? { type: "boolean", loc: r.loc.start, value: r } : { type: "invalid", loc: e };
                }
                default:
                  return { type: "invalid", loc: e };
              }
            }
            flowEnumMemberRaw() {
              let e = this.state.startLoc, s = this.parseIdentifier(true), r = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
              return { id: s, init: r };
            }
            flowEnumCheckExplicitTypeMismatch(e, s, r) {
              let { explicitType: i } = s;
              i !== null && i !== r && this.flowEnumErrorInvalidMemberInitializer(e, s);
            }
            flowEnumMembers(e) {
              let { enumName: s, explicitType: r } = e, i = /* @__PURE__ */ new Set(), a = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n = false;
              for (; !this.match(8); ) {
                if (this.eat(21)) {
                  n = true;
                  break;
                }
                let o = this.startNode(), { id: c, init: f } = this.flowEnumMemberRaw(), y = c.name;
                if (y === "")
                  continue;
                /^[a-z]/.test(y) && this.raise(I.EnumInvalidMemberName, { at: c, memberName: y, suggestion: y[0].toUpperCase() + y.slice(1), enumName: s }), i.has(y) && this.raise(I.EnumDuplicateMemberName, { at: c, memberName: y, enumName: s }), i.add(y);
                let P = { enumName: s, explicitType: r, memberName: y };
                switch (o.id = c, f.type) {
                  case "boolean": {
                    this.flowEnumCheckExplicitTypeMismatch(f.loc, P, "boolean"), o.init = f.value, a.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
                    break;
                  }
                  case "number": {
                    this.flowEnumCheckExplicitTypeMismatch(f.loc, P, "number"), o.init = f.value, a.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
                    break;
                  }
                  case "string": {
                    this.flowEnumCheckExplicitTypeMismatch(f.loc, P, "string"), o.init = f.value, a.stringMembers.push(this.finishNode(o, "EnumStringMember"));
                    break;
                  }
                  case "invalid":
                    throw this.flowEnumErrorInvalidMemberInitializer(f.loc, P);
                  case "none":
                    switch (r) {
                      case "boolean":
                        this.flowEnumErrorBooleanMemberNotInitialized(f.loc, P);
                        break;
                      case "number":
                        this.flowEnumErrorNumberMemberNotInitialized(f.loc, P);
                        break;
                      default:
                        a.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
                    }
                }
                this.match(8) || this.expect(12);
              }
              return { members: a, hasUnknownMembers: n };
            }
            flowEnumStringMembers(e, s, r) {
              let { enumName: i } = r;
              if (e.length === 0)
                return s;
              if (s.length === 0)
                return e;
              if (s.length > e.length) {
                for (let a of e)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(a, { enumName: i });
                return s;
              } else {
                for (let a of s)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(a, { enumName: i });
                return e;
              }
            }
            flowEnumParseExplicitType(e) {
              let { enumName: s } = e;
              if (!this.eatContextual(101))
                return null;
              if (!K(this.state.type))
                throw this.raise(I.EnumInvalidExplicitTypeUnknownSupplied, { at: this.state.startLoc, enumName: s });
              let { value: r } = this.state;
              return this.next(), r !== "boolean" && r !== "number" && r !== "string" && r !== "symbol" && this.raise(I.EnumInvalidExplicitType, { at: this.state.startLoc, enumName: s, invalidEnumType: r }), r;
            }
            flowEnumBody(e, s) {
              let r = s.name, i = s.loc.start, a = this.flowEnumParseExplicitType({ enumName: r });
              this.expect(5);
              let { members: n, hasUnknownMembers: o } = this.flowEnumMembers({ enumName: r, explicitType: a });
              switch (e.hasUnknownMembers = o, a) {
                case "boolean":
                  return e.explicitType = true, e.members = n.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                case "number":
                  return e.explicitType = true, e.members = n.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                case "string":
                  return e.explicitType = true, e.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: r }), this.expect(8), this.finishNode(e, "EnumStringBody");
                case "symbol":
                  return e.members = n.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
                default: {
                  let c = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                  e.explicitType = false;
                  let f = n.booleanMembers.length, y = n.numberMembers.length, P = n.stringMembers.length, v = n.defaultedMembers.length;
                  if (!f && !y && !P && !v)
                    return c();
                  if (!f && !y)
                    return e.members = this.flowEnumStringMembers(n.stringMembers, n.defaultedMembers, { enumName: r }), this.expect(8), this.finishNode(e, "EnumStringBody");
                  if (!y && !P && f >= v) {
                    for (let N of n.defaultedMembers)
                      this.flowEnumErrorBooleanMemberNotInitialized(N.loc.start, { enumName: r, memberName: N.id.name });
                    return e.members = n.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                  } else if (!f && !P && y >= v) {
                    for (let N of n.defaultedMembers)
                      this.flowEnumErrorNumberMemberNotInitialized(N.loc.start, { enumName: r, memberName: N.id.name });
                    return e.members = n.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                  } else
                    return this.raise(I.EnumInconsistentMemberValues, { at: i, enumName: r }), c();
                }
              }
            }
            flowParseEnumDeclaration(e) {
              let s = this.parseIdentifier();
              return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
            }
            isLookaheadToken_lt() {
              let e = this.nextTokenStart();
              if (this.input.charCodeAt(e) === 60) {
                let s = this.input.charCodeAt(e + 1);
                return s !== 60 && s !== 61;
              }
              return false;
            }
            maybeUnwrapTypeCastExpression(e) {
              return e.type === "TypeCastExpression" ? e.expression : e;
            }
          }, Fh = { __proto__: null, quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" }, Ie = j(Kn || (Kn = rt(["jsx"])))((t) => ({ AttributeIsEmpty: t("JSX attributes must only be assigned a non-empty expression."), MissingClosingTagElement: t((e) => {
            let { openingTagName: s } = e;
            return "Expected corresponding JSX closing tag for <".concat(s, ">.");
          }), MissingClosingTagFragment: t("Expected corresponding JSX closing tag for <>."), UnexpectedSequenceExpression: t("Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?"), UnexpectedToken: t((e) => {
            let { unexpected: s, HTMLEntity: r } = e;
            return "Unexpected token `".concat(s, "`. Did you mean `").concat(r, "` or `{'").concat(s, "'}`?");
          }), UnsupportedJsxValue: t("JSX value should be either an expression or a quoted JSX text."), UnterminatedJsxContent: t("Unterminated JSX contents."), UnwrappedAdjacentJSXElements: t("Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?") }));
          function Ce(t) {
            return t ? t.type === "JSXOpeningFragment" || t.type === "JSXClosingFragment" : false;
          }
          function Ue(t) {
            if (t.type === "JSXIdentifier")
              return t.name;
            if (t.type === "JSXNamespacedName")
              return t.namespace.name + ":" + t.name.name;
            if (t.type === "JSXMemberExpression")
              return Ue(t.object) + "." + Ue(t.property);
            throw new Error("Node had unexpected type: " + t.type);
          }
          var Lh = (t) => class extends t {
            jsxReadToken() {
              let e = "", s = this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(Ie.UnterminatedJsxContent, { at: this.state.startLoc });
                let r = this.input.charCodeAt(this.state.pos);
                switch (r) {
                  case 60:
                  case 123:
                    return this.state.pos === this.state.start ? r === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(r) : (e += this.input.slice(s, this.state.pos), this.finishToken(137, e));
                  case 38:
                    e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
                    break;
                  case 62:
                  case 125:
                  default:
                    Ne(r) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
                }
              }
            }
            jsxReadNewLine(e) {
              let s = this.input.charCodeAt(this.state.pos), r;
              return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r = e ? `
` : `\r
`) : r = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, r;
            }
            jsxReadString(e) {
              let s = "", r = ++this.state.pos;
              for (; ; ) {
                if (this.state.pos >= this.length)
                  throw this.raise(u.UnterminatedString, { at: this.state.startLoc });
                let i = this.input.charCodeAt(this.state.pos);
                if (i === e)
                  break;
                i === 38 ? (s += this.input.slice(r, this.state.pos), s += this.jsxReadEntity(), r = this.state.pos) : Ne(i) ? (s += this.input.slice(r, this.state.pos), s += this.jsxReadNewLine(false), r = this.state.pos) : ++this.state.pos;
              }
              return s += this.input.slice(r, this.state.pos++), this.finishToken(129, s);
            }
            jsxReadEntity() {
              let e = ++this.state.pos;
              if (this.codePointAtPos(this.state.pos) === 35) {
                ++this.state.pos;
                let s = 10;
                this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
                let r = this.readInt(s, void 0, false, "bail");
                if (r !== null && this.codePointAtPos(this.state.pos) === 59)
                  return ++this.state.pos, String.fromCodePoint(r);
              } else {
                let s = 0, r = false;
                for (; s++ < 10 && this.state.pos < this.length && !(r = this.codePointAtPos(this.state.pos) == 59); )
                  ++this.state.pos;
                if (r) {
                  let i = this.input.slice(e, this.state.pos), a = Fh[i];
                  if (++this.state.pos, a)
                    return a;
                }
              }
              return this.state.pos = e, "&";
            }
            jsxReadWord() {
              let e, s = this.state.pos;
              do
                e = this.input.charCodeAt(++this.state.pos);
              while (Be(e) || e === 45);
              return this.finishToken(136, this.input.slice(s, this.state.pos));
            }
            jsxParseIdentifier() {
              let e = this.startNode();
              return this.match(136) ? e.name = this.state.value : Ht(this.state.type) ? e.name = Pe(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
            }
            jsxParseNamespacedName() {
              let e = this.state.start, s = this.state.startLoc, r = this.jsxParseIdentifier();
              if (!this.eat(14))
                return r;
              let i = this.startNodeAt(e, s);
              return i.namespace = r, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
            }
            jsxParseElementName() {
              let e = this.state.start, s = this.state.startLoc, r = this.jsxParseNamespacedName();
              if (r.type === "JSXNamespacedName")
                return r;
              for (; this.eat(16); ) {
                let i = this.startNodeAt(e, s);
                i.object = r, i.property = this.jsxParseIdentifier(), r = this.finishNode(i, "JSXMemberExpression");
              }
              return r;
            }
            jsxParseAttributeValue() {
              let e;
              switch (this.state.type) {
                case 5:
                  return e = this.startNode(), this.setContext(z.brace), this.next(), e = this.jsxParseExpressionContainer(e, z.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(Ie.AttributeIsEmpty, { at: e }), e;
                case 138:
                case 129:
                  return this.parseExprAtom();
                default:
                  throw this.raise(Ie.UnsupportedJsxValue, { at: this.state.startLoc });
              }
            }
            jsxParseEmptyExpression() {
              let e = this.startNodeAt(this.state.lastTokEndLoc.index, this.state.lastTokEndLoc);
              return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
            }
            jsxParseSpreadChild(e) {
              return this.next(), e.expression = this.parseExpression(), this.setContext(z.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
            }
            jsxParseExpressionContainer(e, s) {
              if (this.match(8))
                e.expression = this.jsxParseEmptyExpression();
              else {
                let r = this.parseExpression();
                e.expression = r;
              }
              return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
            }
            jsxParseAttribute() {
              let e = this.startNode();
              return this.match(5) ? (this.setContext(z.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(z.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
            }
            jsxParseOpeningElementAt(e, s) {
              let r = this.startNodeAt(e, s);
              return this.eat(139) ? this.finishNode(r, "JSXOpeningFragment") : (r.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r));
            }
            jsxParseOpeningElementAfterName(e) {
              let s = [];
              for (; !this.match(56) && !this.match(139); )
                s.push(this.jsxParseAttribute());
              return e.attributes = s, e.selfClosing = this.eat(56), this.expect(139), this.finishNode(e, "JSXOpeningElement");
            }
            jsxParseClosingElementAt(e, s) {
              let r = this.startNodeAt(e, s);
              return this.eat(139) ? this.finishNode(r, "JSXClosingFragment") : (r.name = this.jsxParseElementName(), this.expect(139), this.finishNode(r, "JSXClosingElement"));
            }
            jsxParseElementAt(e, s) {
              let r = this.startNodeAt(e, s), i = [], a = this.jsxParseOpeningElementAt(e, s), n = null;
              if (!a.selfClosing) {
                e:
                  for (; ; )
                    switch (this.state.type) {
                      case 138:
                        if (e = this.state.start, s = this.state.startLoc, this.next(), this.eat(56)) {
                          n = this.jsxParseClosingElementAt(e, s);
                          break e;
                        }
                        i.push(this.jsxParseElementAt(e, s));
                        break;
                      case 137:
                        i.push(this.parseExprAtom());
                        break;
                      case 5: {
                        let o = this.startNode();
                        this.setContext(z.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, z.j_expr));
                        break;
                      }
                      default:
                        throw this.unexpected();
                    }
                Ce(a) && !Ce(n) && n !== null ? this.raise(Ie.MissingClosingTagFragment, { at: n }) : !Ce(a) && Ce(n) ? this.raise(Ie.MissingClosingTagElement, { at: n, openingTagName: Ue(a.name) }) : !Ce(a) && !Ce(n) && Ue(n.name) !== Ue(a.name) && this.raise(Ie.MissingClosingTagElement, { at: n, openingTagName: Ue(a.name) });
              }
              if (Ce(a) ? (r.openingFragment = a, r.closingFragment = n) : (r.openingElement = a, r.closingElement = n), r.children = i, this.match(47))
                throw this.raise(Ie.UnwrappedAdjacentJSXElements, { at: this.state.startLoc });
              return Ce(a) ? this.finishNode(r, "JSXFragment") : this.finishNode(r, "JSXElement");
            }
            jsxParseElement() {
              let e = this.state.start, s = this.state.startLoc;
              return this.next(), this.jsxParseElementAt(e, s);
            }
            setContext(e) {
              let { context: s } = this.state;
              s[s.length - 1] = e;
            }
            parseExprAtom(e) {
              return this.match(137) ? this.parseLiteral(this.state.value, "JSXText") : this.match(138) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(138), this.jsxParseElement()) : super.parseExprAtom(e);
            }
            skipSpace() {
              this.curContext().preserveSpace || super.skipSpace();
            }
            getTokenFromCode(e) {
              let s = this.curContext();
              if (s === z.j_expr)
                return this.jsxReadToken();
              if (s === z.j_oTag || s === z.j_cTag) {
                if (de(e))
                  return this.jsxReadWord();
                if (e === 62)
                  return ++this.state.pos, this.finishToken(139);
                if ((e === 34 || e === 39) && s === z.j_oTag)
                  return this.jsxReadString(e);
              }
              return e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(138)) : super.getTokenFromCode(e);
            }
            updateContext(e) {
              let { context: s, type: r } = this.state;
              if (r === 56 && e === 138)
                s.splice(-2, 2, z.j_cTag), this.state.canStartJSXElement = false;
              else if (r === 138)
                s.push(z.j_oTag);
              else if (r === 139) {
                let i = s[s.length - 1];
                i === z.j_oTag && e === 56 || i === z.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === z.j_expr) : (this.setContext(z.j_expr), this.state.canStartJSXElement = true);
              } else
                this.state.canStartJSXElement = So(r);
            }
          }, Oh = class extends os {
            constructor() {
              super(...arguments), this.types = /* @__PURE__ */ new Set(), this.enums = /* @__PURE__ */ new Set(), this.constEnums = /* @__PURE__ */ new Set(), this.classes = /* @__PURE__ */ new Set(), this.exportOnlyBindings = /* @__PURE__ */ new Set();
            }
          }, Bh = class extends hs {
            createScope(t) {
              return new Oh(t);
            }
            declareName(t, e, s) {
              let r = this.currentScope();
              if (e & Zt) {
                this.maybeExportDefined(r, t), r.exportOnlyBindings.add(t);
                return;
              }
              super.declareName(...arguments), e & Re && (e & ye || (this.checkRedeclarationInScope(r, t, e, s), this.maybeExportDefined(r, t)), r.types.add(t)), e & $t && r.enums.add(t), e & Qt && r.constEnums.add(t), e & ct && r.classes.add(t);
            }
            isRedeclaredInScope(t, e, s) {
              if (t.enums.has(e)) {
                if (s & $t) {
                  let r = !!(s & Qt), i = t.constEnums.has(e);
                  return r !== i;
                }
                return true;
              }
              return s & ct && t.classes.has(e) ? t.lexical.has(e) ? !!(s & ye) : false : s & Re && t.types.has(e) ? true : super.isRedeclaredInScope(...arguments);
            }
            checkLocalExport(t) {
              let e = this.scopeStack[0], { name: s } = t;
              !e.types.has(s) && !e.exportOnlyBindings.has(s) && super.checkLocalExport(t);
            }
          }, Mh = (t, e) => Object.hasOwnProperty.call(t, e) && t[e];
          function Rh(t) {
            if (t == null)
              throw new Error("Unexpected ".concat(t, " value."));
            return t;
          }
          function Br(t) {
            if (!t)
              throw new Error("Assert fail");
          }
          function jh(t) {
            return Vt(t) || Oo(t);
          }
          var S = j(Vn || (Vn = rt(["typescript"])))((t) => ({ AbstractMethodHasImplementation: t((e) => {
            let { methodName: s } = e;
            return "Method '".concat(s, "' cannot have an implementation because it is marked abstract.");
          }), AbstractPropertyHasInitializer: t((e) => {
            let { propertyName: s } = e;
            return "Property '".concat(s, "' cannot have an initializer because it is marked abstract.");
          }), AccesorCannotDeclareThisParameter: t("'get' and 'set' accessors cannot declare 'this' parameters."), AccesorCannotHaveTypeParameters: t("An accessor cannot have type parameters."), CannotFindName: t((e) => {
            let { name: s } = e;
            return "Cannot find name '".concat(s, "'.");
          }), ClassMethodHasDeclare: t("Class methods cannot have the 'declare' modifier."), ClassMethodHasReadonly: t("Class methods cannot have the 'readonly' modifier."), ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: t("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."), ConstructorHasTypeParameters: t("Type parameters cannot appear on a constructor declaration."), DeclareAccessor: t((e) => {
            let { kind: s } = e;
            return "'declare' is not allowed in ".concat(s, "ters.");
          }), DeclareClassFieldHasInitializer: t("Initializers are not allowed in ambient contexts."), DeclareFunctionHasImplementation: t("An implementation cannot be declared in ambient contexts."), DuplicateAccessibilityModifier: t((e) => {
            let { modifier: s } = e;
            return "Accessibility modifier already seen.";
          }), DuplicateModifier: t((e) => {
            let { modifier: s } = e;
            return "Duplicate modifier: '".concat(s, "'.");
          }), EmptyHeritageClauseType: t((e) => {
            let { token: s } = e;
            return "'".concat(s, "' list cannot be empty.");
          }), EmptyTypeArguments: t("Type argument list cannot be empty."), EmptyTypeParameters: t("Type parameter list cannot be empty."), ExpectedAmbientAfterExportDeclare: t("'export declare' must be followed by an ambient declaration."), ImportAliasHasImportType: t("An import alias can not use 'import type'."), IncompatibleModifiers: t((e) => {
            let { modifiers: s } = e;
            return "'".concat(s[0], "' modifier cannot be used with '").concat(s[1], "' modifier.");
          }), IndexSignatureHasAbstract: t("Index signatures cannot have the 'abstract' modifier."), IndexSignatureHasAccessibility: t((e) => {
            let { modifier: s } = e;
            return "Index signatures cannot have an accessibility modifier ('".concat(s, "').");
          }), IndexSignatureHasDeclare: t("Index signatures cannot have the 'declare' modifier."), IndexSignatureHasOverride: t("'override' modifier cannot appear on an index signature."), IndexSignatureHasStatic: t("Index signatures cannot have the 'static' modifier."), InitializerNotAllowedInAmbientContext: t("Initializers are not allowed in ambient contexts."), InvalidModifierOnTypeMember: t((e) => {
            let { modifier: s } = e;
            return "'".concat(s, "' modifier cannot appear on a type member.");
          }), InvalidModifierOnTypeParameter: t((e) => {
            let { modifier: s } = e;
            return "'".concat(s, "' modifier cannot appear on a type parameter.");
          }), InvalidModifierOnTypeParameterPositions: t((e) => {
            let { modifier: s } = e;
            return "'".concat(s, "' modifier can only appear on a type parameter of a class, interface or type alias.");
          }), InvalidModifiersOrder: t((e) => {
            let { orderedModifiers: s } = e;
            return "'".concat(s[0], "' modifier must precede '").concat(s[1], "' modifier.");
          }), InvalidTupleMemberLabel: t("Tuple members must be labeled with a simple identifier."), MissingInterfaceName: t("'interface' declarations must be followed by an identifier."), MixedLabeledAndUnlabeledElements: t("Tuple members must all have names or all not have names."), NonAbstractClassHasAbstractMethod: t("Abstract methods can only appear within an abstract class."), NonClassMethodPropertyHasAbstractModifer: t("'abstract' modifier can only appear on a class, method, or property declaration."), OptionalTypeBeforeRequired: t("A required element cannot follow an optional element."), OverrideNotInSubClass: t("This member cannot have an 'override' modifier because its containing class does not extend another class."), PatternIsOptional: t("A binding pattern parameter cannot be optional in an implementation signature."), PrivateElementHasAbstract: t("Private elements cannot have the 'abstract' modifier."), PrivateElementHasAccessibility: t((e) => {
            let { modifier: s } = e;
            return "Private elements cannot have an accessibility modifier ('".concat(s, "').");
          }), ReadonlyForMethodSignature: t("'readonly' modifier can only appear on a property declaration or index signature."), ReservedArrowTypeParam: t("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`."), ReservedTypeAssertion: t("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."), SetAccesorCannotHaveOptionalParameter: t("A 'set' accessor cannot have an optional parameter."), SetAccesorCannotHaveRestParameter: t("A 'set' accessor cannot have rest parameter."), SetAccesorCannotHaveReturnType: t("A 'set' accessor cannot have a return type annotation."), SingleTypeParameterWithoutTrailingComma: t((e) => {
            let { typeParameterName: s } = e;
            return "Single type parameter ".concat(s, " should have a trailing comma. Example usage: <").concat(s, ",>.");
          }), StaticBlockCannotHaveModifier: t("Static class blocks cannot have any modifier."), TypeAnnotationAfterAssign: t("Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`."), TypeImportCannotSpecifyDefaultAndNamed: t("A type-only import can specify a default import or named bindings, but not both."), TypeModifierIsUsedInTypeExports: t("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."), TypeModifierIsUsedInTypeImports: t("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."), UnexpectedParameterModifier: t("A parameter property is only allowed in a constructor implementation."), UnexpectedReadonly: t("'readonly' type modifier is only permitted on array and tuple literal types."), UnexpectedTypeAnnotation: t("Did not expect a type annotation here."), UnexpectedTypeCastInParameter: t("Unexpected type cast in parameter position."), UnsupportedImportTypeArgument: t("Argument in a type import must be a string literal."), UnsupportedParameterPropertyKind: t("A parameter property may not be declared using a binding pattern."), UnsupportedSignatureParameterKind: t((e) => {
            let { type: s } = e;
            return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(s, ".");
          }) }));
          function qh(t) {
            switch (t) {
              case "any":
                return "TSAnyKeyword";
              case "boolean":
                return "TSBooleanKeyword";
              case "bigint":
                return "TSBigIntKeyword";
              case "never":
                return "TSNeverKeyword";
              case "number":
                return "TSNumberKeyword";
              case "object":
                return "TSObjectKeyword";
              case "string":
                return "TSStringKeyword";
              case "symbol":
                return "TSSymbolKeyword";
              case "undefined":
                return "TSUndefinedKeyword";
              case "unknown":
                return "TSUnknownKeyword";
              default:
                return;
            }
          }
          function Mr(t) {
            return t === "private" || t === "public" || t === "protected";
          }
          function Uh(t) {
            return t === "in" || t === "out";
          }
          var _h = (t) => class extends t {
            getScopeHandler() {
              return Bh;
            }
            tsIsIdentifier() {
              return K(this.state.type);
            }
            tsTokenCanFollowModifier() {
              return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(134) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
            }
            tsNextTokenCanFollowModifier() {
              return this.next(), this.tsTokenCanFollowModifier();
            }
            tsParseModifier(e, s) {
              if (!K(this.state.type) && this.state.type !== 58)
                return;
              let r = this.state.value;
              if (e.indexOf(r) !== -1) {
                if (s && this.tsIsStartOfStaticBlocks())
                  return;
                if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
                  return r;
              }
            }
            tsParseModifiers(e) {
              let { modified: s, allowedModifiers: r, disallowedModifiers: i, stopOnStartOfClassStaticBlock: a, errorTemplate: n = S.InvalidModifierOnTypeMember } = e, o = (f, y, P, v) => {
                y === P && s[v] && this.raise(S.InvalidModifiersOrder, { at: f, orderedModifiers: [P, v] });
              }, c = (f, y, P, v) => {
                (s[P] && y === v || s[v] && y === P) && this.raise(S.IncompatibleModifiers, { at: f, modifiers: [P, v] });
              };
              for (; ; ) {
                let { startLoc: f } = this.state, y = this.tsParseModifier(r.concat(i != null ? i : []), a);
                if (!y)
                  break;
                Mr(y) ? s.accessibility ? this.raise(S.DuplicateAccessibilityModifier, { at: f, modifier: y }) : (o(f, y, y, "override"), o(f, y, y, "static"), o(f, y, y, "readonly"), s.accessibility = y) : Uh(y) ? (s[y] && this.raise(S.DuplicateModifier, { at: f, modifier: y }), s[y] = true, o(f, y, "in", "out")) : (Object.hasOwnProperty.call(s, y) ? this.raise(S.DuplicateModifier, { at: f, modifier: y }) : (o(f, y, "static", "readonly"), o(f, y, "static", "override"), o(f, y, "override", "readonly"), o(f, y, "abstract", "override"), c(f, y, "declare", "override"), c(f, y, "static", "abstract")), s[y] = true), i != null && i.includes(y) && this.raise(n, { at: f, modifier: y });
              }
            }
            tsIsListTerminator(e) {
              switch (e) {
                case "EnumMembers":
                case "TypeMembers":
                  return this.match(8);
                case "HeritageClauseElement":
                  return this.match(5);
                case "TupleElementTypes":
                  return this.match(3);
                case "TypeParametersOrArguments":
                  return this.match(48);
              }
              throw new Error("Unreachable");
            }
            tsParseList(e, s) {
              let r = [];
              for (; !this.tsIsListTerminator(e); )
                r.push(s());
              return r;
            }
            tsParseDelimitedList(e, s, r) {
              return Rh(this.tsParseDelimitedListWorker(e, s, true, r));
            }
            tsParseDelimitedListWorker(e, s, r, i) {
              let a = [], n = -1;
              for (; !this.tsIsListTerminator(e); ) {
                n = -1;
                let o = s();
                if (o == null)
                  return;
                if (a.push(o), this.eat(12)) {
                  n = this.state.lastTokStart;
                  continue;
                }
                if (this.tsIsListTerminator(e))
                  break;
                r && this.expect(12);
                return;
              }
              return i && (i.value = n), a;
            }
            tsParseBracketedList(e, s, r, i, a) {
              i || (r ? this.expect(0) : this.expect(47));
              let n = this.tsParseDelimitedList(e, s, a);
              return r ? this.expect(3) : this.expect(48), n;
            }
            tsParseImportType() {
              let e = this.startNode();
              return this.expect(83), this.expect(10), this.match(129) || this.raise(S.UnsupportedImportTypeArgument, { at: this.state.startLoc }), e.argument = this.parseExprAtom(), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
            }
            tsParseEntityName() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = this.parseIdentifier(e);
              for (; this.eat(16); ) {
                let r = this.startNodeAtNode(s);
                r.left = s, r.right = this.parseIdentifier(e), s = this.finishNode(r, "TSQualifiedName");
              }
              return s;
            }
            tsParseTypeReference() {
              let e = this.startNode();
              return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
            }
            tsParseThisTypePredicate(e) {
              this.next();
              let s = this.startNodeAtNode(e);
              return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
            }
            tsParseThisTypeNode() {
              let e = this.startNode();
              return this.next(), this.finishNode(e, "TSThisType");
            }
            tsParseTypeQuery() {
              let e = this.startNode();
              return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
            }
            tsParseInOutModifiers(e) {
              this.tsParseModifiers({ modified: e, allowedModifiers: ["in", "out"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: S.InvalidModifierOnTypeParameter });
            }
            tsParseNoneModifiers(e) {
              this.tsParseModifiers({ modified: e, allowedModifiers: [], disallowedModifiers: ["in", "out"], errorTemplate: S.InvalidModifierOnTypeParameterPositions });
            }
            tsParseTypeParameter() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.tsParseNoneModifiers.bind(this), s = this.startNode();
              return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
            }
            tsTryParseTypeParameters(e) {
              if (this.match(47))
                return this.tsParseTypeParameters(e);
            }
            tsParseTypeParameters(e) {
              let s = this.startNode();
              this.match(47) || this.match(138) ? this.next() : this.unexpected();
              let r = { value: -1 };
              return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, r), s.params.length === 0 && this.raise(S.EmptyTypeParameters, { at: s }), r.value !== -1 && this.addExtra(s, "trailingComma", r.value), this.finishNode(s, "TSTypeParameterDeclaration");
            }
            tsTryNextParseConstantContext() {
              if (this.lookahead().type !== 75)
                return null;
              this.next();
              let e = this.tsParseTypeReference();
              return e.typeParameters && this.raise(S.CannotFindName, { at: e.typeName, name: "const" }), e;
            }
            tsFillSignature(e, s) {
              let r = e === 19, i = "parameters", a = "typeAnnotation";
              s.typeParameters = this.tsTryParseTypeParameters(), this.expect(10), s[i] = this.tsParseBindingListForSignature(), r ? s[a] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[a] = this.tsParseTypeOrTypePredicateAnnotation(e));
            }
            tsParseBindingListForSignature() {
              return this.parseBindingList(11, 41).map((e) => (e.type !== "Identifier" && e.type !== "RestElement" && e.type !== "ObjectPattern" && e.type !== "ArrayPattern" && this.raise(S.UnsupportedSignatureParameterKind, { at: e, type: e.type }), e));
            }
            tsParseTypeMemberSemicolon() {
              !this.eat(12) && !this.isLineTerminator() && this.expect(13);
            }
            tsParseSignatureMember(e, s) {
              return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
            }
            tsIsUnambiguouslyIndexSignature() {
              return this.next(), K(this.state.type) ? (this.next(), this.match(14)) : false;
            }
            tsTryParseIndexSignature(e) {
              if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
                return;
              this.expect(0);
              let s = this.parseIdentifier();
              s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
              let r = this.tsTryParseTypeAnnotation();
              return r && (e.typeAnnotation = r), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
            }
            tsParsePropertyOrMethodSignature(e, s) {
              this.eat(17) && (e.optional = true);
              let r = e;
              if (this.match(10) || this.match(47)) {
                s && this.raise(S.ReadonlyForMethodSignature, { at: e });
                let i = r;
                i.kind && this.match(47) && this.raise(S.AccesorCannotHaveTypeParameters, { at: this.state.curPosition() }), this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon();
                let a = "parameters", n = "typeAnnotation";
                if (i.kind === "get")
                  i[a].length > 0 && (this.raise(u.BadGetterArity, { at: this.state.curPosition() }), this.isThisParam(i[a][0]) && this.raise(S.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }));
                else if (i.kind === "set") {
                  if (i[a].length !== 1)
                    this.raise(u.BadSetterArity, { at: this.state.curPosition() });
                  else {
                    let o = i[a][0];
                    this.isThisParam(o) && this.raise(S.AccesorCannotDeclareThisParameter, { at: this.state.curPosition() }), o.type === "Identifier" && o.optional && this.raise(S.SetAccesorCannotHaveOptionalParameter, { at: this.state.curPosition() }), o.type === "RestElement" && this.raise(S.SetAccesorCannotHaveRestParameter, { at: this.state.curPosition() });
                  }
                  i[n] && this.raise(S.SetAccesorCannotHaveReturnType, { at: i[n] });
                } else
                  i.kind = "method";
                return this.finishNode(i, "TSMethodSignature");
              } else {
                let i = r;
                s && (i.readonly = true);
                let a = this.tsTryParseTypeAnnotation();
                return a && (i.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(i, "TSPropertySignature");
              }
            }
            tsParseTypeMember() {
              let e = this.startNode();
              if (this.match(10) || this.match(47))
                return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
              if (this.match(77)) {
                let r = this.startNode();
                return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(r, "new"), this.tsParsePropertyOrMethodSignature(e, false));
              }
              this.tsParseModifiers({ modified: e, allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] });
              let s = this.tsTryParseIndexSignature(e);
              return s || (this.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, this.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
            }
            tsParseTypeLiteral() {
              let e = this.startNode();
              return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
            }
            tsParseObjectTypeMembers() {
              this.expect(5);
              let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
              return this.expect(8), e;
            }
            tsIsStartOfMappedType() {
              return this.next(), this.eat(53) ? this.isContextual(118) : (this.isContextual(118) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
            }
            tsParseMappedTypeParameter() {
              let e = this.startNode();
              return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
            }
            tsParseMappedType() {
              let e = this.startNode();
              return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(118)) : this.eatContextual(118) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
            }
            tsParseTupleType() {
              let e = this.startNode();
              e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
              let s = false, r = null;
              return e.elementTypes.forEach((i) => {
                var a;
                let { type: n } = i;
                s && n !== "TSRestType" && n !== "TSOptionalType" && !(n === "TSNamedTupleMember" && i.optional) && this.raise(S.OptionalTypeBeforeRequired, { at: i }), s = s || n === "TSNamedTupleMember" && i.optional || n === "TSOptionalType", n === "TSRestType" && (i = i.typeAnnotation, n = i.type);
                let o = n === "TSNamedTupleMember";
                r = (a = r) != null ? a : o, r !== o && this.raise(S.MixedLabeledAndUnlabeledElements, { at: i });
              }), this.finishNode(e, "TSTupleType");
            }
            tsParseTupleElementType() {
              let { start: e, startLoc: s } = this.state, r = this.eat(21), i = this.tsParseType(), a = this.eat(17);
              if (this.eat(14)) {
                let o = this.startNodeAtNode(i);
                o.optional = a, i.type === "TSTypeReference" && !i.typeParameters && i.typeName.type === "Identifier" ? o.label = i.typeName : (this.raise(S.InvalidTupleMemberLabel, { at: i }), o.label = i), o.elementType = this.tsParseType(), i = this.finishNode(o, "TSNamedTupleMember");
              } else if (a) {
                let o = this.startNodeAtNode(i);
                o.typeAnnotation = i, i = this.finishNode(o, "TSOptionalType");
              }
              if (r) {
                let o = this.startNodeAt(e, s);
                o.typeAnnotation = i, i = this.finishNode(o, "TSRestType");
              }
              return i;
            }
            tsParseParenthesizedType() {
              let e = this.startNode();
              return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
            }
            tsParseFunctionOrConstructorType(e, s) {
              let r = this.startNode();
              return e === "TSConstructorType" && (r.abstract = !!s, s && this.next(), this.next()), this.tsFillSignature(19, r), this.finishNode(r, e);
            }
            tsParseLiteralTypeNode() {
              let e = this.startNode();
              return e.literal = (() => {
                switch (this.state.type) {
                  case 130:
                  case 131:
                  case 129:
                  case 85:
                  case 86:
                    return this.parseExprAtom();
                  default:
                    throw this.unexpected();
                }
              })(), this.finishNode(e, "TSLiteralType");
            }
            tsParseTemplateLiteralType() {
              let e = this.startNode();
              return e.literal = this.parseTemplate(false), this.finishNode(e, "TSLiteralType");
            }
            parseTemplateSubstitution() {
              return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
            }
            tsParseThisTypeOrThisTypePredicate() {
              let e = this.tsParseThisTypeNode();
              return this.isContextual(113) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
            }
            tsParseNonArrayType() {
              switch (this.state.type) {
                case 129:
                case 130:
                case 131:
                case 85:
                case 86:
                  return this.tsParseLiteralTypeNode();
                case 53:
                  if (this.state.value === "-") {
                    let e = this.startNode(), s = this.lookahead();
                    if (s.type !== 130 && s.type !== 131)
                      throw this.unexpected();
                    return e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                  }
                  break;
                case 78:
                  return this.tsParseThisTypeOrThisTypePredicate();
                case 87:
                  return this.tsParseTypeQuery();
                case 83:
                  return this.tsParseImportType();
                case 5:
                  return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                case 0:
                  return this.tsParseTupleType();
                case 10:
                  return this.tsParseParenthesizedType();
                case 25:
                case 24:
                  return this.tsParseTemplateLiteralType();
                default: {
                  let { type: e } = this.state;
                  if (K(e) || e === 88 || e === 84) {
                    let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : qh(this.state.value);
                    if (s !== void 0 && this.lookaheadCharCode() !== 46) {
                      let r = this.startNode();
                      return this.next(), this.finishNode(r, s);
                    }
                    return this.tsParseTypeReference();
                  }
                }
              }
              throw this.unexpected();
            }
            tsParseArrayTypeOrHigher() {
              let e = this.tsParseNonArrayType();
              for (; !this.hasPrecedingLineBreak() && this.eat(0); )
                if (this.match(3)) {
                  let s = this.startNodeAtNode(e);
                  s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
                } else {
                  let s = this.startNodeAtNode(e);
                  s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
                }
              return e;
            }
            tsParseTypeOperator() {
              let e = this.startNode(), s = this.state.value;
              return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
            }
            tsCheckTypeAnnotationForReadOnly(e) {
              switch (e.typeAnnotation.type) {
                case "TSTupleType":
                case "TSArrayType":
                  return;
                default:
                  this.raise(S.UnexpectedReadonly, { at: e });
              }
            }
            tsParseInferType() {
              let e = this.startNode();
              this.expectContextual(112);
              let s = this.startNode();
              return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
            }
            tsParseConstraintForInferType() {
              if (this.eat(81)) {
                let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
                if (this.state.inDisallowConditionalTypesContext || !this.match(17))
                  return e;
              }
            }
            tsParseTypeOperatorOrHigher() {
              return Fo(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(112) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
            }
            tsParseUnionOrIntersectionType(e, s, r) {
              let i = this.startNode(), a = this.eat(r), n = [];
              do
                n.push(s());
              while (this.eat(r));
              return n.length === 1 && !a ? n[0] : (i.types = n, this.finishNode(i, e));
            }
            tsParseIntersectionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
            }
            tsParseUnionTypeOrHigher() {
              return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
            }
            tsIsStartOfFunctionType() {
              return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
            }
            tsSkipParameterStart() {
              if (K(this.state.type) || this.match(78))
                return this.next(), true;
              if (this.match(5)) {
                let { errors: e } = this.state, s = e.length;
                try {
                  return this.parseObjectLike(8, true), e.length === s;
                } catch {
                  return false;
                }
              }
              if (this.match(0)) {
                this.next();
                let { errors: e } = this.state, s = e.length;
                try {
                  return this.parseBindingList(3, 93, true), e.length === s;
                } catch {
                  return false;
                }
              }
              return false;
            }
            tsIsUnambiguouslyStartOfFunctionType() {
              return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
            }
            tsParseTypeOrTypePredicateAnnotation(e) {
              return this.tsInType(() => {
                let s = this.startNode();
                this.expect(e);
                let r = this.startNode(), i = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                if (i && this.match(78)) {
                  let o = this.tsParseThisTypeOrThisTypePredicate();
                  return o.type === "TSThisType" ? (r.parameterName = o, r.asserts = true, r.typeAnnotation = null, o = this.finishNode(r, "TSTypePredicate")) : (this.resetStartLocationFromNode(o, r), o.asserts = true), s.typeAnnotation = o, this.finishNode(s, "TSTypeAnnotation");
                }
                let a = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                if (!a)
                  return i ? (r.parameterName = this.parseIdentifier(), r.asserts = i, r.typeAnnotation = null, s.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
                let n = this.tsParseTypeAnnotation(false);
                return r.parameterName = a, r.typeAnnotation = n, r.asserts = i, s.typeAnnotation = this.finishNode(r, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
              });
            }
            tsTryParseTypeOrTypePredicateAnnotation() {
              return this.match(14) ? this.tsParseTypeOrTypePredicateAnnotation(14) : void 0;
            }
            tsTryParseTypeAnnotation() {
              return this.match(14) ? this.tsParseTypeAnnotation() : void 0;
            }
            tsTryParseType() {
              return this.tsEatThenParseType(14);
            }
            tsParseTypePredicatePrefix() {
              let e = this.parseIdentifier();
              if (this.isContextual(113) && !this.hasPrecedingLineBreak())
                return this.next(), e;
            }
            tsParseTypePredicateAsserts() {
              if (this.state.type !== 106)
                return false;
              let e = this.state.containsEsc;
              return this.next(), !K(this.state.type) && !this.match(78) ? false : (e && this.raise(u.InvalidEscapedReservedWord, { at: this.state.lastTokStartLoc, reservedWord: "asserts" }), true);
            }
            tsParseTypeAnnotation() {
              let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.startNode();
              return this.tsInType(() => {
                e && this.expect(14), s.typeAnnotation = this.tsParseType();
              }), this.finishNode(s, "TSTypeAnnotation");
            }
            tsParseType() {
              Br(this.state.inType);
              let e = this.tsParseNonConditionalType();
              if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
                return e;
              let s = this.startNodeAtNode(e);
              return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
            }
            isAbstractConstructorSignature() {
              return this.isContextual(120) && this.lookahead().type === 77;
            }
            tsParseNonConditionalType() {
              return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
            }
            tsParseTypeAssertion() {
              this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(S.ReservedTypeAssertion, { at: this.state.startLoc });
              let e = this.startNode(), s = this.tsTryNextParseConstantContext();
              return e.typeAnnotation = s || this.tsNextThenParseType(), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
            }
            tsParseHeritageClause(e) {
              let s = this.state.startLoc, r = this.tsParseDelimitedList("HeritageClauseElement", () => {
                let i = this.startNode();
                return i.expression = this.tsParseEntityName(), this.match(47) && (i.typeParameters = this.tsParseTypeArguments()), this.finishNode(i, "TSExpressionWithTypeArguments");
              });
              return r.length || this.raise(S.EmptyHeritageClauseType, { at: s, token: e }), r;
            }
            tsParseInterfaceDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              if (this.hasFollowingLineBreak())
                return null;
              this.expectContextual(125), s.declare && (e.declare = true), K(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Wo)) : (e.id = null, this.raise(S.MissingInterfaceName, { at: this.state.startLoc })), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
              let r = this.startNode();
              return r.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(r, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
            }
            tsParseTypeAliasDeclaration(e) {
              return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, Go), e.typeAnnotation = this.tsInType(() => {
                if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this)), this.expect(29), this.isContextual(111) && this.lookahead().type !== 16) {
                  let s = this.startNode();
                  return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
                }
                return this.tsParseType();
              }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
            }
            tsInNoContext(e) {
              let s = this.state.context;
              this.state.context = [s[0]];
              try {
                return e();
              } finally {
                this.state.context = s;
              }
            }
            tsInType(e) {
              let s = this.state.inType;
              this.state.inType = true;
              try {
                return e();
              } finally {
                this.state.inType = s;
              }
            }
            tsInDisallowConditionalTypesContext(e) {
              let s = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = true;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s;
              }
            }
            tsInAllowConditionalTypesContext(e) {
              let s = this.state.inDisallowConditionalTypesContext;
              this.state.inDisallowConditionalTypesContext = false;
              try {
                return e();
              } finally {
                this.state.inDisallowConditionalTypesContext = s;
              }
            }
            tsEatThenParseType(e) {
              return this.match(e) ? this.tsNextThenParseType() : void 0;
            }
            tsExpectThenParseType(e) {
              return this.tsDoThenParseType(() => this.expect(e));
            }
            tsNextThenParseType() {
              return this.tsDoThenParseType(() => this.next());
            }
            tsDoThenParseType(e) {
              return this.tsInType(() => (e(), this.tsParseType()));
            }
            tsParseEnumMember() {
              let e = this.startNode();
              return e.id = this.match(129) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(29) && (e.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
            }
            tsParseEnumDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(122), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? Jo : Er), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
            }
            tsParseModuleBlock() {
              let e = this.startNode();
              return this.scope.enter(Me), this.expect(5), this.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
            }
            tsParseModuleOrNamespaceDeclaration(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, Yo), this.eat(16)) {
                let r = this.startNode();
                this.tsParseModuleOrNamespaceDeclaration(r, true), e.body = r;
              } else
                this.scope.enter(ht), this.prodParam.enter(je), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
              return this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseAmbientExternalModuleDeclaration(e) {
              return this.isContextual(109) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(129) ? e.id = this.parseExprAtom() : this.unexpected(), this.match(5) ? (this.scope.enter(ht), this.prodParam.enter(je), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
            }
            tsParseImportEqualsDeclaration(e, s) {
              e.isExport = s || false, e.id = this.parseIdentifier(), this.checkIdentifier(e.id, xe), this.expect(29);
              let r = this.tsParseModuleReference();
              return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(S.ImportAliasHasImportType, { at: r }), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
            }
            tsIsExternalModuleReference() {
              return this.isContextual(116) && this.lookaheadCharCode() === 40;
            }
            tsParseModuleReference() {
              return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
            }
            tsParseExternalModuleReference() {
              let e = this.startNode();
              if (this.expectContextual(116), this.expect(10), !this.match(129))
                throw this.unexpected();
              return e.expression = this.parseExprAtom(), this.expect(11), this.finishNode(e, "TSExternalModuleReference");
            }
            tsLookAhead(e) {
              let s = this.state.clone(), r = e();
              return this.state = s, r;
            }
            tsTryParseAndCatch(e) {
              let s = this.tryParse((r) => e() || r());
              if (!(s.aborted || !s.node))
                return s.error && (this.state = s.failState), s.node;
            }
            tsTryParse(e) {
              let s = this.state.clone(), r = e();
              if (r !== void 0 && r !== false)
                return r;
              this.state = s;
            }
            tsTryParseDeclare(e) {
              if (this.isLineTerminator())
                return;
              let s = this.state.type, r;
              return this.isContextual(99) && (s = 74, r = "let"), this.tsInAmbientContext(() => {
                if (s === 68)
                  return e.declare = true, this.parseFunctionStatement(e, false, true);
                if (s === 80)
                  return e.declare = true, this.parseClass(e, true, false);
                if (s === 122)
                  return this.tsParseEnumDeclaration(e, { declare: true });
                if (s === 109)
                  return this.tsParseAmbientExternalModuleDeclaration(e);
                if (s === 75 || s === 74)
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, r || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                if (s === 125) {
                  let i = this.tsParseInterfaceDeclaration(e, { declare: true });
                  if (i)
                    return i;
                }
                if (K(s))
                  return this.tsParseDeclaration(e, this.state.value, true);
              });
            }
            tsTryParseExportDeclaration() {
              return this.tsParseDeclaration(this.startNode(), this.state.value, true);
            }
            tsParseExpressionStatement(e, s) {
              switch (s.name) {
                case "declare": {
                  let r = this.tsTryParseDeclare(e);
                  if (r)
                    return r.declare = true, r;
                  break;
                }
                case "global":
                  if (this.match(5)) {
                    this.scope.enter(ht), this.prodParam.enter(je);
                    let r = e;
                    return r.global = true, r.id = s, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
                  }
                  break;
                default:
                  return this.tsParseDeclaration(e, s.name, false);
              }
            }
            tsParseDeclaration(e, s, r) {
              switch (s) {
                case "abstract":
                  if (this.tsCheckLineTerminator(r) && (this.match(80) || K(this.state.type)))
                    return this.tsParseAbstractDeclaration(e);
                  break;
                case "module":
                  if (this.tsCheckLineTerminator(r)) {
                    if (this.match(129))
                      return this.tsParseAmbientExternalModuleDeclaration(e);
                    if (K(this.state.type))
                      return this.tsParseModuleOrNamespaceDeclaration(e);
                  }
                  break;
                case "namespace":
                  if (this.tsCheckLineTerminator(r) && K(this.state.type))
                    return this.tsParseModuleOrNamespaceDeclaration(e);
                  break;
                case "type":
                  if (this.tsCheckLineTerminator(r) && K(this.state.type))
                    return this.tsParseTypeAliasDeclaration(e);
                  break;
              }
            }
            tsCheckLineTerminator(e) {
              return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
            }
            tsTryParseGenericAsyncArrowFunction(e, s) {
              if (!this.match(47))
                return;
              let r = this.state.maybeInArrowParameters;
              this.state.maybeInArrowParameters = true;
              let i = this.tsTryParseAndCatch(() => {
                let a = this.startNodeAt(e, s);
                return a.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), a;
              });
              if (this.state.maybeInArrowParameters = r, !!i)
                return this.parseArrowExpression(i, null, true);
            }
            tsParseTypeArgumentsInExpression() {
              if (this.reScan_lt() === 47)
                return this.tsParseTypeArguments();
            }
            tsParseTypeArguments() {
              let e = this.startNode();
              return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 && this.raise(S.EmptyTypeArguments, { at: e }), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
            }
            tsIsDeclarationStart() {
              return Lo(this.state.type);
            }
            isExportDefaultSpecifier() {
              return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
            }
            parseAssignableListItem(e, s) {
              let r = this.state.start, i = this.state.startLoc, a, n = false, o = false;
              if (e !== void 0) {
                let y = {};
                this.tsParseModifiers({ modified: y, allowedModifiers: ["public", "private", "protected", "override", "readonly"] }), a = y.accessibility, o = y.override, n = y.readonly, e === false && (a || n || o) && this.raise(S.UnexpectedParameterModifier, { at: i });
              }
              let c = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(c);
              let f = this.parseMaybeDefault(c.start, c.loc.start, c);
              if (a || n || o) {
                let y = this.startNodeAt(r, i);
                return s.length && (y.decorators = s), a && (y.accessibility = a), n && (y.readonly = n), o && (y.override = o), f.type !== "Identifier" && f.type !== "AssignmentPattern" && this.raise(S.UnsupportedParameterPropertyKind, { at: y }), y.parameter = f, this.finishNode(y, "TSParameterProperty");
              }
              return s.length && (c.decorators = s), f;
            }
            isSimpleParameter(e) {
              return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
            }
            parseFunctionBodyAndFinish(e, s) {
              let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
              let i = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
              if (i && !this.match(5) && this.isLineTerminator()) {
                this.finishNode(e, i);
                return;
              }
              if (i === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(S.DeclareFunctionHasImplementation, { at: e }), e.declare)) {
                super.parseFunctionBodyAndFinish(e, i, r);
                return;
              }
              super.parseFunctionBodyAndFinish(e, s, r);
            }
            registerFunctionStatementId(e) {
              !e.body && e.id ? this.checkIdentifier(e.id, Cr) : super.registerFunctionStatementId(...arguments);
            }
            tsCheckForInvalidTypeCasts(e) {
              e.forEach((s) => {
                (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(S.UnexpectedTypeAnnotation, { at: s.typeAnnotation });
              });
            }
            toReferencedList(e, s) {
              return this.tsCheckForInvalidTypeCasts(e), e;
            }
            parseArrayLike() {
              let e = super.parseArrayLike(...arguments);
              return e.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(e.elements), e;
            }
            parseSubscript(e, s, r, i, a) {
              if (!this.hasPrecedingLineBreak() && this.match(35)) {
                this.state.canStartJSXElement = false, this.next();
                let o = this.startNodeAt(s, r);
                return o.expression = e, this.finishNode(o, "TSNonNullExpression");
              }
              let n = false;
              if (this.match(18) && this.lookaheadCharCode() === 60) {
                if (i)
                  return a.stop = true, e;
                a.optionalChainMember = n = true, this.next();
              }
              if (this.match(47) || this.match(51)) {
                let o, c = this.tsTryParseAndCatch(() => {
                  if (!i && this.atPossibleAsyncArrow(e)) {
                    let P = this.tsTryParseGenericAsyncArrowFunction(s, r);
                    if (P)
                      return P;
                  }
                  let f = this.tsParseTypeArgumentsInExpression();
                  if (!f)
                    throw this.unexpected();
                  if (n && !this.match(10))
                    throw o = this.state.curPosition(), this.unexpected();
                  if (nt(this.state.type)) {
                    let P = this.parseTaggedTemplateExpression(e, s, r, a);
                    return P.typeParameters = f, P;
                  }
                  if (!i && this.eat(10)) {
                    let P = this.startNodeAt(s, r);
                    return P.callee = e, P.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(P.arguments), P.typeParameters = f, a.optionalChainMember && (P.optional = n), this.finishCallExpression(P, a.optionalChainMember);
                  }
                  if (jh(this.state.type) && this.state.type !== 10)
                    throw this.unexpected();
                  let y = this.startNodeAt(s, r);
                  return y.expression = e, y.typeParameters = f, this.finishNode(y, "TSInstantiationExpression");
                });
                if (o && this.unexpected(o, 10), c)
                  return c;
              }
              return super.parseSubscript(e, s, r, i, a);
            }
            parseNewCallee(e) {
              var s;
              super.parseNewCallee(e);
              let { callee: r } = e;
              r.type === "TSInstantiationExpression" && !((s = r.extra) != null && s.parenthesized) && (e.typeParameters = r.typeParameters, e.callee = r.expression);
            }
            parseExprOp(e, s, r, i) {
              if (at(58) > i && !this.hasPrecedingLineBreak() && this.isContextual(93)) {
                let a = this.startNodeAt(s, r);
                a.expression = e;
                let n = this.tsTryNextParseConstantContext();
                return n ? a.typeAnnotation = n : a.typeAnnotation = this.tsNextThenParseType(), this.finishNode(a, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(a, s, r, i);
              }
              return super.parseExprOp(e, s, r, i);
            }
            checkReservedWord(e, s, r, i) {
              this.state.isAmbientContext || super.checkReservedWord(e, s, r, i);
            }
            checkDuplicateExports() {
            }
            parseImport(e) {
              if (e.importKind = "value", K(this.state.type) || this.match(55) || this.match(5)) {
                let r = this.lookahead();
                if (this.isContextual(126) && r.type !== 12 && r.type !== 97 && r.type !== 29 && (e.importKind = "type", this.next(), r = this.lookahead()), K(this.state.type) && r.type === 29)
                  return this.tsParseImportEqualsDeclaration(e);
              }
              let s = super.parseImport(e);
              return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(S.TypeImportCannotSpecifyDefaultAndNamed, { at: s }), s;
            }
            parseExport(e) {
              if (this.match(83))
                return this.next(), this.isContextual(126) && this.lookaheadCharCode() !== 61 ? (e.importKind = "type", this.next()) : e.importKind = "value", this.tsParseImportEqualsDeclaration(e, true);
              if (this.eat(29)) {
                let s = e;
                return s.expression = this.parseExpression(), this.semicolon(), this.finishNode(s, "TSExportAssignment");
              } else if (this.eatContextual(93)) {
                let s = e;
                return this.expectContextual(124), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
              } else
                return this.isContextual(126) && this.lookahead().type === 5 ? (this.next(), e.exportKind = "type") : e.exportKind = "value", super.parseExport(e);
            }
            isAbstractClass() {
              return this.isContextual(120) && this.lookahead().type === 80;
            }
            parseExportDefaultExpression() {
              if (this.isAbstractClass()) {
                let e = this.startNode();
                return this.next(), e.abstract = true, this.parseClass(e, true, true), e;
              }
              if (this.match(125)) {
                let e = this.tsParseInterfaceDeclaration(this.startNode());
                if (e)
                  return e;
              }
              return super.parseExportDefaultExpression();
            }
            parseVarStatement(e, s) {
              let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, { isAmbientContext: i } = this.state, a = super.parseVarStatement(e, s, r || i);
              if (!i)
                return a;
              for (let { id: n, init: o } of a.declarations)
                !o || (s !== "const" || !!n.typeAnnotation ? this.raise(S.InitializerNotAllowedInAmbientContext, { at: o }) : o.type !== "StringLiteral" && o.type !== "BooleanLiteral" && o.type !== "NumericLiteral" && o.type !== "BigIntLiteral" && (o.type !== "TemplateLiteral" || o.expressions.length > 0) && !zh(o) && this.raise(S.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, { at: o }));
              return a;
            }
            parseStatementContent(e, s) {
              if (this.match(75) && this.isLookaheadContextual("enum")) {
                let r = this.startNode();
                return this.expect(75), this.tsParseEnumDeclaration(r, { const: true });
              }
              if (this.isContextual(122))
                return this.tsParseEnumDeclaration(this.startNode());
              if (this.isContextual(125)) {
                let r = this.tsParseInterfaceDeclaration(this.startNode());
                if (r)
                  return r;
              }
              return super.parseStatementContent(e, s);
            }
            parseAccessModifier() {
              return this.tsParseModifier(["public", "protected", "private"]);
            }
            tsHasSomeModifiers(e, s) {
              return s.some((r) => Mr(r) ? e.accessibility === r : !!e[r]);
            }
            tsIsStartOfStaticBlocks() {
              return this.isContextual(104) && this.lookaheadCharCode() === 123;
            }
            parseClassMember(e, s, r) {
              let i = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
              this.tsParseModifiers({ modified: s, allowedModifiers: i, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: S.InvalidModifierOnTypeParameterPositions });
              let a = () => {
                this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, i) && this.raise(S.StaticBlockCannotHaveModifier, { at: this.state.curPosition() }), this.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, r, !!s.static);
              };
              s.declare ? this.tsInAmbientContext(a) : a();
            }
            parseClassMemberWithIsStatic(e, s, r, i) {
              let a = this.tsTryParseIndexSignature(s);
              if (a) {
                e.body.push(a), s.abstract && this.raise(S.IndexSignatureHasAbstract, { at: s }), s.accessibility && this.raise(S.IndexSignatureHasAccessibility, { at: s, modifier: s.accessibility }), s.declare && this.raise(S.IndexSignatureHasDeclare, { at: s }), s.override && this.raise(S.IndexSignatureHasOverride, { at: s });
                return;
              }
              !this.state.inAbstractClass && s.abstract && this.raise(S.NonAbstractClassHasAbstractMethod, { at: s }), s.override && (r.hadSuperClass || this.raise(S.OverrideNotInSubClass, { at: s })), super.parseClassMemberWithIsStatic(e, s, r, i);
            }
            parsePostMemberNameModifiers(e) {
              this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(S.ClassMethodHasReadonly, { at: e }), e.declare && this.match(10) && this.raise(S.ClassMethodHasDeclare, { at: e });
            }
            parseExpressionStatement(e, s) {
              return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s) : void 0) || super.parseExpressionStatement(e, s);
            }
            shouldParseExportDeclaration() {
              return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
            }
            parseConditional(e, s, r, i) {
              if (!this.state.maybeInArrowParameters || !this.match(17))
                return super.parseConditional(e, s, r, i);
              let a = this.tryParse(() => super.parseConditional(e, s, r));
              return a.node ? (a.error && (this.state = a.failState), a.node) : (a.error && super.setOptionalParametersError(i, a.error), e);
            }
            parseParenItem(e, s, r) {
              if (e = super.parseParenItem(e, s, r), this.eat(17) && (e.optional = true, this.resetEndLocation(e)), this.match(14)) {
                let i = this.startNodeAt(s, r);
                return i.expression = e, i.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(i, "TSTypeCastExpression");
              }
              return e;
            }
            parseExportDeclaration(e) {
              if (!this.state.isAmbientContext && this.isContextual(121))
                return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
              let s = this.state.start, r = this.state.startLoc, i = this.eatContextual(121);
              if (i && (this.isContextual(121) || !this.shouldParseExportDeclaration()))
                throw this.raise(S.ExpectedAmbientAfterExportDeclare, { at: this.state.startLoc });
              let n = K(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
              return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s, r), n.declare = true), n) : null;
            }
            parseClassId(e, s, r) {
              if ((!s || r) && this.isContextual(110))
                return;
              super.parseClassId(e, s, r, e.declare ? Cr : Pr);
              let i = this.tsTryParseTypeParameters(this.tsParseInOutModifiers.bind(this));
              i && (e.typeParameters = i);
            }
            parseClassPropertyAnnotation(e) {
              !e.optional && this.eat(35) && (e.definite = true);
              let s = this.tsTryParseTypeAnnotation();
              s && (e.typeAnnotation = s);
            }
            parseClassProperty(e) {
              if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && this.match(29) && this.raise(S.DeclareClassFieldHasInitializer, { at: this.state.startLoc }), e.abstract && this.match(29)) {
                let { key: s } = e;
                this.raise(S.AbstractPropertyHasInitializer, { at: this.state.startLoc, propertyName: s.type === "Identifier" && !e.computed ? s.name : "[".concat(this.input.slice(s.start, s.end), "]") });
              }
              return super.parseClassProperty(e);
            }
            parseClassPrivateProperty(e) {
              return e.abstract && this.raise(S.PrivateElementHasAbstract, { at: e }), e.accessibility && this.raise(S.PrivateElementHasAccessibility, { at: e, modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
            }
            pushClassMethod(e, s, r, i, a, n) {
              let o = this.tsTryParseTypeParameters();
              o && a && this.raise(S.ConstructorHasTypeParameters, { at: o });
              let { declare: c = false, kind: f } = s;
              c && (f === "get" || f === "set") && this.raise(S.DeclareAccessor, { at: s, kind: f }), o && (s.typeParameters = o), super.pushClassMethod(e, s, r, i, a, n);
            }
            pushClassPrivateMethod(e, s, r, i) {
              let a = this.tsTryParseTypeParameters();
              a && (s.typeParameters = a), super.pushClassPrivateMethod(e, s, r, i);
            }
            declareClassPrivateMethodInScope(e, s) {
              e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !e.value.body || super.declareClassPrivateMethodInScope(e, s));
            }
            parseClassSuper(e) {
              super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(110) && (e.implements = this.tsParseHeritageClause("implements"));
            }
            parseObjPropValue(e) {
              let s = this.tsTryParseTypeParameters();
              s && (e.typeParameters = s);
              for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
                i[a - 1] = arguments[a];
              super.parseObjPropValue(e, ...i);
            }
            parseFunctionParams(e, s) {
              let r = this.tsTryParseTypeParameters();
              r && (e.typeParameters = r), super.parseFunctionParams(e, s);
            }
            parseVarId(e, s) {
              super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
              let r = this.tsTryParseTypeAnnotation();
              r && (e.id.typeAnnotation = r, this.resetEndLocation(e.id));
            }
            parseAsyncArrowFromCallExpression(e, s) {
              return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
            }
            parseMaybeAssign() {
              for (var e = arguments.length, s = new Array(e), r = 0; r < e; r++)
                s[r] = arguments[r];
              var i, a, n, o, c, f, y;
              let P, v, N;
              if (this.hasPlugin("jsx") && (this.match(138) || this.match(47))) {
                if (P = this.state.clone(), v = this.tryParse(() => super.parseMaybeAssign(...s), P), !v.error)
                  return v.node;
                let { context: Q } = this.state, re = Q[Q.length - 1];
                (re === z.j_oTag || re === z.j_expr) && Q.pop();
              }
              if (!((i = v) != null && i.error) && !this.match(47))
                return super.parseMaybeAssign(...s);
              let B;
              P = P || this.state.clone();
              let _ = this.tryParse((Q) => {
                var re, ne, $e;
                B = this.tsParseTypeParameters();
                let le = super.parseMaybeAssign(...s);
                return (le.type !== "ArrowFunctionExpression" || (re = le.extra) != null && re.parenthesized) && Q(), ((ne = B) == null ? void 0 : ne.params.length) !== 0 && this.resetStartLocationFromNode(le, B), le.typeParameters = B, this.hasPlugin("jsx") && le.typeParameters.params.length === 1 && !(($e = le.typeParameters.extra) != null && $e.trailingComma) && le.typeParameters.params[0].constraint, le;
              }, P);
              if (!_.error && !_.aborted)
                return B && this.reportReservedArrowTypeParam(B), _.node;
              if (!v && (Br(!this.hasPlugin("jsx")), N = this.tryParse(() => super.parseMaybeAssign(...s), P), !N.error))
                return N.node;
              if ((a = v) != null && a.node)
                return this.state = v.failState, v.node;
              if (_.node)
                return this.state = _.failState, B && this.reportReservedArrowTypeParam(B), _.node;
              if ((n = N) != null && n.node)
                return this.state = N.failState, N.node;
              throw (o = v) != null && o.thrown ? v.error : _.thrown ? _.error : (c = N) != null && c.thrown ? N.error : ((f = v) == null ? void 0 : f.error) || _.error || ((y = N) == null ? void 0 : y.error);
            }
            reportReservedArrowTypeParam(e) {
              var s;
              e.params.length === 1 && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(S.ReservedArrowTypeParam, { at: e });
            }
            parseMaybeUnary(e) {
              return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e);
            }
            parseArrow(e) {
              if (this.match(14)) {
                let s = this.tryParse((r) => {
                  let i = this.tsParseTypeOrTypePredicateAnnotation(14);
                  return (this.canInsertSemicolon() || !this.match(19)) && r(), i;
                });
                if (s.aborted)
                  return;
                s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
              }
              return super.parseArrow(e);
            }
            parseAssignableListItemTypes(e) {
              this.eat(17) && (e.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType && this.raise(S.PatternIsOptional, { at: e }), e.optional = true);
              let s = this.tsTryParseTypeAnnotation();
              return s && (e.typeAnnotation = s), this.resetEndLocation(e), e;
            }
            isAssignable(e, s) {
              switch (e.type) {
                case "TSTypeCastExpression":
                  return this.isAssignable(e.expression, s);
                case "TSParameterProperty":
                  return true;
                default:
                  return super.isAssignable(e, s);
              }
            }
            toAssignable(e) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              switch (e.type) {
                case "ParenthesizedExpression":
                  this.toAssignableParenthesizedExpression(e, s);
                  break;
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                  s ? this.expressionScope.recordArrowParemeterBindingError(S.UnexpectedTypeCastInParameter, { at: e }) : this.raise(S.UnexpectedTypeCastInParameter, { at: e }), this.toAssignable(e.expression, s);
                  break;
                case "AssignmentExpression":
                  !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
                default:
                  super.toAssignable(e, s);
              }
            }
            toAssignableParenthesizedExpression(e, s) {
              switch (e.expression.type) {
                case "TSAsExpression":
                case "TSNonNullExpression":
                case "TSTypeAssertion":
                case "ParenthesizedExpression":
                  this.toAssignable(e.expression, s);
                  break;
                default:
                  super.toAssignable(e, s);
              }
            }
            checkToRestConversion(e, s) {
              switch (e.type) {
                case "TSAsExpression":
                case "TSTypeAssertion":
                case "TSNonNullExpression":
                  this.checkToRestConversion(e.expression, false);
                  break;
                default:
                  super.checkToRestConversion(e, s);
              }
            }
            isValidLVal(e, s, r) {
              return Mh({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSAsExpression: (r !== we || !s) && ["expression", true], TSTypeAssertion: (r !== we || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, r);
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 78:
                  return this.parseIdentifier(true);
                default:
                  return super.parseBindingAtom();
              }
            }
            parseMaybeDecoratorArguments(e) {
              if (this.match(47) || this.match(51)) {
                let s = this.tsParseTypeArgumentsInExpression();
                if (this.match(10)) {
                  let r = super.parseMaybeDecoratorArguments(e);
                  return r.typeParameters = s, r;
                }
                this.unexpected(null, 10);
              }
              return super.parseMaybeDecoratorArguments(e);
            }
            checkCommaAfterRest(e) {
              return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
            }
            isClassMethod() {
              return this.match(47) || super.isClassMethod();
            }
            isClassProperty() {
              return this.match(35) || this.match(14) || super.isClassProperty();
            }
            parseMaybeDefault() {
              let e = super.parseMaybeDefault(...arguments);
              return e.type === "AssignmentPattern" && e.typeAnnotation && e.right.start < e.typeAnnotation.start && this.raise(S.TypeAnnotationAfterAssign, { at: e.typeAnnotation }), e;
            }
            getTokenFromCode(e) {
              if (this.state.inType) {
                if (e === 62)
                  return this.finishOp(48, 1);
                if (e === 60)
                  return this.finishOp(47, 1);
              }
              return super.getTokenFromCode(e);
            }
            reScan_lt_gt() {
              let { type: e } = this.state;
              e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
            }
            reScan_lt() {
              let { type: e } = this.state;
              return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
            }
            toAssignableList(e) {
              for (let s = 0; s < e.length; s++) {
                let r = e[s];
                (r == null ? void 0 : r.type) === "TSTypeCastExpression" && (e[s] = this.typeCastToParameter(r));
              }
              super.toAssignableList(...arguments);
            }
            typeCastToParameter(e) {
              return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
            }
            shouldParseArrow(e) {
              return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
            }
            shouldParseAsyncArrow() {
              return this.match(14) || super.shouldParseAsyncArrow();
            }
            canHaveLeadingDecorator() {
              return super.canHaveLeadingDecorator() || this.isAbstractClass();
            }
            jsxParseOpeningElementAfterName(e) {
              if (this.match(47) || this.match(51)) {
                let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
                s && (e.typeParameters = s);
              }
              return super.jsxParseOpeningElementAfterName(e);
            }
            getGetterSetterExpectedParamCount(e) {
              let s = super.getGetterSetterExpectedParamCount(e), i = this.getObjectOrClassMethodParams(e)[0];
              return i && this.isThisParam(i) ? s + 1 : s;
            }
            parseCatchClauseParam() {
              let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
              return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
            }
            tsInAmbientContext(e) {
              let s = this.state.isAmbientContext;
              this.state.isAmbientContext = true;
              try {
                return e();
              } finally {
                this.state.isAmbientContext = s;
              }
            }
            parseClass(e) {
              let s = this.state.inAbstractClass;
              this.state.inAbstractClass = !!e.abstract;
              try {
                for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)
                  i[a - 1] = arguments[a];
                return super.parseClass(e, ...i);
              } finally {
                this.state.inAbstractClass = s;
              }
            }
            tsParseAbstractDeclaration(e) {
              if (this.match(80))
                return e.abstract = true, this.parseClass(e, true, false);
              if (this.isContextual(125)) {
                if (!this.hasFollowingLineBreak())
                  return e.abstract = true, this.raise(S.NonClassMethodPropertyHasAbstractModifer, { at: e }), this.tsParseInterfaceDeclaration(e);
              } else
                this.unexpected(null, 80);
            }
            parseMethod() {
              let e = super.parseMethod(...arguments);
              if (e.abstract && (this.hasPlugin("estree") ? !!e.value.body : !!e.body)) {
                let { key: r } = e;
                this.raise(S.AbstractMethodHasImplementation, { at: e, methodName: r.type === "Identifier" && !e.computed ? r.name : "[".concat(this.input.slice(r.start, r.end), "]") });
              }
              return e;
            }
            tsParseTypeParameterName() {
              return this.parseIdentifier().name;
            }
            shouldParseAsAmbientContext() {
              return !!this.getPluginOption("typescript", "dts");
            }
            parse() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
            }
            getExpression() {
              return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
            }
            parseExportSpecifier(e, s, r, i) {
              return !s && i ? (this.parseTypeOnlyImportExportSpecifier(e, false, r), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, r, i));
            }
            parseImportSpecifier(e, s, r, i) {
              return !s && i ? (this.parseTypeOnlyImportExportSpecifier(e, true, r), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, r, i));
            }
            parseTypeOnlyImportExportSpecifier(e, s, r) {
              let i = s ? "imported" : "local", a = s ? "local" : "exported", n = e[i], o, c = false, f = true, y = n.loc.start;
              if (this.isContextual(93)) {
                let v = this.parseIdentifier();
                if (this.isContextual(93)) {
                  let N = this.parseIdentifier();
                  pe(this.state.type) ? (c = true, n = v, o = s ? this.parseIdentifier() : this.parseModuleExportName(), f = false) : (o = N, f = false);
                } else
                  pe(this.state.type) ? (f = false, o = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = true, n = v);
              } else
                pe(this.state.type) && (c = true, s ? (n = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(n.name, n.loc.start, true, true)) : n = this.parseModuleExportName());
              c && r && this.raise(s ? S.TypeModifierIsUsedInTypeImports : S.TypeModifierIsUsedInTypeExports, { at: y }), e[i] = n, e[a] = o;
              let P = s ? "importKind" : "exportKind";
              e[P] = c ? "type" : "value", f && this.eatContextual(93) && (e[a] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[a] || (e[a] = ge(e[i])), s && this.checkIdentifier(e[a], xe);
            }
          };
          function zh(t) {
            if (t.type !== "MemberExpression")
              return false;
            let { computed: e, property: s } = t;
            return e && s.type !== "StringLiteral" && (s.type !== "TemplateLiteral" || s.expressions.length > 0) ? false : Rr(t.object);
          }
          function Rr(t) {
            return t.type === "Identifier" ? true : t.type !== "MemberExpression" || t.computed ? false : Rr(t.object);
          }
          var jr = j(Hn || (Hn = rt(["placeholders"])))((t) => ({ ClassNameIsRequired: t("A class name is required."), UnexpectedSpace: t("Unexpected space in placeholder.") })), Kh = (t) => class extends t {
            parsePlaceholder(e) {
              if (this.match(140)) {
                let s = this.startNode();
                return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(140), this.finishPlaceholder(s, e);
              }
            }
            finishPlaceholder(e, s) {
              let r = !!(e.expectedNode && e.type === "Placeholder");
              return e.expectedNode = s, r ? e : this.finishNode(e, "Placeholder");
            }
            getTokenFromCode(e) {
              return e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(140, 2) : super.getTokenFromCode(...arguments);
            }
            parseExprAtom() {
              return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
            }
            parseIdentifier() {
              return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
            }
            checkReservedWord(e) {
              e !== void 0 && super.checkReservedWord(...arguments);
            }
            parseBindingAtom() {
              return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
            }
            isValidLVal(e) {
              for (var s = arguments.length, r = new Array(s > 1 ? s - 1 : 0), i = 1; i < s; i++)
                r[i - 1] = arguments[i];
              return e === "Placeholder" || super.isValidLVal(e, ...r);
            }
            toAssignable(e) {
              e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(...arguments);
            }
            isLet(e) {
              return super.isLet(e) ? true : !this.isContextual(99) || e ? false : this.lookahead().type === 140;
            }
            verifyBreakContinue(e) {
              e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
            }
            parseExpressionStatement(e, s) {
              if (s.type !== "Placeholder" || s.extra && s.extra.parenthesized)
                return super.parseExpressionStatement(...arguments);
              if (this.match(14)) {
                let r = e;
                return r.label = this.finishPlaceholder(s, "Identifier"), this.next(), r.body = this.parseStatement("label"), this.finishNode(r, "LabeledStatement");
              }
              return this.semicolon(), e.name = s.name, this.finishPlaceholder(e, "Statement");
            }
            parseBlock() {
              return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
            }
            parseFunctionId() {
              return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
            }
            parseClass(e, s, r) {
              let i = s ? "ClassDeclaration" : "ClassExpression";
              this.next(), this.takeDecorators(e);
              let a = this.state.strict, n = this.parsePlaceholder("Identifier");
              if (n)
                if (this.match(81) || this.match(140) || this.match(5))
                  e.id = n;
                else {
                  if (r || !s)
                    return e.id = null, e.body = this.finishPlaceholder(n, "ClassBody"), this.finishNode(e, i);
                  throw this.raise(jr.ClassNameIsRequired, { at: this.state.startLoc });
                }
              else
                this.parseClassId(e, s, r);
              return this.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e.superClass, a), this.finishNode(e, i);
            }
            parseExport(e) {
              let s = this.parsePlaceholder("Identifier");
              if (!s)
                return super.parseExport(...arguments);
              if (!this.isContextual(97) && !this.match(12))
                return e.specifiers = [], e.source = null, e.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(e, "ExportNamedDeclaration");
              this.expectPlugin("exportDefaultFrom");
              let r = this.startNode();
              return r.exported = s, e.specifiers = [this.finishNode(r, "ExportDefaultSpecifier")], super.parseExport(e);
            }
            isExportDefaultSpecifier() {
              if (this.match(65)) {
                let e = this.nextTokenStart();
                if (this.isUnparsedContextual(e, "from") && this.input.startsWith(Pe(140), this.nextTokenStartSince(e + 4)))
                  return true;
              }
              return super.isExportDefaultSpecifier();
            }
            maybeParseExportDefaultSpecifier(e) {
              return e.specifiers && e.specifiers.length > 0 ? true : super.maybeParseExportDefaultSpecifier(...arguments);
            }
            checkExport(e) {
              let { specifiers: s } = e;
              s != null && s.length && (e.specifiers = s.filter((r) => r.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
            }
            parseImport(e) {
              let s = this.parsePlaceholder("Identifier");
              if (!s)
                return super.parseImport(...arguments);
              if (e.specifiers = [], !this.isContextual(97) && !this.match(12))
                return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
              let r = this.startNodeAtNode(s);
              return r.local = s, this.finishNode(r, "ImportDefaultSpecifier"), e.specifiers.push(r), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(97), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
            }
            parseImportSource() {
              return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
            }
            assertNoSpace() {
              this.state.start > this.state.lastTokEndLoc.index && this.raise(jr.UnexpectedSpace, { at: this.state.lastTokEndLoc });
            }
          }, Vh = (t) => class extends t {
            parseV8Intrinsic() {
              if (this.match(54)) {
                let e = this.state.startLoc, s = this.startNode();
                if (this.next(), K(this.state.type)) {
                  let r = this.parseIdentifierName(this.state.start), i = this.createIdentifier(s, r);
                  if (i.type = "V8IntrinsicIdentifier", this.match(10))
                    return i;
                }
                this.unexpected(e);
              }
            }
            parseExprAtom() {
              return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
            }
          };
          function ee(t, e) {
            let [s, r] = typeof e == "string" ? [e, {}] : e, i = Object.keys(r), a = i.length === 0;
            return t.some((n) => {
              if (typeof n == "string")
                return a && n === s;
              {
                let [o, c] = n;
                if (o !== s)
                  return false;
                for (let f of i)
                  if (c[f] !== r[f])
                    return false;
                return true;
              }
            });
          }
          function Je(t, e, s) {
            let r = t.find((i) => Array.isArray(i) ? i[0] === e : i === e);
            return r && Array.isArray(r) ? r[1][s] : null;
          }
          var qr = ["minimal", "fsharp", "hack", "smart"], Ur = ["^^", "@@", "^", "%", "#"], _r = ["hash", "bar"];
          function Hh(t) {
            if (ee(t, "decorators")) {
              if (ee(t, "decorators-legacy"))
                throw new Error("Cannot use the decorators and decorators-legacy plugin together");
              let e = Je(t, "decorators", "decoratorsBeforeExport");
              if (e == null)
                throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
              if (typeof e != "boolean")
                throw new Error("'decoratorsBeforeExport' must be a boolean.");
            }
            if (ee(t, "flow") && ee(t, "typescript"))
              throw new Error("Cannot combine flow and typescript plugins.");
            if (ee(t, "placeholders") && ee(t, "v8intrinsic"))
              throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
            if (ee(t, "pipelineOperator")) {
              let e = Je(t, "pipelineOperator", "proposal");
              if (!qr.includes(e)) {
                let r = qr.map((i) => '"'.concat(i, '"')).join(", ");
                throw new Error('"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(r, "."));
              }
              let s = ee(t, ["recordAndTuple", { syntaxType: "hash" }]);
              if (e === "hack") {
                if (ee(t, "placeholders"))
                  throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
                if (ee(t, "v8intrinsic"))
                  throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
                let r = Je(t, "pipelineOperator", "topicToken");
                if (!Ur.includes(r)) {
                  let i = Ur.map((a) => '"'.concat(a, '"')).join(", ");
                  throw new Error('"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(i, "."));
                }
                if (r === "#" && s)
                  throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
              } else if (e === "smart" && s)
                throw new Error('Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.');
            }
            if (ee(t, "moduleAttributes")) {
              if (ee(t, "importAssertions"))
                throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
              if (Je(t, "moduleAttributes", "version") !== "may-2020")
                throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
            }
            if (ee(t, "recordAndTuple") && !_r.includes(Je(t, "recordAndTuple", "syntaxType")))
              throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + _r.map((e) => "'".concat(e, "'")).join(", "));
            if (ee(t, "asyncDoExpressions") && !ee(t, "doExpressions")) {
              let e = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
              throw e.missingPlugins = "doExpressions", e;
            }
          }
          var zr = { estree: Oe, jsx: Lh, flow: Dh, typescript: _h, v8intrinsic: Vh, placeholders: Kh }, Wh = Object.keys(zr), Kr = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true };
          function Gh(t) {
            let e = {};
            for (let s of Object.keys(Kr))
              e[s] = t && t[s] != null ? t[s] : Kr[s];
            return e;
          }
          var Xh = (t, e) => Object.hasOwnProperty.call(t, e) && t[e], Vr = (t) => t.type === "ParenthesizedExpression" ? Vr(t.expression) : t, Jh = class extends vh {
            toAssignable(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var s, r;
              let i;
              switch ((t.type === "ParenthesizedExpression" || (s = t.extra) != null && s.parenthesized) && (i = Vr(t), e ? i.type === "Identifier" ? this.expressionScope.recordArrowParemeterBindingError(u.InvalidParenthesizedAssignment, { at: t }) : i.type !== "MemberExpression" && this.raise(u.InvalidParenthesizedAssignment, { at: t }) : this.raise(u.InvalidParenthesizedAssignment, { at: t })), t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  break;
                case "ObjectExpression":
                  t.type = "ObjectPattern";
                  for (let n = 0, o = t.properties.length, c = o - 1; n < o; n++) {
                    var a;
                    let f = t.properties[n], y = n === c;
                    this.toAssignableObjectExpressionProp(f, y, e), y && f.type === "RestElement" && (a = t.extra) != null && a.trailingCommaLoc && this.raise(u.RestTrailingComma, { at: t.extra.trailingCommaLoc });
                  }
                  break;
                case "ObjectProperty": {
                  let { key: n, value: o } = t;
                  this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(o, e);
                  break;
                }
                case "SpreadElement":
                  throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
                case "ArrayExpression":
                  t.type = "ArrayPattern", this.toAssignableList(t.elements, (r = t.extra) == null ? void 0 : r.trailingCommaLoc, e);
                  break;
                case "AssignmentExpression":
                  t.operator !== "=" && this.raise(u.MissingEqInAssignment, { at: t.left.loc.end }), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
                  break;
                case "ParenthesizedExpression":
                  this.toAssignable(i, e);
                  break;
              }
            }
            toAssignableObjectExpressionProp(t, e, s) {
              if (t.type === "ObjectMethod")
                this.raise(t.kind === "get" || t.kind === "set" ? u.PatternHasAccessor : u.PatternHasMethod, { at: t.key });
              else if (t.type === "SpreadElement") {
                t.type = "RestElement";
                let r = t.argument;
                this.checkToRestConversion(r, false), this.toAssignable(r, s), e || this.raise(u.RestTrailingComma, { at: t });
              } else
                this.toAssignable(t, s);
            }
            toAssignableList(t, e, s) {
              let r = t.length - 1;
              for (let i = 0; i <= r; i++) {
                let a = t[i];
                if (!!a) {
                  if (a.type === "SpreadElement") {
                    a.type = "RestElement";
                    let n = a.argument;
                    this.checkToRestConversion(n, true), this.toAssignable(n, s);
                  } else
                    this.toAssignable(a, s);
                  a.type === "RestElement" && (i < r ? this.raise(u.RestTrailingComma, { at: a }) : e && this.raise(u.RestTrailingComma, { at: e }));
                }
              }
            }
            isAssignable(t, e) {
              switch (t.type) {
                case "Identifier":
                case "ObjectPattern":
                case "ArrayPattern":
                case "AssignmentPattern":
                case "RestElement":
                  return true;
                case "ObjectExpression": {
                  let s = t.properties.length - 1;
                  return t.properties.every((r, i) => r.type !== "ObjectMethod" && (i === s || r.type !== "SpreadElement") && this.isAssignable(r));
                }
                case "ObjectProperty":
                  return this.isAssignable(t.value);
                case "SpreadElement":
                  return this.isAssignable(t.argument);
                case "ArrayExpression":
                  return t.elements.every((s) => s === null || this.isAssignable(s));
                case "AssignmentExpression":
                  return t.operator === "=";
                case "ParenthesizedExpression":
                  return this.isAssignable(t.expression);
                case "MemberExpression":
                case "OptionalMemberExpression":
                  return !e;
                default:
                  return false;
              }
            }
            toReferencedList(t, e) {
              return t;
            }
            toReferencedListDeep(t, e) {
              this.toReferencedList(t, e);
              for (let s of t)
                (s == null ? void 0 : s.type) === "ArrayExpression" && this.toReferencedListDeep(s.elements);
            }
            parseSpread(t, e) {
              let s = this.startNode();
              return this.next(), s.argument = this.parseMaybeAssignAllowIn(t, void 0, e), this.finishNode(s, "SpreadElement");
            }
            parseRestBinding() {
              let t = this.startNode();
              return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
            }
            parseBindingAtom() {
              switch (this.state.type) {
                case 0: {
                  let t = this.startNode();
                  return this.next(), t.elements = this.parseBindingList(3, 93, true), this.finishNode(t, "ArrayPattern");
                }
                case 5:
                  return this.parseObjectLike(8, true);
              }
              return this.parseIdentifier();
            }
            parseBindingList(t, e, s, r) {
              let i = [], a = true;
              for (; !this.eat(t); )
                if (a ? a = false : this.expect(12), s && this.match(12))
                  i.push(null);
                else {
                  if (this.eat(t))
                    break;
                  if (this.match(21)) {
                    if (i.push(this.parseAssignableListItemTypes(this.parseRestBinding())), !this.checkCommaAfterRest(e)) {
                      this.expect(t);
                      break;
                    }
                  } else {
                    let n = [];
                    for (this.match(26) && this.hasPlugin("decorators") && this.raise(u.UnsupportedParameterDecorator, { at: this.state.startLoc }); this.match(26); )
                      n.push(this.parseDecorator());
                    i.push(this.parseAssignableListItem(r, n));
                  }
                }
              return i;
            }
            parseBindingRestProperty(t) {
              return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
            }
            parseBindingProperty() {
              let t = this.startNode(), { type: e, start: s, startLoc: r } = this.state;
              return e === 21 ? this.parseBindingRestProperty(t) : (e === 134 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), t.key = this.parsePrivateName()) : this.parsePropertyName(t), t.method = false, this.parseObjPropValue(t, s, r, false, false, true, false), t);
            }
            parseAssignableListItem(t, e) {
              let s = this.parseMaybeDefault();
              this.parseAssignableListItemTypes(s);
              let r = this.parseMaybeDefault(s.start, s.loc.start, s);
              return e.length && (s.decorators = e), r;
            }
            parseAssignableListItemTypes(t) {
              return t;
            }
            parseMaybeDefault(t, e, s) {
              var r, i, a;
              if (e = (r = e) != null ? r : this.state.startLoc, t = (i = t) != null ? i : this.state.start, s = (a = s) != null ? a : this.parseBindingAtom(), !this.eat(29))
                return s;
              let n = this.startNodeAt(t, e);
              return n.left = s, n.right = this.parseMaybeAssignAllowIn(), this.finishNode(n, "AssignmentPattern");
            }
            isValidLVal(t, e, s) {
              return Xh({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
            }
            checkLVal(t, e) {
              let { in: s, binding: r = we, checkClashes: i = false, strictModeChanged: a = false, allowingSloppyLetBinding: n = !(r & Te), hasParenthesizedAncestor: o = false } = e;
              var c;
              let f = t.type;
              if (this.isObjectMethod(t))
                return;
              if (f === "MemberExpression") {
                r !== we && this.raise(u.InvalidPropertyBindingPattern, { at: t });
                return;
              }
              if (t.type === "Identifier") {
                this.checkIdentifier(t, r, a, n);
                let { name: B } = t;
                i && (i.has(B) ? this.raise(u.ParamDupe, { at: t }) : i.add(B));
                return;
              }
              let y = this.isValidLVal(t.type, !(o || (c = t.extra) != null && c.parenthesized) && s.type === "AssignmentExpression", r);
              if (y === true)
                return;
              if (y === false) {
                let B = r === we ? u.InvalidLhs : u.InvalidLhsBinding;
                this.raise(B, { at: t, ancestor: s.type === "UpdateExpression" ? { type: "UpdateExpression", prefix: s.prefix } : { type: s.type } });
                return;
              }
              let [P, v] = Array.isArray(y) ? y : [y, f === "ParenthesizedExpression"], N = t.type === "ArrayPattern" || t.type === "ObjectPattern" || t.type === "ParenthesizedExpression" ? t : s;
              for (let B of [].concat(t[P]))
                B && this.checkLVal(B, { in: N, binding: r, checkClashes: i, allowingSloppyLetBinding: n, strictModeChanged: a, hasParenthesizedAncestor: v });
            }
            checkIdentifier(t, e) {
              let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !(e & Te);
              this.state.strict && (s ? mr(t.name, this.inModule) : dr(t.name)) && (e === we ? this.raise(u.StrictEvalArguments, { at: t, referenceName: t.name }) : this.raise(u.StrictEvalArgumentsBinding, { at: t, bindingName: t.name })), !r && t.name === "let" && this.raise(u.LetInLexicalBinding, { at: t }), e & we || this.declareNameFromIdentifier(t, e);
            }
            declareNameFromIdentifier(t, e) {
              this.scope.declareName(t.name, e, t.loc.start);
            }
            checkToRestConversion(t, e) {
              switch (t.type) {
                case "ParenthesizedExpression":
                  this.checkToRestConversion(t.expression, e);
                  break;
                case "Identifier":
                case "MemberExpression":
                  break;
                case "ArrayExpression":
                case "ObjectExpression":
                  if (e)
                    break;
                default:
                  this.raise(u.InvalidRestAssignmentPattern, { at: t });
              }
            }
            checkCommaAfterRest(t) {
              return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? u.RestTrailingComma : u.ElementAfterRest, { at: this.state.startLoc }), true) : false;
            }
          }, Yh = class extends Jh {
            checkProto(t, e, s, r) {
              if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
                return;
              let i = t.key;
              if ((i.type === "Identifier" ? i.name : i.value) === "__proto__") {
                if (e) {
                  this.raise(u.RecordNoProto, { at: i });
                  return;
                }
                s.used && (r ? r.doubleProtoLoc === null && (r.doubleProtoLoc = i.loc.start) : this.raise(u.DuplicateProto, { at: i })), s.used = true;
              }
            }
            shouldExitDescending(t, e) {
              return t.type === "ArrowFunctionExpression" && t.start === e;
            }
            getExpression() {
              this.enterInitialScopes(), this.nextToken();
              let t = this.parseExpression();
              return this.match(135) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.state.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
            }
            parseExpression(t, e) {
              return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
            }
            parseExpressionBase(t) {
              let e = this.state.start, s = this.state.startLoc, r = this.parseMaybeAssign(t);
              if (this.match(12)) {
                let i = this.startNodeAt(e, s);
                for (i.expressions = [r]; this.eat(12); )
                  i.expressions.push(this.parseMaybeAssign(t));
                return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
              }
              return r;
            }
            parseMaybeAssignDisallowIn(t, e) {
              return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
            }
            parseMaybeAssignAllowIn(t, e) {
              return this.allowInAnd(() => this.parseMaybeAssign(t, e));
            }
            setOptionalParametersError(t, e) {
              var s;
              t.optionalParametersLoc = (s = e == null ? void 0 : e.loc) != null ? s : this.state.startLoc;
            }
            parseMaybeAssign(t, e) {
              let s = this.state.start, r = this.state.startLoc;
              if (this.isContextual(105) && this.prodParam.hasYield) {
                let o = this.parseYield();
                return e && (o = e.call(this, o, s, r)), o;
              }
              let i;
              t ? i = false : (t = new At(), i = true);
              let { type: a } = this.state;
              (a === 10 || K(a)) && (this.state.potentialArrowAt = this.state.start);
              let n = this.parseMaybeConditional(t);
              if (e && (n = e.call(this, n, s, r)), wo(this.state.type)) {
                let o = this.startNodeAt(s, r), c = this.state.value;
                return o.operator = c, this.match(29) ? (this.toAssignable(n, true), o.left = n, t.doubleProtoLoc != null && t.doubleProtoLoc.index >= s && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= s && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= s && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null)) : o.left = n, this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(n, { in: this.finishNode(o, "AssignmentExpression") }), o;
              } else
                i && this.checkExpressionErrors(t, true);
              return n;
            }
            parseMaybeConditional(t) {
              let e = this.state.start, s = this.state.startLoc, r = this.state.potentialArrowAt, i = this.parseExprOps(t);
              return this.shouldExitDescending(i, r) ? i : this.parseConditional(i, e, s, t);
            }
            parseConditional(t, e, s, r) {
              if (this.eat(17)) {
                let i = this.startNodeAt(e, s);
                return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
              }
              return t;
            }
            parseMaybeUnaryOrPrivate(t) {
              return this.match(134) ? this.parsePrivateName() : this.parseMaybeUnary(t);
            }
            parseExprOps(t) {
              let e = this.state.start, s = this.state.startLoc, r = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
              return this.shouldExitDescending(i, r) ? i : this.parseExprOp(i, e, s, -1);
            }
            parseExprOp(t, e, s, r) {
              if (this.isPrivateName(t)) {
                let a = this.getPrivateNameSV(t);
                (r >= at(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(u.PrivateInExpectedIn, { at: t, identifierName: a }), this.classScope.usePrivateName(a, t.loc.start);
              }
              let i = this.state.type;
              if (Io(i) && (this.prodParam.hasIn || !this.match(58))) {
                let a = at(i);
                if (a > r) {
                  if (i === 39) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                      return t;
                    this.checkPipelineAtInfixOperator(t, s);
                  }
                  let n = this.startNodeAt(e, s);
                  n.left = t, n.operator = this.state.value;
                  let o = i === 41 || i === 42, c = i === 40;
                  if (c && (a = at(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait)
                    throw this.raise(u.UnexpectedAwaitAfterPipelineBody, { at: this.state.startLoc });
                  n.right = this.parseExprOpRightExpr(i, a), this.finishNode(n, o || c ? "LogicalExpression" : "BinaryExpression");
                  let f = this.state.type;
                  if (c && (f === 41 || f === 42) || o && f === 40)
                    throw this.raise(u.MixingCoalesceWithLogical, { at: this.state.startLoc });
                  return this.parseExprOp(n, e, s, r);
                }
              }
              return t;
            }
            parseExprOpRightExpr(t, e) {
              let s = this.state.start, r = this.state.startLoc;
              switch (t) {
                case 39:
                  switch (this.getPluginOption("pipelineOperator", "proposal")) {
                    case "hack":
                      return this.withTopicBindingContext(() => this.parseHackPipeBody());
                    case "smart":
                      return this.withTopicBindingContext(() => {
                        if (this.prodParam.hasYield && this.isContextual(105))
                          throw this.raise(u.PipeBodyIsTighter, { at: this.state.startLoc });
                        return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, e), s, r);
                      });
                    case "fsharp":
                      return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
                  }
                default:
                  return this.parseExprOpBaseRightExpr(t, e);
              }
            }
            parseExprOpBaseRightExpr(t, e) {
              let s = this.state.start, r = this.state.startLoc;
              return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, r, Bo(t) ? e - 1 : e);
            }
            parseHackPipeBody() {
              var t;
              let { startLoc: e } = this.state, s = this.parseMaybeAssign();
              return R.has(s.type) && !((t = s.extra) != null && t.parenthesized) && this.raise(u.PipeUnparenthesizedBody, { at: e, type: s.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(u.PipeTopicUnused, { at: e }), s;
            }
            checkExponentialAfterUnary(t) {
              this.match(57) && this.raise(u.UnexpectedTokenUnaryExponentiation, { at: t.argument });
            }
            parseMaybeUnary(t, e) {
              let s = this.state.start, r = this.state.startLoc, i = this.isContextual(96);
              if (i && this.isAwaitAllowed()) {
                this.next();
                let c = this.parseAwait(s, r);
                return e || this.checkExponentialAfterUnary(c), c;
              }
              let a = this.match(34), n = this.startNode();
              if (Do(this.state.type)) {
                n.operator = this.state.value, n.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
                let c = this.match(89);
                if (this.next(), n.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && c) {
                  let f = n.argument;
                  f.type === "Identifier" ? this.raise(u.StrictDelete, { at: n }) : this.hasPropertyAsPrivateName(f) && this.raise(u.DeletePrivateField, { at: n });
                }
                if (!a)
                  return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
              }
              let o = this.parseUpdate(n, a, t);
              if (i) {
                let { type: c } = this.state;
                if ((this.hasPlugin("v8intrinsic") ? Vt(c) : Vt(c) && !this.match(54)) && !this.isAmbiguousAwait())
                  return this.raiseOverwrite(u.AwaitNotInAsyncContext, { at: r }), this.parseAwait(s, r);
              }
              return o;
            }
            parseUpdate(t, e, s) {
              if (e)
                return this.checkLVal(t.argument, { in: this.finishNode(t, "UpdateExpression") }), t;
              let r = this.state.start, i = this.state.startLoc, a = this.parseExprSubscripts(s);
              if (this.checkExpressionErrors(s, false))
                return a;
              for (; ko(this.state.type) && !this.canInsertSemicolon(); ) {
                let n = this.startNodeAt(r, i);
                n.operator = this.state.value, n.prefix = false, n.argument = a, this.next(), this.checkLVal(a, { in: a = this.finishNode(n, "UpdateExpression") });
              }
              return a;
            }
            parseExprSubscripts(t) {
              let e = this.state.start, s = this.state.startLoc, r = this.state.potentialArrowAt, i = this.parseExprAtom(t);
              return this.shouldExitDescending(i, r) ? i : this.parseSubscripts(i, e, s);
            }
            parseSubscripts(t, e, s, r) {
              let i = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
              do
                t = this.parseSubscript(t, e, s, r, i), i.maybeAsyncArrow = false;
              while (!i.stop);
              return t;
            }
            parseSubscript(t, e, s, r, i) {
              let { type: a } = this.state;
              if (!r && a === 15)
                return this.parseBind(t, e, s, r, i);
              if (nt(a))
                return this.parseTaggedTemplateExpression(t, e, s, i);
              let n = false;
              if (a === 18) {
                if (r && this.lookaheadCharCode() === 40)
                  return i.stop = true, t;
                i.optionalChainMember = n = true, this.next();
              }
              if (!r && this.match(10))
                return this.parseCoverCallAndAsyncArrowHead(t, e, s, i, n);
              {
                let o = this.eat(0);
                return o || n || this.eat(16) ? this.parseMember(t, e, s, i, o, n) : (i.stop = true, t);
              }
            }
            parseMember(t, e, s, r, i, a) {
              let n = this.startNodeAt(e, s);
              return n.object = t, n.computed = i, i ? (n.property = this.parseExpression(), this.expect(3)) : this.match(134) ? (t.type === "Super" && this.raise(u.SuperPrivateField, { at: s }), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(true), r.optionalChainMember ? (n.optional = a, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
            }
            parseBind(t, e, s, r, i) {
              let a = this.startNodeAt(e, s);
              return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), i.stop = true, this.parseSubscripts(this.finishNode(a, "BindExpression"), e, s, r);
            }
            parseCoverCallAndAsyncArrowHead(t, e, s, r, i) {
              let a = this.state.maybeInArrowParameters, n = null;
              this.state.maybeInArrowParameters = true, this.next();
              let o = this.startNodeAt(e, s);
              o.callee = t;
              let { maybeAsyncArrow: c, optionalChainMember: f } = r;
              return c && (this.expressionScope.enter(Ph()), n = new At()), f && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, n), this.finishCallExpression(o, f), c && this.shouldParseAsyncArrow() && !i ? (r.stop = true, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), o = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e, s), o)) : (c && (this.checkExpressionErrors(n, true), this.expressionScope.exit()), this.toReferencedArguments(o)), this.state.maybeInArrowParameters = a, o;
            }
            toReferencedArguments(t, e) {
              this.toReferencedListDeep(t.arguments, e);
            }
            parseTaggedTemplateExpression(t, e, s, r) {
              let i = this.startNodeAt(e, s);
              return i.tag = t, i.quasi = this.parseTemplate(true), r.optionalChainMember && this.raise(u.OptionalChainingNoTemplate, { at: s }), this.finishNode(i, "TaggedTemplateExpression");
            }
            atPossibleAsyncArrow(t) {
              return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
            }
            finishCallExpression(t, e) {
              if (t.callee.type === "Import")
                if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), t.arguments.length === 0 || t.arguments.length > 2)
                  this.raise(u.ImportCallArity, { at: t, maxArgumentCount: this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
                else
                  for (let s of t.arguments)
                    s.type === "SpreadElement" && this.raise(u.ImportCallSpreadArgument, { at: s });
              return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
            }
            parseCallExpressionArguments(t, e, s, r, i) {
              let a = [], n = true, o = this.state.inFSharpPipelineDirectBody;
              for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
                if (n)
                  n = false;
                else if (this.expect(12), this.match(t)) {
                  e && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(u.ImportCallArgumentTrailingComma, { at: this.state.lastTokStartLoc }), r && this.addTrailingCommaExtraToNode(r), this.next();
                  break;
                }
                a.push(this.parseExprListItem(false, i, s));
              }
              return this.state.inFSharpPipelineDirectBody = o, a;
            }
            shouldParseAsyncArrow() {
              return this.match(19) && !this.canInsertSemicolon();
            }
            parseAsyncArrowFromCallExpression(t, e) {
              var s;
              return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, true, (s = e.extra) == null ? void 0 : s.trailingCommaLoc), e.innerComments && Ge(t, e.innerComments), e.callee.trailingComments && Ge(t, e.callee.trailingComments), t;
            }
            parseNoCallExpr() {
              let t = this.state.start, e = this.state.startLoc;
              return this.parseSubscripts(this.parseExprAtom(), t, e, true);
            }
            parseExprAtom(t) {
              let e, { type: s } = this.state;
              switch (s) {
                case 79:
                  return this.parseSuper();
                case 83:
                  return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e) : (this.match(10) || this.raise(u.UnsupportedImport, { at: this.state.lastTokStartLoc }), this.finishNode(e, "Import"));
                case 78:
                  return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
                case 90:
                  return this.parseDo(this.startNode(), false);
                case 56:
                case 31:
                  return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                case 130:
                  return this.parseNumericLiteral(this.state.value);
                case 131:
                  return this.parseBigIntLiteral(this.state.value);
                case 132:
                  return this.parseDecimalLiteral(this.state.value);
                case 129:
                  return this.parseStringLiteral(this.state.value);
                case 84:
                  return this.parseNullLiteral();
                case 85:
                  return this.parseBooleanLiteral(true);
                case 86:
                  return this.parseBooleanLiteral(false);
                case 10: {
                  let r = this.state.potentialArrowAt === this.state.start;
                  return this.parseParenAndDistinguishExpression(r);
                }
                case 2:
                case 1:
                  return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
                case 0:
                  return this.parseArrayLike(3, true, false, t);
                case 6:
                case 7:
                  return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
                case 5:
                  return this.parseObjectLike(8, false, false, t);
                case 68:
                  return this.parseFunctionOrFunctionSent();
                case 26:
                  this.parseDecorators();
                case 80:
                  return e = this.startNode(), this.takeDecorators(e), this.parseClass(e, false);
                case 77:
                  return this.parseNewOrNewTarget();
                case 25:
                case 24:
                  return this.parseTemplate(false);
                case 15: {
                  e = this.startNode(), this.next(), e.object = null;
                  let r = e.callee = this.parseNoCallExpr();
                  if (r.type === "MemberExpression")
                    return this.finishNode(e, "BindExpression");
                  throw this.raise(u.UnsupportedBind, { at: r });
                }
                case 134:
                  return this.raise(u.PrivateInExpectedIn, { at: this.state.startLoc, identifierName: this.state.value }), this.parsePrivateName();
                case 33:
                  return this.parseTopicReferenceThenEqualsSign(54, "%");
                case 32:
                  return this.parseTopicReferenceThenEqualsSign(44, "^");
                case 37:
                case 38:
                  return this.parseTopicReference("hack");
                case 44:
                case 54:
                case 27: {
                  let r = this.getPluginOption("pipelineOperator", "proposal");
                  if (r)
                    return this.parseTopicReference(r);
                  throw this.unexpected();
                }
                case 47: {
                  let r = this.input.codePointAt(this.nextTokenStart());
                  if (de(r) || r === 62) {
                    this.expectOnePlugin(["jsx", "flow", "typescript"]);
                    break;
                  } else
                    throw this.unexpected();
                }
                default:
                  if (K(s)) {
                    if (this.isContextual(123) && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                      return this.parseModuleExpression();
                    let r = this.state.potentialArrowAt === this.state.start, i = this.state.containsEsc, a = this.parseIdentifier();
                    if (!i && a.name === "async" && !this.canInsertSemicolon()) {
                      let { type: n } = this.state;
                      if (n === 68)
                        return this.resetPreviousNodeTrailingComments(a), this.next(), this.parseFunction(this.startNodeAtNode(a), void 0, true);
                      if (K(n))
                        return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(a)) : a;
                      if (n === 90)
                        return this.resetPreviousNodeTrailingComments(a), this.parseDo(this.startNodeAtNode(a), true);
                    }
                    return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(a), [a], false)) : a;
                  } else
                    throw this.unexpected();
              }
            }
            parseTopicReferenceThenEqualsSign(t, e) {
              let s = this.getPluginOption("pipelineOperator", "proposal");
              if (s)
                return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = m2(this.state.endLoc, -1), this.parseTopicReference(s);
              throw this.unexpected();
            }
            parseTopicReference(t) {
              let e = this.startNode(), s = this.state.startLoc, r = this.state.type;
              return this.next(), this.finishTopicReference(e, s, t, r);
            }
            finishTopicReference(t, e, s, r) {
              if (this.testTopicReferenceConfiguration(s, e, r)) {
                let i = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
                return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? u.PrimaryTopicNotAllowed : u.PipeTopicUnbound, { at: e }), this.registerTopicReference(), this.finishNode(t, i);
              } else
                throw this.raise(u.PipeTopicUnconfiguredToken, { at: e, token: Pe(r) });
            }
            testTopicReferenceConfiguration(t, e, s) {
              switch (t) {
                case "hack":
                  return this.hasPlugin(["pipelineOperator", { topicToken: Pe(s) }]);
                case "smart":
                  return s === 27;
                default:
                  throw this.raise(u.PipeTopicRequiresHackPipes, { at: e });
              }
            }
            parseAsyncArrowUnaryFunction(t) {
              this.prodParam.enter(gt(true, this.prodParam.hasYield));
              let e = [this.parseIdentifier()];
              return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(u.LineTerminatorBeforeArrow, { at: this.state.curPosition() }), this.expect(19), this.parseArrowExpression(t, e, true), t;
            }
            parseDo(t, e) {
              this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
              let s = this.state.labels;
              return this.state.labels = [], e ? (this.prodParam.enter(xt), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s, this.finishNode(t, "DoExpression");
            }
            parseSuper() {
              let t = this.startNode();
              return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(u.SuperNotAllowed, { at: t }) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(u.UnexpectedSuper, { at: t }), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(u.UnsupportedSuper, { at: t }), this.finishNode(t, "Super");
            }
            parsePrivateName() {
              let t = this.startNode(), e = this.startNodeAt(this.state.start + 1, new p2(this.state.curLine, this.state.start + 1 - this.state.lineStart, this.state.start + 1)), s = this.state.value;
              return this.next(), t.id = this.createIdentifier(e, s), this.finishNode(t, "PrivateName");
            }
            parseFunctionOrFunctionSent() {
              let t = this.startNode();
              if (this.next(), this.prodParam.hasYield && this.match(16)) {
                let e = this.createIdentifier(this.startNodeAtNode(t), "function");
                return this.next(), this.match(102) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
              }
              return this.parseFunction(t);
            }
            parseMetaProperty(t, e, s) {
              t.meta = e;
              let r = this.state.containsEsc;
              return t.property = this.parseIdentifier(true), (t.property.name !== s || r) && this.raise(u.UnsupportedMetaProperty, { at: t.property, target: e.name, onlyValidPropertyName: s }), this.finishNode(t, "MetaProperty");
            }
            parseImportMetaProperty(t) {
              let e = this.createIdentifier(this.startNodeAtNode(t), "import");
              return this.next(), this.isContextual(100) && (this.inModule || this.raise(u.ImportMetaOutsideModule, { at: e }), this.sawUnambiguousESM = true), this.parseMetaProperty(t, e, "meta");
            }
            parseLiteralAtNode(t, e, s) {
              return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = t, this.next(), this.finishNode(s, e);
            }
            parseLiteral(t, e) {
              let s = this.startNode();
              return this.parseLiteralAtNode(t, e, s);
            }
            parseStringLiteral(t) {
              return this.parseLiteral(t, "StringLiteral");
            }
            parseNumericLiteral(t) {
              return this.parseLiteral(t, "NumericLiteral");
            }
            parseBigIntLiteral(t) {
              return this.parseLiteral(t, "BigIntLiteral");
            }
            parseDecimalLiteral(t) {
              return this.parseLiteral(t, "DecimalLiteral");
            }
            parseRegExpLiteral(t) {
              let e = this.parseLiteral(t.value, "RegExpLiteral");
              return e.pattern = t.pattern, e.flags = t.flags, e;
            }
            parseBooleanLiteral(t) {
              let e = this.startNode();
              return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
            }
            parseNullLiteral() {
              let t = this.startNode();
              return this.next(), this.finishNode(t, "NullLiteral");
            }
            parseParenAndDistinguishExpression(t) {
              let e = this.state.start, s = this.state.startLoc, r;
              this.next(), this.expressionScope.enter(Ah());
              let i = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
              this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
              let n = this.state.start, o = this.state.startLoc, c = [], f = new At(), y = true, P, v;
              for (; !this.match(11); ) {
                if (y)
                  y = false;
                else if (this.expect(12, f.optionalParametersLoc === null ? null : f.optionalParametersLoc), this.match(11)) {
                  v = this.state.startLoc;
                  break;
                }
                if (this.match(21)) {
                  let _ = this.state.start, Q = this.state.startLoc;
                  if (P = this.state.startLoc, c.push(this.parseParenItem(this.parseRestBinding(), _, Q)), !this.checkCommaAfterRest(41))
                    break;
                } else
                  c.push(this.parseMaybeAssignAllowIn(f, this.parseParenItem));
              }
              let N = this.state.lastTokEndLoc;
              this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = a;
              let B = this.startNodeAt(e, s);
              return t && this.shouldParseArrow(c) && (B = this.parseArrow(B)) ? (this.checkDestructuringPrivate(f), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(B, c, false), B) : (this.expressionScope.exit(), c.length || this.unexpected(this.state.lastTokStartLoc), v && this.unexpected(v), P && this.unexpected(P), this.checkExpressionErrors(f, true), this.toReferencedListDeep(c, true), c.length > 1 ? (r = this.startNodeAt(n, o), r.expressions = c, this.finishNode(r, "SequenceExpression"), this.resetEndLocation(r, N)) : r = c[0], this.wrapParenthesis(e, s, r));
            }
            wrapParenthesis(t, e, s) {
              if (!this.options.createParenthesizedExpressions)
                return this.addExtra(s, "parenthesized", true), this.addExtra(s, "parenStart", t), this.takeSurroundingComments(s, t, this.state.lastTokEndLoc.index), s;
              let r = this.startNodeAt(t, e);
              return r.expression = s, this.finishNode(r, "ParenthesizedExpression"), r;
            }
            shouldParseArrow(t) {
              return !this.canInsertSemicolon();
            }
            parseArrow(t) {
              if (this.eat(19))
                return t;
            }
            parseParenItem(t, e, s) {
              return t;
            }
            parseNewOrNewTarget() {
              let t = this.startNode();
              if (this.next(), this.match(16)) {
                let e = this.createIdentifier(this.startNodeAtNode(t), "new");
                this.next();
                let s = this.parseMetaProperty(t, e, "target");
                return !this.scope.inNonArrowFunction && !this.scope.inClass && this.raise(u.UnexpectedNewTarget, { at: s }), s;
              }
              return this.parseNew(t);
            }
            parseNew(t) {
              if (this.parseNewCallee(t), this.eat(10)) {
                let e = this.parseExprList(11);
                this.toReferencedList(e), t.arguments = e;
              } else
                t.arguments = [];
              return this.finishNode(t, "NewExpression");
            }
            parseNewCallee(t) {
              t.callee = this.parseNoCallExpr(), t.callee.type === "Import" ? this.raise(u.ImportCallNotNewExpression, { at: t.callee }) : this.isOptionalChain(t.callee) ? this.raise(u.OptionalChainingNoNew, { at: this.state.lastTokEndLoc }) : this.eat(18) && this.raise(u.OptionalChainingNoNew, { at: this.state.startLoc });
            }
            parseTemplateElement(t) {
              let { start: e, startLoc: s, end: r, value: i } = this.state, a = e + 1, n = this.startNodeAt(a, m2(s, 1));
              i === null && (t || this.raise(u.InvalidEscapeSequenceTemplate, { at: m2(s, 2) }));
              let o = this.match(24), c = o ? -1 : -2, f = r + c;
              return n.value = { raw: this.input.slice(a, f).replace(/\r\n?/g, `
`), cooked: i === null ? null : i.slice(1, c) }, n.tail = o, this.next(), this.finishNode(n, "TemplateElement"), this.resetEndLocation(n, m2(this.state.lastTokEndLoc, c)), n;
            }
            parseTemplate(t) {
              let e = this.startNode();
              e.expressions = [];
              let s = this.parseTemplateElement(t);
              for (e.quasis = [s]; !s.tail; )
                e.expressions.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), e.quasis.push(s = this.parseTemplateElement(t));
              return this.finishNode(e, "TemplateLiteral");
            }
            parseTemplateSubstitution() {
              return this.parseExpression();
            }
            parseObjectLike(t, e, s, r) {
              s && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a = /* @__PURE__ */ Object.create(null), n = true, o = this.startNode();
              for (o.properties = [], this.next(); !this.match(t); ) {
                if (n)
                  n = false;
                else if (this.expect(12), this.match(t)) {
                  this.addTrailingCommaExtraToNode(o);
                  break;
                }
                let f;
                e ? f = this.parseBindingProperty() : (f = this.parsePropertyDefinition(r), this.checkProto(f, s, a, r)), s && !this.isObjectProperty(f) && f.type !== "SpreadElement" && this.raise(u.InvalidRecordProperty, { at: f }), f.shorthand && this.addExtra(f, "shorthand", true), o.properties.push(f);
              }
              this.next(), this.state.inFSharpPipelineDirectBody = i;
              let c = "ObjectExpression";
              return e ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(o, c);
            }
            addTrailingCommaExtraToNode(t) {
              this.addExtra(t, "trailingComma", this.state.lastTokStart), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
            }
            maybeAsyncOrAccessorProp(t) {
              return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
            }
            parsePropertyDefinition(t) {
              let e = [];
              if (this.match(26))
                for (this.hasPlugin("decorators") && this.raise(u.UnsupportedPropertyDecorator, { at: this.state.startLoc }); this.match(26); )
                  e.push(this.parseDecorator());
              let s = this.startNode(), r = false, i = false, a, n;
              if (this.match(21))
                return e.length && this.unexpected(), this.parseSpread();
              e.length && (s.decorators = e, e = []), s.method = false, t && (a = this.state.start, n = this.state.startLoc);
              let o = this.eat(55);
              this.parsePropertyNamePrefixOperator(s);
              let c = this.state.containsEsc, f = this.parsePropertyName(s, t);
              if (!o && !c && this.maybeAsyncOrAccessorProp(s)) {
                let y = f.name;
                y === "async" && !this.hasPrecedingLineBreak() && (r = true, this.resetPreviousNodeTrailingComments(f), o = this.eat(55), this.parsePropertyName(s)), (y === "get" || y === "set") && (i = true, this.resetPreviousNodeTrailingComments(f), s.kind = y, this.match(55) && (o = true, this.raise(u.AccessorIsGenerator, { at: this.state.curPosition(), kind: y }), this.next()), this.parsePropertyName(s));
              }
              return this.parseObjPropValue(s, a, n, o, r, false, i, t), s;
            }
            getGetterSetterExpectedParamCount(t) {
              return t.kind === "get" ? 0 : 1;
            }
            getObjectOrClassMethodParams(t) {
              return t.params;
            }
            checkGetterSetterParams(t) {
              var e;
              let s = this.getGetterSetterExpectedParamCount(t), r = this.getObjectOrClassMethodParams(t);
              r.length !== s && this.raise(t.kind === "get" ? u.BadGetterArity : u.BadSetterArity, { at: t }), t.kind === "set" && ((e = r[r.length - 1]) == null ? void 0 : e.type) === "RestElement" && this.raise(u.BadSetterRestParameter, { at: t });
            }
            parseObjectMethod(t, e, s, r, i) {
              if (i)
                return this.parseMethod(t, e, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(t), t;
              if (s || e || this.match(10))
                return r && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, e, s, false, false, "ObjectMethod");
            }
            parseObjectProperty(t, e, s, r, i) {
              if (t.shorthand = false, this.eat(14))
                return t.value = r ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProperty");
              if (!t.computed && t.key.type === "Identifier") {
                if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), r)
                  t.value = this.parseMaybeDefault(e, s, ge(t.key));
                else if (this.match(29)) {
                  let a = this.state.startLoc;
                  i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = a) : this.raise(u.InvalidCoverInitializedName, { at: a }), t.value = this.parseMaybeDefault(e, s, ge(t.key));
                } else
                  t.value = ge(t.key);
                return t.shorthand = true, this.finishNode(t, "ObjectProperty");
              }
            }
            parseObjPropValue(t, e, s, r, i, a, n, o) {
              let c = this.parseObjectMethod(t, r, i, a, n) || this.parseObjectProperty(t, e, s, a, o);
              return c || this.unexpected(), c;
            }
            parsePropertyName(t, e) {
              if (this.eat(0))
                t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
              else {
                let { type: s, value: r } = this.state, i;
                if (pe(s))
                  i = this.parseIdentifier(true);
                else
                  switch (s) {
                    case 130:
                      i = this.parseNumericLiteral(r);
                      break;
                    case 129:
                      i = this.parseStringLiteral(r);
                      break;
                    case 131:
                      i = this.parseBigIntLiteral(r);
                      break;
                    case 132:
                      i = this.parseDecimalLiteral(r);
                      break;
                    case 134: {
                      let a = this.state.startLoc;
                      e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = a) : this.raise(u.UnexpectedPrivateField, { at: a }), i = this.parsePrivateName();
                      break;
                    }
                    default:
                      throw this.unexpected();
                  }
                t.key = i, s !== 134 && (t.computed = false);
              }
              return t.key;
            }
            initFunction(t, e) {
              t.id = null, t.generator = false, t.async = !!e;
            }
            parseMethod(t, e, s, r, i, a) {
              let n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
              this.initFunction(t, s), t.generator = !!e;
              let o = r;
              return this.scope.enter(me | ot | (n ? Se : 0) | (i ? xr : 0)), this.prodParam.enter(gt(s, t.generator)), this.parseFunctionParams(t, o), this.parseFunctionBodyAndFinish(t, a, true), this.prodParam.exit(), this.scope.exit(), t;
            }
            parseArrayLike(t, e, s, r) {
              s && this.expectPlugin("recordAndTuple");
              let i = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = false;
              let a = this.startNode();
              return this.next(), a.elements = this.parseExprList(t, !s, r, a), this.state.inFSharpPipelineDirectBody = i, this.finishNode(a, s ? "TupleExpression" : "ArrayExpression");
            }
            parseArrowExpression(t, e, s, r) {
              this.scope.enter(me | Jt);
              let i = gt(s, false);
              !this.match(5) && this.prodParam.hasIn && (i |= qe), this.prodParam.enter(i), this.initFunction(t, s);
              let a = this.state.maybeInArrowParameters;
              return e && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, e, r)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = a, this.finishNode(t, "ArrowFunctionExpression");
            }
            setArrowFunctionParameters(t, e, s) {
              this.toAssignableList(e, s, false), t.params = e;
            }
            parseFunctionBodyAndFinish(t, e) {
              let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              this.parseFunctionBody(t, false, s), this.finishNode(t, e);
            }
            parseFunctionBody(t, e) {
              let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = e && !this.match(5);
              if (this.expressionScope.enter(Dr()), r)
                t.body = this.parseMaybeAssign(), this.checkParams(t, false, e, false);
              else {
                let i = this.state.strict, a = this.state.labels;
                this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | Lr), t.body = this.parseBlock(true, false, (n) => {
                  let o = !this.isSimpleParamList(t.params);
                  n && o && this.raise(u.IllegalLanguageModeDirective, { at: (t.kind === "method" || t.kind === "constructor") && !!t.key ? t.key.loc.end : t });
                  let c = !i && this.state.strict;
                  this.checkParams(t, !this.state.strict && !e && !s && !o, e, c), this.state.strict && t.id && this.checkIdentifier(t.id, Xo, c);
                }), this.prodParam.exit(), this.state.labels = a;
              }
              this.expressionScope.exit();
            }
            isSimpleParameter(t) {
              return t.type === "Identifier";
            }
            isSimpleParamList(t) {
              for (let e = 0, s = t.length; e < s; e++)
                if (!this.isSimpleParameter(t[e]))
                  return false;
              return true;
            }
            checkParams(t, e, s) {
              let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, i = !e && /* @__PURE__ */ new Set(), a = { type: "FormalParameters" };
              for (let n of t.params)
                this.checkLVal(n, { in: a, binding: pt, checkClashes: i, strictModeChanged: r });
            }
            parseExprList(t, e, s, r) {
              let i = [], a = true;
              for (; !this.eat(t); ) {
                if (a)
                  a = false;
                else if (this.expect(12), this.match(t)) {
                  r && this.addTrailingCommaExtraToNode(r), this.next();
                  break;
                }
                i.push(this.parseExprListItem(e, s));
              }
              return i;
            }
            parseExprListItem(t, e, s) {
              let r;
              if (this.match(12))
                t || this.raise(u.UnexpectedToken, { at: this.state.curPosition(), unexpected: "," }), r = null;
              else if (this.match(21)) {
                let i = this.state.start, a = this.state.startLoc;
                r = this.parseParenItem(this.parseSpread(e), i, a);
              } else if (this.match(17)) {
                this.expectPlugin("partialApplication"), s || this.raise(u.UnexpectedArgumentPlaceholder, { at: this.state.startLoc });
                let i = this.startNode();
                this.next(), r = this.finishNode(i, "ArgumentPlaceholder");
              } else
                r = this.parseMaybeAssignAllowIn(e, this.parseParenItem);
              return r;
            }
            parseIdentifier(t) {
              let e = this.startNode(), s = this.parseIdentifierName(e.start, t);
              return this.createIdentifier(e, s);
            }
            createIdentifier(t, e) {
              return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
            }
            parseIdentifierName(t, e) {
              let s, { startLoc: r, type: i } = this.state;
              if (pe(i))
                s = this.state.value;
              else
                throw this.unexpected();
              let a = vo(i);
              return e ? a && this.replaceToken(128) : this.checkReservedWord(s, r, a, false), this.next(), s;
            }
            checkReservedWord(t, e, s, r) {
              if (t.length > 10 || !Ho(t))
                return;
              if (t === "yield") {
                if (this.prodParam.hasYield) {
                  this.raise(u.YieldBindingIdentifier, { at: e });
                  return;
                }
              } else if (t === "await") {
                if (this.prodParam.hasAwait) {
                  this.raise(u.AwaitBindingIdentifier, { at: e });
                  return;
                }
                if (this.scope.inStaticBlock) {
                  this.raise(u.AwaitBindingIdentifierInStaticBlock, { at: e });
                  return;
                }
                this.expressionScope.recordAsyncArrowParametersError({ at: e });
              } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
                this.raise(u.ArgumentsInClass, { at: e });
                return;
              }
              if (s && zo(t)) {
                this.raise(u.UnexpectedKeyword, { at: e, keyword: t });
                return;
              }
              (this.state.strict ? r ? mr : fr : pr)(t, this.inModule) && this.raise(u.UnexpectedReservedWord, { at: e, reservedWord: t });
            }
            isAwaitAllowed() {
              return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
            }
            parseAwait(t, e) {
              let s = this.startNodeAt(t, e);
              return this.expressionScope.recordParameterInitializerError(u.AwaitExpressionFormalParameter, { at: s }), this.eat(55) && this.raise(u.ObsoleteAwaitStar, { at: s }), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (s.argument = this.parseMaybeUnary(null, true)), this.finishNode(s, "AwaitExpression");
            }
            isAmbiguousAwait() {
              if (this.hasPrecedingLineBreak())
                return true;
              let { type: t } = this.state;
              return t === 53 || t === 10 || t === 0 || nt(t) || t === 133 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
            }
            parseYield() {
              let t = this.startNode();
              this.expressionScope.recordParameterInitializerError(u.YieldInParameter, { at: t }), this.next();
              let e = false, s = null;
              if (!this.hasPrecedingLineBreak())
                switch (e = this.eat(55), this.state.type) {
                  case 13:
                  case 135:
                  case 8:
                  case 11:
                  case 3:
                  case 9:
                  case 14:
                  case 12:
                    if (!e)
                      break;
                  default:
                    s = this.parseMaybeAssign();
                }
              return t.delegate = e, t.argument = s, this.finishNode(t, "YieldExpression");
            }
            checkPipelineAtInfixOperator(t, e) {
              this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(u.PipelineHeadSequenceExpression, { at: e });
            }
            parseSmartPipelineBodyInStyle(t, e, s) {
              let r = this.startNodeAt(e, s);
              return this.isSimpleReference(t) ? (r.callee = t, this.finishNode(r, "PipelineBareFunction")) : (this.checkSmartPipeTopicBodyEarlyErrors(s), r.expression = t, this.finishNode(r, "PipelineTopicExpression"));
            }
            isSimpleReference(t) {
              switch (t.type) {
                case "MemberExpression":
                  return !t.computed && this.isSimpleReference(t.object);
                case "Identifier":
                  return true;
                default:
                  return false;
              }
            }
            checkSmartPipeTopicBodyEarlyErrors(t) {
              if (this.match(19))
                throw this.raise(u.PipelineBodyNoArrow, { at: this.state.startLoc });
              this.topicReferenceWasUsedInCurrentContext() || this.raise(u.PipelineTopicUnused, { at: t });
            }
            withTopicBindingContext(t) {
              let e = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
              try {
                return t();
              } finally {
                this.state.topicContext = e;
              }
            }
            withSmartMixTopicForbiddingContext(t) {
              if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
                let e = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                try {
                  return t();
                } finally {
                  this.state.topicContext = e;
                }
              } else
                return t();
            }
            withSoloAwaitPermittingContext(t) {
              let e = this.state.soloAwait;
              this.state.soloAwait = true;
              try {
                return t();
              } finally {
                this.state.soloAwait = e;
              }
            }
            allowInAnd(t) {
              let e = this.prodParam.currentFlags();
              if (qe & ~e) {
                this.prodParam.enter(e | qe);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            disallowInAnd(t) {
              let e = this.prodParam.currentFlags();
              if (qe & e) {
                this.prodParam.enter(e & ~qe);
                try {
                  return t();
                } finally {
                  this.prodParam.exit();
                }
              }
              return t();
            }
            registerTopicReference() {
              this.state.topicContext.maxTopicIndex = 0;
            }
            topicReferenceIsAllowedInCurrentContext() {
              return this.state.topicContext.maxNumOfResolvableTopics >= 1;
            }
            topicReferenceWasUsedInCurrentContext() {
              return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
            }
            parseFSharpPipelineBody(t) {
              let e = this.state.start, s = this.state.startLoc;
              this.state.potentialArrowAt = this.state.start;
              let r = this.state.inFSharpPipelineDirectBody;
              this.state.inFSharpPipelineDirectBody = true;
              let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, s, t);
              return this.state.inFSharpPipelineDirectBody = r, i;
            }
            parseModuleExpression() {
              this.expectPlugin("moduleBlocks");
              let t = this.startNode();
              this.next(), this.eat(5);
              let e = this.initializeScopes(true);
              this.enterInitialScopes();
              let s = this.startNode();
              try {
                t.body = this.parseProgram(s, 8, "module");
              } finally {
                e();
              }
              return this.eat(8), this.finishNode(t, "ModuleExpression");
            }
            parsePropertyNamePrefixOperator(t) {
            }
          }, ps = { kind: "loop" }, $h = { kind: "switch" }, Qh = 0, fs = 1, Hr = 2, Wr = 4, Zh = /[\uD800-\uDFFF]/u, ds = /in(?:stanceof)?/y;
          function el(t, e) {
            for (let s = 0; s < t.length; s++) {
              let r = t[s], { type: i } = r;
              if (typeof i == "number") {
                {
                  if (i === 134) {
                    let { loc: a, start: n, value: o, end: c } = r, f = n + 1, y = m2(a.start, 1);
                    t.splice(s, 1, new Ee({ type: fe(27), value: "#", start: n, end: f, startLoc: a.start, endLoc: y }), new Ee({ type: fe(128), value: o, start: f, end: c, startLoc: y, endLoc: a.end })), s++;
                    continue;
                  }
                  if (nt(i)) {
                    let { loc: a, start: n, value: o, end: c } = r, f = n + 1, y = m2(a.start, 1), P;
                    e.charCodeAt(n) === 96 ? P = new Ee({ type: fe(22), value: "`", start: n, end: f, startLoc: a.start, endLoc: y }) : P = new Ee({ type: fe(8), value: "}", start: n, end: f, startLoc: a.start, endLoc: y });
                    let v, N, B, _;
                    i === 24 ? (N = c - 1, B = m2(a.end, -1), v = o === null ? null : o.slice(1, -1), _ = new Ee({ type: fe(22), value: "`", start: N, end: c, startLoc: B, endLoc: a.end })) : (N = c - 2, B = m2(a.end, -2), v = o === null ? null : o.slice(1, -2), _ = new Ee({ type: fe(23), value: "${", start: N, end: c, startLoc: B, endLoc: a.end })), t.splice(s, 1, P, new Ee({ type: fe(20), value: v, start: f, end: N, startLoc: y, endLoc: B }), _), s += 2;
                    continue;
                  }
                }
                r.type = fe(i);
              }
            }
            return t;
          }
          var tl = class extends Yh {
            parseTopLevel(t, e) {
              return t.program = this.parseProgram(e), t.comments = this.state.comments, this.options.tokens && (t.tokens = el(this.tokens, this.input)), this.finishNode(t, "File");
            }
            parseProgram(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 135, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.options.sourceType;
              if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, e), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                for (let [r, i] of Array.from(this.scope.undefinedExports))
                  this.raise(u.ModuleExportUndefined, { at: i, localName: r });
              return this.finishNode(t, "Program");
            }
            stmtToDirective(t) {
              let e = t;
              e.type = "Directive", e.value = e.expression, delete e.expression;
              let s = e.value, r = s.value, i = this.input.slice(s.start, s.end), a = s.value = i.slice(1, -1);
              return this.addExtra(s, "raw", i), this.addExtra(s, "rawValue", a), this.addExtra(s, "expressionValue", r), s.type = "DirectiveLiteral", e;
            }
            parseInterpreterDirective() {
              if (!this.match(28))
                return null;
              let t = this.startNode();
              return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
            }
            isLet(t) {
              return this.isContextual(99) ? this.isLetKeyword(t) : false;
            }
            isLetKeyword(t) {
              let e = this.nextTokenStart(), s = this.codePointAtPos(e);
              if (s === 92 || s === 91)
                return true;
              if (t)
                return false;
              if (s === 123)
                return true;
              if (de(s)) {
                if (ds.lastIndex = e, ds.test(this.input)) {
                  let r = this.codePointAtPos(ds.lastIndex);
                  if (!Be(r) && r !== 92)
                    return false;
                }
                return true;
              }
              return false;
            }
            parseStatement(t, e) {
              return this.match(26) && this.parseDecorators(true), this.parseStatementContent(t, e);
            }
            parseStatementContent(t, e) {
              let s = this.state.type, r = this.startNode(), i;
              switch (this.isLet(t) && (s = 74, i = "let"), s) {
                case 60:
                  return this.parseBreakContinueStatement(r, true);
                case 63:
                  return this.parseBreakContinueStatement(r, false);
                case 64:
                  return this.parseDebuggerStatement(r);
                case 90:
                  return this.parseDoStatement(r);
                case 91:
                  return this.parseForStatement(r);
                case 68:
                  if (this.lookaheadCharCode() === 46)
                    break;
                  return t && (this.state.strict ? this.raise(u.StrictFunction, { at: this.state.startLoc }) : t !== "if" && t !== "label" && this.raise(u.SloppyFunction, { at: this.state.startLoc })), this.parseFunctionStatement(r, false, !t);
                case 80:
                  return t && this.unexpected(), this.parseClass(r, true);
                case 69:
                  return this.parseIfStatement(r);
                case 70:
                  return this.parseReturnStatement(r);
                case 71:
                  return this.parseSwitchStatement(r);
                case 72:
                  return this.parseThrowStatement(r);
                case 73:
                  return this.parseTryStatement(r);
                case 75:
                case 74:
                  return i = i || this.state.value, t && i !== "var" && this.raise(u.UnexpectedLexicalDeclaration, { at: this.state.startLoc }), this.parseVarStatement(r, i);
                case 92:
                  return this.parseWhileStatement(r);
                case 76:
                  return this.parseWithStatement(r);
                case 5:
                  return this.parseBlock();
                case 13:
                  return this.parseEmptyStatement(r);
                case 83: {
                  let o = this.lookaheadCharCode();
                  if (o === 40 || o === 46)
                    break;
                }
                case 82: {
                  !this.options.allowImportExportEverywhere && !e && this.raise(u.UnexpectedImportExport, { at: this.state.startLoc }), this.next();
                  let o;
                  return s === 83 ? (o = this.parseImport(r), o.type === "ImportDeclaration" && (!o.importKind || o.importKind === "value") && (this.sawUnambiguousESM = true)) : (o = this.parseExport(r), (o.type === "ExportNamedDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportAllDeclaration" && (!o.exportKind || o.exportKind === "value") || o.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(r), o;
                }
                default:
                  if (this.isAsyncFunction())
                    return t && this.raise(u.AsyncFunctionInSingleStatementContext, { at: this.state.startLoc }), this.next(), this.parseFunctionStatement(r, true, !t);
              }
              let a = this.state.value, n = this.parseExpression();
              return K(s) && n.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(r, a, n, t) : this.parseExpressionStatement(r, n);
            }
            assertModuleNodeAllowed(t) {
              !this.options.allowImportExportEverywhere && !this.inModule && this.raise(u.ImportOutsideModule, { at: t });
            }
            takeDecorators(t) {
              let e = this.state.decoratorStack[this.state.decoratorStack.length - 1];
              e.length && (t.decorators = e, this.resetStartLocationFromNode(t, e[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
            }
            canHaveLeadingDecorator() {
              return this.match(80);
            }
            parseDecorators(t) {
              let e = this.state.decoratorStack[this.state.decoratorStack.length - 1];
              for (; this.match(26); ) {
                let s = this.parseDecorator();
                e.push(s);
              }
              if (this.match(82))
                t || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(u.DecoratorExportClass, { at: this.state.startLoc });
              else if (!this.canHaveLeadingDecorator())
                throw this.raise(u.UnexpectedLeadingDecorator, { at: this.state.startLoc });
            }
            parseDecorator() {
              this.expectOnePlugin(["decorators-legacy", "decorators"]);
              let t = this.startNode();
              if (this.next(), this.hasPlugin("decorators")) {
                this.state.decoratorStack.push([]);
                let e = this.state.start, s = this.state.startLoc, r;
                if (this.match(10)) {
                  let i = this.state.start, a = this.state.startLoc;
                  this.next(), r = this.parseExpression(), this.expect(11), r = this.wrapParenthesis(i, a, r);
                } else
                  for (r = this.parseIdentifier(false); this.eat(16); ) {
                    let i = this.startNodeAt(e, s);
                    i.object = r, i.property = this.parseIdentifier(true), i.computed = false, r = this.finishNode(i, "MemberExpression");
                  }
                t.expression = this.parseMaybeDecoratorArguments(r), this.state.decoratorStack.pop();
              } else
                t.expression = this.parseExprSubscripts();
              return this.finishNode(t, "Decorator");
            }
            parseMaybeDecoratorArguments(t) {
              if (this.eat(10)) {
                let e = this.startNodeAtNode(t);
                return e.callee = t, e.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e.arguments), this.finishNode(e, "CallExpression");
              }
              return t;
            }
            parseBreakContinueStatement(t, e) {
              return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
            }
            verifyBreakContinue(t, e) {
              let s;
              for (s = 0; s < this.state.labels.length; ++s) {
                let r = this.state.labels[s];
                if ((t.label == null || r.name === t.label.name) && (r.kind != null && (e || r.kind === "loop") || t.label && e))
                  break;
              }
              if (s === this.state.labels.length) {
                let r = e ? "BreakStatement" : "ContinueStatement";
                this.raise(u.IllegalBreakContinue, { at: t, type: r });
              }
            }
            parseDebuggerStatement(t) {
              return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
            }
            parseHeaderExpression() {
              this.expect(10);
              let t = this.parseExpression();
              return this.expect(11), t;
            }
            parseDoStatement(t) {
              return this.next(), this.state.labels.push(ps), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
            }
            parseForStatement(t) {
              this.next(), this.state.labels.push(ps);
              let e = null;
              if (this.isAwaitAllowed() && this.eatContextual(96) && (e = this.state.lastTokStartLoc), this.scope.enter(Me), this.expect(10), this.match(13))
                return e !== null && this.unexpected(e), this.parseFor(t, null);
              let s = this.isContextual(99), r = s && this.isLetKeyword();
              if (this.match(74) || this.match(75) || r) {
                let c = this.startNode(), f = r ? "let" : this.state.value;
                return this.next(), this.parseVar(c, true, f), this.finishNode(c, "VariableDeclaration"), (this.match(58) || this.isContextual(101)) && c.declarations.length === 1 ? this.parseForIn(t, c, e) : (e !== null && this.unexpected(e), this.parseFor(t, c));
              }
              let i = this.isContextual(95), a = new At(), n = this.parseExpression(true, a), o = this.isContextual(101);
              if (o && (s && this.raise(u.ForOfLet, { at: n }), e === null && i && n.type === "Identifier" && this.raise(u.ForOfAsync, { at: n })), o || this.match(58)) {
                this.checkDestructuringPrivate(a), this.toAssignable(n, true);
                let c = o ? "ForOfStatement" : "ForInStatement";
                return this.checkLVal(n, { in: { type: c } }), this.parseForIn(t, n, e);
              } else
                this.checkExpressionErrors(a, true);
              return e !== null && this.unexpected(e), this.parseFor(t, n);
            }
            parseFunctionStatement(t, e, s) {
              return this.next(), this.parseFunction(t, fs | (s ? 0 : Hr), e);
            }
            parseIfStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(66) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
            }
            parseReturnStatement(t) {
              return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(u.IllegalReturn, { at: this.state.startLoc }), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
            }
            parseSwitchStatement(t) {
              this.next(), t.discriminant = this.parseHeaderExpression();
              let e = t.cases = [];
              this.expect(5), this.state.labels.push($h), this.scope.enter(Me);
              let s;
              for (let r; !this.match(8); )
                if (this.match(61) || this.match(65)) {
                  let i = this.match(61);
                  s && this.finishNode(s, "SwitchCase"), e.push(s = this.startNode()), s.consequent = [], this.next(), i ? s.test = this.parseExpression() : (r && this.raise(u.MultipleDefaultsInSwitch, { at: this.state.lastTokStartLoc }), r = true, s.test = null), this.expect(14);
                } else
                  s ? s.consequent.push(this.parseStatement(null)) : this.unexpected();
              return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
            }
            parseThrowStatement(t) {
              return this.next(), this.hasPrecedingLineBreak() && this.raise(u.NewlineAfterThrow, { at: this.state.lastTokEndLoc }), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
            }
            parseCatchClauseParam() {
              let t = this.parseBindingAtom(), e = t.type === "Identifier";
              return this.scope.enter(e ? yr : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: xe, allowingSloppyLetBinding: true }), t;
            }
            parseTryStatement(t) {
              if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
                let e = this.startNode();
                this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(Me)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
              }
              return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(u.NoCatchOrFinally, { at: t }), this.finishNode(t, "TryStatement");
            }
            parseVarStatement(t, e) {
              let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return this.next(), this.parseVar(t, false, e, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
            }
            parseWhileStatement(t) {
              return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(ps), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
            }
            parseWithStatement(t) {
              return this.state.strict && this.raise(u.StrictWith, { at: this.state.startLoc }), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(t, "WithStatement");
            }
            parseEmptyStatement(t) {
              return this.next(), this.finishNode(t, "EmptyStatement");
            }
            parseLabeledStatement(t, e, s, r) {
              for (let a of this.state.labels)
                a.name === e && this.raise(u.LabelRedeclaration, { at: s, labelName: e });
              let i = No(this.state.type) ? "loop" : this.match(71) ? "switch" : null;
              for (let a = this.state.labels.length - 1; a >= 0; a--) {
                let n = this.state.labels[a];
                if (n.statementStart === t.start)
                  n.statementStart = this.state.start, n.kind = i;
                else
                  break;
              }
              return this.state.labels.push({ name: e, kind: i, statementStart: this.state.start }), t.body = this.parseStatement(r ? r.indexOf("label") === -1 ? r + "label" : r : "label"), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
            }
            parseExpressionStatement(t, e) {
              return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
            }
            parseBlock() {
              let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, s = arguments.length > 2 ? arguments[2] : void 0, r = this.startNode();
              return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(Me), this.parseBlockBody(r, t, false, 8, s), e && this.scope.exit(), this.finishNode(r, "BlockStatement");
            }
            isValidDirective(t) {
              return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
            }
            parseBlockBody(t, e, s, r, i) {
              let a = t.body = [], n = t.directives = [];
              this.parseBlockOrModuleBlockBody(a, e ? n : void 0, s, r, i);
            }
            parseBlockOrModuleBlockBody(t, e, s, r, i) {
              let a = this.state.strict, n = false, o = false;
              for (; !this.match(r); ) {
                let c = this.parseStatement(null, s);
                if (e && !o) {
                  if (this.isValidDirective(c)) {
                    let f = this.stmtToDirective(c);
                    e.push(f), !n && f.value.value === "use strict" && (n = true, this.setStrict(true));
                    continue;
                  }
                  o = true, this.state.strictErrors.clear();
                }
                t.push(c);
              }
              i && i.call(this, n), a || this.setStrict(false), this.next();
            }
            parseFor(t, e) {
              return t.init = e, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
            }
            parseForIn(t, e, s) {
              let r = this.match(58);
              return this.next(), r ? s !== null && this.unexpected(s) : t.await = s !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!r || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(u.ForInOfLoopInitializer, { at: e, type: r ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(u.InvalidLhs, { at: e, ancestor: { type: "ForStatement" } }), t.left = e, t.right = r ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, r ? "ForInStatement" : "ForOfStatement");
            }
            parseVar(t, e, s) {
              let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, i = t.declarations = [];
              for (t.kind = s; ; ) {
                let a = this.startNode();
                if (this.parseVarId(a, s), a.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, a.init === null && !r && (a.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(101))) ? this.raise(u.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "destructuring" }) : s === "const" && !(this.match(58) || this.isContextual(101)) && this.raise(u.DeclarationMissingInitializer, { at: this.state.lastTokEndLoc, kind: "const" })), i.push(this.finishNode(a, "VariableDeclarator")), !this.eat(12))
                  break;
              }
              return t;
            }
            parseVarId(t, e) {
              t.id = this.parseBindingAtom(), this.checkLVal(t.id, { in: { type: "VariableDeclarator" }, binding: e === "var" ? pt : xe });
            }
            parseFunction(t) {
              let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Qh, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, r = e & fs, i = e & Hr, a = !!r && !(e & Wr);
              this.initFunction(t, s), this.match(55) && i && this.raise(u.GeneratorInSingleStatementContext, { at: this.state.startLoc }), t.generator = this.eat(55), r && (t.id = this.parseFunctionId(a));
              let n = this.state.maybeInArrowParameters;
              return this.state.maybeInArrowParameters = false, this.scope.enter(me), this.prodParam.enter(gt(s, t.generator)), r || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
                this.parseFunctionBodyAndFinish(t, r ? "FunctionDeclaration" : "FunctionExpression");
              }), this.prodParam.exit(), this.scope.exit(), r && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = n, t;
            }
            parseFunctionId(t) {
              return t || K(this.state.type) ? this.parseIdentifier() : null;
            }
            parseFunctionParams(t, e) {
              this.expect(10), this.expressionScope.enter(gh()), t.params = this.parseBindingList(11, 41, false, e), this.expressionScope.exit();
            }
            registerFunctionStatementId(t) {
              !t.id || this.scope.declareName(t.id.name, this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? pt : xe : Tr, t.id.loc.start);
            }
            parseClass(t, e, s) {
              this.next(), this.takeDecorators(t);
              let r = this.state.strict;
              return this.state.strict = true, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, r), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
            }
            isClassProperty() {
              return this.match(29) || this.match(13) || this.match(8);
            }
            isClassMethod() {
              return this.match(10);
            }
            isNonstaticConstructor(t) {
              return !t.computed && !t.static && (t.key.name === "constructor" || t.key.value === "constructor");
            }
            parseClassBody(t, e) {
              this.classScope.enter();
              let s = { hadConstructor: false, hadSuperClass: t }, r = [], i = this.startNode();
              if (i.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
                for (; !this.match(8); ) {
                  if (this.eat(13)) {
                    if (r.length > 0)
                      throw this.raise(u.DecoratorSemicolon, { at: this.state.lastTokEndLoc });
                    continue;
                  }
                  if (this.match(26)) {
                    r.push(this.parseDecorator());
                    continue;
                  }
                  let a = this.startNode();
                  r.length && (a.decorators = r, this.resetStartLocationFromNode(a, r[0]), r = []), this.parseClassMember(i, a, s), a.kind === "constructor" && a.decorators && a.decorators.length > 0 && this.raise(u.DecoratorConstructor, { at: a });
                }
              }), this.state.strict = e, this.next(), r.length)
                throw this.raise(u.TrailingDecorator, { at: this.state.startLoc });
              return this.classScope.exit(), this.finishNode(i, "ClassBody");
            }
            parseClassMemberFromModifier(t, e) {
              let s = this.parseIdentifier(true);
              if (this.isClassMethod()) {
                let r = e;
                return r.kind = "method", r.computed = false, r.key = s, r.static = false, this.pushClassMethod(t, r, false, false, false, false), true;
              } else if (this.isClassProperty()) {
                let r = e;
                return r.computed = false, r.key = s, r.static = false, t.body.push(this.parseClassProperty(r)), true;
              }
              return this.resetPreviousNodeTrailingComments(s), false;
            }
            parseClassMember(t, e, s) {
              let r = this.isContextual(104);
              if (r) {
                if (this.parseClassMemberFromModifier(t, e))
                  return;
                if (this.eat(5)) {
                  this.parseClassStaticBlock(t, e);
                  return;
                }
              }
              this.parseClassMemberWithIsStatic(t, e, s, r);
            }
            parseClassMemberWithIsStatic(t, e, s, r) {
              let i = e, a = e, n = e, o = e, c = e, f = i, y = i;
              if (e.static = r, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
                f.kind = "method";
                let _ = this.match(134);
                if (this.parseClassElementName(f), _) {
                  this.pushClassPrivateMethod(t, a, true, false);
                  return;
                }
                this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsGenerator, { at: i.key }), this.pushClassMethod(t, i, true, false, false, false);
                return;
              }
              let P = K(this.state.type) && !this.state.containsEsc, v = this.match(134), N = this.parseClassElementName(e), B = this.state.startLoc;
              if (this.parsePostMemberNameModifiers(y), this.isClassMethod()) {
                if (f.kind = "method", v) {
                  this.pushClassPrivateMethod(t, a, false, false);
                  return;
                }
                let _ = this.isNonstaticConstructor(i), Q = false;
                _ && (i.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(u.DuplicateConstructor, { at: N }), _ && this.hasPlugin("typescript") && e.override && this.raise(u.OverrideOnConstructor, { at: N }), s.hadConstructor = true, Q = s.hadSuperClass), this.pushClassMethod(t, i, false, false, _, Q);
              } else if (this.isClassProperty())
                v ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n);
              else if (P && N.name === "async" && !this.isLineTerminator()) {
                this.resetPreviousNodeTrailingComments(N);
                let _ = this.eat(55);
                y.optional && this.unexpected(B), f.kind = "method";
                let Q = this.match(134);
                this.parseClassElementName(f), this.parsePostMemberNameModifiers(y), Q ? this.pushClassPrivateMethod(t, a, _, true) : (this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsAsync, { at: i.key }), this.pushClassMethod(t, i, _, true, false, false));
              } else if (P && (N.name === "get" || N.name === "set") && !(this.match(55) && this.isLineTerminator())) {
                this.resetPreviousNodeTrailingComments(N), f.kind = N.name;
                let _ = this.match(134);
                this.parseClassElementName(i), _ ? this.pushClassPrivateMethod(t, a, false, false) : (this.isNonstaticConstructor(i) && this.raise(u.ConstructorIsAccessor, { at: i.key }), this.pushClassMethod(t, i, false, false, false, false)), this.checkGetterSetterParams(i);
              } else if (P && N.name === "accessor" && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(N);
                let _ = this.match(134);
                this.parseClassElementName(n), this.pushClassAccessorProperty(t, c, _);
              } else
                this.isLineTerminator() ? v ? this.pushClassPrivateProperty(t, o) : this.pushClassProperty(t, n) : this.unexpected();
            }
            parseClassElementName(t) {
              let { type: e, value: s } = this.state;
              if ((e === 128 || e === 129) && t.static && s === "prototype" && this.raise(u.StaticPrototype, { at: this.state.startLoc }), e === 134) {
                s === "constructor" && this.raise(u.ConstructorClassPrivateField, { at: this.state.startLoc });
                let r = this.parsePrivateName();
                return t.key = r, r;
              }
              return this.parsePropertyName(t);
            }
            parseClassStaticBlock(t, e) {
              var s;
              this.scope.enter(Se | Yt | ot);
              let r = this.state.labels;
              this.state.labels = [], this.prodParam.enter(je);
              let i = e.body = [];
              this.parseBlockOrModuleBlockBody(i, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = r, t.body.push(this.finishNode(e, "StaticBlock")), (s = e.decorators) != null && s.length && this.raise(u.DecoratorStaticBlock, { at: e });
            }
            pushClassProperty(t, e) {
              !e.computed && (e.key.name === "constructor" || e.key.value === "constructor") && this.raise(u.ConstructorClassField, { at: e.key }), t.body.push(this.parseClassProperty(e));
            }
            pushClassPrivateProperty(t, e) {
              let s = this.parseClassPrivateProperty(e);
              t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), is, s.key.loc.start);
            }
            pushClassAccessorProperty(t, e, s) {
              if (!s && !e.computed) {
                let i = e.key;
                (i.name === "constructor" || i.value === "constructor") && this.raise(u.ConstructorClassField, { at: i });
              }
              let r = this.parseClassAccessorProperty(e);
              t.body.push(r), s && this.classScope.declarePrivateName(this.getPrivateNameSV(r.key), is, r.key.loc.start);
            }
            pushClassMethod(t, e, s, r, i, a) {
              t.body.push(this.parseMethod(e, s, r, i, a, "ClassMethod", true));
            }
            pushClassPrivateMethod(t, e, s, r) {
              let i = this.parseMethod(e, s, r, false, false, "ClassPrivateMethod", true);
              t.body.push(i);
              let a = i.kind === "get" ? i.static ? Qo : eh : i.kind === "set" ? i.static ? Zo : th : is;
              this.declareClassPrivateMethodInScope(i, a);
            }
            declareClassPrivateMethodInScope(t, e) {
              this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
            }
            parsePostMemberNameModifiers(t) {
            }
            parseClassPrivateProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
            }
            parseClassProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
            }
            parseClassAccessorProperty(t) {
              return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
            }
            parseInitializer(t) {
              this.scope.enter(Se | ot), this.expressionScope.enter(Dr()), this.prodParam.enter(je), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
            }
            parseClassId(t, e, s) {
              let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Pr;
              if (K(this.state.type))
                t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, r);
              else if (s || !e)
                t.id = null;
              else
                throw this.raise(u.MissingClassName, { at: this.state.startLoc });
            }
            parseClassSuper(t) {
              t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
            }
            parseExport(t) {
              let e = this.maybeParseExportDefaultSpecifier(t), s = !e || this.eat(12), r = s && this.eatExportStar(t), i = r && this.maybeParseExportNamespaceSpecifier(t), a = s && (!i || this.eat(12)), n = e || r;
              if (r && !i)
                return e && this.unexpected(), this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
              let o = this.maybeParseExportNamedSpecifiers(t);
              if (e && s && !r && !o || i && a && !o)
                throw this.unexpected(null, 5);
              let c;
              if (n || o ? (c = false, this.parseExportFrom(t, n)) : c = this.maybeParseExportDeclaration(t), n || o || c)
                return this.checkExport(t, true, false, !!t.source), this.finishNode(t, "ExportNamedDeclaration");
              if (this.eat(65))
                return t.declaration = this.parseExportDefaultExpression(), this.checkExport(t, true, true), this.finishNode(t, "ExportDefaultDeclaration");
              throw this.unexpected(null, 5);
            }
            eatExportStar(t) {
              return this.eat(55);
            }
            maybeParseExportDefaultSpecifier(t) {
              if (this.isExportDefaultSpecifier()) {
                this.expectPlugin("exportDefaultFrom");
                let e = this.startNode();
                return e.exported = this.parseIdentifier(true), t.specifiers = [this.finishNode(e, "ExportDefaultSpecifier")], true;
              }
              return false;
            }
            maybeParseExportNamespaceSpecifier(t) {
              if (this.isContextual(93)) {
                t.specifiers || (t.specifiers = []);
                let e = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                return this.next(), e.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(e, "ExportNamespaceSpecifier")), true;
              }
              return false;
            }
            maybeParseExportNamedSpecifiers(t) {
              if (this.match(5)) {
                t.specifiers || (t.specifiers = []);
                let e = t.exportKind === "type";
                return t.specifiers.push(...this.parseExportSpecifiers(e)), t.source = null, t.declaration = null, this.hasPlugin("importAssertions") && (t.assertions = []), true;
              }
              return false;
            }
            maybeParseExportDeclaration(t) {
              return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
            }
            isAsyncFunction() {
              if (!this.isContextual(95))
                return false;
              let t = this.nextTokenStart();
              return !as.test(this.input.slice(this.state.pos, t)) && this.isUnparsedContextual(t, "function");
            }
            parseExportDefaultExpression() {
              let t = this.startNode(), e = this.isAsyncFunction();
              if (this.match(68) || e)
                return this.next(), e && this.next(), this.parseFunction(t, fs | Wr, e);
              if (this.match(80))
                return this.parseClass(t, true, true);
              if (this.match(26))
                return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(u.DecoratorBeforeExport, { at: this.state.startLoc }), this.parseDecorators(false), this.parseClass(t, true, true);
              if (this.match(75) || this.match(74) || this.isLet())
                throw this.raise(u.UnsupportedDefaultExport, { at: this.state.startLoc });
              let s = this.parseMaybeAssignAllowIn();
              return this.semicolon(), s;
            }
            parseExportDeclaration(t) {
              return this.parseStatement(null);
            }
            isExportDefaultSpecifier() {
              let { type: t } = this.state;
              if (K(t)) {
                if (t === 95 && !this.state.containsEsc || t === 99)
                  return false;
                if ((t === 126 || t === 125) && !this.state.containsEsc) {
                  let { type: r } = this.lookahead();
                  if (K(r) && r !== 97 || r === 5)
                    return this.expectOnePlugin(["flow", "typescript"]), false;
                }
              } else if (!this.match(65))
                return false;
              let e = this.nextTokenStart(), s = this.isUnparsedContextual(e, "from");
              if (this.input.charCodeAt(e) === 44 || K(this.state.type) && s)
                return true;
              if (this.match(65) && s) {
                let r = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
                return r === 34 || r === 39;
              }
              return false;
            }
            parseExportFrom(t, e) {
              if (this.eatContextual(97)) {
                t.source = this.parseImportSource(), this.checkExport(t);
                let s = this.maybeParseImportAssertions();
                s && (t.assertions = s);
              } else
                e && this.unexpected();
              this.semicolon();
            }
            shouldParseExportDeclaration() {
              let { type: t } = this.state;
              if (t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
                if (this.getPluginOption("decorators", "decoratorsBeforeExport"))
                  throw this.raise(u.DecoratorBeforeExport, { at: this.state.startLoc });
                return true;
              }
              return t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
            }
            checkExport(t, e, s, r) {
              if (e) {
                if (s) {
                  if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                    var i;
                    let n = t.declaration;
                    n.type === "Identifier" && n.name === "from" && n.end - n.start === 4 && !((i = n.extra) != null && i.parenthesized) && this.raise(u.ExportDefaultFromAsIdentifier, { at: n });
                  }
                } else if (t.specifiers && t.specifiers.length)
                  for (let n of t.specifiers) {
                    let { exported: o } = n, c = o.type === "Identifier" ? o.name : o.value;
                    if (this.checkDuplicateExports(n, c), !r && n.local) {
                      let { local: f } = n;
                      f.type !== "Identifier" ? this.raise(u.ExportBindingIsString, { at: n, localName: f.value, exportName: c }) : (this.checkReservedWord(f.name, f.loc.start, true, false), this.scope.checkLocalExport(f));
                    }
                  }
                else if (t.declaration) {
                  if (t.declaration.type === "FunctionDeclaration" || t.declaration.type === "ClassDeclaration") {
                    let n = t.declaration.id;
                    if (!n)
                      throw new Error("Assertion failure");
                    this.checkDuplicateExports(t, n.name);
                  } else if (t.declaration.type === "VariableDeclaration")
                    for (let n of t.declaration.declarations)
                      this.checkDeclaration(n.id);
                }
              }
              if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
                throw this.raise(u.UnsupportedDecoratorExport, { at: t });
            }
            checkDeclaration(t) {
              if (t.type === "Identifier")
                this.checkDuplicateExports(t, t.name);
              else if (t.type === "ObjectPattern")
                for (let e of t.properties)
                  this.checkDeclaration(e);
              else if (t.type === "ArrayPattern")
                for (let e of t.elements)
                  e && this.checkDeclaration(e);
              else
                t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
            }
            checkDuplicateExports(t, e) {
              this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(u.DuplicateDefaultExport, { at: t }) : this.raise(u.DuplicateExport, { at: t, exportName: e })), this.exportedIdentifiers.add(e);
            }
            parseExportSpecifiers(t) {
              let e = [], s = true;
              for (this.expect(5); !this.eat(8); ) {
                if (s)
                  s = false;
                else if (this.expect(12), this.eat(8))
                  break;
                let r = this.isContextual(126), i = this.match(129), a = this.startNode();
                a.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(a, i, t, r));
              }
              return e;
            }
            parseExportSpecifier(t, e, s, r) {
              return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = bh(t.local) : t.exported || (t.exported = ge(t.local)), this.finishNode(t, "ExportSpecifier");
            }
            parseModuleExportName() {
              if (this.match(129)) {
                let t = this.parseStringLiteral(this.state.value), e = t.value.match(Zh);
                return e && this.raise(u.ModuleExportNameHasLoneSurrogate, { at: t, surrogateCharCode: e[0].charCodeAt(0) }), t;
              }
              return this.parseIdentifier(true);
            }
            parseImport(t) {
              if (t.specifiers = [], !this.match(129)) {
                let r = !this.maybeParseDefaultImportSpecifier(t) || this.eat(12), i = r && this.maybeParseStarImportSpecifier(t);
                r && !i && this.parseNamedImportSpecifiers(t), this.expectContextual(97);
              }
              t.source = this.parseImportSource();
              let e = this.maybeParseImportAssertions();
              if (e)
                t.assertions = e;
              else {
                let s = this.maybeParseModuleAttributes();
                s && (t.attributes = s);
              }
              return this.semicolon(), this.finishNode(t, "ImportDeclaration");
            }
            parseImportSource() {
              return this.match(129) || this.unexpected(), this.parseExprAtom();
            }
            shouldParseDefaultImport(t) {
              return K(this.state.type);
            }
            parseImportSpecifierLocal(t, e, s) {
              e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s));
            }
            finishImportSpecifier(t, e) {
              return this.checkLVal(t.local, { in: t, binding: xe }), this.finishNode(t, e);
            }
            parseAssertEntries() {
              let t = [], e = /* @__PURE__ */ new Set();
              do {
                if (this.match(8))
                  break;
                let s = this.startNode(), r = this.state.value;
                if (e.has(r) && this.raise(u.ModuleAttributesWithDuplicateKeys, { at: this.state.startLoc, key: r }), e.add(r), this.match(129) ? s.key = this.parseStringLiteral(r) : s.key = this.parseIdentifier(true), this.expect(14), !this.match(129))
                  throw this.raise(u.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                s.value = this.parseStringLiteral(this.state.value), this.finishNode(s, "ImportAttribute"), t.push(s);
              } while (this.eat(12));
              return t;
            }
            maybeParseModuleAttributes() {
              if (this.match(76) && !this.hasPrecedingLineBreak())
                this.expectPlugin("moduleAttributes"), this.next();
              else
                return this.hasPlugin("moduleAttributes") ? [] : null;
              let t = [], e = /* @__PURE__ */ new Set();
              do {
                let s = this.startNode();
                if (s.key = this.parseIdentifier(true), s.key.name !== "type" && this.raise(u.ModuleAttributeDifferentFromType, { at: s.key }), e.has(s.key.name) && this.raise(u.ModuleAttributesWithDuplicateKeys, { at: s.key, key: s.key.name }), e.add(s.key.name), this.expect(14), !this.match(129))
                  throw this.raise(u.ModuleAttributeInvalidValue, { at: this.state.startLoc });
                s.value = this.parseStringLiteral(this.state.value), this.finishNode(s, "ImportAttribute"), t.push(s);
              } while (this.eat(12));
              return t;
            }
            maybeParseImportAssertions() {
              if (this.isContextual(94) && !this.hasPrecedingLineBreak())
                this.expectPlugin("importAssertions"), this.next();
              else
                return this.hasPlugin("importAssertions") ? [] : null;
              this.eat(5);
              let t = this.parseAssertEntries();
              return this.eat(8), t;
            }
            maybeParseDefaultImportSpecifier(t) {
              return this.shouldParseDefaultImport(t) ? (this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true) : false;
            }
            maybeParseStarImportSpecifier(t) {
              if (this.match(55)) {
                let e = this.startNode();
                return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), true;
              }
              return false;
            }
            parseNamedImportSpecifiers(t) {
              let e = true;
              for (this.expect(5); !this.eat(8); ) {
                if (e)
                  e = false;
                else {
                  if (this.eat(14))
                    throw this.raise(u.DestructureNamedImport, { at: this.state.startLoc });
                  if (this.expect(12), this.eat(8))
                    break;
                }
                let s = this.startNode(), r = this.match(129), i = this.isContextual(126);
                s.imported = this.parseModuleExportName();
                let a = this.parseImportSpecifier(s, r, t.importKind === "type" || t.importKind === "typeof", i);
                t.specifiers.push(a);
              }
            }
            parseImportSpecifier(t, e, s, r) {
              if (this.eatContextual(93))
                t.local = this.parseIdentifier();
              else {
                let { imported: i } = t;
                if (e)
                  throw this.raise(u.ImportBindingIsString, { at: t, importName: i.value });
                this.checkReservedWord(i.name, t.loc.start, true, true), t.local || (t.local = ge(i));
              }
              return this.finishImportSpecifier(t, "ImportSpecifier");
            }
            isThisParam(t) {
              return t.type === "Identifier" && t.name === "this";
            }
          }, Gr = class extends tl {
            constructor(t, e) {
              t = Gh(t), super(t, e), this.options = t, this.initializeScopes(), this.plugins = sl(this.options.plugins), this.filename = t.sourceFilename;
            }
            getScopeHandler() {
              return hs;
            }
            parse() {
              this.enterInitialScopes();
              let t = this.startNode(), e = this.startNode();
              return this.nextToken(), t.errors = null, this.parseTopLevel(t, e), t.errors = this.state.errors, t;
            }
          };
          function sl(t) {
            let e = /* @__PURE__ */ new Map();
            for (let s of t) {
              let [r, i] = Array.isArray(s) ? s : [s, {}];
              e.has(r) || e.set(r, i || {});
            }
            return e;
          }
          function rl(t, e) {
            var s;
            if (((s = e) == null ? void 0 : s.sourceType) === "unambiguous") {
              e = Object.assign({}, e);
              try {
                e.sourceType = "module";
                let r = Ye(e, t), i = r.parse();
                if (r.sawUnambiguousESM)
                  return i;
                if (r.ambiguousScriptDifferentAst)
                  try {
                    return e.sourceType = "script", Ye(e, t).parse();
                  } catch {
                  }
                else
                  i.program.sourceType = "script";
                return i;
              } catch (r) {
                try {
                  return e.sourceType = "script", Ye(e, t).parse();
                } catch {
                }
                throw r;
              }
            } else
              return Ye(e, t).parse();
          }
          function il(t, e) {
            let s = Ye(e, t);
            return s.options.strictMode && (s.state.strict = true), s.getExpression();
          }
          function al(t) {
            let e = {};
            for (let s of Object.keys(t))
              e[s] = fe(t[s]);
            return e;
          }
          var nl = al(bo);
          function Ye(t, e) {
            let s = Gr;
            return t != null && t.plugins && (Hh(t.plugins), s = ol(t.plugins)), new s(t, e);
          }
          var Xr = {};
          function ol(t) {
            let e = Wh.filter((i) => ee(t, i)), s = e.join("/"), r = Xr[s];
            if (!r) {
              r = Gr;
              for (let i of e)
                r = zr[i](r);
              Xr[s] = r;
            }
            return r;
          }
          h3.parse = rl, h3.parseExpression = il, h3.tokTypes = nl;
        } }), Pf = H({ "src/language-js/parse/json.js"(h3, l) {
          "use strict";
          V();
          var p2 = fo(), d = nr(), m2 = yo(), A = xo();
          function g() {
            let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, { allowComments: L = true } = E;
            return function(F) {
              let { parseExpression: W } = Po(), Y;
              try {
                Y = W(F, { tokens: true, ranges: true });
              } catch (M) {
                throw A(M);
              }
              if (!L && p2(Y.comments))
                throw x(Y.comments[0], "Comment");
              return T(Y), Y;
            };
          }
          function x(E, L) {
            let [R, F] = [E.loc.start, E.loc.end].map((W) => {
              let { line: Y, column: M } = W;
              return { line: Y, column: M + 1 };
            });
            return d("".concat(L, " is not allowed in JSON."), { start: R, end: F });
          }
          function T(E) {
            switch (E.type) {
              case "ArrayExpression":
                for (let L of E.elements)
                  L !== null && T(L);
                return;
              case "ObjectExpression":
                for (let L of E.properties)
                  T(L);
                return;
              case "ObjectProperty":
                if (E.computed)
                  throw x(E.key, "Computed key");
                if (E.shorthand)
                  throw x(E.key, "Shorthand property");
                E.key.type !== "Identifier" && T(E.key), T(E.value);
                return;
              case "UnaryExpression": {
                let { operator: L, argument: R } = E;
                if (L !== "+" && L !== "-")
                  throw x(E, "Operator '".concat(E.operator, "'"));
                if (R.type === "NumericLiteral" || R.type === "Identifier" && (R.name === "Infinity" || R.name === "NaN"))
                  return;
                throw x(R, "Operator '".concat(L, "' before '").concat(R.type, "'"));
              }
              case "Identifier":
                if (E.name !== "Infinity" && E.name !== "NaN" && E.name !== "undefined")
                  throw x(E, "Identifier '".concat(E.name, "'"));
                return;
              case "TemplateLiteral":
                if (p2(E.expressions))
                  throw x(E.expressions[0], "'TemplateLiteral' with expression");
                for (let L of E.quasis)
                  T(L);
                return;
              case "NullLiteral":
              case "BooleanLiteral":
              case "NumericLiteral":
              case "StringLiteral":
              case "TemplateElement":
                return;
              default:
                throw x(E, "'".concat(E.type, "'"));
            }
          }
          var k = g(), D = { json: m2({ parse: k, hasPragma() {
            return true;
          } }), json5: m2(k), "json-stringify": m2({ parse: g({ allowComments: false }), astFormat: "estree-json" }) };
          l.exports = D;
        } });
        V();
        var Tf = ef(), Ef = Qn(), Cf = af(), ze = yo(), bf = xo(), vf = Af(), Sf = Pf(), wf = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", ["decorators", { decoratorsBeforeExport: false }], "importAssertions", "decimal", "moduleBlocks", "asyncDoExpressions", "regexpUnicodeSets", "destructuringPrivate", "decoratorAutoAccessors"], tokens: true, ranges: true }, Nf = ["recordAndTuple", { syntaxType: "hash" }], Wn = "v8intrinsic", Gn = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], ue = function(h3) {
          let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : wf;
          return Object.assign(Object.assign({}, l), {}, { plugins: [...l.plugins, ...h3] });
        }, If = /@(?:no)?flow\b/;
        function kf(h3, l) {
          if (l.filepath && l.filepath.endsWith(".js.flow"))
            return true;
          let p2 = Ef(h3);
          p2 && (h3 = h3.slice(p2.length));
          let d = Cf(h3, 0);
          return d !== false && (h3 = h3.slice(0, d)), If.test(h3);
        }
        function Df(h3, l, p2) {
          let m2 = Po()[h3](l, p2), A = m2.errors.find((g) => !Rf.has(g.reasonCode));
          if (A)
            throw A;
          return m2;
        }
        function Ke(h3) {
          for (var l = arguments.length, p2 = new Array(l > 1 ? l - 1 : 0), d = 1; d < l; d++)
            p2[d - 1] = arguments[d];
          return function(m2, A) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if ((g.parser === "babel" || g.parser === "__babel_estree") && kf(m2, g))
              return g.parser = "babel-flow", To(m2, A, g);
            let x = p2;
            g.__babelSourceType === "script" && (x = x.map((E) => Object.assign(Object.assign({}, E), {}, { sourceType: "script" }))), /#[[{]/.test(m2) && (x = x.map((E) => ue([Nf], E)));
            let T = /%[A-Z]/.test(m2);
            m2.includes("|>") ? x = (T ? [...Gn, Wn] : Gn).flatMap((L) => x.map((R) => ue([L], R))) : T && (x = x.map((E) => ue([Wn], E)));
            let { result: k, error: D } = Tf(...x.map((E) => () => Df(h3, m2, E)));
            if (!k)
              throw bf(D);
            return g.originalText = m2, vf(k, g);
          };
        }
        var Ff = Ke("parse", ue(["jsx", "flow"])), To = Ke("parse", ue(["jsx", ["flow", { all: true, enums: true }]])), Lf = Ke("parse", ue(["jsx", "typescript"]), ue(["typescript"])), Of = Ke("parse", ue(["jsx", "flow", "estree"])), Bf = Ke("parseExpression", ue(["jsx"])), Mf = Ke("parseExpression", ue(["typescript"])), Rf = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "UnexpectedParameterModifier", "MixedLabeledAndUnlabeledElements", "InvalidTupleMemberLabel", "NonClassMethodPropertyHasAbstractModifer", "ReadonlyForMethodSignature", "ClassMethodHasDeclare", "ClassMethodHasReadonly", "InvalidModifierOnTypeMember", "DuplicateAccessibilityModifier", "IndexSignatureHasDeclare", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "UnsupportedPropertyDecorator", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "DeclareFunctionHasImplementation", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Xn = ze(Ff), Jn = ze(Lf), Yn = ze(Bf), jf = ze(Mf);
        Eo.exports = { parsers: Object.assign(Object.assign({ babel: Xn, "babel-flow": ze(To), "babel-ts": Jn }, Sf), {}, { __js_expression: Yn, __vue_expression: Yn, __vue_ts_expression: jf, __vue_event_binding: Xn, __vue_ts_event_binding: Jn, __babel_estree: ze(Of) }) };
      });
      return qf();
    });
  }
});

// ../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-html.js
var require_parser_html = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-html.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.html = e();
      }
    })(function() {
      "use strict";
      var y = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
      var G = y((cl, zr) => {
        var we = function(e) {
          return e && e.Math == Math && e;
        };
        zr.exports = we(typeof globalThis == "object" && globalThis) || we(typeof window == "object" && window) || we(typeof self == "object" && self) || we(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var se = y((Dl, Wr) => {
        Wr.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var oe = y((ll, Yr) => {
        var bs = se();
        Yr.exports = !bs(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Ne = y((hl, Qr) => {
        var ws2 = se();
        Qr.exports = !ws2(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var ce = y((pl, Kr) => {
        var Ns = Ne(), Oe = Function.prototype.call;
        Kr.exports = Ns ? Oe.bind(Oe) : function() {
          return Oe.apply(Oe, arguments);
        };
      });
      var rt = y((et) => {
        "use strict";
        var Jr = {}.propertyIsEnumerable, Zr = Object.getOwnPropertyDescriptor, Os = Zr && !Jr.call({ 1: 2 }, 1);
        et.f = Os ? function(r) {
          var t = Zr(this, r);
          return !!t && t.enumerable;
        } : Jr;
      });
      var qe = y((dl, tt) => {
        tt.exports = function(e, r) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
        };
      });
      var Q = y((El, st) => {
        var ut = Ne(), nt = Function.prototype, qs = nt.bind, er = nt.call, Is = ut && qs.bind(er, er);
        st.exports = ut ? function(e) {
          return e && Is(e);
        } : function(e) {
          return e && function() {
            return er.apply(e, arguments);
          };
        };
      });
      var Ie = y((Cl, it) => {
        var at = Q(), Rs = at({}.toString), xs = at("".slice);
        it.exports = function(e) {
          return xs(Rs(e), 8, -1);
        };
      });
      var ct = y((ml, ot) => {
        var Ps = G(), ks = Q(), Ls = se(), Ms = Ie(), rr = Ps.Object, js = ks("".split);
        ot.exports = Ls(function() {
          return !rr("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return Ms(e) == "String" ? js(e, "") : rr(e);
        } : rr;
      });
      var tr = y((gl, Dt) => {
        var $s = G(), Us = $s.TypeError;
        Dt.exports = function(e) {
          if (e == null)
            throw Us("Can't call method on " + e);
          return e;
        };
      });
      var Re = y((Fl, lt) => {
        var Gs = ct(), Vs = tr();
        lt.exports = function(e) {
          return Gs(Vs(e));
        };
      });
      var K = y((Al, ht) => {
        ht.exports = function(e) {
          return typeof e == "function";
        };
      });
      var De = y((vl, pt) => {
        var Xs = K();
        pt.exports = function(e) {
          return typeof e == "object" ? e !== null : Xs(e);
        };
      });
      var ge = y((_l, ft) => {
        var ur = G(), Hs = K(), zs = function(e) {
          return Hs(e) ? e : void 0;
        };
        ft.exports = function(e, r) {
          return arguments.length < 2 ? zs(ur[e]) : ur[e] && ur[e][r];
        };
      });
      var nr = y((Sl, dt) => {
        var Ws = Q();
        dt.exports = Ws({}.isPrototypeOf);
      });
      var Ct = y((yl, Et) => {
        var Ys = ge();
        Et.exports = Ys("navigator", "userAgent") || "";
      });
      var St = y((Tl, _t) => {
        var vt = G(), sr = Ct(), mt = vt.process, gt = vt.Deno, Ft = mt && mt.versions || gt && gt.version, At = Ft && Ft.v8, te, xe;
        At && (te = At.split("."), xe = te[0] > 0 && te[0] < 4 ? 1 : +(te[0] + te[1]));
        !xe && sr && (te = sr.match(/Edge\/(\d+)/), (!te || te[1] >= 74) && (te = sr.match(/Chrome\/(\d+)/), te && (xe = +te[1])));
        _t.exports = xe;
      });
      var ar = y((Bl, Tt) => {
        var yt = St(), Qs = se();
        Tt.exports = !!Object.getOwnPropertySymbols && !Qs(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && yt && yt < 41;
        });
      });
      var ir = y((bl, Bt) => {
        var Ks = ar();
        Bt.exports = Ks && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var or = y((wl, bt) => {
        var Js = G(), Zs = ge(), ea = K(), ra = nr(), ta = ir(), ua = Js.Object;
        bt.exports = ta ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var r = Zs("Symbol");
          return ea(r) && ra(r.prototype, ua(e));
        };
      });
      var Pe = y((Nl, wt) => {
        var na = G(), sa = na.String;
        wt.exports = function(e) {
          try {
            return sa(e);
          } catch {
            return "Object";
          }
        };
      });
      var Fe = y((Ol, Nt) => {
        var aa = G(), ia = K(), oa = Pe(), ca = aa.TypeError;
        Nt.exports = function(e) {
          if (ia(e))
            return e;
          throw ca(oa(e) + " is not a function");
        };
      });
      var ke = y((ql, Ot) => {
        var Da = Fe();
        Ot.exports = function(e, r) {
          var t = e[r];
          return t == null ? void 0 : Da(t);
        };
      });
      var It = y((Il, qt) => {
        var la = G(), cr = ce(), Dr = K(), lr = De(), ha = la.TypeError;
        qt.exports = function(e, r) {
          var t, s;
          if (r === "string" && Dr(t = e.toString) && !lr(s = cr(t, e)) || Dr(t = e.valueOf) && !lr(s = cr(t, e)) || r !== "string" && Dr(t = e.toString) && !lr(s = cr(t, e)))
            return s;
          throw ha("Can't convert object to primitive value");
        };
      });
      var xt = y((Rl, Rt) => {
        Rt.exports = false;
      });
      var Le = y((xl, kt) => {
        var Pt = G(), pa = Object.defineProperty;
        kt.exports = function(e, r) {
          try {
            pa(Pt, e, { value: r, configurable: true, writable: true });
          } catch {
            Pt[e] = r;
          }
          return r;
        };
      });
      var Me = y((Pl, Mt) => {
        var fa = G(), da = Le(), Lt = "__core-js_shared__", Ea = fa[Lt] || da(Lt, {});
        Mt.exports = Ea;
      });
      var hr = y((kl, $t) => {
        var Ca = xt(), jt = Me();
        ($t.exports = function(e, r) {
          return jt[e] || (jt[e] = r !== void 0 ? r : {});
        })("versions", []).push({ version: "3.22.2", mode: Ca ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var pr = y((Ll, Ut) => {
        var ma = G(), ga = tr(), Fa = ma.Object;
        Ut.exports = function(e) {
          return Fa(ga(e));
        };
      });
      var ae = y((Ml, Gt) => {
        var Aa = Q(), va = pr(), _a = Aa({}.hasOwnProperty);
        Gt.exports = Object.hasOwn || function(r, t) {
          return _a(va(r), t);
        };
      });
      var fr = y((jl, Vt) => {
        var Sa = Q(), ya = 0, Ta = Math.random(), Ba = Sa(1 .toString);
        Vt.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + Ba(++ya + Ta, 36);
        };
      });
      var he = y(($l, Yt) => {
        var ba = G(), wa = hr(), Xt = ae(), Na = fr(), Ht = ar(), Wt = ir(), fe = wa("wks"), le = ba.Symbol, zt = le && le.for, Oa = Wt ? le : le && le.withoutSetter || Na;
        Yt.exports = function(e) {
          if (!Xt(fe, e) || !(Ht || typeof fe[e] == "string")) {
            var r = "Symbol." + e;
            Ht && Xt(le, e) ? fe[e] = le[e] : Wt && zt ? fe[e] = zt(r) : fe[e] = Oa(r);
          }
          return fe[e];
        };
      });
      var Zt = y((Ul, Jt) => {
        var qa = G(), Ia = ce(), Qt = De(), Kt = or(), Ra = ke(), xa = It(), Pa = he(), ka = qa.TypeError, La = Pa("toPrimitive");
        Jt.exports = function(e, r) {
          if (!Qt(e) || Kt(e))
            return e;
          var t = Ra(e, La), s;
          if (t) {
            if (r === void 0 && (r = "default"), s = Ia(t, e, r), !Qt(s) || Kt(s))
              return s;
            throw ka("Can't convert object to primitive value");
          }
          return r === void 0 && (r = "number"), xa(e, r);
        };
      });
      var je = y((Gl, eu) => {
        var Ma = Zt(), ja = or();
        eu.exports = function(e) {
          var r = Ma(e, "string");
          return ja(r) ? r : r + "";
        };
      });
      var uu = y((Vl, tu) => {
        var $a = G(), ru = De(), dr = $a.document, Ua = ru(dr) && ru(dr.createElement);
        tu.exports = function(e) {
          return Ua ? dr.createElement(e) : {};
        };
      });
      var Er = y((Xl, nu) => {
        var Ga = oe(), Va = se(), Xa = uu();
        nu.exports = !Ga && !Va(function() {
          return Object.defineProperty(Xa("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Cr = y((au) => {
        var Ha = oe(), za = ce(), Wa = rt(), Ya = qe(), Qa = Re(), Ka = je(), Ja = ae(), Za = Er(), su = Object.getOwnPropertyDescriptor;
        au.f = Ha ? su : function(r, t) {
          if (r = Qa(r), t = Ka(t), Za)
            try {
              return su(r, t);
            } catch {
            }
          if (Ja(r, t))
            return Ya(!za(Wa.f, r, t), r[t]);
        };
      });
      var ou = y((zl, iu) => {
        var ei = oe(), ri = se();
        iu.exports = ei && ri(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var de = y((Wl, Du) => {
        var cu = G(), ti = De(), ui = cu.String, ni = cu.TypeError;
        Du.exports = function(e) {
          if (ti(e))
            return e;
          throw ni(ui(e) + " is not an object");
        };
      });
      var Ue = y((hu) => {
        var si = G(), ai = oe(), ii = Er(), oi = ou(), $e = de(), lu = je(), ci = si.TypeError, mr = Object.defineProperty, Di = Object.getOwnPropertyDescriptor, gr = "enumerable", Fr = "configurable", Ar = "writable";
        hu.f = ai ? oi ? function(r, t, s) {
          if ($e(r), t = lu(t), $e(s), typeof r == "function" && t === "prototype" && "value" in s && Ar in s && !s[Ar]) {
            var c = Di(r, t);
            c && c[Ar] && (r[t] = s.value, s = { configurable: Fr in s ? s[Fr] : c[Fr], enumerable: gr in s ? s[gr] : c[gr], writable: false });
          }
          return mr(r, t, s);
        } : mr : function(r, t, s) {
          if ($e(r), t = lu(t), $e(s), ii)
            try {
              return mr(r, t, s);
            } catch {
            }
          if ("get" in s || "set" in s)
            throw ci("Accessors not supported");
          return "value" in s && (r[t] = s.value), r;
        };
      });
      var Ge = y((Ql, pu) => {
        var li = oe(), hi = Ue(), pi = qe();
        pu.exports = li ? function(e, r, t) {
          return hi.f(e, r, pi(1, t));
        } : function(e, r, t) {
          return e[r] = t, e;
        };
      });
      var Ve = y((Kl, fu) => {
        var fi = Q(), di = K(), vr = Me(), Ei = fi(Function.toString);
        di(vr.inspectSource) || (vr.inspectSource = function(e) {
          return Ei(e);
        });
        fu.exports = vr.inspectSource;
      });
      var Cu = y((Jl, Eu) => {
        var Ci = G(), mi = K(), gi = Ve(), du = Ci.WeakMap;
        Eu.exports = mi(du) && /native code/.test(gi(du));
      });
      var Fu = y((Zl, gu) => {
        var Fi = hr(), Ai = fr(), mu = Fi("keys");
        gu.exports = function(e) {
          return mu[e] || (mu[e] = Ai(e));
        };
      });
      var _r = y((e2, Au) => {
        Au.exports = {};
      });
      var Bu = y((r2, Tu) => {
        var vi = Cu(), yu = G(), Sr = Q(), _i = De(), Si = Ge(), yr = ae(), Tr = Me(), yi = Fu(), Ti = _r(), vu = "Object already initialized", br = yu.TypeError, Bi = yu.WeakMap, Xe, Ae, He, bi = function(e) {
          return He(e) ? Ae(e) : Xe(e, {});
        }, wi = function(e) {
          return function(r) {
            var t;
            if (!_i(r) || (t = Ae(r)).type !== e)
              throw br("Incompatible receiver, " + e + " required");
            return t;
          };
        };
        vi || Tr.state ? (ie = Tr.state || (Tr.state = new Bi()), _u = Sr(ie.get), Br = Sr(ie.has), Su = Sr(ie.set), Xe = function(e, r) {
          if (Br(ie, e))
            throw new br(vu);
          return r.facade = e, Su(ie, e, r), r;
        }, Ae = function(e) {
          return _u(ie, e) || {};
        }, He = function(e) {
          return Br(ie, e);
        }) : (pe = yi("state"), Ti[pe] = true, Xe = function(e, r) {
          if (yr(e, pe))
            throw new br(vu);
          return r.facade = e, Si(e, pe, r), r;
        }, Ae = function(e) {
          return yr(e, pe) ? e[pe] : {};
        }, He = function(e) {
          return yr(e, pe);
        });
        var ie, _u, Br, Su, pe;
        Tu.exports = { set: Xe, get: Ae, has: He, enforce: bi, getterFor: wi };
      });
      var Nu = y((t2, wu) => {
        var wr = oe(), Ni = ae(), bu = Function.prototype, Oi = wr && Object.getOwnPropertyDescriptor, Nr = Ni(bu, "name"), qi = Nr && function() {
        }.name === "something", Ii = Nr && (!wr || wr && Oi(bu, "name").configurable);
        wu.exports = { EXISTS: Nr, PROPER: qi, CONFIGURABLE: Ii };
      });
      var xu = y((u2, Ru) => {
        var Ri = G(), Ou = K(), xi = ae(), qu = Ge(), Pi = Le(), ki = Ve(), Iu = Bu(), Li = Nu().CONFIGURABLE, Mi = Iu.get, ji = Iu.enforce, $i = String(String).split("String");
        (Ru.exports = function(e, r, t, s) {
          var c = s ? !!s.unsafe : false, n = s ? !!s.enumerable : false, a = s ? !!s.noTargetGet : false, p2 = s && s.name !== void 0 ? s.name : r, D;
          if (Ou(t) && (String(p2).slice(0, 7) === "Symbol(" && (p2 = "[" + String(p2).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!xi(t, "name") || Li && t.name !== p2) && qu(t, "name", p2), D = ji(t), D.source || (D.source = $i.join(typeof p2 == "string" ? p2 : ""))), e === Ri) {
            n ? e[r] = t : Pi(r, t);
            return;
          } else
            c ? !a && e[r] && (n = true) : delete e[r];
          n ? e[r] = t : qu(e, r, t);
        })(Function.prototype, "toString", function() {
          return Ou(this) && Mi(this).source || ki(this);
        });
      });
      var Or = y((n2, Pu) => {
        var Ui = Math.ceil, Gi = Math.floor;
        Pu.exports = function(e) {
          var r = +e;
          return r !== r || r === 0 ? 0 : (r > 0 ? Gi : Ui)(r);
        };
      });
      var Lu = y((s2, ku) => {
        var Vi = Or(), Xi = Math.max, Hi = Math.min;
        ku.exports = function(e, r) {
          var t = Vi(e);
          return t < 0 ? Xi(t + r, 0) : Hi(t, r);
        };
      });
      var ju = y((a2, Mu) => {
        var zi = Or(), Wi = Math.min;
        Mu.exports = function(e) {
          return e > 0 ? Wi(zi(e), 9007199254740991) : 0;
        };
      });
      var ve = y((i2, $u) => {
        var Yi = ju();
        $u.exports = function(e) {
          return Yi(e.length);
        };
      });
      var Vu = y((o2, Gu) => {
        var Qi = Re(), Ki = Lu(), Ji = ve(), Uu = function(e) {
          return function(r, t, s) {
            var c = Qi(r), n = Ji(c), a = Ki(s, n), p2;
            if (e && t != t) {
              for (; n > a; )
                if (p2 = c[a++], p2 != p2)
                  return true;
            } else
              for (; n > a; a++)
                if ((e || a in c) && c[a] === t)
                  return e || a || 0;
            return !e && -1;
          };
        };
        Gu.exports = { includes: Uu(true), indexOf: Uu(false) };
      });
      var zu = y((c2, Hu) => {
        var Zi = Q(), qr = ae(), eo = Re(), ro = Vu().indexOf, to = _r(), Xu = Zi([].push);
        Hu.exports = function(e, r) {
          var t = eo(e), s = 0, c = [], n;
          for (n in t)
            !qr(to, n) && qr(t, n) && Xu(c, n);
          for (; r.length > s; )
            qr(t, n = r[s++]) && (~ro(c, n) || Xu(c, n));
          return c;
        };
      });
      var Yu = y((D2, Wu) => {
        Wu.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var Ku = y((Qu) => {
        var uo = zu(), no = Yu(), so = no.concat("length", "prototype");
        Qu.f = Object.getOwnPropertyNames || function(r) {
          return uo(r, so);
        };
      });
      var Zu = y((Ju) => {
        Ju.f = Object.getOwnPropertySymbols;
      });
      var rn = y((p2, en) => {
        var ao = ge(), io = Q(), oo = Ku(), co = Zu(), Do = de(), lo = io([].concat);
        en.exports = ao("Reflect", "ownKeys") || function(r) {
          var t = oo.f(Do(r)), s = co.f;
          return s ? lo(t, s(r)) : t;
        };
      });
      var nn = y((f2, un) => {
        var tn = ae(), ho = rn(), po = Cr(), fo = Ue();
        un.exports = function(e, r, t) {
          for (var s = ho(r), c = fo.f, n = po.f, a = 0; a < s.length; a++) {
            var p2 = s[a];
            !tn(e, p2) && !(t && tn(t, p2)) && c(e, p2, n(r, p2));
          }
        };
      });
      var an = y((d2, sn) => {
        var Eo = se(), Co = K(), mo = /#|\.prototype\./, _e = function(e, r) {
          var t = Fo[go(e)];
          return t == vo ? true : t == Ao ? false : Co(r) ? Eo(r) : !!r;
        }, go = _e.normalize = function(e) {
          return String(e).replace(mo, ".").toLowerCase();
        }, Fo = _e.data = {}, Ao = _e.NATIVE = "N", vo = _e.POLYFILL = "P";
        sn.exports = _e;
      });
      var ze = y((E2, on) => {
        var Ir = G(), _o = Cr().f, So = Ge(), yo = xu(), To = Le(), Bo = nn(), bo = an();
        on.exports = function(e, r) {
          var t = e.target, s = e.global, c = e.stat, n, a, p2, D, g, i;
          if (s ? a = Ir : c ? a = Ir[t] || To(t, {}) : a = (Ir[t] || {}).prototype, a)
            for (p2 in r) {
              if (g = r[p2], e.noTargetGet ? (i = _o(a, p2), D = i && i.value) : D = a[p2], n = bo(s ? p2 : t + (c ? "." : "#") + p2, e.forced), !n && D !== void 0) {
                if (typeof g == typeof D)
                  continue;
                Bo(g, D);
              }
              (e.sham || D && D.sham) && So(g, "sham", true), yo(a, p2, g, e);
            }
        };
      });
      var cn = y(() => {
        var wo = ze(), No = G();
        wo({ global: true }, { globalThis: No });
      });
      var Dn = y(() => {
        cn();
      });
      var Rr = y((A2, ln) => {
        var Oo = Ie();
        ln.exports = Array.isArray || function(r) {
          return Oo(r) == "Array";
        };
      });
      var xr = y((v2, pn) => {
        var hn = Q(), qo = Fe(), Io = Ne(), Ro = hn(hn.bind);
        pn.exports = function(e, r) {
          return qo(e), r === void 0 ? e : Io ? Ro(e, r) : function() {
            return e.apply(r, arguments);
          };
        };
      });
      var En = y((_2, dn) => {
        "use strict";
        var xo = G(), Po = Rr(), ko = ve(), Lo = xr(), Mo = xo.TypeError, fn = function(e, r, t, s, c, n, a, p2) {
          for (var D = c, g = 0, i = a ? Lo(a, p2) : false, l, h3; g < s; ) {
            if (g in t) {
              if (l = i ? i(t[g], g, r) : t[g], n > 0 && Po(l))
                h3 = ko(l), D = fn(e, r, l, h3, D, n - 1) - 1;
              else {
                if (D >= 9007199254740991)
                  throw Mo("Exceed the acceptable array length");
                e[D] = l;
              }
              D++;
            }
            g++;
          }
          return D;
        };
        dn.exports = fn;
      });
      var gn = y((S2, mn) => {
        var jo = he(), $o = jo("toStringTag"), Cn = {};
        Cn[$o] = "z";
        mn.exports = String(Cn) === "[object z]";
      });
      var Pr = y((y2, Fn) => {
        var Uo = G(), Go = gn(), Vo = K(), We = Ie(), Xo = he(), Ho = Xo("toStringTag"), zo = Uo.Object, Wo = We(function() {
          return arguments;
        }()) == "Arguments", Yo = function(e, r) {
          try {
            return e[r];
          } catch {
          }
        };
        Fn.exports = Go ? We : function(e) {
          var r, t, s;
          return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Yo(r = zo(e), Ho)) == "string" ? t : Wo ? We(r) : (s = We(r)) == "Object" && Vo(r.callee) ? "Arguments" : s;
        };
      });
      var Tn = y((T2, yn) => {
        var Qo = Q(), Ko = se(), An = K(), Jo = Pr(), Zo = ge(), ec = Ve(), vn = function() {
        }, rc = [], _n2 = Zo("Reflect", "construct"), kr = /^\s*(?:class|function)\b/, tc = Qo(kr.exec), uc = !kr.exec(vn), Se = function(r) {
          if (!An(r))
            return false;
          try {
            return _n2(vn, rc, r), true;
          } catch {
            return false;
          }
        }, Sn = function(r) {
          if (!An(r))
            return false;
          switch (Jo(r)) {
            case "AsyncFunction":
            case "GeneratorFunction":
            case "AsyncGeneratorFunction":
              return false;
          }
          try {
            return uc || !!tc(kr, ec(r));
          } catch {
            return true;
          }
        };
        Sn.sham = true;
        yn.exports = !_n2 || Ko(function() {
          var e;
          return Se(Se.call) || !Se(Object) || !Se(function() {
            e = true;
          }) || e;
        }) ? Sn : Se;
      });
      var Nn = y((B2, wn) => {
        var nc = G(), Bn = Rr(), sc = Tn(), ac = De(), ic = he(), oc = ic("species"), bn = nc.Array;
        wn.exports = function(e) {
          var r;
          return Bn(e) && (r = e.constructor, sc(r) && (r === bn || Bn(r.prototype)) ? r = void 0 : ac(r) && (r = r[oc], r === null && (r = void 0))), r === void 0 ? bn : r;
        };
      });
      var qn = y((b2, On) => {
        var cc = Nn();
        On.exports = function(e, r) {
          return new (cc(e))(r === 0 ? 0 : r);
        };
      });
      var In = y(() => {
        "use strict";
        var Dc = ze(), lc = En(), hc = Fe(), pc = pr(), fc = ve(), dc = qn();
        Dc({ target: "Array", proto: true }, { flatMap: function(r) {
          var t = pc(this), s = fc(t), c;
          return hc(r), c = dc(t, 0), c.length = lc(c, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), c;
        } });
      });
      var Lr = y((O2, Rn) => {
        Rn.exports = {};
      });
      var Pn = y((q2, xn) => {
        var Ec = he(), Cc = Lr(), mc = Ec("iterator"), gc = Array.prototype;
        xn.exports = function(e) {
          return e !== void 0 && (Cc.Array === e || gc[mc] === e);
        };
      });
      var Mr = y((I2, Ln) => {
        var Fc = Pr(), kn = ke(), Ac = Lr(), vc = he(), _c = vc("iterator");
        Ln.exports = function(e) {
          if (e != null)
            return kn(e, _c) || kn(e, "@@iterator") || Ac[Fc(e)];
        };
      });
      var jn = y((R2, Mn) => {
        var Sc = G(), yc = ce(), Tc = Fe(), Bc = de(), bc2 = Pe(), wc = Mr(), Nc = Sc.TypeError;
        Mn.exports = function(e, r) {
          var t = arguments.length < 2 ? wc(e) : r;
          if (Tc(t))
            return Bc(yc(t, e));
          throw Nc(bc2(e) + " is not iterable");
        };
      });
      var Gn = y((x2, Un) => {
        var Oc = ce(), $n = de(), qc = ke();
        Un.exports = function(e, r, t) {
          var s, c;
          $n(e);
          try {
            if (s = qc(e, "return"), !s) {
              if (r === "throw")
                throw t;
              return t;
            }
            s = Oc(s, e);
          } catch (n) {
            c = true, s = n;
          }
          if (r === "throw")
            throw t;
          if (c)
            throw s;
          return $n(s), t;
        };
      });
      var Wn = y((P2, zn) => {
        var Ic = G(), Rc = xr(), xc = ce(), Pc = de(), kc = Pe(), Lc = Pn(), Mc = ve(), Vn = nr(), jc = jn(), $c = Mr(), Xn = Gn(), Uc = Ic.TypeError, Ye = function(e, r) {
          this.stopped = e, this.result = r;
        }, Hn = Ye.prototype;
        zn.exports = function(e, r, t) {
          var s = t && t.that, c = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_ITERATOR), a = !!(t && t.INTERRUPTED), p2 = Rc(r, s), D, g, i, l, h3, C, d, m2 = function(B) {
            return D && Xn(D, "normal", B), new Ye(true, B);
          }, T = function(B) {
            return c ? (Pc(B), a ? p2(B[0], B[1], m2) : p2(B[0], B[1])) : a ? p2(B, m2) : p2(B);
          };
          if (n)
            D = e;
          else {
            if (g = $c(e), !g)
              throw Uc(kc(e) + " is not iterable");
            if (Lc(g)) {
              for (i = 0, l = Mc(e); l > i; i++)
                if (h3 = T(e[i]), h3 && Vn(Hn, h3))
                  return h3;
              return new Ye(false);
            }
            D = jc(e, g);
          }
          for (C = D.next; !(d = xc(C, D)).done; ) {
            try {
              h3 = T(d.value);
            } catch (B) {
              Xn(D, "throw", B);
            }
            if (typeof h3 == "object" && h3 && Vn(Hn, h3))
              return h3;
          }
          return new Ye(false);
        };
      });
      var Qn = y((k2, Yn) => {
        "use strict";
        var Gc = je(), Vc = Ue(), Xc = qe();
        Yn.exports = function(e, r, t) {
          var s = Gc(r);
          s in e ? Vc.f(e, s, Xc(0, t)) : e[s] = t;
        };
      });
      var Kn = y(() => {
        var Hc = ze(), zc = Wn(), Wc = Qn();
        Hc({ target: "Object", stat: true }, { fromEntries: function(r) {
          var t = {};
          return zc(r, function(s, c) {
            Wc(t, s, c);
          }, { AS_ENTRIES: true }), t;
        } });
      });
      var il = y((j2, Bs) => {
        var Yc = ["cliName", "cliCategory", "cliDescription"], Jn, Zn, es, rs, ts, us;
        function Qc(e, r) {
          if (e == null)
            return {};
          var t = Kc(e, r), s, c;
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            for (c = 0; c < n.length; c++)
              s = n[c], !(r.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(e, s) || (t[s] = e[s]));
          }
          return t;
        }
        function Kc(e, r) {
          if (e == null)
            return {};
          var t = {}, s = Object.keys(e), c, n;
          for (n = 0; n < s.length; n++)
            c = s[n], !(r.indexOf(c) >= 0) && (t[c] = e[c]);
          return t;
        }
        function Ee(e, r) {
          return r || (r = e.slice(0)), Object.freeze(Object.defineProperties(e, { raw: { value: Object.freeze(r) } }));
        }
        Dn();
        In();
        Kn();
        var Jc = Object.create, Je = Object.defineProperty, Zc = Object.getOwnPropertyDescriptor, $r = Object.getOwnPropertyNames, eD = Object.getPrototypeOf, rD = Object.prototype.hasOwnProperty, Ce = (e, r) => function() {
          return e && (r = (0, e[$r(e)[0]])(e = 0)), r;
        }, I = (e, r) => function() {
          return r || (0, e[$r(e)[0]])((r = { exports: {} }).exports, r), r.exports;
        }, cs = (e, r) => {
          for (var t in r)
            Je(e, t, { get: r[t], enumerable: true });
        }, Ds = (e, r, t, s) => {
          if (r && typeof r == "object" || typeof r == "function")
            for (let c of $r(r))
              !rD.call(e, c) && c !== t && Je(e, c, { get: () => r[c], enumerable: !(s = Zc(r, c)) || s.enumerable });
          return e;
        }, tD = (e, r, t) => (t = e != null ? Jc(eD(e)) : {}, Ds(r || !e || !e.__esModule ? Je(t, "default", { value: e, enumerable: true }) : t, e)), ls = (e) => Ds(Je({}, "__esModule", { value: true }), e), ns, ss, ye, q = Ce({ "<define:process>"() {
          ns = {}, ss = [], ye = { env: ns, argv: ss };
        } }), hs = I({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
          function r(p2) {
            return p2 >= e.$TAB && p2 <= e.$SPACE || p2 == e.$NBSP;
          }
          e.isWhitespace = r;
          function t(p2) {
            return e.$0 <= p2 && p2 <= e.$9;
          }
          e.isDigit = t;
          function s(p2) {
            return p2 >= e.$a && p2 <= e.$z || p2 >= e.$A && p2 <= e.$Z;
          }
          e.isAsciiLetter = s;
          function c(p2) {
            return p2 >= e.$a && p2 <= e.$f || p2 >= e.$A && p2 <= e.$F || t(p2);
          }
          e.isAsciiHexDigit = c;
          function n(p2) {
            return p2 === e.$LF || p2 === e.$CR;
          }
          e.isNewLine = n;
          function a(p2) {
            return e.$0 <= p2 && p2 <= e.$7;
          }
          e.isOctalDigit = a;
        } }), uD = I({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = class {
            constructor(s, c, n) {
              this.filePath = s, this.name = c, this.members = n;
            }
            assertNoMembers() {
              if (this.members.length)
                throw new Error("Illegal state: symbol without members expected, but got ".concat(JSON.stringify(this), "."));
            }
          };
          e.StaticSymbol = r;
          var t = class {
            constructor() {
              this.cache = /* @__PURE__ */ new Map();
            }
            get(s, c, n) {
              n = n || [];
              let a = n.length ? ".".concat(n.join(".")) : "", p2 = '"'.concat(s, '".').concat(c).concat(a), D = this.cache.get(p2);
              return D || (D = new r(s, c, n), this.cache.set(p2, D)), D;
            }
          };
          e.StaticSymbolCache = t;
        } }), nD = I({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = /-+([a-z0-9])/g;
          function t(o) {
            return o.replace(r, function() {
              for (var E = arguments.length, f = new Array(E), F = 0; F < E; F++)
                f[F] = arguments[F];
              return f[1].toUpperCase();
            });
          }
          e.dashCaseToCamelCase = t;
          function s(o, E) {
            return n(o, ":", E);
          }
          e.splitAtColon = s;
          function c(o, E) {
            return n(o, ".", E);
          }
          e.splitAtPeriod = c;
          function n(o, E, f) {
            let F = o.indexOf(E);
            return F == -1 ? f : [o.slice(0, F).trim(), o.slice(F + 1).trim()];
          }
          function a(o, E, f) {
            return Array.isArray(o) ? E.visitArray(o, f) : A(o) ? E.visitStringMap(o, f) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? E.visitPrimitive(o, f) : E.visitOther(o, f);
          }
          e.visitValue = a;
          function p2(o) {
            return o != null;
          }
          e.isDefined = p2;
          function D(o) {
            return o === void 0 ? null : o;
          }
          e.noUndefined = D;
          var g = class {
            visitArray(o, E) {
              return o.map((f) => a(f, this, E));
            }
            visitStringMap(o, E) {
              let f = {};
              return Object.keys(o).forEach((F) => {
                f[F] = a(o[F], this, E);
              }), f;
            }
            visitPrimitive(o, E) {
              return o;
            }
            visitOther(o, E) {
              return o;
            }
          };
          e.ValueTransformer = g, e.SyncAsync = { assertSync: (o) => {
            if (_(o))
              throw new Error("Illegal state: value cannot be a promise");
            return o;
          }, then: (o, E) => _(o) ? o.then(E) : E(o), all: (o) => o.some(_) ? Promise.all(o) : o };
          function i(o) {
            throw new Error("Internal Error: ".concat(o));
          }
          e.error = i;
          function l(o, E) {
            let f = Error(o);
            return f[h3] = true, E && (f[C] = E), f;
          }
          e.syntaxError = l;
          var h3 = "ngSyntaxError", C = "ngParseErrors";
          function d(o) {
            return o[h3];
          }
          e.isSyntaxError = d;
          function m2(o) {
            return o[C] || [];
          }
          e.getParseErrors = m2;
          function T(o) {
            return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          e.escapeRegExp = T;
          var B = Object.getPrototypeOf({});
          function A(o) {
            return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === B;
          }
          function N(o) {
            let E = "";
            for (let f = 0; f < o.length; f++) {
              let F = o.charCodeAt(f);
              if (F >= 55296 && F <= 56319 && o.length > f + 1) {
                let P = o.charCodeAt(f + 1);
                P >= 56320 && P <= 57343 && (f++, F = (F - 55296 << 10) + P - 56320 + 65536);
              }
              F <= 127 ? E += String.fromCharCode(F) : F <= 2047 ? E += String.fromCharCode(F >> 6 & 31 | 192, F & 63 | 128) : F <= 65535 ? E += String.fromCharCode(F >> 12 | 224, F >> 6 & 63 | 128, F & 63 | 128) : F <= 2097151 && (E += String.fromCharCode(F >> 18 & 7 | 240, F >> 12 & 63 | 128, F >> 6 & 63 | 128, F & 63 | 128));
            }
            return E;
          }
          e.utf8Encode = N;
          function R(o) {
            if (typeof o == "string")
              return o;
            if (o instanceof Array)
              return "[" + o.map(R).join(", ") + "]";
            if (o == null)
              return "" + o;
            if (o.overriddenName)
              return "".concat(o.overriddenName);
            if (o.name)
              return "".concat(o.name);
            if (!o.toString)
              return "object";
            let E = o.toString();
            if (E == null)
              return "" + E;
            let f = E.indexOf(`
`);
            return f === -1 ? E : E.substring(0, f);
          }
          e.stringify = R;
          function $2(o) {
            return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
          }
          e.resolveForwardRef = $2;
          function _(o) {
            return !!o && typeof o.then == "function";
          }
          e.isPromise = _;
          var O = class {
            constructor(o) {
              this.full = o;
              let E = o.split(".");
              this.major = E[0], this.minor = E[1], this.patch = E.slice(2).join(".");
            }
          };
          e.Version = O;
          var x = typeof window < "u" && window, k = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, M = typeof globalThis < "u" && globalThis, u = M || x || k;
          e.global = u;
        } }), sD = I({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = uD(), t = nD(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
          function c(f) {
            return f.replace(/\W/g, "_");
          }
          e.sanitizeIdentifier = c;
          var n = 0;
          function a(f) {
            if (!f || !f.reference)
              return null;
            let F = f.reference;
            if (F instanceof r.StaticSymbol)
              return F.name;
            if (F.__anonymousType)
              return F.__anonymousType;
            let P = t.stringify(F);
            return P.indexOf("(") >= 0 ? (P = "anonymous_".concat(n++), F.__anonymousType = P) : P = c(P), P;
          }
          e.identifierName = a;
          function p2(f) {
            let F = f.reference;
            return F instanceof r.StaticSymbol ? F.filePath : "./".concat(t.stringify(F));
          }
          e.identifierModuleUrl = p2;
          function D(f, F) {
            return "View_".concat(a({ reference: f }), "_").concat(F);
          }
          e.viewClassName = D;
          function g(f) {
            return "RenderType_".concat(a({ reference: f }));
          }
          e.rendererTypeName = g;
          function i(f) {
            return "HostView_".concat(a({ reference: f }));
          }
          e.hostViewClassName = i;
          function l(f) {
            return "".concat(a({ reference: f }), "NgFactory");
          }
          e.componentFactoryName = l;
          var h3;
          (function(f) {
            f[f.Pipe = 0] = "Pipe", f[f.Directive = 1] = "Directive", f[f.NgModule = 2] = "NgModule", f[f.Injectable = 3] = "Injectable";
          })(h3 = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
          function C(f) {
            return f.value != null ? c(f.value) : a(f.identifier);
          }
          e.tokenName = C;
          function d(f) {
            return f.identifier != null ? f.identifier.reference : f.value;
          }
          e.tokenReference = d;
          var m2 = class {
            constructor() {
              let { moduleUrl: f, styles: F, styleUrls: P } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.moduleUrl = f || null, this.styles = _(F), this.styleUrls = _(P);
            }
          };
          e.CompileStylesheetMetadata = m2;
          var T = class {
            constructor(f) {
              let { encapsulation: F, template: P, templateUrl: j, htmlAst: W, styles: X, styleUrls: H, externalStylesheets: z, animations: J, ngContentSelectors: Z, interpolation: ee, isInline: v, preserveWhitespaces: S } = f;
              if (this.encapsulation = F, this.template = P, this.templateUrl = j, this.htmlAst = W, this.styles = _(X), this.styleUrls = _(H), this.externalStylesheets = _(z), this.animations = J ? x(J) : [], this.ngContentSelectors = Z || [], ee && ee.length != 2)
                throw new Error("'interpolation' should have a start and an end symbol.");
              this.interpolation = ee, this.isInline = v, this.preserveWhitespaces = S;
            }
            toSummary() {
              return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
            }
          };
          e.CompileTemplateMetadata = T;
          var B = class {
            static create(f) {
              let { isHost: F, type: P, isComponent: j, selector: W, exportAs: X, changeDetection: H, inputs: z, outputs: J, host: Z, providers: ee, viewProviders: v, queries: S, guards: b, viewQueries: w, entryComponents: L, template: U, componentViewType: V, rendererType: Y, componentFactory: ue } = f, Be = {}, be = {}, Vr = {};
              Z != null && Object.keys(Z).forEach((re) => {
                let ne = Z[re], me = re.match(s);
                me === null ? Vr[re] = ne : me[1] != null ? be[me[1]] = ne : me[2] != null && (Be[me[2]] = ne);
              });
              let Xr = {};
              z != null && z.forEach((re) => {
                let ne = t.splitAtColon(re, [re, re]);
                Xr[ne[0]] = ne[1];
              });
              let Hr = {};
              return J != null && J.forEach((re) => {
                let ne = t.splitAtColon(re, [re, re]);
                Hr[ne[0]] = ne[1];
              }), new B({ isHost: F, type: P, isComponent: !!j, selector: W, exportAs: X, changeDetection: H, inputs: Xr, outputs: Hr, hostListeners: Be, hostProperties: be, hostAttributes: Vr, providers: ee, viewProviders: v, queries: S, guards: b, viewQueries: w, entryComponents: L, template: U, componentViewType: V, rendererType: Y, componentFactory: ue });
            }
            constructor(f) {
              let { isHost: F, type: P, isComponent: j, selector: W, exportAs: X, changeDetection: H, inputs: z, outputs: J, hostListeners: Z, hostProperties: ee, hostAttributes: v, providers: S, viewProviders: b, queries: w, guards: L, viewQueries: U, entryComponents: V, template: Y, componentViewType: ue, rendererType: Be, componentFactory: be } = f;
              this.isHost = !!F, this.type = P, this.isComponent = j, this.selector = W, this.exportAs = X, this.changeDetection = H, this.inputs = z, this.outputs = J, this.hostListeners = Z, this.hostProperties = ee, this.hostAttributes = v, this.providers = _(S), this.viewProviders = _(b), this.queries = _(w), this.guards = L, this.viewQueries = _(U), this.entryComponents = _(V), this.template = Y, this.componentViewType = ue, this.rendererType = Be, this.componentFactory = be;
            }
            toSummary() {
              return { summaryKind: h3.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
            }
          };
          e.CompileDirectiveMetadata = B;
          var A = class {
            constructor(f) {
              let { type: F, name: P, pure: j } = f;
              this.type = F, this.name = P, this.pure = !!j;
            }
            toSummary() {
              return { summaryKind: h3.Pipe, type: this.type, name: this.name, pure: this.pure };
            }
          };
          e.CompilePipeMetadata = A;
          var N = class {
          };
          e.CompileShallowModuleMetadata = N;
          var R = class {
            constructor(f) {
              let { type: F, providers: P, declaredDirectives: j, exportedDirectives: W, declaredPipes: X, exportedPipes: H, entryComponents: z, bootstrapComponents: J, importedModules: Z, exportedModules: ee, schemas: v, transitiveModule: S, id: b } = f;
              this.type = F || null, this.declaredDirectives = _(j), this.exportedDirectives = _(W), this.declaredPipes = _(X), this.exportedPipes = _(H), this.providers = _(P), this.entryComponents = _(z), this.bootstrapComponents = _(J), this.importedModules = _(Z), this.exportedModules = _(ee), this.schemas = _(v), this.id = b || null, this.transitiveModule = S || null;
            }
            toSummary() {
              let f = this.transitiveModule;
              return { summaryKind: h3.NgModule, type: this.type, entryComponents: f.entryComponents, providers: f.providers, modules: f.modules, exportedDirectives: f.exportedDirectives, exportedPipes: f.exportedPipes };
            }
          };
          e.CompileNgModuleMetadata = R;
          var $2 = class {
            constructor() {
              this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
            }
            addProvider(f, F) {
              this.providers.push({ provider: f, module: F });
            }
            addDirective(f) {
              this.directivesSet.has(f.reference) || (this.directivesSet.add(f.reference), this.directives.push(f));
            }
            addExportedDirective(f) {
              this.exportedDirectivesSet.has(f.reference) || (this.exportedDirectivesSet.add(f.reference), this.exportedDirectives.push(f));
            }
            addPipe(f) {
              this.pipesSet.has(f.reference) || (this.pipesSet.add(f.reference), this.pipes.push(f));
            }
            addExportedPipe(f) {
              this.exportedPipesSet.has(f.reference) || (this.exportedPipesSet.add(f.reference), this.exportedPipes.push(f));
            }
            addModule(f) {
              this.modulesSet.has(f.reference) || (this.modulesSet.add(f.reference), this.modules.push(f));
            }
            addEntryComponent(f) {
              this.entryComponentsSet.has(f.componentType) || (this.entryComponentsSet.add(f.componentType), this.entryComponents.push(f));
            }
          };
          e.TransitiveCompileNgModuleMetadata = $2;
          function _(f) {
            return f || [];
          }
          var O = class {
            constructor(f, F) {
              let { useClass: P, useValue: j, useExisting: W, useFactory: X, deps: H, multi: z } = F;
              this.token = f, this.useClass = P || null, this.useValue = j, this.useExisting = W, this.useFactory = X || null, this.dependencies = H || null, this.multi = !!z;
            }
          };
          e.ProviderMeta = O;
          function x(f) {
            return f.reduce((F, P) => {
              let j = Array.isArray(P) ? x(P) : P;
              return F.concat(j);
            }, []);
          }
          e.flatten = x;
          function k(f) {
            return f.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
          }
          function M(f, F, P) {
            let j;
            return P.isInline ? F.type.reference instanceof r.StaticSymbol ? j = "".concat(F.type.reference.filePath, ".").concat(F.type.reference.name, ".html") : j = "".concat(a(f), "/").concat(a(F.type), ".html") : j = P.templateUrl, F.type.reference instanceof r.StaticSymbol ? j : k(j);
          }
          e.templateSourceUrl = M;
          function u(f, F) {
            let P = f.moduleUrl.split(/\/\\/g), j = P[P.length - 1];
            return k("css/".concat(F).concat(j, ".ngstyle.js"));
          }
          e.sharedStylesheetJitUrl = u;
          function o(f) {
            return k("".concat(a(f.type), "/module.ngfactory.js"));
          }
          e.ngModuleJitUrl = o;
          function E(f, F) {
            return k("".concat(a(f), "/").concat(a(F.type), ".ngfactory.js"));
          }
          e.templateJitUrl = E;
        } }), Te = I({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = hs(), t = sD(), s = class {
            constructor(i, l, h3, C) {
              this.file = i, this.offset = l, this.line = h3, this.col = C;
            }
            toString() {
              return this.offset != null ? "".concat(this.file.url, "@").concat(this.line, ":").concat(this.col) : this.file.url;
            }
            moveBy(i) {
              let l = this.file.content, h3 = l.length, C = this.offset, d = this.line, m2 = this.col;
              for (; C > 0 && i < 0; )
                if (C--, i++, l.charCodeAt(C) == r.$LF) {
                  d--;
                  let B = l.substr(0, C - 1).lastIndexOf(String.fromCharCode(r.$LF));
                  m2 = B > 0 ? C - B : C;
                } else
                  m2--;
              for (; C < h3 && i > 0; ) {
                let T = l.charCodeAt(C);
                C++, i--, T == r.$LF ? (d++, m2 = 0) : m2++;
              }
              return new s(this.file, C, d, m2);
            }
            getContext(i, l) {
              let h3 = this.file.content, C = this.offset;
              if (C != null) {
                C > h3.length - 1 && (C = h3.length - 1);
                let d = C, m2 = 0, T = 0;
                for (; m2 < i && C > 0 && (C--, m2++, !(h3[C] == `
` && ++T == l)); )
                  ;
                for (m2 = 0, T = 0; m2 < i && d < h3.length - 1 && (d++, m2++, !(h3[d] == `
` && ++T == l)); )
                  ;
                return { before: h3.substring(C, this.offset), after: h3.substring(this.offset, d + 1) };
              }
              return null;
            }
          };
          e.ParseLocation = s;
          var c = class {
            constructor(i, l) {
              this.content = i, this.url = l;
            }
          };
          e.ParseSourceFile = c;
          var n = class {
            constructor(i, l) {
              let h3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              this.start = i, this.end = l, this.details = h3;
            }
            toString() {
              return this.start.file.content.substring(this.start.offset, this.end.offset);
            }
          };
          e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new c("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
          var a;
          (function(i) {
            i[i.WARNING = 0] = "WARNING", i[i.ERROR = 1] = "ERROR";
          })(a = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
          var p2 = class {
            constructor(i, l) {
              let h3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : a.ERROR;
              this.span = i, this.msg = l, this.level = h3;
            }
            contextualMessage() {
              let i = this.span.start.getContext(100, 3);
              return i ? "".concat(this.msg, ' ("').concat(i.before, "[").concat(a[this.level], " ->]").concat(i.after, '")') : this.msg;
            }
            toString() {
              let i = this.span.details ? ", ".concat(this.span.details) : "";
              return "".concat(this.contextualMessage(), ": ").concat(this.span.start).concat(i);
            }
          };
          e.ParseError = p2;
          function D(i, l) {
            let h3 = t.identifierModuleUrl(l), C = h3 != null ? "in ".concat(i, " ").concat(t.identifierName(l), " in ").concat(h3) : "in ".concat(i, " ").concat(t.identifierName(l)), d = new c("", C);
            return new n(new s(d, -1, -1, -1), new s(d, -1, -1, -1));
          }
          e.typeSourceSpan = D;
          function g(i, l, h3) {
            let C = "in ".concat(i, " ").concat(l, " in ").concat(h3), d = new c("", C);
            return new n(new s(d, -1, -1, -1), new s(d, -1, -1, -1));
          }
          e.r3JitTypeSourceSpan = g;
        } }), aD = I({ "src/utils/front-matter/parse.js"(e, r) {
          "use strict";
          q();
          var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function s(c) {
            let n = c.match(t);
            if (!n)
              return { content: c };
            let { startDelimiter: a, language: p2, value: D = "", endDelimiter: g } = n.groups, i = p2.trim() || "yaml";
            if (a === "+++" && (i = "toml"), i !== "yaml" && a !== g)
              return { content: c };
            let [l] = n;
            return { frontMatter: { type: "front-matter", lang: i, value: D, startDelimiter: a, endDelimiter: g, raw: l.replace(/\n$/, "") }, content: l.replace(/[^\n]/g, " ") + c.slice(l.length) };
          }
          r.exports = s;
        } }), ps = I({ "src/utils/get-last.js"(e, r) {
          "use strict";
          q();
          var t = (s) => s[s.length - 1];
          r.exports = t;
        } }), iD = I({ "src/common/parser-create-error.js"(e, r) {
          "use strict";
          q();
          function t(s, c) {
            let n = new SyntaxError(s + " (" + c.start.line + ":" + c.start.column + ")");
            return n.loc = c, n;
          }
          r.exports = t;
        } }), fs = {};
        cs(fs, { default: () => oD });
        function oD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a string");
          return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
        }
        var cD = Ce({ "node_modules/escape-string-regexp/index.js"() {
          q();
        } }), ds = I({ "node_modules/semver/internal/debug.js"(e, r) {
          q();
          var t = typeof ye == "object" && ye.env && ye.env.NODE_DEBUG && /\bsemver\b/i.test(ye.env.NODE_DEBUG) ? function() {
            for (var s = arguments.length, c = new Array(s), n = 0; n < s; n++)
              c[n] = arguments[n];
            return console.error("SEMVER", ...c);
          } : () => {
          };
          r.exports = t;
        } }), Es = I({ "node_modules/semver/internal/constants.js"(e, r) {
          q();
          var t = "2.0.0", s = 256, c = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
          r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: c, MAX_SAFE_COMPONENT_LENGTH: n };
        } }), DD = I({ "node_modules/semver/internal/re.js"(e, r) {
          q();
          var { MAX_SAFE_COMPONENT_LENGTH: t } = Es(), s = ds();
          e = r.exports = {};
          var c = e.re = [], n = e.src = [], a = e.t = {}, p2 = 0, D = (g, i, l) => {
            let h3 = p2++;
            s(g, h3, i), a[g] = h3, n[h3] = i, c[h3] = new RegExp(i, l ? "g" : void 0);
          };
          D("NUMERICIDENTIFIER", "0|[1-9]\\d*"), D("NUMERICIDENTIFIERLOOSE", "[0-9]+"), D("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), D("MAINVERSION", "(".concat(n[a.NUMERICIDENTIFIER], ")\\.(").concat(n[a.NUMERICIDENTIFIER], ")\\.(").concat(n[a.NUMERICIDENTIFIER], ")")), D("MAINVERSIONLOOSE", "(".concat(n[a.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(n[a.NUMERICIDENTIFIERLOOSE], ")\\.(").concat(n[a.NUMERICIDENTIFIERLOOSE], ")")), D("PRERELEASEIDENTIFIER", "(?:".concat(n[a.NUMERICIDENTIFIER], "|").concat(n[a.NONNUMERICIDENTIFIER], ")")), D("PRERELEASEIDENTIFIERLOOSE", "(?:".concat(n[a.NUMERICIDENTIFIERLOOSE], "|").concat(n[a.NONNUMERICIDENTIFIER], ")")), D("PRERELEASE", "(?:-(".concat(n[a.PRERELEASEIDENTIFIER], "(?:\\.").concat(n[a.PRERELEASEIDENTIFIER], ")*))")), D("PRERELEASELOOSE", "(?:-?(".concat(n[a.PRERELEASEIDENTIFIERLOOSE], "(?:\\.").concat(n[a.PRERELEASEIDENTIFIERLOOSE], ")*))")), D("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), D("BUILD", "(?:\\+(".concat(n[a.BUILDIDENTIFIER], "(?:\\.").concat(n[a.BUILDIDENTIFIER], ")*))")), D("FULLPLAIN", "v?".concat(n[a.MAINVERSION]).concat(n[a.PRERELEASE], "?").concat(n[a.BUILD], "?")), D("FULL", "^".concat(n[a.FULLPLAIN], "$")), D("LOOSEPLAIN", "[v=\\s]*".concat(n[a.MAINVERSIONLOOSE]).concat(n[a.PRERELEASELOOSE], "?").concat(n[a.BUILD], "?")), D("LOOSE", "^".concat(n[a.LOOSEPLAIN], "$")), D("GTLT", "((?:<|>)?=?)"), D("XRANGEIDENTIFIERLOOSE", "".concat(n[a.NUMERICIDENTIFIERLOOSE], "|x|X|\\*")), D("XRANGEIDENTIFIER", "".concat(n[a.NUMERICIDENTIFIER], "|x|X|\\*")), D("XRANGEPLAIN", "[v=\\s]*(".concat(n[a.XRANGEIDENTIFIER], ")(?:\\.(").concat(n[a.XRANGEIDENTIFIER], ")(?:\\.(").concat(n[a.XRANGEIDENTIFIER], ")(?:").concat(n[a.PRERELEASE], ")?").concat(n[a.BUILD], "?)?)?")), D("XRANGEPLAINLOOSE", "[v=\\s]*(".concat(n[a.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(n[a.XRANGEIDENTIFIERLOOSE], ")(?:\\.(").concat(n[a.XRANGEIDENTIFIERLOOSE], ")(?:").concat(n[a.PRERELEASELOOSE], ")?").concat(n[a.BUILD], "?)?)?")), D("XRANGE", "^".concat(n[a.GTLT], "\\s*").concat(n[a.XRANGEPLAIN], "$")), D("XRANGELOOSE", "^".concat(n[a.GTLT], "\\s*").concat(n[a.XRANGEPLAINLOOSE], "$")), D("COERCE", "(^|[^\\d])(\\d{1,".concat(t, "})(?:\\.(\\d{1,").concat(t, "}))?(?:\\.(\\d{1,").concat(t, "}))?(?:$|[^\\d])")), D("COERCERTL", n[a.COERCE], true), D("LONETILDE", "(?:~>?)"), D("TILDETRIM", "(\\s*)".concat(n[a.LONETILDE], "\\s+"), true), e.tildeTrimReplace = "$1~", D("TILDE", "^".concat(n[a.LONETILDE]).concat(n[a.XRANGEPLAIN], "$")), D("TILDELOOSE", "^".concat(n[a.LONETILDE]).concat(n[a.XRANGEPLAINLOOSE], "$")), D("LONECARET", "(?:\\^)"), D("CARETTRIM", "(\\s*)".concat(n[a.LONECARET], "\\s+"), true), e.caretTrimReplace = "$1^", D("CARET", "^".concat(n[a.LONECARET]).concat(n[a.XRANGEPLAIN], "$")), D("CARETLOOSE", "^".concat(n[a.LONECARET]).concat(n[a.XRANGEPLAINLOOSE], "$")), D("COMPARATORLOOSE", "^".concat(n[a.GTLT], "\\s*(").concat(n[a.LOOSEPLAIN], ")$|^$")), D("COMPARATOR", "^".concat(n[a.GTLT], "\\s*(").concat(n[a.FULLPLAIN], ")$|^$")), D("COMPARATORTRIM", "(\\s*)".concat(n[a.GTLT], "\\s*(").concat(n[a.LOOSEPLAIN], "|").concat(n[a.XRANGEPLAIN], ")"), true), e.comparatorTrimReplace = "$1$2$3", D("HYPHENRANGE", "^\\s*(".concat(n[a.XRANGEPLAIN], ")\\s+-\\s+(").concat(n[a.XRANGEPLAIN], ")\\s*$")), D("HYPHENRANGELOOSE", "^\\s*(".concat(n[a.XRANGEPLAINLOOSE], ")\\s+-\\s+(").concat(n[a.XRANGEPLAINLOOSE], ")\\s*$")), D("STAR", "(<|>)?=?\\s*\\*"), D("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), D("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
        } }), lD = I({ "node_modules/semver/internal/parse-options.js"(e, r) {
          q();
          var t = ["includePrerelease", "loose", "rtl"], s = (c) => c ? typeof c != "object" ? { loose: true } : t.filter((n) => c[n]).reduce((n, a) => (n[a] = true, n), {}) : {};
          r.exports = s;
        } }), hD = I({ "node_modules/semver/internal/identifiers.js"(e, r) {
          q();
          var t = /^[0-9]+$/, s = (n, a) => {
            let p2 = t.test(n), D = t.test(a);
            return p2 && D && (n = +n, a = +a), n === a ? 0 : p2 && !D ? -1 : D && !p2 ? 1 : n < a ? -1 : 1;
          }, c = (n, a) => s(a, n);
          r.exports = { compareIdentifiers: s, rcompareIdentifiers: c };
        } }), pD = I({ "node_modules/semver/classes/semver.js"(e, r) {
          q();
          var t = ds(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: c } = Es(), { re: n, t: a } = DD(), p2 = lD(), { compareIdentifiers: D } = hD(), g = class {
            constructor(i, l) {
              if (l = p2(l), i instanceof g) {
                if (i.loose === !!l.loose && i.includePrerelease === !!l.includePrerelease)
                  return i;
                i = i.version;
              } else if (typeof i != "string")
                throw new TypeError("Invalid Version: ".concat(i));
              if (i.length > s)
                throw new TypeError("version is longer than ".concat(s, " characters"));
              t("SemVer", i, l), this.options = l, this.loose = !!l.loose, this.includePrerelease = !!l.includePrerelease;
              let h3 = i.trim().match(l.loose ? n[a.LOOSE] : n[a.FULL]);
              if (!h3)
                throw new TypeError("Invalid Version: ".concat(i));
              if (this.raw = i, this.major = +h3[1], this.minor = +h3[2], this.patch = +h3[3], this.major > c || this.major < 0)
                throw new TypeError("Invalid major version");
              if (this.minor > c || this.minor < 0)
                throw new TypeError("Invalid minor version");
              if (this.patch > c || this.patch < 0)
                throw new TypeError("Invalid patch version");
              h3[4] ? this.prerelease = h3[4].split(".").map((C) => {
                if (/^[0-9]+$/.test(C)) {
                  let d = +C;
                  if (d >= 0 && d < c)
                    return d;
                }
                return C;
              }) : this.prerelease = [], this.build = h3[5] ? h3[5].split(".") : [], this.format();
            }
            format() {
              return this.version = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch), this.prerelease.length && (this.version += "-".concat(this.prerelease.join("."))), this.version;
            }
            toString() {
              return this.version;
            }
            compare(i) {
              if (t("SemVer.compare", this.version, this.options, i), !(i instanceof g)) {
                if (typeof i == "string" && i === this.version)
                  return 0;
                i = new g(i, this.options);
              }
              return i.version === this.version ? 0 : this.compareMain(i) || this.comparePre(i);
            }
            compareMain(i) {
              return i instanceof g || (i = new g(i, this.options)), D(this.major, i.major) || D(this.minor, i.minor) || D(this.patch, i.patch);
            }
            comparePre(i) {
              if (i instanceof g || (i = new g(i, this.options)), this.prerelease.length && !i.prerelease.length)
                return -1;
              if (!this.prerelease.length && i.prerelease.length)
                return 1;
              if (!this.prerelease.length && !i.prerelease.length)
                return 0;
              let l = 0;
              do {
                let h3 = this.prerelease[l], C = i.prerelease[l];
                if (t("prerelease compare", l, h3, C), h3 === void 0 && C === void 0)
                  return 0;
                if (C === void 0)
                  return 1;
                if (h3 === void 0)
                  return -1;
                if (h3 === C)
                  continue;
                return D(h3, C);
              } while (++l);
            }
            compareBuild(i) {
              i instanceof g || (i = new g(i, this.options));
              let l = 0;
              do {
                let h3 = this.build[l], C = i.build[l];
                if (t("prerelease compare", l, h3, C), h3 === void 0 && C === void 0)
                  return 0;
                if (C === void 0)
                  return 1;
                if (h3 === void 0)
                  return -1;
                if (h3 === C)
                  continue;
                return D(h3, C);
              } while (++l);
            }
            inc(i, l) {
              switch (i) {
                case "premajor":
                  this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", l);
                  break;
                case "preminor":
                  this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", l);
                  break;
                case "prepatch":
                  this.prerelease.length = 0, this.inc("patch", l), this.inc("pre", l);
                  break;
                case "prerelease":
                  this.prerelease.length === 0 && this.inc("patch", l), this.inc("pre", l);
                  break;
                case "major":
                  (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                  break;
                case "minor":
                  (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
                  break;
                case "patch":
                  this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                  break;
                case "pre":
                  if (this.prerelease.length === 0)
                    this.prerelease = [0];
                  else {
                    let h3 = this.prerelease.length;
                    for (; --h3 >= 0; )
                      typeof this.prerelease[h3] == "number" && (this.prerelease[h3]++, h3 = -2);
                    h3 === -1 && this.prerelease.push(0);
                  }
                  l && (D(this.prerelease[0], l) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [l, 0]) : this.prerelease = [l, 0]);
                  break;
                default:
                  throw new Error("invalid increment argument: ".concat(i));
              }
              return this.format(), this.raw = this.version, this;
            }
          };
          r.exports = g;
        } }), Ur = I({ "node_modules/semver/functions/compare.js"(e, r) {
          q();
          var t = pD(), s = (c, n, a) => new t(c, a).compare(new t(n, a));
          r.exports = s;
        } }), fD = I({ "node_modules/semver/functions/lt.js"(e, r) {
          q();
          var t = Ur(), s = (c, n, a) => t(c, n, a) < 0;
          r.exports = s;
        } }), dD = I({ "node_modules/semver/functions/gte.js"(e, r) {
          q();
          var t = Ur(), s = (c, n, a) => t(c, n, a) >= 0;
          r.exports = s;
        } }), ED = I({ "src/utils/arrayify.js"(e, r) {
          "use strict";
          q(), r.exports = (t, s) => Object.entries(t).map((c) => {
            let [n, a] = c;
            return Object.assign({ [s]: n }, a);
          });
        } }), CD = I({ "package.json"(e, r) {
          r.exports = { version: "2.7.1" };
        } }), mD = I({ "node_modules/outdent/lib/index.js"(e, r) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
          function t() {
            for (var A = [], N = 0; N < arguments.length; N++)
              A[N] = arguments[N];
          }
          function s() {
            return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : c();
          }
          function c() {
            return { add: t, delete: t, get: t, set: t, has: function(A) {
              return false;
            } };
          }
          var n = Object.prototype.hasOwnProperty, a = function(A, N) {
            return n.call(A, N);
          };
          function p2(A, N) {
            for (var R in N)
              a(N, R) && (A[R] = N[R]);
            return A;
          }
          var D = /^[ \t]*(?:\r\n|\r|\n)/, g = /(?:\r\n|\r|\n)[ \t]*$/, i = /^(?:[\r\n]|$)/, l = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, h3 = /^[ \t]*[\r\n][ \t\r\n]*$/;
          function C(A, N, R) {
            var $2 = 0, _ = A[0].match(l);
            _ && ($2 = _[1].length);
            var O = "(\\r\\n|\\r|\\n).{0," + $2 + "}", x = new RegExp(O, "g");
            N && (A = A.slice(1));
            var k = R.newline, M = R.trimLeadingNewline, u = R.trimTrailingNewline, o = typeof k == "string", E = A.length, f = A.map(function(F, P) {
              return F = F.replace(x, "$1"), P === 0 && M && (F = F.replace(D, "")), P === E - 1 && u && (F = F.replace(g, "")), o && (F = F.replace(/\r\n|\n|\r/g, function(j) {
                return k;
              })), F;
            });
            return f;
          }
          function d(A, N) {
            for (var R = "", $2 = 0, _ = A.length; $2 < _; $2++)
              R += A[$2], $2 < _ - 1 && (R += N[$2]);
            return R;
          }
          function m2(A) {
            return a(A, "raw") && a(A, "length");
          }
          function T(A) {
            var N = s(), R = s();
            function $2(O) {
              for (var x = [], k = 1; k < arguments.length; k++)
                x[k - 1] = arguments[k];
              if (m2(O)) {
                var M = O, u = (x[0] === $2 || x[0] === B) && h3.test(M[0]) && i.test(M[1]), o = u ? R : N, E = o.get(M);
                if (E || (E = C(M, u, A), o.set(M, E)), x.length === 0)
                  return E[0];
                var f = d(E, u ? x.slice(1) : x);
                return f;
              } else
                return T(p2(p2({}, A), O || {}));
            }
            var _ = p2($2, { string: function(O) {
              return C([O], false, A)[0];
            } });
            return _;
          }
          var B = T({ trimLeadingNewline: true, trimTrailingNewline: true });
          if (e.outdent = B, e.default = B, typeof r < "u")
            try {
              r.exports = B, Object.defineProperty(B, "__esModule", { value: true }), B.default = B, B.outdent = B;
            } catch {
            }
        } }), gD = I({ "src/main/core-options.js"(e, r) {
          "use strict";
          q();
          var { outdent: t } = mD(), s = "Config", c = "Editor", n = "Format", a = "Other", p2 = "Output", D = "Global", g = "Special", i = { cursorOffset: { since: "1.4.0", category: g, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(Jn || (Jn = Ee([`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `]))), cliCategory: c }, endOfLine: { since: "1.15.0", category: D, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t(Zn || (Zn = Ee([`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `]))) }] }, filepath: { since: "1.4.0", category: g, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: a, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: g, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: a }, parser: { since: "0.0.10", category: D, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (l) => typeof l == "string" || typeof l == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: D, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: D, description: t(es || (es = Ee([`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `]))), exception: (l) => typeof l == "string" || typeof l == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: D, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: g, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(rs || (rs = Ee([`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: c }, rangeStart: { since: "1.4.0", category: g, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t(ts || (ts = Ee([`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `]))), cliCategory: c }, requirePragma: { since: "1.7.0", category: g, type: "boolean", default: false, description: t(us || (us = Ee([`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `]))), cliCategory: a }, tabWidth: { type: "int", category: D, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: D, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: D, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
          r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: c, CATEGORY_FORMAT: n, CATEGORY_OTHER: a, CATEGORY_OUTPUT: p2, CATEGORY_GLOBAL: D, CATEGORY_SPECIAL: g, options: i };
        } }), FD = I({ "src/main/support.js"(e, r) {
          "use strict";
          q();
          var t = { compare: Ur(), lt: fD(), gte: dD() }, s = ED(), c = CD().version, n = gD().options;
          function a() {
            let { plugins: D = [], showUnreleased: g = false, showDeprecated: i = false, showInternal: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, h3 = c.split("-", 1)[0], C = D.flatMap((A) => A.languages || []).filter(m2), d = s(Object.assign({}, ...D.map((A) => {
              let { options: N } = A;
              return N;
            }), n), "name").filter((A) => m2(A) && T(A)).sort((A, N) => A.name === N.name ? 0 : A.name < N.name ? -1 : 1).map(B).map((A) => {
              A = Object.assign({}, A), Array.isArray(A.default) && (A.default = A.default.length === 1 ? A.default[0].value : A.default.filter(m2).sort((R, $2) => t.compare($2.since, R.since))[0].value), Array.isArray(A.choices) && (A.choices = A.choices.filter((R) => m2(R) && T(R)), A.name === "parser" && p2(A, C, D));
              let N = Object.fromEntries(D.filter((R) => R.defaultOptions && R.defaultOptions[A.name] !== void 0).map((R) => [R.name, R.defaultOptions[A.name]]));
              return Object.assign(Object.assign({}, A), {}, { pluginDefaults: N });
            });
            return { languages: C, options: d };
            function m2(A) {
              return g || !("since" in A) || A.since && t.gte(h3, A.since);
            }
            function T(A) {
              return i || !("deprecated" in A) || A.deprecated && t.lt(h3, A.deprecated);
            }
            function B(A) {
              if (l)
                return A;
              let { cliName: N, cliCategory: R, cliDescription: $2 } = A;
              return Qc(A, Yc);
            }
          }
          function p2(D, g, i) {
            let l = new Set(D.choices.map((h3) => h3.value));
            for (let h3 of g)
              if (h3.parsers) {
                for (let C of h3.parsers)
                  if (!l.has(C)) {
                    l.add(C);
                    let d = i.find((T) => T.parsers && T.parsers[C]), m2 = h3.name;
                    d && d.name && (m2 += " (plugin: ".concat(d.name, ")")), D.choices.push({ value: C, description: m2 });
                  }
              }
          }
          r.exports = { getSupportInfo: a };
        } }), AD = I({ "src/utils/is-non-empty-array.js"(e, r) {
          "use strict";
          q();
          function t(s) {
            return Array.isArray(s) && s.length > 0;
          }
          r.exports = t;
        } });
        function vD() {
          let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
          return new RegExp(r, e ? void 0 : "g");
        }
        var _D = Ce({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
          q();
        } });
        function SD(e) {
          if (typeof e != "string")
            throw new TypeError("Expected a `string`, got `".concat(typeof e, "`"));
          return e.replace(vD(), "");
        }
        var yD = Ce({ "node_modules/strip-ansi/index.js"() {
          q(), _D();
        } });
        function TD(e) {
          return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
        }
        var BD = Ce({ "node_modules/is-fullwidth-code-point/index.js"() {
          q();
        } }), bD = I({ "node_modules/emoji-regex/index.js"(e, r) {
          "use strict";
          q(), r.exports = function() {
            return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
          };
        } }), Cs = {};
        cs(Cs, { default: () => wD });
        function wD(e) {
          if (typeof e != "string" || e.length === 0 || (e = SD(e), e.length === 0))
            return 0;
          e = e.replace((0, ms.default)(), "  ");
          let r = 0;
          for (let t = 0; t < e.length; t++) {
            let s = e.codePointAt(t);
            s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += TD(s) ? 2 : 1);
          }
          return r;
        }
        var ms, ND = Ce({ "node_modules/string-width/index.js"() {
          q(), yD(), BD(), ms = tD(bD());
        } }), OD = I({ "src/utils/get-string-width.js"(e, r) {
          "use strict";
          q();
          var t = (ND(), ls(Cs)).default, s = /[^\x20-\x7F]/;
          function c(n) {
            return n ? s.test(n) ? t(n) : n.length : 0;
          }
          r.exports = c;
        } }), Gr = I({ "src/utils/text/skip.js"(e, r) {
          "use strict";
          q();
          function t(p2) {
            return (D, g, i) => {
              let l = i && i.backwards;
              if (g === false)
                return false;
              let { length: h3 } = D, C = g;
              for (; C >= 0 && C < h3; ) {
                let d = D.charAt(C);
                if (p2 instanceof RegExp) {
                  if (!p2.test(d))
                    return C;
                } else if (!p2.includes(d))
                  return C;
                l ? C-- : C++;
              }
              return C === -1 || C === h3 ? C : false;
            };
          }
          var s = t(/\s/), c = t(" 	"), n = t(",; 	"), a = t(/[^\n\r]/);
          r.exports = { skipWhitespace: s, skipSpaces: c, skipToLineEnd: n, skipEverythingButNewLine: a };
        } }), gs = I({ "src/utils/text/skip-inline-comment.js"(e, r) {
          "use strict";
          q();
          function t(s, c) {
            if (c === false)
              return false;
            if (s.charAt(c) === "/" && s.charAt(c + 1) === "*") {
              for (let n = c + 2; n < s.length; ++n)
                if (s.charAt(n) === "*" && s.charAt(n + 1) === "/")
                  return n + 2;
            }
            return c;
          }
          r.exports = t;
        } }), Fs = I({ "src/utils/text/skip-trailing-comment.js"(e, r) {
          "use strict";
          q();
          var { skipEverythingButNewLine: t } = Gr();
          function s(c, n) {
            return n === false ? false : c.charAt(n) === "/" && c.charAt(n + 1) === "/" ? t(c, n) : n;
          }
          r.exports = s;
        } }), As = I({ "src/utils/text/skip-newline.js"(e, r) {
          "use strict";
          q();
          function t(s, c, n) {
            let a = n && n.backwards;
            if (c === false)
              return false;
            let p2 = s.charAt(c);
            if (a) {
              if (s.charAt(c - 1) === "\r" && p2 === `
`)
                return c - 2;
              if (p2 === `
` || p2 === "\r" || p2 === "\u2028" || p2 === "\u2029")
                return c - 1;
            } else {
              if (p2 === "\r" && s.charAt(c + 1) === `
`)
                return c + 2;
              if (p2 === `
` || p2 === "\r" || p2 === "\u2028" || p2 === "\u2029")
                return c + 1;
            }
            return c;
          }
          r.exports = t;
        } }), qD = I({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
          "use strict";
          q();
          var t = gs(), s = As(), c = Fs(), { skipSpaces: n } = Gr();
          function a(p2, D) {
            let g = null, i = D;
            for (; i !== g; )
              g = i, i = n(p2, i), i = t(p2, i), i = c(p2, i), i = s(p2, i);
            return i;
          }
          r.exports = a;
        } }), ID = I({ "src/common/util.js"(e, r) {
          "use strict";
          q();
          var { default: t } = (cD(), ls(fs)), s = ps(), { getSupportInfo: c } = FD(), n = AD(), a = OD(), { skipWhitespace: p2, skipSpaces: D, skipToLineEnd: g, skipEverythingButNewLine: i } = Gr(), l = gs(), h3 = Fs(), C = As(), d = qD(), m2 = (v) => v[v.length - 2];
          function T(v) {
            return (S, b, w) => {
              let L = w && w.backwards;
              if (b === false)
                return false;
              let { length: U } = S, V = b;
              for (; V >= 0 && V < U; ) {
                let Y = S.charAt(V);
                if (v instanceof RegExp) {
                  if (!v.test(Y))
                    return V;
                } else if (!v.includes(Y))
                  return V;
                L ? V-- : V++;
              }
              return V === -1 || V === U ? V : false;
            };
          }
          function B(v, S) {
            let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, w = D(v, b.backwards ? S - 1 : S, b), L = C(v, w, b);
            return w !== L;
          }
          function A(v, S, b) {
            for (let w = S; w < b; ++w)
              if (v.charAt(w) === `
`)
                return true;
            return false;
          }
          function N(v, S, b) {
            let w = b(S) - 1;
            w = D(v, w, { backwards: true }), w = C(v, w, { backwards: true }), w = D(v, w, { backwards: true });
            let L = C(v, w, { backwards: true });
            return w !== L;
          }
          function R(v, S) {
            let b = null, w = S;
            for (; w !== b; )
              b = w, w = g(v, w), w = l(v, w), w = D(v, w);
            return w = h3(v, w), w = C(v, w), w !== false && B(v, w);
          }
          function $2(v, S, b) {
            return R(v, b(S));
          }
          function _(v, S, b) {
            return d(v, b(S));
          }
          function O(v, S, b) {
            return v.charAt(_(v, S, b));
          }
          function x(v, S) {
            let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return D(v, b.backwards ? S - 1 : S, b) !== S;
          }
          function k(v, S) {
            let b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, w = 0;
            for (let L = b; L < v.length; ++L)
              v[L] === "	" ? w = w + S - w % S : w++;
            return w;
          }
          function M(v, S) {
            let b = v.lastIndexOf(`
`);
            return b === -1 ? 0 : k(v.slice(b + 1).match(/^[\t ]*/)[0], S);
          }
          function u(v, S) {
            let b = { quote: '"', regex: /"/g, escaped: "&quot;" }, w = { quote: "'", regex: /'/g, escaped: "&apos;" }, L = S === "'" ? w : b, U = L === w ? b : w, V = L;
            if (v.includes(L.quote) || v.includes(U.quote)) {
              let Y = (v.match(L.regex) || []).length, ue = (v.match(U.regex) || []).length;
              V = Y > ue ? U : L;
            }
            return V;
          }
          function o(v, S) {
            let b = v.slice(1, -1), w = S.parser === "json" || S.parser === "json5" && S.quoteProps === "preserve" && !S.singleQuote ? '"' : S.__isInHtmlAttribute ? "'" : u(b, S.singleQuote ? "'" : '"').quote;
            return E(b, w, !(S.parser === "css" || S.parser === "less" || S.parser === "scss" || S.__embeddedInHtml));
          }
          function E(v, S, b) {
            let w = S === '"' ? "'" : '"', L = /\\(.)|(["'])/gs, U = v.replace(L, (V, Y, ue) => Y === w ? Y : ue === S ? "\\" + ue : ue || (b && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(Y) ? Y : "\\" + Y));
            return S + U + S;
          }
          function f(v) {
            return v.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
          }
          function F(v, S) {
            let b = v.match(new RegExp("(".concat(t(S), ")+"), "g"));
            return b === null ? 0 : b.reduce((w, L) => Math.max(w, L.length / S.length), 0);
          }
          function P(v, S) {
            let b = v.match(new RegExp("(".concat(t(S), ")+"), "g"));
            if (b === null)
              return 0;
            let w = /* @__PURE__ */ new Map(), L = 0;
            for (let U of b) {
              let V = U.length / S.length;
              w.set(V, true), V > L && (L = V);
            }
            for (let U = 1; U < L; U++)
              if (!w.get(U))
                return U;
            return L + 1;
          }
          function j(v, S) {
            (v.comments || (v.comments = [])).push(S), S.printed = false, S.nodeDescription = ee(v);
          }
          function W(v, S) {
            S.leading = true, S.trailing = false, j(v, S);
          }
          function X(v, S, b) {
            S.leading = false, S.trailing = false, b && (S.marker = b), j(v, S);
          }
          function H(v, S) {
            S.leading = false, S.trailing = true, j(v, S);
          }
          function z(v, S) {
            let { languages: b } = c({ plugins: S.plugins }), w = b.find((L) => {
              let { name: U } = L;
              return U.toLowerCase() === v;
            }) || b.find((L) => {
              let { aliases: U } = L;
              return Array.isArray(U) && U.includes(v);
            }) || b.find((L) => {
              let { extensions: U } = L;
              return Array.isArray(U) && U.includes(".".concat(v));
            });
            return w && w.parsers[0];
          }
          function J(v) {
            return v && v.type === "front-matter";
          }
          function Z(v) {
            let S = /* @__PURE__ */ new WeakMap();
            return function(b) {
              return S.has(b) || S.set(b, Symbol(v)), S.get(b);
            };
          }
          function ee(v) {
            let S = v.type || v.kind || "(unknown type)", b = String(v.name || v.id && (typeof v.id == "object" ? v.id.name : v.id) || v.key && (typeof v.key == "object" ? v.key.name : v.key) || v.value && (typeof v.value == "object" ? "" : String(v.value)) || v.operator || "");
            return b.length > 20 && (b = b.slice(0, 19) + "\u2026"), S + (b ? " " + b : "");
          }
          r.exports = { inferParserByLanguage: z, getStringWidth: a, getMaxContinuousCount: F, getMinNotPresentContinuousCount: P, getPenultimate: m2, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: d, getNextNonSpaceNonCommentCharacterIndex: _, getNextNonSpaceNonCommentCharacter: O, skip: T, skipWhitespace: p2, skipSpaces: D, skipToLineEnd: g, skipEverythingButNewLine: i, skipInlineComment: l, skipTrailingComment: h3, skipNewline: C, isNextLineEmptyAfterIndex: R, isNextLineEmpty: $2, isPreviousLineEmpty: N, hasNewline: B, hasNewlineInRange: A, hasSpaces: x, getAlignmentSize: k, getIndentSize: M, getPreferredQuote: u, printString: o, printNumber: f, makeString: E, addLeadingComment: W, addDanglingComment: X, addTrailingComment: H, isFrontMatterNode: J, isNonEmptyArray: n, createGroupIdMapper: Z };
        } }), RD = I({ "vendors/html-tag-names.json"(e, r) {
          r.exports = { htmlTagNames: ["a", "abbr", "acronym", "address", "applet", "area", "article", "aside", "audio", "b", "base", "basefont", "bdi", "bdo", "bgsound", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "command", "content", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "embed", "fieldset", "figcaption", "figure", "font", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "image", "img", "input", "ins", "isindex", "kbd", "keygen", "label", "legend", "li", "link", "listing", "main", "map", "mark", "marquee", "math", "menu", "menuitem", "meta", "meter", "multicol", "nav", "nextid", "nobr", "noembed", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "plaintext", "pre", "progress", "q", "rb", "rbc", "rp", "rt", "rtc", "ruby", "s", "samp", "script", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "svg", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "tt", "u", "ul", "var", "video", "wbr", "xmp"] };
        } }), vs = I({ "src/language-html/utils/array-to-map.js"(e, r) {
          "use strict";
          q();
          function t(s) {
            let c = /* @__PURE__ */ Object.create(null);
            for (let n of s)
              c[n] = true;
            return c;
          }
          r.exports = t;
        } }), xD = I({ "src/language-html/utils/html-tag-names.js"(e, r) {
          "use strict";
          q();
          var { htmlTagNames: t } = RD(), s = vs(), c = s(t);
          r.exports = c;
        } }), PD = I({ "vendors/html-element-attributes.json"(e, r) {
          r.exports = { htmlElementAttributes: { "*": ["accesskey", "autocapitalize", "autofocus", "class", "contenteditable", "dir", "draggable", "enterkeyhint", "hidden", "id", "inputmode", "is", "itemid", "itemprop", "itemref", "itemscope", "itemtype", "lang", "nonce", "slot", "spellcheck", "style", "tabindex", "title", "translate"], a: ["charset", "coords", "download", "href", "hreflang", "name", "ping", "referrerpolicy", "rel", "rev", "shape", "target", "type"], applet: ["align", "alt", "archive", "code", "codebase", "height", "hspace", "name", "object", "vspace", "width"], area: ["alt", "coords", "download", "href", "hreflang", "nohref", "ping", "referrerpolicy", "rel", "shape", "target", "type"], audio: ["autoplay", "controls", "crossorigin", "loop", "muted", "preload", "src"], base: ["href", "target"], basefont: ["color", "face", "size"], blockquote: ["cite"], body: ["alink", "background", "bgcolor", "link", "text", "vlink"], br: ["clear"], button: ["disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "name", "type", "value"], canvas: ["height", "width"], caption: ["align"], col: ["align", "char", "charoff", "span", "valign", "width"], colgroup: ["align", "char", "charoff", "span", "valign", "width"], data: ["value"], del: ["cite", "datetime"], details: ["open"], dialog: ["open"], dir: ["compact"], div: ["align"], dl: ["compact"], embed: ["height", "src", "type", "width"], fieldset: ["disabled", "form", "name"], font: ["color", "face", "size"], form: ["accept", "accept-charset", "action", "autocomplete", "enctype", "method", "name", "novalidate", "target"], frame: ["frameborder", "longdesc", "marginheight", "marginwidth", "name", "noresize", "scrolling", "src"], frameset: ["cols", "rows"], h1: ["align"], h2: ["align"], h3: ["align"], h4: ["align"], h5: ["align"], h6: ["align"], head: ["profile"], hr: ["align", "noshade", "size", "width"], html: ["manifest", "version"], iframe: ["align", "allow", "allowfullscreen", "allowpaymentrequest", "allowusermedia", "frameborder", "height", "loading", "longdesc", "marginheight", "marginwidth", "name", "referrerpolicy", "sandbox", "scrolling", "src", "srcdoc", "width"], img: ["align", "alt", "border", "crossorigin", "decoding", "height", "hspace", "ismap", "loading", "longdesc", "name", "referrerpolicy", "sizes", "src", "srcset", "usemap", "vspace", "width"], input: ["accept", "align", "alt", "autocomplete", "checked", "dirname", "disabled", "form", "formaction", "formenctype", "formmethod", "formnovalidate", "formtarget", "height", "ismap", "list", "max", "maxlength", "min", "minlength", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "src", "step", "type", "usemap", "value", "width"], ins: ["cite", "datetime"], isindex: ["prompt"], label: ["for", "form"], legend: ["align"], li: ["type", "value"], link: ["as", "charset", "color", "crossorigin", "disabled", "href", "hreflang", "imagesizes", "imagesrcset", "integrity", "media", "referrerpolicy", "rel", "rev", "sizes", "target", "type"], map: ["name"], menu: ["compact"], meta: ["charset", "content", "http-equiv", "media", "name", "scheme"], meter: ["high", "low", "max", "min", "optimum", "value"], object: ["align", "archive", "border", "classid", "codebase", "codetype", "data", "declare", "form", "height", "hspace", "name", "standby", "type", "typemustmatch", "usemap", "vspace", "width"], ol: ["compact", "reversed", "start", "type"], optgroup: ["disabled", "label"], option: ["disabled", "label", "selected", "value"], output: ["for", "form", "name"], p: ["align"], param: ["name", "type", "value", "valuetype"], pre: ["width"], progress: ["max", "value"], q: ["cite"], script: ["async", "charset", "crossorigin", "defer", "integrity", "language", "nomodule", "referrerpolicy", "src", "type"], select: ["autocomplete", "disabled", "form", "multiple", "name", "required", "size"], slot: ["name"], source: ["height", "media", "sizes", "src", "srcset", "type", "width"], style: ["media", "type"], table: ["align", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "rules", "summary", "width"], tbody: ["align", "char", "charoff", "valign"], td: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], textarea: ["autocomplete", "cols", "dirname", "disabled", "form", "maxlength", "minlength", "name", "placeholder", "readonly", "required", "rows", "wrap"], tfoot: ["align", "char", "charoff", "valign"], th: ["abbr", "align", "axis", "bgcolor", "char", "charoff", "colspan", "headers", "height", "nowrap", "rowspan", "scope", "valign", "width"], thead: ["align", "char", "charoff", "valign"], time: ["datetime"], tr: ["align", "bgcolor", "char", "charoff", "valign"], track: ["default", "kind", "label", "src", "srclang"], ul: ["compact", "type"], video: ["autoplay", "controls", "crossorigin", "height", "loop", "muted", "playsinline", "poster", "preload", "src", "width"] } };
        } }), kD = I({ "src/language-html/utils/map-object.js"(e, r) {
          "use strict";
          q();
          function t(s, c) {
            let n = /* @__PURE__ */ Object.create(null);
            for (let [a, p2] of Object.entries(s))
              n[a] = c(p2, a);
            return n;
          }
          r.exports = t;
        } }), LD = I({ "src/language-html/utils/html-elements-attributes.js"(e, r) {
          "use strict";
          q();
          var { htmlElementAttributes: t } = PD(), s = kD(), c = vs(), n = s(t, c);
          r.exports = n;
        } }), MD = I({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
          "use strict";
          q();
          function t(s) {
            return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
          }
          r.exports = t;
        } }), jD = I({ "src/language-html/pragma.js"(e, r) {
          "use strict";
          q();
          function t(c) {
            return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(c);
          }
          function s(c) {
            return `<!-- @format -->

` + c.replace(/^\s*\n/, "");
          }
          r.exports = { hasPragma: t, insertPragma: s };
        } }), $D = I({ "src/language-html/ast.js"(e, r) {
          "use strict";
          q();
          var t = { attrs: true, children: true }, s = /* @__PURE__ */ new Set(["parent"]), c = class {
            constructor() {
              let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              for (let p2 of /* @__PURE__ */ new Set([...s, ...Object.keys(a)]))
                this.setProperty(p2, a[p2]);
            }
            setProperty(a, p2) {
              if (this[a] !== p2) {
                if (a in t && (p2 = p2.map((D) => this.createChild(D))), !s.has(a)) {
                  this[a] = p2;
                  return;
                }
                Object.defineProperty(this, a, { value: p2, enumerable: false, configurable: true });
              }
            }
            map(a) {
              let p2;
              for (let D in t) {
                let g = this[D];
                if (g) {
                  let i = n(g, (l) => l.map(a));
                  p2 !== g && (p2 || (p2 = new c({ parent: this.parent })), p2.setProperty(D, i));
                }
              }
              if (p2)
                for (let D in this)
                  D in t || (p2[D] = this[D]);
              return a(p2 || this);
            }
            walk(a) {
              for (let p2 in t) {
                let D = this[p2];
                if (D)
                  for (let g = 0; g < D.length; g++)
                    D[g].walk(a);
              }
              a(this);
            }
            createChild(a) {
              let p2 = a instanceof c ? a.clone() : new c(a);
              return p2.setProperty("parent", this), p2;
            }
            insertChildBefore(a, p2) {
              this.children.splice(this.children.indexOf(a), 0, this.createChild(p2));
            }
            removeChild(a) {
              this.children.splice(this.children.indexOf(a), 1);
            }
            replaceChild(a, p2) {
              this.children[this.children.indexOf(a)] = this.createChild(p2);
            }
            clone() {
              return new c(this);
            }
            get firstChild() {
              var a;
              return (a = this.children) === null || a === void 0 ? void 0 : a[0];
            }
            get lastChild() {
              var a;
              return (a = this.children) === null || a === void 0 ? void 0 : a[this.children.length - 1];
            }
            get prev() {
              var a;
              return (a = this.parent) === null || a === void 0 ? void 0 : a.children[this.parent.children.indexOf(this) - 1];
            }
            get next() {
              var a;
              return (a = this.parent) === null || a === void 0 ? void 0 : a.children[this.parent.children.indexOf(this) + 1];
            }
            get rawName() {
              return this.hasExplicitNamespace ? this.fullName : this.name;
            }
            get fullName() {
              return this.namespace ? this.namespace + ":" + this.name : this.name;
            }
            get attrMap() {
              return Object.fromEntries(this.attrs.map((a) => [a.fullName, a.value]));
            }
          };
          function n(a, p2) {
            let D = a.map(p2);
            return D.some((g, i) => g !== a[i]) ? D : a;
          }
          r.exports = { Node: c };
        } }), UD = I({ "src/language-html/conditional-comment.js"(e, r) {
          "use strict";
          q();
          var { ParseSourceSpan: t } = Te(), s = [{ regex: /^(\[if([^\]]*)]>)(.*?)<!\s*\[endif]$/s, parse: n }, { regex: /^\[if([^\]]*)]><!$/, parse: a }, { regex: /^<!\s*\[endif]$/, parse: p2 }];
          function c(D, g) {
            if (D.value)
              for (let { regex: i, parse: l } of s) {
                let h3 = D.value.match(i);
                if (h3)
                  return l(D, g, h3);
              }
            return null;
          }
          function n(D, g, i) {
            let [, l, h3, C] = i, d = 4 + l.length, m2 = D.sourceSpan.start.moveBy(d), T = m2.moveBy(C.length), [B, A] = (() => {
              try {
                return [true, g(C, m2).children];
              } catch {
                let N = { type: "text", value: C, sourceSpan: new t(m2, T) };
                return [false, [N]];
              }
            })();
            return { type: "ieConditionalComment", complete: B, children: A, condition: h3.trim().replace(/\s+/g, " "), sourceSpan: D.sourceSpan, startSourceSpan: new t(D.sourceSpan.start, m2), endSourceSpan: new t(T, D.sourceSpan.end) };
          }
          function a(D, g, i) {
            let [, l] = i;
            return { type: "ieConditionalStartComment", condition: l.trim().replace(/\s+/g, " "), sourceSpan: D.sourceSpan };
          }
          function p2(D) {
            return { type: "ieConditionalEndComment", sourceSpan: D.sourceSpan };
          }
          r.exports = { parseIeConditionalComment: c };
        } }), GD = I({ "src/language-html/loc.js"(e, r) {
          "use strict";
          q();
          function t(c) {
            return c.sourceSpan.start.offset;
          }
          function s(c) {
            return c.sourceSpan.end.offset;
          }
          r.exports = { locStart: t, locEnd: s };
        } }), Ze = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/tags.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r;
          (function(D) {
            D[D.RAW_TEXT = 0] = "RAW_TEXT", D[D.ESCAPABLE_RAW_TEXT = 1] = "ESCAPABLE_RAW_TEXT", D[D.PARSABLE_DATA = 2] = "PARSABLE_DATA";
          })(r = e.TagContentType || (e.TagContentType = {}));
          function t(D) {
            if (D[0] != ":")
              return [null, D];
            let g = D.indexOf(":", 1);
            if (g == -1)
              throw new Error('Unsupported format "'.concat(D, '" expecting ":namespace:name"'));
            return [D.slice(1, g), D.slice(g + 1)];
          }
          e.splitNsName = t;
          function s(D) {
            return t(D)[1] === "ng-container";
          }
          e.isNgContainer = s;
          function c(D) {
            return t(D)[1] === "ng-content";
          }
          e.isNgContent = c;
          function n(D) {
            return t(D)[1] === "ng-template";
          }
          e.isNgTemplate = n;
          function a(D) {
            return D === null ? null : t(D)[0];
          }
          e.getNsPrefix = a;
          function p2(D, g) {
            return D ? ":".concat(D, ":").concat(g) : g;
          }
          e.mergeNsAndName = p2, e.NAMED_ENTITIES = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", AMP: "&", amp: "&", And: "\u2A53", and: "\u2227", andand: "\u2A55", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsd: "\u2221", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", ap: "\u2248", apacir: "\u2A6F", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", Barwed: "\u2306", barwed: "\u2305", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", Because: "\u2235", because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxDL: "\u2557", boxDl: "\u2556", boxdL: "\u2555", boxdl: "\u2510", boxDR: "\u2554", boxDr: "\u2553", boxdR: "\u2552", boxdr: "\u250C", boxH: "\u2550", boxh: "\u2500", boxHD: "\u2566", boxHd: "\u2564", boxhD: "\u2565", boxhd: "\u252C", boxHU: "\u2569", boxHu: "\u2567", boxhU: "\u2568", boxhu: "\u2534", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxUL: "\u255D", boxUl: "\u255C", boxuL: "\u255B", boxul: "\u2518", boxUR: "\u255A", boxUr: "\u2559", boxuR: "\u2558", boxur: "\u2514", boxV: "\u2551", boxv: "\u2502", boxVH: "\u256C", boxVh: "\u256B", boxvH: "\u256A", boxvh: "\u253C", boxVL: "\u2563", boxVl: "\u2562", boxvL: "\u2561", boxvl: "\u2524", boxVR: "\u2560", boxVr: "\u255F", boxvR: "\u255E", boxvr: "\u251C", bprime: "\u2035", Breve: "\u02D8", breve: "\u02D8", brvbar: "\xA6", Bscr: "\u212C", bscr: "\u{1D4B7}", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsol: "\\", bsolb: "\u29C5", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", Cap: "\u22D2", cap: "\u2229", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", CenterDot: "\xB7", centerdot: "\xB7", Cfr: "\u212D", cfr: "\u{1D520}", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", cir: "\u25CB", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", Colon: "\u2237", colon: ":", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", Conint: "\u222F", conint: "\u222E", ContourIntegral: "\u222E", Copf: "\u2102", copf: "\u{1D554}", coprod: "\u2210", Coproduct: "\u2210", COPY: "\xA9", copy: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", Cross: "\u2A2F", cross: "\u2717", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", Cup: "\u22D3", cup: "\u222A", cupbrcap: "\u2A48", CupCap: "\u224D", cupcap: "\u2A46", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", Dagger: "\u2021", dagger: "\u2020", daleth: "\u2138", Darr: "\u21A1", dArr: "\u21D3", darr: "\u2193", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", DD: "\u2145", dd: "\u2146", ddagger: "\u2021", ddarr: "\u21CA", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", Diamond: "\u22C4", diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrow: "\u2193", Downarrow: "\u21D3", downarrow: "\u2193", DownArrowBar: "\u2913", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVector: "\u21BD", DownLeftVectorBar: "\u2956", DownRightTeeVector: "\u295F", DownRightVector: "\u21C1", DownRightVectorBar: "\u2957", DownTee: "\u22A4", DownTeeArrow: "\u21A7", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", ecir: "\u2256", Ecirc: "\xCA", ecirc: "\xEA", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", eDot: "\u2251", edot: "\u0117", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp: "\u2003", emsp13: "\u2004", emsp14: "\u2005", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", Escr: "\u2130", escr: "\u212F", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", ExponentialE: "\u2147", exponentiale: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", ForAll: "\u2200", forall: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", Fscr: "\u2131", fscr: "\u{1D4BB}", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", gE: "\u2267", ge: "\u2265", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", ges: "\u2A7E", gescc: "\u2AA9", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", Gg: "\u22D9", gg: "\u226B", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gl: "\u2277", gla: "\u2AA5", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gnE: "\u2269", gne: "\u2A88", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", GT: ">", Gt: "\u226B", gt: ">", gtcc: "\u2AA7", gtcir: "\u2A7A", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", hArr: "\u21D4", harr: "\u2194", harrcir: "\u2948", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", Hfr: "\u210C", hfr: "\u{1D525}", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", Hopf: "\u210D", hopf: "\u{1D559}", horbar: "\u2015", HorizontalLine: "\u2500", Hscr: "\u210B", hscr: "\u{1D4BD}", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", Ifr: "\u2111", ifr: "\u{1D526}", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Im: "\u2111", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", in: "\u2208", incare: "\u2105", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", Int: "\u222C", int: "\u222B", intcal: "\u22BA", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", Iscr: "\u2110", iscr: "\u{1D4BE}", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", Lang: "\u27EA", lang: "\u27E8", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", Larr: "\u219E", lArr: "\u21D0", larr: "\u2190", larrb: "\u21E4", larrbfs: "\u291F", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", lat: "\u2AAB", lAtail: "\u291B", latail: "\u2919", late: "\u2AAD", lates: "\u2AAD\uFE00", lBarr: "\u290E", lbarr: "\u290C", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", lE: "\u2266", le: "\u2264", LeftAngleBracket: "\u27E8", LeftArrow: "\u2190", Leftarrow: "\u21D0", leftarrow: "\u2190", LeftArrowBar: "\u21E4", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVector: "\u21C3", LeftDownVectorBar: "\u2959", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrow: "\u2194", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTee: "\u22A3", LeftTeeArrow: "\u21A4", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangle: "\u22B2", LeftTriangleBar: "\u29CF", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVector: "\u21BF", LeftUpVectorBar: "\u2958", LeftVector: "\u21BC", LeftVectorBar: "\u2952", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", les: "\u2A7D", lescc: "\u2AA8", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", Ll: "\u22D8", ll: "\u226A", llarr: "\u21C7", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoust: "\u23B0", lmoustache: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lnE: "\u2268", lne: "\u2A87", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftarrow: "\u27F5", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longleftrightarrow: "\u27F7", longmapsto: "\u27FC", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", longrightarrow: "\u27F6", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", Lscr: "\u2112", lscr: "\u{1D4C1}", Lsh: "\u21B0", lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", LT: "<", Lt: "\u226A", lt: "<", ltcc: "\u2AA6", ltcir: "\u2A79", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", mid: "\u2223", midast: "*", midcir: "\u2AF0", middot: "\xB7", minus: "\u2212", minusb: "\u229F", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", Mscr: "\u2133", mscr: "\u{1D4C2}", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natur: "\u266E", natural: "\u266E", naturals: "\u2115", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", ne: "\u2260", nearhk: "\u2924", neArr: "\u21D7", nearr: "\u2197", nearrow: "\u2197", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: `
`, nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nhArr: "\u21CE", nharr: "\u21AE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlArr: "\u21CD", nlarr: "\u219A", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nLeftarrow: "\u21CD", nleftarrow: "\u219A", nLeftrightarrow: "\u21CE", nleftrightarrow: "\u21AE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", Nopf: "\u2115", nopf: "\u{1D55F}", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangle: "\u22EA", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangle: "\u22EB", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", npar: "\u2226", nparallel: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", npre: "\u2AAF\u0338", nprec: "\u2280", npreceq: "\u2AAF\u0338", nrArr: "\u21CF", nrarr: "\u219B", nrarrc: "\u2933\u0338", nrarrw: "\u219D\u0338", nRightarrow: "\u21CF", nrightarrow: "\u219B", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nVDash: "\u22AF", nVdash: "\u22AE", nvDash: "\u22AD", nvdash: "\u22AC", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwArr: "\u21D6", nwarr: "\u2196", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", ocir: "\u229A", Ocirc: "\xD4", ocirc: "\xF4", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", Or: "\u2A54", or: "\u2228", orarr: "\u21BB", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", Otimes: "\u2A37", otimes: "\u2297", otimesas: "\u2A36", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", par: "\u2225", para: "\xB6", parallel: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plus: "+", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", Popf: "\u2119", popf: "\u{1D561}", pound: "\xA3", Pr: "\u2ABB", pr: "\u227A", prap: "\u2AB7", prcue: "\u227C", prE: "\u2AB3", pre: "\u2AAF", prec: "\u227A", precapprox: "\u2AB7", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", precsim: "\u227E", Prime: "\u2033", prime: "\u2032", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportion: "\u2237", Proportional: "\u221D", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", Qopf: "\u211A", qopf: "\u{1D562}", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", QUOT: '"', quot: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", Rang: "\u27EB", rang: "\u27E9", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", Rarr: "\u21A0", rArr: "\u21D2", rarr: "\u2192", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", rAtail: "\u291C", ratail: "\u291A", ratio: "\u2236", rationals: "\u211A", RBarr: "\u2910", rBarr: "\u290F", rbarr: "\u290D", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", Re: "\u211C", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", rect: "\u25AD", REG: "\xAE", reg: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", Rfr: "\u211C", rfr: "\u{1D52F}", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrow: "\u2192", Rightarrow: "\u21D2", rightarrow: "\u2192", RightArrowBar: "\u21E5", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVector: "\u21C2", RightDownVectorBar: "\u2955", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTee: "\u22A2", RightTeeArrow: "\u21A6", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangle: "\u22B3", RightTriangleBar: "\u29D0", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVector: "\u21BE", RightUpVectorBar: "\u2954", RightVector: "\u21C0", RightVectorBar: "\u2953", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoust: "\u23B1", rmoustache: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", Ropf: "\u211D", ropf: "\u{1D563}", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", Rscr: "\u211B", rscr: "\u{1D4C7}", Rsh: "\u21B1", rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", Sc: "\u2ABC", sc: "\u227B", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", sccue: "\u227D", scE: "\u2AB4", sce: "\u2AB0", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdot: "\u22C5", sdotb: "\u22A1", sdote: "\u2A66", searhk: "\u2925", seArr: "\u21D8", searr: "\u2198", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", sol: "/", solb: "\u29C4", solbar: "\u233F", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", squ: "\u25A1", Square: "\u25A1", square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", Sub: "\u22D0", sub: "\u2282", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", Subset: "\u22D0", subset: "\u2282", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succ: "\u227B", succapprox: "\u2AB8", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", Sum: "\u2211", sum: "\u2211", sung: "\u266A", Sup: "\u22D1", sup: "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", Supset: "\u22D1", supset: "\u2283", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swArr: "\u21D9", swarr: "\u2199", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", Therefore: "\u2234", therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", thinsp: "\u2009", ThinSpace: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", Tilde: "\u223C", tilde: "\u02DC", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", times: "\xD7", timesb: "\u22A0", timesbar: "\u2A31", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", top: "\u22A4", topbot: "\u2336", topcir: "\u2AF1", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", TRADE: "\u2122", trade: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", Uarr: "\u219F", uArr: "\u21D1", uarr: "\u2191", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrow: "\u2191", Uparrow: "\u21D1", uparrow: "\u2191", UpArrowBar: "\u2912", UpArrowDownArrow: "\u21C5", UpDownArrow: "\u2195", Updownarrow: "\u21D5", updownarrow: "\u2195", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", Upsi: "\u03D2", upsi: "\u03C5", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTee: "\u22A5", UpTeeArrow: "\u21A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", vArr: "\u21D5", varr: "\u2195", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", Vbar: "\u2AEB", vBar: "\u2AE8", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", VDash: "\u22AB", Vdash: "\u22A9", vDash: "\u22A8", vdash: "\u22A2", Vdashl: "\u2AE6", Vee: "\u22C1", vee: "\u2228", veebar: "\u22BB", veeeq: "\u225A", vellip: "\u22EE", Verbar: "\u2016", verbar: "|", Vert: "\u2016", vert: "|", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", Wedge: "\u22C0", wedge: "\u2227", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xhArr: "\u27FA", xharr: "\u27F7", Xi: "\u039E", xi: "\u03BE", xlArr: "\u27F8", xlarr: "\u27F5", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrArr: "\u27F9", xrarr: "\u27F6", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", Yuml: "\u0178", yuml: "\xFF", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", Zfr: "\u2128", zfr: "\u{1D537}", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", Zopf: "\u2124", zopf: "\u{1D56B}", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" }, e.NGSP_UNICODE = "\uE500", e.NAMED_ENTITIES.ngsp = e.NGSP_UNICODE;
        } }), _s = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_tags.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Ze(), t = class {
            constructor() {
              let { closedByChildren: a, implicitNamespacePrefix: p2, contentType: D = r.TagContentType.PARSABLE_DATA, closedByParent: g = false, isVoid: i = false, ignoreFirstLf: l = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              this.closedByChildren = {}, this.closedByParent = false, this.canSelfClose = false, a && a.length > 0 && a.forEach((h3) => this.closedByChildren[h3] = true), this.isVoid = i, this.closedByParent = g || i, this.implicitNamespacePrefix = p2 || null, this.contentType = D, this.ignoreFirstLf = l;
            }
            isClosedByChild(a) {
              return this.isVoid || a.toLowerCase() in this.closedByChildren;
            }
          };
          e.HtmlTagDefinition = t;
          var s, c;
          function n(a) {
            return c || (s = new t(), c = { base: new t({ isVoid: true }), meta: new t({ isVoid: true }), area: new t({ isVoid: true }), embed: new t({ isVoid: true }), link: new t({ isVoid: true }), img: new t({ isVoid: true }), input: new t({ isVoid: true }), param: new t({ isVoid: true }), hr: new t({ isVoid: true }), br: new t({ isVoid: true }), source: new t({ isVoid: true }), track: new t({ isVoid: true }), wbr: new t({ isVoid: true }), p: new t({ closedByChildren: ["address", "article", "aside", "blockquote", "div", "dl", "fieldset", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"], closedByParent: true }), thead: new t({ closedByChildren: ["tbody", "tfoot"] }), tbody: new t({ closedByChildren: ["tbody", "tfoot"], closedByParent: true }), tfoot: new t({ closedByChildren: ["tbody"], closedByParent: true }), tr: new t({ closedByChildren: ["tr"], closedByParent: true }), td: new t({ closedByChildren: ["td", "th"], closedByParent: true }), th: new t({ closedByChildren: ["td", "th"], closedByParent: true }), col: new t({ isVoid: true }), svg: new t({ implicitNamespacePrefix: "svg" }), math: new t({ implicitNamespacePrefix: "math" }), li: new t({ closedByChildren: ["li"], closedByParent: true }), dt: new t({ closedByChildren: ["dt", "dd"] }), dd: new t({ closedByChildren: ["dt", "dd"], closedByParent: true }), rb: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rt: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), rtc: new t({ closedByChildren: ["rb", "rtc", "rp"], closedByParent: true }), rp: new t({ closedByChildren: ["rb", "rt", "rtc", "rp"], closedByParent: true }), optgroup: new t({ closedByChildren: ["optgroup"], closedByParent: true }), option: new t({ closedByChildren: ["option", "optgroup"], closedByParent: true }), pre: new t({ ignoreFirstLf: true }), listing: new t({ ignoreFirstLf: true }), style: new t({ contentType: r.TagContentType.RAW_TEXT }), script: new t({ contentType: r.TagContentType.RAW_TEXT }), title: new t({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT }), textarea: new t({ contentType: r.TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }) }), c[a] || s;
          }
          e.getHtmlTagDefinition = n;
        } }), VD = I({ "node_modules/angular-html-parser/lib/compiler/src/ast_path.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = class {
            constructor(t) {
              let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
              this.path = t, this.position = s;
            }
            get empty() {
              return !this.path || !this.path.length;
            }
            get head() {
              return this.path[0];
            }
            get tail() {
              return this.path[this.path.length - 1];
            }
            parentOf(t) {
              return t && this.path[this.path.indexOf(t) - 1];
            }
            childOf(t) {
              return this.path[this.path.indexOf(t) + 1];
            }
            first(t) {
              for (let s = this.path.length - 1; s >= 0; s--) {
                let c = this.path[s];
                if (c instanceof t)
                  return c;
              }
            }
            push(t) {
              this.path.push(t);
            }
            pop() {
              return this.path.pop();
            }
          };
          e.AstPath = r;
        } }), Ss = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/ast.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = VD(), t = class {
            constructor(d, m2, T) {
              this.value = d, this.sourceSpan = m2, this.i18n = T, this.type = "text";
            }
            visit(d, m2) {
              return d.visitText(this, m2);
            }
          };
          e.Text = t;
          var s = class {
            constructor(d, m2) {
              this.value = d, this.sourceSpan = m2, this.type = "cdata";
            }
            visit(d, m2) {
              return d.visitCdata(this, m2);
            }
          };
          e.CDATA = s;
          var c = class {
            constructor(d, m2, T, B, A, N) {
              this.switchValue = d, this.type = m2, this.cases = T, this.sourceSpan = B, this.switchValueSourceSpan = A, this.i18n = N;
            }
            visit(d, m2) {
              return d.visitExpansion(this, m2);
            }
          };
          e.Expansion = c;
          var n = class {
            constructor(d, m2, T, B, A) {
              this.value = d, this.expression = m2, this.sourceSpan = T, this.valueSourceSpan = B, this.expSourceSpan = A;
            }
            visit(d, m2) {
              return d.visitExpansionCase(this, m2);
            }
          };
          e.ExpansionCase = n;
          var a = class {
            constructor(d, m2, T) {
              let B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null;
              this.name = d, this.value = m2, this.sourceSpan = T, this.valueSpan = B, this.nameSpan = A, this.i18n = N, this.type = "attribute";
            }
            visit(d, m2) {
              return d.visitAttribute(this, m2);
            }
          };
          e.Attribute = a;
          var p2 = class {
            constructor(d, m2, T, B) {
              let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null, N = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null, R = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, $2 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null;
              this.name = d, this.attrs = m2, this.children = T, this.sourceSpan = B, this.startSourceSpan = A, this.endSourceSpan = N, this.nameSpan = R, this.i18n = $2, this.type = "element";
            }
            visit(d, m2) {
              return d.visitElement(this, m2);
            }
          };
          e.Element = p2;
          var D = class {
            constructor(d, m2) {
              this.value = d, this.sourceSpan = m2, this.type = "comment";
            }
            visit(d, m2) {
              return d.visitComment(this, m2);
            }
          };
          e.Comment = D;
          var g = class {
            constructor(d, m2) {
              this.value = d, this.sourceSpan = m2, this.type = "docType";
            }
            visit(d, m2) {
              return d.visitDocType(this, m2);
            }
          };
          e.DocType = g;
          function i(d, m2) {
            let T = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, B = [], A = d.visit ? (N) => d.visit(N, T) || N.visit(d, T) : (N) => N.visit(d, T);
            return m2.forEach((N) => {
              let R = A(N);
              R && B.push(R);
            }), B;
          }
          e.visitAll = i;
          var l = class {
            constructor() {
            }
            visitElement(d, m2) {
              this.visitChildren(m2, (T) => {
                T(d.attrs), T(d.children);
              });
            }
            visitAttribute(d, m2) {
            }
            visitText(d, m2) {
            }
            visitCdata(d, m2) {
            }
            visitComment(d, m2) {
            }
            visitDocType(d, m2) {
            }
            visitExpansion(d, m2) {
              return this.visitChildren(m2, (T) => {
                T(d.cases);
              });
            }
            visitExpansionCase(d, m2) {
            }
            visitChildren(d, m2) {
              let T = [], B = this;
              function A(N) {
                N && T.push(i(B, N, d));
              }
              return m2(A), Array.prototype.concat.apply([], T);
            }
          };
          e.RecursiveVisitor = l;
          function h3(d) {
            let m2 = d.sourceSpan.start.offset, T = d.sourceSpan.end.offset;
            return d instanceof p2 && (d.endSourceSpan ? T = d.endSourceSpan.end.offset : d.children && d.children.length && (T = h3(d.children[d.children.length - 1]).end)), { start: m2, end: T };
          }
          function C(d, m2) {
            let T = [], B = new class extends l {
              visit(A, N) {
                let R = h3(A);
                if (R.start <= m2 && m2 < R.end)
                  T.push(A);
                else
                  return true;
              }
            }();
            return i(B, d), new r.AstPath(T, m2);
          }
          e.findNode = C;
        } }), XD = I({ "node_modules/angular-html-parser/lib/compiler/src/assertions.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          function r(c, n) {
            if (n != null) {
              if (!Array.isArray(n))
                throw new Error("Expected '".concat(c, "' to be an array of strings."));
              for (let a = 0; a < n.length; a += 1)
                if (typeof n[a] != "string")
                  throw new Error("Expected '".concat(c, "' to be an array of strings."));
            }
          }
          e.assertArrayOfStrings = r;
          var t = [/^\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\/\//];
          function s(c, n) {
            if (n != null && !(Array.isArray(n) && n.length == 2))
              throw new Error("Expected '".concat(c, "' to be an array, [start, end]."));
            if (n != null) {
              let a = n[0], p2 = n[1];
              t.forEach((D) => {
                if (D.test(a) || D.test(p2))
                  throw new Error("['".concat(a, "', '").concat(p2, "'] contains unusable interpolation symbol."));
              });
            }
          }
          e.assertInterpolationSymbols = s;
        } }), HD = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/interpolation_config.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = XD(), t = class {
            constructor(s, c) {
              this.start = s, this.end = c;
            }
            static fromArray(s) {
              return s ? (r.assertInterpolationSymbols("interpolation", s), new t(s[0], s[1])) : e.DEFAULT_INTERPOLATION_CONFIG;
            }
          };
          e.InterpolationConfig = t, e.DEFAULT_INTERPOLATION_CONFIG = new t("{{", "}}");
        } }), zD = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/lexer.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = hs(), t = Te(), s = HD(), c = Ze(), n;
          (function(u) {
            u[u.TAG_OPEN_START = 0] = "TAG_OPEN_START", u[u.TAG_OPEN_END = 1] = "TAG_OPEN_END", u[u.TAG_OPEN_END_VOID = 2] = "TAG_OPEN_END_VOID", u[u.TAG_CLOSE = 3] = "TAG_CLOSE", u[u.TEXT = 4] = "TEXT", u[u.ESCAPABLE_RAW_TEXT = 5] = "ESCAPABLE_RAW_TEXT", u[u.RAW_TEXT = 6] = "RAW_TEXT", u[u.COMMENT_START = 7] = "COMMENT_START", u[u.COMMENT_END = 8] = "COMMENT_END", u[u.CDATA_START = 9] = "CDATA_START", u[u.CDATA_END = 10] = "CDATA_END", u[u.ATTR_NAME = 11] = "ATTR_NAME", u[u.ATTR_QUOTE = 12] = "ATTR_QUOTE", u[u.ATTR_VALUE = 13] = "ATTR_VALUE", u[u.DOC_TYPE_START = 14] = "DOC_TYPE_START", u[u.DOC_TYPE_END = 15] = "DOC_TYPE_END", u[u.EXPANSION_FORM_START = 16] = "EXPANSION_FORM_START", u[u.EXPANSION_CASE_VALUE = 17] = "EXPANSION_CASE_VALUE", u[u.EXPANSION_CASE_EXP_START = 18] = "EXPANSION_CASE_EXP_START", u[u.EXPANSION_CASE_EXP_END = 19] = "EXPANSION_CASE_EXP_END", u[u.EXPANSION_FORM_END = 20] = "EXPANSION_FORM_END", u[u.EOF = 21] = "EOF";
          })(n = e.TokenType || (e.TokenType = {}));
          var a = class {
            constructor(u, o, E) {
              this.type = u, this.parts = o, this.sourceSpan = E;
            }
          };
          e.Token = a;
          var p2 = class extends t.ParseError {
            constructor(u, o, E) {
              super(E, u), this.tokenType = o;
            }
          };
          e.TokenError = p2;
          var D = class {
            constructor(u, o) {
              this.tokens = u, this.errors = o;
            }
          };
          e.TokenizeResult = D;
          function g(u, o, E) {
            let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return new d(new t.ParseSourceFile(u, o), E, f).tokenize();
          }
          e.tokenize = g;
          var i = /\r\n?/g;
          function l(u) {
            let o = u === r.$EOF ? "EOF" : String.fromCharCode(u);
            return 'Unexpected character "'.concat(o, '"');
          }
          function h3(u) {
            return 'Unknown entity "'.concat(u, '" - use the "&#<decimal>;" or  "&#x<hex>;" syntax');
          }
          var C = class {
            constructor(u) {
              this.error = u;
            }
          }, d = class {
            constructor(u, o, E) {
              this._getTagContentType = o, this._currentTokenStart = null, this._currentTokenType = null, this._expansionCaseStack = [], this._inInterpolation = false, this._fullNameStack = [], this.tokens = [], this.errors = [], this._tokenizeIcu = E.tokenizeExpansionForms || false, this._interpolationConfig = E.interpolationConfig || s.DEFAULT_INTERPOLATION_CONFIG, this._leadingTriviaCodePoints = E.leadingTriviaChars && E.leadingTriviaChars.map((F) => F.codePointAt(0) || 0), this._canSelfClose = E.canSelfClose || false, this._allowHtmComponentClosingTags = E.allowHtmComponentClosingTags || false;
              let f = E.range || { endPos: u.content.length, startPos: 0, startLine: 0, startCol: 0 };
              this._cursor = E.escapedString ? new k(u, f) : new x(u, f);
              try {
                this._cursor.init();
              } catch (F) {
                this.handleError(F);
              }
            }
            _processCarriageReturns(u) {
              return u.replace(i, `
`);
            }
            tokenize() {
              for (; this._cursor.peek() !== r.$EOF; ) {
                let u = this._cursor.clone();
                try {
                  if (this._attemptCharCode(r.$LT))
                    if (this._attemptCharCode(r.$BANG))
                      this._attemptStr("[CDATA[") ? this._consumeCdata(u) : this._attemptStr("--") ? this._consumeComment(u) : this._attemptStrCaseInsensitive("doctype") ? this._consumeDocType(u) : this._consumeBogusComment(u);
                    else if (this._attemptCharCode(r.$SLASH))
                      this._consumeTagClose(u);
                    else {
                      let o = this._cursor.clone();
                      this._attemptCharCode(r.$QUESTION) ? (this._cursor = o, this._consumeBogusComment(u)) : this._consumeTagOpen(u);
                    }
                  else
                    this._tokenizeIcu && this._tokenizeExpansionForm() || this._consumeText();
                } catch (o) {
                  this.handleError(o);
                }
              }
              return this._beginToken(n.EOF), this._endToken([]), new D(O(this.tokens), this.errors);
            }
            _tokenizeExpansionForm() {
              if (this.isExpansionFormStart())
                return this._consumeExpansionFormStart(), true;
              if (R(this._cursor.peek()) && this._isInExpansionForm())
                return this._consumeExpansionCaseStart(), true;
              if (this._cursor.peek() === r.$RBRACE) {
                if (this._isInExpansionCase())
                  return this._consumeExpansionCaseEnd(), true;
                if (this._isInExpansionForm())
                  return this._consumeExpansionFormEnd(), true;
              }
              return false;
            }
            _beginToken(u) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
              this._currentTokenStart = o, this._currentTokenType = u;
            }
            _endToken(u) {
              let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._cursor.clone();
              if (this._currentTokenStart === null)
                throw new p2("Programming error - attempted to end a token when there was no start to the token", this._currentTokenType, this._cursor.getSpan(o));
              if (this._currentTokenType === null)
                throw new p2("Programming error - attempted to end a token which has no token type", null, this._cursor.getSpan(this._currentTokenStart));
              let E = new a(this._currentTokenType, u, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));
              return this.tokens.push(E), this._currentTokenStart = null, this._currentTokenType = null, E;
            }
            _createError(u, o) {
              this._isInExpansionForm() && (u += ` (Do you have an unescaped "{" in your template? Use "{{ '{' }}") to escape it.)`);
              let E = new p2(u, this._currentTokenType, o);
              return this._currentTokenStart = null, this._currentTokenType = null, new C(E);
            }
            handleError(u) {
              if (u instanceof M && (u = this._createError(u.msg, this._cursor.getSpan(u.cursor))), u instanceof C)
                this.errors.push(u.error);
              else
                throw u;
            }
            _attemptCharCode(u) {
              return this._cursor.peek() === u ? (this._cursor.advance(), true) : false;
            }
            _attemptCharCodeCaseInsensitive(u) {
              return $2(this._cursor.peek(), u) ? (this._cursor.advance(), true) : false;
            }
            _requireCharCode(u) {
              let o = this._cursor.clone();
              if (!this._attemptCharCode(u))
                throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
            }
            _attemptStr(u) {
              let o = u.length;
              if (this._cursor.charsLeft() < o)
                return false;
              let E = this._cursor.clone();
              for (let f = 0; f < o; f++)
                if (!this._attemptCharCode(u.charCodeAt(f)))
                  return this._cursor = E, false;
              return true;
            }
            _attemptStrCaseInsensitive(u) {
              for (let o = 0; o < u.length; o++)
                if (!this._attemptCharCodeCaseInsensitive(u.charCodeAt(o)))
                  return false;
              return true;
            }
            _requireStr(u) {
              let o = this._cursor.clone();
              if (!this._attemptStr(u))
                throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
            }
            _requireStrCaseInsensitive(u) {
              let o = this._cursor.clone();
              if (!this._attemptStrCaseInsensitive(u))
                throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(o));
            }
            _attemptCharCodeUntilFn(u) {
              for (; !u(this._cursor.peek()); )
                this._cursor.advance();
            }
            _requireCharCodeUntilFn(u, o) {
              let E = this._cursor.clone();
              if (this._attemptCharCodeUntilFn(u), this._cursor.clone().diff(E) < o)
                throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(E));
            }
            _attemptUntilChar(u) {
              for (; this._cursor.peek() !== u; )
                this._cursor.advance();
            }
            _readChar(u) {
              if (u && this._cursor.peek() === r.$AMPERSAND)
                return this._decodeEntity();
              {
                let o = String.fromCodePoint(this._cursor.peek());
                return this._cursor.advance(), o;
              }
            }
            _decodeEntity() {
              let u = this._cursor.clone();
              if (this._cursor.advance(), this._attemptCharCode(r.$HASH)) {
                let o = this._attemptCharCode(r.$x) || this._attemptCharCode(r.$X), E = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(A), this._cursor.peek() != r.$SEMICOLON)
                  throw this._createError(l(this._cursor.peek()), this._cursor.getSpan());
                let f = this._cursor.getChars(E);
                this._cursor.advance();
                try {
                  let F = parseInt(f, o ? 16 : 10);
                  return String.fromCharCode(F);
                } catch {
                  throw this._createError(h3(this._cursor.getChars(u)), this._cursor.getSpan());
                }
              } else {
                let o = this._cursor.clone();
                if (this._attemptCharCodeUntilFn(N), this._cursor.peek() != r.$SEMICOLON)
                  return this._cursor = o, "&";
                let E = this._cursor.getChars(o);
                this._cursor.advance();
                let f = c.NAMED_ENTITIES[E];
                if (!f)
                  throw this._createError(h3(E), this._cursor.getSpan(u));
                return f;
              }
            }
            _consumeRawText(u, o) {
              this._beginToken(u ? n.ESCAPABLE_RAW_TEXT : n.RAW_TEXT);
              let E = [];
              for (; ; ) {
                let f = this._cursor.clone(), F = o();
                if (this._cursor = f, F)
                  break;
                E.push(this._readChar(u));
              }
              return this._endToken([this._processCarriageReturns(E.join(""))]);
            }
            _consumeComment(u) {
              this._beginToken(n.COMMENT_START, u), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("-->")), this._beginToken(n.COMMENT_END), this._requireStr("-->"), this._endToken([]);
            }
            _consumeBogusComment(u) {
              this._beginToken(n.COMMENT_START, u), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.COMMENT_END), this._cursor.advance(), this._endToken([]);
            }
            _consumeCdata(u) {
              this._beginToken(n.CDATA_START, u), this._endToken([]), this._consumeRawText(false, () => this._attemptStr("]]>")), this._beginToken(n.CDATA_END), this._requireStr("]]>"), this._endToken([]);
            }
            _consumeDocType(u) {
              this._beginToken(n.DOC_TYPE_START, u), this._endToken([]), this._consumeRawText(false, () => this._cursor.peek() === r.$GT), this._beginToken(n.DOC_TYPE_END), this._cursor.advance(), this._endToken([]);
            }
            _consumePrefixAndName() {
              let u = this._cursor.clone(), o = "";
              for (; this._cursor.peek() !== r.$COLON && !B(this._cursor.peek()); )
                this._cursor.advance();
              let E;
              this._cursor.peek() === r.$COLON ? (o = this._cursor.getChars(u), this._cursor.advance(), E = this._cursor.clone()) : E = u, this._requireCharCodeUntilFn(T, o === "" ? 0 : 1);
              let f = this._cursor.getChars(E);
              return [o, f];
            }
            _consumeTagOpen(u) {
              let o, E, f, F = this.tokens.length, P = this._cursor.clone(), j = [];
              try {
                if (!r.isAsciiLetter(this._cursor.peek()))
                  throw this._createError(l(this._cursor.peek()), this._cursor.getSpan(u));
                for (f = this._consumeTagOpenStart(u), E = f.parts[0], o = f.parts[1], this._attemptCharCodeUntilFn(m2); this._cursor.peek() !== r.$SLASH && this._cursor.peek() !== r.$GT; ) {
                  let [X, H] = this._consumeAttributeName();
                  if (this._attemptCharCodeUntilFn(m2), this._attemptCharCode(r.$EQ)) {
                    this._attemptCharCodeUntilFn(m2);
                    let z = this._consumeAttributeValue();
                    j.push({ prefix: X, name: H, value: z });
                  } else
                    j.push({ prefix: X, name: H });
                  this._attemptCharCodeUntilFn(m2);
                }
                this._consumeTagOpenEnd();
              } catch (X) {
                if (X instanceof C) {
                  this._cursor = P, f && (this.tokens.length = F), this._beginToken(n.TEXT, u), this._endToken(["<"]);
                  return;
                }
                throw X;
              }
              if (this._canSelfClose && this.tokens[this.tokens.length - 1].type === n.TAG_OPEN_END_VOID)
                return;
              let W = this._getTagContentType(o, E, this._fullNameStack.length > 0, j);
              this._handleFullNameStackForTagOpen(E, o), W === c.TagContentType.RAW_TEXT ? this._consumeRawTextWithTagClose(E, o, false) : W === c.TagContentType.ESCAPABLE_RAW_TEXT && this._consumeRawTextWithTagClose(E, o, true);
            }
            _consumeRawTextWithTagClose(u, o, E) {
              let f = this._consumeRawText(E, () => !this._attemptCharCode(r.$LT) || !this._attemptCharCode(r.$SLASH) || (this._attemptCharCodeUntilFn(m2), !this._attemptStrCaseInsensitive(u ? "".concat(u, ":").concat(o) : o)) ? false : (this._attemptCharCodeUntilFn(m2), this._attemptCharCode(r.$GT)));
              this._beginToken(n.TAG_CLOSE), this._requireCharCodeUntilFn((F) => F === r.$GT, 3), this._cursor.advance(), this._endToken([u, o]), this._handleFullNameStackForTagClose(u, o);
            }
            _consumeTagOpenStart(u) {
              this._beginToken(n.TAG_OPEN_START, u);
              let o = this._consumePrefixAndName();
              return this._endToken(o);
            }
            _consumeAttributeName() {
              let u = this._cursor.peek();
              if (u === r.$SQ || u === r.$DQ)
                throw this._createError(l(u), this._cursor.getSpan());
              this._beginToken(n.ATTR_NAME);
              let o = this._consumePrefixAndName();
              return this._endToken(o), o;
            }
            _consumeAttributeValue() {
              let u;
              if (this._cursor.peek() === r.$SQ || this._cursor.peek() === r.$DQ) {
                this._beginToken(n.ATTR_QUOTE);
                let o = this._cursor.peek();
                this._cursor.advance(), this._endToken([String.fromCodePoint(o)]), this._beginToken(n.ATTR_VALUE);
                let E = [];
                for (; this._cursor.peek() !== o; )
                  E.push(this._readChar(true));
                u = this._processCarriageReturns(E.join("")), this._endToken([u]), this._beginToken(n.ATTR_QUOTE), this._cursor.advance(), this._endToken([String.fromCodePoint(o)]);
              } else {
                this._beginToken(n.ATTR_VALUE);
                let o = this._cursor.clone();
                this._requireCharCodeUntilFn(T, 1), u = this._processCarriageReturns(this._cursor.getChars(o)), this._endToken([u]);
              }
              return u;
            }
            _consumeTagOpenEnd() {
              let u = this._attemptCharCode(r.$SLASH) ? n.TAG_OPEN_END_VOID : n.TAG_OPEN_END;
              this._beginToken(u), this._requireCharCode(r.$GT), this._endToken([]);
            }
            _consumeTagClose(u) {
              if (this._beginToken(n.TAG_CLOSE, u), this._attemptCharCodeUntilFn(m2), this._allowHtmComponentClosingTags && this._attemptCharCode(r.$SLASH))
                this._attemptCharCodeUntilFn(m2), this._requireCharCode(r.$GT), this._endToken([]);
              else {
                let [o, E] = this._consumePrefixAndName();
                this._attemptCharCodeUntilFn(m2), this._requireCharCode(r.$GT), this._endToken([o, E]), this._handleFullNameStackForTagClose(o, E);
              }
            }
            _consumeExpansionFormStart() {
              this._beginToken(n.EXPANSION_FORM_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._expansionCaseStack.push(n.EXPANSION_FORM_START), this._beginToken(n.RAW_TEXT);
              let u = this._readUntil(r.$COMMA);
              this._endToken([u]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m2), this._beginToken(n.RAW_TEXT);
              let o = this._readUntil(r.$COMMA);
              this._endToken([o]), this._requireCharCode(r.$COMMA), this._attemptCharCodeUntilFn(m2);
            }
            _consumeExpansionCaseStart() {
              this._beginToken(n.EXPANSION_CASE_VALUE);
              let u = this._readUntil(r.$LBRACE).trim();
              this._endToken([u]), this._attemptCharCodeUntilFn(m2), this._beginToken(n.EXPANSION_CASE_EXP_START), this._requireCharCode(r.$LBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m2), this._expansionCaseStack.push(n.EXPANSION_CASE_EXP_START);
            }
            _consumeExpansionCaseEnd() {
              this._beginToken(n.EXPANSION_CASE_EXP_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._attemptCharCodeUntilFn(m2), this._expansionCaseStack.pop();
            }
            _consumeExpansionFormEnd() {
              this._beginToken(n.EXPANSION_FORM_END), this._requireCharCode(r.$RBRACE), this._endToken([]), this._expansionCaseStack.pop();
            }
            _consumeText() {
              let u = this._cursor.clone();
              this._beginToken(n.TEXT, u);
              let o = [];
              do
                this._interpolationConfig && this._attemptStr(this._interpolationConfig.start) ? (o.push(this._interpolationConfig.start), this._inInterpolation = true) : this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end) ? (o.push(this._interpolationConfig.end), this._inInterpolation = false) : o.push(this._readChar(true));
              while (!this._isTextEnd());
              this._endToken([this._processCarriageReturns(o.join(""))]);
            }
            _isTextEnd() {
              return !!(this._cursor.peek() === r.$LT || this._cursor.peek() === r.$EOF || this._tokenizeIcu && !this._inInterpolation && (this.isExpansionFormStart() || this._cursor.peek() === r.$RBRACE && this._isInExpansionCase()));
            }
            _readUntil(u) {
              let o = this._cursor.clone();
              return this._attemptUntilChar(u), this._cursor.getChars(o);
            }
            _isInExpansionCase() {
              return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_CASE_EXP_START;
            }
            _isInExpansionForm() {
              return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === n.EXPANSION_FORM_START;
            }
            isExpansionFormStart() {
              if (this._cursor.peek() !== r.$LBRACE)
                return false;
              if (this._interpolationConfig) {
                let u = this._cursor.clone(), o = this._attemptStr(this._interpolationConfig.start);
                return this._cursor = u, !o;
              }
              return true;
            }
            _handleFullNameStackForTagOpen(u, o) {
              let E = c.mergeNsAndName(u, o);
              (this._fullNameStack.length === 0 || this._fullNameStack[this._fullNameStack.length - 1] === E) && this._fullNameStack.push(E);
            }
            _handleFullNameStackForTagClose(u, o) {
              let E = c.mergeNsAndName(u, o);
              this._fullNameStack.length !== 0 && this._fullNameStack[this._fullNameStack.length - 1] === E && this._fullNameStack.pop();
            }
          };
          function m2(u) {
            return !r.isWhitespace(u) || u === r.$EOF;
          }
          function T(u) {
            return r.isWhitespace(u) || u === r.$GT || u === r.$SLASH || u === r.$SQ || u === r.$DQ || u === r.$EQ;
          }
          function B(u) {
            return (u < r.$a || r.$z < u) && (u < r.$A || r.$Z < u) && (u < r.$0 || u > r.$9);
          }
          function A(u) {
            return u == r.$SEMICOLON || u == r.$EOF || !r.isAsciiHexDigit(u);
          }
          function N(u) {
            return u == r.$SEMICOLON || u == r.$EOF || !r.isAsciiLetter(u);
          }
          function R(u) {
            return u === r.$EQ || r.isAsciiLetter(u) || r.isDigit(u);
          }
          function $2(u, o) {
            return _(u) == _(o);
          }
          function _(u) {
            return u >= r.$a && u <= r.$z ? u - r.$a + r.$A : u;
          }
          function O(u) {
            let o = [], E;
            for (let f = 0; f < u.length; f++) {
              let F = u[f];
              E && E.type == n.TEXT && F.type == n.TEXT ? (E.parts[0] += F.parts[0], E.sourceSpan.end = F.sourceSpan.end) : (E = F, o.push(E));
            }
            return o;
          }
          var x = class {
            constructor(u, o) {
              if (u instanceof x)
                this.file = u.file, this.input = u.input, this.end = u.end, this.state = Object.assign({}, u.state);
              else {
                if (!o)
                  throw new Error("Programming error: the range argument must be provided with a file argument.");
                this.file = u, this.input = u.content, this.end = o.endPos, this.state = { peek: -1, offset: o.startPos, line: o.startLine, column: o.startCol };
              }
            }
            clone() {
              return new x(this);
            }
            peek() {
              return this.state.peek;
            }
            charsLeft() {
              return this.end - this.state.offset;
            }
            diff(u) {
              return this.state.offset - u.state.offset;
            }
            advance() {
              this.advanceState(this.state);
            }
            init() {
              this.updatePeek(this.state);
            }
            getSpan(u, o) {
              if (u = u || this, o)
                for (u = u.clone(); this.diff(u) > 0 && o.indexOf(u.peek()) !== -1; )
                  u.advance();
              return new t.ParseSourceSpan(new t.ParseLocation(u.file, u.state.offset, u.state.line, u.state.column), new t.ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));
            }
            getChars(u) {
              return this.input.substring(u.state.offset, this.state.offset);
            }
            charAt(u) {
              return this.input.charCodeAt(u);
            }
            advanceState(u) {
              if (u.offset >= this.end)
                throw this.state = u, new M('Unexpected character "EOF"', this);
              let o = this.charAt(u.offset);
              o === r.$LF ? (u.line++, u.column = 0) : r.isNewLine(o) || u.column++, u.offset++, this.updatePeek(u);
            }
            updatePeek(u) {
              u.peek = u.offset >= this.end ? r.$EOF : this.charAt(u.offset);
            }
          }, k = class extends x {
            constructor(u, o) {
              u instanceof k ? (super(u), this.internalState = Object.assign({}, u.internalState)) : (super(u, o), this.internalState = this.state);
            }
            advance() {
              this.state = this.internalState, super.advance(), this.processEscapeSequence();
            }
            init() {
              super.init(), this.processEscapeSequence();
            }
            clone() {
              return new k(this);
            }
            getChars(u) {
              let o = u.clone(), E = "";
              for (; o.internalState.offset < this.internalState.offset; )
                E += String.fromCodePoint(o.peek()), o.advance();
              return E;
            }
            processEscapeSequence() {
              let u = () => this.internalState.peek;
              if (u() === r.$BACKSLASH)
                if (this.internalState = Object.assign({}, this.state), this.advanceState(this.internalState), u() === r.$n)
                  this.state.peek = r.$LF;
                else if (u() === r.$r)
                  this.state.peek = r.$CR;
                else if (u() === r.$v)
                  this.state.peek = r.$VTAB;
                else if (u() === r.$t)
                  this.state.peek = r.$TAB;
                else if (u() === r.$b)
                  this.state.peek = r.$BSPACE;
                else if (u() === r.$f)
                  this.state.peek = r.$FF;
                else if (u() === r.$u)
                  if (this.advanceState(this.internalState), u() === r.$LBRACE) {
                    this.advanceState(this.internalState);
                    let o = this.clone(), E = 0;
                    for (; u() !== r.$RBRACE; )
                      this.advanceState(this.internalState), E++;
                    this.state.peek = this.decodeHexDigits(o, E);
                  } else {
                    let o = this.clone();
                    this.advanceState(this.internalState), this.advanceState(this.internalState), this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 4);
                  }
                else if (u() === r.$x) {
                  this.advanceState(this.internalState);
                  let o = this.clone();
                  this.advanceState(this.internalState), this.state.peek = this.decodeHexDigits(o, 2);
                } else if (r.isOctalDigit(u())) {
                  let o = "", E = 0, f = this.clone();
                  for (; r.isOctalDigit(u()) && E < 3; )
                    f = this.clone(), o += String.fromCodePoint(u()), this.advanceState(this.internalState), E++;
                  this.state.peek = parseInt(o, 8), this.internalState = f.internalState;
                } else
                  r.isNewLine(this.internalState.peek) ? (this.advanceState(this.internalState), this.state = this.internalState) : this.state.peek = this.internalState.peek;
            }
            decodeHexDigits(u, o) {
              let E = this.input.substr(u.internalState.offset, o), f = parseInt(E, 16);
              if (isNaN(f))
                throw u.state = u.internalState, new M("Invalid hexadecimal escape sequence", u);
              return f;
            }
          }, M = class {
            constructor(u, o) {
              this.msg = u, this.cursor = o;
            }
          };
          e.CursorError = M;
        } }), as = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/parser.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = Te(), t = Ss(), s = zD(), c = Ze(), n = class extends r.ParseError {
            constructor(i, l, h3) {
              super(l, h3), this.elementName = i;
            }
            static create(i, l, h3) {
              return new n(i, l, h3);
            }
          };
          e.TreeError = n;
          var a = class {
            constructor(i, l) {
              this.rootNodes = i, this.errors = l;
            }
          };
          e.ParseTreeResult = a;
          var p2 = class {
            constructor(i) {
              this.getTagDefinition = i;
            }
            parse(i, l, h3) {
              let C = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, d = arguments.length > 4 ? arguments[4] : void 0, m2 = (x) => function(k) {
                for (var M = arguments.length, u = new Array(M > 1 ? M - 1 : 0), o = 1; o < M; o++)
                  u[o - 1] = arguments[o];
                return x(k.toLowerCase(), ...u);
              }, T = C ? this.getTagDefinition : m2(this.getTagDefinition), B = (x) => T(x).contentType, A = C ? d : m2(d), N = d ? (x, k, M, u) => {
                let o = A(x, k, M, u);
                return o !== void 0 ? o : B(x);
              } : B, R = s.tokenize(i, l, N, h3), $2 = h3 && h3.canSelfClose || false, _ = h3 && h3.allowHtmComponentClosingTags || false, O = new D(R.tokens, T, $2, _, C).build();
              return new a(O.rootNodes, R.errors.concat(O.errors));
            }
          };
          e.Parser = p2;
          var D = class {
            constructor(i, l, h3, C, d) {
              this.tokens = i, this.getTagDefinition = l, this.canSelfClose = h3, this.allowHtmComponentClosingTags = C, this.isTagNameCaseSensitive = d, this._index = -1, this._rootNodes = [], this._errors = [], this._elementStack = [], this._advance();
            }
            build() {
              for (; this._peek.type !== s.TokenType.EOF; )
                this._peek.type === s.TokenType.TAG_OPEN_START ? this._consumeStartTag(this._advance()) : this._peek.type === s.TokenType.TAG_CLOSE ? (this._closeVoidElement(), this._consumeEndTag(this._advance())) : this._peek.type === s.TokenType.CDATA_START ? (this._closeVoidElement(), this._consumeCdata(this._advance())) : this._peek.type === s.TokenType.COMMENT_START ? (this._closeVoidElement(), this._consumeComment(this._advance())) : this._peek.type === s.TokenType.TEXT || this._peek.type === s.TokenType.RAW_TEXT || this._peek.type === s.TokenType.ESCAPABLE_RAW_TEXT ? (this._closeVoidElement(), this._consumeText(this._advance())) : this._peek.type === s.TokenType.EXPANSION_FORM_START ? this._consumeExpansion(this._advance()) : this._peek.type === s.TokenType.DOC_TYPE_START ? this._consumeDocType(this._advance()) : this._advance();
              return new a(this._rootNodes, this._errors);
            }
            _advance() {
              let i = this._peek;
              return this._index < this.tokens.length - 1 && this._index++, this._peek = this.tokens[this._index], i;
            }
            _advanceIf(i) {
              return this._peek.type === i ? this._advance() : null;
            }
            _consumeCdata(i) {
              let l = this._advance(), h3 = this._getText(l), C = this._advanceIf(s.TokenType.CDATA_END);
              this._addToParent(new t.CDATA(h3, new r.ParseSourceSpan(i.sourceSpan.start, (C || l).sourceSpan.end)));
            }
            _consumeComment(i) {
              let l = this._advanceIf(s.TokenType.RAW_TEXT), h3 = this._advanceIf(s.TokenType.COMMENT_END), C = l != null ? l.parts[0].trim() : null, d = new r.ParseSourceSpan(i.sourceSpan.start, (h3 || l || i).sourceSpan.end);
              this._addToParent(new t.Comment(C, d));
            }
            _consumeDocType(i) {
              let l = this._advanceIf(s.TokenType.RAW_TEXT), h3 = this._advanceIf(s.TokenType.DOC_TYPE_END), C = l != null ? l.parts[0].trim() : null, d = new r.ParseSourceSpan(i.sourceSpan.start, (h3 || l || i).sourceSpan.end);
              this._addToParent(new t.DocType(C, d));
            }
            _consumeExpansion(i) {
              let l = this._advance(), h3 = this._advance(), C = [];
              for (; this._peek.type === s.TokenType.EXPANSION_CASE_VALUE; ) {
                let m2 = this._parseExpansionCase();
                if (!m2)
                  return;
                C.push(m2);
              }
              if (this._peek.type !== s.TokenType.EXPANSION_FORM_END) {
                this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '}'."));
                return;
              }
              let d = new r.ParseSourceSpan(i.sourceSpan.start, this._peek.sourceSpan.end);
              this._addToParent(new t.Expansion(l.parts[0], h3.parts[0], C, d, l.sourceSpan)), this._advance();
            }
            _parseExpansionCase() {
              let i = this._advance();
              if (this._peek.type !== s.TokenType.EXPANSION_CASE_EXP_START)
                return this._errors.push(n.create(null, this._peek.sourceSpan, "Invalid ICU message. Missing '{'.")), null;
              let l = this._advance(), h3 = this._collectExpansionExpTokens(l);
              if (!h3)
                return null;
              let C = this._advance();
              h3.push(new s.Token(s.TokenType.EOF, [], C.sourceSpan));
              let d = new D(h3, this.getTagDefinition, this.canSelfClose, this.allowHtmComponentClosingTags, this.isTagNameCaseSensitive).build();
              if (d.errors.length > 0)
                return this._errors = this._errors.concat(d.errors), null;
              let m2 = new r.ParseSourceSpan(i.sourceSpan.start, C.sourceSpan.end), T = new r.ParseSourceSpan(l.sourceSpan.start, C.sourceSpan.end);
              return new t.ExpansionCase(i.parts[0], d.rootNodes, m2, i.sourceSpan, T);
            }
            _collectExpansionExpTokens(i) {
              let l = [], h3 = [s.TokenType.EXPANSION_CASE_EXP_START];
              for (; ; ) {
                if ((this._peek.type === s.TokenType.EXPANSION_FORM_START || this._peek.type === s.TokenType.EXPANSION_CASE_EXP_START) && h3.push(this._peek.type), this._peek.type === s.TokenType.EXPANSION_CASE_EXP_END)
                  if (g(h3, s.TokenType.EXPANSION_CASE_EXP_START)) {
                    if (h3.pop(), h3.length == 0)
                      return l;
                  } else
                    return this._errors.push(n.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                if (this._peek.type === s.TokenType.EXPANSION_FORM_END)
                  if (g(h3, s.TokenType.EXPANSION_FORM_START))
                    h3.pop();
                  else
                    return this._errors.push(n.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                if (this._peek.type === s.TokenType.EOF)
                  return this._errors.push(n.create(null, i.sourceSpan, "Invalid ICU message. Missing '}'.")), null;
                l.push(this._advance());
              }
            }
            _getText(i) {
              let l = i.parts[0];
              if (l.length > 0 && l[0] == `
`) {
                let h3 = this._getParentElement();
                h3 != null && h3.children.length == 0 && this.getTagDefinition(h3.name).ignoreFirstLf && (l = l.substring(1));
              }
              return l;
            }
            _consumeText(i) {
              let l = this._getText(i);
              l.length > 0 && this._addToParent(new t.Text(l, i.sourceSpan));
            }
            _closeVoidElement() {
              let i = this._getParentElement();
              i && this.getTagDefinition(i.name).isVoid && this._elementStack.pop();
            }
            _consumeStartTag(i) {
              let l = i.parts[0], h3 = i.parts[1], C = [];
              for (; this._peek.type === s.TokenType.ATTR_NAME; )
                C.push(this._consumeAttr(this._advance()));
              let d = this._getElementFullName(l, h3, this._getParentElement()), m2 = false;
              if (this._peek.type === s.TokenType.TAG_OPEN_END_VOID) {
                this._advance(), m2 = true;
                let R = this.getTagDefinition(d);
                this.canSelfClose || R.canSelfClose || c.getNsPrefix(d) !== null || R.isVoid || this._errors.push(n.create(d, i.sourceSpan, 'Only void and foreign elements can be self closed "'.concat(i.parts[1], '"')));
              } else
                this._peek.type === s.TokenType.TAG_OPEN_END && (this._advance(), m2 = false);
              let T = this._peek.sourceSpan.start, B = new r.ParseSourceSpan(i.sourceSpan.start, T), A = new r.ParseSourceSpan(i.sourceSpan.start.moveBy(1), i.sourceSpan.end), N = new t.Element(d, C, [], B, B, void 0, A);
              this._pushElement(N), m2 && (this._popElement(d), N.endSourceSpan = B);
            }
            _pushElement(i) {
              let l = this._getParentElement();
              l && this.getTagDefinition(l.name).isClosedByChild(i.name) && this._elementStack.pop(), this._addToParent(i), this._elementStack.push(i);
            }
            _consumeEndTag(i) {
              let l = this.allowHtmComponentClosingTags && i.parts.length === 0 ? null : this._getElementFullName(i.parts[0], i.parts[1], this._getParentElement());
              if (this._getParentElement() && (this._getParentElement().endSourceSpan = i.sourceSpan), l && this.getTagDefinition(l).isVoid)
                this._errors.push(n.create(l, i.sourceSpan, 'Void elements do not have end tags "'.concat(i.parts[1], '"')));
              else if (!this._popElement(l)) {
                let h3 = 'Unexpected closing tag "'.concat(l, '". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags');
                this._errors.push(n.create(l, i.sourceSpan, h3));
              }
            }
            _popElement(i) {
              for (let l = this._elementStack.length - 1; l >= 0; l--) {
                let h3 = this._elementStack[l];
                if (!i || (c.getNsPrefix(h3.name) ? h3.name == i : h3.name.toLowerCase() == i.toLowerCase()))
                  return this._elementStack.splice(l, this._elementStack.length - l), true;
                if (!this.getTagDefinition(h3.name).closedByParent)
                  return false;
              }
              return false;
            }
            _consumeAttr(i) {
              let l = c.mergeNsAndName(i.parts[0], i.parts[1]), h3 = i.sourceSpan.end, C = "", d, m2;
              if (this._peek.type === s.TokenType.ATTR_QUOTE && (m2 = this._advance().sourceSpan.start), this._peek.type === s.TokenType.ATTR_VALUE) {
                let T = this._advance();
                C = T.parts[0], h3 = T.sourceSpan.end, d = T.sourceSpan;
              }
              return this._peek.type === s.TokenType.ATTR_QUOTE && (h3 = this._advance().sourceSpan.end, d = new r.ParseSourceSpan(m2, h3)), new t.Attribute(l, C, new r.ParseSourceSpan(i.sourceSpan.start, h3), d, i.sourceSpan);
            }
            _getParentElement() {
              return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;
            }
            _getParentElementSkippingContainers() {
              let i = null;
              for (let l = this._elementStack.length - 1; l >= 0; l--) {
                if (!c.isNgContainer(this._elementStack[l].name))
                  return { parent: this._elementStack[l], container: i };
                i = this._elementStack[l];
              }
              return { parent: null, container: i };
            }
            _addToParent(i) {
              let l = this._getParentElement();
              l != null ? l.children.push(i) : this._rootNodes.push(i);
            }
            _insertBeforeContainer(i, l, h3) {
              if (!l)
                this._addToParent(h3), this._elementStack.push(h3);
              else {
                if (i) {
                  let C = i.children.indexOf(l);
                  i.children[C] = h3;
                } else
                  this._rootNodes.push(h3);
                h3.children.push(l), this._elementStack.splice(this._elementStack.indexOf(l), 0, h3);
              }
            }
            _getElementFullName(i, l, h3) {
              return i === "" && (i = this.getTagDefinition(l).implicitNamespacePrefix || "", i === "" && h3 != null && (i = c.getNsPrefix(h3.name))), c.mergeNsAndName(i, l);
            }
          };
          function g(i, l) {
            return i.length > 0 && i[i.length - 1] === l;
          }
        } }), WD = I({ "node_modules/angular-html-parser/lib/compiler/src/ml_parser/html_parser.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = _s(), t = as(), s = as();
          e.ParseTreeResult = s.ParseTreeResult, e.TreeError = s.TreeError;
          var c = class extends t.Parser {
            constructor() {
              super(r.getHtmlTagDefinition);
            }
            parse(n, a, p2) {
              let D = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, g = arguments.length > 4 ? arguments[4] : void 0;
              return super.parse(n, a, p2, D, g);
            }
          };
          e.HtmlParser = c;
        } }), ys = I({ "node_modules/angular-html-parser/lib/angular-html-parser/src/index.js"(e) {
          "use strict";
          q(), Object.defineProperty(e, "__esModule", { value: true });
          var r = WD(), t = Ze();
          e.TagContentType = t.TagContentType;
          var s = null, c = () => (s || (s = new r.HtmlParser()), s);
          function n(a) {
            let p2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, { canSelfClose: D = false, allowHtmComponentClosingTags: g = false, isTagNameCaseSensitive: i = false, getTagContentType: l } = p2;
            return c().parse(a, "angular-html-parser", { tokenizeExpansionForms: false, interpolationConfig: void 0, canSelfClose: D, allowHtmComponentClosingTags: g }, i, l);
          }
          e.parse = n;
        } });
        q();
        var { ParseSourceSpan: Qe, ParseLocation: is, ParseSourceFile: YD } = Te(), QD = aD(), KD = ps(), JD = iD(), { inferParserByLanguage: ZD } = ID(), el = xD(), jr = LD(), os = MD(), { hasPragma: rl } = jD(), { Node: tl } = $D(), { parseIeConditionalComment: ul } = UD(), { locStart: nl, locEnd: sl } = GD();
        function al(e, r, t) {
          let { recognizeSelfClosing: s, normalizeTagName: c, normalizeAttributeName: n, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: p2, getTagContentType: D } = r, g = ys(), { RecursiveVisitor: i, visitAll: l } = Ss(), { ParseSourceSpan: h3 } = Te(), { getHtmlTagDefinition: C } = _s(), { rootNodes: d, errors: m2 } = g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: p2, getTagContentType: D });
          if (t.parser === "vue")
            if (d.some((O) => O.type === "docType" && O.value === "html" || O.type === "element" && O.name.toLowerCase() === "html")) {
              s = true, c = true, n = true, a = true, p2 = false;
              let O = g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: p2 });
              d = O.rootNodes, m2 = O.errors;
            } else {
              let O = (x) => {
                if (!x || x.type !== "element" || x.name !== "template")
                  return false;
                let k = x.attrs.find((u) => u.name === "lang"), M = k && k.value;
                return !M || ZD(M, t) === "html";
              };
              if (d.some(O)) {
                let x, k = () => g.parse(e, { canSelfClose: s, allowHtmComponentClosingTags: a, isTagNameCaseSensitive: p2 }), M = () => x || (x = k()), u = (o) => M().rootNodes.find((E) => {
                  let { startSourceSpan: f } = E;
                  return f && f.start.offset === o.startSourceSpan.start.offset;
                });
                for (let o = 0; o < d.length; o++) {
                  let E = d[o], { endSourceSpan: f, startSourceSpan: F } = E;
                  if (f === null)
                    m2 = M().errors, d[o] = u(E) || E;
                  else if (O(E)) {
                    let j = M(), W = F.end.offset, X = f.start.offset;
                    for (let H of j.errors) {
                      let { offset: z } = H.span.start;
                      if (W < z && z < X) {
                        m2 = [H];
                        break;
                      }
                    }
                    d[o] = u(E) || E;
                  }
                }
              }
            }
          if (m2.length > 0) {
            let { msg: _, span: { start: O, end: x } } = m2[0];
            throw JD(_, { start: { line: O.line + 1, column: O.col + 1 }, end: { line: x.line + 1, column: x.col + 1 } });
          }
          let T = (_) => {
            let O = _.name.startsWith(":") ? _.name.slice(1).split(":")[0] : null, x = _.nameSpan.toString(), k = O !== null && x.startsWith("".concat(O, ":")), M = k ? x.slice(O.length + 1) : x;
            _.name = M, _.namespace = O, _.hasExplicitNamespace = k;
          }, B = (_) => {
            switch (_.type) {
              case "element":
                T(_);
                for (let O of _.attrs)
                  T(O), O.valueSpan ? (O.value = O.valueSpan.toString(), /["']/.test(O.value[0]) && (O.value = O.value.slice(1, -1))) : O.value = null;
                break;
              case "comment":
                _.value = _.sourceSpan.toString().slice(4, -3);
                break;
              case "text":
                _.value = _.sourceSpan.toString();
                break;
            }
          }, A = (_, O) => {
            let x = _.toLowerCase();
            return O(x) ? x : _;
          }, N = (_) => {
            if (_.type === "element" && (c && (!_.namespace || _.namespace === _.tagDefinition.implicitNamespacePrefix || os(_)) && (_.name = A(_.name, (O) => O in el)), n)) {
              let O = jr[_.name] || /* @__PURE__ */ Object.create(null);
              for (let x of _.attrs)
                x.namespace || (x.name = A(x.name, (k) => _.name in jr && (k in jr["*"] || k in O)));
            }
          }, R = (_) => {
            _.sourceSpan && _.endSourceSpan && (_.sourceSpan = new h3(_.sourceSpan.start, _.endSourceSpan.end));
          }, $2 = (_) => {
            if (_.type === "element") {
              let O = C(p2 ? _.name : _.name.toLowerCase());
              !_.namespace || _.namespace === O.implicitNamespacePrefix || os(_) ? _.tagDefinition = O : _.tagDefinition = C("");
            }
          };
          return l(new class extends i {
            visit(_) {
              B(_), $2(_), N(_), R(_);
            }
          }(), d), d;
        }
        function Ts(e, r, t) {
          let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true, { frontMatter: c, content: n } = s ? QD(e) : { frontMatter: null, content: e }, a = new YD(e, r.filepath), p2 = new is(a, 0, 0, 0), D = p2.moveBy(e.length), g = { type: "root", sourceSpan: new Qe(p2, D), children: al(n, t, r) };
          if (c) {
            let h3 = new is(a, 0, 0, 0), C = h3.moveBy(c.raw.length);
            c.sourceSpan = new Qe(h3, C), g.children.unshift(c);
          }
          let i = new tl(g), l = (h3, C) => {
            let { offset: d } = C, m2 = e.slice(0, d).replace(/[^\n\r]/g, " "), B = Ts(m2 + h3, r, t, false);
            B.sourceSpan = new Qe(C, KD(B.children).sourceSpan.end);
            let A = B.children[0];
            return A.length === d ? B.children.shift() : (A.sourceSpan = new Qe(A.sourceSpan.start.moveBy(d), A.sourceSpan.end), A.value = A.value.slice(d)), B;
          };
          return i.walk((h3) => {
            if (h3.type === "comment") {
              let C = ul(h3, l);
              C && h3.parent.replaceChild(h3, C);
            }
          }), i;
        }
        function Ke() {
          let { name: e, recognizeSelfClosing: r = false, normalizeTagName: t = false, normalizeAttributeName: s = false, allowHtmComponentClosingTags: c = false, isTagNameCaseSensitive: n = false, getTagContentType: a } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return { parse: (p2, D, g) => Ts(p2, Object.assign({ parser: e }, g), { recognizeSelfClosing: r, normalizeTagName: t, normalizeAttributeName: s, allowHtmComponentClosingTags: c, isTagNameCaseSensitive: n, getTagContentType: a }), hasPragma: rl, astFormat: "html", locStart: nl, locEnd: sl };
        }
        Bs.exports = { parsers: { html: Ke({ name: "html", recognizeSelfClosing: true, normalizeTagName: true, normalizeAttributeName: true, allowHtmComponentClosingTags: true }), angular: Ke({ name: "angular" }), vue: Ke({ name: "vue", recognizeSelfClosing: true, isTagNameCaseSensitive: true, getTagContentType: (e, r, t, s) => {
          if (e.toLowerCase() !== "html" && !t && (e !== "template" || s.some((c) => {
            let { name: n, value: a } = c;
            return n === "lang" && a !== "html" && a !== "" && a !== void 0;
          })))
            return ys().TagContentType.RAW_TEXT;
        } }), lwc: Ke({ name: "lwc" }) } };
      });
      return il();
    });
  }
});

// ../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-postcss.js
var require_parser_postcss = __commonJS({
  "../../../../../Users/z/.yarn/berry/cache/prettier-npm-2.7.1-d1f40f5e1a-9.zip/node_modules/prettier/parser-postcss.js"(exports, module) {
    init_define_process();
    (function(e) {
      if (typeof exports == "object" && typeof module == "object")
        module.exports = e();
      else if (typeof define == "function" && define.amd)
        define(e);
      else {
        var i = typeof globalThis < "u" ? globalThis : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : this || {};
        i.prettierPlugins = i.prettierPlugins || {}, i.prettierPlugins.postcss = e();
      }
    })(function() {
      "use strict";
      var V = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports);
      var ee = V((pp, Ut) => {
        var er = function(e) {
          return e && e.Math == Math && e;
        };
        Ut.exports = er(typeof globalThis == "object" && globalThis) || er(typeof window == "object" && window) || er(typeof self == "object" && self) || er(typeof globalThis == "object" && globalThis) || function() {
          return this;
        }() || Function("return this")();
      });
      var ke = V((hp, Wt) => {
        Wt.exports = function(e) {
          try {
            return !!e();
          } catch {
            return true;
          }
        };
      });
      var Te = V((dp, $t) => {
        var fa = ke();
        $t.exports = !fa(function() {
          return Object.defineProperty({}, 1, { get: function() {
            return 7;
          } })[1] != 7;
        });
      });
      var Sr = V((vp, Vt) => {
        var pa = ke();
        Vt.exports = !pa(function() {
          var e = function() {
          }.bind();
          return typeof e != "function" || e.hasOwnProperty("prototype");
        });
      });
      var tr = V((mp, Gt) => {
        var ha = Sr(), rr = Function.prototype.call;
        Gt.exports = ha ? rr.bind(rr) : function() {
          return rr.apply(rr, arguments);
        };
      });
      var Qt = V((Kt) => {
        "use strict";
        var Ht = {}.propertyIsEnumerable, Jt = Object.getOwnPropertyDescriptor, da = Jt && !Ht.call({ 1: 2 }, 1);
        Kt.f = da ? function(n) {
          var i = Jt(this, n);
          return !!i && i.enumerable;
        } : Ht;
      });
      var Or = V((yp, Yt) => {
        Yt.exports = function(e, n) {
          return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: n };
        };
      });
      var de = V((wp, en) => {
        var Xt = Sr(), Zt = Function.prototype, va = Zt.bind, Tr = Zt.call, ma = Xt && va.bind(Tr, Tr);
        en.exports = Xt ? function(e) {
          return e && ma(e);
        } : function(e) {
          return e && function() {
            return Tr.apply(e, arguments);
          };
        };
      });
      var nn = V((_p, tn) => {
        var rn = de(), ga = rn({}.toString), ya = rn("".slice);
        tn.exports = function(e) {
          return ya(ga(e), 8, -1);
        };
      });
      var on = V((bp, sn) => {
        var wa = ee(), _a = de(), ba = ke(), xa = nn(), Er = wa.Object, ka = _a("".split);
        sn.exports = ba(function() {
          return !Er("z").propertyIsEnumerable(0);
        }) ? function(e) {
          return xa(e) == "String" ? ka(e, "") : Er(e);
        } : Er;
      });
      var qr = V((xp, an) => {
        var Sa = ee(), Oa = Sa.TypeError;
        an.exports = function(e) {
          if (e == null)
            throw Oa("Can't call method on " + e);
          return e;
        };
      });
      var nr = V((kp, un) => {
        var Ta = on(), Ea = qr();
        un.exports = function(e) {
          return Ta(Ea(e));
        };
      });
      var ve = V((Sp, cn) => {
        cn.exports = function(e) {
          return typeof e == "function";
        };
      });
      var Me = V((Op, ln) => {
        var qa = ve();
        ln.exports = function(e) {
          return typeof e == "object" ? e !== null : qa(e);
        };
      });
      var ir = V((Tp, fn) => {
        var Ar = ee(), Aa = ve(), Pa = function(e) {
          return Aa(e) ? e : void 0;
        };
        fn.exports = function(e, n) {
          return arguments.length < 2 ? Pa(Ar[e]) : Ar[e] && Ar[e][n];
        };
      });
      var hn = V((Ep, pn) => {
        var Ra = de();
        pn.exports = Ra({}.isPrototypeOf);
      });
      var vn = V((qp, dn) => {
        var Ia = ir();
        dn.exports = Ia("navigator", "userAgent") || "";
      });
      var xn = V((Ap, bn) => {
        var _n2 = ee(), Pr = vn(), mn = _n2.process, gn = _n2.Deno, yn = mn && mn.versions || gn && gn.version, wn = yn && yn.v8, he, sr;
        wn && (he = wn.split("."), sr = he[0] > 0 && he[0] < 4 ? 1 : +(he[0] + he[1]));
        !sr && Pr && (he = Pr.match(/Edge\/(\d+)/), (!he || he[1] >= 74) && (he = Pr.match(/Chrome\/(\d+)/), he && (sr = +he[1])));
        bn.exports = sr;
      });
      var Rr = V((Pp, Sn) => {
        var kn = xn(), Ca = ke();
        Sn.exports = !!Object.getOwnPropertySymbols && !Ca(function() {
          var e = Symbol();
          return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && kn && kn < 41;
        });
      });
      var Ir = V((Rp, On) => {
        var Na = Rr();
        On.exports = Na && !Symbol.sham && typeof Symbol.iterator == "symbol";
      });
      var Cr = V((Ip, Tn) => {
        var ja = ee(), Ma = ir(), Da = ve(), La = hn(), za = Ir(), Ba = ja.Object;
        Tn.exports = za ? function(e) {
          return typeof e == "symbol";
        } : function(e) {
          var n = Ma("Symbol");
          return Da(n) && La(n.prototype, Ba(e));
        };
      });
      var qn = V((Cp, En) => {
        var Fa = ee(), Ua = Fa.String;
        En.exports = function(e) {
          try {
            return Ua(e);
          } catch {
            return "Object";
          }
        };
      });
      var Pn = V((Np, An) => {
        var Wa = ee(), $a = ve(), Va = qn(), Ga = Wa.TypeError;
        An.exports = function(e) {
          if ($a(e))
            return e;
          throw Ga(Va(e) + " is not a function");
        };
      });
      var In = V((jp, Rn) => {
        var Ha = Pn();
        Rn.exports = function(e, n) {
          var i = e[n];
          return i == null ? void 0 : Ha(i);
        };
      });
      var Nn = V((Mp, Cn) => {
        var Ja = ee(), Nr = tr(), jr = ve(), Mr = Me(), Ka = Ja.TypeError;
        Cn.exports = function(e, n) {
          var i, a;
          if (n === "string" && jr(i = e.toString) && !Mr(a = Nr(i, e)) || jr(i = e.valueOf) && !Mr(a = Nr(i, e)) || n !== "string" && jr(i = e.toString) && !Mr(a = Nr(i, e)))
            return a;
          throw Ka("Can't convert object to primitive value");
        };
      });
      var Mn = V((Dp, jn) => {
        jn.exports = false;
      });
      var or = V((Lp, Ln) => {
        var Dn = ee(), Qa = Object.defineProperty;
        Ln.exports = function(e, n) {
          try {
            Qa(Dn, e, { value: n, configurable: true, writable: true });
          } catch {
            Dn[e] = n;
          }
          return n;
        };
      });
      var ar = V((zp, Bn) => {
        var Ya = ee(), Xa = or(), zn = "__core-js_shared__", Za = Ya[zn] || Xa(zn, {});
        Bn.exports = Za;
      });
      var Dr = V((Bp, Un) => {
        var eu = Mn(), Fn = ar();
        (Un.exports = function(e, n) {
          return Fn[e] || (Fn[e] = n !== void 0 ? n : {});
        })("versions", []).push({ version: "3.22.2", mode: eu ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE", source: "https://github.com/zloirock/core-js" });
      });
      var $n = V((Fp, Wn) => {
        var ru = ee(), tu = qr(), nu = ru.Object;
        Wn.exports = function(e) {
          return nu(tu(e));
        };
      });
      var Se = V((Up, Vn) => {
        var iu = de(), su = $n(), ou = iu({}.hasOwnProperty);
        Vn.exports = Object.hasOwn || function(n, i) {
          return ou(su(n), i);
        };
      });
      var Lr = V((Wp, Gn) => {
        var au = de(), uu = 0, cu = Math.random(), lu = au(1 .toString);
        Gn.exports = function(e) {
          return "Symbol(" + (e === void 0 ? "" : e) + ")_" + lu(++uu + cu, 36);
        };
      });
      var Xn = V(($p, Yn) => {
        var fu = ee(), pu = Dr(), Hn = Se(), hu = Lr(), Jn = Rr(), Qn = Ir(), De = pu("wks"), Ee = fu.Symbol, Kn = Ee && Ee.for, du = Qn ? Ee : Ee && Ee.withoutSetter || hu;
        Yn.exports = function(e) {
          if (!Hn(De, e) || !(Jn || typeof De[e] == "string")) {
            var n = "Symbol." + e;
            Jn && Hn(Ee, e) ? De[e] = Ee[e] : Qn && Kn ? De[e] = Kn(n) : De[e] = du(n);
          }
          return De[e];
        };
      });
      var ti = V((Vp, ri) => {
        var vu = ee(), mu = tr(), Zn = Me(), ei = Cr(), gu = In(), yu = Nn(), wu = Xn(), _u = vu.TypeError, bu = wu("toPrimitive");
        ri.exports = function(e, n) {
          if (!Zn(e) || ei(e))
            return e;
          var i = gu(e, bu), a;
          if (i) {
            if (n === void 0 && (n = "default"), a = mu(i, e, n), !Zn(a) || ei(a))
              return a;
            throw _u("Can't convert object to primitive value");
          }
          return n === void 0 && (n = "number"), yu(e, n);
        };
      });
      var zr = V((Gp, ni) => {
        var xu = ti(), ku = Cr();
        ni.exports = function(e) {
          var n = xu(e, "string");
          return ku(n) ? n : n + "";
        };
      });
      var oi = V((Hp, si) => {
        var Su = ee(), ii = Me(), Br = Su.document, Ou = ii(Br) && ii(Br.createElement);
        si.exports = function(e) {
          return Ou ? Br.createElement(e) : {};
        };
      });
      var Fr = V((Jp, ai) => {
        var Tu = Te(), Eu = ke(), qu = oi();
        ai.exports = !Tu && !Eu(function() {
          return Object.defineProperty(qu("div"), "a", { get: function() {
            return 7;
          } }).a != 7;
        });
      });
      var Ur = V((ci) => {
        var Au = Te(), Pu = tr(), Ru = Qt(), Iu = Or(), Cu = nr(), Nu = zr(), ju = Se(), Mu = Fr(), ui = Object.getOwnPropertyDescriptor;
        ci.f = Au ? ui : function(n, i) {
          if (n = Cu(n), i = Nu(i), Mu)
            try {
              return ui(n, i);
            } catch {
            }
          if (ju(n, i))
            return Iu(!Pu(Ru.f, n, i), n[i]);
        };
      });
      var fi = V((Qp, li) => {
        var Du = Te(), Lu = ke();
        li.exports = Du && Lu(function() {
          return Object.defineProperty(function() {
          }, "prototype", { value: 42, writable: false }).prototype != 42;
        });
      });
      var Wr = V((Yp, hi) => {
        var pi = ee(), zu = Me(), Bu = pi.String, Fu = pi.TypeError;
        hi.exports = function(e) {
          if (zu(e))
            return e;
          throw Fu(Bu(e) + " is not an object");
        };
      });
      var Jr = V((vi) => {
        var Uu = ee(), Wu = Te(), $u = Fr(), Vu = fi(), ur = Wr(), di = zr(), Gu = Uu.TypeError, $r = Object.defineProperty, Hu = Object.getOwnPropertyDescriptor, Vr = "enumerable", Gr = "configurable", Hr = "writable";
        vi.f = Wu ? Vu ? function(n, i, a) {
          if (ur(n), i = di(i), ur(a), typeof n == "function" && i === "prototype" && "value" in a && Hr in a && !a[Hr]) {
            var o = Hu(n, i);
            o && o[Hr] && (n[i] = a.value, a = { configurable: Gr in a ? a[Gr] : o[Gr], enumerable: Vr in a ? a[Vr] : o[Vr], writable: false });
          }
          return $r(n, i, a);
        } : $r : function(n, i, a) {
          if (ur(n), i = di(i), ur(a), $u)
            try {
              return $r(n, i, a);
            } catch {
            }
          if ("get" in a || "set" in a)
            throw Gu("Accessors not supported");
          return "value" in a && (n[i] = a.value), n;
        };
      });
      var cr = V((Zp, mi) => {
        var Ju = Te(), Ku = Jr(), Qu = Or();
        mi.exports = Ju ? function(e, n, i) {
          return Ku.f(e, n, Qu(1, i));
        } : function(e, n, i) {
          return e[n] = i, e;
        };
      });
      var Qr = V((eh, gi) => {
        var Yu = de(), Xu = ve(), Kr = ar(), Zu = Yu(Function.toString);
        Xu(Kr.inspectSource) || (Kr.inspectSource = function(e) {
          return Zu(e);
        });
        gi.exports = Kr.inspectSource;
      });
      var _i = V((rh, wi) => {
        var ec = ee(), rc = ve(), tc = Qr(), yi = ec.WeakMap;
        wi.exports = rc(yi) && /native code/.test(tc(yi));
      });
      var ki = V((th, xi) => {
        var nc = Dr(), ic = Lr(), bi = nc("keys");
        xi.exports = function(e) {
          return bi[e] || (bi[e] = ic(e));
        };
      });
      var Yr = V((nh, Si) => {
        Si.exports = {};
      });
      var Pi = V((ih, Ai) => {
        var sc = _i(), qi = ee(), Xr = de(), oc = Me(), ac = cr(), Zr = Se(), et = ar(), uc = ki(), cc = Yr(), Oi = "Object already initialized", tt = qi.TypeError, lc = qi.WeakMap, lr, Fe, fr, fc = function(e) {
          return fr(e) ? Fe(e) : lr(e, {});
        }, pc = function(e) {
          return function(n) {
            var i;
            if (!oc(n) || (i = Fe(n)).type !== e)
              throw tt("Incompatible receiver, " + e + " required");
            return i;
          };
        };
        sc || et.state ? (Oe = et.state || (et.state = new lc()), Ti = Xr(Oe.get), rt = Xr(Oe.has), Ei = Xr(Oe.set), lr = function(e, n) {
          if (rt(Oe, e))
            throw new tt(Oi);
          return n.facade = e, Ei(Oe, e, n), n;
        }, Fe = function(e) {
          return Ti(Oe, e) || {};
        }, fr = function(e) {
          return rt(Oe, e);
        }) : (qe = uc("state"), cc[qe] = true, lr = function(e, n) {
          if (Zr(e, qe))
            throw new tt(Oi);
          return n.facade = e, ac(e, qe, n), n;
        }, Fe = function(e) {
          return Zr(e, qe) ? e[qe] : {};
        }, fr = function(e) {
          return Zr(e, qe);
        });
        var Oe, Ti, rt, Ei, qe;
        Ai.exports = { set: lr, get: Fe, has: fr, enforce: fc, getterFor: pc };
      });
      var Ci = V((sh, Ii) => {
        var nt = Te(), hc = Se(), Ri = Function.prototype, dc = nt && Object.getOwnPropertyDescriptor, it = hc(Ri, "name"), vc = it && function() {
        }.name === "something", mc = it && (!nt || nt && dc(Ri, "name").configurable);
        Ii.exports = { EXISTS: it, PROPER: vc, CONFIGURABLE: mc };
      });
      var Li = V((oh, Di) => {
        var gc = ee(), Ni = ve(), yc = Se(), ji = cr(), wc = or(), _c = Qr(), Mi = Pi(), bc2 = Ci().CONFIGURABLE, xc = Mi.get, kc = Mi.enforce, Sc = String(String).split("String");
        (Di.exports = function(e, n, i, a) {
          var o = a ? !!a.unsafe : false, f = a ? !!a.enumerable : false, p2 = a ? !!a.noTargetGet : false, h3 = a && a.name !== void 0 ? a.name : n, g;
          if (Ni(i) && (String(h3).slice(0, 7) === "Symbol(" && (h3 = "[" + String(h3).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!yc(i, "name") || bc2 && i.name !== h3) && ji(i, "name", h3), g = kc(i), g.source || (g.source = Sc.join(typeof h3 == "string" ? h3 : ""))), e === gc) {
            f ? e[n] = i : wc(n, i);
            return;
          } else
            o ? !p2 && e[n] && (f = true) : delete e[n];
          f ? e[n] = i : ji(e, n, i);
        })(Function.prototype, "toString", function() {
          return Ni(this) && xc(this).source || _c(this);
        });
      });
      var st = V((ah, zi) => {
        var Oc = Math.ceil, Tc = Math.floor;
        zi.exports = function(e) {
          var n = +e;
          return n !== n || n === 0 ? 0 : (n > 0 ? Tc : Oc)(n);
        };
      });
      var Fi = V((uh, Bi) => {
        var Ec = st(), qc = Math.max, Ac = Math.min;
        Bi.exports = function(e, n) {
          var i = Ec(e);
          return i < 0 ? qc(i + n, 0) : Ac(i, n);
        };
      });
      var Wi = V((ch, Ui) => {
        var Pc = st(), Rc = Math.min;
        Ui.exports = function(e) {
          return e > 0 ? Rc(Pc(e), 9007199254740991) : 0;
        };
      });
      var Vi = V((lh, $i) => {
        var Ic = Wi();
        $i.exports = function(e) {
          return Ic(e.length);
        };
      });
      var Ji = V((fh, Hi) => {
        var Cc = nr(), Nc = Fi(), jc = Vi(), Gi = function(e) {
          return function(n, i, a) {
            var o = Cc(n), f = jc(o), p2 = Nc(a, f), h3;
            if (e && i != i) {
              for (; f > p2; )
                if (h3 = o[p2++], h3 != h3)
                  return true;
            } else
              for (; f > p2; p2++)
                if ((e || p2 in o) && o[p2] === i)
                  return e || p2 || 0;
            return !e && -1;
          };
        };
        Hi.exports = { includes: Gi(true), indexOf: Gi(false) };
      });
      var Yi = V((ph, Qi) => {
        var Mc = de(), ot = Se(), Dc = nr(), Lc = Ji().indexOf, zc = Yr(), Ki = Mc([].push);
        Qi.exports = function(e, n) {
          var i = Dc(e), a = 0, o = [], f;
          for (f in i)
            !ot(zc, f) && ot(i, f) && Ki(o, f);
          for (; n.length > a; )
            ot(i, f = n[a++]) && (~Lc(o, f) || Ki(o, f));
          return o;
        };
      });
      var Zi = V((hh, Xi) => {
        Xi.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
      });
      var rs = V((es) => {
        var Bc = Yi(), Fc = Zi(), Uc = Fc.concat("length", "prototype");
        es.f = Object.getOwnPropertyNames || function(n) {
          return Bc(n, Uc);
        };
      });
      var ns = V((ts) => {
        ts.f = Object.getOwnPropertySymbols;
      });
      var ss = V((mh, is) => {
        var Wc = ir(), $c = de(), Vc = rs(), Gc = ns(), Hc = Wr(), Jc = $c([].concat);
        is.exports = Wc("Reflect", "ownKeys") || function(n) {
          var i = Vc.f(Hc(n)), a = Gc.f;
          return a ? Jc(i, a(n)) : i;
        };
      });
      var us = V((gh, as) => {
        var os = Se(), Kc = ss(), Qc = Ur(), Yc = Jr();
        as.exports = function(e, n, i) {
          for (var a = Kc(n), o = Yc.f, f = Qc.f, p2 = 0; p2 < a.length; p2++) {
            var h3 = a[p2];
            !os(e, h3) && !(i && os(i, h3)) && o(e, h3, f(n, h3));
          }
        };
      });
      var ls = V((yh, cs) => {
        var Xc = ke(), Zc = ve(), el = /#|\.prototype\./, Ue = function(e, n) {
          var i = tl[rl(e)];
          return i == il ? true : i == nl ? false : Zc(n) ? Xc(n) : !!n;
        }, rl = Ue.normalize = function(e) {
          return String(e).replace(el, ".").toLowerCase();
        }, tl = Ue.data = {}, nl = Ue.NATIVE = "N", il = Ue.POLYFILL = "P";
        cs.exports = Ue;
      });
      var ps = V((wh, fs) => {
        var at = ee(), sl = Ur().f, ol = cr(), al = Li(), ul = or(), cl = us(), ll = ls();
        fs.exports = function(e, n) {
          var i = e.target, a = e.global, o = e.stat, f, p2, h3, g, c, t;
          if (a ? p2 = at : o ? p2 = at[i] || ul(i, {}) : p2 = (at[i] || {}).prototype, p2)
            for (h3 in n) {
              if (c = n[h3], e.noTargetGet ? (t = sl(p2, h3), g = t && t.value) : g = p2[h3], f = ll(a ? h3 : i + (o ? "." : "#") + h3, e.forced), !f && g !== void 0) {
                if (typeof c == typeof g)
                  continue;
                cl(c, g);
              }
              (e.sham || g && g.sham) && ol(c, "sham", true), al(p2, h3, c, e);
            }
        };
      });
      var hs = V(() => {
        var fl = ps(), pl = ee();
        fl({ global: true }, { globalThis: pl });
      });
      var ds = V(() => {
        hs();
      });
      var lp = V((Ph, la) => {
        ds();
        var kt = Object.defineProperty, hl = Object.getOwnPropertyDescriptor, St = Object.getOwnPropertyNames, dl = Object.prototype.hasOwnProperty, Le = (e, n) => function() {
          return e && (n = (0, e[St(e)[0]])(e = 0)), n;
        }, R = (e, n) => function() {
          return n || (0, e[St(e)[0]])((n = { exports: {} }).exports, n), n.exports;
        }, Ot = (e, n) => {
          for (var i in n)
            kt(e, i, { get: n[i], enumerable: true });
        }, vl = (e, n, i, a) => {
          if (n && typeof n == "object" || typeof n == "function")
            for (let o of St(n))
              !dl.call(e, o) && o !== i && kt(e, o, { get: () => n[o], enumerable: !(a = hl(n, o)) || a.enumerable });
          return e;
        }, Tt = (e) => vl(kt({}, "__esModule", { value: true }), e), A = Le({ "<define:process>"() {
        } }), ml = R({ "src/common/parser-create-error.js"(e, n) {
          "use strict";
          A();
          function i(a, o) {
            let f = new SyntaxError(a + " (" + o.start.line + ":" + o.start.column + ")");
            return f.loc = o, f;
          }
          n.exports = i;
        } }), Cs = R({ "src/utils/get-last.js"(e, n) {
          "use strict";
          A();
          var i = (a) => a[a.length - 1];
          n.exports = i;
        } }), Ns = R({ "src/utils/front-matter/parse.js"(e, n) {
          "use strict";
          A();
          var i = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
          function a(o) {
            let f = o.match(i);
            if (!f)
              return { content: o };
            let { startDelimiter: p2, language: h3, value: g = "", endDelimiter: c } = f.groups, t = h3.trim() || "yaml";
            if (p2 === "+++" && (t = "toml"), t !== "yaml" && p2 !== c)
              return { content: o };
            let [r] = f;
            return { frontMatter: { type: "front-matter", lang: t, value: g, startDelimiter: p2, endDelimiter: c, raw: r.replace(/\n$/, "") }, content: r.replace(/[^\n]/g, " ") + o.slice(r.length) };
          }
          n.exports = a;
        } }), js = {};
        Ot(js, { EOL: () => gt, arch: () => gl, cpus: () => Us, default: () => Hs, endianness: () => Ms, freemem: () => Bs, getNetworkInterfaces: () => Gs, hostname: () => Ds, loadavg: () => Ls, networkInterfaces: () => Vs, platform: () => yl, release: () => $s, tmpDir: () => vt, tmpdir: () => mt, totalmem: () => Fs, type: () => Ws, uptime: () => zs });
        function Ms() {
          if (typeof pr > "u") {
            var e = new ArrayBuffer(2), n = new Uint8Array(e), i = new Uint16Array(e);
            if (n[0] = 1, n[1] = 2, i[0] === 258)
              pr = "BE";
            else if (i[0] === 513)
              pr = "LE";
            else
              throw new Error("unable to figure out endianess");
          }
          return pr;
        }
        function Ds() {
          return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
        }
        function Ls() {
          return [];
        }
        function zs() {
          return 0;
        }
        function Bs() {
          return Number.MAX_VALUE;
        }
        function Fs() {
          return Number.MAX_VALUE;
        }
        function Us() {
          return [];
        }
        function Ws() {
          return "Browser";
        }
        function $s() {
          return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
        }
        function Vs() {
        }
        function Gs() {
        }
        function gl() {
          return "javascript";
        }
        function yl() {
          return "browser";
        }
        function vt() {
          return "/tmp";
        }
        var pr, mt, gt, Hs, wl = Le({ "node-modules-polyfills:os"() {
          A(), mt = vt, gt = `
`, Hs = { EOL: gt, tmpdir: mt, tmpDir: vt, networkInterfaces: Vs, getNetworkInterfaces: Gs, release: $s, type: Ws, cpus: Us, totalmem: Fs, freemem: Bs, uptime: zs, loadavg: Ls, hostname: Ds, endianness: Ms };
        } }), _l = R({ "node-modules-polyfills-commonjs:os"(e, n) {
          A();
          var i = (wl(), Tt(js));
          if (i && i.default) {
            n.exports = i.default;
            for (let a in i)
              n.exports[a] = i[a];
          } else
            i && (n.exports = i);
        } }), bl = R({ "node_modules/detect-newline/index.js"(e, n) {
          "use strict";
          A();
          var i = (a) => {
            if (typeof a != "string")
              throw new TypeError("Expected a string");
            let o = a.match(/(?:\r?\n)/g) || [];
            if (o.length === 0)
              return;
            let f = o.filter((h3) => h3 === `\r
`).length, p2 = o.length - f;
            return f > p2 ? `\r
` : `
`;
          };
          n.exports = i, n.exports.graceful = (a) => typeof a == "string" && i(a) || `
`;
        } }), xl = R({ "node_modules/jest-docblock/build/index.js"(e) {
          "use strict";
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = s, e.parse = m2, e.parseWithComments = v, e.print = y, e.strip = l;
          function n() {
            let d = _l();
            return n = function() {
              return d;
            }, d;
          }
          function i() {
            let d = a(bl());
            return i = function() {
              return d;
            }, d;
          }
          function a(d) {
            return d && d.__esModule ? d : { default: d };
          }
          var o = /\*\/$/, f = /^\/\*\*/, p2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, h3 = /(^|\s+)\/\/([^\r\n]*)/g, g = /^(\r?\n)+/, c = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, t = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, r = /(\r?\n|^) *\* ?/g, u = [];
          function s(d) {
            let _ = d.match(p2);
            return _ ? _[0].trimLeft() : "";
          }
          function l(d) {
            let _ = d.match(p2);
            return _ && _[0] ? d.substring(_[0].length) : d;
          }
          function m2(d) {
            return v(d).pragmas;
          }
          function v(d) {
            let _ = (0, i().default)(d) || n().EOL;
            d = d.replace(f, "").replace(o, "").replace(r, "$1");
            let S = "";
            for (; S !== d; )
              S = d, d = d.replace(c, "".concat(_, "$1 $2").concat(_));
            d = d.replace(g, "").trimRight();
            let x = /* @__PURE__ */ Object.create(null), N = d.replace(t, "").replace(g, "").trimRight(), P;
            for (; P = t.exec(d); ) {
              let W = P[2].replace(h3, "");
              typeof x[P[1]] == "string" || Array.isArray(x[P[1]]) ? x[P[1]] = u.concat(x[P[1]], W) : x[P[1]] = W;
            }
            return { comments: N, pragmas: x };
          }
          function y(d) {
            let { comments: _ = "", pragmas: S = {} } = d, x = (0, i().default)(_) || n().EOL, N = "/**", P = " *", W = " */", U = Object.keys(S), H = U.map(($2) => w($2, S[$2])).reduce(($2, B) => $2.concat(B), []).map(($2) => P + " " + $2 + x).join("");
            if (!_) {
              if (U.length === 0)
                return "";
              if (U.length === 1 && !Array.isArray(S[U[0]])) {
                let $2 = S[U[0]];
                return "".concat(N, " ").concat(w(U[0], $2)[0]).concat(W);
              }
            }
            let D = _.split(x).map(($2) => "".concat(P, " ").concat($2)).join(x) + x;
            return N + x + (_ ? D : "") + (_ && U.length ? P + x : "") + H + W;
          }
          function w(d, _) {
            return u.concat(_).map((S) => "@".concat(d, " ").concat(S).trim());
          }
        } }), kl = R({ "src/common/end-of-line.js"(e, n) {
          "use strict";
          A();
          function i(p2) {
            let h3 = p2.indexOf("\r");
            return h3 >= 0 ? p2.charAt(h3 + 1) === `
` ? "crlf" : "cr" : "lf";
          }
          function a(p2) {
            switch (p2) {
              case "cr":
                return "\r";
              case "crlf":
                return `\r
`;
              default:
                return `
`;
            }
          }
          function o(p2, h3) {
            let g;
            switch (h3) {
              case `
`:
                g = /\n/g;
                break;
              case "\r":
                g = /\r/g;
                break;
              case `\r
`:
                g = /\r\n/g;
                break;
              default:
                throw new Error('Unexpected "eol" '.concat(JSON.stringify(h3), "."));
            }
            let c = p2.match(g);
            return c ? c.length : 0;
          }
          function f(p2) {
            return p2.replace(/\r\n?/g, `
`);
          }
          n.exports = { guessEndOfLine: i, convertEndOfLineToChars: a, countEndOfLineChars: o, normalizeEndOfLine: f };
        } }), Sl = R({ "src/language-js/utils/get-shebang.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            if (!a.startsWith("#!"))
              return "";
            let o = a.indexOf(`
`);
            return o === -1 ? a : a.slice(0, o);
          }
          n.exports = i;
        } }), Ol = R({ "src/language-js/pragma.js"(e, n) {
          "use strict";
          A();
          var { parseWithComments: i, strip: a, extract: o, print: f } = xl(), { normalizeEndOfLine: p2 } = kl(), h3 = Sl();
          function g(r) {
            let u = h3(r);
            u && (r = r.slice(u.length + 1));
            let s = o(r), { pragmas: l, comments: m2 } = i(s);
            return { shebang: u, text: r, pragmas: l, comments: m2 };
          }
          function c(r) {
            let u = Object.keys(g(r).pragmas);
            return u.includes("prettier") || u.includes("format");
          }
          function t(r) {
            let { shebang: u, text: s, pragmas: l, comments: m2 } = g(r), v = a(s), y = f({ pragmas: Object.assign({ format: "" }, l), comments: m2.trimStart() });
            return (u ? "".concat(u, `
`) : "") + p2(y) + (v.startsWith(`
`) ? `
` : `

`) + v;
          }
          n.exports = { hasPragma: c, insertPragma: t };
        } }), Tl = R({ "src/language-css/pragma.js"(e, n) {
          "use strict";
          A();
          var i = Ol(), a = Ns();
          function o(p2) {
            return i.hasPragma(a(p2).content);
          }
          function f(p2) {
            let { frontMatter: h3, content: g } = a(p2);
            return (h3 ? h3.raw + `

` : "") + i.insertPragma(g);
          }
          n.exports = { hasPragma: o, insertPragma: f };
        } }), El = R({ "src/utils/text/skip.js"(e, n) {
          "use strict";
          A();
          function i(h3) {
            return (g, c, t) => {
              let r = t && t.backwards;
              if (c === false)
                return false;
              let { length: u } = g, s = c;
              for (; s >= 0 && s < u; ) {
                let l = g.charAt(s);
                if (h3 instanceof RegExp) {
                  if (!h3.test(l))
                    return s;
                } else if (!h3.includes(l))
                  return s;
                r ? s-- : s++;
              }
              return s === -1 || s === u ? s : false;
            };
          }
          var a = i(/\s/), o = i(" 	"), f = i(",; 	"), p2 = i(/[^\n\r]/);
          n.exports = { skipWhitespace: a, skipSpaces: o, skipToLineEnd: f, skipEverythingButNewLine: p2 };
        } }), ql = R({ "src/utils/line-column-to-index.js"(e, n) {
          "use strict";
          A(), n.exports = function(i, a) {
            let o = 0;
            for (let f = 0; f < i.line - 1; ++f)
              o = a.indexOf(`
`, o) + 1;
            return o + i.column;
          };
        } }), Js = R({ "src/language-css/loc.js"(e, n) {
          "use strict";
          A();
          var { skipEverythingButNewLine: i } = El(), a = Cs(), o = ql();
          function f(s, l) {
            return typeof s.sourceIndex == "number" ? s.sourceIndex : s.source ? o(s.source.start, l) - 1 : null;
          }
          function p2(s, l) {
            if (s.type === "css-comment" && s.inline)
              return i(l, s.source.startOffset);
            let m2 = s.nodes && a(s.nodes);
            return m2 && s.source && !s.source.end && (s = m2), s.source && s.source.end ? o(s.source.end, l) : null;
          }
          function h3(s, l) {
            s.source && (s.source.startOffset = f(s, l), s.source.endOffset = p2(s, l));
            for (let m2 in s) {
              let v = s[m2];
              m2 === "source" || !v || typeof v != "object" || (v.type === "value-root" || v.type === "value-unknown" ? g(v, c(s), v.text || v.value) : h3(v, l));
            }
          }
          function g(s, l, m2) {
            s.source && (s.source.startOffset = f(s, m2) + l, s.source.endOffset = p2(s, m2) + l);
            for (let v in s) {
              let y = s[v];
              v === "source" || !y || typeof y != "object" || g(y, l, m2);
            }
          }
          function c(s) {
            let l = s.source.startOffset;
            return typeof s.prop == "string" && (l += s.prop.length), s.type === "css-atrule" && typeof s.name == "string" && (l += 1 + s.name.length + s.raws.afterName.match(/^\s*:?\s*/)[0].length), s.type !== "css-atrule" && s.raws && typeof s.raws.between == "string" && (l += s.raws.between.length), l;
          }
          function t(s) {
            let l = "initial", m2 = "initial", v, y = false, w = [];
            for (let d = 0; d < s.length; d++) {
              let _ = s[d];
              switch (l) {
                case "initial":
                  if (_ === "'") {
                    l = "single-quotes";
                    continue;
                  }
                  if (_ === '"') {
                    l = "double-quotes";
                    continue;
                  }
                  if ((_ === "u" || _ === "U") && s.slice(d, d + 4).toLowerCase() === "url(") {
                    l = "url", d += 3;
                    continue;
                  }
                  if (_ === "*" && s[d - 1] === "/") {
                    l = "comment-block";
                    continue;
                  }
                  if (_ === "/" && s[d - 1] === "/") {
                    l = "comment-inline", v = d - 1;
                    continue;
                  }
                  continue;
                case "single-quotes":
                  if (_ === "'" && s[d - 1] !== "\\" && (l = m2, m2 = "initial"), _ === `
` || _ === "\r")
                    return s;
                  continue;
                case "double-quotes":
                  if (_ === '"' && s[d - 1] !== "\\" && (l = m2, m2 = "initial"), _ === `
` || _ === "\r")
                    return s;
                  continue;
                case "url":
                  if (_ === ")" && (l = "initial"), _ === `
` || _ === "\r")
                    return s;
                  if (_ === "'") {
                    l = "single-quotes", m2 = "url";
                    continue;
                  }
                  if (_ === '"') {
                    l = "double-quotes", m2 = "url";
                    continue;
                  }
                  continue;
                case "comment-block":
                  _ === "/" && s[d - 1] === "*" && (l = "initial");
                  continue;
                case "comment-inline":
                  (_ === '"' || _ === "'" || _ === "*") && (y = true), (_ === `
` || _ === "\r") && (y && w.push([v, d]), l = "initial", y = false);
                  continue;
              }
            }
            for (let [d, _] of w)
              s = s.slice(0, d) + s.slice(d, _).replace(/["'*]/g, " ") + s.slice(_);
            return s;
          }
          function r(s) {
            return s.source.startOffset;
          }
          function u(s) {
            return s.source.endOffset;
          }
          n.exports = { locStart: r, locEnd: u, calculateLoc: h3, replaceQuotesInInlineComments: t };
        } }), Al = R({ "src/utils/is-non-empty-array.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            return Array.isArray(a) && a.length > 0;
          }
          n.exports = i;
        } }), Pl = R({ "src/language-css/utils/has-scss-interpolation.js"(e, n) {
          "use strict";
          A();
          var i = Al();
          function a(o) {
            if (i(o)) {
              for (let f = o.length - 1; f > 0; f--)
                if (o[f].type === "word" && o[f].value === "{" && o[f - 1].type === "word" && o[f - 1].value.endsWith("#"))
                  return true;
            }
            return false;
          }
          n.exports = a;
        } }), Rl = R({ "src/language-css/utils/has-string-or-function.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            return a.some((o) => o.type === "string" || o.type === "func");
          }
          n.exports = i;
        } }), Il = R({ "src/language-css/utils/is-less-parser.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            return a.parser === "css" || a.parser === "less";
          }
          n.exports = i;
        } }), Cl = R({ "src/language-css/utils/is-scss.js"(e, n) {
          "use strict";
          A();
          function i(a, o) {
            return a === "less" || a === "scss" ? a === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(o);
          }
          n.exports = i;
        } }), Nl = R({ "src/language-css/utils/is-scss-nested-property-node.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            return a.selector ? a.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*\n/, "").trim().endsWith(":") : false;
          }
          n.exports = i;
        } }), jl = R({ "src/language-css/utils/is-scss-variable.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            return Boolean((a == null ? void 0 : a.type) === "word" && a.value.startsWith("$"));
          }
          n.exports = i;
        } }), Ml = R({ "src/language-css/utils/stringify-node.js"(e, n) {
          "use strict";
          A();
          function i(a) {
            var o, f, p2;
            if (a.groups) {
              var h3, g, c;
              let y = ((h3 = a.open) === null || h3 === void 0 ? void 0 : h3.value) || "", w = a.groups.map((_) => i(_)).join(((g = a.groups[0]) === null || g === void 0 ? void 0 : g.type) === "comma_group" ? "," : ""), d = ((c = a.close) === null || c === void 0 ? void 0 : c.value) || "";
              return y + w + d;
            }
            let t = ((o = a.raws) === null || o === void 0 ? void 0 : o.before) || "", r = ((f = a.raws) === null || f === void 0 ? void 0 : f.quote) || "", u = a.type === "atword" ? "@" : "", s = a.value || "", l = a.unit || "", m2 = a.group ? i(a.group) : "", v = ((p2 = a.raws) === null || p2 === void 0 ? void 0 : p2.after) || "";
            return t + r + u + s + r + l + m2 + v;
          }
          n.exports = i;
        } }), Dl = R({ "src/language-css/utils/is-module-rule-name.js"(e, n) {
          "use strict";
          A();
          var i = /* @__PURE__ */ new Set(["import", "use", "forward"]);
          function a(o) {
            return i.has(o);
          }
          n.exports = a;
        } }), we = R({ "node_modules/postcss-values-parser/lib/node.js"(e, n) {
          "use strict";
          A();
          var i = function(a, o) {
            let f = new a.constructor();
            for (let p2 in a) {
              if (!a.hasOwnProperty(p2))
                continue;
              let h3 = a[p2], g = typeof h3;
              p2 === "parent" && g === "object" ? o && (f[p2] = o) : p2 === "source" ? f[p2] = h3 : h3 instanceof Array ? f[p2] = h3.map((c) => i(c, f)) : p2 !== "before" && p2 !== "after" && p2 !== "between" && p2 !== "semicolon" && (g === "object" && h3 !== null && (h3 = i(h3)), f[p2] = h3);
            }
            return f;
          };
          n.exports = class {
            constructor(o) {
              o = o || {}, this.raws = { before: "", after: "" };
              for (let f in o)
                this[f] = o[f];
            }
            remove() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }
            toString() {
              return [this.raws.before, String(this.value), this.raws.after].join("");
            }
            clone(o) {
              o = o || {};
              let f = i(this);
              for (let p2 in o)
                f[p2] = o[p2];
              return f;
            }
            cloneBefore(o) {
              o = o || {};
              let f = this.clone(o);
              return this.parent.insertBefore(this, f), f;
            }
            cloneAfter(o) {
              o = o || {};
              let f = this.clone(o);
              return this.parent.insertAfter(this, f), f;
            }
            replaceWith() {
              let o = Array.prototype.slice.call(arguments);
              if (this.parent) {
                for (let f of o)
                  this.parent.insertBefore(this, f);
                this.remove();
              }
              return this;
            }
            moveTo(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.append(this), this;
            }
            moveBefore(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertBefore(o, this), this;
            }
            moveAfter(o) {
              return this.cleanRaws(this.root() === o.root()), this.remove(), o.parent.insertAfter(o, this), this;
            }
            next() {
              let o = this.parent.index(this);
              return this.parent.nodes[o + 1];
            }
            prev() {
              let o = this.parent.index(this);
              return this.parent.nodes[o - 1];
            }
            toJSON() {
              let o = {};
              for (let f in this) {
                if (!this.hasOwnProperty(f) || f === "parent")
                  continue;
                let p2 = this[f];
                p2 instanceof Array ? o[f] = p2.map((h3) => typeof h3 == "object" && h3.toJSON ? h3.toJSON() : h3) : typeof p2 == "object" && p2.toJSON ? o[f] = p2.toJSON() : o[f] = p2;
              }
              return o;
            }
            root() {
              let o = this;
              for (; o.parent; )
                o = o.parent;
              return o;
            }
            cleanRaws(o) {
              delete this.raws.before, delete this.raws.after, o || delete this.raws.between;
            }
            positionInside(o) {
              let f = this.toString(), p2 = this.source.start.column, h3 = this.source.start.line;
              for (let g = 0; g < o; g++)
                f[g] === `
` ? (p2 = 1, h3 += 1) : p2 += 1;
              return { line: h3, column: p2 };
            }
            positionBy(o) {
              let f = this.source.start;
              if (Object(o).index)
                f = this.positionInside(o.index);
              else if (Object(o).word) {
                let p2 = this.toString().indexOf(o.word);
                p2 !== -1 && (f = this.positionInside(p2));
              }
              return f;
            }
          };
        } }), ue = R({ "node_modules/postcss-values-parser/lib/container.js"(e, n) {
          "use strict";
          A();
          var i = we(), a = class extends i {
            constructor(o) {
              super(o), this.nodes || (this.nodes = []);
            }
            push(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            each(o) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              let f = this.lastEach, p2, h3;
              if (this.indexes[f] = 0, !!this.nodes) {
                for (; this.indexes[f] < this.nodes.length && (p2 = this.indexes[f], h3 = o(this.nodes[p2], p2), h3 !== false); )
                  this.indexes[f] += 1;
                return delete this.indexes[f], h3;
              }
            }
            walk(o) {
              return this.each((f, p2) => {
                let h3 = o(f, p2);
                return h3 !== false && f.walk && (h3 = f.walk(o)), h3;
              });
            }
            walkType(o, f) {
              if (!o || !f)
                throw new Error("Parameters {type} and {callback} are required.");
              let p2 = typeof o == "function";
              return this.walk((h3, g) => {
                if (p2 && h3 instanceof o || !p2 && h3.type === o)
                  return f.call(this, h3, g);
              });
            }
            append(o) {
              return o.parent = this, this.nodes.push(o), this;
            }
            prepend(o) {
              return o.parent = this, this.nodes.unshift(o), this;
            }
            cleanRaws(o) {
              if (super.cleanRaws(o), this.nodes)
                for (let f of this.nodes)
                  f.cleanRaws(o);
            }
            insertAfter(o, f) {
              let p2 = this.index(o), h3;
              this.nodes.splice(p2 + 1, 0, f);
              for (let g in this.indexes)
                h3 = this.indexes[g], p2 <= h3 && (this.indexes[g] = h3 + this.nodes.length);
              return this;
            }
            insertBefore(o, f) {
              let p2 = this.index(o), h3;
              this.nodes.splice(p2, 0, f);
              for (let g in this.indexes)
                h3 = this.indexes[g], p2 <= h3 && (this.indexes[g] = h3 + this.nodes.length);
              return this;
            }
            removeChild(o) {
              o = this.index(o), this.nodes[o].parent = void 0, this.nodes.splice(o, 1);
              let f;
              for (let p2 in this.indexes)
                f = this.indexes[p2], f >= o && (this.indexes[p2] = f - 1);
              return this;
            }
            removeAll() {
              for (let o of this.nodes)
                o.parent = void 0;
              return this.nodes = [], this;
            }
            every(o) {
              return this.nodes.every(o);
            }
            some(o) {
              return this.nodes.some(o);
            }
            index(o) {
              return typeof o == "number" ? o : this.nodes.indexOf(o);
            }
            get first() {
              if (!!this.nodes)
                return this.nodes[0];
            }
            get last() {
              if (!!this.nodes)
                return this.nodes[this.nodes.length - 1];
            }
            toString() {
              let o = this.nodes.map(String).join("");
              return this.value && (o = this.value + o), this.raws.before && (o = this.raws.before + o), this.raws.after && (o += this.raws.after), o;
            }
          };
          a.registerWalker = (o) => {
            let f = "walk" + o.name;
            f.lastIndexOf("s") !== f.length - 1 && (f += "s"), !a.prototype[f] && (a.prototype[f] = function(p2) {
              return this.walkType(o, p2);
            });
          }, n.exports = a;
        } }), Ll = R({ "node_modules/postcss-values-parser/lib/root.js"(e, n) {
          "use strict";
          A();
          var i = ue();
          n.exports = class extends i {
            constructor(o) {
              super(o), this.type = "root";
            }
          };
        } }), Ks = R({ "node_modules/postcss-values-parser/lib/value.js"(e, n) {
          "use strict";
          A();
          var i = ue();
          n.exports = class extends i {
            constructor(o) {
              super(o), this.type = "value", this.unbalanced = 0;
            }
          };
        } }), Qs = R({ "node_modules/postcss-values-parser/lib/atword.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = class extends i {
            constructor(o) {
              super(o), this.type = "atword";
            }
            toString() {
              let o = this.quoted ? this.raws.quote : "";
              return [this.raws.before, "@", String.prototype.toString.call(this.value), this.raws.after].join("");
            }
          };
          i.registerWalker(a), n.exports = a;
        } }), Ys = R({ "node_modules/postcss-values-parser/lib/colon.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "colon";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), Xs = R({ "node_modules/postcss-values-parser/lib/comma.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "comma";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), Zs = R({ "node_modules/postcss-values-parser/lib/comment.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "comment", this.inline = Object(f).inline || false;
            }
            toString() {
              return [this.raws.before, this.inline ? "//" : "/*", String(this.value), this.inline ? "" : "*/", this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), eo = R({ "node_modules/postcss-values-parser/lib/function.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = class extends i {
            constructor(o) {
              super(o), this.type = "func", this.unbalanced = -1;
            }
          };
          i.registerWalker(a), n.exports = a;
        } }), ro = R({ "node_modules/postcss-values-parser/lib/number.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "number", this.unit = Object(f).unit || "";
            }
            toString() {
              return [this.raws.before, String(this.value), this.unit, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), to = R({ "node_modules/postcss-values-parser/lib/operator.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "operator";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), no = R({ "node_modules/postcss-values-parser/lib/paren.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "paren", this.parenType = "";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), io = R({ "node_modules/postcss-values-parser/lib/string.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "string";
            }
            toString() {
              let f = this.quoted ? this.raws.quote : "";
              return [this.raws.before, f, this.value + "", f, this.raws.after].join("");
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), so = R({ "node_modules/postcss-values-parser/lib/word.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "word";
            }
          };
          i.registerWalker(o), n.exports = o;
        } }), oo = R({ "node_modules/postcss-values-parser/lib/unicode-range.js"(e, n) {
          "use strict";
          A();
          var i = ue(), a = we(), o = class extends a {
            constructor(f) {
              super(f), this.type = "unicode-range";
            }
          };
          i.registerWalker(o), n.exports = o;
        } });
        function ao() {
          throw new Error("setTimeout has not been defined");
        }
        function uo() {
          throw new Error("clearTimeout has not been defined");
        }
        function co(e) {
          if (be === setTimeout)
            return setTimeout(e, 0);
          if ((be === ao || !be) && setTimeout)
            return be = setTimeout, setTimeout(e, 0);
          try {
            return be(e, 0);
          } catch {
            try {
              return be.call(null, e, 0);
            } catch {
              return be.call(this, e, 0);
            }
          }
        }
        function zl(e) {
          if (xe === clearTimeout)
            return clearTimeout(e);
          if ((xe === uo || !xe) && clearTimeout)
            return xe = clearTimeout, clearTimeout(e);
          try {
            return xe(e);
          } catch {
            try {
              return xe.call(null, e);
            } catch {
              return xe.call(this, e);
            }
          }
        }
        function Bl() {
          !Ne || !Ce || (Ne = false, Ce.length ? me = Ce.concat(me) : $e = -1, me.length && lo());
        }
        function lo() {
          if (!Ne) {
            var e = co(Bl);
            Ne = true;
            for (var n = me.length; n; ) {
              for (Ce = me, me = []; ++$e < n; )
                Ce && Ce[$e].run();
              $e = -1, n = me.length;
            }
            Ce = null, Ne = false, zl(e);
          }
        }
        function Fl(e) {
          var n = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++)
              n[i - 1] = arguments[i];
          me.push(new fo(e, n)), me.length === 1 && !Ne && co(lo);
        }
        function fo(e, n) {
          this.fun = e, this.array = n;
        }
        function Ae() {
        }
        function Ul(e) {
          throw new Error("process.binding is not supported");
        }
        function Wl() {
          return "/";
        }
        function $l(e) {
          throw new Error("process.chdir is not supported");
        }
        function Vl() {
          return 0;
        }
        function Gl(e) {
          var n = po.call(Re) * 1e-3, i = Math.floor(n), a = Math.floor(n % 1 * 1e9);
          return e && (i = i - e[0], a = a - e[1], a < 0 && (i--, a += 1e9)), [i, a];
        }
        function Hl() {
          var e = new Date(), n = e - ho;
          return n / 1e3;
        }
        var be, xe, me, Ne, Ce, $e, vs, ms, gs, ys, ws2, _s, bs, xs, ks, Ss, Os, Ts, Es, qs, As, Ps, Re, po, ho, Rs, Ve, Jl = Le({ "node-modules-polyfills:process"() {
          A(), be = ao, xe = uo, typeof globalThis.setTimeout == "function" && (be = setTimeout), typeof globalThis.clearTimeout == "function" && (xe = clearTimeout), me = [], Ne = false, $e = -1, fo.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, vs = "browser", ms = "browser", gs = true, ys = {}, ws2 = [], _s = "", bs = {}, xs = {}, ks = {}, Ss = Ae, Os = Ae, Ts = Ae, Es = Ae, qs = Ae, As = Ae, Ps = Ae, Re = globalThis.performance || {}, po = Re.now || Re.mozNow || Re.msNow || Re.oNow || Re.webkitNow || function() {
            return new Date().getTime();
          }, ho = new Date(), Rs = { nextTick: Fl, title: vs, browser: gs, env: ys, argv: ws2, version: _s, versions: bs, on: Ss, addListener: Os, once: Ts, off: Es, removeListener: qs, removeAllListeners: As, emit: Ps, binding: Ul, cwd: Wl, chdir: $l, umask: Vl, hrtime: Gl, platform: ms, release: xs, config: ks, uptime: Hl }, Ve = Rs;
        } }), ut, Et, Kl = Le({ "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
          A(), typeof Object.create == "function" ? ut = function(n, i) {
            n.super_ = i, n.prototype = Object.create(i.prototype, { constructor: { value: n, enumerable: false, writable: true, configurable: true } });
          } : ut = function(n, i) {
            n.super_ = i;
            var a = function() {
            };
            a.prototype = i.prototype, n.prototype = new a(), n.prototype.constructor = n;
          }, Et = ut;
        } }), vo = {};
        Ot(vo, { _extend: () => It, debuglog: () => mo, default: () => Oo, deprecate: () => qt, format: () => gr, inherits: () => Et, inspect: () => ye, isArray: () => At, isBoolean: () => yr, isBuffer: () => _o, isDate: () => vr, isError: () => He, isFunction: () => Je, isNull: () => Ke, isNullOrUndefined: () => go, isNumber: () => Pt, isObject: () => je, isPrimitive: () => wo, isRegExp: () => Ge, isString: () => Qe, isSymbol: () => yo, isUndefined: () => ge, log: () => bo });
        function gr(e) {
          if (!Qe(e)) {
            for (var n = [], i = 0; i < arguments.length; i++)
              n.push(ye(arguments[i]));
            return n.join(" ");
          }
          for (var i = 1, a = arguments, o = a.length, f = String(e).replace(ko, function(h3) {
            if (h3 === "%%")
              return "%";
            if (i >= o)
              return h3;
            switch (h3) {
              case "%s":
                return String(a[i++]);
              case "%d":
                return Number(a[i++]);
              case "%j":
                try {
                  return JSON.stringify(a[i++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return h3;
            }
          }), p2 = a[i]; i < o; p2 = a[++i])
            Ke(p2) || !je(p2) ? f += " " + p2 : f += " " + ye(p2);
          return f;
        }
        function qt(e, n) {
          if (ge(globalThis.process))
            return function() {
              return qt(e, n).apply(this, arguments);
            };
          if (Ve.noDeprecation === true)
            return e;
          var i = false;
          function a() {
            if (!i) {
              if (Ve.throwDeprecation)
                throw new Error(n);
              Ve.traceDeprecation ? console.trace(n) : console.error(n), i = true;
            }
            return e.apply(this, arguments);
          }
          return a;
        }
        function mo(e) {
          if (ge(ft) && (ft = Ve.env.NODE_DEBUG || ""), e = e.toUpperCase(), !We[e])
            if (new RegExp("\\b" + e + "\\b", "i").test(ft)) {
              var n = 0;
              We[e] = function() {
                var i = gr.apply(null, arguments);
                console.error("%s %d: %s", e, n, i);
              };
            } else
              We[e] = function() {
              };
          return We[e];
        }
        function ye(e, n) {
          var i = { seen: [], stylize: Yl };
          return arguments.length >= 3 && (i.depth = arguments[2]), arguments.length >= 4 && (i.colors = arguments[3]), yr(n) ? i.showHidden = n : n && It(i, n), ge(i.showHidden) && (i.showHidden = false), ge(i.depth) && (i.depth = 2), ge(i.colors) && (i.colors = false), ge(i.customInspect) && (i.customInspect = true), i.colors && (i.stylize = Ql), dr(i, e, i.depth);
        }
        function Ql(e, n) {
          var i = ye.styles[n];
          return i ? "\x1B[" + ye.colors[i][0] + "m" + e + "\x1B[" + ye.colors[i][1] + "m" : e;
        }
        function Yl(e, n) {
          return e;
        }
        function Xl(e) {
          var n = {};
          return e.forEach(function(i, a) {
            n[i] = true;
          }), n;
        }
        function dr(e, n, i) {
          if (e.customInspect && n && Je(n.inspect) && n.inspect !== ye && !(n.constructor && n.constructor.prototype === n)) {
            var a = n.inspect(i, e);
            return Qe(a) || (a = dr(e, a, i)), a;
          }
          var o = Zl(e, n);
          if (o)
            return o;
          var f = Object.keys(n), p2 = Xl(f);
          if (e.showHidden && (f = Object.getOwnPropertyNames(n)), He(n) && (f.indexOf("message") >= 0 || f.indexOf("description") >= 0))
            return ct(n);
          if (f.length === 0) {
            if (Je(n)) {
              var h3 = n.name ? ": " + n.name : "";
              return e.stylize("[Function" + h3 + "]", "special");
            }
            if (Ge(n))
              return e.stylize(RegExp.prototype.toString.call(n), "regexp");
            if (vr(n))
              return e.stylize(Date.prototype.toString.call(n), "date");
            if (He(n))
              return ct(n);
          }
          var g = "", c = false, t = ["{", "}"];
          if (At(n) && (c = true, t = ["[", "]"]), Je(n)) {
            var r = n.name ? ": " + n.name : "";
            g = " [Function" + r + "]";
          }
          if (Ge(n) && (g = " " + RegExp.prototype.toString.call(n)), vr(n) && (g = " " + Date.prototype.toUTCString.call(n)), He(n) && (g = " " + ct(n)), f.length === 0 && (!c || n.length == 0))
            return t[0] + g + t[1];
          if (i < 0)
            return Ge(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special");
          e.seen.push(n);
          var u;
          return c ? u = ef(e, n, i, p2, f) : u = f.map(function(s) {
            return yt(e, n, i, p2, s, c);
          }), e.seen.pop(), rf(u, g, t);
        }
        function Zl(e, n) {
          if (ge(n))
            return e.stylize("undefined", "undefined");
          if (Qe(n)) {
            var i = "'" + JSON.stringify(n).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return e.stylize(i, "string");
          }
          if (Pt(n))
            return e.stylize("" + n, "number");
          if (yr(n))
            return e.stylize("" + n, "boolean");
          if (Ke(n))
            return e.stylize("null", "null");
        }
        function ct(e) {
          return "[" + Error.prototype.toString.call(e) + "]";
        }
        function ef(e, n, i, a, o) {
          for (var f = [], p2 = 0, h3 = n.length; p2 < h3; ++p2)
            xo(n, String(p2)) ? f.push(yt(e, n, i, a, String(p2), true)) : f.push("");
          return o.forEach(function(g) {
            g.match(/^\d+$/) || f.push(yt(e, n, i, a, g, true));
          }), f;
        }
        function yt(e, n, i, a, o, f) {
          var p2, h3, g;
          if (g = Object.getOwnPropertyDescriptor(n, o) || { value: n[o] }, g.get ? g.set ? h3 = e.stylize("[Getter/Setter]", "special") : h3 = e.stylize("[Getter]", "special") : g.set && (h3 = e.stylize("[Setter]", "special")), xo(a, o) || (p2 = "[" + o + "]"), h3 || (e.seen.indexOf(g.value) < 0 ? (Ke(i) ? h3 = dr(e, g.value, null) : h3 = dr(e, g.value, i - 1), h3.indexOf(`
`) > -1 && (f ? h3 = h3.split(`
`).map(function(c) {
            return "  " + c;
          }).join(`
`).substr(2) : h3 = `
` + h3.split(`
`).map(function(c) {
            return "   " + c;
          }).join(`
`))) : h3 = e.stylize("[Circular]", "special")), ge(p2)) {
            if (f && o.match(/^\d+$/))
              return h3;
            p2 = JSON.stringify("" + o), p2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (p2 = p2.substr(1, p2.length - 2), p2 = e.stylize(p2, "name")) : (p2 = p2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), p2 = e.stylize(p2, "string"));
          }
          return p2 + ": " + h3;
        }
        function rf(e, n, i) {
          var a = 0, o = e.reduce(function(f, p2) {
            return a++, p2.indexOf(`
`) >= 0 && a++, f + p2.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          return o > 60 ? i[0] + (n === "" ? "" : n + `
 `) + " " + e.join(`,
  `) + " " + i[1] : i[0] + n + " " + e.join(", ") + " " + i[1];
        }
        function At(e) {
          return Array.isArray(e);
        }
        function yr(e) {
          return typeof e == "boolean";
        }
        function Ke(e) {
          return e === null;
        }
        function go(e) {
          return e == null;
        }
        function Pt(e) {
          return typeof e == "number";
        }
        function Qe(e) {
          return typeof e == "string";
        }
        function yo(e) {
          return typeof e == "symbol";
        }
        function ge(e) {
          return e === void 0;
        }
        function Ge(e) {
          return je(e) && Rt(e) === "[object RegExp]";
        }
        function je(e) {
          return typeof e == "object" && e !== null;
        }
        function vr(e) {
          return je(e) && Rt(e) === "[object Date]";
        }
        function He(e) {
          return je(e) && (Rt(e) === "[object Error]" || e instanceof Error);
        }
        function Je(e) {
          return typeof e == "function";
        }
        function wo(e) {
          return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e > "u";
        }
        function _o(e) {
          return Buffer.isBuffer(e);
        }
        function Rt(e) {
          return Object.prototype.toString.call(e);
        }
        function lt(e) {
          return e < 10 ? "0" + e.toString(10) : e.toString(10);
        }
        function tf() {
          var e = new Date(), n = [lt(e.getHours()), lt(e.getMinutes()), lt(e.getSeconds())].join(":");
          return [e.getDate(), So[e.getMonth()], n].join(" ");
        }
        function bo() {
          console.log("%s - %s", tf(), gr.apply(null, arguments));
        }
        function It(e, n) {
          if (!n || !je(n))
            return e;
          for (var i = Object.keys(n), a = i.length; a--; )
            e[i[a]] = n[i[a]];
          return e;
        }
        function xo(e, n) {
          return Object.prototype.hasOwnProperty.call(e, n);
        }
        var ko, We, ft, So, Oo, nf = Le({ "node-modules-polyfills:util"() {
          A(), Jl(), Kl(), ko = /%[sdj%]/g, We = {}, ye.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, ye.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, So = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Oo = { inherits: Et, _extend: It, log: bo, isBuffer: _o, isPrimitive: wo, isFunction: Je, isError: He, isDate: vr, isObject: je, isRegExp: Ge, isUndefined: ge, isSymbol: yo, isString: Qe, isNumber: Pt, isNullOrUndefined: go, isNull: Ke, isBoolean: yr, isArray: At, inspect: ye, deprecate: qt, format: gr, debuglog: mo };
        } }), sf = R({ "node-modules-polyfills-commonjs:util"(e, n) {
          A();
          var i = (nf(), Tt(vo));
          if (i && i.default) {
            n.exports = i.default;
            for (let a in i)
              n.exports[a] = i[a];
          } else
            i && (n.exports = i);
        } }), of = R({ "node_modules/postcss-values-parser/lib/errors/TokenizeError.js"(e, n) {
          "use strict";
          A();
          var i = class extends Error {
            constructor(a) {
              super(a), this.name = this.constructor.name, this.message = a || "An error ocurred while tokzenizing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(a).stack;
            }
          };
          n.exports = i;
        } }), af = R({ "node_modules/postcss-values-parser/lib/tokenize.js"(e, n) {
          "use strict";
          A();
          var i = "{".charCodeAt(0), a = "}".charCodeAt(0), o = "(".charCodeAt(0), f = ")".charCodeAt(0), p2 = "'".charCodeAt(0), h3 = '"'.charCodeAt(0), g = "\\".charCodeAt(0), c = "/".charCodeAt(0), t = ".".charCodeAt(0), r = ",".charCodeAt(0), u = ":".charCodeAt(0), s = "*".charCodeAt(0), l = "-".charCodeAt(0), m2 = "+".charCodeAt(0), v = "#".charCodeAt(0), y = `
`.charCodeAt(0), w = " ".charCodeAt(0), d = "\f".charCodeAt(0), _ = "	".charCodeAt(0), S = "\r".charCodeAt(0), x = "@".charCodeAt(0), N = "e".charCodeAt(0), P = "E".charCodeAt(0), W = "0".charCodeAt(0), U = "9".charCodeAt(0), H = "u".charCodeAt(0), D = "U".charCodeAt(0), $2 = /[ \n\t\r\{\(\)'"\\;,/]/g, B = /[ \n\t\r\(\)\{\}\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g, O = /[ \n\t\r\(\)\{\}\*:;@!&'"\-\+\|~>,\[\]\\]|\//g, j = /^[a-z0-9]/i, C = /^[a-f0-9?\-]/i, I = sf(), X = of();
          n.exports = function(Q, K) {
            K = K || {};
            let J = [], M = Q.valueOf(), Y = M.length, G = -1, E = 1, k = 0, b = 0, L = null, q, T, F, z, re, ne, ce, fe, te, ie, ae, se;
            function le(Ze) {
              let _e = I.format("Unclosed %s at line: %d, column: %d, token: %d", Ze, E, k - G, k);
              throw new X(_e);
            }
            function pe() {
              let Ze = I.format("Syntax error at line: %d, column: %d, token: %d", E, k - G, k);
              throw new X(Ze);
            }
            for (; k < Y; ) {
              switch (q = M.charCodeAt(k), q === y && (G = k, E += 1), q) {
                case y:
                case w:
                case _:
                case S:
                case d:
                  T = k;
                  do
                    T += 1, q = M.charCodeAt(T), q === y && (G = T, E += 1);
                  while (q === w || q === y || q === _ || q === S || q === d);
                  J.push(["space", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  break;
                case u:
                  T = k + 1, J.push(["colon", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  break;
                case r:
                  T = k + 1, J.push(["comma", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  break;
                case i:
                  J.push(["{", "{", E, k - G, E, T - G, k]);
                  break;
                case a:
                  J.push(["}", "}", E, k - G, E, T - G, k]);
                  break;
                case o:
                  b++, L = !L && b === 1 && J.length > 0 && J[J.length - 1][0] === "word" && J[J.length - 1][1] === "url", J.push(["(", "(", E, k - G, E, T - G, k]);
                  break;
                case f:
                  b--, L = L && b > 0, J.push([")", ")", E, k - G, E, T - G, k]);
                  break;
                case p2:
                case h3:
                  F = q === p2 ? "'" : '"', T = k;
                  do
                    for (ie = false, T = M.indexOf(F, T + 1), T === -1 && le("quote", F), ae = T; M.charCodeAt(ae - 1) === g; )
                      ae -= 1, ie = !ie;
                  while (ie);
                  J.push(["string", M.slice(k, T + 1), E, k - G, E, T - G, k]), k = T;
                  break;
                case x:
                  $2.lastIndex = k + 1, $2.test(M), $2.lastIndex === 0 ? T = M.length - 1 : T = $2.lastIndex - 2, J.push(["atword", M.slice(k, T + 1), E, k - G, E, T - G, k]), k = T;
                  break;
                case g:
                  T = k, q = M.charCodeAt(T + 1), ce && q !== c && q !== w && q !== y && q !== _ && q !== S && q !== d && (T += 1), J.push(["word", M.slice(k, T + 1), E, k - G, E, T - G, k]), k = T;
                  break;
                case m2:
                case l:
                case s:
                  T = k + 1, se = M.slice(k + 1, T + 1);
                  let Ze = M.slice(k - 1, k);
                  if (q === l && se.charCodeAt(0) === l) {
                    T++, J.push(["word", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                    break;
                  }
                  J.push(["operator", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  break;
                default:
                  if (q === c && (M.charCodeAt(k + 1) === s || K.loose && !L && M.charCodeAt(k + 1) === c)) {
                    if (M.charCodeAt(k + 1) === s)
                      T = M.indexOf("*/", k + 2) + 1, T === 0 && le("comment", "*/");
                    else {
                      let Be = M.indexOf(`
`, k + 2);
                      T = Be !== -1 ? Be - 1 : Y;
                    }
                    ne = M.slice(k, T + 1), z = ne.split(`
`), re = z.length - 1, re > 0 ? (fe = E + re, te = T - z[re].length) : (fe = E, te = G), J.push(["comment", ne, E, k - G, fe, T - te, k]), G = te, E = fe, k = T;
                  } else if (q === v && !j.test(M.slice(k + 1, k + 2)))
                    T = k + 1, J.push(["#", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  else if ((q === H || q === D) && M.charCodeAt(k + 1) === m2) {
                    T = k + 2;
                    do
                      T += 1, q = M.charCodeAt(T);
                    while (T < Y && C.test(M.slice(T, T + 1)));
                    J.push(["unicoderange", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  } else if (q === c)
                    T = k + 1, J.push(["operator", M.slice(k, T), E, k - G, E, T - G, k]), k = T - 1;
                  else {
                    let _e = B;
                    if (q >= W && q <= U && (_e = O), _e.lastIndex = k + 1, _e.test(M), _e.lastIndex === 0 ? T = M.length - 1 : T = _e.lastIndex - 2, _e === O || q === t) {
                      let Be = M.charCodeAt(T), Bt = M.charCodeAt(T + 1), Ft = M.charCodeAt(T + 2);
                      (Be === N || Be === P) && (Bt === l || Bt === m2) && Ft >= W && Ft <= U && (O.lastIndex = T + 2, O.test(M), O.lastIndex === 0 ? T = M.length - 1 : T = O.lastIndex - 2);
                    }
                    J.push(["word", M.slice(k, T + 1), E, k - G, E, T - G, k]), k = T;
                  }
                  break;
              }
              k++;
            }
            return J;
          };
        } }), To = R({ "node_modules/flatten/index.js"(e, n) {
          A(), n.exports = function(a, o) {
            if (o = typeof o == "number" ? o : 1 / 0, !o)
              return Array.isArray(a) ? a.map(function(p2) {
                return p2;
              }) : a;
            return f(a, 1);
            function f(p2, h3) {
              return p2.reduce(function(g, c) {
                return Array.isArray(c) && h3 < o ? g.concat(f(c, h3 + 1)) : g.concat(c);
              }, []);
            }
          };
        } }), Eo = R({ "node_modules/indexes-of/index.js"(e, n) {
          A(), n.exports = function(i, a) {
            for (var o = -1, f = []; (o = i.indexOf(a, o + 1)) !== -1; )
              f.push(o);
            return f;
          };
        } }), qo = R({ "node_modules/uniq/uniq.js"(e, n) {
          "use strict";
          A();
          function i(f, p2) {
            for (var h3 = 1, g = f.length, c = f[0], t = f[0], r = 1; r < g; ++r)
              if (t = c, c = f[r], p2(c, t)) {
                if (r === h3) {
                  h3++;
                  continue;
                }
                f[h3++] = c;
              }
            return f.length = h3, f;
          }
          function a(f) {
            for (var p2 = 1, h3 = f.length, g = f[0], c = f[0], t = 1; t < h3; ++t, c = g)
              if (c = g, g = f[t], g !== c) {
                if (t === p2) {
                  p2++;
                  continue;
                }
                f[p2++] = g;
              }
            return f.length = p2, f;
          }
          function o(f, p2, h3) {
            return f.length === 0 ? f : p2 ? (h3 || f.sort(p2), i(f, p2)) : (h3 || f.sort(), a(f));
          }
          n.exports = o;
        } }), uf = R({ "node_modules/postcss-values-parser/lib/errors/ParserError.js"(e, n) {
          "use strict";
          A();
          var i = class extends Error {
            constructor(a) {
              super(a), this.name = this.constructor.name, this.message = a || "An error ocurred while parsing.", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(a).stack;
            }
          };
          n.exports = i;
        } }), cf = R({ "node_modules/postcss-values-parser/lib/parser.js"(e, n) {
          "use strict";
          A();
          var i = Ll(), a = Ks(), o = Qs(), f = Ys(), p2 = Xs(), h3 = Zs(), g = eo(), c = ro(), t = to(), r = no(), u = io(), s = so(), l = oo(), m2 = af(), v = To(), y = Eo(), w = qo(), d = uf();
          function _(S) {
            return S.sort((x, N) => x - N);
          }
          n.exports = class {
            constructor(x, N) {
              let P = { loose: false };
              this.cache = [], this.input = x, this.options = Object.assign({}, P, N), this.position = 0, this.unbalanced = 0, this.root = new i();
              let W = new a();
              this.root.append(W), this.current = W, this.tokens = m2(x, this.options);
            }
            parse() {
              return this.loop();
            }
            colon() {
              let x = this.currToken;
              this.newNode(new f({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            comma() {
              let x = this.currToken;
              this.newNode(new p2({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            comment() {
              let x = false, N = this.currToken[1].replace(/\/\*|\*\//g, ""), P;
              this.options.loose && N.startsWith("//") && (N = N.substring(2), x = true), P = new h3({ value: N, inline: x, source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] }), this.newNode(P), this.position++;
            }
            error(x, N) {
              throw new d(x + " at line: ".concat(N[2], ", column ").concat(N[3]));
            }
            loop() {
              for (; this.position < this.tokens.length; )
                this.parseTokens();
              return !this.current.last && this.spaces ? this.current.raws.before += this.spaces : this.spaces && (this.current.last.raws.after += this.spaces), this.spaces = "", this.root;
            }
            operator() {
              let x = this.currToken[1], N;
              if (x === "+" || x === "-") {
                if (this.options.loose || this.position > 0 && (this.current.type === "func" && this.current.value === "calc" ? this.prevToken[0] !== "space" && this.prevToken[0] !== "(" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] !== "space" && this.nextToken[0] !== "word" ? this.error("Syntax Error", this.currToken) : this.nextToken[0] === "word" && this.current.last.type !== "operator" && this.current.last.value !== "(" && this.error("Syntax Error", this.currToken) : (this.nextToken[0] === "space" || this.nextToken[0] === "operator" || this.prevToken[0] === "operator") && this.error("Syntax Error", this.currToken)), this.options.loose) {
                  if ((!this.current.nodes.length || this.current.last && this.current.last.type === "operator") && this.nextToken[0] === "word")
                    return this.word();
                } else if (this.nextToken[0] === "word")
                  return this.word();
              }
              return N = new t({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), this.position++, this.newNode(N);
            }
            parseTokens() {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "colon":
                  this.colon();
                  break;
                case "comma":
                  this.comma();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parenOpen();
                  break;
                case ")":
                  this.parenClose();
                  break;
                case "atword":
                case "word":
                  this.word();
                  break;
                case "operator":
                  this.operator();
                  break;
                case "string":
                  this.string();
                  break;
                case "unicoderange":
                  this.unicodeRange();
                  break;
                default:
                  this.word();
                  break;
              }
            }
            parenOpen() {
              let x = 1, N = this.position + 1, P = this.currToken, W;
              for (; N < this.tokens.length && x; ) {
                let U = this.tokens[N];
                U[0] === "(" && x++, U[0] === ")" && x--, N++;
              }
              if (x && this.error("Expected closing parenthesis", P), W = this.current.last, W && W.type === "func" && W.unbalanced < 0 && (W.unbalanced = 0, this.current = W), this.current.unbalanced++, this.newNode(new r({ value: P[1], source: { start: { line: P[2], column: P[3] }, end: { line: P[4], column: P[5] } }, sourceIndex: P[6] })), this.position++, this.current.type === "func" && this.current.unbalanced && this.current.value === "url" && this.currToken[0] !== "string" && this.currToken[0] !== ")" && !this.options.loose) {
                let U = this.nextToken, H = this.currToken[1], D = { line: this.currToken[2], column: this.currToken[3] };
                for (; U && U[0] !== ")" && this.current.unbalanced; )
                  this.position++, H += this.currToken[1], U = this.nextToken;
                this.position !== this.tokens.length - 1 && (this.position++, this.newNode(new s({ value: H, source: { start: D, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] })));
              }
            }
            parenClose() {
              let x = this.currToken;
              this.newNode(new r({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++, !(this.position >= this.tokens.length - 1 && !this.current.unbalanced) && (this.current.unbalanced--, this.current.unbalanced < 0 && this.error("Expected opening parenthesis", x), !this.current.unbalanced && this.cache.length && (this.current = this.cache.pop()));
            }
            space() {
              let x = this.currToken;
              this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.raws.after += x[1], this.position++) : (this.spaces = x[1], this.position++);
            }
            unicodeRange() {
              let x = this.currToken;
              this.newNode(new l({ value: x[1], source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6] })), this.position++;
            }
            splitWord() {
              let x = this.nextToken, N = this.currToken[1], P = /^[\+\-]?((\d+(\.\d*)?)|(\.\d+))([eE][\+\-]?\d+)?/, W = /^(?!\#([a-z0-9]+))[\#\{\}]/gi, U, H;
              if (!W.test(N))
                for (; x && x[0] === "word"; )
                  this.position++, N += this.currToken[1], x = this.nextToken;
              U = y(N, "@"), H = _(w(v([[0], U]))), H.forEach((D, $2) => {
                let B = H[$2 + 1] || N.length, O = N.slice(D, B), j;
                if (~U.indexOf(D))
                  j = new o({ value: O.slice(1), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[$2] });
                else if (P.test(this.currToken[1])) {
                  let C = O.replace(P, "");
                  j = new c({ value: O.replace(C, ""), source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[$2], unit: C });
                } else
                  j = new (x && x[0] === "(" ? g : s)({ value: O, source: { start: { line: this.currToken[2], column: this.currToken[3] + D }, end: { line: this.currToken[4], column: this.currToken[3] + (B - 1) } }, sourceIndex: this.currToken[6] + H[$2] }), j.type === "word" ? (j.isHex = /^#(.+)/.test(O), j.isColor = /^#([0-9a-f]{3}|[0-9a-f]{4}|[0-9a-f]{6}|[0-9a-f]{8})$/i.test(O)) : this.cache.push(this.current);
                this.newNode(j);
              }), this.position++;
            }
            string() {
              let x = this.currToken, N = this.currToken[1], P = /^(\"|\')/, W = P.test(N), U = "", H;
              W && (U = N.match(P)[0], N = N.slice(1, N.length - 1)), H = new u({ value: N, source: { start: { line: x[2], column: x[3] }, end: { line: x[4], column: x[5] } }, sourceIndex: x[6], quoted: W }), H.raws.quote = U, this.newNode(H), this.position++;
            }
            word() {
              return this.splitWord();
            }
            newNode(x) {
              return this.spaces && (x.raws.before += this.spaces, this.spaces = ""), this.current.append(x);
            }
            get currToken() {
              return this.tokens[this.position];
            }
            get nextToken() {
              return this.tokens[this.position + 1];
            }
            get prevToken() {
              return this.tokens[this.position - 1];
            }
          };
        } }), lf = R({ "node_modules/postcss-values-parser/lib/index.js"(e, n) {
          "use strict";
          A();
          var i = cf(), a = Qs(), o = Ys(), f = Xs(), p2 = Zs(), h3 = eo(), g = ro(), c = to(), t = no(), r = io(), u = oo(), s = Ks(), l = so(), m2 = function(v, y) {
            return new i(v, y);
          };
          m2.atword = function(v) {
            return new a(v);
          }, m2.colon = function(v) {
            return new o(Object.assign({ value: ":" }, v));
          }, m2.comma = function(v) {
            return new f(Object.assign({ value: "," }, v));
          }, m2.comment = function(v) {
            return new p2(v);
          }, m2.func = function(v) {
            return new h3(v);
          }, m2.number = function(v) {
            return new g(v);
          }, m2.operator = function(v) {
            return new c(v);
          }, m2.paren = function(v) {
            return new t(Object.assign({ value: "(" }, v));
          }, m2.string = function(v) {
            return new r(Object.assign({ quote: "'" }, v));
          }, m2.value = function(v) {
            return new s(v);
          }, m2.word = function(v) {
            return new l(v);
          }, m2.unicodeRange = function(v) {
            return new u(v);
          }, n.exports = m2;
        } }), ze = R({ "node_modules/postcss-selector-parser/dist/selectors/node.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(p2) {
            return typeof p2;
          } : function(p2) {
            return p2 && typeof Symbol == "function" && p2.constructor === Symbol && p2 !== Symbol.prototype ? "symbol" : typeof p2;
          };
          function a(p2, h3) {
            if (!(p2 instanceof h3))
              throw new TypeError("Cannot call a class as a function");
          }
          var o = function p2(h3, g) {
            if ((typeof h3 > "u" ? "undefined" : i(h3)) !== "object")
              return h3;
            var c = new h3.constructor();
            for (var t in h3)
              if (!!h3.hasOwnProperty(t)) {
                var r = h3[t], u = typeof r > "u" ? "undefined" : i(r);
                t === "parent" && u === "object" ? g && (c[t] = g) : r instanceof Array ? c[t] = r.map(function(s) {
                  return p2(s, c);
                }) : c[t] = p2(r, c);
              }
            return c;
          }, f = function() {
            function p2() {
              var h3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              a(this, p2);
              for (var g in h3)
                this[g] = h3[g];
              var c = h3.spaces;
              c = c === void 0 ? {} : c;
              var t = c.before, r = t === void 0 ? "" : t, u = c.after, s = u === void 0 ? "" : u;
              this.spaces = { before: r, after: s };
            }
            return p2.prototype.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, p2.prototype.replaceWith = function() {
              if (this.parent) {
                for (var g in arguments)
                  this.parent.insertBefore(this, arguments[g]);
                this.remove();
              }
              return this;
            }, p2.prototype.next = function() {
              return this.parent.at(this.parent.index(this) + 1);
            }, p2.prototype.prev = function() {
              return this.parent.at(this.parent.index(this) - 1);
            }, p2.prototype.clone = function() {
              var g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, c = o(this);
              for (var t in g)
                c[t] = g[t];
              return c;
            }, p2.prototype.toString = function() {
              return [this.spaces.before, String(this.value), this.spaces.after].join("");
            }, p2;
          }();
          e.default = f, n.exports = e.default;
        } }), oe = R({ "node_modules/postcss-selector-parser/dist/selectors/types.js"(e) {
          "use strict";
          A(), e.__esModule = true;
          var n = e.TAG = "tag", i = e.STRING = "string", a = e.SELECTOR = "selector", o = e.ROOT = "root", f = e.PSEUDO = "pseudo", p2 = e.NESTING = "nesting", h3 = e.ID = "id", g = e.COMMENT = "comment", c = e.COMBINATOR = "combinator", t = e.CLASS = "class", r = e.ATTRIBUTE = "attribute", u = e.UNIVERSAL = "universal";
        } }), Ct = R({ "node_modules/postcss-selector-parser/dist/selectors/container.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = function() {
            function s(l, m2) {
              for (var v = 0; v < m2.length; v++) {
                var y = m2[v];
                y.enumerable = y.enumerable || false, y.configurable = true, "value" in y && (y.writable = true), Object.defineProperty(l, y.key, y);
              }
            }
            return function(l, m2, v) {
              return m2 && s(l.prototype, m2), v && s(l, v), l;
            };
          }(), a = ze(), o = g(a), f = oe(), p2 = h3(f);
          function h3(s) {
            if (s && s.__esModule)
              return s;
            var l = {};
            if (s != null)
              for (var m2 in s)
                Object.prototype.hasOwnProperty.call(s, m2) && (l[m2] = s[m2]);
            return l.default = s, l;
          }
          function g(s) {
            return s && s.__esModule ? s : { default: s };
          }
          function c(s, l) {
            if (!(s instanceof l))
              throw new TypeError("Cannot call a class as a function");
          }
          function t(s, l) {
            if (!s)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return l && (typeof l == "object" || typeof l == "function") ? l : s;
          }
          function r(s, l) {
            if (typeof l != "function" && l !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof l);
            s.prototype = Object.create(l && l.prototype, { constructor: { value: s, enumerable: false, writable: true, configurable: true } }), l && (Object.setPrototypeOf ? Object.setPrototypeOf(s, l) : s.__proto__ = l);
          }
          var u = function(s) {
            r(l, s);
            function l(m2) {
              c(this, l);
              var v = t(this, s.call(this, m2));
              return v.nodes || (v.nodes = []), v;
            }
            return l.prototype.append = function(v) {
              return v.parent = this, this.nodes.push(v), this;
            }, l.prototype.prepend = function(v) {
              return v.parent = this, this.nodes.unshift(v), this;
            }, l.prototype.at = function(v) {
              return this.nodes[v];
            }, l.prototype.index = function(v) {
              return typeof v == "number" ? v : this.nodes.indexOf(v);
            }, l.prototype.removeChild = function(v) {
              v = this.index(v), this.at(v).parent = void 0, this.nodes.splice(v, 1);
              var y = void 0;
              for (var w in this.indexes)
                y = this.indexes[w], y >= v && (this.indexes[w] = y - 1);
              return this;
            }, l.prototype.removeAll = function() {
              for (var w = this.nodes, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length)
                    break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done)
                    break;
                  d = y.value;
                }
                var _ = d;
                _.parent = void 0;
              }
              return this.nodes = [], this;
            }, l.prototype.empty = function() {
              return this.removeAll();
            }, l.prototype.insertAfter = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w + 1, 0, y);
              var d = void 0;
              for (var _ in this.indexes)
                d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, l.prototype.insertBefore = function(v, y) {
              var w = this.index(v);
              this.nodes.splice(w, 0, y);
              var d = void 0;
              for (var _ in this.indexes)
                d = this.indexes[_], w <= d && (this.indexes[_] = d + this.nodes.length);
              return this;
            }, l.prototype.each = function(v) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
              var y = this.lastEach;
              if (this.indexes[y] = 0, !!this.length) {
                for (var w = void 0, d = void 0; this.indexes[y] < this.length && (w = this.indexes[y], d = v(this.at(w), w), d !== false); )
                  this.indexes[y] += 1;
                if (delete this.indexes[y], d === false)
                  return false;
              }
            }, l.prototype.walk = function(v) {
              return this.each(function(y, w) {
                var d = v(y, w);
                if (d !== false && y.length && (d = y.walk(v)), d === false)
                  return false;
              });
            }, l.prototype.walkAttributes = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.ATTRIBUTE)
                  return v.call(y, w);
              });
            }, l.prototype.walkClasses = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.CLASS)
                  return v.call(y, w);
              });
            }, l.prototype.walkCombinators = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.COMBINATOR)
                  return v.call(y, w);
              });
            }, l.prototype.walkComments = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.COMMENT)
                  return v.call(y, w);
              });
            }, l.prototype.walkIds = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.ID)
                  return v.call(y, w);
              });
            }, l.prototype.walkNesting = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.NESTING)
                  return v.call(y, w);
              });
            }, l.prototype.walkPseudos = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.PSEUDO)
                  return v.call(y, w);
              });
            }, l.prototype.walkTags = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.TAG)
                  return v.call(y, w);
              });
            }, l.prototype.walkUniversals = function(v) {
              var y = this;
              return this.walk(function(w) {
                if (w.type === p2.UNIVERSAL)
                  return v.call(y, w);
              });
            }, l.prototype.split = function(v) {
              var y = this, w = [];
              return this.reduce(function(d, _, S) {
                var x = v.call(y, _);
                return w.push(_), x ? (d.push(w), w = []) : S === y.length - 1 && d.push(w), d;
              }, []);
            }, l.prototype.map = function(v) {
              return this.nodes.map(v);
            }, l.prototype.reduce = function(v, y) {
              return this.nodes.reduce(v, y);
            }, l.prototype.every = function(v) {
              return this.nodes.every(v);
            }, l.prototype.some = function(v) {
              return this.nodes.some(v);
            }, l.prototype.filter = function(v) {
              return this.nodes.filter(v);
            }, l.prototype.sort = function(v) {
              return this.nodes.sort(v);
            }, l.prototype.toString = function() {
              return this.map(String).join("");
            }, i(l, [{ key: "first", get: function() {
              return this.at(0);
            } }, { key: "last", get: function() {
              return this.at(this.length - 1);
            } }, { key: "length", get: function() {
              return this.nodes.length;
            } }]), l;
          }(o.default);
          e.default = u, n.exports = e.default;
        } }), Ao = R({ "node_modules/postcss-selector-parser/dist/selectors/root.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ct(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.ROOT, s;
            }
            return r.prototype.toString = function() {
              var s = this.reduce(function(l, m2) {
                var v = String(m2);
                return v ? l + v + "," : "";
              }, "").slice(0, -1);
              return this.trailingComma ? s + "," : s;
            }, r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Po = R({ "node_modules/postcss-selector-parser/dist/selectors/selector.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ct(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.SELECTOR, s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Ye = R({ "node_modules/postcss-selector-parser/dist/selectors/namespace.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = function() {
            function t(r, u) {
              for (var s = 0; s < u.length; s++) {
                var l = u[s];
                l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(r, l.key, l);
              }
            }
            return function(r, u, s) {
              return u && t(r.prototype, u), s && t(r, s), r;
            };
          }(), a = ze(), o = f(a);
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r() {
              return p2(this, r), h3(this, t.apply(this, arguments));
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String(this.value), this.spaces.after].join("");
            }, i(r, [{ key: "ns", get: function() {
              var s = this.namespace;
              return s ? (typeof s == "string" ? s : "") + "|" : "";
            } }]), r;
          }(o.default);
          e.default = c, n.exports = e.default;
        } }), Ro = R({ "node_modules/postcss-selector-parser/dist/selectors/className.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ye(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.CLASS, s;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("." + this.value), this.spaces.after].join("");
            }, r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Io = R({ "node_modules/postcss-selector-parser/dist/selectors/comment.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = ze(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.COMMENT, s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Co = R({ "node_modules/postcss-selector-parser/dist/selectors/id.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ye(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.ID, s;
            }
            return r.prototype.toString = function() {
              return [this.spaces.before, this.ns, String("#" + this.value), this.spaces.after].join("");
            }, r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), No = R({ "node_modules/postcss-selector-parser/dist/selectors/tag.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ye(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.TAG, s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), jo = R({ "node_modules/postcss-selector-parser/dist/selectors/string.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = ze(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.STRING, s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Mo = R({ "node_modules/postcss-selector-parser/dist/selectors/pseudo.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ct(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.PSEUDO, s;
            }
            return r.prototype.toString = function() {
              var s = this.length ? "(" + this.map(String).join(",") + ")" : "";
              return [this.spaces.before, String(this.value), s, this.spaces.after].join("");
            }, r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Do = R({ "node_modules/postcss-selector-parser/dist/selectors/attribute.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ye(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.ATTRIBUTE, s.raws = {}, s;
            }
            return r.prototype.toString = function() {
              var s = [this.spaces.before, "[", this.ns, this.attribute];
              return this.operator && s.push(this.operator), this.value && s.push(this.value), this.raws.insensitive ? s.push(this.raws.insensitive) : this.insensitive && s.push(" i"), s.push("]"), s.concat(this.spaces.after).join("");
            }, r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Lo = R({ "node_modules/postcss-selector-parser/dist/selectors/universal.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = Ye(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.UNIVERSAL, s.value = "*", s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), zo = R({ "node_modules/postcss-selector-parser/dist/selectors/combinator.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = ze(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.COMBINATOR, s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), Bo = R({ "node_modules/postcss-selector-parser/dist/selectors/nesting.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = ze(), a = f(i), o = oe();
          function f(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function p2(t, r) {
            if (!(t instanceof r))
              throw new TypeError("Cannot call a class as a function");
          }
          function h3(t, r) {
            if (!t)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return r && (typeof r == "object" || typeof r == "function") ? r : t;
          }
          function g(t, r) {
            if (typeof r != "function" && r !== null)
              throw new TypeError("Super expression must either be null or a function, not " + typeof r);
            t.prototype = Object.create(r && r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }), r && (Object.setPrototypeOf ? Object.setPrototypeOf(t, r) : t.__proto__ = r);
          }
          var c = function(t) {
            g(r, t);
            function r(u) {
              p2(this, r);
              var s = h3(this, t.call(this, u));
              return s.type = o.NESTING, s.value = "&", s;
            }
            return r;
          }(a.default);
          e.default = c, n.exports = e.default;
        } }), ff = R({ "node_modules/postcss-selector-parser/dist/sortAscending.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = i;
          function i(a) {
            return a.sort(function(o, f) {
              return o - f;
            });
          }
          n.exports = e.default;
        } }), pf = R({ "node_modules/postcss-selector-parser/dist/tokenize.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = H;
          var i = 39, a = 34, o = 92, f = 47, p2 = 10, h3 = 32, g = 12, c = 9, t = 13, r = 43, u = 62, s = 126, l = 124, m2 = 44, v = 40, y = 41, w = 91, d = 93, _ = 59, S = 42, x = 58, N = 38, P = 64, W = /[ \n\t\r\{\(\)'"\\;/]/g, U = /[ \n\t\r\(\)\*:;@!&'"\+\|~>,\[\]\\]|\/(?=\*)/g;
          function H(D) {
            for (var $2 = [], B = D.css.valueOf(), O = void 0, j = void 0, C = void 0, I = void 0, X = void 0, Z = void 0, Q = void 0, K = void 0, J = void 0, M = void 0, Y = void 0, G = B.length, E = -1, k = 1, b = 0, L = function(T, F) {
              if (D.safe)
                B += F, j = B.length - 1;
              else
                throw D.error("Unclosed " + T, k, b - E, b);
            }; b < G; ) {
              switch (O = B.charCodeAt(b), O === p2 && (E = b, k += 1), O) {
                case p2:
                case h3:
                case c:
                case t:
                case g:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j), O === p2 && (E = j, k += 1);
                  while (O === h3 || O === p2 || O === c || O === t || O === g);
                  $2.push(["space", B.slice(b, j), k, b - E, b]), b = j - 1;
                  break;
                case r:
                case u:
                case s:
                case l:
                  j = b;
                  do
                    j += 1, O = B.charCodeAt(j);
                  while (O === r || O === u || O === s || O === l);
                  $2.push(["combinator", B.slice(b, j), k, b - E, b]), b = j - 1;
                  break;
                case S:
                  $2.push(["*", "*", k, b - E, b]);
                  break;
                case N:
                  $2.push(["&", "&", k, b - E, b]);
                  break;
                case m2:
                  $2.push([",", ",", k, b - E, b]);
                  break;
                case w:
                  $2.push(["[", "[", k, b - E, b]);
                  break;
                case d:
                  $2.push(["]", "]", k, b - E, b]);
                  break;
                case x:
                  $2.push([":", ":", k, b - E, b]);
                  break;
                case _:
                  $2.push([";", ";", k, b - E, b]);
                  break;
                case v:
                  $2.push(["(", "(", k, b - E, b]);
                  break;
                case y:
                  $2.push([")", ")", k, b - E, b]);
                  break;
                case i:
                case a:
                  C = O === i ? "'" : '"', j = b;
                  do
                    for (M = false, j = B.indexOf(C, j + 1), j === -1 && L("quote", C), Y = j; B.charCodeAt(Y - 1) === o; )
                      Y -= 1, M = !M;
                  while (M);
                  $2.push(["string", B.slice(b, j + 1), k, b - E, k, j - E, b]), b = j;
                  break;
                case P:
                  W.lastIndex = b + 1, W.test(B), W.lastIndex === 0 ? j = B.length - 1 : j = W.lastIndex - 2, $2.push(["at-word", B.slice(b, j + 1), k, b - E, k, j - E, b]), b = j;
                  break;
                case o:
                  for (j = b, Q = true; B.charCodeAt(j + 1) === o; )
                    j += 1, Q = !Q;
                  O = B.charCodeAt(j + 1), Q && O !== f && O !== h3 && O !== p2 && O !== c && O !== t && O !== g && (j += 1), $2.push(["word", B.slice(b, j + 1), k, b - E, k, j - E, b]), b = j;
                  break;
                default:
                  O === f && B.charCodeAt(b + 1) === S ? (j = B.indexOf("*/", b + 2) + 1, j === 0 && L("comment", "*/"), Z = B.slice(b, j + 1), I = Z.split(`
`), X = I.length - 1, X > 0 ? (K = k + X, J = j - I[X].length) : (K = k, J = E), $2.push(["comment", Z, k, b - E, K, j - J, b]), E = J, k = K, b = j) : (U.lastIndex = b + 1, U.test(B), U.lastIndex === 0 ? j = B.length - 1 : j = U.lastIndex - 2, $2.push(["word", B.slice(b, j + 1), k, b - E, k, j - E, b]), b = j);
                  break;
              }
              b++;
            }
            return $2;
          }
          n.exports = e.default;
        } }), hf = R({ "node_modules/postcss-selector-parser/dist/parser.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = function() {
            function E(k, b) {
              for (var L = 0; L < b.length; L++) {
                var q = b[L];
                q.enumerable = q.enumerable || false, q.configurable = true, "value" in q && (q.writable = true), Object.defineProperty(k, q.key, q);
              }
            }
            return function(k, b, L) {
              return b && E(k.prototype, b), L && E(k, L), k;
            };
          }(), a = To(), o = M(a), f = Eo(), p2 = M(f), h3 = qo(), g = M(h3), c = Ao(), t = M(c), r = Po(), u = M(r), s = Ro(), l = M(s), m2 = Io(), v = M(m2), y = Co(), w = M(y), d = No(), _ = M(d), S = jo(), x = M(S), N = Mo(), P = M(N), W = Do(), U = M(W), H = Lo(), D = M(H), $2 = zo(), B = M($2), O = Bo(), j = M(O), C = ff(), I = M(C), X = pf(), Z = M(X), Q = oe(), K = J(Q);
          function J(E) {
            if (E && E.__esModule)
              return E;
            var k = {};
            if (E != null)
              for (var b in E)
                Object.prototype.hasOwnProperty.call(E, b) && (k[b] = E[b]);
            return k.default = E, k;
          }
          function M(E) {
            return E && E.__esModule ? E : { default: E };
          }
          function Y(E, k) {
            if (!(E instanceof k))
              throw new TypeError("Cannot call a class as a function");
          }
          var G = function() {
            function E(k) {
              Y(this, E), this.input = k, this.lossy = k.options.lossless === false, this.position = 0, this.root = new t.default();
              var b = new u.default();
              return this.root.append(b), this.current = b, this.lossy ? this.tokens = (0, Z.default)({ safe: k.safe, css: k.css.trim() }) : this.tokens = (0, Z.default)(k), this.loop();
            }
            return E.prototype.attribute = function() {
              var b = "", L = void 0, q = this.currToken;
              for (this.position++; this.position < this.tokens.length && this.currToken[0] !== "]"; )
                b += this.tokens[this.position][1], this.position++;
              this.position === this.tokens.length && !~b.indexOf("]") && this.error("Expected a closing square bracket.");
              var T = b.split(/((?:[*~^$|]?=))([^]*)/), F = T[0].split(/(\|)/g), z = { operator: T[1], value: T[2], source: { start: { line: q[2], column: q[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: q[4] };
              if (F.length > 1 ? (F[0] === "" && (F[0] = true), z.attribute = this.parseValue(F[2]), z.namespace = this.parseNamespace(F[0])) : z.attribute = this.parseValue(T[0]), L = new U.default(z), T[2]) {
                var re = T[2].split(/(\s+i\s*?)$/), ne = re[0].trim();
                L.value = this.lossy ? ne : re[0], re[1] && (L.insensitive = true, this.lossy || (L.raws.insensitive = re[1])), L.quoted = ne[0] === "'" || ne[0] === '"', L.raws.unquoted = L.quoted ? ne.slice(1, -1) : ne;
              }
              this.newNode(L), this.position++;
            }, E.prototype.combinator = function() {
              if (this.currToken[1] === "|")
                return this.namespace();
              for (var b = new B.default({ value: "", source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }); this.position < this.tokens.length && this.currToken && (this.currToken[0] === "space" || this.currToken[0] === "combinator"); )
                this.nextToken && this.nextToken[0] === "combinator" ? (b.spaces.before = this.parseSpace(this.currToken[1]), b.source.start.line = this.nextToken[2], b.source.start.column = this.nextToken[3], b.source.end.column = this.nextToken[3], b.source.end.line = this.nextToken[2], b.sourceIndex = this.nextToken[4]) : this.prevToken && this.prevToken[0] === "combinator" ? b.spaces.after = this.parseSpace(this.currToken[1]) : this.currToken[0] === "combinator" ? b.value = this.currToken[1] : this.currToken[0] === "space" && (b.value = this.parseSpace(this.currToken[1], " ")), this.position++;
              return this.newNode(b);
            }, E.prototype.comma = function() {
              if (this.position === this.tokens.length - 1) {
                this.root.trailingComma = true, this.position++;
                return;
              }
              var b = new u.default();
              this.current.parent.append(b), this.current = b, this.position++;
            }, E.prototype.comment = function() {
              var b = new v.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[4], column: this.currToken[5] } }, sourceIndex: this.currToken[6] });
              this.newNode(b), this.position++;
            }, E.prototype.error = function(b) {
              throw new this.input.error(b);
            }, E.prototype.missingBackslash = function() {
              return this.error("Expected a backslash preceding the semicolon.");
            }, E.prototype.missingParenthesis = function() {
              return this.error("Expected opening parenthesis.");
            }, E.prototype.missingSquareBracket = function() {
              return this.error("Expected opening square bracket.");
            }, E.prototype.namespace = function() {
              var b = this.prevToken && this.prevToken[1] || true;
              if (this.nextToken[0] === "word")
                return this.position++, this.word(b);
              if (this.nextToken[0] === "*")
                return this.position++, this.universal(b);
            }, E.prototype.nesting = function() {
              this.newNode(new j.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] })), this.position++;
            }, E.prototype.parentheses = function() {
              var b = this.current.last;
              if (b && b.type === K.PSEUDO) {
                var L = new u.default(), q = this.current;
                b.append(L), this.current = L;
                var T = 1;
                for (this.position++; this.position < this.tokens.length && T; )
                  this.currToken[0] === "(" && T++, this.currToken[0] === ")" && T--, T ? this.parse() : (L.parent.source.end.line = this.currToken[2], L.parent.source.end.column = this.currToken[3], this.position++);
                T && this.error("Expected closing parenthesis."), this.current = q;
              } else {
                var F = 1;
                for (this.position++, b.value += "("; this.position < this.tokens.length && F; )
                  this.currToken[0] === "(" && F++, this.currToken[0] === ")" && F--, b.value += this.parseParenthesisToken(this.currToken), this.position++;
                F && this.error("Expected closing parenthesis.");
              }
            }, E.prototype.pseudo = function() {
              for (var b = this, L = "", q = this.currToken; this.currToken && this.currToken[0] === ":"; )
                L += this.currToken[1], this.position++;
              if (!this.currToken)
                return this.error("Expected pseudo-class or pseudo-element");
              if (this.currToken[0] === "word") {
                var T = void 0;
                this.splitWord(false, function(F, z) {
                  L += F, T = new P.default({ value: L, source: { start: { line: q[2], column: q[3] }, end: { line: b.currToken[4], column: b.currToken[5] } }, sourceIndex: q[4] }), b.newNode(T), z > 1 && b.nextToken && b.nextToken[0] === "(" && b.error("Misplaced parenthesis.");
                });
              } else
                this.error('Unexpected "' + this.currToken[0] + '" found.');
            }, E.prototype.space = function() {
              var b = this.currToken;
              this.position === 0 || this.prevToken[0] === "," || this.prevToken[0] === "(" ? (this.spaces = this.parseSpace(b[1]), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[0] === "," || this.nextToken[0] === ")" ? (this.current.last.spaces.after = this.parseSpace(b[1]), this.position++) : this.combinator();
            }, E.prototype.string = function() {
              var b = this.currToken;
              this.newNode(new x.default({ value: this.currToken[1], source: { start: { line: b[2], column: b[3] }, end: { line: b[4], column: b[5] } }, sourceIndex: b[6] })), this.position++;
            }, E.prototype.universal = function(b) {
              var L = this.nextToken;
              if (L && L[1] === "|")
                return this.position++, this.namespace();
              this.newNode(new D.default({ value: this.currToken[1], source: { start: { line: this.currToken[2], column: this.currToken[3] }, end: { line: this.currToken[2], column: this.currToken[3] } }, sourceIndex: this.currToken[4] }), b), this.position++;
            }, E.prototype.splitWord = function(b, L) {
              for (var q = this, T = this.nextToken, F = this.currToken[1]; T && T[0] === "word"; ) {
                this.position++;
                var z = this.currToken[1];
                if (F += z, z.lastIndexOf("\\") === z.length - 1) {
                  var re = this.nextToken;
                  re && re[0] === "space" && (F += this.parseSpace(re[1], " "), this.position++);
                }
                T = this.nextToken;
              }
              var ne = (0, p2.default)(F, "."), ce = (0, p2.default)(F, "#"), fe = (0, p2.default)(F, "#{");
              fe.length && (ce = ce.filter(function(ie) {
                return !~fe.indexOf(ie);
              }));
              var te = (0, I.default)((0, g.default)((0, o.default)([[0], ne, ce])));
              te.forEach(function(ie, ae) {
                var se = te[ae + 1] || F.length, le = F.slice(ie, se);
                if (ae === 0 && L)
                  return L.call(q, le, te.length);
                var pe = void 0;
                ~ne.indexOf(ie) ? pe = new l.default({ value: le.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ie }, end: { line: q.currToken[4], column: q.currToken[3] + (se - 1) } }, sourceIndex: q.currToken[6] + te[ae] }) : ~ce.indexOf(ie) ? pe = new w.default({ value: le.slice(1), source: { start: { line: q.currToken[2], column: q.currToken[3] + ie }, end: { line: q.currToken[4], column: q.currToken[3] + (se - 1) } }, sourceIndex: q.currToken[6] + te[ae] }) : pe = new _.default({ value: le, source: { start: { line: q.currToken[2], column: q.currToken[3] + ie }, end: { line: q.currToken[4], column: q.currToken[3] + (se - 1) } }, sourceIndex: q.currToken[6] + te[ae] }), q.newNode(pe, b);
              }), this.position++;
            }, E.prototype.word = function(b) {
              var L = this.nextToken;
              return L && L[1] === "|" ? (this.position++, this.namespace()) : this.splitWord(b);
            }, E.prototype.loop = function() {
              for (; this.position < this.tokens.length; )
                this.parse(true);
              return this.root;
            }, E.prototype.parse = function(b) {
              switch (this.currToken[0]) {
                case "space":
                  this.space();
                  break;
                case "comment":
                  this.comment();
                  break;
                case "(":
                  this.parentheses();
                  break;
                case ")":
                  b && this.missingParenthesis();
                  break;
                case "[":
                  this.attribute();
                  break;
                case "]":
                  this.missingSquareBracket();
                  break;
                case "at-word":
                case "word":
                  this.word();
                  break;
                case ":":
                  this.pseudo();
                  break;
                case ";":
                  this.missingBackslash();
                  break;
                case ",":
                  this.comma();
                  break;
                case "*":
                  this.universal();
                  break;
                case "&":
                  this.nesting();
                  break;
                case "combinator":
                  this.combinator();
                  break;
                case "string":
                  this.string();
                  break;
              }
            }, E.prototype.parseNamespace = function(b) {
              if (this.lossy && typeof b == "string") {
                var L = b.trim();
                return L.length ? L : true;
              }
              return b;
            }, E.prototype.parseSpace = function(b, L) {
              return this.lossy ? L || "" : b;
            }, E.prototype.parseValue = function(b) {
              return this.lossy && b && typeof b == "string" ? b.trim() : b;
            }, E.prototype.parseParenthesisToken = function(b) {
              return this.lossy ? b[0] === "space" ? this.parseSpace(b[1], " ") : this.parseValue(b[1]) : b[1];
            }, E.prototype.newNode = function(b, L) {
              return L && (b.namespace = this.parseNamespace(L)), this.spaces && (b.spaces.before = this.spaces, this.spaces = ""), this.current.append(b);
            }, i(E, [{ key: "currToken", get: function() {
              return this.tokens[this.position];
            } }, { key: "nextToken", get: function() {
              return this.tokens[this.position + 1];
            } }, { key: "prevToken", get: function() {
              return this.tokens[this.position - 1];
            } }]), E;
          }();
          e.default = G, n.exports = e.default;
        } }), df = R({ "node_modules/postcss-selector-parser/dist/processor.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = function() {
            function g(c, t) {
              for (var r = 0; r < t.length; r++) {
                var u = t[r];
                u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(c, u.key, u);
              }
            }
            return function(c, t, r) {
              return t && g(c.prototype, t), r && g(c, r), c;
            };
          }(), a = hf(), o = f(a);
          function f(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function p2(g, c) {
            if (!(g instanceof c))
              throw new TypeError("Cannot call a class as a function");
          }
          var h3 = function() {
            function g(c) {
              return p2(this, g), this.func = c || function() {
              }, this;
            }
            return g.prototype.process = function(t) {
              var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = new o.default({ css: t, error: function(l) {
                throw new Error(l);
              }, options: r });
              return this.res = u, this.func(u), this;
            }, i(g, [{ key: "result", get: function() {
              return String(this.res);
            } }]), g;
          }();
          e.default = h3, n.exports = e.default;
        } }), vf = R({ "node_modules/postcss-selector-parser/dist/index.js"(e, n) {
          "use strict";
          A(), e.__esModule = true;
          var i = df(), a = O(i), o = Do(), f = O(o), p2 = Ro(), h3 = O(p2), g = zo(), c = O(g), t = Io(), r = O(t), u = Co(), s = O(u), l = Bo(), m2 = O(l), v = Mo(), y = O(v), w = Ao(), d = O(w), _ = Po(), S = O(_), x = jo(), N = O(x), P = No(), W = O(P), U = Lo(), H = O(U), D = oe(), $2 = B(D);
          function B(C) {
            if (C && C.__esModule)
              return C;
            var I = {};
            if (C != null)
              for (var X in C)
                Object.prototype.hasOwnProperty.call(C, X) && (I[X] = C[X]);
            return I.default = C, I;
          }
          function O(C) {
            return C && C.__esModule ? C : { default: C };
          }
          var j = function(I) {
            return new a.default(I);
          };
          j.attribute = function(C) {
            return new f.default(C);
          }, j.className = function(C) {
            return new h3.default(C);
          }, j.combinator = function(C) {
            return new c.default(C);
          }, j.comment = function(C) {
            return new r.default(C);
          }, j.id = function(C) {
            return new s.default(C);
          }, j.nesting = function(C) {
            return new m2.default(C);
          }, j.pseudo = function(C) {
            return new y.default(C);
          }, j.root = function(C) {
            return new d.default(C);
          }, j.selector = function(C) {
            return new S.default(C);
          }, j.string = function(C) {
            return new N.default(C);
          }, j.tag = function(C) {
            return new W.default(C);
          }, j.universal = function(C) {
            return new H.default(C);
          }, Object.keys($2).forEach(function(C) {
            C !== "__esModule" && (j[C] = $2[C]);
          }), e.default = j, n.exports = e.default;
        } }), Fo = R({ "node_modules/postcss-media-query-parser/dist/nodes/Node.js"(e) {
          "use strict";
          A(), Object.defineProperty(e, "__esModule", { value: true });
          function n(i) {
            this.after = i.after, this.before = i.before, this.type = i.type, this.value = i.value, this.sourceIndex = i.sourceIndex;
          }
          e.default = n;
        } }), Uo = R({ "node_modules/postcss-media-query-parser/dist/nodes/Container.js"(e) {
          "use strict";
          A(), Object.defineProperty(e, "__esModule", { value: true });
          var n = Fo(), i = a(n);
          function a(f) {
            return f && f.__esModule ? f : { default: f };
          }
          function o(f) {
            var p2 = this;
            this.constructor(f), this.nodes = f.nodes, this.after === void 0 && (this.after = this.nodes.length > 0 ? this.nodes[this.nodes.length - 1].after : ""), this.before === void 0 && (this.before = this.nodes.length > 0 ? this.nodes[0].before : ""), this.sourceIndex === void 0 && (this.sourceIndex = this.before.length), this.nodes.forEach(function(h3) {
              h3.parent = p2;
            });
          }
          o.prototype = Object.create(i.default.prototype), o.constructor = i.default, o.prototype.walk = function(p2, h3) {
            for (var g = typeof p2 == "string" || p2 instanceof RegExp, c = g ? h3 : p2, t = typeof p2 == "string" ? new RegExp(p2) : p2, r = 0; r < this.nodes.length; r++) {
              var u = this.nodes[r], s = g ? t.test(u.type) : true;
              if (s && c && c(u, r, this.nodes) === false || u.nodes && u.walk(p2, h3) === false)
                return false;
            }
            return true;
          }, o.prototype.each = function() {
            for (var p2 = arguments.length <= 0 || arguments[0] === void 0 ? function() {
            } : arguments[0], h3 = 0; h3 < this.nodes.length; h3++) {
              var g = this.nodes[h3];
              if (p2(g, h3, this.nodes) === false)
                return false;
            }
            return true;
          }, e.default = o;
        } }), mf = R({ "node_modules/postcss-media-query-parser/dist/parsers.js"(e) {
          "use strict";
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.parseMediaFeature = p2, e.parseMediaQuery = h3, e.parseMediaList = g;
          var n = Fo(), i = f(n), a = Uo(), o = f(a);
          function f(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function p2(c) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [{ mode: "normal", character: null }], u = [], s = 0, l = "", m2 = null, v = null, y = t, w = c;
            c[0] === "(" && c[c.length - 1] === ")" && (w = c.substring(1, c.length - 1), y++);
            for (var d = 0; d < w.length; d++) {
              var _ = w[d];
              if ((_ === "'" || _ === '"') && (r[s].isCalculationEnabled === true ? (r.push({ mode: "string", isCalculationEnabled: false, character: _ }), s++) : r[s].mode === "string" && r[s].character === _ && w[d - 1] !== "\\" && (r.pop(), s--)), _ === "{" ? (r.push({ mode: "interpolation", isCalculationEnabled: true }), s++) : _ === "}" && (r.pop(), s--), r[s].mode === "normal" && _ === ":") {
                var S = w.substring(d + 1);
                v = { type: "value", before: /^(\s*)/.exec(S)[1], after: /(\s*)$/.exec(S)[1], value: S.trim() }, v.sourceIndex = v.before.length + d + 1 + y, m2 = { type: "colon", sourceIndex: d + y, after: v.before, value: ":" };
                break;
              }
              l += _;
            }
            return l = { type: "media-feature", before: /^(\s*)/.exec(l)[1], after: /(\s*)$/.exec(l)[1], value: l.trim() }, l.sourceIndex = l.before.length + y, u.push(l), m2 !== null && (m2.before = l.after, u.push(m2)), v !== null && u.push(v), u;
          }
          function h3(c) {
            var t = arguments.length <= 1 || arguments[1] === void 0 ? 0 : arguments[1], r = [], u = 0, s = false, l = void 0;
            function m2() {
              return { before: "", after: "", value: "" };
            }
            l = m2();
            for (var v = 0; v < c.length; v++) {
              var y = c[v];
              s ? (l.value += y, (y === "{" || y === "(") && u++, (y === ")" || y === "}") && u--) : y.search(/\s/) !== -1 ? l.before += y : (y === "(" && (l.type = "media-feature-expression", u++), l.value = y, l.sourceIndex = t + v, s = true), s && u === 0 && (y === ")" || v === c.length - 1 || c[v + 1].search(/\s/) !== -1) && (["not", "only", "and"].indexOf(l.value) !== -1 && (l.type = "keyword"), l.type === "media-feature-expression" && (l.nodes = p2(l.value, l.sourceIndex)), r.push(Array.isArray(l.nodes) ? new o.default(l) : new i.default(l)), l = m2(), s = false);
            }
            for (var w = 0; w < r.length; w++)
              if (l = r[w], w > 0 && (r[w - 1].after = l.before), l.type === void 0) {
                if (w > 0) {
                  if (r[w - 1].type === "media-feature-expression") {
                    l.type = "keyword";
                    continue;
                  }
                  if (r[w - 1].value === "not" || r[w - 1].value === "only") {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w - 1].value === "and") {
                    l.type = "media-feature-expression";
                    continue;
                  }
                  r[w - 1].type === "media-type" && (r[w + 1] ? l.type = r[w + 1].type === "media-feature-expression" ? "keyword" : "media-feature-expression" : l.type = "media-feature-expression");
                }
                if (w === 0) {
                  if (!r[w + 1]) {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w + 1] && (r[w + 1].type === "media-feature-expression" || r[w + 1].type === "keyword")) {
                    l.type = "media-type";
                    continue;
                  }
                  if (r[w + 2]) {
                    if (r[w + 2].type === "media-feature-expression") {
                      l.type = "media-type", r[w + 1].type = "keyword";
                      continue;
                    }
                    if (r[w + 2].type === "keyword") {
                      l.type = "keyword", r[w + 1].type = "media-type";
                      continue;
                    }
                  }
                  if (r[w + 3] && r[w + 3].type === "media-feature-expression") {
                    l.type = "keyword", r[w + 1].type = "media-type", r[w + 2].type = "keyword";
                    continue;
                  }
                }
              }
            return r;
          }
          function g(c) {
            var t = [], r = 0, u = 0, s = /^(\s*)url\s*\(/.exec(c);
            if (s !== null) {
              for (var l = s[0].length, m2 = 1; m2 > 0; ) {
                var v = c[l];
                v === "(" && m2++, v === ")" && m2--, l++;
              }
              t.unshift(new i.default({ type: "url", value: c.substring(0, l).trim(), sourceIndex: s[1].length, before: s[1], after: /^(\s*)/.exec(c.substring(l))[1] })), r = l;
            }
            for (var y = r; y < c.length; y++) {
              var w = c[y];
              if (w === "(" && u++, w === ")" && u--, u === 0 && w === ",") {
                var d = c.substring(r, y), _ = /^(\s*)/.exec(d)[1];
                t.push(new o.default({ type: "media-query", value: d.trim(), sourceIndex: r + _.length, nodes: h3(d, r), before: _, after: /(\s*)$/.exec(d)[1] })), r = y + 1;
              }
            }
            var S = c.substring(r), x = /^(\s*)/.exec(S)[1];
            return t.push(new o.default({ type: "media-query", value: S.trim(), sourceIndex: r + x.length, nodes: h3(S, r), before: x, after: /(\s*)$/.exec(S)[1] })), t;
          }
        } }), gf = R({ "node_modules/postcss-media-query-parser/dist/index.js"(e) {
          "use strict";
          A(), Object.defineProperty(e, "__esModule", { value: true }), e.default = f;
          var n = Uo(), i = o(n), a = mf();
          function o(p2) {
            return p2 && p2.__esModule ? p2 : { default: p2 };
          }
          function f(p2) {
            return new i.default({ nodes: (0, a.parseMediaList)(p2), type: "media-query-list", value: p2.trim() });
          }
        } }), Wo = {};
        Ot(Wo, { basename: () => Jo, default: () => Qo, delimiter: () => _t, dirname: () => Ho, extname: () => Ko, isAbsolute: () => jt, join: () => Vo, normalize: () => Nt, relative: () => Go, resolve: () => mr, sep: () => wt });
        function $o(e, n) {
          for (var i = 0, a = e.length - 1; a >= 0; a--) {
            var o = e[a];
            o === "." ? e.splice(a, 1) : o === ".." ? (e.splice(a, 1), i++) : i && (e.splice(a, 1), i--);
          }
          if (n)
            for (; i--; i)
              e.unshift("..");
          return e;
        }
        function mr() {
          for (var e = "", n = false, i = arguments.length - 1; i >= -1 && !n; i--) {
            var a = i >= 0 ? arguments[i] : "/";
            if (typeof a != "string")
              throw new TypeError("Arguments to path.resolve must be strings");
            if (!a)
              continue;
            e = a + "/" + e, n = a.charAt(0) === "/";
          }
          return e = $o(Mt(e.split("/"), function(o) {
            return !!o;
          }), !n).join("/"), (n ? "/" : "") + e || ".";
        }
        function Nt(e) {
          var n = jt(e), i = Yo(e, -1) === "/";
          return e = $o(Mt(e.split("/"), function(a) {
            return !!a;
          }), !n).join("/"), !e && !n && (e = "."), e && i && (e += "/"), (n ? "/" : "") + e;
        }
        function jt(e) {
          return e.charAt(0) === "/";
        }
        function Vo() {
          var e = Array.prototype.slice.call(arguments, 0);
          return Nt(Mt(e, function(n, i) {
            if (typeof n != "string")
              throw new TypeError("Arguments to path.join must be strings");
            return n;
          }).join("/"));
        }
        function Go(e, n) {
          e = mr(e).substr(1), n = mr(n).substr(1);
          function i(c) {
            for (var t = 0; t < c.length && c[t] === ""; t++)
              ;
            for (var r = c.length - 1; r >= 0 && c[r] === ""; r--)
              ;
            return t > r ? [] : c.slice(t, r - t + 1);
          }
          for (var a = i(e.split("/")), o = i(n.split("/")), f = Math.min(a.length, o.length), p2 = f, h3 = 0; h3 < f; h3++)
            if (a[h3] !== o[h3]) {
              p2 = h3;
              break;
            }
          for (var g = [], h3 = p2; h3 < a.length; h3++)
            g.push("..");
          return g = g.concat(o.slice(p2)), g.join("/");
        }
        function Ho(e) {
          var n = wr(e), i = n[0], a = n[1];
          return !i && !a ? "." : (a && (a = a.substr(0, a.length - 1)), i + a);
        }
        function Jo(e, n) {
          var i = wr(e)[2];
          return n && i.substr(-1 * n.length) === n && (i = i.substr(0, i.length - n.length)), i;
        }
        function Ko(e) {
          return wr(e)[3];
        }
        function Mt(e, n) {
          if (e.filter)
            return e.filter(n);
          for (var i = [], a = 0; a < e.length; a++)
            n(e[a], a, e) && i.push(e[a]);
          return i;
        }
        var Is, wr, wt, _t, Qo, Yo, yf = Le({ "node-modules-polyfills:path"() {
          A(), Is = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, wr = function(e) {
            return Is.exec(e).slice(1);
          }, wt = "/", _t = ":", Qo = { extname: Ko, basename: Jo, dirname: Ho, sep: wt, delimiter: _t, relative: Go, join: Vo, isAbsolute: jt, normalize: Nt, resolve: mr }, Yo = "ab".substr(-1) === "b" ? function(e, n, i) {
            return e.substr(n, i);
          } : function(e, n, i) {
            return n < 0 && (n = e.length + n), e.substr(n, i);
          };
        } }), wf = R({ "node-modules-polyfills-commonjs:path"(e, n) {
          A();
          var i = (yf(), Tt(Wo));
          if (i && i.default) {
            n.exports = i.default;
            for (let a in i)
              n.exports[a] = i[a];
          } else
            i && (n.exports = i);
        } }), _f = R({ "node_modules/picocolors/picocolors.browser.js"(e, n) {
          A();
          var i = String, a = function() {
            return { isColorSupported: false, reset: i, bold: i, dim: i, italic: i, underline: i, inverse: i, hidden: i, strikethrough: i, black: i, red: i, green: i, yellow: i, blue: i, magenta: i, cyan: i, white: i, gray: i, bgBlack: i, bgRed: i, bgGreen: i, bgYellow: i, bgBlue: i, bgMagenta: i, bgCyan: i, bgWhite: i };
          };
          n.exports = a(), n.exports.createColors = a;
        } }), bf = R({ "(disabled):node_modules/postcss/lib/terminal-highlight"() {
          A();
        } }), Xo = R({ "node_modules/postcss/lib/css-syntax-error.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = o(_f()), a = o(bf());
          function o(m2) {
            return m2 && m2.__esModule ? m2 : { default: m2 };
          }
          function f(m2) {
            if (m2 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return m2;
          }
          function p2(m2, v) {
            m2.prototype = Object.create(v.prototype), m2.prototype.constructor = m2, m2.__proto__ = v;
          }
          function h3(m2) {
            var v = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
            return h3 = function(w) {
              if (w === null || !t(w))
                return w;
              if (typeof w != "function")
                throw new TypeError("Super expression must either be null or a function");
              if (typeof v < "u") {
                if (v.has(w))
                  return v.get(w);
                v.set(w, d);
              }
              function d() {
                return g(w, arguments, u(this).constructor);
              }
              return d.prototype = Object.create(w.prototype, { constructor: { value: d, enumerable: false, writable: true, configurable: true } }), r(d, w);
            }, h3(m2);
          }
          function g(m2, v, y) {
            return c() ? g = Reflect.construct : g = function(d, _, S) {
              var x = [null];
              x.push.apply(x, _);
              var N = Function.bind.apply(d, x), P = new N();
              return S && r(P, S.prototype), P;
            }, g.apply(null, arguments);
          }
          function c() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
              return false;
            if (typeof Proxy == "function")
              return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch {
              return false;
            }
          }
          function t(m2) {
            return Function.toString.call(m2).indexOf("[native code]") !== -1;
          }
          function r(m2, v) {
            return r = Object.setPrototypeOf || function(w, d) {
              return w.__proto__ = d, w;
            }, r(m2, v);
          }
          function u(m2) {
            return u = Object.setPrototypeOf ? Object.getPrototypeOf : function(y) {
              return y.__proto__ || Object.getPrototypeOf(y);
            }, u(m2);
          }
          var s = function(m2) {
            p2(v, m2);
            function v(w, d, _, S, x, N) {
              var P;
              return P = m2.call(this, w) || this, P.name = "CssSyntaxError", P.reason = w, x && (P.file = x), S && (P.source = S), N && (P.plugin = N), typeof d < "u" && typeof _ < "u" && (P.line = d, P.column = _), P.setMessage(), Error.captureStackTrace && Error.captureStackTrace(f(P), v), P;
            }
            var y = v.prototype;
            return y.setMessage = function() {
              this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
            }, y.showSourceCode = function(d) {
              var _ = this;
              if (!this.source)
                return "";
              var S = this.source;
              a.default && (typeof d > "u" && (d = i.default.isColorSupported), d && (S = (0, a.default)(S)));
              var x = S.split(/\r?\n/), N = Math.max(this.line - 3, 0), P = Math.min(this.line + 2, x.length), W = String(P).length;
              function U(D) {
                return d && i.default.red ? i.default.red(i.default.bold(D)) : D;
              }
              function H(D) {
                return d && i.default.gray ? i.default.gray(D) : D;
              }
              return x.slice(N, P).map(function(D, $2) {
                var B = N + 1 + $2, O = " " + (" " + B).slice(-W) + " | ";
                if (B === _.line) {
                  var j = H(O.replace(/\d/g, " ")) + D.slice(0, _.column - 1).replace(/[^\t]/g, " ");
                  return U(">") + H(O) + D + `
 ` + j + U("^");
                }
                return " " + H(O) + D;
              }).join(`
`);
            }, y.toString = function() {
              var d = this.showSourceCode();
              return d && (d = `

` + d + `
`), this.name + ": " + this.message + d;
            }, v;
          }(h3(Error)), l = s;
          e.default = l, n.exports = e.default;
        } }), xf = R({ "node_modules/postcss/lib/previous-map.js"(e, n) {
          A(), n.exports = class {
          };
        } }), _r = R({ "node_modules/postcss/lib/input.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = f(wf()), a = f(Xo()), o = f(xf());
          function f(r) {
            return r && r.__esModule ? r : { default: r };
          }
          function p2(r, u) {
            for (var s = 0; s < u.length; s++) {
              var l = u[s];
              l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(r, l.key, l);
            }
          }
          function h3(r, u, s) {
            return u && p2(r.prototype, u), s && p2(r, s), r;
          }
          var g = 0, c = function() {
            function r(s, l) {
              if (l === void 0 && (l = {}), s === null || typeof s > "u" || typeof s == "object" && !s.toString)
                throw new Error("PostCSS received " + s + " instead of CSS string");
              this.css = s.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, l.from && (/^\w+:\/\//.test(l.from) || i.default.isAbsolute(l.from) ? this.file = l.from : this.file = i.default.resolve(l.from));
              var m2 = new o.default(this.css, l);
              if (m2.text) {
                this.map = m2;
                var v = m2.consumer().file;
                !this.file && v && (this.file = this.mapResolve(v));
              }
              this.file || (g += 1, this.id = "<input css " + g + ">"), this.map && (this.map.file = this.from);
            }
            var u = r.prototype;
            return u.error = function(l, m2, v, y) {
              y === void 0 && (y = {});
              var w, d = this.origin(m2, v);
              return d ? w = new a.default(l, d.line, d.column, d.source, d.file, y.plugin) : w = new a.default(l, m2, v, this.css, this.file, y.plugin), w.input = { line: m2, column: v, source: this.css }, this.file && (w.input.file = this.file), w;
            }, u.origin = function(l, m2) {
              if (!this.map)
                return false;
              var v = this.map.consumer(), y = v.originalPositionFor({ line: l, column: m2 });
              if (!y.source)
                return false;
              var w = { file: this.mapResolve(y.source), line: y.line, column: y.column }, d = v.sourceContentFor(y.source);
              return d && (w.source = d), w;
            }, u.mapResolve = function(l) {
              return /^\w+:\/\//.test(l) ? l : i.default.resolve(this.map.consumer().sourceRoot || ".", l);
            }, h3(r, [{ key: "from", get: function() {
              return this.file || this.id;
            } }]), r;
          }(), t = c;
          e.default = t, n.exports = e.default;
        } }), br = R({ "node_modules/postcss/lib/stringifier.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = { colon: ": ", indent: "    ", beforeDecl: `
`, beforeRule: `
`, beforeOpen: " ", beforeClose: `
`, beforeComment: `
`, after: `
`, emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
          function a(p2) {
            return p2[0].toUpperCase() + p2.slice(1);
          }
          var o = function() {
            function p2(g) {
              this.builder = g;
            }
            var h3 = p2.prototype;
            return h3.stringify = function(c, t) {
              this[c.type](c, t);
            }, h3.root = function(c) {
              this.body(c), c.raws.after && this.builder(c.raws.after);
            }, h3.comment = function(c) {
              var t = this.raw(c, "left", "commentLeft"), r = this.raw(c, "right", "commentRight");
              this.builder("/*" + t + c.text + r + "*/", c);
            }, h3.decl = function(c, t) {
              var r = this.raw(c, "between", "colon"), u = c.prop + r + this.rawValue(c, "value");
              c.important && (u += c.raws.important || " !important"), t && (u += ";"), this.builder(u, c);
            }, h3.rule = function(c) {
              this.block(c, this.rawValue(c, "selector")), c.raws.ownSemicolon && this.builder(c.raws.ownSemicolon, c, "end");
            }, h3.atrule = function(c, t) {
              var r = "@" + c.name, u = c.params ? this.rawValue(c, "params") : "";
              if (typeof c.raws.afterName < "u" ? r += c.raws.afterName : u && (r += " "), c.nodes)
                this.block(c, r + u);
              else {
                var s = (c.raws.between || "") + (t ? ";" : "");
                this.builder(r + u + s, c);
              }
            }, h3.body = function(c) {
              for (var t = c.nodes.length - 1; t > 0 && c.nodes[t].type === "comment"; )
                t -= 1;
              for (var r = this.raw(c, "semicolon"), u = 0; u < c.nodes.length; u++) {
                var s = c.nodes[u], l = this.raw(s, "before");
                l && this.builder(l), this.stringify(s, t !== u || r);
              }
            }, h3.block = function(c, t) {
              var r = this.raw(c, "between", "beforeOpen");
              this.builder(t + r + "{", c, "start");
              var u;
              c.nodes && c.nodes.length ? (this.body(c), u = this.raw(c, "after")) : u = this.raw(c, "after", "emptyBody"), u && this.builder(u), this.builder("}", c, "end");
            }, h3.raw = function(c, t, r) {
              var u;
              if (r || (r = t), t && (u = c.raws[t], typeof u < "u"))
                return u;
              var s = c.parent;
              if (r === "before" && (!s || s.type === "root" && s.first === c))
                return "";
              if (!s)
                return i[r];
              var l = c.root();
              if (l.rawCache || (l.rawCache = {}), typeof l.rawCache[r] < "u")
                return l.rawCache[r];
              if (r === "before" || r === "after")
                return this.beforeAfter(c, r);
              var m2 = "raw" + a(r);
              return this[m2] ? u = this[m2](l, c) : l.walk(function(v) {
                if (u = v.raws[t], typeof u < "u")
                  return false;
              }), typeof u > "u" && (u = i[r]), l.rawCache[r] = u, u;
            }, h3.rawSemicolon = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length && r.last.type === "decl" && (t = r.raws.semicolon, typeof t < "u"))
                  return false;
              }), t;
            }, h3.rawEmptyBody = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length === 0 && (t = r.raws.after, typeof t < "u"))
                  return false;
              }), t;
            }, h3.rawIndent = function(c) {
              if (c.raws.indent)
                return c.raws.indent;
              var t;
              return c.walk(function(r) {
                var u = r.parent;
                if (u && u !== c && u.parent && u.parent === c && typeof r.raws.before < "u") {
                  var s = r.raws.before.split(`
`);
                  return t = s[s.length - 1], t = t.replace(/[^\s]/g, ""), false;
                }
              }), t;
            }, h3.rawBeforeComment = function(c, t) {
              var r;
              return c.walkComments(function(u) {
                if (typeof u.raws.before < "u")
                  return r = u.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeDecl") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, h3.rawBeforeDecl = function(c, t) {
              var r;
              return c.walkDecls(function(u) {
                if (typeof u.raws.before < "u")
                  return r = u.raws.before, r.indexOf(`
`) !== -1 && (r = r.replace(/[^\n]+$/, "")), false;
              }), typeof r > "u" ? r = this.raw(t, null, "beforeRule") : r && (r = r.replace(/[^\s]/g, "")), r;
            }, h3.rawBeforeRule = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && (r.parent !== c || c.first !== r) && typeof r.raws.before < "u")
                  return t = r.raws.before, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, h3.rawBeforeClose = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.nodes && r.nodes.length > 0 && typeof r.raws.after < "u")
                  return t = r.raws.after, t.indexOf(`
`) !== -1 && (t = t.replace(/[^\n]+$/, "")), false;
              }), t && (t = t.replace(/[^\s]/g, "")), t;
            }, h3.rawBeforeOpen = function(c) {
              var t;
              return c.walk(function(r) {
                if (r.type !== "decl" && (t = r.raws.between, typeof t < "u"))
                  return false;
              }), t;
            }, h3.rawColon = function(c) {
              var t;
              return c.walkDecls(function(r) {
                if (typeof r.raws.between < "u")
                  return t = r.raws.between.replace(/[^\s:]/g, ""), false;
              }), t;
            }, h3.beforeAfter = function(c, t) {
              var r;
              c.type === "decl" ? r = this.raw(c, null, "beforeDecl") : c.type === "comment" ? r = this.raw(c, null, "beforeComment") : t === "before" ? r = this.raw(c, null, "beforeRule") : r = this.raw(c, null, "beforeClose");
              for (var u = c.parent, s = 0; u && u.type !== "root"; )
                s += 1, u = u.parent;
              if (r.indexOf(`
`) !== -1) {
                var l = this.raw(c, null, "indent");
                if (l.length)
                  for (var m2 = 0; m2 < s; m2++)
                    r += l;
              }
              return r;
            }, h3.rawValue = function(c, t) {
              var r = c[t], u = c.raws[t];
              return u && u.value === r ? u.raw : r;
            }, p2;
          }(), f = o;
          e.default = f, n.exports = e.default;
        } }), Zo = R({ "node_modules/postcss/lib/stringify.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(br());
          function a(p2) {
            return p2 && p2.__esModule ? p2 : { default: p2 };
          }
          function o(p2, h3) {
            var g = new i.default(h3);
            g.stringify(p2);
          }
          var f = o;
          e.default = f, n.exports = e.default;
        } }), Dt = R({ "node_modules/postcss/lib/node.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = f(Xo()), a = f(br()), o = f(Zo());
          function f(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function p2(c, t) {
            var r = new c.constructor();
            for (var u in c)
              if (!!c.hasOwnProperty(u)) {
                var s = c[u], l = typeof s;
                u === "parent" && l === "object" ? t && (r[u] = t) : u === "source" ? r[u] = s : s instanceof Array ? r[u] = s.map(function(m2) {
                  return p2(m2, r);
                }) : (l === "object" && s !== null && (s = p2(s)), r[u] = s);
              }
            return r;
          }
          var h3 = function() {
            function c(r) {
              r === void 0 && (r = {}), this.raws = {};
              for (var u in r)
                this[u] = r[u];
            }
            var t = c.prototype;
            return t.error = function(u, s) {
              if (s === void 0 && (s = {}), this.source) {
                var l = this.positionBy(s);
                return this.source.input.error(u, l.line, l.column, s);
              }
              return new i.default(u);
            }, t.warn = function(u, s, l) {
              var m2 = { node: this };
              for (var v in l)
                m2[v] = l[v];
              return u.warn(s, m2);
            }, t.remove = function() {
              return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
            }, t.toString = function(u) {
              u === void 0 && (u = o.default), u.stringify && (u = u.stringify);
              var s = "";
              return u(this, function(l) {
                s += l;
              }), s;
            }, t.clone = function(u) {
              u === void 0 && (u = {});
              var s = p2(this);
              for (var l in u)
                s[l] = u[l];
              return s;
            }, t.cloneBefore = function(u) {
              u === void 0 && (u = {});
              var s = this.clone(u);
              return this.parent.insertBefore(this, s), s;
            }, t.cloneAfter = function(u) {
              u === void 0 && (u = {});
              var s = this.clone(u);
              return this.parent.insertAfter(this, s), s;
            }, t.replaceWith = function() {
              if (this.parent) {
                for (var u = arguments.length, s = new Array(u), l = 0; l < u; l++)
                  s[l] = arguments[l];
                for (var m2 = 0, v = s; m2 < v.length; m2++) {
                  var y = v[m2];
                  this.parent.insertBefore(this, y);
                }
                this.remove();
              }
              return this;
            }, t.next = function() {
              if (!!this.parent) {
                var u = this.parent.index(this);
                return this.parent.nodes[u + 1];
              }
            }, t.prev = function() {
              if (!!this.parent) {
                var u = this.parent.index(this);
                return this.parent.nodes[u - 1];
              }
            }, t.before = function(u) {
              return this.parent.insertBefore(this, u), this;
            }, t.after = function(u) {
              return this.parent.insertAfter(this, u), this;
            }, t.toJSON = function() {
              var u = {};
              for (var s in this)
                if (!!this.hasOwnProperty(s) && s !== "parent") {
                  var l = this[s];
                  l instanceof Array ? u[s] = l.map(function(m2) {
                    return typeof m2 == "object" && m2.toJSON ? m2.toJSON() : m2;
                  }) : typeof l == "object" && l.toJSON ? u[s] = l.toJSON() : u[s] = l;
                }
              return u;
            }, t.raw = function(u, s) {
              var l = new a.default();
              return l.raw(this, u, s);
            }, t.root = function() {
              for (var u = this; u.parent; )
                u = u.parent;
              return u;
            }, t.cleanRaws = function(u) {
              delete this.raws.before, delete this.raws.after, u || delete this.raws.between;
            }, t.positionInside = function(u) {
              for (var s = this.toString(), l = this.source.start.column, m2 = this.source.start.line, v = 0; v < u; v++)
                s[v] === `
` ? (l = 1, m2 += 1) : l += 1;
              return { line: m2, column: l };
            }, t.positionBy = function(u) {
              var s = this.source.start;
              if (u.index)
                s = this.positionInside(u.index);
              else if (u.word) {
                var l = this.toString().indexOf(u.word);
                l !== -1 && (s = this.positionInside(l));
              }
              return s;
            }, c;
          }(), g = h3;
          e.default = g, n.exports = e.default;
        } }), xr = R({ "node_modules/postcss/lib/comment.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(Dt());
          function a(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          function o(h3, g) {
            h3.prototype = Object.create(g.prototype), h3.prototype.constructor = h3, h3.__proto__ = g;
          }
          var f = function(h3) {
            o(g, h3);
            function g(c) {
              var t;
              return t = h3.call(this, c) || this, t.type = "comment", t;
            }
            return g;
          }(i.default), p2 = f;
          e.default = p2, n.exports = e.default;
        } }), ea = R({ "node_modules/postcss/lib/declaration.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(Dt());
          function a(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          function o(h3, g) {
            h3.prototype = Object.create(g.prototype), h3.prototype.constructor = h3, h3.__proto__ = g;
          }
          var f = function(h3) {
            o(g, h3);
            function g(c) {
              var t;
              return t = h3.call(this, c) || this, t.type = "decl", t;
            }
            return g;
          }(i.default), p2 = f;
          e.default = p2, n.exports = e.default;
        } }), Lt = R({ "node_modules/postcss/lib/tokenize.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = W;
          var i = "'".charCodeAt(0), a = '"'.charCodeAt(0), o = "\\".charCodeAt(0), f = "/".charCodeAt(0), p2 = `
`.charCodeAt(0), h3 = " ".charCodeAt(0), g = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), u = "]".charCodeAt(0), s = "(".charCodeAt(0), l = ")".charCodeAt(0), m2 = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), S = /[ \n\t\r\f{}()'"\\;/[\]#]/g, x = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, N = /.[\\/("'\n]/, P = /[a-f0-9]/i;
          function W(U, H) {
            H === void 0 && (H = {});
            var D = U.css.valueOf(), $2 = H.ignoreErrors, B, O, j, C, I, X, Z, Q, K, J, M, Y, G, E, k = D.length, b = -1, L = 1, q = 0, T = [], F = [];
            function z() {
              return q;
            }
            function re(te) {
              throw U.error("Unclosed " + te, L, q - b);
            }
            function ne() {
              return F.length === 0 && q >= k;
            }
            function ce(te) {
              if (F.length)
                return F.pop();
              if (!(q >= k)) {
                var ie = te ? te.ignoreUnclosed : false;
                switch (B = D.charCodeAt(q), (B === p2 || B === g || B === t && D.charCodeAt(q + 1) !== p2) && (b = q, L += 1), B) {
                  case p2:
                  case h3:
                  case c:
                  case t:
                  case g:
                    O = q;
                    do
                      O += 1, B = D.charCodeAt(O), B === p2 && (b = O, L += 1);
                    while (B === h3 || B === p2 || B === c || B === t || B === g);
                    E = ["space", D.slice(q, O)], q = O - 1;
                    break;
                  case r:
                  case u:
                  case m2:
                  case v:
                  case d:
                  case y:
                  case l:
                    var ae = String.fromCharCode(B);
                    E = [ae, ae, L, q - b];
                    break;
                  case s:
                    if (Y = T.length ? T.pop()[1] : "", G = D.charCodeAt(q + 1), Y === "url" && G !== i && G !== a && G !== h3 && G !== p2 && G !== c && G !== g && G !== t) {
                      O = q;
                      do {
                        if (J = false, O = D.indexOf(")", O + 1), O === -1)
                          if ($2 || ie) {
                            O = q;
                            break;
                          } else
                            re("bracket");
                        for (M = O; D.charCodeAt(M - 1) === o; )
                          M -= 1, J = !J;
                      } while (J);
                      E = ["brackets", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    } else
                      O = D.indexOf(")", q + 1), X = D.slice(q, O + 1), O === -1 || N.test(X) ? E = ["(", "(", L, q - b] : (E = ["brackets", X, L, q - b, L, O - b], q = O);
                    break;
                  case i:
                  case a:
                    j = B === i ? "'" : '"', O = q;
                    do {
                      if (J = false, O = D.indexOf(j, O + 1), O === -1)
                        if ($2 || ie) {
                          O = q + 1;
                          break;
                        } else
                          re("string");
                      for (M = O; D.charCodeAt(M - 1) === o; )
                        M -= 1, J = !J;
                    } while (J);
                    X = D.slice(q, O + 1), C = X.split(`
`), I = C.length - 1, I > 0 ? (Q = L + I, K = O - C[I].length) : (Q = L, K = b), E = ["string", D.slice(q, O + 1), L, q - b, Q, O - K], b = K, L = Q, q = O;
                    break;
                  case _:
                    S.lastIndex = q + 1, S.test(D), S.lastIndex === 0 ? O = D.length - 1 : O = S.lastIndex - 2, E = ["at-word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  case o:
                    for (O = q, Z = true; D.charCodeAt(O + 1) === o; )
                      O += 1, Z = !Z;
                    if (B = D.charCodeAt(O + 1), Z && B !== f && B !== h3 && B !== p2 && B !== c && B !== t && B !== g && (O += 1, P.test(D.charAt(O)))) {
                      for (; P.test(D.charAt(O + 1)); )
                        O += 1;
                      D.charCodeAt(O + 1) === h3 && (O += 1);
                    }
                    E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], q = O;
                    break;
                  default:
                    B === f && D.charCodeAt(q + 1) === w ? (O = D.indexOf("*/", q + 2) + 1, O === 0 && ($2 || ie ? O = D.length : re("comment")), X = D.slice(q, O + 1), C = X.split(`
`), I = C.length - 1, I > 0 ? (Q = L + I, K = O - C[I].length) : (Q = L, K = b), E = ["comment", X, L, q - b, Q, O - K], b = K, L = Q, q = O) : (x.lastIndex = q + 1, x.test(D), x.lastIndex === 0 ? O = D.length - 1 : O = x.lastIndex - 2, E = ["word", D.slice(q, O + 1), L, q - b, L, O - b], T.push(E), q = O);
                    break;
                }
                return q++, E;
              }
            }
            function fe(te) {
              F.push(te);
            }
            return { back: fe, nextToken: ce, endOfFile: ne, position: z };
          }
          n.exports = e.default;
        } }), ra = R({ "node_modules/postcss/lib/parse.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = o(zt()), a = o(_r());
          function o(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          function f(h3, g) {
            var c = new a.default(h3, g), t = new i.default(c);
            try {
              t.parse();
            } catch (r) {
              throw r;
            }
            return t.root;
          }
          var p2 = f;
          e.default = p2, n.exports = e.default;
        } }), kf = R({ "node_modules/postcss/lib/list.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = { split: function(f, p2, h3) {
            for (var g = [], c = "", t = false, r = 0, u = false, s = false, l = 0; l < f.length; l++) {
              var m2 = f[l];
              u ? s ? s = false : m2 === "\\" ? s = true : m2 === u && (u = false) : m2 === '"' || m2 === "'" ? u = m2 : m2 === "(" ? r += 1 : m2 === ")" ? r > 0 && (r -= 1) : r === 0 && p2.indexOf(m2) !== -1 && (t = true), t ? (c !== "" && g.push(c.trim()), c = "", t = false) : c += m2;
            }
            return (h3 || c !== "") && g.push(c.trim()), g;
          }, space: function(f) {
            var p2 = [" ", `
`, "	"];
            return i.split(f, p2);
          }, comma: function(f) {
            return i.split(f, [","], true);
          } }, a = i;
          e.default = a, n.exports = e.default;
        } }), ta = R({ "node_modules/postcss/lib/rule.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = o(kr()), a = o(kf());
          function o(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function f(t, r) {
            for (var u = 0; u < r.length; u++) {
              var s = r[u];
              s.enumerable = s.enumerable || false, s.configurable = true, "value" in s && (s.writable = true), Object.defineProperty(t, s.key, s);
            }
          }
          function p2(t, r, u) {
            return r && f(t.prototype, r), u && f(t, u), t;
          }
          function h3(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var g = function(t) {
            h3(r, t);
            function r(u) {
              var s;
              return s = t.call(this, u) || this, s.type = "rule", s.nodes || (s.nodes = []), s;
            }
            return p2(r, [{ key: "selectors", get: function() {
              return a.default.comma(this.selector);
            }, set: function(s) {
              var l = this.selector ? this.selector.match(/,\s*/) : null, m2 = l ? l[0] : "," + this.raw("between", "beforeOpen");
              this.selector = s.join(m2);
            } }]), r;
          }(i.default), c = g;
          e.default = c, n.exports = e.default;
        } }), kr = R({ "node_modules/postcss/lib/container.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = f(ea()), a = f(xr()), o = f(Dt());
          function f(m2) {
            return m2 && m2.__esModule ? m2 : { default: m2 };
          }
          function p2(m2, v) {
            var y;
            if (typeof Symbol > "u" || m2[Symbol.iterator] == null) {
              if (Array.isArray(m2) || (y = h3(m2)) || v && m2 && typeof m2.length == "number") {
                y && (m2 = y);
                var w = 0;
                return function() {
                  return w >= m2.length ? { done: true } : { done: false, value: m2[w++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return y = m2[Symbol.iterator](), y.next.bind(y);
          }
          function h3(m2, v) {
            if (!!m2) {
              if (typeof m2 == "string")
                return g(m2, v);
              var y = Object.prototype.toString.call(m2).slice(8, -1);
              if (y === "Object" && m2.constructor && (y = m2.constructor.name), y === "Map" || y === "Set")
                return Array.from(m2);
              if (y === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(y))
                return g(m2, v);
            }
          }
          function g(m2, v) {
            (v == null || v > m2.length) && (v = m2.length);
            for (var y = 0, w = new Array(v); y < v; y++)
              w[y] = m2[y];
            return w;
          }
          function c(m2, v) {
            for (var y = 0; y < v.length; y++) {
              var w = v[y];
              w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(m2, w.key, w);
            }
          }
          function t(m2, v, y) {
            return v && c(m2.prototype, v), y && c(m2, y), m2;
          }
          function r(m2, v) {
            m2.prototype = Object.create(v.prototype), m2.prototype.constructor = m2, m2.__proto__ = v;
          }
          function u(m2) {
            return m2.map(function(v) {
              return v.nodes && (v.nodes = u(v.nodes)), delete v.source, v;
            });
          }
          var s = function(m2) {
            r(v, m2);
            function v() {
              return m2.apply(this, arguments) || this;
            }
            var y = v.prototype;
            return y.push = function(d) {
              return d.parent = this, this.nodes.push(d), this;
            }, y.each = function(d) {
              this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
              var _ = this.lastEach;
              if (this.indexes[_] = 0, !!this.nodes) {
                for (var S, x; this.indexes[_] < this.nodes.length && (S = this.indexes[_], x = d(this.nodes[S], S), x !== false); )
                  this.indexes[_] += 1;
                return delete this.indexes[_], x;
              }
            }, y.walk = function(d) {
              return this.each(function(_, S) {
                var x;
                try {
                  x = d(_, S);
                } catch (P) {
                  if (P.postcssNode = _, P.stack && _.source && /\n\s{4}at /.test(P.stack)) {
                    var N = _.source;
                    P.stack = P.stack.replace(/\n\s{4}at /, "$&" + N.input.from + ":" + N.start.line + ":" + N.start.column + "$&");
                  }
                  throw P;
                }
                return x !== false && _.walk && (x = _.walk(d)), x;
              });
            }, y.walkDecls = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(S, x) {
                if (S.type === "decl" && d.test(S.prop))
                  return _(S, x);
              }) : this.walk(function(S, x) {
                if (S.type === "decl" && S.prop === d)
                  return _(S, x);
              }) : (_ = d, this.walk(function(S, x) {
                if (S.type === "decl")
                  return _(S, x);
              }));
            }, y.walkRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(S, x) {
                if (S.type === "rule" && d.test(S.selector))
                  return _(S, x);
              }) : this.walk(function(S, x) {
                if (S.type === "rule" && S.selector === d)
                  return _(S, x);
              }) : (_ = d, this.walk(function(S, x) {
                if (S.type === "rule")
                  return _(S, x);
              }));
            }, y.walkAtRules = function(d, _) {
              return _ ? d instanceof RegExp ? this.walk(function(S, x) {
                if (S.type === "atrule" && d.test(S.name))
                  return _(S, x);
              }) : this.walk(function(S, x) {
                if (S.type === "atrule" && S.name === d)
                  return _(S, x);
              }) : (_ = d, this.walk(function(S, x) {
                if (S.type === "atrule")
                  return _(S, x);
              }));
            }, y.walkComments = function(d) {
              return this.walk(function(_, S) {
                if (_.type === "comment")
                  return d(_, S);
              });
            }, y.append = function() {
              for (var d = arguments.length, _ = new Array(d), S = 0; S < d; S++)
                _[S] = arguments[S];
              for (var x = 0, N = _; x < N.length; x++)
                for (var P = N[x], W = this.normalize(P, this.last), U = p2(W), H; !(H = U()).done; ) {
                  var D = H.value;
                  this.nodes.push(D);
                }
              return this;
            }, y.prepend = function() {
              for (var d = arguments.length, _ = new Array(d), S = 0; S < d; S++)
                _[S] = arguments[S];
              _ = _.reverse();
              for (var x = p2(_), N; !(N = x()).done; ) {
                for (var P = N.value, W = this.normalize(P, this.first, "prepend").reverse(), U = p2(W), H; !(H = U()).done; ) {
                  var D = H.value;
                  this.nodes.unshift(D);
                }
                for (var $2 in this.indexes)
                  this.indexes[$2] = this.indexes[$2] + W.length;
              }
              return this;
            }, y.cleanRaws = function(d) {
              if (m2.prototype.cleanRaws.call(this, d), this.nodes)
                for (var _ = p2(this.nodes), S; !(S = _()).done; ) {
                  var x = S.value;
                  x.cleanRaws(d);
                }
            }, y.insertBefore = function(d, _) {
              d = this.index(d);
              for (var S = d === 0 ? "prepend" : false, x = this.normalize(_, this.nodes[d], S).reverse(), N = p2(x), P; !(P = N()).done; ) {
                var W = P.value;
                this.nodes.splice(d, 0, W);
              }
              var U;
              for (var H in this.indexes)
                U = this.indexes[H], d <= U && (this.indexes[H] = U + x.length);
              return this;
            }, y.insertAfter = function(d, _) {
              d = this.index(d);
              for (var S = this.normalize(_, this.nodes[d]).reverse(), x = p2(S), N; !(N = x()).done; ) {
                var P = N.value;
                this.nodes.splice(d + 1, 0, P);
              }
              var W;
              for (var U in this.indexes)
                W = this.indexes[U], d < W && (this.indexes[U] = W + S.length);
              return this;
            }, y.removeChild = function(d) {
              d = this.index(d), this.nodes[d].parent = void 0, this.nodes.splice(d, 1);
              var _;
              for (var S in this.indexes)
                _ = this.indexes[S], _ >= d && (this.indexes[S] = _ - 1);
              return this;
            }, y.removeAll = function() {
              for (var d = p2(this.nodes), _; !(_ = d()).done; ) {
                var S = _.value;
                S.parent = void 0;
              }
              return this.nodes = [], this;
            }, y.replaceValues = function(d, _, S) {
              return S || (S = _, _ = {}), this.walkDecls(function(x) {
                _.props && _.props.indexOf(x.prop) === -1 || _.fast && x.value.indexOf(_.fast) === -1 || (x.value = x.value.replace(d, S));
              }), this;
            }, y.every = function(d) {
              return this.nodes.every(d);
            }, y.some = function(d) {
              return this.nodes.some(d);
            }, y.index = function(d) {
              return typeof d == "number" ? d : this.nodes.indexOf(d);
            }, y.normalize = function(d, _) {
              var S = this;
              if (typeof d == "string") {
                var x = ra();
                d = u(x(d).nodes);
              } else if (Array.isArray(d)) {
                d = d.slice(0);
                for (var N = p2(d), P; !(P = N()).done; ) {
                  var W = P.value;
                  W.parent && W.parent.removeChild(W, "ignore");
                }
              } else if (d.type === "root") {
                d = d.nodes.slice(0);
                for (var U = p2(d), H; !(H = U()).done; ) {
                  var D = H.value;
                  D.parent && D.parent.removeChild(D, "ignore");
                }
              } else if (d.type)
                d = [d];
              else if (d.prop) {
                if (typeof d.value > "u")
                  throw new Error("Value field is missed in node creation");
                typeof d.value != "string" && (d.value = String(d.value)), d = [new i.default(d)];
              } else if (d.selector) {
                var $2 = ta();
                d = [new $2(d)];
              } else if (d.name) {
                var B = na();
                d = [new B(d)];
              } else if (d.text)
                d = [new a.default(d)];
              else
                throw new Error("Unknown node type in node creation");
              var O = d.map(function(j) {
                return j.parent && j.parent.removeChild(j), typeof j.raws.before > "u" && _ && typeof _.raws.before < "u" && (j.raws.before = _.raws.before.replace(/[^\s]/g, "")), j.parent = S, j;
              });
              return O;
            }, t(v, [{ key: "first", get: function() {
              if (!!this.nodes)
                return this.nodes[0];
            } }, { key: "last", get: function() {
              if (!!this.nodes)
                return this.nodes[this.nodes.length - 1];
            } }]), v;
          }(o.default), l = s;
          e.default = l, n.exports = e.default;
        } }), na = R({ "node_modules/postcss/lib/at-rule.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(kr());
          function a(h3) {
            return h3 && h3.__esModule ? h3 : { default: h3 };
          }
          function o(h3, g) {
            h3.prototype = Object.create(g.prototype), h3.prototype.constructor = h3, h3.__proto__ = g;
          }
          var f = function(h3) {
            o(g, h3);
            function g(t) {
              var r;
              return r = h3.call(this, t) || this, r.type = "atrule", r;
            }
            var c = g.prototype;
            return c.append = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var u = arguments.length, s = new Array(u), l = 0; l < u; l++)
                s[l] = arguments[l];
              return (r = h3.prototype.append).call.apply(r, [this].concat(s));
            }, c.prepend = function() {
              var r;
              this.nodes || (this.nodes = []);
              for (var u = arguments.length, s = new Array(u), l = 0; l < u; l++)
                s[l] = arguments[l];
              return (r = h3.prototype.prepend).call.apply(r, [this].concat(s));
            }, g;
          }(i.default), p2 = f;
          e.default = p2, n.exports = e.default;
        } }), Sf = R({ "node_modules/postcss/lib/map-generator.js"(e, n) {
          A(), n.exports = class {
            generate() {
            }
          };
        } }), Of = R({ "node_modules/postcss/lib/warn-once.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = a;
          var i = {};
          function a(o) {
            i[o] || (i[o] = true, typeof console < "u" && console.warn && console.warn(o));
          }
          n.exports = e.default;
        } }), Tf = R({ "node_modules/postcss/lib/warning.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = function() {
            function o(p2, h3) {
              if (h3 === void 0 && (h3 = {}), this.type = "warning", this.text = p2, h3.node && h3.node.source) {
                var g = h3.node.positionBy(h3);
                this.line = g.line, this.column = g.column;
              }
              for (var c in h3)
                this[c] = h3[c];
            }
            var f = o.prototype;
            return f.toString = function() {
              return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
            }, o;
          }(), a = i;
          e.default = a, n.exports = e.default;
        } }), Ef = R({ "node_modules/postcss/lib/result.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(Tf());
          function a(g) {
            return g && g.__esModule ? g : { default: g };
          }
          function o(g, c) {
            for (var t = 0; t < c.length; t++) {
              var r = c[t];
              r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(g, r.key, r);
            }
          }
          function f(g, c, t) {
            return c && o(g.prototype, c), t && o(g, t), g;
          }
          var p2 = function() {
            function g(t, r, u) {
              this.processor = t, this.messages = [], this.root = r, this.opts = u, this.css = void 0, this.map = void 0;
            }
            var c = g.prototype;
            return c.toString = function() {
              return this.css;
            }, c.warn = function(r, u) {
              u === void 0 && (u = {}), u.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (u.plugin = this.lastPlugin.postcssPlugin);
              var s = new i.default(r, u);
              return this.messages.push(s), s;
            }, c.warnings = function() {
              return this.messages.filter(function(r) {
                return r.type === "warning";
              });
            }, f(g, [{ key: "content", get: function() {
              return this.css;
            } }]), g;
          }(), h3 = p2;
          e.default = h3, n.exports = e.default;
        } }), ia = R({ "node_modules/postcss/lib/lazy-result.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = h3(Sf()), a = h3(Zo()), o = h3(Of()), f = h3(Ef()), p2 = h3(ra());
          function h3(v) {
            return v && v.__esModule ? v : { default: v };
          }
          function g(v, y) {
            var w;
            if (typeof Symbol > "u" || v[Symbol.iterator] == null) {
              if (Array.isArray(v) || (w = c(v)) || y && v && typeof v.length == "number") {
                w && (v = w);
                var d = 0;
                return function() {
                  return d >= v.length ? { done: true } : { done: false, value: v[d++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return w = v[Symbol.iterator](), w.next.bind(w);
          }
          function c(v, y) {
            if (!!v) {
              if (typeof v == "string")
                return t(v, y);
              var w = Object.prototype.toString.call(v).slice(8, -1);
              if (w === "Object" && v.constructor && (w = v.constructor.name), w === "Map" || w === "Set")
                return Array.from(v);
              if (w === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(w))
                return t(v, y);
            }
          }
          function t(v, y) {
            (y == null || y > v.length) && (y = v.length);
            for (var w = 0, d = new Array(y); w < y; w++)
              d[w] = v[w];
            return d;
          }
          function r(v, y) {
            for (var w = 0; w < y.length; w++) {
              var d = y[w];
              d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(v, d.key, d);
            }
          }
          function u(v, y, w) {
            return y && r(v.prototype, y), w && r(v, w), v;
          }
          function s(v) {
            return typeof v == "object" && typeof v.then == "function";
          }
          var l = function() {
            function v(w, d, _) {
              this.stringified = false, this.processed = false;
              var S;
              if (typeof d == "object" && d !== null && d.type === "root")
                S = d;
              else if (d instanceof v || d instanceof f.default)
                S = d.root, d.map && (typeof _.map > "u" && (_.map = {}), _.map.inline || (_.map.inline = false), _.map.prev = d.map);
              else {
                var x = p2.default;
                _.syntax && (x = _.syntax.parse), _.parser && (x = _.parser), x.parse && (x = x.parse);
                try {
                  S = x(d, _);
                } catch (N) {
                  this.error = N;
                }
              }
              this.result = new f.default(w, S, _);
            }
            var y = v.prototype;
            return y.warnings = function() {
              return this.sync().warnings();
            }, y.toString = function() {
              return this.css;
            }, y.then = function(d, _) {
              return this.async().then(d, _);
            }, y.catch = function(d) {
              return this.async().catch(d);
            }, y.finally = function(d) {
              return this.async().then(d, d);
            }, y.handleError = function(d, _) {
              try {
                if (this.error = d, d.name === "CssSyntaxError" && !d.plugin)
                  d.plugin = _.postcssPlugin, d.setMessage();
                else if (_.postcssVersion && false)
                  var S, x, N, P, W;
              } catch (U) {
                console && console.error && console.error(U);
              }
            }, y.asyncTick = function(d, _) {
              var S = this;
              if (this.plugin >= this.processor.plugins.length)
                return this.processed = true, d();
              try {
                var x = this.processor.plugins[this.plugin], N = this.run(x);
                this.plugin += 1, s(N) ? N.then(function() {
                  S.asyncTick(d, _);
                }).catch(function(P) {
                  S.handleError(P, x), S.processed = true, _(P);
                }) : this.asyncTick(d, _);
              } catch (P) {
                this.processed = true, _(P);
              }
            }, y.async = function() {
              var d = this;
              return this.processed ? new Promise(function(_, S) {
                d.error ? S(d.error) : _(d.stringify());
              }) : this.processing ? this.processing : (this.processing = new Promise(function(_, S) {
                if (d.error)
                  return S(d.error);
                d.plugin = 0, d.asyncTick(_, S);
              }).then(function() {
                return d.processed = true, d.stringify();
              }), this.processing);
            }, y.sync = function() {
              if (this.processed)
                return this.result;
              if (this.processed = true, this.processing)
                throw new Error("Use process(css).then(cb) to work with async plugins");
              if (this.error)
                throw this.error;
              for (var d = g(this.result.processor.plugins), _; !(_ = d()).done; ) {
                var S = _.value, x = this.run(S);
                if (s(x))
                  throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              return this.result;
            }, y.run = function(d) {
              this.result.lastPlugin = d;
              try {
                return d(this.result.root, this.result);
              } catch (_) {
                throw this.handleError(_, d), _;
              }
            }, y.stringify = function() {
              if (this.stringified)
                return this.result;
              this.stringified = true, this.sync();
              var d = this.result.opts, _ = a.default;
              d.syntax && (_ = d.syntax.stringify), d.stringifier && (_ = d.stringifier), _.stringify && (_ = _.stringify);
              var S = new i.default(_, this.result.root, this.result.opts), x = S.generate();
              return this.result.css = x[0], this.result.map = x[1], this.result;
            }, u(v, [{ key: "processor", get: function() {
              return this.result.processor;
            } }, { key: "opts", get: function() {
              return this.result.opts;
            } }, { key: "css", get: function() {
              return this.stringify().css;
            } }, { key: "content", get: function() {
              return this.stringify().content;
            } }, { key: "map", get: function() {
              return this.stringify().map;
            } }, { key: "root", get: function() {
              return this.sync().root;
            } }, { key: "messages", get: function() {
              return this.sync().messages;
            } }]), v;
          }(), m2 = l;
          e.default = m2, n.exports = e.default;
        } }), qf = R({ "node_modules/postcss/lib/processor.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(ia());
          function a(c) {
            return c && c.__esModule ? c : { default: c };
          }
          function o(c, t) {
            var r;
            if (typeof Symbol > "u" || c[Symbol.iterator] == null) {
              if (Array.isArray(c) || (r = f(c)) || t && c && typeof c.length == "number") {
                r && (c = r);
                var u = 0;
                return function() {
                  return u >= c.length ? { done: true } : { done: false, value: c[u++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return r = c[Symbol.iterator](), r.next.bind(r);
          }
          function f(c, t) {
            if (!!c) {
              if (typeof c == "string")
                return p2(c, t);
              var r = Object.prototype.toString.call(c).slice(8, -1);
              if (r === "Object" && c.constructor && (r = c.constructor.name), r === "Map" || r === "Set")
                return Array.from(c);
              if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
                return p2(c, t);
            }
          }
          function p2(c, t) {
            (t == null || t > c.length) && (t = c.length);
            for (var r = 0, u = new Array(t); r < t; r++)
              u[r] = c[r];
            return u;
          }
          var h3 = function() {
            function c(r) {
              r === void 0 && (r = []), this.version = "7.0.39", this.plugins = this.normalize(r);
            }
            var t = c.prototype;
            return t.use = function(u) {
              return this.plugins = this.plugins.concat(this.normalize([u])), this;
            }, t.process = function(r) {
              function u(s) {
                return r.apply(this, arguments);
              }
              return u.toString = function() {
                return r.toString();
              }, u;
            }(function(r, u) {
              return u === void 0 && (u = {}), this.plugins.length === 0 && (u.parser, u.stringifier), new i.default(this, r, u);
            }), t.normalize = function(u) {
              for (var s = [], l = o(u), m2; !(m2 = l()).done; ) {
                var v = m2.value;
                if (v.postcss === true) {
                  var y = v();
                  throw new Error("PostCSS plugin " + y.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`);
                }
                if (v.postcss && (v = v.postcss), typeof v == "object" && Array.isArray(v.plugins))
                  s = s.concat(v.plugins);
                else if (typeof v == "function")
                  s.push(v);
                else if (!(typeof v == "object" && (v.parse || v.stringify)))
                  throw typeof v == "object" && v.postcssPlugin ? new Error("PostCSS plugin " + v.postcssPlugin + ` requires PostCSS 8.
Migration guide for end-users:
https://github.com/postcss/postcss/wiki/PostCSS-8-for-end-users`) : new Error(v + " is not a PostCSS plugin");
              }
              return s;
            }, c;
          }(), g = h3;
          e.default = g, n.exports = e.default;
        } }), Af = R({ "node_modules/postcss/lib/root.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = a(kr());
          function a(t) {
            return t && t.__esModule ? t : { default: t };
          }
          function o(t, r) {
            var u;
            if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
              if (Array.isArray(t) || (u = f(t)) || r && t && typeof t.length == "number") {
                u && (t = u);
                var s = 0;
                return function() {
                  return s >= t.length ? { done: true } : { done: false, value: t[s++] };
                };
              }
              throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            return u = t[Symbol.iterator](), u.next.bind(u);
          }
          function f(t, r) {
            if (!!t) {
              if (typeof t == "string")
                return p2(t, r);
              var u = Object.prototype.toString.call(t).slice(8, -1);
              if (u === "Object" && t.constructor && (u = t.constructor.name), u === "Map" || u === "Set")
                return Array.from(t);
              if (u === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(u))
                return p2(t, r);
            }
          }
          function p2(t, r) {
            (r == null || r > t.length) && (r = t.length);
            for (var u = 0, s = new Array(r); u < r; u++)
              s[u] = t[u];
            return s;
          }
          function h3(t, r) {
            t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;
          }
          var g = function(t) {
            h3(r, t);
            function r(s) {
              var l;
              return l = t.call(this, s) || this, l.type = "root", l.nodes || (l.nodes = []), l;
            }
            var u = r.prototype;
            return u.removeChild = function(l, m2) {
              var v = this.index(l);
              return !m2 && v === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[v].raws.before), t.prototype.removeChild.call(this, l);
            }, u.normalize = function(l, m2, v) {
              var y = t.prototype.normalize.call(this, l);
              if (m2) {
                if (v === "prepend")
                  this.nodes.length > 1 ? m2.raws.before = this.nodes[1].raws.before : delete m2.raws.before;
                else if (this.first !== m2)
                  for (var w = o(y), d; !(d = w()).done; ) {
                    var _ = d.value;
                    _.raws.before = m2.raws.before;
                  }
              }
              return y;
            }, u.toResult = function(l) {
              l === void 0 && (l = {});
              var m2 = ia(), v = qf(), y = new m2(new v(), this, l);
              return y.stringify();
            }, r;
          }(i.default), c = g;
          e.default = c, n.exports = e.default;
        } }), zt = R({ "node_modules/postcss/lib/parser.js"(e, n) {
          "use strict";
          A(), e.__esModule = true, e.default = void 0;
          var i = g(ea()), a = g(Lt()), o = g(xr()), f = g(na()), p2 = g(Af()), h3 = g(ta());
          function g(t) {
            return t && t.__esModule ? t : { default: t };
          }
          var c = function() {
            function t(u) {
              this.input = u, this.root = new p2.default(), this.current = this.root, this.spaces = "", this.semicolon = false, this.createTokenizer(), this.root.source = { input: u, start: { line: 1, column: 1 } };
            }
            var r = t.prototype;
            return r.createTokenizer = function() {
              this.tokenizer = (0, a.default)(this.input);
            }, r.parse = function() {
              for (var s; !this.tokenizer.endOfFile(); )
                switch (s = this.tokenizer.nextToken(), s[0]) {
                  case "space":
                    this.spaces += s[1];
                    break;
                  case ";":
                    this.freeSemicolon(s);
                    break;
                  case "}":
                    this.end(s);
                    break;
                  case "comment":
                    this.comment(s);
                    break;
                  case "at-word":
                    this.atrule(s);
                    break;
                  case "{":
                    this.emptyRule(s);
                    break;
                  default:
                    this.other(s);
                    break;
                }
              this.endFile();
            }, r.comment = function(s) {
              var l = new o.default();
              this.init(l, s[2], s[3]), l.source.end = { line: s[4], column: s[5] };
              var m2 = s[1].slice(2, -2);
              if (/^\s*$/.test(m2))
                l.text = "", l.raws.left = m2, l.raws.right = "";
              else {
                var v = m2.match(/^(\s*)([^]*[^\s])(\s*)$/);
                l.text = v[2], l.raws.left = v[1], l.raws.right = v[3];
              }
            }, r.emptyRule = function(s) {
              var l = new h3.default();
              this.init(l, s[2], s[3]), l.selector = "", l.raws.between = "", this.current = l;
            }, r.other = function(s) {
              for (var l = false, m2 = null, v = false, y = null, w = [], d = [], _ = s; _; ) {
                if (m2 = _[0], d.push(_), m2 === "(" || m2 === "[")
                  y || (y = _), w.push(m2 === "(" ? ")" : "]");
                else if (w.length === 0)
                  if (m2 === ";")
                    if (v) {
                      this.decl(d);
                      return;
                    } else
                      break;
                  else if (m2 === "{") {
                    this.rule(d);
                    return;
                  } else if (m2 === "}") {
                    this.tokenizer.back(d.pop()), l = true;
                    break;
                  } else
                    m2 === ":" && (v = true);
                else
                  m2 === w[w.length - 1] && (w.pop(), w.length === 0 && (y = null));
                _ = this.tokenizer.nextToken();
              }
              if (this.tokenizer.endOfFile() && (l = true), w.length > 0 && this.unclosedBracket(y), l && v) {
                for (; d.length && (_ = d[d.length - 1][0], !(_ !== "space" && _ !== "comment")); )
                  this.tokenizer.back(d.pop());
                this.decl(d);
              } else
                this.unknownWord(d);
            }, r.rule = function(s) {
              s.pop();
              var l = new h3.default();
              this.init(l, s[0][2], s[0][3]), l.raws.between = this.spacesAndCommentsFromEnd(s), this.raw(l, "selector", s), this.current = l;
            }, r.decl = function(s) {
              var l = new i.default();
              this.init(l);
              var m2 = s[s.length - 1];
              for (m2[0] === ";" && (this.semicolon = true, s.pop()), m2[4] ? l.source.end = { line: m2[4], column: m2[5] } : l.source.end = { line: m2[2], column: m2[3] }; s[0][0] !== "word"; )
                s.length === 1 && this.unknownWord(s), l.raws.before += s.shift()[1];
              for (l.source.start = { line: s[0][2], column: s[0][3] }, l.prop = ""; s.length; ) {
                var v = s[0][0];
                if (v === ":" || v === "space" || v === "comment")
                  break;
                l.prop += s.shift()[1];
              }
              l.raws.between = "";
              for (var y; s.length; )
                if (y = s.shift(), y[0] === ":") {
                  l.raws.between += y[1];
                  break;
                } else
                  y[0] === "word" && /\w/.test(y[1]) && this.unknownWord([y]), l.raws.between += y[1];
              (l.prop[0] === "_" || l.prop[0] === "*") && (l.raws.before += l.prop[0], l.prop = l.prop.slice(1)), l.raws.between += this.spacesAndCommentsFromStart(s), this.precheckMissedSemicolon(s);
              for (var w = s.length - 1; w > 0; w--) {
                if (y = s[w], y[1].toLowerCase() === "!important") {
                  l.important = true;
                  var d = this.stringFrom(s, w);
                  d = this.spacesFromEnd(s) + d, d !== " !important" && (l.raws.important = d);
                  break;
                } else if (y[1].toLowerCase() === "important") {
                  for (var _ = s.slice(0), S = "", x = w; x > 0; x--) {
                    var N = _[x][0];
                    if (S.trim().indexOf("!") === 0 && N !== "space")
                      break;
                    S = _.pop()[1] + S;
                  }
                  S.trim().indexOf("!") === 0 && (l.important = true, l.raws.important = S, s = _);
                }
                if (y[0] !== "space" && y[0] !== "comment")
                  break;
              }
              this.raw(l, "value", s), l.value.indexOf(":") !== -1 && this.checkMissedSemicolon(s);
            }, r.atrule = function(s) {
              var l = new f.default();
              l.name = s[1].slice(1), l.name === "" && this.unnamedAtrule(l, s), this.init(l, s[2], s[3]);
              for (var m2, v, y = false, w = false, d = []; !this.tokenizer.endOfFile(); ) {
                if (s = this.tokenizer.nextToken(), s[0] === ";") {
                  l.source.end = { line: s[2], column: s[3] }, this.semicolon = true;
                  break;
                } else if (s[0] === "{") {
                  w = true;
                  break;
                } else if (s[0] === "}") {
                  if (d.length > 0) {
                    for (v = d.length - 1, m2 = d[v]; m2 && m2[0] === "space"; )
                      m2 = d[--v];
                    m2 && (l.source.end = { line: m2[4], column: m2[5] });
                  }
                  this.end(s);
                  break;
                } else
                  d.push(s);
                if (this.tokenizer.endOfFile()) {
                  y = true;
                  break;
                }
              }
              l.raws.between = this.spacesAndCommentsFromEnd(d), d.length ? (l.raws.afterName = this.spacesAndCommentsFromStart(d), this.raw(l, "params", d), y && (s = d[d.length - 1], l.source.end = { line: s[4], column: s[5] }, this.spaces = l.raws.between, l.raws.between = "")) : (l.raws.afterName = "", l.params = ""), w && (l.nodes = [], this.current = l);
            }, r.end = function(s) {
              this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = { line: s[2], column: s[3] }, this.current = this.current.parent) : this.unexpectedClose(s);
            }, r.endFile = function() {
              this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
            }, r.freeSemicolon = function(s) {
              if (this.spaces += s[1], this.current.nodes) {
                var l = this.current.nodes[this.current.nodes.length - 1];
                l && l.type === "rule" && !l.raws.ownSemicolon && (l.raws.ownSemicolon = this.spaces, this.spaces = "");
              }
            }, r.init = function(s, l, m2) {
              this.current.push(s), s.source = { start: { line: l, column: m2 }, input: this.input }, s.raws.before = this.spaces, this.spaces = "", s.type !== "comment" && (this.semicolon = false);
            }, r.raw = function(s, l, m2) {
              for (var v, y, w = m2.length, d = "", _ = true, S, x, N = /^([.|#])?([\w])+/i, P = 0; P < w; P += 1) {
                if (v = m2[P], y = v[0], y === "comment" && s.type === "rule") {
                  x = m2[P - 1], S = m2[P + 1], x[0] !== "space" && S[0] !== "space" && N.test(x[1]) && N.test(S[1]) ? d += v[1] : _ = false;
                  continue;
                }
                y === "comment" || y === "space" && P === w - 1 ? _ = false : d += v[1];
              }
              if (!_) {
                var W = m2.reduce(function(U, H) {
                  return U + H[1];
                }, "");
                s.raws[l] = { value: d, raw: W };
              }
              s[l] = d;
            }, r.spacesAndCommentsFromEnd = function(s) {
              for (var l, m2 = ""; s.length && (l = s[s.length - 1][0], !(l !== "space" && l !== "comment")); )
                m2 = s.pop()[1] + m2;
              return m2;
            }, r.spacesAndCommentsFromStart = function(s) {
              for (var l, m2 = ""; s.length && (l = s[0][0], !(l !== "space" && l !== "comment")); )
                m2 += s.shift()[1];
              return m2;
            }, r.spacesFromEnd = function(s) {
              for (var l, m2 = ""; s.length && (l = s[s.length - 1][0], l === "space"); )
                m2 = s.pop()[1] + m2;
              return m2;
            }, r.stringFrom = function(s, l) {
              for (var m2 = "", v = l; v < s.length; v++)
                m2 += s[v][1];
              return s.splice(l, s.length - l), m2;
            }, r.colon = function(s) {
              for (var l = 0, m2, v, y, w = 0; w < s.length; w++) {
                if (m2 = s[w], v = m2[0], v === "(" && (l += 1), v === ")" && (l -= 1), l === 0 && v === ":")
                  if (!y)
                    this.doubleColon(m2);
                  else {
                    if (y[0] === "word" && y[1] === "progid")
                      continue;
                    return w;
                  }
                y = m2;
              }
              return false;
            }, r.unclosedBracket = function(s) {
              throw this.input.error("Unclosed bracket", s[2], s[3]);
            }, r.unknownWord = function(s) {
              throw this.input.error("Unknown word", s[0][2], s[0][3]);
            }, r.unexpectedClose = function(s) {
              throw this.input.error("Unexpected }", s[2], s[3]);
            }, r.unclosedBlock = function() {
              var s = this.current.source.start;
              throw this.input.error("Unclosed block", s.line, s.column);
            }, r.doubleColon = function(s) {
              throw this.input.error("Double colon", s[2], s[3]);
            }, r.unnamedAtrule = function(s, l) {
              throw this.input.error("At-rule without name", l[2], l[3]);
            }, r.precheckMissedSemicolon = function() {
            }, r.checkMissedSemicolon = function(s) {
              var l = this.colon(s);
              if (l !== false) {
                for (var m2 = 0, v, y = l - 1; y >= 0 && (v = s[y], !(v[0] !== "space" && (m2 += 1, m2 === 2))); y--)
                  ;
                throw this.input.error("Missed semicolon", v[2], v[3]);
              }
            }, t;
          }();
          e.default = c, n.exports = e.default;
        } }), Pf = R({ "node_modules/postcss-less/lib/nodes/inline-comment.js"(e, n) {
          A();
          var i = Lt(), a = _r();
          n.exports = { isInlineComment(o) {
            if (o[0] === "word" && o[1].slice(0, 2) === "//") {
              let f = o, p2 = [], h3;
              for (; o; ) {
                if (/\r?\n/.test(o[1])) {
                  if (/['"].*\r?\n/.test(o[1])) {
                    p2.push(o[1].substring(0, o[1].indexOf(`
`)));
                    let c = o[1].substring(o[1].indexOf(`
`));
                    c += this.input.css.valueOf().substring(this.tokenizer.position()), this.input = new a(c), this.tokenizer = i(this.input);
                  } else
                    this.tokenizer.back(o);
                  break;
                }
                p2.push(o[1]), h3 = o, o = this.tokenizer.nextToken({ ignoreUnclosed: true });
              }
              let g = ["comment", p2.join(""), f[2], f[3], h3[2], h3[3]];
              return this.inlineComment(g), true;
            } else if (o[1] === "/") {
              let f = this.tokenizer.nextToken({ ignoreUnclosed: true });
              if (f[0] === "comment" && /^\/\*/.test(f[1]))
                return f[0] = "word", f[1] = f[1].slice(1), o[1] = "//", this.tokenizer.back(f), n.exports.isInlineComment.bind(this)(o);
            }
            return false;
          } };
        } }), Rf = R({ "node_modules/postcss-less/lib/nodes/interpolation.js"(e, n) {
          A(), n.exports = { interpolation(i) {
            let a = i, o = [i], f = ["word", "{", "}"];
            if (i = this.tokenizer.nextToken(), a[1].length > 1 || i[0] !== "{")
              return this.tokenizer.back(i), false;
            for (; i && f.includes(i[0]); )
              o.push(i), i = this.tokenizer.nextToken();
            let p2 = o.map((r) => r[1]);
            [a] = o;
            let h3 = o.pop(), g = [a[2], a[3]], c = [h3[4] || h3[2], h3[5] || h3[3]], t = ["word", p2.join("")].concat(g, c);
            return this.tokenizer.back(i), this.tokenizer.back(t), true;
          } };
        } }), If = R({ "node_modules/postcss-less/lib/nodes/mixin.js"(e, n) {
          A();
          var i = /^#[0-9a-fA-F]{6}$|^#[0-9a-fA-F]{3}$/, a = /\.[0-9]/, o = (f) => {
            let [, p2] = f, [h3] = p2;
            return (h3 === "." || h3 === "#") && i.test(p2) === false && a.test(p2) === false;
          };
          n.exports = { isMixinToken: o };
        } }), Cf = R({ "node_modules/postcss-less/lib/nodes/import.js"(e, n) {
          A();
          var i = Lt(), a = /^url\((.+)\)/;
          n.exports = (o) => {
            let { name: f, params: p2 = "" } = o;
            if (f === "import" && p2.length) {
              o.import = true;
              let h3 = i({ css: p2 });
              for (o.filename = p2.replace(a, "$1"); !h3.endOfFile(); ) {
                let [g, c] = h3.nextToken();
                if (g === "word" && c === "url")
                  return;
                if (g === "brackets") {
                  o.options = c, o.filename = p2.replace(c, "").trim();
                  break;
                }
              }
            }
          };
        } }), Nf = R({ "node_modules/postcss-less/lib/nodes/variable.js"(e, n) {
          A();
          var i = /:$/, a = /^:(\s+)?/;
          n.exports = (o) => {
            let { name: f, params: p2 = "" } = o;
            if (o.name.slice(-1) === ":") {
              if (i.test(f)) {
                let [h3] = f.match(i);
                o.name = f.replace(h3, ""), o.raws.afterName = h3 + (o.raws.afterName || ""), o.variable = true, o.value = o.params;
              }
              if (a.test(p2)) {
                let [h3] = p2.match(a);
                o.value = p2.replace(h3, ""), o.raws.afterName = (o.raws.afterName || "") + h3, o.variable = true;
              }
            }
          };
        } }), jf = R({ "node_modules/postcss-less/lib/LessParser.js"(e, n) {
          A();
          var i = xr(), a = zt(), { isInlineComment: o } = Pf(), { interpolation: f } = Rf(), { isMixinToken: p2 } = If(), h3 = Cf(), g = Nf(), c = /(!\s*important)$/i;
          n.exports = class extends a {
            constructor() {
              super(...arguments), this.lastNode = null;
            }
            atrule(r) {
              f.bind(this)(r) || (super.atrule(r), h3(this.lastNode), g(this.lastNode));
            }
            decl() {
              super.decl(...arguments), /extend\(.+\)/i.test(this.lastNode.value) && (this.lastNode.extend = true);
            }
            each(r) {
              r[0][1] = " ".concat(r[0][1]);
              let u = r.findIndex((y) => y[0] === "("), s = r.reverse().find((y) => y[0] === ")"), l = r.reverse().indexOf(s), v = r.splice(u, l).map((y) => y[1]).join("");
              for (let y of r.reverse())
                this.tokenizer.back(y);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.function = true, this.lastNode.params = v;
            }
            init(r, u, s) {
              super.init(r, u, s), this.lastNode = r;
            }
            inlineComment(r) {
              let u = new i(), s = r[1].slice(2);
              if (this.init(u, r[2], r[3]), u.source.end = { line: r[4], column: r[5] }, u.inline = true, u.raws.begin = "//", /^\s*$/.test(s))
                u.text = "", u.raws.left = s, u.raws.right = "";
              else {
                let l = s.match(/^(\s*)([^]*[^\s])(\s*)$/);
                [, u.raws.left, u.text, u.raws.right] = l;
              }
            }
            mixin(r) {
              let [u] = r, s = u[1].slice(0, 1), l = r.findIndex((d) => d[0] === "brackets"), m2 = r.findIndex((d) => d[0] === "("), v = "";
              if ((l < 0 || l > 3) && m2 > 0) {
                let d = r.reduce(($2, B, O) => B[0] === ")" ? O : $2), S = r.slice(m2, d + m2).map(($2) => $2[1]).join(""), [x] = r.slice(m2), N = [x[2], x[3]], [P] = r.slice(d, d + 1), W = [P[2], P[3]], U = ["brackets", S].concat(N, W), H = r.slice(0, m2), D = r.slice(d + 1);
                r = H, r.push(U), r = r.concat(D);
              }
              let y = [];
              for (let d of r)
                if ((d[1] === "!" || y.length) && y.push(d), d[1] === "important")
                  break;
              if (y.length) {
                let [d] = y, _ = r.indexOf(d), S = y[y.length - 1], x = [d[2], d[3]], N = [S[4], S[5]], P = y.map((U) => U[1]).join(""), W = ["word", P].concat(x, N);
                r.splice(_, y.length, W);
              }
              let w = r.findIndex((d) => c.test(d[1]));
              w > 0 && ([, v] = r[w], r.splice(w, 1));
              for (let d of r.reverse())
                this.tokenizer.back(d);
              this.atrule(this.tokenizer.nextToken()), this.lastNode.mixin = true, this.lastNode.raws.identifier = s, v && (this.lastNode.important = true, this.lastNode.raws.important = v);
            }
            other(r) {
              o.bind(this)(r) || super.other(r);
            }
            rule(r) {
              let u = r[r.length - 1], s = r[r.length - 2];
              if (s[0] === "at-word" && u[0] === "{" && (this.tokenizer.back(u), f.bind(this)(s))) {
                let m2 = this.tokenizer.nextToken();
                r = r.slice(0, r.length - 2).concat([m2]);
                for (let v of r.reverse())
                  this.tokenizer.back(v);
                return;
              }
              super.rule(r), /:extend\(.+\)/i.test(this.lastNode.selector) && (this.lastNode.extend = true);
            }
            unknownWord(r) {
              let [u] = r;
              if (r[0][1] === "each" && r[1][0] === "(") {
                this.each(r);
                return;
              }
              if (p2(u)) {
                this.mixin(r);
                return;
              }
              super.unknownWord(r);
            }
          };
        } }), Mf = R({ "node_modules/postcss-less/lib/LessStringifier.js"(e, n) {
          A();
          var i = br();
          n.exports = class extends i {
            atrule(o, f) {
              if (!o.mixin && !o.variable && !o.function) {
                super.atrule(o, f);
                return;
              }
              let p2 = o.function ? "" : o.raws.identifier || "@", h3 = "".concat(p2).concat(o.name), g = o.params ? this.rawValue(o, "params") : "", c = o.raws.important || "";
              if (o.variable && (g = o.value), typeof o.raws.afterName < "u" ? h3 += o.raws.afterName : g && (h3 += " "), o.nodes)
                this.block(o, h3 + g + c);
              else {
                let t = (o.raws.between || "") + c + (f ? ";" : "");
                this.builder(h3 + g + t, o);
              }
            }
            comment(o) {
              if (o.inline) {
                let f = this.raw(o, "left", "commentLeft"), p2 = this.raw(o, "right", "commentRight");
                this.builder("//".concat(f).concat(o.text).concat(p2), o);
              } else
                super.comment(o);
            }
          };
        } }), Df = R({ "node_modules/postcss-less/lib/index.js"(e, n) {
          A();
          var i = _r(), a = jf(), o = Mf();
          n.exports = { parse(f, p2) {
            let h3 = new i(f, p2), g = new a(h3);
            return g.parse(), g.root;
          }, stringify(f, p2) {
            new o(p2).stringify(f);
          }, nodeToString(f) {
            let p2 = "";
            return n.exports.stringify(f, (h3) => {
              p2 += h3;
            }), p2;
          } };
        } }), Lf = R({ "node_modules/postcss-scss/lib/scss-stringifier.js"(e, n) {
          "use strict";
          A();
          function i(f, p2) {
            f.prototype = Object.create(p2.prototype), f.prototype.constructor = f, f.__proto__ = p2;
          }
          var a = br(), o = function(f) {
            i(p2, f);
            function p2() {
              return f.apply(this, arguments) || this;
            }
            var h3 = p2.prototype;
            return h3.comment = function(c) {
              var t = this.raw(c, "left", "commentLeft"), r = this.raw(c, "right", "commentRight");
              if (c.raws.inline) {
                var u = c.raws.text || c.text;
                this.builder("//" + t + u + r, c);
              } else
                this.builder("/*" + t + c.text + r + "*/", c);
            }, h3.decl = function(c, t) {
              if (!c.isNested)
                f.prototype.decl.call(this, c, t);
              else {
                var r = this.raw(c, "between", "colon"), u = c.prop + r + this.rawValue(c, "value");
                c.important && (u += c.raws.important || " !important"), this.builder(u + "{", c, "start");
                var s;
                c.nodes && c.nodes.length ? (this.body(c), s = this.raw(c, "after")) : s = this.raw(c, "after", "emptyBody"), s && this.builder(s), this.builder("}", c, "end");
              }
            }, h3.rawValue = function(c, t) {
              var r = c[t], u = c.raws[t];
              return u && u.value === r ? u.scss ? u.scss : u.raw : r;
            }, p2;
          }(a);
          n.exports = o;
        } }), zf = R({ "node_modules/postcss-scss/lib/scss-stringify.js"(e, n) {
          "use strict";
          A();
          var i = Lf();
          n.exports = function(o, f) {
            var p2 = new i(f);
            p2.stringify(o);
          };
        } }), Bf = R({ "node_modules/postcss-scss/lib/nested-declaration.js"(e, n) {
          "use strict";
          A();
          function i(f, p2) {
            f.prototype = Object.create(p2.prototype), f.prototype.constructor = f, f.__proto__ = p2;
          }
          var a = kr(), o = function(f) {
            i(p2, f);
            function p2(h3) {
              var g;
              return g = f.call(this, h3) || this, g.type = "decl", g.isNested = true, g.nodes || (g.nodes = []), g;
            }
            return p2;
          }(a);
          n.exports = o;
        } }), Ff = R({ "node_modules/postcss-scss/lib/scss-tokenize.js"(e, n) {
          "use strict";
          A();
          var i = "'".charCodeAt(0), a = '"'.charCodeAt(0), o = "\\".charCodeAt(0), f = "/".charCodeAt(0), p2 = `
`.charCodeAt(0), h3 = " ".charCodeAt(0), g = "\f".charCodeAt(0), c = "	".charCodeAt(0), t = "\r".charCodeAt(0), r = "[".charCodeAt(0), u = "]".charCodeAt(0), s = "(".charCodeAt(0), l = ")".charCodeAt(0), m2 = "{".charCodeAt(0), v = "}".charCodeAt(0), y = ";".charCodeAt(0), w = "*".charCodeAt(0), d = ":".charCodeAt(0), _ = "@".charCodeAt(0), S = ",".charCodeAt(0), x = "#".charCodeAt(0), N = /[ \n\t\r\f{}()'"\\;/[\]#]/g, P = /[ \n\t\r\f(){}:;@!'"\\\][#]|\/(?=\*)/g, W = /.[\\/("'\n]/, U = /[a-f0-9]/i, H = /[\r\f\n]/g;
          n.exports = function($2, B) {
            B === void 0 && (B = {});
            var O = $2.css.valueOf(), j = B.ignoreErrors, C, I, X, Z, Q, K, J, M, Y, G, E, k, b, L, q = O.length, T = -1, F = 1, z = 0, re = [], ne = [];
            function ce(se) {
              throw $2.error("Unclosed " + se, F, z - T);
            }
            function fe() {
              return ne.length === 0 && z >= q;
            }
            function te() {
              for (var se = 1, le = false, pe = false; se > 0; )
                I += 1, O.length <= I && ce("interpolation"), C = O.charCodeAt(I), k = O.charCodeAt(I + 1), le ? !pe && C === le ? (le = false, pe = false) : C === o ? pe = !G : pe && (pe = false) : C === i || C === a ? le = C : C === v ? se -= 1 : C === x && k === m2 && (se += 1);
            }
            function ie() {
              if (ne.length)
                return ne.pop();
              if (!(z >= q)) {
                switch (C = O.charCodeAt(z), (C === p2 || C === g || C === t && O.charCodeAt(z + 1) !== p2) && (T = z, F += 1), C) {
                  case p2:
                  case h3:
                  case c:
                  case t:
                  case g:
                    I = z;
                    do
                      I += 1, C = O.charCodeAt(I), C === p2 && (T = I, F += 1);
                    while (C === h3 || C === p2 || C === c || C === t || C === g);
                    b = ["space", O.slice(z, I)], z = I - 1;
                    break;
                  case r:
                    b = ["[", "[", F, z - T];
                    break;
                  case u:
                    b = ["]", "]", F, z - T];
                    break;
                  case m2:
                    b = ["{", "{", F, z - T];
                    break;
                  case v:
                    b = ["}", "}", F, z - T];
                    break;
                  case S:
                    b = ["word", ",", F, z - T, F, z - T + 1];
                    break;
                  case d:
                    b = [":", ":", F, z - T];
                    break;
                  case y:
                    b = [";", ";", F, z - T];
                    break;
                  case s:
                    if (E = re.length ? re.pop()[1] : "", k = O.charCodeAt(z + 1), E === "url" && k !== i && k !== a) {
                      for (L = 1, G = false, I = z + 1; I <= O.length - 1; ) {
                        if (k = O.charCodeAt(I), k === o)
                          G = !G;
                        else if (k === s)
                          L += 1;
                        else if (k === l && (L -= 1, L === 0))
                          break;
                        I += 1;
                      }
                      K = O.slice(z, I + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = I - Z[Q].length) : (M = F, Y = T), b = ["brackets", K, F, z - T, M, I - Y], T = Y, F = M, z = I;
                    } else
                      I = O.indexOf(")", z + 1), K = O.slice(z, I + 1), I === -1 || W.test(K) ? b = ["(", "(", F, z - T] : (b = ["brackets", K, F, z - T, F, I - T], z = I);
                    break;
                  case l:
                    b = [")", ")", F, z - T];
                    break;
                  case i:
                  case a:
                    for (X = C, I = z, G = false; I < q && (I++, I === q && ce("string"), C = O.charCodeAt(I), k = O.charCodeAt(I + 1), !(!G && C === X)); )
                      C === o ? G = !G : G ? G = false : C === x && k === m2 && te();
                    K = O.slice(z, I + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = I - Z[Q].length) : (M = F, Y = T), b = ["string", O.slice(z, I + 1), F, z - T, M, I - Y], T = Y, F = M, z = I;
                    break;
                  case _:
                    N.lastIndex = z + 1, N.test(O), N.lastIndex === 0 ? I = O.length - 1 : I = N.lastIndex - 2, b = ["at-word", O.slice(z, I + 1), F, z - T, F, I - T], z = I;
                    break;
                  case o:
                    for (I = z, J = true; O.charCodeAt(I + 1) === o; )
                      I += 1, J = !J;
                    if (C = O.charCodeAt(I + 1), J && C !== f && C !== h3 && C !== p2 && C !== c && C !== t && C !== g && (I += 1, U.test(O.charAt(I)))) {
                      for (; U.test(O.charAt(I + 1)); )
                        I += 1;
                      O.charCodeAt(I + 1) === h3 && (I += 1);
                    }
                    b = ["word", O.slice(z, I + 1), F, z - T, F, I - T], z = I;
                    break;
                  default:
                    k = O.charCodeAt(z + 1), C === x && k === m2 ? (I = z, te(), K = O.slice(z, I + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = I - Z[Q].length) : (M = F, Y = T), b = ["word", K, F, z - T, M, I - Y], T = Y, F = M, z = I) : C === f && k === w ? (I = O.indexOf("*/", z + 2) + 1, I === 0 && (j ? I = O.length : ce("comment")), K = O.slice(z, I + 1), Z = K.split(`
`), Q = Z.length - 1, Q > 0 ? (M = F + Q, Y = I - Z[Q].length) : (M = F, Y = T), b = ["comment", K, F, z - T, M, I - Y], T = Y, F = M, z = I) : C === f && k === f ? (H.lastIndex = z + 1, H.test(O), H.lastIndex === 0 ? I = O.length - 1 : I = H.lastIndex - 2, K = O.slice(z, I + 1), b = ["comment", K, F, z - T, F, I - T, "inline"], z = I) : (P.lastIndex = z + 1, P.test(O), P.lastIndex === 0 ? I = O.length - 1 : I = P.lastIndex - 2, b = ["word", O.slice(z, I + 1), F, z - T, F, I - T], re.push(b), z = I);
                    break;
                }
                return z++, b;
              }
            }
            function ae(se) {
              ne.push(se);
            }
            return { back: ae, nextToken: ie, endOfFile: fe };
          };
        } }), Uf = R({ "node_modules/postcss-scss/lib/scss-parser.js"(e, n) {
          "use strict";
          A();
          function i(g, c) {
            g.prototype = Object.create(c.prototype), g.prototype.constructor = g, g.__proto__ = c;
          }
          var a = xr(), o = zt(), f = Bf(), p2 = Ff(), h3 = function(g) {
            i(c, g);
            function c() {
              return g.apply(this, arguments) || this;
            }
            var t = c.prototype;
            return t.createTokenizer = function() {
              this.tokenizer = p2(this.input);
            }, t.rule = function(u) {
              for (var s = false, l = 0, m2 = "", w = u, v = Array.isArray(w), y = 0, w = v ? w : w[Symbol.iterator](); ; ) {
                var d;
                if (v) {
                  if (y >= w.length)
                    break;
                  d = w[y++];
                } else {
                  if (y = w.next(), y.done)
                    break;
                  d = y.value;
                }
                var _ = d;
                if (s)
                  _[0] !== "comment" && _[0] !== "{" && (m2 += _[1]);
                else {
                  if (_[0] === "space" && _[1].indexOf(`
`) !== -1)
                    break;
                  _[0] === "(" ? l += 1 : _[0] === ")" ? l -= 1 : l === 0 && _[0] === ":" && (s = true);
                }
              }
              if (!s || m2.trim() === "" || /^[a-zA-Z-:#]/.test(m2))
                g.prototype.rule.call(this, u);
              else {
                u.pop();
                var S = new f();
                this.init(S);
                var x = u[u.length - 1];
                for (x[4] ? S.source.end = { line: x[4], column: x[5] } : S.source.end = { line: x[2], column: x[3] }; u[0][0] !== "word"; )
                  S.raws.before += u.shift()[1];
                for (S.source.start = { line: u[0][2], column: u[0][3] }, S.prop = ""; u.length; ) {
                  var N = u[0][0];
                  if (N === ":" || N === "space" || N === "comment")
                    break;
                  S.prop += u.shift()[1];
                }
                S.raws.between = "";
                for (var P; u.length; )
                  if (P = u.shift(), P[0] === ":") {
                    S.raws.between += P[1];
                    break;
                  } else
                    S.raws.between += P[1];
                (S.prop[0] === "_" || S.prop[0] === "*") && (S.raws.before += S.prop[0], S.prop = S.prop.slice(1)), S.raws.between += this.spacesAndCommentsFromStart(u), this.precheckMissedSemicolon(u);
                for (var W = u.length - 1; W > 0; W--) {
                  if (P = u[W], P[1] === "!important") {
                    S.important = true;
                    var U = this.stringFrom(u, W);
                    U = this.spacesFromEnd(u) + U, U !== " !important" && (S.raws.important = U);
                    break;
                  } else if (P[1] === "important") {
                    for (var H = u.slice(0), D = "", $2 = W; $2 > 0; $2--) {
                      var B = H[$2][0];
                      if (D.trim().indexOf("!") === 0 && B !== "space")
                        break;
                      D = H.pop()[1] + D;
                    }
                    D.trim().indexOf("!") === 0 && (S.important = true, S.raws.important = D, u = H);
                  }
                  if (P[0] !== "space" && P[0] !== "comment")
                    break;
                }
                this.raw(S, "value", u), S.value.indexOf(":") !== -1 && this.checkMissedSemicolon(u), this.current = S;
              }
            }, t.comment = function(u) {
              if (u[6] === "inline") {
                var s = new a();
                this.init(s, u[2], u[3]), s.raws.inline = true, s.source.end = { line: u[4], column: u[5] };
                var l = u[1].slice(2);
                if (/^\s*$/.test(l))
                  s.text = "", s.raws.left = l, s.raws.right = "";
                else {
                  var m2 = l.match(/^(\s*)([^]*[^\s])(\s*)$/), v = m2[2].replace(/(\*\/|\/\*)/g, "*//*");
                  s.text = v, s.raws.left = m2[1], s.raws.right = m2[3], s.raws.text = m2[2];
                }
              } else
                g.prototype.comment.call(this, u);
            }, t.raw = function(u, s, l) {
              if (g.prototype.raw.call(this, u, s, l), u.raws[s]) {
                var m2 = u.raws[s].raw;
                u.raws[s].raw = l.reduce(function(v, y) {
                  if (y[0] === "comment" && y[6] === "inline") {
                    var w = y[1].slice(2).replace(/(\*\/|\/\*)/g, "*//*");
                    return v + "/*" + w + "*/";
                  } else
                    return v + y[1];
                }, ""), m2 !== u.raws[s].raw && (u.raws[s].scss = m2);
              }
            }, c;
          }(o);
          n.exports = h3;
        } }), Wf = R({ "node_modules/postcss-scss/lib/scss-parse.js"(e, n) {
          "use strict";
          A();
          var i = _r(), a = Uf();
          n.exports = function(f, p2) {
            var h3 = new i(f, p2), g = new a(h3);
            return g.parse(), g.root;
          };
        } }), $f = R({ "node_modules/postcss-scss/lib/scss-syntax.js"(e, n) {
          "use strict";
          A();
          var i = zf(), a = Wf();
          n.exports = { parse: a, stringify: i };
        } });
        A();
        var Vf = ml(), pt = Cs(), Gf = Ns(), { hasPragma: Hf } = Tl(), { locStart: Jf, locEnd: Kf } = Js(), { calculateLoc: Qf, replaceQuotesInInlineComments: Yf } = Js(), Xf = Pl(), Zf = Rl(), ht = Il(), sa = Cl(), ep = Nl(), rp = jl(), tp = Ml(), np = Dl(), ip = (e) => {
          for (; e.parent; )
            e = e.parent;
          return e;
        };
        function sp(e, n) {
          let { nodes: i } = e, a = { open: null, close: null, groups: [], type: "paren_group" }, o = [a], f = a, p2 = { groups: [], type: "comma_group" }, h3 = [p2];
          for (let g = 0; g < i.length; ++g) {
            let c = i[g];
            if (sa(n.parser, c.value) && c.type === "number" && c.unit === ".." && pt(c.value) === "." && (c.value = c.value.slice(0, -1), c.unit = "..."), c.type === "func" && c.value === "selector" && (c.group.groups = [Ie(ip(e).text.slice(c.group.open.sourceIndex + 1, c.group.close.sourceIndex))]), c.type === "func" && c.value === "url") {
              let t = c.group && c.group.groups || [], r = [];
              for (let u = 0; u < t.length; u++) {
                let s = t[u];
                s.type === "comma_group" ? r = [...r, ...s.groups] : r.push(s);
              }
              if (Xf(r) || !Zf(r) && !rp(r[0])) {
                let u = tp({ groups: c.group.groups });
                c.group.groups = [u.trim()];
              }
            }
            if (c.type === "paren" && c.value === "(")
              a = { open: c, close: null, groups: [], type: "paren_group" }, o.push(a), p2 = { groups: [], type: "comma_group" }, h3.push(p2);
            else if (c.type === "paren" && c.value === ")") {
              if (p2.groups.length > 0 && a.groups.push(p2), a.close = c, h3.length === 1)
                throw new Error("Unbalanced parenthesis");
              h3.pop(), p2 = pt(h3), p2.groups.push(a), o.pop(), a = pt(o);
            } else
              c.type === "comma" ? (a.groups.push(p2), p2 = { groups: [], type: "comma_group" }, h3[h3.length - 1] = p2) : p2.groups.push(c);
          }
          return p2.groups.length > 0 && a.groups.push(p2), f;
        }
        function hr(e) {
          return e.type === "paren_group" && !e.open && !e.close && e.groups.length === 1 || e.type === "comma_group" && e.groups.length === 1 ? hr(e.groups[0]) : e.type === "paren_group" || e.type === "comma_group" ? Object.assign(Object.assign({}, e), {}, { groups: e.groups.map(hr) }) : e;
        }
        function Xe(e, n, i) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let a in e)
              Xe(e[a], n, i), a === "type" && typeof e[a] == "string" && !e[a].startsWith(n) && (!i || !i.test(e[a])) && (e[a] = n + e[a]);
          }
          return e;
        }
        function oa(e) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let n in e)
              oa(e[n]);
            !Array.isArray(e) && e.value && !e.type && (e.type = "unknown");
          }
          return e;
        }
        function aa(e, n) {
          if (e && typeof e == "object") {
            for (let i in e)
              i !== "parent" && (aa(e[i], n), i === "nodes" && (e.group = hr(sp(e, n)), delete e[i]));
            delete e.parent;
          }
          return e;
        }
        function Pe(e, n) {
          let i = lf(), a = null;
          try {
            a = i(e, { loose: true }).parse();
          } catch {
            return { type: "value-unknown", value: e };
          }
          a.text = e;
          let o = aa(a, n);
          return Xe(o, "value-", /^selector-/);
        }
        function Ie(e) {
          if (/\/\/|\/\*/.test(e))
            return { type: "selector-unknown", value: e.trim() };
          let n = vf(), i = null;
          try {
            n((a) => {
              i = a;
            }).process(e);
          } catch {
            return { type: "selector-unknown", value: e };
          }
          return Xe(i, "selector-");
        }
        function op(e) {
          let n = gf().default, i = null;
          try {
            i = n(e);
          } catch {
            return { type: "selector-unknown", value: e };
          }
          return Xe(oa(i), "media-");
        }
        var ap = /(\s*)(!default).*$/, up = /(\s*)(!global).*$/;
        function ua(e, n) {
          if (e && typeof e == "object") {
            delete e.parent;
            for (let f in e)
              ua(e[f], n);
            if (!e.type)
              return e;
            e.raws || (e.raws = {});
            let i = "";
            typeof e.selector == "string" && (i = e.raws.selector ? e.raws.selector.scss ? e.raws.selector.scss : e.raws.selector.raw : e.selector, e.raws.between && e.raws.between.trim().length > 0 && (i += e.raws.between), e.raws.selector = i);
            let a = "";
            typeof e.value == "string" && (a = e.raws.value ? e.raws.value.scss ? e.raws.value.scss : e.raws.value.raw : e.value, a = a.trim(), e.raws.value = a);
            let o = "";
            if (typeof e.params == "string" && (o = e.raws.params ? e.raws.params.scss ? e.raws.params.scss : e.raws.params.raw : e.params, e.raws.afterName && e.raws.afterName.trim().length > 0 && (o = e.raws.afterName + o), e.raws.between && e.raws.between.trim().length > 0 && (o = o + e.raws.between), o = o.trim(), e.raws.params = o), i.trim().length > 0)
              return i.startsWith("@") && i.endsWith(":") ? e : e.mixin ? (e.selector = Pe(i, n), e) : (ep(e) && (e.isSCSSNesterProperty = true), e.selector = Ie(i), e);
            if (a.length > 0) {
              let f = a.match(ap);
              f && (a = a.slice(0, f.index), e.scssDefault = true, f[0].trim() !== "!default" && (e.raws.scssDefault = f[0]));
              let p2 = a.match(up);
              if (p2 && (a = a.slice(0, p2.index), e.scssGlobal = true, p2[0].trim() !== "!global" && (e.raws.scssGlobal = p2[0])), a.startsWith("progid:"))
                return { type: "value-unknown", value: a };
              e.value = Pe(a, n);
            }
            if (ht(n) && e.type === "css-decl" && a.startsWith("extend(") && (e.extend || (e.extend = e.raws.between === ":"), e.extend && !e.selector && (delete e.value, e.selector = Ie(a.slice(7, -1)))), e.type === "css-atrule") {
              if (ht(n)) {
                if (e.mixin) {
                  let f = e.raws.identifier + e.name + e.raws.afterName + e.raws.params;
                  return e.selector = Ie(f), delete e.params, e;
                }
                if (e.function)
                  return e;
              }
              if (n.parser === "css" && e.name === "custom-selector") {
                let f = e.params.match(/:--\S+\s+/)[0].trim();
                return e.customSelector = f, e.selector = Ie(e.params.slice(f.length).trim()), delete e.params, e;
              }
              if (ht(n)) {
                if (e.name.includes(":") && !e.params) {
                  e.variable = true;
                  let f = e.name.split(":");
                  e.name = f[0], e.value = Pe(f.slice(1).join(":"), n);
                }
                if (!["page", "nest", "keyframes"].includes(e.name) && e.params && e.params[0] === ":" && (e.variable = true, e.value = Pe(e.params.slice(1), n), e.raws.afterName += ":"), e.variable)
                  return delete e.params, e;
              }
            }
            if (e.type === "css-atrule" && o.length > 0) {
              let { name: f } = e, p2 = e.name.toLowerCase();
              return f === "warn" || f === "error" ? (e.params = { type: "media-unknown", value: o }, e) : f === "extend" || f === "nest" ? (e.selector = Ie(o), delete e.params, e) : f === "at-root" ? (/^\(\s*(?:without|with)\s*:.+\)$/s.test(o) ? e.params = Pe(o, n) : (e.selector = Ie(o), delete e.params), e) : np(p2) ? (e.import = true, delete e.filename, e.params = Pe(o, n), e) : ["namespace", "supports", "if", "else", "for", "each", "while", "debug", "mixin", "include", "function", "return", "define-mixin", "add-mixin"].includes(f) ? (o = o.replace(/(\$\S+?)(\s+)?\.{3}/, "$1...$2"), o = o.replace(/^(?!if)(\S+)(\s+)\(/, "$1($2"), e.value = Pe(o, n), delete e.params, e) : ["media", "custom-media"].includes(p2) ? o.includes("#{") ? { type: "media-unknown", value: o } : (e.params = op(o), e) : (e.params = o, e);
            }
          }
          return e;
        }
        function ca(e, n, i) {
          let a = Gf(n), { frontMatter: o } = a;
          n = a.content;
          let f;
          try {
            f = e(n);
          } catch (p2) {
            let { name: h3, reason: g, line: c, column: t } = p2;
            throw typeof c != "number" ? p2 : Vf("".concat(h3, ": ").concat(g), { start: { line: c, column: t } });
          }
          return f = ua(Xe(f, "css-"), i), Qf(f, n), o && (o.source = { startOffset: 0, endOffset: o.raw.length }, f.nodes.unshift(o)), f;
        }
        function cp(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = sa(i.parser, e) ? [xt, bt] : [bt, xt], f;
          for (let p2 of o)
            try {
              return p2(e, n, i);
            } catch (h3) {
              f = f || h3;
            }
          if (f)
            throw f;
        }
        function bt(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = Df();
          return ca((o) => a.parse(Yf(o)), e, i);
        }
        function xt(e, n) {
          let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: a } = $f();
          return ca(a, e, i);
        }
        var dt = { astFormat: "postcss", hasPragma: Hf, locStart: Jf, locEnd: Kf };
        la.exports = { parsers: { css: Object.assign(Object.assign({}, dt), {}, { parse: cp }), less: Object.assign(Object.assign({}, dt), {}, { parse: bt }), scss: Object.assign(Object.assign({}, dt), {}, { parse: xt }) } };
      });
      return lp();
    });
  }
});

// js/ws.ts
init_define_process();
var import_lodash = __toESM(require_lodash(), 1);

// js/renderPreviewWindow.tsx
init_define_process();
init_react_preact();
init_react_preact();

// ../../.yarn/__virtual__/react-reverse-portal-virtual-1d0f51ed61/4/Users/z/.yarn/berry/cache/react-reverse-portal-npm-2.1.1-e50ec91de3-9.zip/node_modules/react-reverse-portal/dist/web/index.js
init_define_process();
init_react_preact();
init_react_preact();
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (b2.hasOwnProperty(p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ELEMENT_TYPE_HTML = "html";
var ELEMENT_TYPE_SVG = "svg";
var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
var validateElementType = function(domElement, elementType) {
  if (elementType === ELEMENT_TYPE_HTML) {
    return domElement instanceof HTMLElement;
  }
  if (elementType === ELEMENT_TYPE_SVG) {
    return domElement instanceof SVGElement;
  }
  throw new Error('Unrecognized element type "' + elementType + '" for validateElementType.');
};
var createPortalNode = function(elementType, options) {
  var initialProps = {};
  var parent;
  var lastPlaceholder;
  var element;
  if (elementType === ELEMENT_TYPE_HTML) {
    element = document.createElement("div");
  } else if (elementType === ELEMENT_TYPE_SVG) {
    element = document.createElementNS(SVG_NAMESPACE, "g");
  } else {
    throw new Error('Invalid element type "' + elementType + '" for createPortalNode: must be "html" or "svg".');
  }
  if (options && typeof options === "object") {
    for (var _i = 0, _a = Object.entries(options.attributes); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      element.setAttribute(key, value);
    }
  }
  var portalNode = {
    element,
    elementType,
    setPortalProps: function(props) {
      initialProps = props;
    },
    getInitialPortalProps: function() {
      return initialProps;
    },
    mount: function(newParent, newPlaceholder) {
      if (newPlaceholder === lastPlaceholder) {
        return;
      }
      portalNode.unmount();
      if (newParent !== parent) {
        if (!validateElementType(newParent, elementType)) {
          throw new Error('Invalid element type for portal: "' + elementType + '" portalNodes must be used with ' + elementType + " elements, but OutPortal is within <" + newParent.tagName + ">.");
        }
      }
      newParent.replaceChild(portalNode.element, newPlaceholder);
      parent = newParent;
      lastPlaceholder = newPlaceholder;
    },
    unmount: function(expectedPlaceholder) {
      if (expectedPlaceholder && expectedPlaceholder !== lastPlaceholder) {
        return;
      }
      if (parent && lastPlaceholder) {
        parent.replaceChild(lastPlaceholder, portalNode.element);
        parent = void 0;
        lastPlaceholder = void 0;
      }
    }
  };
  return portalNode;
};
var InPortal = function(_super) {
  __extends(InPortal2, _super);
  function InPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.addPropsChannel = function() {
      Object.assign(_this.props.node, {
        setPortalProps: function(props2) {
          _this.setState({ nodeProps: props2 });
        }
      });
    };
    _this.state = {
      nodeProps: _this.props.node.getInitialPortalProps()
    };
    return _this;
  }
  InPortal2.prototype.componentDidMount = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.componentDidUpdate = function() {
    this.addPropsChannel();
  };
  InPortal2.prototype.render = function() {
    var _this = this;
    var _a = this.props, children = _a.children, node = _a.node;
    return $(Children.map(children, function(child) {
      if (!isValidElement(child))
        return child;
      return cloneElement(child, _this.state.nodeProps);
    }), node.element);
  };
  return InPortal2;
}(PureComponent);
var OutPortal = function(_super) {
  __extends(OutPortal2, _super);
  function OutPortal2(props) {
    var _this = _super.call(this, props) || this;
    _this.placeholderNode = createRef();
    _this.passPropsThroughPortal();
    return _this;
  }
  OutPortal2.prototype.passPropsThroughPortal = function() {
    var propsForTarget = Object.assign({}, this.props, { node: void 0 });
    this.props.node.setPortalProps(propsForTarget);
  };
  OutPortal2.prototype.componentDidMount = function() {
    var node = this.props.node;
    this.currentPortalNode = node;
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentDidUpdate = function() {
    var node = this.props.node;
    if (this.currentPortalNode && node !== this.currentPortalNode) {
      this.currentPortalNode.unmount(this.placeholderNode.current);
      this.currentPortalNode.setPortalProps({});
      this.currentPortalNode = node;
    }
    var placeholder = this.placeholderNode.current;
    var parent = placeholder.parentNode;
    node.mount(parent, placeholder);
    this.passPropsThroughPortal();
  };
  OutPortal2.prototype.componentWillUnmount = function() {
    var node = this.props.node;
    node.unmount(this.placeholderNode.current);
    node.setPortalProps({});
  };
  OutPortal2.prototype.render = function() {
    return h("div", { ref: this.placeholderNode });
  };
  return OutPortal2;
}(PureComponent);
var createHtmlPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_HTML);
var createSvgPortalNode = createPortalNode.bind(null, ELEMENT_TYPE_SVG);

// js/renderPreviewWindow.tsx
var import_react15 = __toESM(require_emotion_react_cjs(), 1);

// js/starter.tsx
init_define_process();
var import_react2 = __toESM(require_emotion_react_cjs(), 1);
init_react_preact();

// js/ErrorBoundary.tsx
init_define_process();
init_react_preact();
var import_jsx_runtime = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var ErrorBoundary = class extends _n.Component {
  constructor(props) {
    super(props);
    this.state = { error: void 0, errorInfo: void 0 };
  }
  componentDidCatch(error, errorInfo) {
    this.setState({
      error,
      errorInfo
    });
  }
  render() {
    if (this.state.errorInfo) {
      return (0, import_jsx_runtime.jsxs)("div", {
        children: [
          (0, import_jsx_runtime.jsx)("h2", {
            children: "Something went wrong."
          }),
          (0, import_jsx_runtime.jsxs)("details", {
            style: { whiteSpace: "pre-wrap" },
            children: [
              this.state.error && this.state.error.toString(),
              (0, import_jsx_runtime.jsx)("br", {}),
              this.state.errorInfo.componentStack
            ]
          })
        ]
      });
    }
    return this.props.children || (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
};
var ErrorBoundary_default = ErrorBoundary;

// js/md5.js
init_define_process();
function md5(inputString) {
  const hc = "0123456789abcdef";
  function rh(n) {
    let j;
    let s = "";
    for (j = 0; j <= 3; j++) {
      s += hc.charAt(n >> j * 8 + 4 & 15) + hc.charAt(n >> j * 8 & 15);
    }
    return s;
  }
  function ad(x2, y) {
    const l = (x2 & 65535) + (y & 65535);
    const m2 = (x2 >> 16) + (y >> 16) + (l >> 16);
    return m2 << 16 | l & 65535;
  }
  function rl(n, c2) {
    return n << c2 | n >>> 32 - c2;
  }
  function cm(q, a2, b2, x2, s, t) {
    return ad(rl(ad(ad(a2, q), ad(x2, t)), s), b2);
  }
  function ff(a2, b2, c2, d2, x2, s, t) {
    return cm(b2 & c2 | ~b2 & d2, a2, b2, x2, s, t);
  }
  function gg(a2, b2, c2, d2, x2, s, t) {
    return cm(b2 & d2 | c2 & ~d2, a2, b2, x2, s, t);
  }
  function hh(a2, b2, c2, d2, x2, s, t) {
    return cm(b2 ^ c2 ^ d2, a2, b2, x2, s, t);
  }
  function ii(a2, b2, c2, d2, x2, s, t) {
    return cm(c2 ^ (b2 | ~d2), a2, b2, x2, s, t);
  }
  function sb(x2) {
    let i2;
    const nblk = (x2.length + 8 >> 6) + 1;
    const blks = Array.from({ length: nblk * 16 });
    for (i2 = 0; i2 < nblk * 16; i2++) {
      blks[i2] = 0;
    }
    for (i2 = 0; i2 < x2.length; i2++) {
      blks[i2 >> 2] |= x2.charCodeAt(i2) << i2 % 4 * 8;
    }
    blks[i2 >> 2] |= 128 << i2 % 4 * 8;
    blks[nblk * 16 - 2] = x2.length * 8;
    return blks;
  }
  let i;
  const x = sb(inputString);
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  let olda;
  let oldb;
  let oldc;
  let oldd;
  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = ff(a, b, c, d, x[i + 0], 7, -680876936);
    d = ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = ff(c, d, a, b, x[i + 10], 17, -42063);
    b = ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = gg(b, c, d, a, x[i + 0], 20, -373897302);
    a = gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = hh(a, b, c, d, x[i + 5], 4, -378558);
    d = hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = hh(d, a, b, c, x[i + 0], 11, -358537222);
    c = hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = ii(a, b, c, d, x[i + 0], 6, -198630844);
    d = ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = ad(a, olda);
    b = ad(b, oldb);
    c = ad(c, oldc);
    d = ad(d, oldd);
  }
  return rh(a) + rh(b) + rh(c) + rh(d);
}

// js/renderToString.tsx
init_define_process();
var renderFromString = (codeSpace2, hash) => {
  const md5hash = md5(mST().transpiled).slice(0, 8);
  if (hash !== hashCode()) {
    return { html: null, css: null };
  }
  const html = document.getElementById(`${codeSpace2}-${md5hash}`)?.innerHTML;
  const css7 = html ? extractCritical22(html) : "";
  return {
    html: `<div id="${codeSpace2}-${md5hash}" style="height:100%">${html}</div>`,
    css: css7
  };
};
var extractCritical22 = (html) => {
  try {
    const rules = {};
    for (const i in document.styleSheets) {
      let yesFromNow = false;
      const styleSheet = document.styleSheets[i];
      if (styleSheet?.cssRules) {
        for (const rule of Array.from(styleSheet.cssRules)) {
          if (yesFromNow || rule && rule.cssText && rule.cssText.startsWith(".css-")) {
            const selector = rule.cssText.slice(1, 9);
            const selectorText = selector;
            if (!rules[selector] && html.includes(selector) && !rule.cssText.slice(10).includes(".css-")) {
              yesFromNow = true;
              rules[selectorText] = rule.cssText;
            }
          }
        }
      }
    }
    return Object.keys(rules).map((r) => rules[r]).join(" ");
  } catch {
    console.error("no css");
    return "";
  }
};

// js/wait.ts
init_define_process();
async function wait(delay) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, delay);
  });
}

// js/starter.tsx
var import_jsx_runtime2 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
async function importShim(scr) {
  if (!document.scripts) {
    throw new Error("document.scripts");
  }
  const scripts = Array.from(document.scripts);
  const imap = scripts.find((s) => s.type === "importmap");
  if (!imap) {
    throw new Error("no imap");
  }
  await import("./chunk-es-module-shims-V26B5OGY.mjs");
  await window.importShim.addImportMap(
    JSON.parse(
      imap.innerText
    )
  );
  importShim = window.importShim;
  return importShim(scr);
}
var apps = {};
var AutoUpdateApp = ({ hash, codeSpace: codeSpace2 }) => {
  const md5Hash = md5(mST().transpiled).slice(0, 8);
  useEffect(() => {
    const { i } = mST();
    (async () => {
      await wait(100);
      if (i !== mST().i)
        return;
      const { html, css: css7 } = renderFromString(codeSpace2, hash);
      if (html && css7)
        patchSync({ ...mST(), html, css: css7 });
    })();
  }, [hash]);
  const ref = useRef(null);
  const transpiled = mST().transpiled;
  const App = apps[md5(transpiled)];
  return (0, import_jsx_runtime2.jsx)(ErrorBoundary_default, {
    ref,
    children: (0, import_jsx_runtime2.jsx)("div", {
      style: {
        height: "100%"
      },
      id: `${codeSpace2}-${md5Hash}`,
      children: (0, import_jsx_runtime2.jsx)(App, {})
    }, hash)
  });
};
async function appFactory(transpiled = "") {
  const trp = transpiled.length > 0 ? transpiled : mST().transpiled;
  const hash = md5(trp);
  if (!apps[hash]) {
    try {
      apps[hash] = (await importShim(createJsBlob(trp))).default;
    } catch (error) {
      if (error instanceof SyntaxError) {
        const name = error.name;
        const message = error.message;
        apps[hash] = () => (0, import_jsx_runtime2.jsxs)("div", {
          css: import_react2.css`
        background-color: orange;
        `,
          children: [
            (0, import_jsx_runtime2.jsx)("h1", {
              children: "Syntax Error"
            }),
            (0, import_jsx_runtime2.jsxs)("h2", {
              children: [
                name,
                ": ",
                message
              ]
            }),
            (0, import_jsx_runtime2.jsx)("p", {
              children: JSON.stringify({ err: error })
            })
          ]
        });
      } else if (error instanceof Error) {
        const name = error.name;
        const message = error.message;
        apps[hash] = () => (0, import_jsx_runtime2.jsxs)("div", {
          css: import_react2.css`
        background-color: orange;
        `,
          children: [
            (0, import_jsx_runtime2.jsx)("h1", {
              children: "Syntax Error"
            }),
            (0, import_jsx_runtime2.jsxs)("h2", {
              children: [
                name,
                ": ",
                message
              ]
            }),
            (0, import_jsx_runtime2.jsx)("p", {
              children: JSON.stringify({ err: error })
            })
          ]
        });
      } else {
        apps[hash] = () => (0, import_jsx_runtime2.jsx)("div", {
          css: import_react2.css`
        background-color: orange;
      `,
          children: (0, import_jsx_runtime2.jsxs)("h1", {
            children: [
              "Unknown Error: $",
              hash
            ]
          })
        });
      }
    }
  }
  return apps[hash];
}
function createJsBlob(code) {
  const file = new File([code], "index.mjs", {
    type: "application/javascript"
  });
  const blobUrl = URL.createObjectURL(file);
  return blobUrl;
}

// js/DraggableWindow.tsx
init_define_process();
var import_react10 = __toESM(require_emotion_react_cjs(), 1);
init_react_preact();

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/md/index.esm.js
init_define_process();

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/lib/esm/index.js
init_define_process();

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/lib/esm/iconsManifest.js
init_define_process();

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/lib/esm/iconBase.js
init_define_process();
init_react_preact();

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/lib/esm/iconContext.js
init_define_process();
init_react_preact();
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = _n.createContext && _n.createContext(DefaultContext);

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/lib/esm/iconBase.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i) {
    return _n.createElement(node.tag, __assign({
      key: i
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return _n.createElement(IconBase, __assign({
      attr: __assign({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return _n.createElement("svg", __assign({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign(__assign({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && _n.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? _n.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}

// ../../.yarn/__virtual__/react-icons-virtual-368142a91f/4/Users/z/.yarn/berry/cache/react-icons-npm-4.4.0-a6c91164a4-9.zip/node_modules/react-icons/md/index.esm.js
function MdQrCode(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M3 11h8V3H3v8zm2-6h4v4H5V5zM3 21h8v-8H3v8zm2-6h4v4H5v-4zM13 3v8h8V3h-8zm6 6h-4V5h4v4zM19 19h2v2h-2zM13 13h2v2h-2zM15 15h2v2h-2zM13 17h2v2h-2zM15 19h2v2h-2zM17 17h2v2h-2zM17 13h2v2h-2zM19 15h2v2h-2z" } }] })(props);
}
function MdPhoneAndroid(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M16 1H8C6.34 1 5 2.34 5 4v16c0 1.66 1.34 3 3 3h8c1.66 0 3-1.34 3-3V4c0-1.66-1.34-3-3-3zm-2 20h-4v-1h4v1zm3.25-3H6.75V4h10.5v14z" } }] })(props);
}
function MdTabletAndroid(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M18 0H6C4.34 0 3 1.34 3 3v18c0 1.66 1.34 3 3 3h12c1.66 0 3-1.34 3-3V3c0-1.66-1.34-3-3-3zm-4 22h-4v-1h4v1zm5.25-3H4.75V3h14.5v16z" } }] })(props);
}
function MdTv(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z" } }] })(props);
}
function MdFullscreen(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" } }] })(props);
}
function MdShare(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z" } }] })(props);
}

// js/Qr.tsx
init_define_process();
var import_react8 = __toESM(require_emotion_react_cjs(), 1);
init_react_preact();

// js/icons.tsx
init_define_process();
var import_react6 = __toESM(require_emotion_react_cjs(), 1);
var import_jsx_runtime3 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var Wrap = ({ children }) => (0, import_jsx_runtime3.jsx)("span", {
  css: import_react6.css`
font-size:20pt;
`,
  children
});
var QrCodeIcon = () => (0, import_jsx_runtime3.jsx)(Wrap, {
  children: (0, import_jsx_runtime3.jsx)(MdQrCode, {})
});
var Phone = () => (0, import_jsx_runtime3.jsx)(Wrap, {
  children: (0, import_jsx_runtime3.jsx)(MdPhoneAndroid, {})
});
var Share = () => (0, import_jsx_runtime3.jsx)(Wrap, {
  children: (0, import_jsx_runtime3.jsx)(MdShare, {})
});
var Tablet = () => (0, import_jsx_runtime3.jsx)(Wrap, {
  children: (0, import_jsx_runtime3.jsx)(MdTabletAndroid, {})
});
var Tv = () => (0, import_jsx_runtime3.jsx)(Wrap, {
  children: (0, import_jsx_runtime3.jsx)(MdTv, {})
});

// js/mui.tsx
init_define_process();
init_react_preact();
var import_jsx_runtime4 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var FabLazy = lazy(async () => import("./chunk-Fab-TRZJGXBG.mjs"));
var Fab = (props) => (0, import_jsx_runtime4.jsx)(Suspense, {
  children: (0, import_jsx_runtime4.jsx)(FabLazy, {
    ...props
  })
});
var ToggleButtonLazy = lazy(async () => import("./chunk-ToggleButton-4IOKXAHM.mjs"));
var ToggleButton = (props) => (0, import_jsx_runtime4.jsx)(Suspense, {
  children: (0, import_jsx_runtime4.jsx)(ToggleButtonLazy, {
    ...props
  })
});
var ToggleButtonGroupLazy = lazy(
  async () => import("./chunk-ToggleButtonGroup-MLIYRB4Q.mjs")
);
var ToggleButtonGroup = (props) => (0, import_jsx_runtime4.jsx)(Suspense, {
  children: (0, import_jsx_runtime4.jsx)(ToggleButtonGroupLazy, {
    ...props
  })
});

// js/Qr.tsx
var import_jsx_runtime5 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var QR = ({ url }) => (0, import_jsx_runtime5.jsx)(QRious, {
  value: url
});
var QRiousLazy = _n.lazy(
  async () => import("./chunk-lib-3NBL6X55.mjs").then(({ QRious: QRious2 }) => ({ default: QRious2 }))
);
var QRious = ({ value }) => (0, import_jsx_runtime5.jsx)(Suspense, {
  fallback: (0, import_jsx_runtime5.jsx)("p", {
    children: ".."
  }),
  children: (0, import_jsx_runtime5.jsx)(QRiousLazy, {
    value
  })
});
var QRButton = ({ url }) => {
  const [showQR, setQR] = useState(false);
  return (0, import_jsx_runtime5.jsx)(motion.div, {
    animate: {
      width: showQR ? 200 : 56,
      height: showQR ? 220 : 48
    },
    onClick: () => {
      setQR(!showQR);
    },
    css: import_react8.css`
          margin-top: 12px;
          margin-bottom: 12px;
              `,
    children: showQR ? (0, import_jsx_runtime5.jsx)(QR, {
      url: url || "/live/coder/public"
    }, url || origin + url) : (0, import_jsx_runtime5.jsx)(Fab, {
      children: (0, import_jsx_runtime5.jsx)(QrCodeIcon, {})
    })
  });
};

// js/DraggableWindow.tsx
var import_jsx_runtime6 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var breakPoints = [680, 768, 1920];
var breakPointHeights = [1137, 1024, 1080];
var sizes = [10, 25, 50, 75, 100];
var bg = `rgba(${Math.random() * 128 + 64}, ${Math.random() * 128 + 64}, ${Math.random() * 128 + 64}, ${!navigator.userAgent.includes("Firefox") ? 0.3 : 0.7})`;
var DraggableWindow = ({
  children,
  room
}) => {
  const [scaleRange, changeScaleRange] = useState(100);
  const startPositions = { bottom: 0, right: 0 };
  const [{ bottom, right }, setPositions] = useState(startPositions);
  const [width, setWidth] = useState(window.innerWidth * devicePixelRatio);
  const [height, setHeight] = useState(window.innerHeight * devicePixelRatio);
  const scale = scaleRange / 100;
  useEffect(() => {
    const reveal = async () => {
      setPositions({
        bottom: window.innerHeight * 0.2,
        right: window.innerWidth * 0.2
      });
      if (window.innerWidth / devicePixelRatio < 600) {
        changeScaleRange(50);
        setWidth(breakPoints[0]);
        setHeight(breakPointHeights[0]);
      }
      if (window.innerWidth / devicePixelRatio < 1200) {
        changeScaleRange(100);
        setWidth(breakPoints[0]);
        setHeight(breakPointHeights[0]);
      } else if (window.innerWidth / devicePixelRatio < 1800) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(50);
      } else if (window.innerWidth / devicePixelRatio < 2500) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(75);
      } else if (window.innerWidth / devicePixelRatio > 2500) {
        setWidth(breakPoints[1]);
        setHeight(breakPointHeights[1]);
        changeScaleRange(100);
      }
      setPositions({
        bottom: 20,
        right: 20
      });
    };
    reveal();
  }, []);
  const bgCV = window.getComputedStyle(document.body, null).getPropertyValue("background-color").slice(4, -1).split(",").slice(0, 3).map(
    (x) => Number(x) || "0"
  ).join(",");
  return (0, import_jsx_runtime6.jsx)(LazyMotion, {
    features: { ...domAnimation, ...domMax },
    children: (0, import_jsx_runtime6.jsx)(m.div, {
      transition: { delay: 0, duration: 0.4 },
      initial: {
        top: 0,
        padding: 0,
        right: 0,
        borderRadius: 0
      },
      animate: {
        top: bottom,
        padding: 8,
        right,
        borderRadius: 16
      },
      css: import_react10.css`
            touch-action: pinch-zoom;
            background-color: ${bg};
            backdrop-filter: blur(15px);
            z-index: 10;

            white-space: normal;
            position: fixed;
          `,
      drag: true,
      dragMomentum: false,
      dragConstraints: {
        left: 0,
        right: width - 20 - width / 6,
        bottom: innerHeight
      },
      dragElastic: 0.5,
      children: (0, import_jsx_runtime6.jsxs)("div", {
        css: import_react10.css` 
              display: flex;
              
                `,
        children: [
          (0, import_jsx_runtime6.jsxs)("div", {
            css: import_react10.css`
            display: flex;
            flex-direction: column;
            align-items: center;
          `,
            children: [
              (0, import_jsx_runtime6.jsx)(m.div, {
                transition: { delay: 0, duration: 0.4 },
                initial: { height: 0, width: 0 },
                animate: { height: "auto", width: "auto" },
                children: (0, import_jsx_runtime6.jsx)(ToggleButtonGroup, {
                  value: scaleRange,
                  size: "small",
                  exclusive: true,
                  onChange: (_e, newScale) => {
                    newScale && changeScaleRange(newScale);
                  },
                  children: sizes.map((size, ind) => (0, import_jsx_runtime6.jsx)(ToggleButton, {
                    value: size,
                    children: (0, import_jsx_runtime6.jsxs)("span", {
                      css: import_react10.css`
                       color: ${size === scaleRange ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                       `,
                      children: [
                        size,
                        "%"
                      ]
                    })
                  }, ind))
                })
              }),
              (0, import_jsx_runtime6.jsx)(m.div, {
                transition: { delay: 0, duration: 0.4 },
                initial: {
                  width: window.innerWidth,
                  height: window.innerHeight,
                  borderRadius: 0
                },
                animate: {
                  width: width * scale / devicePixelRatio,
                  height: height * scale / devicePixelRatio,
                  borderRadius: 8
                },
                css: import_react10.css`

                display: block;
                overflow: hidden;
                overflow-y: hidden;
            `,
                children: (0, import_jsx_runtime6.jsx)(m.div, {
                  transition: { delay: 0, duration: 0.4 },
                  initial: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    background: "rgba(0,0,0, 1)",
                    scale: 1
                  },
                  animate: {
                    background: "rgba(" + bgCV + ", 0.5)",
                    transformOrigin: "0px 0px",
                    width: width / devicePixelRatio,
                    height: height / devicePixelRatio,
                    scale: scaleRange / 100
                  },
                  "data-test-id": "z-body",
                  css: import_react10.css`
                  overflow:overlay;
                  overflow-y: hidden;
              `,
                  children
                })
              }),
              (0, import_jsx_runtime6.jsx)(m.div, {
                transition: { delay: 0, duration: 0.4 },
                children: (0, import_jsx_runtime6.jsx)(ToggleButtonGroup, {
                  value: width,
                  size: "small",
                  exclusive: true,
                  onChange: (_e, newSize) => {
                    if (newSize) {
                      setHeight(breakPointHeights[breakPoints.indexOf(newSize)]);
                      setWidth(newSize);
                    }
                  },
                  children: breakPoints.map((size, ind) => (0, import_jsx_runtime6.jsx)(ToggleButton, {
                    value: size,
                    children: size === 680 ? (0, import_jsx_runtime6.jsx)("span", {
                      css: import_react10.css`
                        color: ${width === 680 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                        `,
                      children: (0, import_jsx_runtime6.jsx)(Phone, {})
                    }) : size === 768 ? (0, import_jsx_runtime6.jsx)("span", {
                      css: import_react10.css`
                        color: ${width === 768 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                        `,
                      children: (0, import_jsx_runtime6.jsx)(Tablet, {})
                    }) : (0, import_jsx_runtime6.jsx)("span", {
                      css: import_react10.css`
                        color: ${width === 1920 ? "rgba(255,255,255,.8)" : "rgba(0,0,0,.3)"};
                      `,
                      children: (0, import_jsx_runtime6.jsx)(Tv, {})
                    })
                  }, ind))
                })
              })
            ]
          }),
          (0, import_jsx_runtime6.jsx)(m.div, {
            transition: { delay: 0, duration: 0.4 },
            initial: { height: 0, width: 0 },
            animate: { height: "100%", width: "auto" },
            children: (0, import_jsx_runtime6.jsxs)("div", {
              css: import_react10.css`
              padding: 16px;
              display: flex;
              overflow: "hidden";
              align-items: center;          
              flex-direction: column;
              `,
              children: [
                (0, import_jsx_runtime6.jsx)(Fab, {
                  onClick: () => {
                    document.querySelector("#root")?.requestFullscreen();
                  },
                  children: (0, import_jsx_runtime6.jsx)("span", {
                    css: import_react10.css`
                font-size: 20pt;
              `,
                    children: (0, import_jsx_runtime6.jsx)(MdFullscreen, {}, "fs")
                  })
                }, "fullscreen"),
                (0, import_jsx_runtime6.jsx)(QRButton, {
                  url: location.origin + `/live/${room}/public`
                }),
                (0, import_jsx_runtime6.jsx)(Fab, {
                  onClick: () => open(`/live/${room}/public`),
                  children: (0, import_jsx_runtime6.jsx)(Share, {})
                }, "Share")
              ]
            })
          })
        ]
      })
    })
  });
};

// js/Editor.tsx
init_define_process();
init_react_preact();
var import_react13 = __toESM(require_emotion_react_cjs(), 1);

// js/prettierEsm.ts
init_define_process();
var import_standalone = __toESM(require_standalone(), 1);
var import_parser_babel = __toESM(require_parser_babel(), 1);
var import_parser_html = __toESM(require_parser_html(), 1);
var import_parser_postcss = __toESM(require_parser_postcss(), 1);
var lastSuccessful = null;
var prettierJs = (code) => {
  try {
    const current = import_standalone.default.format(code, {
      arrowParens: "always",
      bracketSpacing: true,
      embeddedLanguageFormatting: "auto",
      insertPragma: false,
      bracketSameLine: true,
      jsxSingleQuote: false,
      htmlWhitespaceSensitivity: "strict",
      printWidth: 90,
      proseWrap: "preserve",
      quoteProps: "as-needed",
      requirePragma: false,
      semi: true,
      singleQuote: true,
      tabWidth: 2,
      trailingComma: "all",
      useTabs: false,
      parser: "babel-ts",
      plugins: [import_parser_babel.default, import_parser_html.default, import_parser_postcss.default]
    });
    return lastSuccessful = current;
  } catch (error) {
    console.error("prettier error"), console.error({ err: error });
    return lastSuccessful || code;
  }
};

// js/isMobile.mjs
init_define_process();
function isMobile() {
  const isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.userAgent.indexOf("SAMSUNG") === -1;
  let check = false;
  (function(a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[23]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(a.slice(0, 4))) {
      check = true;
    }
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check && !isIOS;
}

// js/Editor.tsx
var import_jsx_runtime7 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var mod = {
  CH() {
  },
  code: ""
};
var Editor = ({ code, i, codeSpace: codeSpace2, assets }) => {
  const ref = useRef(null);
  const [
    mySession,
    changeContent
  ] = useState({
    myCode: code,
    counter: i,
    started: false,
    async runner({ code: code2, counter: counter2, codeSpace: codeSpace3 }) {
      const { runner: runner2 } = await import("./chunk-runner-6CSUREMM.mjs");
      runner2({ code: prettierJs(code2), counter: counter2, codeSpace: codeSpace3 });
      changeContent((x) => ({
        ...x,
        runner: runner2,
        code: code2,
        counter: counter2
      }));
    },
    myId: "loading",
    getValue: () => "",
    setValue(_code) {
    },
    onChange(_cb) {
    },
    engine: isMobile() ? "ace" : "monaco"
  });
  mod.CH = () => changeContent;
  const {
    counter,
    myCode,
    started,
    myId,
    runner,
    engine,
    getValue,
    setValue,
    onChange
  } = mySession;
  mod.code = myCode;
  useEffect(() => {
    if (!ref?.current) {
      return;
    }
    const setMonaco = async () => {
      const link = document.createElement("link");
      link.setAttribute("rel", "stylesheet");
      link.href = location.origin + "/" + assets["ws.css"];
      document.head.append(link);
      const { startMonaco } = await import("./chunk-startMonaco-QRPKLESS.mjs");
      const { model, getTypeScriptWorker, setValue: setValue2 } = await startMonaco(
        {
          container: ref.current,
          name: codeSpace2,
          code: mST().code
        }
      );
      const getValue2 = () => {
        try {
          (async () => {
            const tsWorker = await (await getTypeScriptWorker())(
              model.uri
            );
            const diag = await tsWorker.getSemanticDiagnostics(
              location.origin + "/live/" + codeSpace2 + ".tsx"
            );
            console.log({ diag });
          })();
        } catch {
          console.error("ts diag error");
        }
        return prettierJs(model.getValue());
      };
      changeContent((x) => ({
        ...x,
        started: true,
        setValue: (code2) => {
          if (code2 === getValue2())
            return;
          setValue2(code2);
        },
        getValue: getValue2,
        onChange: (cb2) => model.onDidChangeContent(cb2).dispose,
        myId: "editor"
      }));
    };
    const setAce = async () => {
      const { startAce } = await import("./chunk-startAce-EPI3GJHC.mjs");
      const editor = await startAce(mST().code);
      const getValue2 = () => prettierJs(editor.session.getValue());
      changeContent((x) => ({
        ...x,
        onChange(cb2) {
          editor.session.on("change", cb2);
          return () => {
            editor.session.off("change", cb2);
          };
        },
        started: true,
        getValue: getValue2,
        setValue(code2) {
          if (code2 === getValue2())
            return;
          editor.session.setValue(code2);
        },
        myId: "editor"
      }));
    };
    const loadEditors = async () => {
      engine === "monaco" ? await setMonaco() : await setAce();
    };
    !started && loadEditors();
  }, [started, ref]);
  useEffect(() => {
    if (!started) {
      return;
    }
    const lastCode = mod.code;
    let last = 0;
    const handler = setInterval(() => {
      const now = Date.now();
      if (now - last < 5e3) {
        return;
      }
      last = now;
      if (getValue() !== lastCode) {
        const code2 = getValue();
        if (code2 === mST().code || code2 === mod.code) {
          return;
        }
        changeContent((x) => ({ ...x, myCode: code2, i: i + 1 }));
        runner({ code: code2, counter, codeSpace: codeSpace2 });
      }
    }, 5e3);
    onSessionUpdate(() => {
      const sess = mST();
      setTimeout(() => {
        if (mST().i <= counter) {
          return;
        }
        if (mST().i > sess.i) {
          return;
        }
        console.log("sessUP");
        setValue(sess.code);
        if (mod.CH() !== changeContent) {
          const ch = mod.CH();
          ch((x) => ({
            ...x,
            myCode: sess.code,
            counter: sess.i
          }));
        }
        changeContent((x) => ({
          ...x,
          myCode: sess.code,
          counter: sess.i
        }));
      }, 300);
    }, "editor");
    return () => {
      clearInterval(handler);
    };
  }, [changeContent, counter, myCode]);
  useEffect(() => {
    onChange(cb);
  }, [onChange]);
  useEffect(() => {
    if (!started)
      return;
    setValue(myCode);
    runner({ code: myCode, counter, codeSpace: codeSpace2 });
  }, [setValue, myCode, counter, codeSpace2, started]);
  return (0, import_jsx_runtime7.jsx)("div", {
    "data-test-id": myId,
    id: "editor",
    css: import_react13.css`
        
            max-width: 640px;
            height: 100%;
            
            
        `,
    ref
  });
  function cb() {
    const code2 = getValue();
    const newCode = prettierJs(code2);
    if (newCode === mod.code) {
      return;
    }
    if (newCode === mST().code) {
      return;
    }
    try {
      changeContent((x) => ({
        ...x,
        counter: mST().i + 1,
        myCode: newCode
      }));
    } catch (error) {
      console.error({ err: error });
      console.error("restore editor");
    }
  }
  ;
};

// js/renderPreviewWindow.tsx
var import_jsx_runtime8 = __toESM(require_emotion_react_jsx_runtime_cjs(), 1);
var RainbowContainer = ({ children }) => (0, import_jsx_runtime8.jsx)("div", {
  css: import_react15.css`
height: 100%;
width: 100%;
background-blend-mode: overlay;
background:  repeating-radial-gradient(circle at bottom left, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
            #e87f24 0, #e87f24 22.2222222222%, 
            #dd6227 0, #dd6227 27.7777777778%,
             #dc4c27 0, #dc4c27 33.3333333333%, 
            #ca3435 0, #ca3435 38.8888888889%, 
            #b82841 0, #b82841 44.4444444444%, 
            #953751 0, #953751 50%, #364c88 0, 
            #364c88 55.5555555556%, #16599d 0, 
            #16599d 61.1111111111%, #02609e 0, 
            #02609e 66.6666666667%, #0073a9 0, 
            #0073a9 72.2222222222%, #008aa4 0, 
            #008aa4 77.7777777778%, #239a87 0, 
            #239a87 83.3333333333%, #7cba6d 0, 
            #7cba6d 88.8888888889%, #becc2f 0, 
            #becc2f 94.4444444444%, #e0d81d 0, 
            #e0d81d 100%), 
            repeating-radial-gradient(circle at bottom right, 
              #fedc00 0, #fedc00 5.5555555556%, 
              #fcb712 0, #fcb712 11.1111111111%, 
              #f7921e 0, #f7921e 16.6666666667%, 
              #e87f24 0, #e87f24 22.2222222222%, 
              #dd6227 0, #dd6227 27.7777777778%, 
              #dc4c27 0, #dc4c27 33.3333333333%, 
              #ca3435 0, #ca3435 38.8888888889%, 
              #b82841 0, #b82841 44.4444444444%, 
              #953751 0, #953751 50%,
               #364c88 0, #364c88 55.5555555556%, 
               #16599d 0, #16599d 61.1111111111%, 
               #02609e 0, #02609e 66.6666666667%, 
               #0073a9 0, #0073a9 72.2222222222%, 
               #008aa4 0, #008aa4 77.7777777778%,
                #239a87 0, #239a87 83.3333333333%, 
                #7cba6d 0, #7cba6d 88.8888888889%, 
                #becc2f 0, #becc2f 94.4444444444%, 
                #e0d81d 0, #e0d81d 100%);
`,
  children
});
var AppToRender = ({ codeSpace: codeSpace2, assets }) => {
  const [hash, setHash] = useState(() => hashCode());
  const [isStandalone, setIsStandalone] = useState(true);
  useEffect(() => {
    onSessionUpdate(async () => {
      const newHash = hashCode();
      if (hash !== newHash) {
        try {
          await appFactory();
          setHash(newHash);
        } catch (error) {
          console.error({ e: error });
        }
      }
    }, "myApp");
  }, [hash, setHash]);
  useEffect(() => {
    setTimeout(() => {
      const isStandalone2 = location.pathname.endsWith("public") || location.pathname.endsWith("hydrated");
      setIsStandalone(isStandalone2);
    }, 800);
  }, []);
  const portalNode = useMemo(() => createHtmlPortalNode({
    attributes: { id: `root-${codeSpace2}`, style: "height: 100%" }
  }), []);
  return (0, import_jsx_runtime8.jsxs)(p, {
    children: [
      (0, import_jsx_runtime8.jsx)(InPortal, {
        node: portalNode,
        children: (0, import_jsx_runtime8.jsx)(AutoUpdateApp, {
          hash,
          codeSpace: codeSpace2
        })
      }),
      isStandalone ? (0, import_jsx_runtime8.jsx)(OutPortal, {
        node: portalNode
      }) : (0, import_jsx_runtime8.jsx)(RainbowContainer, {
        children: (0, import_jsx_runtime8.jsxs)(p, {
          children: [
            (0, import_jsx_runtime8.jsx)(Editor, {
              code: mST().code,
              i: mST().i,
              codeSpace: codeSpace2,
              assets
            }),
            (0, import_jsx_runtime8.jsx)(DraggableWindow, {
              hashCode: 0,
              room: codeSpace2,
              children: (0, import_jsx_runtime8.jsx)(OutPortal, {
                node: portalNode
              })
            })
          ]
        })
      })
    ]
  });
};
var renderPreviewWindow = ({ codeSpace: codeSpace2, assets }) => {
  const div = document.querySelector("#root");
  const root = createRoot(div);
  root.render(
    (0, import_jsx_runtime8.jsx)(p, {
      children: (0, import_jsx_runtime8.jsx)(AppToRender, {
        codeSpace: codeSpace2,
        assets
      })
    })
  );
};

// js/uidV4.mjs
init_define_process();
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error(
        "crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported"
      );
    }
  }
  return getRandomValues(rnds8);
}
var __default = /^(?:[\da-f]{8}-[\da-f]{4}-[1-5][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}|0{8}-(?:0{4}-){3}0{12})$/i;
function validate(uuid) {
  return typeof uuid === "string" && __default.test(uuid);
}
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function stringify(array) {
  const offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const uuid = (byteToHex[array[offset + 0]] + byteToHex[array[offset + 1]] + byteToHex[array[offset + 2]] + byteToHex[array[offset + 3]] + "-" + byteToHex[array[offset + 4]] + byteToHex[array[offset + 5]] + "-" + byteToHex[array[offset + 6]] + byteToHex[array[offset + 7]] + "-" + byteToHex[array[offset + 8]] + byteToHex[array[offset + 9]] + "-" + byteToHex[array[offset + 10]] + byteToHex[array[offset + 11]] + byteToHex[array[offset + 12]] + byteToHex[array[offset + 13]] + byteToHex[array[offset + 14]] + byteToHex[array[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw new TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i1 = 0; i1 < 16; ++i1) {
      buf[offset + i1] = rnds[i1];
    }
    return buf;
  }
  return stringify(rnds);
}

// js/ws.ts
var webRtcArray = [];
var user = (self && self.crypto && self.crypto.randomUUID && self.crypto.randomUUID() || v4()).slice(
  0,
  8
);
var rtcConns = {};
var bc;
var codeSpace;
var _hash = "";
var address;
var wsLastHashCode = 0;
var webRTCLastSeenHashCode = 0;
var lastSeenTimestamp = 0;
var lastSeenNow = 0;
var ws = null;
var sendWS;
var rejoined = false;
var sendChannel = {
  webRtcArray,
  rtcConns,
  send(data) {
    const messageString = JSON.stringify({
      ...data,
      name: data.name || user
    });
    webRtcArray.map((ch) => {
      try {
        console.log("WebRtc send", data, ch);
        if (ch.readyState !== "open") {
          return;
        }
        if (!data.target || ch.target === data.target && !ignoreUsers.includes(ch.target)) {
          ch.send(messageString);
        }
      } catch (error) {
        console.error("Error in broadcasting event", { e: error });
      }
    });
  }
};
var setWsLastHashCode = (hashCode2) => {
  wsLastHashCode = Number(hashCode2);
};
var run = async (startState) => {
  if (location.pathname.endsWith("dehydrated")) {
    return;
  }
  codeSpace = startState.codeSpace;
  address = startState.address;
  startSession(codeSpace, {
    name: user,
    state: startState.mST
  }, location.origin);
  bc = new BroadcastChannel("spike.land");
  bc.onmessage = async (event) => {
    if (event.data.ignoreUser && event.data.ignoreUser === user) {
      return;
    }
    console.log({ event });
    if (event.data.codeSpace === codeSpace && event.data.address && !address) {
      ws?.send(JSON.stringify({ codeSpace, address: event.data.address }));
    }
    if (event.data.ignoreUser) {
      !ignoreUsers.includes(event.data.ignoreUser) && ignoreUsers.push(event.data.ignoreUser);
    }
    if (event.data.codeSpace === codeSpace && event.data.sess.code !== mST().code) {
      const messageData = await makePatch(event.data.sess, setWsLastHashCode);
      await applyPatch(messageData);
    }
  };
  onSessionUpdate(
    () => {
      const sess = mST();
      const hash = md5(JSON.stringify(sess));
      if (hash === _hash)
        return;
      _hash = hash;
      bc.postMessage({
        ignoreUser: user,
        sess,
        codeSpace,
        address
      });
    },
    "broadcast"
  );
  await appFactory(startState.mST.transpiled);
  while (!mST().code) {
    console.log("mst.code is empty, waiting");
    await wait(100);
  }
  renderPreviewWindow(startState);
  await join();
};
var intervalHandler = null;
async function rejoin() {
  if (!rejoined || ws === null) {
    ws = null;
    const newWs = await join();
    return newWs;
  }
  return ws;
}
var ignoreUsers = [];
function saveCode() {
  debouncedSyncWs();
  debouncedSyncRTC();
}
var debouncedSyncRTC = (0, import_lodash.default)(syncRTC, 100, {
  trailing: true,
  leading: true,
  maxWait: 500
});
var debouncedSyncWs = (0, import_lodash.default)(syncWS, 1200, {
  trailing: true,
  leading: true,
  maxWait: 2500
});
async function syncWS() {
  try {
    if (ws) {
      if (wsLastHashCode === hashCode()) {
        return;
      }
      const sess = mST();
      console.log({ wsLastHashCode });
      const message = await makePatchFrom(
        wsLastHashCode,
        sess
      );
      if (!message) {
        return;
      }
      if (message.newHash !== hashCode()) {
        console.error("NEW hash is not even hashCode", hashCode());
        return;
      }
      const messageString = JSON.stringify({ ...message, name: user });
      sendWS(messageString);
    } else {
      rejoined = false;
      await rejoin();
    }
  } catch (error) {
    console.error("error 2", { e: error });
  }
}
async function syncRTC() {
  try {
    if (Object.keys(rtcConns).length > 0) {
      if (webRTCLastSeenHashCode === hashCode()) {
        return;
      }
      const sess = mST();
      console.log({ wsLastHashCode });
      const message = webRTCLastSeenHashCode ? await makePatchFrom(
        webRTCLastSeenHashCode,
        sess
      ) : await makePatch(sess);
      if (message && message.patch) {
        console.log("sendRTC");
        sendChannel.send(message);
      }
    }
  } catch (error) {
    console.error("Error sending RTC...", { e: error });
  }
}
async function join() {
  if (ws !== null) {
    return ws;
  }
  rejoined = true;
  console.log("WS connect!");
  if (location.host.includes("localhost")) {
    return;
  }
  const wsConnection = new WebSocket(
    `wss://${location.host}/live/` + codeSpace + "/websocket"
  );
  rejoined = false;
  wsConnection.addEventListener("open", () => {
    console.log("NEW WS CONNECTION");
    ws = wsConnection;
    const mess = (data) => {
      try {
        ws && ws?.send && ws?.send(data);
      } catch {
        ws = null;
        rejoined = false;
        rejoin();
      }
    };
    sendWS = mess;
    ws.addEventListener(
      "message",
      async (message) => processWsMessage(message, "ws")
    );
    if (intervalHandler) {
      clearInterval(intervalHandler);
    }
    intervalHandler = setInterval(() => {
      const now = Date.now();
      const diff = now - lastSeenNow;
      if (diff > 4e4) {
        try {
          if (wsConnection.readyState === wsConnection.OPEN) {
            wsConnection?.send(
              JSON.stringify({
                name: user,
                timestamp: lastSeenTimestamp + diff
              })
            );
            return;
          }
          rejoined = false;
          rejoin();
        } catch {
          rejoined = false;
          rejoin();
        }
      }
    }, 3e4);
    wsConnection.send(JSON.stringify({ name: user }));
    return wsConnection;
  });
  return wsConnection;
}
var h2 = {};
async function processWsMessage(event, source) {
  if (ws == null) {
    return;
  }
  lastSeenNow = Date.now();
  const data = JSON.parse(event.data);
  processData(data, source);
}
async function processData(data, source) {
  console.log("ws", data.name, data.oldHash, data.newHash);
  if (source === "ws" && data.timestamp) {
    lastSeenNow = Date.now();
    lastSeenTimestamp = data.timestamp;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "ws" && data.hashCode) {
    wsLastHashCode = data.hashCode;
  }
  if (source === "rtc" && data.hashCode || data.newHash) {
    webRTCLastSeenHashCode = data.hashCode || data.newHash;
  }
  if (ignoreUsers.includes(data.name)) {
    return;
  }
  if (data.newHash === hashCode()) {
    return;
  }
  if (data.oldHash && data.newHash) {
    if (h2[data.oldHash] && h2[data.oldHash] === data.newHash) {
      return;
    }
    h2[data.oldHash] = data.newHash;
  }
  if (data.newHash === hashCode()) {
    return;
  }
  (async () => {
    try {
      if (data.type === "new-ice-candidate") {
        await handleNewICECandidateMessage(data.candidate, data.name);
        return;
      }
      if (data.type === "offer") {
        await handleChatOffer(data.offer, data.name);
        return;
      }
      if (data.type === "answer") {
        await handleChatAnswerMessage(data.answer, data.name);
        return;
      }
      if (data.name && data.name !== user && !rtcConns[data.name]) {
        await createPeerConnection(data.name);
        return;
      }
    } catch (error) {
      console.log({ e: error });
      log_error("Error with p2p");
    }
  })();
  if (data.patch && data.name !== user) {
    if (data.newHash === hashCode()) {
      return;
    }
    await applyPatch(data);
    if (data.newHash === hashCode()) {
      if (sendChannel) {
        sendChannel.send({ hashCode: data.newHash });
      }
      return;
    }
    console.log("error -sending on sendChannel");
    return;
  }
  if (data.patch && data.name === user) {
    wsLastHashCode = data.newHash;
    return;
  }
  if (data.name === user) {
    return;
  }
  if (wsLastHashCode !== hashCode()) {
  }
  function createPeerConnection(target) {
    log(`Setting up a connection with ${target}`);
    if (rtcConns[target]) {
      log(`Aborting, since we have connection with this ${target}`);
      return;
    }
    rtcConns[target] = new RTCPeerConnection(
      rcpOptions
    );
    rtcConns[target].onicecandidate = (event) => {
      if (event.candidate) {
        log("*** Outgoing ICE candidate: " + event.candidate);
        ws?.send(JSON.stringify({
          type: "new-ice-candidate",
          target,
          name: user,
          candidate: event.candidate.toJSON()
        }));
      }
    };
    rtcConns[target].oniceconnectionstatechange = handleICEConnectionStateChangeEvent;
    rtcConns[target].onicegatheringstatechange = handleICEGatheringStateChangeEvent;
    rtcConns[target].onsignalingstatechange = () => {
      log(
        "*** rtcConns[target].signalingState  changed to: " + rtcConns[target].signalingState
      );
      switch (rtcConns[target].signalingState) {
        case "closed":
          break;
      }
    };
    rtcConns[target].onnegotiationneeded = handleNegotiationNeededEvent;
    rtcConns[target].ontrack = (ev) => {
      console.log(ev);
    };
    rtcConns[target].ondatachannel = (event) => {
      console.log("Receive Channel Callback");
      const rtc2 = event.channel;
      rtc2.binaryType = "arraybuffer";
      rtc2.addEventListener("close", onReceiveChannelClosed);
      rtc2.addEventListener(
        "message",
        async (message) => processWsMessage(message, "rtc")
      );
      const rtcWithTarget = Object.assign(rtc2, { target });
      webRtcArray.push(rtcWithTarget);
    };
    const dataChannelOptions = {
      ordered: true,
      reliable: true,
      maxPacketLifeTime: 3e3
    };
    const rtc = Object.assign(
      rtcConns[target].createDataChannel(
        target,
        dataChannelOptions
      ),
      { target }
    );
    rtc.binaryType = "arraybuffer";
    rtc.addEventListener("message", async (message) => {
      console.log("***********RTC***", { msg: message });
      const data2 = JSON.parse(message.data);
      if (data2 && data2.hashCode) {
        webRTCLastSeenHashCode = data2.hashCode;
      }
      if (data2 && data2.newHash) {
        webRTCLastSeenHashCode = data2.newHash;
      }
      return processWsMessage(message, "rtc");
    });
    rtc.addEventListener("error", (error) => {
      console.log("xxxxxx-  Data Channel Error:", error);
    });
    rtc.addEventListener("open", () => {
      console.log("@@@@@@@@RTC IS OPEN&&&&&&&&");
      webRtcArray.push(rtc);
    });
    rtc.addEventListener("close", () => {
      console.log("xxxxxxxx- The Data Channel is Closed");
    });
    return rtcConns[target];
    function onReceiveChannelClosed() {
      console.log("Receive channel is closed");
      rtcConns[target].close();
      delete rtcConns[target];
      console.log("Closed remote peer connection");
    }
    async function handleNegotiationNeededEvent() {
      log("*** Negotiation needed");
      try {
        log("---> Creating offer");
        const offer = await rtcConns[target].createOffer();
        if (rtcConns[target].signalingState != "stable") {
          log("The connection isn't stable yet; postponing...");
          return;
        }
        log("---> Setting local description to the offer");
        await rtcConns[target].setLocalDescription(offer);
        log("---> Sending the offer to the remote peer");
        ws?.send(JSON.stringify({
          target,
          name: user,
          type: "offer",
          offer: rtcConns[target].localDescription
        }));
      } catch {
        log(
          "*** The following error occurred while handling the negotiationneeded event:"
        );
      }
    }
    function handleICEConnectionStateChangeEvent() {
      log(
        "*** ICE connection state changed to " + rtcConns[target].iceConnectionState
      );
      switch (rtcConns[target].iceConnectionState) {
        case "closed":
        case "failed":
        case "disconnected":
          break;
      }
    }
    function handleICEGatheringStateChangeEvent() {
      log(
        "*** rtcConns[target].iceGatheringState changed to: " + rtcConns[target].iceGatheringState
      );
    }
  }
  async function handleChatAnswerMessage(answer, target) {
    log("*** Call recipient has accepted our call");
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(
        answer
      )
    ).catch(console.error);
  }
  async function handleChatOffer(offer, target) {
    if (!rtcConns[target]) {
      createPeerConnection(target);
    }
    await rtcConns[target].setRemoteDescription(
      new RTCSessionDescription(offer)
    );
    log("---> Creating and sending answer to caller");
    const answer = await rtcConns[target].createAnswer();
    await rtcConns[target].setLocalDescription(
      answer
    );
    ws?.send(JSON.stringify({
      target,
      name: user,
      type: "answer",
      answer
    }));
  }
}
function log(text) {
  const time = new Date();
  console.log("[" + time.toLocaleTimeString() + "] " + text);
}
function log_error(text) {
  const time = new Date();
  console.trace("[" + time.toLocaleTimeString() + "] " + text);
}
var rcpOptions = {
  iceServers: ["stun3.l.google.com:19302"].map((url) => ({
    urls: `stun:${url}`
  }))
};
rcpOptions.iceServers = [{ urls: "stun:stun.stunprotocol.org:3478" }, {
  urls: "stun:stun.l.google.com:19302"
}];
async function handleNewICECandidateMessage(init, target) {
  log(
    "*** Adding received ICE candidate: " + JSON.stringify(init)
  );
  const candidate = new RTCIceCandidate(init);
  console.log(rtcConns[target]);
  await rtcConns[target].addIceCandidate(candidate);
}
async function sw() {
  try {
    navigator.serviceWorker.onmessage = async (event) => {
      const serviceWorker = event.source;
      if (serviceWorker == null) {
        return;
      }
      switch (event.data.method) {
        case "ipfs-message-port":
          console.log("Message port request");
          const channel = new MessageChannel();
          {
            serviceWorker.postMessage({
              method: "ipfs-message-port",
              id: event.data.id,
              port: channel.port2
            }, { transfer: [channel.port2] });
          }
      }
    };
    if (document.documentElement.dataset.viewer) {
      const load = async (path) => {
        const paths = path && path.split("/") || [];
        const protocol = paths[0] || "";
        switch (protocol) {
          case "ipfs":
          case "ipns": {
            document.body.innerHTML = `<iframe id="viewer" style="width:100%;height:100%;position:fixed;top:0;left:0;border:none;" src="/view${path}"></iframe>`;
          }
        }
      };
      await load(location.pathname);
      return;
    }
  } catch {
    console.log("ipfs load error");
  }
}

export {
  run,
  saveCode,
  join,
  sw
};
