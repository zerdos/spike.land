# eslint.config.mts

```mts
import js from "@eslint/js";
import reactPlugin from "eslint-plugin-react";
import reactHooks from "eslint-plugin-react-hooks";
import reactRefresh from "eslint-plugin-react-refresh";
import globals from "globals";
import tsEslint from "typescript-eslint";

export default tsEslint.config(
  {
    ignores: [
      "dist",
      "dts",
      "node_modules",
      "**/*.d.ts",
      "**/*.config.js",
      "**/*.config.ts",
    ],
  },
  {
    files: ["src/**/*.{ts,tsx}"],
    extends: [
      js.configs.recommended,
      ...tsEslint.configs.recommended,
      ...tsEslint.configs.stylistic,
    ],
    languageOptions: {
      ecmaVersion: 2025,
      sourceType: "module",
      globals: {
        ...globals.browser,
        ...globals.es2024,
        ...globals.node,
        ...globals.es2025,
      },
      parser: tsEslint.parser,
      parserOptions: {
        tsconfigRootDir: ".",
        project: true,
        projectService: true,
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    plugins: {
      "react-hooks": reactHooks,
      "react-refresh": reactRefresh,
      "@typescript-eslint": tsEslint.plugin,
      "react": reactPlugin,
    },
    rules: {
      // Console statements - changed to 'error' to make it auto-fixable
      // "no-console": ["error", {
      //   allow: ["warn", "error"],
      // }],

      // React Refresh rules
      "react-hooks/exhaustive-deps": ["off"],
      "react-refresh/only-export-components": [
        "off",
        { allowConstantExport: true },
      ],

      // Unused variables handling
      "@typescript-eslint/no-unused-vars": [
        "warn",
        {
          argsIgnorePattern: "^_",
          varsIgnorePattern: "^_",
          destructuredArrayIgnorePattern: "^_",
          caughtErrorsIgnorePattern: "^_",
        },
      ],

      // Type definition rules
      "@typescript-eslint/consistent-type-definitions": ["error", "interface"],
      "@typescript-eslint/no-empty-object-type": [
        "error",
        { allowInterfaces: "always" },
      ],

      // Array type handling
      "@typescript-eslint/array-type": ["error", { default: "array-simple" }],

      // Empty function handling
      "@typescript-eslint/no-empty-function": "off",

      // Inferrable type annotations
      "@typescript-eslint/no-inferrable-types": "warn",

      // React hooks rules
      "react-hooks/rules-of-hooks": "error",

      // Additional recommended rules
      "prefer-const": "error",
      "@typescript-eslint/no-explicit-any": "warn",
      "@typescript-eslint/consistent-indexed-object-style": ["error", "record"],
      "@typescript-eslint/prefer-for-of": "error",

      // React-specific rules
      "react/jsx-key": "error",
      "react/no-unescaped-entities": "warn",
      "react/prop-types": "off",
      "react/display-name": "off",
    },
  },
);

```

# index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <base href="/" />
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>spike.land</title>
    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap"
      as="style"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap"
      rel="stylesheet"
    />

    <script type="importmap">
      {
        "imports": {
          "@/": "/@/",
          "@emotion/react/jsx-runtime": "/emotionJsxRuntime.mjs",
          "@emotion/react/jsx-dev-runtime": "/emotionJsxRuntime.mjs",
          "@emotion/styled": "/emotionStyled.mjs", 
          "react/jsx-runtime": "/jsx.mjs",
          "react-dom/server": "/reactDomServer.mjs",
          "react-dom/client": "/reactDomClient.mjs",
          "@emotion/react": "/emotion.mjs",
          "react": "/reactMod.mjs",
          "framer-motion": "/@/workers/framer-motion.mjs",
          "react-dom": "/reactDom.mjs"
        }
      }
    </script>
  </head>

  <body>
    <div id="embed"></div>
    <script type="module" src="./src/start.ts"></script>
  </body>
</html>

```

# package-ast.json

```json
{
  "name": "ast-code-modification",
  "version": "1.0.0",
  "description": "AST-based code modification tool for AI agents",
  "main": "index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "dependencies": {
    "@babel/core": "7.23.5",
    "@babel/generator": "7.23.5",
    "@babel/parser": "7.23.5",
    "@babel/traverse": "7.23.5",
    "@babel/types": "7.23.5",
    "@langchain/anthropic": "0.0.10",
    "@langchain/core": "0.1.15",
    "@langchain/langgraph": "0.0.8",
    "prettier": "3.1.0",
    "uuid": "9.0.1",
    "zod": "3.22.4"
  },
  "devDependencies": {
    "@types/babel__core": "7.20.5",
    "@types/babel__generator": "7.6.8",
    "@types/babel__traverse": "7.20.4",
    "@types/jest": "29.5.10",
    "@types/node": "20.10.3",
    "@types/prettier": "3.0.0",
    "@types/uuid": "9.0.7",
    "jest": "29.7.0",
    "ts-jest": "29.1.1",
    "typescript": "5.3.2"
  }
}

```

# package.json

```json
{
  "name": "@spike-npm-land/code",
  "version": "0.9.56",
  "type": "module",
  "description": "spike.land",
  "entry": "dist/modules.mjs",
  "main": "dist/modules.mjs",
  "source": "src/modules.ts",
  "types": "dts/src/modules.d.ts",
  "module": "dist/modules.mjs",
  "files": [
    "dist",
    "src",
    "dts"
  ],
  "scripts": {
    "// Development": "",
    "dev": "concurrently \"yarn dev:vite\" \"yarn types:watch\" \"yarn dev:workers\"",
    "dev:vite": "vite",
    "dev:workers": "node --experimental-strip-types  src/@/lib/esbuild-dev.ts --watch",
    "// Build": "",
    "build": "yarn clean && yarn build:all",
    "build:all": "concurrently --kill-others-on-fail \"yarn build:vite\" \"yarn build:types\" \"yarn build:workers\" && yarn post-build",
    "build:vite": "vite build",
    "build:workers": "node --experimental-strip-types  src/@/lib/esbuild-dev.ts",
    "build:types": "tsc --build && yarn types:cp",
    "post-build": "cp -a -f dist-vite/. dist/  && yarn remove-extraneous",
    "remove-extraneous": "cd dist && rm tsconfig.node.tsbuildinfo && cd @/workers/monaco && rm css.worker.js html.worker.js json.worker.js",
    "// Types": "",
    "types:check": "tsc --noEmit",
    "types:build": "tsc --build",
    "types:watch": "tsc --watch",
    "types:cp": "cp -r dts/src/reactMod.d.ts dts/src/reactDom.d.ts dts/src/jsx.d.ts dts/src/emotion.d.ts dts/src/reactDomClient.d.ts dist/ && cp -r dts/src/@ dist/.",
    "// Testing": "",
    "test": "sh scripts/run-tests.sh",
    "test:full": "yarn types:check && yarn lint && yarn test",
    "// Utils": "",
    "clean": "rm -rf .tsBuildInfo dist dts dist-vite && mkdir -p dist dts dist-vite",
    "lint": "eslint .",
    "fmt": "dprint fmt \"**/*.{ts,tsx,js,jsx,json,mjs}\"",
    "preview": "vite preview"
  },
  "keywords": [
    "monaco",
    "editor",
    "react",
    "typescript",
    "html",
    "vscode"
  ],
  "authors": [
    "Zoltan Erdos <zolika84@gmail.com>"
  ],
  "bugs": {
    "url": "https://github.com/zerdos/spike.land"
  },
  "homepage": "http://spike.land",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/zerdos/spike.land.git"
  },
  "author": "Zoltan Erdos <zolika84@gmail.com>",
  "license": "BSD-3-Clause",
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "0.39.0",
    "@babel/core": "7.26.9",
    "@babel/generator": "7.26.9",
    "@babel/parser": "7.26.9",
    "@babel/traverse": "7.26.9",
    "@babel/types": "7.26.9",
    "@clerk/clerk-react": "5.24.0",
    "@clerk/nextjs": "6.12.1",
    "@emotion/cache": "11.14.0",
    "@emotion/css-prettifier": "1.2.0",
    "@emotion/react": "11.14.0",
    "@emotion/styled": "11.14.0",
    "@github/stable-socket": "1.1.1",
    "@heroicons/react": "2.2.0",
    "@hookform/resolvers": "4.1.2",
    "@langchain/anthropic": "0.3.15",
    "@langchain/core": "0.3.42",
    "@langchain/langgraph": "0.2.51",
    "@mui/material": "6.4.6",
    "@okikio/sharedworker": "1.1.0",
    "@radix-ui/react-accordion": "1.2.3",
    "@radix-ui/react-alert-dialog": "1.1.6",
    "@radix-ui/react-aspect-ratio": "1.1.2",
    "@radix-ui/react-avatar": "1.1.3",
    "@radix-ui/react-checkbox": "1.1.4",
    "@radix-ui/react-collapsible": "1.1.3",
    "@radix-ui/react-context-menu": "2.2.6",
    "@radix-ui/react-dialog": "1.1.6",
    "@radix-ui/react-dropdown-menu": "2.1.6",
    "@radix-ui/react-hover-card": "1.1.6",
    "@radix-ui/react-icons": "1.3.2",
    "@radix-ui/react-label": "2.1.2",
    "@radix-ui/react-menubar": "1.1.6",
    "@radix-ui/react-navigation-menu": "1.2.5",
    "@radix-ui/react-popover": "1.1.6",
    "@radix-ui/react-progress": "1.1.2",
    "@radix-ui/react-radio-group": "1.2.3",
    "@radix-ui/react-scroll-area": "1.2.3",
    "@radix-ui/react-select": "2.1.6",
    "@radix-ui/react-separator": "1.1.2",
    "@radix-ui/react-slider": "1.2.3",
    "@radix-ui/react-slot": "1.1.2",
    "@radix-ui/react-switch": "1.1.3",
    "@radix-ui/react-tabs": "1.1.3",
    "@radix-ui/react-toast": "1.2.6",
    "@radix-ui/react-toggle": "1.1.2",
    "@radix-ui/react-toggle-group": "1.1.2",
    "@radix-ui/react-tooltip": "1.1.8",
    "@react-spring/web": "9.7.5",
    "@tabler/icons-react": "3.30.0",
    "@tailwindcss/aspect-ratio": "0.4.2",
    "@tailwindcss/browser": "4.0.9",
    "@tailwindcss/container-queries": "0.1.1",
    "@tailwindcss/forms": "0.5.10",
    "@tailwindcss/line-clamp": "0.4.4",
    "@tailwindcss/postcss": "4.0.9",
    "@tailwindcss/typography": "0.5.16",
    "@tailwindcss/vite": "4.0.9",
    "@tanstack/react-router": "1.112.0",
    "@tanstack/react-virtual": "3.13.2",
    "@tanstack/router-plugin": "1.112.0",
    "@types/autoprefixer": "10.2.4",
    "@types/diff": "7.0.1",
    "@types/isomorphic-fetch": "0.0.39",
    "@typescript-eslint/typescript-estree": "8.25.0",
    "@typescript/ata": "0.9.7",
    "@uidotdev/usehooks": "2.4.1",
    "assert": "2.1.0",
    "assert-browserify": "2.0.0",
    "async-hooks": "1.3.1",
    "async-mutex": "0.5.0",
    "autoprefixer": "10.4.20",
    "ava": "6.2.0",
    "avl": "1.6.0",
    "beasties": "0.2.0",
    "browser-http": "4.0.2",
    "buffer": "6.0.3",
    "class-variance-authority": "0.7.1",
    "clsx": "2.1.1",
    "cmdk": "1.0.4",
    "constants": "0.0.2",
    "csstype": "3.1.3",
    "date-fns": "4.1.0",
    "detective-typescript": "14.0.0",
    "diff": "7.0.0",
    "embla-carousel-react": "8.5.2",
    "esbuild-plugin-copy": "2.1.1",
    "esbuild-plugin-tailwindcss": "2.0.1",
    "esbuild-style-plugin": "1.6.3",
    "esbuild-wasm": "0.25.0",
    "escodegen": "2.1.0",
    "events": "3.3.0",
    "fast-json-patch": "3.1.1",
    "fetch-retry": "6.0.0",
    "file-type": "20.4.0",
    "framer-motion": "12.4.7",
    "html2canvas": "1.4.1",
    "html2canvas-pro": "1.5.8",
    "i18next": "24.2.2",
    "immer": "10.1.1",
    "immutable": "5.0.3",
    "input-otp": "1.4.2",
    "localforage": "1.10.0",
    "lodash": "4.17.21",
    "lru-cache": "^11.0.2",
    "lucide-react": "0.477.0",
    "microdiff": "1.5.0",
    "mime-db": "1.53.0",
    "mime-types": "2.1.35",
    "module": "1.2.5",
    "monaco-editor": "0.52.2",
    "next-i18next": "15.4.2",
    "next-themes": "0.4.4",
    "node-html-parser": "7.0.1",
    "node-source-walk": "7.0.1",
    "object-hash": "3.0.0",
    "object-inspect": "1.13.4",
    "openai": "4.86.1",
    "os-browserify": "0.3.0",
    "p-map": "7.0.3",
    "path-browserify": "1.0.1",
    "perf_hooks": "0.0.1",
    "postcss-js": "4.0.1",
    "preact": "10.26.4",
    "preact-render-to-string": "6.5.13",
    "prettier": "3.5.2",
    "prism-react-renderer": "2.4.1",
    "process": "0.11.10",
    "purgecss": "7.0.2",
    "qrious": "4.0.2",
    "querystring": "0.2.1",
    "re-resizable": "6.11.2",
    "react": "19.0.0",
    "react-day-picker": "9.5.1",
    "react-dom": "19.0.0",
    "react-hook-form": "7.54.2",
    "react-i18next": "15.4.1",
    "react-icons": "5.5.0",
    "react-live": "4.1.8",
    "react-markdown": "10.0.0",
    "react-qrious": "2.5.6",
    "react-refresh": "0.16.0",
    "react-resizable-panels": "2.1.7",
    "react-reverse-portal": "2.2.0",
    "react-spring": "9.7.5",
    "react-swipeable": "7.0.2",
    "react-syntax-highlighter": "15.6.1",
    "react-use": "17.6.0",
    "recharts": "2.15.1",
    "recordrtc": "5.6.2",
    "shadcdn": "0.0.8",
    "sonner": "2.0.1",
    "stream": "0.0.3",
    "stream-browserify": "3.0.0",
    "string_decoder": "1.3.0",
    "swr": "2.3.2",
    "tailwind-merge": "3.0.2",
    "tailwindcss": "4.0.9",
    "tailwindcss-animate": "1.0.7",
    "transferables": "1.0.3",
    "ts-md5": "1.3.1",
    "url": "0.11.4",
    "use-immer": "0.11.0",
    "util": "0.12.5",
    "uuid": "11.1.0",
    "v8": "0.1.0",
    "vaul": "1.1.2",
    "vitest": "3.0.7",
    "webrtc-adapter": "9.0.1",
    "window-async-local-storage": "1.1.0",
    "workbox-cacheable-response": "7.3.0",
    "workbox-navigation-preload": "7.3.0",
    "workbox-precaching": "7.3.0",
    "workbox-routing": "7.3.0",
    "workbox-strategies": "7.3.0",
    "workbox-sw": "7.3.0",
    "workbox-window": "7.3.0",
    "worker-rpc": "0.2.0",
    "zod": "3.24.2"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "4.20250224.0",
    "@emotion/babel-plugin": "11.13.5",
    "@eslint/js": "9.21.0",
    "@rollup/plugin-html": "2.0.0",
    "@testing-library/dom": "10.4.0",
    "@testing-library/jest-dom": "6.6.3",
    "@testing-library/react": "16.2.0",
    "@testing-library/react-hooks": "8.0.1",
    "@testing-library/user-event": "14.6.1",
    "@types/babel__core": "7.20.5",
    "@types/babel__generator": "7.6.8",
    "@types/babel__traverse": "7.20.6",
    "@types/jest": "29.5.14",
    "@types/mime-db": "1.43.5",
    "@types/mime-types": "2.1.4",
    "@types/node": "22.13.8",
    "@types/object-hash": "3.0.6",
    "@types/offscreencanvas": "2019.7.3",
    "@types/path-browserify": "1.0.3",
    "@types/prettier": "3.0.0",
    "@types/react": "19.0.10",
    "@types/react-dom": "19.0.4",
    "@types/react-syntax-highlighter": "15.5.13",
    "@types/recordrtc": "5.6.14",
    "@types/serve-handler": "6.1.4",
    "@types/text-encoding": "0.0.40",
    "@types/uuid": "10.0.0",
    "@types/web": "0.0.207",
    "@types/wicg-file-system-access": "2023.10.5",
    "@vitejs/plugin-react-swc": "3.8.0",
    "@vitest/runner": "3.0.7",
    "@vitest/snapshot": "3.0.7",
    "ai-digest": "1.0.8",
    "autoprefixer": "10.4.20",
    "concurrently": "9.1.2",
    "crypto-browserify": "3.12.1",
    "esbuild": "0.25.0",
    "eslint": "9.21.0",
    "eslint-plugin-react-hooks": "5.2.0",
    "eslint-plugin-react-refresh": "0.4.19",
    "globals": "16.0.0",
    "happy-dom": "17.1.8",
    "jest": "29.7.0",
    "jsdom": "26.0.0",
    "postcss": "8.5.3",
    "postcss-import": "16.1.0",
    "rimraf": "6.0.1",
    "rollup-plugin-visualizer": "5.14.0",
    "tailwindcss": "4.0.9",
    "text-encoding": "0.7.0",
    "ts-jest": "29.2.6",
    "tslib": "2.8.1",
    "tty-browserify": "0.0.1",
    "typescript": "5.8.2",
    "typescript-eslint": "8.25.0",
    "url-polyfill": "1.1.13",
    "uvu": "0.5.6",
    "vite": "6.2.0",
    "vite-tsconfig-paths": "5.1.4",
    "vitest": "3.0.7",
    "vm-browserify": "1.1.2"
  }
}

```

# postcss.config.cjs

```cjs
module.exports = {
  plugins: [
    require("postcss-import"),
    require("@tailwindcss/postcss"),
    require("autoprefixer"),
  ],
};

```

# scripts/run-tests.sh

```sh
#!/bin/sh
# This script buffers test output and shows filtered errors (max 10 lines) on failure.

# Enable error checking for undefined variables.
set -u

# Create temporary files for buffering.
stdout_file=$(mktemp) || { echo "Failed to create temporary file for stdout"; exit 1; }
stderr_file=$(mktemp) || { echo "Failed to create temporary file for stderr"; exit 1; }

# Run vitest with additional parameters silently and capture its exit code.
if vitest --no-color --reporter dot run "$@" > "$stdout_file" 2> "$stderr_file"; then
    exit_code=0
else
    exit_code=$?
fi

if [ "$exit_code" -ne 0 ]; then
    # Filter out lines containing '.yarn' or 'node_modules' and show at most 200 lines.
    grep -v '.yarn' "$stderr_file" | grep -v 'node_modules'  | head -n 500
else
    # On success, output the buffered stdout.
    cat "$stdout_file"
fi

# Clean up temporary files.
rm -f "$stdout_file" "$stderr_file"

exit "$exit_code"

```

# src/App.tsx

```tsx
import { AppRouter } from "./routes/router";

export function App() {
  return <AppRouter />;
}

```

# src/ast-code-workflow-example.ts

```ts
import { getBroadcastChannel } from "@/lib/broadcast-channel";
import { ICode } from "@/lib/interfaces";
import { md5 } from "@/lib/md5";
import { createAstWorkflow } from "@/workers/ast-langchain-workflow.worker";
import { HumanMessage } from "@langchain/core/messages";

// Custom error class for better error handling
class ExampleError extends Error {
  constructor(
    message: string,
    public readonly context?: Record<string, unknown>,
  ) {
    super(message);
    this.name = "ExampleError";
  }
}

/**
 * Example usage of the AST-based code workflow that demonstrates AI code modifications
 * with improved error handling and code integrity verification
 */
const example = async (
  userRequest: string,
  cSess: ICode,
  channel: BroadcastChannel,
) => {
  try {
    // Get the code session
    const session = await cSess.getSession();
    const codeSpace = cSess.getCodeSpace();

    // Generate document hash for code integrity verification
    const initialCode = session.code;
    const initialDocumentHash = md5(initialCode);
    const filePath = `/live/${codeSpace}.tsx`;

    console.log("Starting AST workflow with code hash:", initialDocumentHash);

    // Create the workflow with initial state
    const workflow = await createAstWorkflow({
      code: initialCode,
      codeSpace: codeSpace,
      origin: location.origin,
      lastError: "",
      isStreaming: false,
      messages: [], // We'll create the messages properly before invoking
      documentHash: initialDocumentHash,
      filePath: filePath,
    });

    // Create system message with code and document hash
    // Insert the code into the system prompt within <code></code> tags

    // Create human message with the user's request
    const humanMessage = new HumanMessage(userRequest);

    // The AI system will:
    // 1. Read the current code and verify its integrity using the document hash
    // 2. Analyze the requirement and current code structure using AST
    // 3. Generate response with code modifications using AST operations
    // 4. Verify the integrity of the modified code
    const initialStateWithMessages = {
      code: initialCode,
      lastError: "",
      isStreaming: false,
      debugLogs: [],
      messages: [],
      documentHash: initialDocumentHash,
      filePath: filePath,
    };

    // Pass the file path as the second parameter
    const result = await workflow.invoke(userRequest, filePath);

    // Verify final code integrity
    if (result.code !== initialCode) {
      const finalDocumentHash = result.documentHash || md5(result.code);
      const actualHash = md5(result.code);

      if (finalDocumentHash !== actualHash) {
        throw new ExampleError("Code integrity verification failed", {
          expectedHash: finalDocumentHash,
          actualHash,
        });
      }

      console.log("AST code modification successful with integrity verified", {
        initialHash: initialDocumentHash,
        finalHash: finalDocumentHash,
      });
    }

    // Log the result
    console.log("AST workflow result:", {
      userRequest,
      codeChanged: initialCode !== result.code,
      result,
    });

    // Broadcast the result to the channel if needed
    channel.postMessage({
      type: "ast-workflow-result",
      result,
    });

    return result;
  } catch (error) {
    // Enhanced error handling
    if (error instanceof ExampleError) {
      console.error(`AST Example Error: ${error.message}`, error.context);
    } else {
      console.error("Unexpected error in AST example:", error);
    }

    // Broadcast error to the channel
    channel.postMessage({
      type: "ast-workflow-error",
      error: error instanceof Error ? error.message : String(error),
    });

    throw error;
  }
};

/**
 * Sets up and runs the AST workflow example with proper resource management
 */
export const setupAndRunAst = async (prompt: string, cSess: ICode) => {
  if (!prompt || typeof prompt !== "string") {
    throw new ExampleError("Invalid prompt", { prompt });
  }

  const codeSpace = await cSess.getCodeSpace();
  const channel = getBroadcastChannel(codeSpace);

  console.log(`Setting up AST workflow for code space: ${codeSpace}`);

  try {
    return await example(prompt, cSess, channel);
  } catch (error) {
    console.error("AST setup and run failed:", error);
    throw error;
  } finally {
    // Ensure channel is always closed to prevent resource leaks
    channel.close();
    console.log("AST workflow channel closed");
  }
};

// Example usage:
// setupAndRunAst("Add error handling to this function", codeSession).catch(console.error);

```

# src/AsyncStorage.ts

```ts
import {
  clear,
  getAllkeys,
  getItem,
  mergeItem,
  multiGet,
  multiMerge,
  multiRemove,
  multiSet,
  removeItem,
  setItem,
} from "window-async-local-storage";

export const getStore = async () => {
  const keys = (await getAllkeys() as string[]).filter((k) => k);
  const stores = (await multiGet(keys)) as string[];
  const store: Record<string, unknown> = {};

  stores.forEach(([key, value]) => {
    Object.assign(store, { [key]: value });
  });
  return store;
};

export {
  clear,
  getAllkeys,
  getItem,
  mergeItem,
  multiGet,
  multiMerge,
  multiRemove,
  multiSet,
  removeItem,
  setItem,
};

export class AsyncLocalStorage {
  private currentStore: Record<string, unknown> = {};

  constructor() {
    console.log("AsyncStorage constructor");
  }

  getItem = getItem;
  setItem = setItem;
  removeItem = removeItem;
  clear = clear;
  getStore = () => this.currentStore;

  run(
    store: Record<string, unknown>,
    callback: (...args: unknown[]) => unknown,
    ...args: unknown[]
  ): unknown {
    const previousStore = this.currentStore;
    this.currentStore = store;

    try {
      return callback(...args);
    } finally {
      this.currentStore = previousStore;
    }
  }

  // This method mimics the behavior of asyncLocalStorage.getStore()
  // in the Node.js implementation
  getStoreSync() {
    return this.currentStore;
  }
}

export default AsyncLocalStorage;

```

# src/cf-esbuild.mjs

```mjs
import esbuild from "../../js.spike.land/src/index";

export default esbuild;

```

# src/chat-utils-langchain-example.ts

```ts
import { ICode } from "@/lib/interfaces";
import { md5 } from "@/lib/md5";

// // Custom error class for better error handling
class CodeModWorkflowError extends Error {
  constructor(
    message: string,
    public readonly context?: Record<string, unknown>,
  ) {
    super(message);
    this.name = "CodeModWorkflowError";
  }
}

export const setupAndRun = async (
  prompt: string,
  cSess: ICode,
  options = { returnModifiedCode: false },
) => {
  if (!prompt || typeof prompt !== "string") {
    throw new CodeModWorkflowError("Invalid prompt", { prompt });
  }

  const codeSpace = await cSess.getCodeSpace();
  const channel = new BroadcastChannel(`codeSpace-${codeSpace}-workflow`);

  console.log(`Setting up workflow for code space: ${codeSpace}`);

  const example = async (
    prompt: string,
    cSess: ICode,
    channel: BroadcastChannel,
    options = { returnModifiedCode: false },
  ) => {
    try {
      // Get the code session
      const { createWorkflowWithStringReplace } = await import(
        "@/workers/chat-utils-langchain.worker"
      );
      const session = await cSess.getSession();
      const codeSpace = cSess.getCodeSpace();

      // Generate document hash for code integrity verification
      const initialCode = session.code;
      const initialDocumentHash = md5(initialCode);

      console.log("Starting workflow with code hash:", initialDocumentHash);

      // Create the workflow with initial state and pass returnModifiedCode in the initial state
      // This will be available in the workflow's state and can be used by the code modification tool
      const workflow = await createWorkflowWithStringReplace({
        code: initialCode,
        codeSpace: codeSpace,
        origin: location.origin,
        lastError: "",
        isStreaming: false,
        messages: [], // We'll create the messages properly before invoking
        documentHash: initialDocumentHash,
        // Add returnModifiedCode to the initial state so it can be accessed by the workflow
        returnModifiedCode: options.returnModifiedCode,
      });

      // The workflow will create the system message with code and document hash
      // and add the human message with the user's request
      const result = await workflow.invoke(prompt);

      // Verify the workflow executed successfully
      if (!result) {
        throw new CodeModWorkflowError("Workflow execution failed", {
          prompt,
          initialDocumentHash,
          returnModifiedCode: options.returnModifiedCode,
        });
      }

      // Verify final code integrity
      if (result.code !== initialCode) {
        const finalDocumentHash = result.documentHash || md5(result.code);
        const actualHash = md5(result.code);

        if (finalDocumentHash !== actualHash) {
          throw new CodeModWorkflowError("Code integrity verification failed", {
            expectedHash: finalDocumentHash,
            actualHash,
          });
        }

        console.log("Code modification successful with integrity verified", {
          initialHash: initialDocumentHash,
          finalHash: finalDocumentHash,
        });
      }

      // Log the result
      console.log("Workflow result:", {
        prompt,
        codeChanged: initialCode !== result.code,
        result,
      });

      // Broadcast the result to the channel if needed
      channel.postMessage({
        type: "workflow-result",
        result,
      });

      return result;
    } catch (error) {
      // Enhanced error handling
      if (error instanceof CodeModWorkflowError) {
        console.error(`Example Error: ${error.message}`, error.context);
      } else {
        console.error("Unexpected error in example:", error);
      }

      // Broadcast error to the channel
      channel.postMessage({
        type: "workflow-error",
        error: error instanceof Error ? error.message : String(error),
      });

      throw error;
    }
  };

  try {
    // Pass the returnModifiedCode option to the example function
    return await example(prompt, cSess, channel, options);
  } catch (error) {
    console.error("Setup and run failed:", error);
    throw error;
  } finally {
    // Ensure channel is always closed to prevent resource leaks
    channel.close();
    console.log("Workflow channel closed");
  }
};

// Example usage:
// setupAndRun("Add error handling to this function", codeSession).catch(console.error);
// With options:
// setupAndRun("Add error handling to this function", codeSession, { returnModifiedCode: true }).catch(console.error);

```

# src/ChatInterface.tsx

```tsx
import { ChatDrawer } from "@/components/app/chat-drawer";
import { useLocalStorage } from "@/external/use-local-storage";
import { useDarkMode } from "@/hooks/use-dark-mode";
import { useDictation } from "@/hooks/use-dictation";
import type { ICode, ICodeSession } from "@/lib/interfaces";
import type { ImageData, Message } from "@/lib/interfaces";
import { handleSendMessage } from "@/lib/shared";
import React, { useCallback, useEffect, useRef, useState } from "react";

import { useScreenshot } from "./hooks/useScreenshot";

let isStreamingTimeout: NodeJS.Timeout | null = null;

const ChatInterface: React.FC<{
  isOpen: boolean;
  cSess: ICode;
  codeSpace: string;
  onClose: () => void;
}> = React.memo(({ onClose, isOpen, cSess }): React.ReactElement | null => {
  const [session, setSession] = useState<ICodeSession | null>(null);
  const { isDarkMode, toggleDarkMode } = useDarkMode();
  const [messages, setMessages] = useState<Message[]>([]);

  useEffect(() => {
    cSess.getSession().then((initialSession) => {
      setSession(initialSession);
      setMessages(initialSession.messages);
    });
  }, [cSess]);

  const codeSpace = session?.codeSpace ?? "";
  const [isStreaming, setIsStreaming] = useLocalStorage<boolean>(
    `streaming-${codeSpace}`,
    false,
  );

  useEffect(() => {
    if (isStreaming) {
      isStreamingTimeout = setTimeout(() => {
        setIsStreaming(false);
      }, 1000);
    }
    const unSub = cSess.sub((sess) => {
      // Deep compare messages to prevent unnecessary updates
      if (sess.messages) {
        if (JSON.stringify(messages) === JSON.stringify(sess.messages)) {
          return;
        }
        setMessages(sess.messages);
      }
    });
    return () => unSub();
  }, []);

  const [input, setInput] = useDictation("");

  const [editingMessageId, setEditingMessageId] = useState<string | null>(null);
  const [editInput, setEditInput] = useState("");

  const inputRef = useRef<HTMLTextAreaElement | null>(null);

  const resetChat = useCallback((): void => {
    cSess.setMessages([]);
    setInput("");
    setEditingMessageId(null);
    setEditInput("");
    if (inputRef.current) {
      inputRef.current.value = "";
    }
  }, [setInput]);

  useEffect(() => {
    if (isOpen) {
      setTimeout(() => {
        document.getElementById("after-last-message")?.scrollIntoView({
          behavior: "instant",
          block: "end",
        });
      });
    }
  }, [isOpen]);

  const handleCancelEdit = useCallback(() => {
    setEditingMessageId(null);
    setEditInput("");
  }, []);

  const handleSaveEdit = useCallback((messageId: string) => {
    const messageIndex = messages.findIndex((msg) => msg.id === messageId);
    const messageToEdit = messages[messageIndex];

    if (!messageToEdit || messageToEdit.role === "assistant") {
      console.error("Invalid message for editing");
      return;
    }

    // Create new message with updated content
    const updatedMessage = {
      ...messageToEdit,
      content: editInput,
    };

    // Create new messages array with updated message and remove subsequent messages
    const updatedMessages = [
      ...messages.slice(0, messageIndex),
      updatedMessage,
    ];

    // Update session with new messages
    cSess.setMessages(updatedMessages);
    setEditingMessageId(null);
    setEditInput("");
  }, [messages, editInput, cSess]);

  useEffect(() => {
    const BC = new BroadcastChannel(`${codeSpace}-chat`);
    BC.onmessage = async (event) => {
      const e = event.data;

      // Clear any existing streaming timeout
      if (isStreamingTimeout) {
        clearTimeout(isStreamingTimeout);
        isStreamingTimeout = null;
      }

      // Handle messages update
      if (e.messages) {
        await cSess.setMessages(e.messages);
      }

      // Handle streaming state
      if (e.isStreaming !== undefined) {
        setIsStreaming(e.isStreaming);
      }

      // Handle debug info
      if (e.debugInfo) {
        const debugInfo = e.debugInfo;
        console.debug("debugInfo", { debugInfo });
        Object.assign(globalThis, { debugInfo });
      }

      // Handle code updates
      if (e.code) {
        console.log("Setting code", e.code);
        cSess.setCode(e.code);
      }

      // Handle instructions/streaming content
      if (e.chunk) {
        cSess.addMessageChunk(e.chunk);
        setMessages((prevMessages) => {
          const lastMessage = prevMessages[prevMessages.length - 1];
          if (lastMessage && lastMessage.role === "assistant") {
            lastMessage.content += e.chunk;
            return prevMessages;
          }
          const newId = lastMessage
            ? (1 + Number(lastMessage.id)).toString()
            : "1";
          return [
            ...prevMessages,
            { role: "assistant", content: e.chunk, id: newId } as Message,
          ];
        });
      }

      if (!isStreaming) {
        setIsStreaming(true);
      }
      if (isStreamingTimeout) {
        clearTimeout(isStreamingTimeout);
        isStreamingTimeout = null;
      }
      isStreamingTimeout = setTimeout(() => {
        setIsStreaming(false);
      }, 1000);

      // Set streaming timeout if we have instructions
      if (e.instructions) {
        setIsStreaming(true);
      }
    };

    return () => {
      if (isStreamingTimeout) {
        clearTimeout(isStreamingTimeout);
        isStreamingTimeout = null;
      }
      BC.close();
    };
  }, [codeSpace, cSess, setIsStreaming, isStreaming]); // Removed messages from deps

  const handleResetChat = useCallback((): void => {
    resetChat();
    setIsStreaming(false);
    if (inputRef.current) {
      inputRef.current.value = "";
    }
  }, [resetChat, setIsStreaming]);

  const {
    isScreenshotLoading,
    screenshotImage,
    handleScreenshotClick,
    handleCancelScreenshot,
  } = useScreenshot(codeSpace);

  useEffect(() => {
    if (codeSpace.includes("-")) {
      const maybeKey = codeSpace.split("-")[1];
      const storedData = sessionStorage.getItem(maybeKey);
      if (storedData) {
        const { prompt, images } = JSON.parse(storedData) as {
          prompt: string;
          images: ImageData[];
        };
        sessionStorage.removeItem(maybeKey);

        cSess.getSession().then((currentSession) => {
          handleSendMessage({
            messages: [],
            codeSpace,
            prompt,
            images,
            code: currentSession.code,
          });
        });
      }
    }
  }, [isOpen, codeSpace, setInput, cSess]);

  const memoizedHandleEditMessage = useCallback((messageId: string): void => {
    setEditingMessageId(messageId);

    const messageToEdit = messages.find((msg) => msg.id === messageId);
    if (!messageToEdit) {
      console.error("Invalid message for editing");
      return;
    }
    const contentToEdit = Array.isArray(messageToEdit.content)
      ? messageToEdit.content.find((
        item,
      ): item is { type: "text"; text: string; } => item.type === "text")
        ?.text || ""
      : messageToEdit.content;

    if (contentToEdit === undefined) {
      console.error("Invalid message content for editing");
      return;
    }
    setEditInput(
      typeof contentToEdit === "string" ? contentToEdit : contentToEdit,
    );
  }, [messages]);

  const memoizedSetEditInput = useCallback((value: string): void => {
    setEditInput(value);
  }, []);

  const memoizedScreenshot = useCallback(
    (): Promise<ImageData> => cSess.screenshot(),
    [cSess],
  );

  if (!isOpen) return null;

  return (
    <ChatDrawer
      isOpen={isOpen}
      setEditingMessageId={setEditingMessageId}
      onClose={onClose}
      isDarkMode={isDarkMode}
      toggleDarkMode={toggleDarkMode}
      handleResetChat={handleResetChat}
      isStreaming={!!isStreaming}
      input={input}
      setInput={setInput}
      cSess={cSess}
      handleSendMessage={handleSendMessage}
      inputRef={inputRef}
      isScreenshotLoading={isScreenshotLoading}
      screenshotImage={screenshotImage}
      handleScreenshotClick={handleScreenshotClick}
      handleCancelScreenshot={handleCancelScreenshot}
      editingMessageId={editingMessageId}
      editInput={editInput}
      setEditInput={memoizedSetEditInput}
      handleEditMessage={memoizedHandleEditMessage}
      handleCancelEdit={handleCancelEdit}
      handleSaveEdit={handleSaveEdit}
      screenshot={memoizedScreenshot}
    />
  );
});

ChatInterface.displayName = "ChatInterface";

export { ChatInterface };

```

# src/codeHistoryUtils.ts

```ts
// src/codeHistoryUtils.ts

export interface Version {
  timestamp: number;
  code: string;
}

const VERSION_HISTORY_KEY = "codeVersionHistory";
const MAX_VERSIONS = 250; // Maximum number of versions to store
const SAVE_INTERVAL = 60000; // 1 minute in milliseconds

export const loadVersionHistory = async (
  codeSpace: string,
): Promise<Version[]> => {
  const res = fetch(`/live/${codeSpace}/auto-save/history`);

  return (await res).json();
};

export const saveVersionHistory = (
  codeSpace: string,
  versions: Version[],
): void => {
  const key = `${VERSION_HISTORY_KEY}_${codeSpace}`;
  localStorage.setItem(key, JSON.stringify(versions.slice(0, MAX_VERSIONS)));
};

export const addVersion = (
  codeSpace: string,
  newVersion: Version,
  currentVersions: Version[],
): Version[] => {
  const now = Date.now();
  const latestVersion = currentVersions[0];

  // Only add a new version if it's been more than SAVE_INTERVAL since the last save
  // or if it's the first version
  if (!latestVersion || (now - latestVersion.timestamp) >= SAVE_INTERVAL) {
    const updatedVersions = [newVersion, ...currentVersions].slice(
      0,
      MAX_VERSIONS,
    );
    saveVersionHistory(codeSpace, updatedVersions);
    return updatedVersions;
  }

  return currentVersions;
};

```

# src/components/ActionButtons.tsx

```tsx
import { FaDownload } from "@/external/icons";
import { FullscreenIcon } from "@/external/lucide-react";
import { Fab, Tooltip } from "@/external/mui-material";
import { motion } from "framer-motion";
import type { FC } from "react";
import { Share } from "./icons";
import { QRButton } from "./Qr.lazy";

interface ActionButtonsProps {
  codeSpace: string;
  handleDownload: () => void;
}

export const ActionButtons: FC<ActionButtonsProps> = ({
  codeSpace,
  handleDownload,
}) => {
  return (
    <motion.div
      layout
      className="overflow-hidden"
      initial={{ height: 0, width: 0 }}
      animate={{ height: "100%", width: 88 }}
    >
      <div className="p-4 flex overflow-hidden items-center flex-col">
        <Tooltip title="Toggle Fullscreen" placement="left">
          <Fab
            onClick={() => document.querySelector("#root")?.requestFullscreen()}
          >
            <span className="text-3xl">
              <FullscreenIcon />
            </span>
          </Fab>
        </Tooltip>
        <Tooltip title="Show QR Code" placement="left">
          <div>
            <QRButton url={`${location.origin}/live/${codeSpace}/`} />
          </div>
        </Tooltip>
        <Tooltip title="Open in New Window" placement="left">
          <Fab onClick={() => window.open(`/live/${codeSpace}/`)}>
            <Share />
          </Fab>
        </Tooltip>
        <Tooltip title="Download Project" placement="left">
          <Fab onClick={handleDownload}>
            <FaDownload />
          </Fab>
        </Tooltip>
      </div>
    </motion.div>
  );
};

```

# src/components/AutoSaveHistory.tsx

```tsx
import type { ICode } from "@/lib/interfaces";
import type { IHistoryItem } from "@/lib/interfaces";
import React, { useCallback, useEffect, useState } from "react";
import type { Version } from "../codeHistoryUtils";
import { loadVersionHistory } from "../codeHistoryUtils";
import { FullScreenHistoryView } from "./History/HistoryFComponents";

interface CodeHistoryCarouselProps {
  codeSpace: string;
  onRestore: (item: IHistoryItem) => void;
  onClose: () => void;
  cSess: ICode;
}

export const CodeHistoryCarousel: React.FC<CodeHistoryCarouselProps> = ({
  codeSpace,
  onRestore,
  onClose,
  cSess,
}) => {
  const [history, setHistory] = useState<IHistoryItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchHistory = useCallback(async () => {
    try {
      setLoading(true);
      const data: Version[] = await loadVersionHistory(codeSpace);
      setHistory(
        data
          .filter((x) => !x.code.includes("History") && !x.code.includes("e/pp"))
          .sort((a, b) => b.timestamp - a.timestamp)
          .map((version) => ({ ...version, timestamp: version.timestamp })),
      );
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "An unknown error occurred",
      );
    } finally {
      setLoading(false);
    }
  }, [codeSpace]);

  useEffect(() => {
    fetchHistory();
  }, [fetchHistory]);

  const handleRestore = useCallback(
    async (item: IHistoryItem) => {
      try {
        const response = await fetch(
          `/live/${codeSpace}/auto-save/restore/${item.timestamp}`,
        );
        if (!response || !response.ok) {
          throw new Error("Failed to restore version");
        }

        onRestore(item);
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "An unknown error occurred",
        );
      }
    },
    [codeSpace, onRestore],
  );

  if (loading) return <div>Loading history...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <FullScreenHistoryView
      history={history}
      onDelete={(timestamp: number) =>
        setHistory((h) => h.filter((x) => x.timestamp !== timestamp))}
      onRestore={(item: IHistoryItem) => handleRestore(item)}
      onClose={() => onClose()}
      cSess={cSess}
    />
  );
};

export default CodeHistoryCarousel;

```

# src/components/BreakpointButtons.tsx

```tsx
import { ToggleButton, ToggleButtonGroup } from "@/external/mui-material";
import { cn } from "@/lib/utils";
import { motion } from "framer-motion";
import { Phone, Tablet, Tv } from "./icons";

interface BreakpointButtonsProps {
  width: number;
  setWidth: (value: number) => void;
  breakPoints: number[];
}

export const BreakpointButtons: React.FC<BreakpointButtonsProps> = ({
  width,
  setWidth,
  breakPoints,
}) => {
  return (
    <motion.div
      layout
      className="overflow-hidden flex justify-evenly"
      initial={{ height: 0, width: 0 }}
      animate={{ height: 42, width: "100%" }}
    >
      <ToggleButtonGroup
        value={width}
        size="small"
        exclusive
        onChange={(_e, newSize) => {
          if (newSize !== null) setWidth(newSize);
        }}
      >
        {breakPoints.map((size, index) => (
          <ToggleButton key={size} value={size}>
            <span
              className={cn(
                width === size ? "text-highlight" : "text-normal",
              )}
            >
              {index === 0 ? <Phone /> : index === 1 ? <Tablet /> : <Tv />}
            </span>
          </ToggleButton>
        ))}
      </ToggleButtonGroup>
    </motion.div>
  );
};

```

# src/components/ContentWrapper.tsx

```tsx
import { motion } from "framer-motion";

export const ContentWrapper = (
  { children, scale, innerHeight, width, bgColor, rgba, type }: {
    children: React.ReactElement;
    scale: number;
    innerHeight: number;
    width: number;
    bgColor: number[];
    rgba: (r: number, g: number, b: number, a: number) => string;
    type: string;
  },
) => (
  <motion.div
    transition={{ scale: { type } }}
    className="block rounded-lg"
    style={{
      backgroundColor: rgba(bgColor[0], bgColor[1], bgColor[2], 0.5),
    }}
    initial={{ height: innerHeight, width: innerWidth }}
    animate={{
      height: innerHeight * scale,
      width: width * scale,
    }}
  >
    {children}
  </motion.div>
);

```

# src/components/ContextViewer.tsx

```tsx
import type { ProjectContext } from "@/lib/context-manager";
import React, { useEffect, useState } from "react";
import { useContext } from "../hooks/useContext";

interface ContextViewerProps {
  codeSpace: string;
}

export const ContextViewer: React.FC<ContextViewerProps> = ({ codeSpace }) => {
  const { getFullContext, updateContext } = useContext(codeSpace);
  const [context, setContext] = useState<ProjectContext>(getFullContext());

  useEffect(() => {
    setContext(getFullContext());
  }, [getFullContext]);

  const handleChange = (key: string & keyof ProjectContext, value: string) => {
    updateContext(key, value);
    setContext((prevContext) => ({ ...prevContext, [key]: value }));
  };

  return (
    <div className="context-viewer">
      <h2>Project Context</h2>
      {(Object.keys(context) as Array<string & keyof ProjectContext>).map((
        key,
      ) => (
        <div key={key} className="context-item">
          <label htmlFor={key}>{key}:</label>
          <textarea
            id={key}
            value={context[key] as string}
            onChange={(e) => handleChange(key, e.target.value)}
            rows={3}
          />
        </div>
      ))}
    </div>
  );
};

```

# src/components/DraggableWindowContent.tsx

```tsx
import { FC } from "react";
import { ActionButtons } from "./ActionButtons";
import { BreakpointButtons } from "./BreakpointButtons";
import { ContentWrapper } from "./ContentWrapper";
import { ScaledContent } from "./ScaledContent";
import { ScaleRangeButtons } from "./ScaleRangeButtons";

interface ColorUtils {
  bgColor: number[];
  rgba: (r: number, g: number, b: number, a: number) => string;
}

interface ScaleProps {
  scaleRange: number;
  setScaleRange: (scaleRange: number) => void;
  scale: number;
  sizes: number[];
  maxScaleRange: number;
}

interface DimensionProps {
  width: number;
  setWidth: (width: number) => void;
  breakPoints: number[];
  innerHeight: number;
}

interface ActionProps {
  codeSpace: string;
  handleDownload: () => void;
}

interface DraggableWindowContentProps extends ScaleProps, DimensionProps, ActionProps, ColorUtils {
  children: React.ReactElement;
}

const rgba = (r: number, g: number, b: number, a: number) =>
  `rgba(${r || 1}, ${g || 1}, ${b || 1}, ${a || 0.7})`;

export const DraggableWindowContent: FC<DraggableWindowContentProps> = ({
  // Scale related props
  scaleRange,
  setScaleRange,
  scale,
  sizes,
  maxScaleRange,

  // Dimension related props
  width,
  setWidth,
  breakPoints,
  innerHeight,

  // Action related props
  codeSpace,
  handleDownload,

  // Color related props
  bgColor,

  // Content
  children,
}) => {
  const commonStyleProps = {
    innerHeight,
    width,
    bgColor,
  };

  return (
    <div
      className="overflow-hidden flex"
      id="DraggableWindow"
      data-testid="draggable-window-content"
    >
      <div className="flex w-full flex-col items-center">
        <ScaleRangeButtons
          scaleRange={scaleRange}
          setScaleRange={setScaleRange}
          sizes={sizes}
          maxScaleRange={maxScaleRange}
        />

        <ContentWrapper
          {...commonStyleProps}
          scale={scale}
          rgba={rgba}
          type="spring"
        >
          <ScaledContent
            {...commonStyleProps}
            rgba={rgba}
            scale={scale}
          >
            {children}
          </ScaledContent>
        </ContentWrapper>

        <BreakpointButtons
          width={width}
          setWidth={setWidth}
          breakPoints={breakPoints}
        />
      </div>

      <ActionButtons
        codeSpace={codeSpace}
        handleDownload={handleDownload}
      />
    </div>
  );
};

// Type exports for consuming components
export type { ActionProps, ColorUtils, DimensionProps, DraggableWindowContentProps, ScaleProps };

```

# src/components/Editor.tsx

```tsx
import type { ICode, ICodeSession } from "@/lib/interfaces";
import { md5 } from "@/lib/md5";
import { prettierToThrow } from "@/lib/shared";
import { wait } from "@/lib/wait";
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useEditorState } from "../hooks/use-editor-state";
import { useErrorHandling } from "../hooks/useErrorHandling";
import { initializeMonaco } from "./editorUtils";
import { EditorNode } from "./ErrorReminder";

interface EditorProps {
  codeSpace: string;
  cSess: ICode;
}

export const Editor: React.FC<EditorProps> = ({ codeSpace, cSess }) => {
  const { containerRef, editorState, setEditorState } = useEditorState();
  const { errorType, throttledTypeCheck } = useErrorHandling("monaco");
  const [session, setSession] = useState<ICodeSession | null>(null);
  const [lastHash, setLastHash] = useState<string>("");
  const controller = useRef(new AbortController());

  // Initialize session with optimized state tracking
  useEffect(() => {
    cSess.getSession().then((initialSession) => {
      setSession(initialSession);
      setLastHash(md5(initialSession.code));
    });
  }, [cSess]);

  const initializeEditor = useMemo(() => initializeMonaco, []);

  // Track performance metrics
  const metrics = useRef({
    lastChangeTime: 0,
    changeCount: 0,
    skippedCount: 0,
    lastLogTime: 0,
  });

  const handleContentChange = useCallback(
    async (newCode: string) => {
      if (!session) return;

      const now = performance.now();
      metrics.current.lastChangeTime = now;
      metrics.current.changeCount++;

      // Abort previous operation if any
      controller.current.abort();
      controller.current = new AbortController();
      const { signal } = controller.current;

      try {
        const formatted = await prettierToThrow({
          code: newCode,
          toThrow: false,
        });

        if (signal.aborted) return;

        const newHash = md5(formatted);
        const startSync = performance.now();

        // Only update if content has actually changed
        if (newHash !== lastHash) {
          setLastHash(newHash);
          setEditorState((prev) => ({ ...prev, code: formatted }));
          await cSess.setCode(formatted);
          await throttledTypeCheck();
        }

        // Update metrics
        const syncTime = performance.now() - startSync;
        lifetimeMetrics.current.longestSyncTime = Math.max(
          lifetimeMetrics.current.longestSyncTime,
          syncTime,
        );

        if (now - metrics.current.lastLogTime > 5000) {
          console.debug("[Editor] Performance metrics:", {
            changeCount: metrics.current.changeCount,
            skippedCount: metrics.current.skippedCount,
            syncTime,
            timestamp: new Date().toISOString(),
          });
          metrics.current.lastLogTime = now;
          metrics.current.changeCount = 0;
          metrics.current.skippedCount = 0;
        }
      } catch (e) {
        console.error("Content change error:", e);
      }
    },
    [cSess, session, lastHash, setEditorState, throttledTypeCheck],
  );

  // Track external change metrics
  const externalMetrics = useRef({
    lastUpdateTime: 0,
    updateCount: 0,
    skippedCount: 0,
    lastLogTime: 0,
  });

  // Optimized external code change listener
  useEffect(() => {
    if (!editorState.started || !cSess || !cSess.sub || !session) return;

    const unsubscribe = cSess.sub(async (sess: ICodeSession) => {
      const now = performance.now();
      const newHash = md5(sess.code);

      if (newHash === lastHash || sess.code === editorState.code) {
        externalMetrics.current.skippedCount++;
        return;
      }

      const timeSinceLastUpdate = now - externalMetrics.current.lastUpdateTime;
      externalMetrics.current.lastUpdateTime = now;
      externalMetrics.current.updateCount++;

      // Log external change metrics every 5 seconds
      if (now - externalMetrics.current.lastLogTime > 5000) {
        console.debug("[Editor] External update metrics:", {
          updateCount: externalMetrics.current.updateCount,
          skippedCount: externalMetrics.current.skippedCount,
          averageTimeBetweenUpdates: timeSinceLastUpdate,
          timestamp: new Date().toISOString(),
        });
        externalMetrics.current.lastLogTime = now;
        externalMetrics.current.updateCount = 0;
        externalMetrics.current.skippedCount = 0;
      }

      // Update state immediately to prevent lag
      setLastHash(newHash);
      const newState = { ...editorState, code: sess.code };
      setEditorState(newState);

      // Then update editor value
      if (newState.setValue) {
        try {
          newState.setValue(sess.code);
          const syncTime = performance.now() - now;
          lifetimeMetrics.current.longestSyncTime = Math.max(
            lifetimeMetrics.current.longestSyncTime,
            syncTime,
          );

          console.debug("[Editor] External sync completed:", {
            syncTime,
            codeLength: sess.code.length,
            timestamp: new Date().toISOString(),
          });
        } catch (error) {
          console.error("[Editor] Error updating editor value:", error);
        }
      }
    });

    return () => {
      try {
        unsubscribe();
      } catch (error) {
        console.error("[Editor] Error unsubscribing:", error);
      }
    };
  }, [editorState, cSess, session, lastHash, setEditorState]);

  // Initialize the editor once containerRef is available
  useEffect(() => {
    const initEditor = async () => {
      if (!session || !containerRef.current || editorState.started) return;

      try {
        console.debug("[Editor] Initializing editor", {
          codeSpace,
          containerRef: !!containerRef.current,
        });

        const { setValue } = await initializeEditor({
          container: containerRef.current,
          codeSpace,
          code: session.code,
          onChange: handleContentChange,
        });

        setEditorState((prev) => ({
          ...prev,
          started: true,
          code: session.code,
          setValue,
        }));

        // Run initial type check after editor is ready
        if (errorType) {
          await throttledTypeCheck();
        }

        console.debug("[Editor] Editor initialized successfully");
      } catch (error) {
        console.error("[Editor] Initialization error:", error);
      }
    };

    initEditor();
  }, [
    containerRef,
    editorState.started,
    setEditorState,
    initializeEditor,
    codeSpace,
    session,
    handleContentChange,
    errorType,
    throttledTypeCheck,
  ]);

  // Track aggregate metrics across component lifetime
  const lifetimeMetrics = useRef({
    startTime: performance.now(),
    totalLocalChanges: 0,
    totalExternalChanges: 0,
    totalSkippedChanges: 0,
    longestSyncTime: 0,
  });

  // Monitor component cleanup and log final statistics
  useEffect(() => {
    return () => {
      const duration = (performance.now() - lifetimeMetrics.current.startTime) /
        1000;
      console.info("[Editor] Component lifetime metrics:", {
        durationSeconds: duration.toFixed(2),
        avgLocalChangesPerMinute: (lifetimeMetrics.current.totalLocalChanges / (duration / 60))
          .toFixed(2),
        avgExternalChangesPerMinute:
          (lifetimeMetrics.current.totalExternalChanges / (duration / 60))
            .toFixed(2),
        totalSkippedChanges: lifetimeMetrics.current.totalSkippedChanges,
        longestSyncTimeMs: lifetimeMetrics.current.longestSyncTime.toFixed(2),
        codeSpace,
      });
    };
  }, [codeSpace]);

  // Consolidated cleanup and metrics tracking
  useEffect(() => {
    // Set up metrics update interval
    const metricsInterval = setInterval(() => {
      // Update local metrics
      lifetimeMetrics.current.totalLocalChanges += metrics.current.changeCount;
      lifetimeMetrics.current.totalSkippedChanges += metrics.current.skippedCount;

      // Update external metrics
      lifetimeMetrics.current.totalExternalChanges += externalMetrics.current.updateCount;
      lifetimeMetrics.current.totalSkippedChanges += externalMetrics.current.skippedCount;

      // Reset current counters after capturing their values
      metrics.current.changeCount = 0;
      metrics.current.skippedCount = 0;
      externalMetrics.current.updateCount = 0;
      externalMetrics.current.skippedCount = 0;
    }, 5000);

    return () => {
      // Clear interval
      clearInterval(metricsInterval);

      // Abort any pending operations
      controller.current.abort();

      // Final metrics capture
      metrics.current.changeCount = 0;
      metrics.current.skippedCount = 0;
      externalMetrics.current.updateCount = 0;
      externalMetrics.current.skippedCount = 0;

      // Log cleanup
      console.debug("[Editor] Component cleanup completed", {
        codeSpace,
        timestamp: new Date().toISOString(),
      });
    };
  }, [codeSpace]);

  if (!session) return null;

  return (
    <div className="flex h-screen w-full max-w-[800px] overflow-hidden">
      <div className="flex-grow overflow-hidden">
        <EditorNode
          engine="monaco"
          errorType={errorType}
          containerRef={containerRef}
          codeSpace={codeSpace}
        />
      </div>
    </div>
  );
};

```

# src/components/editorUtils.ts

```ts
import type { ImageData } from "@/lib/interfaces";
import { md5 } from "@/lib/md5";
import { prettierToThrow, transpile } from "@/lib/shared";
import { RunMessageResult } from "src/services/websocket/types";

export interface EditorState {
  started: boolean;
  sub: boolean;
  code: string;
  setValue: (code: string) => void;
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type AnyFunction = (...args: any[]) => any;

function memoize<T extends AnyFunction>(
  fn: T,
  keyResolver?: (...args: Parameters<T>) => string,
): T {
  const cache = new Map<string, ReturnType<T>>();

  return ((...args: Parameters<T>): ReturnType<T> => {
    const key = keyResolver ? keyResolver(...args) : JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key)!;
    }

    const result = fn(...args);
    cache.set(key, result);

    if (result instanceof Promise) {
      result.catch(() => {
        cache.delete(key);
      });
    }

    return result;
  }) as T;
}

type MemoizedFunctionWithAbort<T extends AnyFunction> = (
  ...args: [...Parameters<T>, AbortSignal]
) => ReturnType<T>;

export function memoizeWithAbort<T extends AnyFunction>(
  fn: T,
  keyResolver?: (...args: Parameters<T>) => string,
): MemoizedFunctionWithAbort<T> {
  interface Callbacks {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    resolve: (value: any) => void;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    reject: (reason?: any) => void;
    signal: AbortSignal;
  }

  const cache = new Map<
    string,
    { promise: Promise<ReturnType<T>>; callbacks: Callbacks[]; }
  >();

  return ((...args: [...Parameters<T>, AbortSignal]): ReturnType<T> => {
    const signal = args.pop() as AbortSignal;
    const fnArgs = args as unknown as Parameters<T>;
    const key = keyResolver ? keyResolver(...fnArgs) : JSON.stringify(fnArgs);

    if (cache.has(key)) {
      const entry = cache.get(key)!;
      const { promise, callbacks } = entry;

      if (signal.aborted) {
        return Promise.reject(
          new DOMException("Aborted", "AbortError"),
        ) as ReturnType<T>;
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const newPromise = new Promise<any>((resolve, reject) => {
        callbacks.push({ resolve, reject, signal });
        signal.addEventListener("abort", () => {
          reject(new DOMException("Aborted", "AbortError"));
        });
      });

      promise.then(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (value: any) => {
          callbacks.forEach((cb) => cb.resolve(value));
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (error: any) => {
          callbacks.forEach((cb) => cb.reject(error));
        },
      );

      return newPromise as ReturnType<T>;
    } else {
      if (signal.aborted) {
        return Promise.reject(
          new DOMException("Aborted", "AbortError"),
        ) as ReturnType<T>;
      }

      const callbacks: Callbacks[] = [];
      const promise = fn(...fnArgs).then(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (value: any) => {
          cache.delete(key);
          return value;
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (error: any) => {
          cache.delete(key);
          throw error;
        },
      );

      cache.set(key, { promise, callbacks });

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const newPromise = new Promise<any>((resolve, reject) => {
        callbacks.push({ resolve, reject, signal });
        signal.addEventListener("abort", () => {
          reject(new DOMException("Aborted", "AbortError"));
        });
      });

      promise.then(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (value: any) => {
          callbacks.forEach((cb) => cb.resolve(value));
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (error: any) => {
          callbacks.forEach((cb) => cb.reject(error));
        },
      );

      return newPromise as ReturnType<T>;
    }
  }) as MemoizedFunctionWithAbort<T>;
}

export const formatCode = memoize(async (code: string): Promise<string> => {
  try {
    return await prettierToThrow({ code, toThrow: true });
  } catch (error) {
    const errorMessage = typeof error === "string"
      ? error
      : (error as Error).message || JSON.stringify(error);
    throw new Error(
      `Prettier formatting failed: ${errorMessage.replace(/\\n/g, "\n").split('"').join('"')}`,
    );
  }
}, (code: string) => md5(code));

export const transpileCode = memoize(async (code: string): Promise<string> => {
  try {
    return await transpile({ code, originToUse: location.origin });
  } catch (error) {
    throw new Error(
      `Transpilation failed: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}, (code: string) => md5(code));

export const screenshot = (): Promise<ImageData> => {
  return new Promise<ImageData>((resolve) => {
    const messageHandler = (ev: MessageEvent): void => {
      if (ev.data.type === "screenshot") {
        const imageData = ev.data.imageData as ImageData;
        window.removeEventListener("message", messageHandler);

        resolve(imageData);
      }
    };

    const iframe = document.querySelector("iframe");
    // Only listen for messages from our iframe
    window.addEventListener("message", (event) => {
      if (iframe && event.source === iframe.contentWindow) {
        messageHandler(event);
      }
    });

    document.querySelector("iframe")?.contentWindow?.postMessage({
      type: "screenshot",
      sender: "Runner / Editor",
    }, "*");
  });
};

export const runCode = async (
  transpiled: string,
): Promise<RunMessageResult | false> => {
  return new Promise((resolve) => {
    const iframe = document.querySelector("iframe");
    if (!iframe || !iframe.contentWindow) {
      console.error("No iframe found for code execution");
      return resolve(false);
    }

    const messageHandler = (event: MessageEvent) => {
      if (
        iframe && event.source === iframe.contentWindow &&
        event.data.type === "code-execution-result"
      ) {
        window.removeEventListener("message", messageHandler);
        resolve(event.data.result);
      }
    };

    window.addEventListener("message", messageHandler);

    iframe.contentWindow.postMessage({
      type: "execute-code",
      code: transpiled,
    }, "*");

    // Add timeout to prevent hanging
    setTimeout(() => {
      window.removeEventListener("message", messageHandler);
      console.error("Code execution timed out");
      resolve(false);
    }, 5000);
  });
};

export interface EditorInitOptions {
  container: HTMLDivElement;
  codeSpace: string;
  code: string;
  onChange: (newCode: string) => void;
}

export interface EditorInstance {
  getValue: () => string;
  silent: boolean;
  getErrors: () => Promise<string[]>;
  isEdit: boolean;
  setValue: (_newCode: string) => void;
}

export async function initializeMonaco(
  options: EditorInitOptions,
): Promise<EditorInstance> {
  const { startMonaco } = await import("../monaco-edi");
  return await startMonaco(options);
}

```

# src/components/ErrorMessages.ts

```ts
// errorMessages.ts

export const errorMessages = {
  typescript: "There might be a TypeScript error in your code. Check the editor for more details.",
  prettier: "There was an issue formatting your code. It might contain syntax errors.",
  transpile: "Your code couldn't be transpiled. There might be a syntax or compilation error.",
  render: "The code was transpiled, but no HTML output was generated. Check your render function.",
};

export type ErrorType = keyof typeof errorMessages | null;

```

# src/components/ErrorReminder.tsx

```tsx
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { ScrollArea } from "@/components/ui/scroll-area";
import { AlertCircle, X } from "@/external/lucide-react";
import { ContextManager } from "@/lib/context-manager";
import { cn } from "@/lib/utils";
import { AnimatePresence, motion } from "framer-motion";
import React, { useState } from "react";
import { useErrorEffect } from "../hooks/useErrorEffect";
import { errorMessages } from "./ErrorMessages";
import type { ErrorType } from "./ErrorMessages";

export const EditorNode: React.FC<{
  engine: "monaco" | "ace";
  errorType: ErrorType;
  containerRef: React.Ref<HTMLDivElement>;
  codeSpace: string;
}> = ({ errorType, containerRef, codeSpace }) => {
  const [errorHeight, setErrorHeight] = useState(0);

  return (
    <div className="w-full h-full flex flex-col">
      <ErrorReminder
        errorType={errorType}
        onHeightChange={setErrorHeight}
        codeSpace={codeSpace}
      />
      <motion.div
        className="flex-grow relative"
        animate={{ marginTop: errorHeight }}
        transition={{ duration: 0.3 }}
      >
        <div
          data-testid="editor-container"
          ref={containerRef}
          className="absolute inset-0"
        />
      </motion.div>
    </div>
  );
};

interface ErrorReminderProps {
  errorType: ErrorType;
  onHeightChange: (height: number) => void;
  codeSpace: string;
}

export const ErrorReminder: React.FC<ErrorReminderProps> = ({
  errorType,
  onHeightChange,
  codeSpace,
}) => {
  const [showError, setShowError] = useState(false);
  const contextManager = new ContextManager(codeSpace);
  useErrorEffect(errorType, codeSpace, contextManager, setShowError);

  const errorLog = contextManager.getContext("errorLog");

  return (
    <AnimatePresence
      initial={false}
      onExitComplete={() => onHeightChange(0)}
    >
      {showError && errorType && (
        <motion.div
          className="absolute top-0 left-0 right-0 z-50"
          initial={{ height: 0, opacity: 0 }}
          animate={{ height: "auto", opacity: 1 }}
          exit={{ height: 0, opacity: 0 }}
          transition={{ duration: 0.3 }}
          onUpdate={(latest) => {
            if (typeof latest.height === "number") {
              onHeightChange(latest.height);
            }
          }}
        >
          <Card
            className={cn("mb-4 border-l-4", {
              "border-l-red-500": errorType === "typescript" ||
                errorType === "transpile",
              "border-l-yellow-500": errorType === "prettier",
              "border-l-orange-500": errorType === "render",
            })}
          >
            <CardHeader className="flex flex-row items-center justify-between pb-2">
              <CardTitle className="flex items-center text-lg font-semibold">
                <AlertCircle className="h-5 w-5 mr-2 text-red-500" />
                Code Issue Detected
              </CardTitle>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setShowError(false)}
                className="h-8 w-8 p-0"
              >
                <X className="h-4 w-4" />
              </Button>
            </CardHeader>
            <CardContent>
              <Alert
                variant="destructive"
                className="mb-4 bg-red-50 text-red-800 border-red-200"
              >
                <AlertTitle>{errorMessages[errorType]}</AlertTitle>
                {errorLog && (
                  <AlertDescription>
                    <h4 className="font-semibold text-sm">Error Log:</h4>
                    <ScrollArea className="h-[100px]">
                      <pre className="text-xs font-mono whitespace-pre-wrap text-gray-700">
                      {errorLog.split('\n').map((log: string, index: number) => (
                        <div key={index} className="mb-1">
                          {log}
                        </div>
                      ))}
                      </pre>
                    </ScrollArea>
                  </AlertDescription>
                )}
              </Alert>
            </CardContent>
          </Card>
        </motion.div>
      )}
    </AnimatePresence>
  );
};

```

# src/components/History/HistoryFComponents.tsx

```tsx
import { Wrapper } from "@/components/app/wrapper";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Dialog, DialogContent, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { ScrollArea } from "@/components/ui/scroll-area";
import type { HistoryItemProps, ICode, IHistoryItem } from "@/lib/interfaces";
import { cn } from "@/lib/utils";
import React from "react";

const format = (date: Date): string =>
  new Intl.DateTimeFormat("en-GB", {
    dateStyle: "full",
    timeStyle: "short",
  }).format(date);
// HistoryItem component
const HistoryItem: React.FC<HistoryItemProps> = (
  { item, index, totalItems, onRestore, onDelete },
) => (
  <Card className={cn("flex flex-col h-full")}>
    <CardHeader>
      <CardTitle>Version {totalItems - index}</CardTitle>
    </CardHeader>
    <CardContent className={cn("flex-grow flex flex-col")}>
      <p className={cn("text-sm text-gray-500 mb-2")}>
        {format(new Date(item.timestamp))}
      </p>
      <div className={cn("flex-grow mb-4")}>
        <Wrapper code={item.code} />
      </div>
      <div className={cn("space-x-2")}>
        <Dialog>
          <DialogTrigger asChild>
            <Button variant="outline">View Source</Button>
          </DialogTrigger>
          <DialogContent
            className={cn("max-w-3xl max-h-[80vh] overflow-y-auto")}
            aria-describedby="dialog-description"
          >
            <DialogTitle>
              Source Code - Version {totalItems - index}
            </DialogTitle>
            <pre className={cn("bg-gray-100 p-4 rounded-md overflow-x-auto")}>
              <code>{item.code}</code>
            </pre>
          </DialogContent>
        </Dialog>
        <Button onClick={() => onRestore(item)}>Restore</Button>
        <Button variant="destructive" onClick={() => onDelete(item.timestamp)}>
          Delete
        </Button>
      </div>
    </CardContent>
  </Card>
);

// RestoreStatusAlert component
const RestoreStatusAlert = (
  { status }: { status: { type: string; message: string; }; },
) => (
  <Alert variant={status.type === "error" ? "destructive" : "default"}>
    <AlertTitle>
      {status.type === "loading"
        ? "Restoring"
        : status.type === "success"
        ? "Success"
        : "Error"}
    </AlertTitle>
    <AlertDescription>{status.message}</AlertDescription>
  </Alert>
);

// FullScreenHistoryView component
const FullScreenHistoryView: React.FC<{
  history: IHistoryItem[];
  onRestore: (item: IHistoryItem) => void;
  onClose: () => void;
  onDelete: (timestamp: number) => void;
  cSess: ICode;
}> = ({ history, onRestore, onClose, onDelete, cSess }) => (
  <div className={cn("fixed inset-0 bg-white z-50")}>
    <ScrollArea className={cn("h-full")}>
      <div className={cn("container mx-auto p-4")}>
        <div className={cn("flex justify-between items-center mb-4")}>
          <h2 className={cn("text-2xl font-bold")}>Code History</h2>
          <Button onClick={onClose}>Close</Button>
        </div>
        <div
          className={cn("grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6")}
        >
          {history.map((item, index) => (
            <HistoryItem
              key={item.timestamp}
              item={item}
              index={index}
              totalItems={history.length}
              onDelete={async (timestamp) => {
                try {
                  const session = await cSess.getSession();
                  await fetch(
                    `/live/${session.codeSpace}/auto-save/history/delete/${timestamp}`,
                  );
                  onDelete(timestamp);
                } catch (error) {
                  console.error(error);
                }
              }}
              onRestore={async () => {
                try {
                  await cSess.setCode(item.code);
                } catch (error) {
                  console.error(error);
                } finally {
                  onRestore(item);
                }
              }}
              cSess={cSess}
            />
          ))}
        </div>
      </div>
    </ScrollArea>
  </div>
);

export { FullScreenHistoryView, HistoryItem, RestoreStatusAlert };

```

# src/components/icons.tsx

```tsx
import type { FC, ReactNode } from "react";

import { MdPhoneAndroid, MdQrCode, MdShare, MdTabletAndroid, MdTv } from "@/external/icons";

const Wrap: FC<{ children: ReactNode; }> = ({ children }) => (
  <span className="text-2xl">
    {children}
  </span>
);

export const QrCodeIcon = () => (
  <Wrap>
    <MdQrCode />
  </Wrap>
);
export const Phone = () => (
  <Wrap>
    <MdPhoneAndroid />
  </Wrap>
);

export const Share = () => (
  <Wrap>
    <MdShare />
  </Wrap>
);

export const Tablet = () => (
  <Wrap>
    <MdTabletAndroid />
  </Wrap>
);

export const Tv = () => (
  <Wrap>
    <MdTv />
  </Wrap>
);

// Import { MdPhoneAndroid, MdShare, MdTabletAndroid, MdTv } from "react-icons/md";

// export const Phone = () => (
//   <span css={css`font-size:20pt;`}>
//     <MdPhoneAndroid />
//   </span>
// );

// export const Share = () => (
//   <span css={css`font-size:20pt;`}>
//     <MdShare />
//   </span>
// );

// export const Tablet = () => (
//   <span css={css`font-size:20pt;`}>
//     <MdTabletAndroid />
//   </span>
// );

// export const Tv = () => (
//   <span css={css`font-size:20pt;`}>
//     <MdTv />
//   </span>
// );

```

# src/components/KeyboardAwareComponent.tsx

```tsx
import { useEffect, useState } from "react";
import type { FC } from "react";

const KeyboardAwareComponent: FC<{ children: React.ReactNode; }> = (
  { children },
) => {
  const [isKeyboardVisible, setIsKeyboardVisible] = useState(false);

  useEffect(() => {
    const detectKeyboard = () => {
      const isKeyboard = visualViewport !== null &&
        window.screen.height > visualViewport.height;
      setIsKeyboardVisible(isKeyboard);
    };

    visualViewport?.addEventListener("resize", detectKeyboard);
    return () => visualViewport?.removeEventListener("resize", detectKeyboard);
  }, []);

  return (
    <div
      className={`app-container ${isKeyboardVisible ? "keyboard-visible" : ""}`}
    >
      {children}
    </div>
  );
};

export default KeyboardAwareComponent;

```

# src/components/MotionContainer.tsx

```tsx
import { css } from "@emotion/react";
import { motion } from "framer-motion";

const rgba = (r: number, g: number, b: number, a: number) =>
  `rgba(${r || 1}, ${g || 1}, ${b || 1}, ${a || 0.7})`;

export const MotionContainer = (
  { children, bottom, right, bgColor, isChatOpen }: {
    children: React.ReactElement;
    bottom: number;
    right: number;
    bgColor: number[];
    isChatOpen: boolean;
  },
) => {
  return (
    <motion.div
      layout
      initial={{ padding: 0, top: 0, right: 0, borderRadius: 0 }}
      animate={{
        padding: 8,
        top: bottom,
        right: isChatOpen ? window.innerWidth / 2 : 0 + right,
        backgroundColor: rgba(bgColor[0], bgColor[1], bgColor[2], 0.5),
        borderRadius: 16,
      }}
      style={{ backgroundColor: rgba(bgColor[0], bgColor[1], bgColor[2], 0.5) }}
      css={css`
      z-index: 1002;
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      position: fixed;
    `}
      drag
      dragMomentum={false}
      dragConstraints={{
        left: -innerWidth,
        right: innerWidth - 20 - innerWidth / 6,
        bottom: innerHeight,
      }}
      dragElastic={0.5}
    >
      {children}
    </motion.div>
  );
};

```

# src/components/Qr.lazy.tsx

```tsx
import { lazy, Suspense } from "react";
import type { FC } from "react";

const LQR = lazy(() => import("./Qr"));
export const QRButton: FC<{ url: string; }> = ({ url }) => (
  <Suspense fallback={<div>qr</div>}>
    <LQR url={url} />
  </Suspense>
);

```

# src/components/Qr.tsx

```tsx
import type { FC } from "react";

import { m } from "framer-motion";

import { useState } from "react";

import { QRious } from "@/external/react-qrious";
import { QrCodeIcon } from "./icons";

import { Fab } from "@/external/mui-material";

export const QRButton: FC<{ url: string; }> = ({ url }) => {
  const [showQR, setQR] = useState(false);
  return (
    <m.div
      animate={{
        width: showQR ? 200 : 56,
        marginLeft: showQR ? 8 : 0,
        marginRight: showQR ? -100 : 0,
        height: showQR ? 220 : 48,
      }}
      onTap={() => {
        setQR(!showQR);
      }}
      className="mt-3 mb-3"
    >
      {showQR
        ? (
          <QRious
            key={url || origin + url}
            value={url || "/live/coder"}
          />
        )
        : (
          <Fab>
            <QrCodeIcon />
          </Fab>
        )}
    </m.div>
  );
};
export default QRButton;

```

# src/components/Rainbow.tsx

```tsx
import { css, keyframes } from "@emotion/react";
import styled from "@emotion/styled";
import type { FC, ReactNode } from "react";

// Define a type for the gradient colors
interface GradientColor {
  color: string;
  percentage: number;
}

// Define a function to create the gradient string
const createGradientString = (colors: GradientColor[]): string => {
  return colors.map((color) => `${color.color} 0, ${color.color} ${color.percentage}%`).join(", ");
};

// Define the gradient colors
const gradientColors: GradientColor[] = [
  { color: "#fedc00", percentage: 5.5555555556 },
  { color: "#fcb712", percentage: 11.1111111111 },
  { color: "#f7921e", percentage: 16.6666666667 },
  { color: "#e87f24", percentage: 22.2222222222 },
  { color: "#dd6227", percentage: 27.7777777778 },
  { color: "#dc4c27", percentage: 33.3333333333 },
  { color: "#ca3435", percentage: 38.8888888889 },
  { color: "#b82841", percentage: 44.4444444444 },
  { color: "#953751", percentage: 50 },
  { color: "#364c88", percentage: 55.5555555556 },
  { color: "#16599d", percentage: 61.1111111111 },
  { color: "#02609e", percentage: 66.6666666667 },
  { color: "#0073a9", percentage: 72.2222222222 },
  { color: "#008aa4", percentage: 77.7777777778 },
  { color: "#239a87", percentage: 83.3333333333 },
  { color: "#7cba6d", percentage: 88.8888888889 },
  { color: "#becc2f", percentage: 94.4444444444 },
  { color: "#e0d81d", percentage: 100 },
];

const Rainbow = () => {
  const rotateAnimation = keyframes`
      0% { background-position: 0% 50%; } 
      100% { background-position: 100% 50%; }
    `;

  const gradientStyle = css`
      position: absolute;
      top: 0;
      left: 0;
      height: 100dvh;
      height: 100svh;
      width: 100vw;
      background-blend-mode: overlay;
      background: 
        repeating-radial-gradient(
          circle at bottom left,
          ${createGradientString(gradientColors)}
        ),
        repeating-radial-gradient(
          circle at bottom right,
          ${createGradientString(gradientColors)}
        );
      background-size: 200% 200%;
      animation: ${rotateAnimation} 10s forwards;
      animation-delay: 2s;
    `;

  return <div css={gradientStyle}></div>;
};

const RainbowContainer = styled.div`
    display: flex;
    position: relative;
    height: 100%;
    width: 100%;
  `;

export const RainbowWrapper: FC<{ children: ReactNode; }> = ({ children }) => (
  <RainbowContainer>
    <Rainbow />
    {children}
  </RainbowContainer>
);

```

# src/components/ScaledContent.tsx

```tsx
import { motion } from "framer-motion";

export const ScaledContent = (
  { children, innerHeight, width, scale, bgColor, rgba }: {
    children: React.ReactElement;
    innerHeight: number;
    width: number;
    scale: number;
    bgColor: number[];
    rgba: (r: number, g: number, b: number, a: number) => string;
  },
): React.ReactElement => (
  <motion.div
    transition={{ zoom: { type: "spring" }, delay: 0 }}
    className="origin-top-left inline-block rounded-lg overflow-hidden"
    style={{
      backgroundColor: rgba(bgColor[0], bgColor[1], bgColor[2], 0.5),
    }}
    initial={{
      height: innerHeight,
      width: innerWidth,
      scale: 1,
    }}
    animate={{ height: innerHeight, width, scale }}
  >
    {children}
  </motion.div>
);

```

# src/components/ScaleRangeButtons.tsx

```tsx
import { ToggleButton, ToggleButtonGroup } from "@/external/mui-material";
import { cn } from "@/lib/utils";
import { motion } from "framer-motion";

interface ScaleRangeButtonsProps {
  scaleRange: number;
  setScaleRange: (value: number) => void;
  sizes: number[];
  maxScaleRange: number;
}

export const ScaleRangeButtons: React.FC<ScaleRangeButtonsProps> = ({
  scaleRange,
  setScaleRange,
  sizes,
  maxScaleRange,
}) => {
  return (
    <motion.div
      layout
      className="overflow-hidden flex justify-evenly"
      initial={{ height: 0, width: 0 }}
      animate={{ height: 42, width: "100%" }}
    >
      <ToggleButtonGroup
        value={scaleRange}
        size="small"
        exclusive
        onChange={(_e, newScale) => {
          if (newScale !== null) setScaleRange(newScale);
        }}
      >
        {Array.from(
          new Set([
            ...sizes.filter((x) => x < maxScaleRange),
            scaleRange,
            maxScaleRange,
          ]),
        )
          .sort((a, b) => a - b)
          .map((size) => (
            <ToggleButton key={size} value={size}>
              <span
                className={cn(
                  size === scaleRange ? "text-highlight" : "text-normal",
                )}
              >
                {size}%
              </span>
            </ToggleButton>
          ))}
      </ToggleButtonGroup>
    </motion.div>
  );
};

```

# src/config/cSessMock.ts

```ts
import type { ICode, ICodeSession, ImageData, Message } from "@/lib/interfaces";

class SessMock implements ICode {
  codeSpace = "mock-code-space";

  private subs: Array<(sess: ICodeSession) => void> = [];

  private session: ICodeSession = {
    code: "",
    codeSpace: "",
    html: "",
    messages: [],
    transpiled: "",
    css: "",
  };

  getSession = async (): Promise<ICodeSession> => this.session;

  getCodeSpace(): string {
    return this.codeSpace;
  }
  setSession = async (sess: ICodeSession): Promise<void> => {
    this.session = sess;
    this.broadCastSessChanged();
  };

  init: () => Promise<ICodeSession> = async () => {
    return this.session;
  };

  sub(fn: (sess: ICodeSession) => void) {
    this.subs.push(fn);
    return () => {
      this.subs = this.subs.filter((f) => f !== fn);
    };
  }

  addMessageChunk(chunk: string) {
    const message: Message = {
      id: "mock-id",
      role: "user",
      content: chunk,
    };
    this.session.messages.push(message);
    this.broadCastSessChanged();
  }

  setMessages(messages: Message[]) {
    this.session.messages = messages;
    return true;
  }

  broadCastSessChanged() {
    this.subs.forEach((cb) => cb(this.session));
  }

  async setCode(rawCode: string): Promise<string> {
    this.session.code = rawCode;
    this.broadCastSessChanged();
    return rawCode;
  }

  async screenshot(): Promise<ImageData> {
    return {
      imageName: "mock-screenshot.png",
      url: "https://example.com/mock-screenshot.png",
      src: "data:image/png;base64,mockedBase64Data",
      mediaType: "image/png",
      data: "mockedBase64Data",
      type: "image/png",
    };
  }

  async getCode(): Promise<string> {
    return this.session.code;
  }

  getMessages = () => this.session.messages;
}

export const cSessMock = new SessMock();

```

# src/config/routes.ts

```ts
/**
 * Application route configuration
 * Contains all route patterns used throughout the application
 */
export const ROUTES = {
  /**
   * Live coding route pattern
   * @param codeSpace - The unique identifier for the code space
   * @returns The formatted live coding route
   */
  LIVE: (codeSpace: string): string => `/live/${codeSpace}`,

  /**
   * Live CMS route pattern
   * @param codeSpace - The unique identifier for the code space
   * @returns The formatted live CMS route
   */
  LIVE_CMS: (codeSpace: string): string => `/live-cms/${codeSpace}`,

  /**
   * Dehydrated state route pattern
   * @param codeSpace - The unique identifier for the code space
   * @returns The formatted dehydrated state route
   */
  DEHYDRATED: (codeSpace: string): string => `/live/${codeSpace}/dehydrated`,
} as const;

/**
 * Type-safe route parameters
 */
export interface RouteParams {
  codeSpace: string;
}

/**
 * Route utilities for common operations
 */
export const RouteUtils = {
  /**
   * Check if the given path is a live route
   * @param pathname - The path to check
   * @returns True if the path is a live route
   */
  isLiveRoute: (pathname: string): boolean => pathname.startsWith("/live/"),

  /**
   * Check if the given path is a live CMS route
   * @param pathname - The path to check
   * @returns True if the path is a live CMS route
   */
  isLiveCMSRoute: (pathname: string): boolean => pathname.startsWith("/live-cms/"),

  /**
   * Check if the given path is a dehydrated route
   * @param pathname - The path to check
   * @returns True if the path is a dehydrated route
   */
  isDehydratedRoute: (pathname: string): boolean => pathname.endsWith("dehydrated"),

  /**
   * Check if the app should be rendered for the given path
   * @param pathname - The path to check
   * @returns True if the app should be rendered
   */
  shouldRenderApp: (pathname: string): boolean =>
    (RouteUtils.isLiveRoute(pathname) || RouteUtils.isLiveCMSRoute(pathname)) &&
    !RouteUtils.isDehydratedRoute(pathname) &&
    !pathname.endsWith("/"),
} as const;

```

# src/css.ts

```ts
/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

import type { AnyNode, ChildNode, Rule } from "postcss";
import { parse, stringify } from "postcss";
import type Root_ from "postcss/lib/root";

/**
 * Parse a textual CSS Stylesheet into a Stylesheet instance.
 * Stylesheet is a mutable postcss AST with format similar to CSSOM.
 * @see https://github.com/postcss/postcss/
 * @private
 */
export function parseStylesheet(stylesheet: string) {
  return parse(stylesheet);
}

/**
 * Options used by the stringify logic
 */
interface SerializeStylesheetOptions {
  /** Compress CSS output (removes comments, whitespace, etc) */
  compress?: boolean;
}

/**
 * Serialize a postcss Stylesheet to a String of CSS.
 * @private
 * @param ast A Stylesheet to serialize, such as one returned from `parseStylesheet()`
 */
export function serializeStylesheet(
  ast: AnyNode,
  options: SerializeStylesheetOptions,
) {
  const cssParts: string[] = [];

  stringify(ast, (result, node, type) => {
    if (node?.type === "decl" && node.value.includes("</style>")) {
      return;
    }

    if (!options.compress) {
      cssParts.push(result);
      return;
    }

    // Simple minification logic
    if (node?.type === "comment") {
      return;
    }

    if (node?.type === "decl") {
      const prefix = node.prop + node.raws.between;

      cssParts.push(result.replace(prefix, prefix.trim()));
      return;
    }

    if (type === "start") {
      if (node?.type === "rule" && node.selectors) {
        if (node.selectors.length === 1) {
          cssParts.push(node.selectors[0] ?? "", "{");
        } else {
          cssParts.push(node.selectors.join(","), "{");
        }
      } else {
        cssParts.push(result.trim());
      }
      return;
    }

    if (type === "end" && result === "}" && node?.raws?.semicolon) {
      const lastItemIdx = cssParts.length - 2;
      if (lastItemIdx >= 0 && cssParts[lastItemIdx]) {
        cssParts[lastItemIdx] = cssParts[lastItemIdx].slice(0, -1);
      }
    }

    cssParts.push(result.trim());
  });

  return cssParts.join("");
}

type SingleIterator<T> = (item: T) => boolean | void;

/**
 * Converts a walkStyleRules() iterator to mark nodes with `.$$remove=true` instead of actually removing them.
 * This means they can be removed in a second pass, allowing the first pass to be nondestructive (eg: to preserve mirrored sheets).
 * @private
 * @param predicate   Invoked on each node in the tree. Return `false` to remove that node.
 */
export function markOnly(
  predicate: SingleIterator<ChildNode | Root_>,
): (rule: Rule | ChildNode | Root_) => void {
  return (rule) => {
    const sel = "selectors" in rule ? rule.selectors : undefined;
    if (predicate(rule) === false) {
      rule.$$remove = true;
    }
    if ("selectors" in rule) {
      rule.$$markedSelectors = rule.selectors;
      rule.selectors = sel!;
    }
    if (rule._other) {
      rule._other.$$markedSelectors = rule._other.selectors;
    }
  };
}

/**
 * Apply filtered selectors to a rule from a previous markOnly run.
 * @private
 * @param rule The Rule to apply marked selectors to (if they exist).
 */
export function applyMarkedSelectors(rule: Rule) {
  if (rule.$$markedSelectors) {
    rule.selectors = rule.$$markedSelectors;
  }
  if (rule._other) {
    applyMarkedSelectors(rule._other);
  }
}

/**
 * Recursively walk all rules in a stylesheet.
 * @private
 * @param node       A Stylesheet or Rule to descend into.
 * @param iterator   Invoked on each node in the tree. Return `false` to remove that node.
 */
export function walkStyleRules(
  node: ChildNode | Root_,
  iterator: SingleIterator<ChildNode | Root_ | Rule>,
) {
  if (!("nodes" in node)) {
    return;
  }
  node.nodes = node.nodes?.filter((rule) => {
    if (hasNestedRules(rule)) {
      walkStyleRules(rule, iterator);
    }
    rule._other = undefined;
    rule.filterSelectors = filterSelectors;
    return iterator(rule) !== false;
  });
}

/**
 * Recursively walk all rules in two identical stylesheets, filtering nodes into one or the other based on a predicate.
 * @private
 * @param node       A Stylesheet or Rule to descend into.
 * @param node2      A second tree identical to `node`
 * @param iterator   Invoked on each node in the tree. Return `false` to remove that node from the first tree, true to remove it from the second.
 */
export function walkStyleRulesWithReverseMirror(
  node: Rule | Root_,
  node2: Rule | Root_ | undefined | null,
  iterator: SingleIterator<ChildNode | Root_>,
) {
  if (!node2) {
    return walkStyleRules(node, iterator);
  }

  [node.nodes, node2.nodes] = splitFilter(
    node.nodes,
    node2.nodes,
    (rule, index, _rules, rules2) => {
      const rule2 = rules2?.[index];
      if (hasNestedRules(rule)) {
        walkStyleRulesWithReverseMirror(rule, rule2 as Rule, iterator);
      }
      rule._other = rule2 as Rule;
      rule.filterSelectors = filterSelectors;
      return iterator(rule) !== false;
    },
  );
}

// Checks if a node has nested rules, like @media
// @keyframes are an exception since they are evaluated as a whole
function hasNestedRules(rule: ChildNode): rule is Rule {
  return (
    "nodes" in rule &&
    !!rule.nodes?.length &&
    (!("name" in rule) ||
      (rule.name !== "keyframes" && rule.name !== "-webkit-keyframes")) &&
    rule.nodes.some((n) => n.type === "rule" || n.type === "atrule")
  );
}

// Like [].filter(), but applies the opposite filtering result to a second copy of the Array without a second pass.
// This is just a quicker version of generating the compliment of the set returned from a filter operation.
type SplitIterator<T> = (item: T, index: number, a: T[], b?: T[]) => boolean;
function splitFilter<T>(a: T[], b: T[], predicate: SplitIterator<T>) {
  const aOut: T[] = [];
  const bOut: T[] = [];
  for (let index = 0; index < a.length; index++) {
    const item = a[index]!;
    if (predicate(item, index, a, b)) {
      aOut.push(item);
    } else {
      bOut.push(item);
    }
  }
  return [aOut, bOut] as const;
}

// can be invoked on a style rule to subset its selectors (with reverse mirroring)
function filterSelectors(this: Rule, predicate: SplitIterator<string>) {
  if (this._other) {
    const [a, b] = splitFilter(
      this.selectors,
      this._other.selectors,
      predicate,
    );
    this.selectors = a;
    this._other.selectors = b;
  } else {
    this.selectors = this.selectors.filter(predicate);
  }
}

declare module "postcss" {
  interface Node {
    _other?: Rule;
    $$remove?: boolean;
    $$markedSelectors?: string[];
    filterSelectors?: typeof filterSelectors;
  }
}

```

# src/DraggableWindow.tsx

```tsx
import { MotionConfig } from "framer-motion";
import { FC, useCallback, useEffect, useMemo, useState } from "react";
import { useWindowSize } from "react-use";
import { DraggableWindowContent } from "./components/DraggableWindowContent";
import { MotionContainer } from "./components/MotionContainer";
import { useDownload } from "./hooks/useDownload";

interface Position {
  bottom: number;
  right: number;
}

interface DraggableWindowProps {
  children: React.ReactElement;
  codeSpace: string;
  isChatOpen: boolean;
  initialDelay?: number;
  initialScale?: number;
}

const BREAK_POINTS = {
  mobile: 750,
  tablet: 1024,
  desktop: 1920,
} as const;

const SCALE_SIZES = [10, 25, 50, 75, 100] as const;
const MAX_SCALE_RANGE = 100;
const INITIAL_POSITION: Position = { bottom: 0, right: 0 };
const REVEALED_POSITION: Position = { bottom: 20, right: 20 };

export const DraggableWindow: FC<DraggableWindowProps> = ({
  children,
  codeSpace,
  isChatOpen,
  initialDelay = 2,
  initialScale = 100,
}) => {
  const [scaleRange, setScaleRange] = useState(initialScale);
  const [delay, setDelay] = useState(initialDelay);
  const { width: innerWidth, height: innerHeight } = useWindowSize();
  const [width, setWidth] = useState(innerWidth);
  const [bgColor, setBgColor] = useState([66, 66, 66, 0.5]);

  const [positions, setPositions] = useState<Position>(INITIAL_POSITION);
  const handleDownload = useDownload(codeSpace);

  const scale = useMemo(() => scaleRange / MAX_SCALE_RANGE, [scaleRange]);

  const rgba = (r: number, g: number, b: number, a: number) =>
    `rgba(${r || 1}, ${g || 1}, ${b || 1}, ${a || 0.7})`;

  const calculateRevealScale = useCallback(() => {
    return Math.min(
      50,
      Math.floor(
        100 * (1 / 2 - 152 / (window.devicePixelRatio * window.innerWidth)),
      ),
    );
  }, []);

  const determineInitialWidth = useCallback(() => {
    return window.devicePixelRatio > 2
      ? BREAK_POINTS.mobile
      : BREAK_POINTS.tablet;
  }, []);

  const reveal = useCallback(() => {
    setScaleRange(calculateRevealScale());
    setWidth(determineInitialWidth());
    setBgColor([66, 66, 66, 0.5]);
    setPositions(REVEALED_POSITION);
    setDelay(0);
  }, [calculateRevealScale, determineInitialWidth, setBgColor]);

  useEffect(() => {
    const timeoutId = setTimeout(reveal, 2000);
    return () => clearTimeout(timeoutId);
  }, [reveal]);

  const transition = useMemo(() => ({
    delay,
    type: sessionStorage?.getItem("type") || "spring",
    duration: Number(sessionStorage?.getItem("duration")) || 1,
  }), [delay]);

  return (
    <MotionConfig transition={transition}>
      <MotionContainer
        bottom={positions.bottom}
        isChatOpen={isChatOpen}
        right={positions.right}
        bgColor={bgColor}
      >
        <DraggableWindowContent
          scaleRange={scaleRange}
          rgba={rgba}
          setScaleRange={setScaleRange}
          width={width}
          setWidth={setWidth}
          codeSpace={codeSpace}
          handleDownload={handleDownload}
          scale={scale}
          sizes={[...SCALE_SIZES]}
          maxScaleRange={MAX_SCALE_RANGE}
          breakPoints={Object.values(BREAK_POINTS)}
          innerHeight={innerHeight}
          bgColor={bgColor}
        >
          {children}
        </DraggableWindowContent>
      </MotionContainer>
    </MotionConfig>
  );
};

```

# src/enhancedFetch.ts

```ts
export const serverFetchUrl = "/api/server-fetch";

export const enhancedFetch = async (
  url: RequestInfo | URL,
  options: RequestInit = {},
) => {
  const controller = new AbortController();
  const { signal: originalSignal } = options;

  const combinedSignal = originalSignal
    ? anySignal([originalSignal, controller.signal])
    : controller.signal;

  try {
    const res = await fetch(url, {
      signal: combinedSignal,
      ...options,
    });
    if (!res || !res.ok) {
      throw new Error(res.statusText);
    }
    return res;
  } catch (error) {
    // console.error("Error in enhancedFetch", error);

    return fetch(serverFetchUrl, {
      signal: combinedSignal,
      method: "POST",
      body: JSON.stringify({
        options: {
          method: "GET",
          ...options,
        },
        url,
      }),
    });
    controller.abort();
    throw error;
  }
};

function anySignal(signals: AbortSignal[]): AbortSignal {
  const controller = new AbortController();
  for (const signal of signals) {
    if (signal.aborted) {
      controller.abort(signal.reason);
      return controller.signal;
    }
    signal.addEventListener("abort", () => controller.abort(signal.reason), {
      once: true,
    });
  }
  return controller.signal;
}

```

# src/esbuildWASM.ts

```ts
import wasmUrl from "esbuild-wasm/esbuild.wasm";
export { wasmUrl as wasmFile };

```

# src/hooks/autoSave.ts

```ts
import { useCallback, useEffect, useRef } from "react";

interface AutoSaveOptions {
  key: string;
  data: unknown;
  debounceMs?: number;
}

const MAX_HISTORY_LENGTH = 100; // Adjust this value as needed

export const useAutoSave = (
  { key, data, debounceMs = 1000 }: AutoSaveOptions,
) => {
  const timerRef = useRef<NodeJS.Timeout | null>(null);

  const saveData = useCallback(async () => {
    const timestamp = Date.now();
    const storageKey = `${key}_${timestamp}`;

    try {
      // Save the current data with the timestamp key
      await localStorage.setItem(storageKey, JSON.stringify(data));

      // Update the inventory of timestamps
      const inventory = JSON.parse(
        await localStorage.getItem(`${key}_inventory`) || "[]",
      );
      inventory.push(timestamp);

      // Limit the inventory size
      if (inventory.length > MAX_HISTORY_LENGTH) {
        const removedTimestamp = inventory.shift();
        await localStorage.removeItem(`${key}_${removedTimestamp}`);
      }

      // Save the updated inventory
      await localStorage.setItem(`${key}_inventory`, JSON.stringify(inventory));

      console.log(`Data saved at ${new Date(timestamp).toISOString()}`);
    } catch (error) {
      console.error("Error saving data:", error);
    }
  }, [key, data]);

  useEffect(() => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }

    timerRef.current = setTimeout(saveData, debounceMs);

    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, [data, debounceMs, saveData]);

  return { saveData };
};

```

# src/hooks/processCSS.ts

```ts
const urlCache = new Map<string, string>();

async function processCSS(
  css: string,
  baseURL: string,
  depth = 0,
): Promise<string> {
  if (depth > 5) {
    console.warn("Maximum CSS processing depth reached");
    return css;
  }

  try {
    // Handle @import statements
    const importRegex = /@import\s+(?:url\(['"]?(.+?)['"]?\)|['"](.+?)['"])/g;
    const imports = Array.from(css.matchAll(importRegex));

    const processedImports = await Promise.all(imports.map(async (match) => {
      const importUrl = match[1] || match[2];
      const absoluteUrl = new URL(importUrl, baseURL).toString();

      if (urlCache.has(absoluteUrl)) {
        return urlCache.get(absoluteUrl);
      }

      const importedCSS = await fetch(absoluteUrl).then((res) => res.text());
      const processedImportedCSS = await processCSS(
        importedCSS,
        absoluteUrl,
        depth + 1,
      );
      urlCache.set(absoluteUrl, processedImportedCSS);
      return processedImportedCSS;
    }));

    css = css.replace(importRegex, () => processedImports.shift() || "");

    // Handle url() references
    const urlRegex = /url\(['"]?(.+?)['"]?\)/g;
    const matches = css.match(urlRegex);

    if (matches) {
      const urlPromises = matches.map(async (match) => {
        const url = match.match(/url\(['"]?(.+?)['"]?\)/)?.[1];
        if (url && !url.startsWith("data:")) {
          const absoluteUrl = new URL(url, baseURL).toString();

          if (urlCache.has(absoluteUrl)) {
            return { match, newValue: urlCache.get(absoluteUrl)! };
          }

          const req = await fetch(absoluteUrl);
          const contentType = req.headers.get("content-type") || "";

          let newUrlValue: string;
          if (contentType.includes("font/")) {
            const content = await req.arrayBuffer();
            const fontType = contentType.split("/").pop();
            newUrlValue = `url("data:font/${fontType};base64,${
              btoa(String.fromCharCode(...new Uint8Array(content)))
            }")`;
          } else {
            newUrlValue = `url("${absoluteUrl}")`;
          }

          urlCache.set(absoluteUrl, newUrlValue);
          return { match, newValue: newUrlValue };
        }
        return { match, newValue: match };
      });

      const results = await Promise.all(urlPromises);
      results.forEach(({ match, newValue }) => {
        css = css.replace(match, newValue);
      });
    }

    return css;
  } catch (error) {
    console.error("Error processing CSS:", error);
    return css; // Return original CSS if processing fails
  }
}

export default processCSS;

```

# src/hooks/use-editor-state.tsx

```tsx
import { getCodeSpace } from "@/hooks/use-code-space";
import { useRef, useState } from "react";
import type { EditorState } from "../components/editorUtils";
import type { ErrorType } from "../components/ErrorMessages";
import { isMobile } from "../isMobile";
import { useContext } from "./useContext";

export const useEditorState = () => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [editorState, setEditorStateInternal] = useState<EditorState>({
    started: false,
    sub: false,
    code: "",
    setValue: () => {},
  });

  const engine = isMobile() ? "ace" : "monaco";

  // Wrap setState to ensure updates are processed correctly
  const setEditorState = (
    updater: EditorState | ((prev: EditorState) => EditorState),
  ) => {
    setEditorStateInternal((prev) => {
      const next = typeof updater === "function" ? updater(prev) : updater;

      // Ensure setValue is preserved if not explicitly changed
      if (!next.setValue && prev.setValue) {
        next.setValue = prev.setValue;
      }

      // Log state changes in development
      if (process.env.NODE_ENV === "development") {
        console.debug("[EditorState] State updated:", {
          prev,
          next,
          timestamp: new Date().toISOString(),
        });
      }

      return next;
    });
  };

  return {
    containerRef,
    engine,
    editorState,
    setEditorState,
  };
};

export const useErrorHandling = () => {
  const [error, setError] = useState<ErrorType>(null);
  const contextManager = useContext(getCodeSpace(location.pathname));

  const handleError = (errorType: ErrorType, errorMessage: string) => {
    setError(errorType);
    contextManager.updateContext("errorLog", errorMessage);
  };

  const clearError = () => {
    setError(null);
    contextManager.updateContext("errorLog", "");
  };

  return { error, handleError, clearError };
};

```

# src/hooks/useAutoSave.ts

```ts
export const useAutoSave = async (codeSpace: string) => fetch(`/live/${codeSpace}/auto-save`);

```

# src/hooks/useBgColor.ts

```ts
import { useState } from "react";

export const useBgColor = () => {
  const [bgColor, setBgColor] = useState<[number, number, number, number]>([
    0,
    0,
    0,
    0,
  ]);

  const rgba = (r: number, g: number, b: number, a: number) =>
    `rgba(${r || 1}, ${g || 1}, ${b || 1}, ${a || 0.7})`;

  return { bgColor, setBgColor, rgba };
};

```

# src/hooks/useClerkSWR.ts

```ts
import { useAuth } from "@clerk/clerk-react";
import useSWR from "swr";

export const useClerkSWR = (url: string) => {
  const { getToken } = useAuth();

  const fetcher = async (...args: [RequestInfo]) => {
    return fetch(...args, {
      headers: { Authorization: `Bearer ${await getToken()}` },
    }).then((res) => res.json());
  };

  return useSWR(url, fetcher);
};

```

# src/hooks/useCodeHistory.ts

```ts
import { useCallback, useEffect, useState } from "react";
import type { Version } from "../codeHistoryUtils";
import { loadVersionHistory } from "../codeHistoryUtils";

interface HistoryItem {
  code: string;
  timestamp: number;
}

export const useCodeHistory = (codeSpace: string) => {
  const [history, setHistory] = useState<HistoryItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchHistory = useCallback(async () => {
    try {
      setLoading(true);
      const data: Version[] = await loadVersionHistory(codeSpace);
      setHistory(
        data
          .filter((x) => !x.code.includes("History") && !x.code.includes("e/pp"))
          .sort((a, b) => b.timestamp - a.timestamp)
          .map((version) => ({ ...version, timestamp: version.timestamp })),
      );
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "An unknown error occurred",
      );
    } finally {
      setLoading(false);
    }
  }, [codeSpace]);

  useEffect(() => {
    fetchHistory();
  }, [fetchHistory]);

  return { history, loading, error, refetch: fetchHistory };
};

```

# src/hooks/useContext.ts

```ts
import type { ProjectContext } from "@/lib/context-manager";
import { ContextManager } from "@/lib/context-manager";

interface ContextHook {
  getContext: (key: string) => string;
  updateContext: (key: string, content: string) => void;
  getFullContext: () => ProjectContext;
  clearContext: () => void;
}

export function useContext(codeSpace: string): ContextHook {
  const contextManager = new ContextManager(codeSpace);

  return {
    getContext: contextManager.getContext.bind(contextManager),
    updateContext: contextManager.updateContext.bind(contextManager),
    getFullContext: contextManager.getFullContext.bind(contextManager),
    clearContext: contextManager.clearContext.bind(contextManager),
  };
}

```

# src/hooks/useDownload.ts

```ts
import { getSpeedy2 } from "@/lib/use-archive";

const download = async (
  codeSpace: string,
  onlyReturn: boolean,
): Promise<string | void> => {
  console.log(
    `useDownload hook called with codeSpace: ${codeSpace}, onlyReturn: ${onlyReturn}`,
  );
  console.log("Starting download process");

  try {
    await getSpeedy2();
    console.log("getSpeedy2 completed");

    const url = `/live-cms/${codeSpace}.html`;
    console.log(`Fetching content from: ${url}`);
    const response = await fetch(url);

    if (!response || !response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const content = await response.text();
    console.log(`Content fetched, length: ${content.length} characters`);

    if (onlyReturn) {
      console.log("Returning content without downloading");
      return content;
    }

    console.log("Creating Blob and initiating download");
    const blob = new Blob([content], { type: "text/html" });
    const blobUrl = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = blobUrl;
    a.download = `${codeSpace}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(blobUrl);

    console.log("Download process completed");
    return;
  } catch (error) {
    console.error("Error in useDownload:", error);
    throw error;
  }
};

export const useDownload = (codeSpace: string, onlyReturn = false) => {
  return () => download(codeSpace, onlyReturn);
};

```

# src/hooks/useErrorEffect.ts

```ts
import type { ContextManager } from "@/lib/context-manager";
import { useEffect } from "react";
import type { ErrorType } from "../components/ErrorMessages";

export const useErrorEffect = (
  errorType: ErrorType | null,
  codeSpace: string,
  contextManager: ContextManager,
  setShowError: (show: boolean) => void,
) => {
  useEffect(() => {
    let timer: NodeJS.Timeout;

    if (errorType) {
      timer = setTimeout(() => {
        setShowError(true);
        const currentErrorLog = contextManager.getContext("errorLog") || "";
        const newErrorLog = `${currentErrorLog}\n${
          new Date().toISOString()
        }: ${errorType} error occurred`;
        contextManager.updateContext("errorLog", newErrorLog.trim());
      }, 500);
    } else {
      // Add a small delay before hiding the error to prevent flickering
      timer = setTimeout(() => setShowError(false), 100);
    }

    return () => clearTimeout(timer);
  }, [errorType, codeSpace, contextManager, setShowError]);
};

```

# src/hooks/useErrorHandling.ts

```ts
import { useCallback, useState } from "react";

export const useErrorHandling = (engine: string) => {
  const [errorType, setErrorType] = useState<
    "typescript" | "prettier" | "transpile" | "render" | null
  >(null);

  const throttledTypeCheck = useCallback(
    async () => {
      if (engine === "monaco") {
        const { editor, languages } = await import(
          "@/workers/monaco-editor.worker"
        );
        const model = editor.getModels()[0];
        const worker = await languages.typescript
          .getTypeScriptWorker();
        const client = await worker(model.uri);
        const diagnostics = await client.getSemanticDiagnostics(
          model.uri.toString(),
        );

        if (diagnostics.length > 0) {
          Object.assign(globalThis, { diagnostics });
          console.error("TypeScript error:", diagnostics);
          setErrorType("typescript");
        } else {
          setErrorType((prevErrorType) => prevErrorType === "typescript" ? null : prevErrorType);
        }
      }
    },
    [engine],
  );

  return { errorType, setErrorType, throttledTypeCheck };
};

Object.assign(globalThis, { useErrorHandling });

```

# src/hooks/useMediaQuery.ts

```ts
import { useEffect, useState } from "react";

export const useMediaQuery = (query: string): boolean => {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    const listener = () => setMatches(media.matches);
    media.addListener(listener);
    return () => media.removeListener(listener);
  }, [matches, query]);

  return matches;
};

```

# src/hooks/useRestoreVersion.ts

```ts
import { useCallback, useState } from "react";

interface RestoreStatus {
  type: "loading" | "success" | "error";
  message: string;
}

export const useRestoreVersion = (codeSpace: string) => {
  const [restoreStatus, setRestoreStatus] = useState<RestoreStatus | null>(
    null,
  );

  const restoreVersion = useCallback(async (timestamp: number) => {
    try {
      setRestoreStatus({ type: "loading", message: "Restoring..." });
      const response = await fetch(
        `/live/${codeSpace}/auto-save/restore/${timestamp}`,
      );
      if (!response || !response.ok) {
        throw new Error("Failed to restore version");
      }
      setRestoreStatus({
        type: "success",
        message: "Version restored successfully!",
      });
    } catch (err) {
      setRestoreStatus({
        type: "error",
        message: err instanceof Error
          ? err.message
          : "An unknown error occurred",
      });
    }
  }, [codeSpace]);

  return { restoreStatus, restoreVersion };
};

```

# src/hooks/useScreenshot.ts

```ts
import { useState } from "react";

export const useScreenshot = (codeSpace: string) => {
  const [isScreenshotLoading, setIsScreenshotLoading] = useState(false);
  const [screenshotImage, setScreenshotImage] = useState<string | null>(null);

  const screenshotToBase64Maker = async (
    codeSpace: string,
  ): Promise<string> => {
    const response = await fetch(`/live/${codeSpace}/screenshot`);
    const blob = await response.blob();
    return new Promise((resolve) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result as string);
      reader.readAsDataURL(blob);
    });
  };

  const handleScreenshotClick = async () => {
    setIsScreenshotLoading(true);
    try {
      const base64Image = await screenshotToBase64Maker(codeSpace);
      setScreenshotImage(base64Image);
    } catch (error) {
      console.error("Error capturing screenshot:", error);
    } finally {
      setIsScreenshotLoading(false);
    }
  };

  const handleCancelScreenshot = () => {
    setScreenshotImage(null);
  };

  return {
    isScreenshotLoading,
    screenshotImage,
    handleScreenshotClick,
    handleCancelScreenshot,
  };
};

```

# src/hooks/useWindowSize.ts

```ts
import { useEffect, useState } from "react";

export const useWindowSize = () => {
  const [windowSize, setWindowSize] = useState({
    innerWidth: window.innerWidth,
    innerHeight: window.innerHeight,
  });

  useEffect(() => {
    const handleResize = () => {
      setWindowSize({
        innerWidth: window.innerWidth,
        innerHeight: window.innerHeight,
      });
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return windowSize;
};

```

# src/index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <base href="/" />
    <meta charset="utf-8" />
    <meta
      name="theme-color"
      content="#ffffff"
      media="(prefers-color-scheme: light)"
    />
    <meta
      name="theme-color"
      content="#000000"
      media="(prefers-color-scheme: dark)"
    />
    <meta
      name="description"
      content="spike.land, an online content Editor with AI support"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <link
      rel="preload"
      href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap"
      as="style"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Flex:opsz,wght@8..144,100..1000&display=swap"
      rel="stylesheet"
    />

    <!-- Inline LINK for initial theme -->

    <!-- Content Security Policy (unchanged) -->
    <meta
      http-equiv="Content-Security-Policy"
      content="
    default-src 'self' ;
    media-src 'self' blob:;
    script-src 'self'  https://cdn.jsdelivr.net https://esm.sh https://static.cloudflareinsights.com data: https://clerk.spike.land blob: 'unsafe-eval' 'unsafe-inline';
    worker-src 'self'  https://storage.googleapis.com https://esm.sh blob:;
    style-src 'self'  https://esm.sh 'unsafe-inline' https://fonts.googleapis.com;
    connect-src 'self'  https://cdn.jsdelivr.net blob: https://esm.sh https://clerk.spike.land wss://*.peerjs.com;
    font-src 'self'  data: blob: https://esm.sh https://fonts.gstatic.com;
    img-src 'self'  https://esm.sh data: blob: https://img.clerk.com https://*.clerk.dev;
    "
    />

    <link
      rel="manifest"
      href="/assets/manifest.webmanifest"
      type="application/manifest+json"
    />

    <link rel="preload" href="/assets/app.css" as="style" />
    <link rel="stylesheet" href="/assets/app.css" />

    <!-- <link rel="preload" href="/start.css" as="style" />
    <link rel="stylesheet" href="/start.css" /> -->

    <!-- Inline style for initial theme -->

    <script type="importmap"></script>

    <script>
      (function () {
        function getInitialDarkMode() {
          const storedDarkMode = localStorage.getItem("darkMode");
          if (storedDarkMode !== null) {
            return storedDarkMode === "true";
          } else {
            return window.matchMedia("(prefers-color-scheme: dark)")
              .matches;
          }
        }

        function setInitialTheme() {
          const isDarkMode = getInitialDarkMode();
          document.documentElement.classList.toggle("dark", isDarkMode);
        }

        setInitialTheme();
      })();
    </script>

    <link
      rel="shortcut icon"
      type="image/png"
      href="/assets/favicons/chunk-chunk-fe2f7da4f9ccc2.png"
    />
    <title>Instant React Editor</title>
  </head>
  <body>
    <div id="embed"></div>

    <script type="module" src="/start.mjs"></script>
  </body>
</html>

```

# src/isMobile.ts

```ts
export function isMobile() {
  return false;

  //   if (localStorage.getItem("isMobile") === "true") {
  //     return true;
  //   }
  //   if (localStorage.getItem("isMobile") === "false") {
  //     return false;
  //   }
  //   return /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
  //     navigator.userAgent,
  //   );
  // }
}

```

# src/jsx.ts

```ts
import { Fragment, jsx, jsxs } from "react/jsx-runtime";

export { Fragment, jsx, jsxs };
const JSX = { jsx, jsxs, Fragment };

export default JSX;

```

# src/lib/caching.ts

```ts
import { LRUCache } from "lru-cache";
import { CodeAnalysis } from '../utils/code-analysis';
import { 
  hashCacheMetrics, 
  toolResponseCacheMetrics, 
  codeAnalysisCacheMetrics, 
  metrics 
} from './metrics';

type CacheValue = string | CodeAnalysis | {
  documentHash?: string;
  modifiedCodeHash?: string;
  compilationError: boolean;
  codeWasReturned: boolean;
};

/**
 * Generic cache store with LRU eviction policy
 */
interface CacheMetricsInterface {
  recordHit: () => void;
  recordMiss: () => void;
}

interface CacheStoreOptions {
  maxSize?: number;
  ttl?: number;
  name?: string;
  metrics?: CacheMetricsInterface;
}

export class CacheStore<T extends CacheValue> {
  private cache: LRUCache<string, T>;
  private metrics: CacheMetricsInterface;
  private name: string;

  constructor(options: CacheStoreOptions = {}) {
    this.cache = new LRUCache({
      max: options.maxSize || 500,
      ttl: options.ttl || 1000 * 60 * 30, // 30 minutes default TTL
    });

    this.name = options.name || 'default';
    this.metrics = options.metrics || {
      recordHit: () => {},
      recordMiss: () => {}
    };
  }

  get(key: string): T | undefined {
    const start = performance.now();
    const value = this.cache.get(key);
    const duration = performance.now() - start;

    if (value !== undefined) {
      this.metrics.recordHit();
      metrics.recordOperation('cache.get.hit', duration);
    } else {
      this.metrics.recordMiss();
      metrics.recordOperation('cache.get.miss', duration);
    }

    return value;
  }

  set(key: string, value: T): void {
    const start = performance.now();
    this.cache.set(key, value);
    metrics.recordOperation('cache.set', performance.now() - start);
  }

  has(key: string): boolean {
    const exists = this.cache.has(key);
    if (exists) {
      this.metrics.recordHit();
    } else {
      this.metrics.recordMiss();
    }
    return exists;
  }

  delete(key: string): void {
    this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }
}

// Create singleton instances for different types of caches with metrics
export const hashCache = new CacheStore<string>({
  name: 'hash',
  metrics: hashCacheMetrics
});

export const codeAnalysisCache = new CacheStore<CodeAnalysis>({
  name: 'codeAnalysis',
  metrics: codeAnalysisCacheMetrics
});

interface ToolResponse {
  documentHash?: string;
  modifiedCodeHash?: string;
  compilationError: boolean;
  codeWasReturned: boolean;
}

export const toolResponseCache = new CacheStore<ToolResponse>({
  name: 'toolResponse',
  metrics: toolResponseCacheMetrics
});

// Export cache operation tracking
export function logCacheStats(): void {
  console.log('\n=== Cache Performance Stats ===\n');
  console.log('Hash Cache:', hashCacheMetrics.getStats());
  console.log('Code Analysis Cache:', codeAnalysisCacheMetrics.getStats());
  console.log('Tool Response Cache:', toolResponseCacheMetrics.getStats());
  console.log('\nTotal Operations:', metrics.getMetrics('cache.set')?.count || 0);
  console.log('Average Set Duration:', metrics.getMetrics('cache.set')?.avgTime.toFixed(2), 'ms');
  console.log('Cache Hit Rate:', (
    (metrics.getMetrics('cache.get.hit')?.count || 0) /
    ((metrics.getMetrics('cache.get.hit')?.count || 0) + 
     (metrics.getMetrics('cache.get.miss')?.count || 0)) * 100
  ).toFixed(1), '%');
}

```

# src/lib/metrics.ts

```ts
/**
 * Workflow metrics collector
 */
interface OperationMetrics {
  count: number;
  totalTime: number;
  avgTime: number;
  min: number;
  max: number;
  errors: number;
}

export class WorkflowMetrics {
  private static instance: WorkflowMetrics;
  private data: Record<string, OperationMetrics> = {};

  private constructor() {}

  public static getInstance(): WorkflowMetrics {
    if (!WorkflowMetrics.instance) {
      WorkflowMetrics.instance = new WorkflowMetrics();
    }
    return WorkflowMetrics.instance;
  }

  /**
   * Record a workflow operation
   */
  public recordOperation(
    name: string, 
    durationMs: number, 
    isError: boolean = false
  ): void {
    if (!this.data[name]) {
      this.data[name] = {
        count: 0,
        totalTime: 0,
        avgTime: 0,
        min: durationMs,
        max: durationMs,
        errors: 0,
      };
    }

    const stats = this.data[name];
    stats.count++;
    stats.totalTime += durationMs;
    stats.avgTime = stats.totalTime / stats.count;
    stats.min = Math.min(stats.min, durationMs);
    stats.max = Math.max(stats.max, durationMs);

    if (isError) {
      stats.errors++;
    }
  }

  /**
   * Get metrics for a specific operation
   */
  public getMetrics(name: string): OperationMetrics | null {
    return this.data[name] || null;
  }

  /**
   * Get metrics summary
   */
  public getSummary() {
    const summary: Record<string, {
      operationCount: number;
      avgDurationMs: number;
      successRate: string;
      p95LatencyMs?: number;
    }> = {};

    for (const [name, stats] of Object.entries(this.data)) {
      summary[name] = {
        operationCount: stats.count,
        avgDurationMs: Math.round(stats.avgTime),
        successRate: `${((stats.count - stats.errors) / stats.count * 100).toFixed(1)}%`
      };
    }

    return summary;
  }

  /**
   * Get performance report
   */
  public getPerformanceReport(): string {
    let report = '=== Workflow Performance Report ===\n\n';

    for (const [name, metrics] of Object.entries(this.getSummary())) {
      report += `${name}:\n`;
      report += `  Operations: ${metrics.operationCount}\n`;
      report += `  Avg Duration: ${metrics.avgDurationMs}ms\n`;
      report += `  Success Rate: ${metrics.successRate}\n\n`;
    }

    return report;
  }

  /**
   * Reset all metrics
   */
  public reset(): void {
    this.data = {};
  }
}

// Export singleton instance
export const metrics = WorkflowMetrics.getInstance();

/**
 * Performance measurement method decorator factory
 */
export function measure(operationName: string) {
  return function measureDecorator(_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    // Preserve the original method type
    descriptor.value = function wrapped(this: any, ...args: any[]) {
      const start = performance.now();
      const result = originalMethod.apply(this, args);

      // Handle both async and sync methods
      if (result instanceof Promise) {
        return result.then(value => {
          const duration = performance.now() - start;
          metrics.recordOperation(operationName, duration);
          return value;
        }).catch(error => {
          const duration = performance.now() - start;
          metrics.recordOperation(operationName, duration, true);
          throw error;
        });
      }

      const duration = performance.now() - start;
      metrics.recordOperation(operationName, duration);
      return result;
    };

    // Preserve method properties
    Object.defineProperty(descriptor.value, 'name', {
      value: `${operationName}::${originalMethod.name}`,
      configurable: true
    });

    return descriptor;
  };
}

/**
 * Cache hit rate metrics
 */
export class CacheMetrics {
  private hits = 0;
  private misses = 0;

  public recordHit(): void {
    this.hits++;
  }

  public recordMiss(): void {
    this.misses++;
  }

  public getHitRate(): number {
    const total = this.hits + this.misses;
    return total > 0 ? this.hits / total : 0;
  }

  public getStats() {
    const total = this.hits + this.misses;
    const hitRate = this.getHitRate();
    return {
      hits: this.hits,
      misses: this.misses,
      total,
      hitRate: `${(hitRate * 100).toFixed(1)}%`
    };
  }

  public reset(): void {
    this.hits = 0;
    this.misses = 0;
  }
}

// Export cache metrics instances
export const hashCacheMetrics = new CacheMetrics();
export const toolResponseCacheMetrics = new CacheMetrics();
export const codeAnalysisCacheMetrics = new CacheMetrics();

```

# src/lib/shared.ts

```ts
// Shared utilities and constants

export const SHARED_CONSTANT = "shared-value";

// Add shared utilities here
export function sharedUtility() {
  return "shared-functionality";
}

```

# src/lib/telemetry.ts

```ts
/**
 * Types for telemetry events
 */
export interface TelemetryEvent {
  name: string;
  properties?: Record<string, string | number | boolean>;
  measurements?: Record<string, number>;
  timestamp: Date;
}

export interface TelemetryOptions {
  enabled?: boolean;
  debug?: boolean;
  flushInterval?: number;
}

/**
 * Telemetry system for tracking workflow performance and debugging
 */
export class Telemetry {
  private static instance: Telemetry;
  private events: TelemetryEvent[] = [];
  private timers: Map<string, number> = new Map();
  private options: TelemetryOptions;

  private constructor(options: TelemetryOptions = {}) {
    this.options = {
      enabled: true,
      debug: false,
      flushInterval: 60000, // 1 minute
      ...options
    };

    if (this.options.flushInterval) {
      setInterval(() => this.flush(), this.options.flushInterval);
    }
  }

  public static getInstance(options?: TelemetryOptions): Telemetry {
    if (!Telemetry.instance) {
      Telemetry.instance = new Telemetry(options);
    }
    return Telemetry.instance;
  }

  public trackEvent(
    name: string, 
    properties?: Record<string, string | number | boolean>,
    measurements?: Record<string, number>
  ): void {
    if (!this.options.enabled) return;

    const event: TelemetryEvent = {
      name,
      properties,
      measurements,
      timestamp: new Date()
    };

    this.events.push(event);
    
    if (this.options.debug) {
      console.debug('[Telemetry]', event);
    }
  }

  public startTimer(name: string): void {
    this.timers.set(name, performance.now());
  }

  public stopTimer(
    name: string,
    properties?: Record<string, string | number | boolean>
  ): number | undefined {
    const start = this.timers.get(name);
    if (start) {
      const duration = performance.now() - start;
      this.timers.delete(name);
      
      this.trackEvent(
        `${name}.duration`,
        { ...properties, durationMs: duration.toFixed(2) },
        { duration }
      );

      return duration;
    }
    return undefined;
  }

  public flush(): TelemetryEvent[] {
    if (this.events.length === 0) return [];

    // In a real implementation, you would send these events to your telemetry service
    // For now, we'll just log them in debug mode and return them
    if (this.options.debug) {
      console.debug('[Telemetry] Flushing events:', this.events);
    }
    
    const events = [...this.events];
    this.events = [];
    return events;
  }

  /**
   * Track error events with context
   */
  public trackError(
    error: Error,
    properties?: Record<string, string | number | boolean>
  ): void {
    const errorProperties: Record<string, string | number | boolean> = {
      ...properties,
      errorName: error.name,
      errorMessage: error.message,
      stackTrace: error.stack || 'No stack trace available'
    };

    this.trackEvent('error', errorProperties);
  }

  /**
   * Track workflow progress
   */
  public trackProgress(
    stage: string,
    percent: number,
    details?: Record<string, string | number | boolean>
  ): void {
    this.trackEvent('workflow.progress', {
      ...details,
      stage,
      percent: percent.toFixed(2)
    });
  }

  /**
   * Track code modifications
   */
  public trackCodeModification(
    type: 'create' | 'update' | 'delete',
    details: {
      filePath: string;
      linesChanged?: number;
      bytesChanged?: number;
    }
  ): void {
    this.trackEvent('code.modification', {
      type,
      ...details
    });
  }

  /**
   * Track model interactions
   */
  public trackModelInteraction(
    details: {
      model: string;
      promptTokens: number;
      completionTokens: number;
      duration: number;
      success: boolean;
      error?: string;
    }
  ): void {
    this.trackEvent('model.interaction', {
      ...details,
      totalTokens: details.promptTokens + details.completionTokens
    });
  }

  /**
   * Track cache operations
   */
  public trackCacheOperation(
    operation: 'hit' | 'miss' | 'set',
    cacheType: string,
    details?: Record<string, string | number | boolean>
  ): void {
    this.trackEvent('cache.operation', {
      operation,
      cacheType,
      ...details
    });
  }
}

// Export singleton instance
export const telemetry = Telemetry.getInstance();

```

# src/memfs.ts

```ts
import memfs from "@/lib/memfs";
export * from "@/lib/memfs";
export default memfs;
```

# src/modules.ts

```ts
import { importMap, importMapReplace } from "@/lib/importmap-utils.ts";
export type {
  ImageData,
  IRenderApp,
  LanguageMap,
  Message,
  MessageContent,
  MessagePart,
  RenderedApp,
} from "@/lib/interfaces.ts";
import HTML from "./index.html";

export { HTML };
export { serveWithCache } from "@/lib/serve-with-cache.ts";

export { md5 } from "@/lib/md5.ts";
export { routes } from "@/lib/routes.ts";

export { importMapReplace };

export { serverFetchUrl } from "@/lib/enhanced-fetch";

import type { ICodeSession } from "@/lib/interfaces";
import type { CodePatch } from "@/lib/make-sess.ts";
export { fakeServer } from "./sw-local-fake-server";

import {
  applySessionPatch,
  computeSessionHash,
  generateSessionPatch,
  sanitizeSession,
  sessionToJSON,
} from "@/lib/common-functions";

export { importMap };

export { computeSessionHash, generateSessionPatch, sessionToJSON };
export type { CodePatch, ICodeSession };
export { applySessionPatch, sanitizeSession };

```

# src/monaco-edi.tsx

```tsx
import { ata, prettierToThrow } from "@/lib/shared";
import { throttle } from "@/lib/throttle";
import { editor, languages, Uri } from "@/workers/monaco-editor.worker";
import type { editor as Editor } from "monaco-editor";
import { version } from "monaco-editor/package.json";

// Types and interfaces for better type safety
interface ExtraLib {
  filePath: string;
  content: string;
}

interface EditorConfig {
  code: string;
  container: HTMLDivElement;
  codeSpace: string;
  onChange: (code: string) => void;
}

interface EditorModel {
  getValue: () => string;
  silent: boolean;
  getErrors: () => Promise<string[]>;
  isEdit: boolean;
  setValue: (newCode: string) => void;
}

// Validate origin and provide fallback
const originToUse = (() => {
  try {
    const origin = location.origin;
    if (!origin || typeof origin !== "string") {
      throw new Error("Invalid origin");
    }
    return origin;
  } catch (error) {
    console.error("Error getting origin:", error);
    return "http://localhost:3000"; // Fallback for development
  }
})();

// Memoized model cache
const modelCache: Record<string, Editor.ITextModel> = {};

const refreshAta = async (code: string): Promise<void> => {
  try {
    const extraLibs: ExtraLib[] = (await ata({ code, originToUse })).map(
      ({ filePath, content }) => ({
        filePath: originToUse + filePath,
        content,
      }),
    );

    console.log("Setting extra libraries:", { extraLibs });
    languages.typescript.typescriptDefaults.setExtraLibs(extraLibs);

    const mjsFiles = extraLibs.filter((lib) => lib.filePath.endsWith(".mjs"));
    for (const lib of mjsFiles) {
      const myUri = Uri.parse(lib.filePath);
      const existingModel = editor.getModel(myUri);

      if (existingModel) {
        existingModel.setValue(lib.content);
      } else {
        editor.createModel(lib.content, "typescript", myUri);
      }
    }

    languages.typescript.typescriptDefaults.setDiagnosticsOptions({
      noSuggestionDiagnostics: false,
      noSemanticValidation: false,
      noSyntaxValidation: false,
      diagnosticCodesToIgnore: [2691],
    });
    languages.typescript.typescriptDefaults.setEagerModelSync(true);
  } catch (error) {
    console.error("Error refreshing ATA:", error);
    throw new Error(
      `Failed to refresh ATA: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
};

const lib = ["dom", "dom.iterable", "es2015", "es2016", "esnext"];

async function fetchAndCreateExtraModels(
  code: string,
  originToUse: string,
): Promise<void> {
  const patterns = [
    new RegExp(` from "(${originToUse})/live/[a-zA-Z0-9\\-_]+`, "gm"),
    new RegExp(` from "\\./(?!@/)[a-zA-Z0-9\\-_]+`, "gm"),
    new RegExp(` from "/live/[a-zA-Z0-9\\-_]+`, "gm"),
  ];

  const matches = patterns.flatMap((pattern) => [...code.matchAll(pattern)]);

  try {
    await Promise.all(matches.map(async (match) => {
      const codeSpace = match[0].split("/").pop();
      const extraModel = new URL(`/live/${codeSpace}/index.tsx`, originToUse)
        .toString();
      const mUri = Uri.parse(`${originToUse}/live/${codeSpace}.tsx`);

      if (!modelCache[mUri.toString()]) {
        const res = await fetch(extraModel);
        if (!res.ok) {
          throw new Error(`Failed to fetch model: ${res.statusText}`);
        }
        const content = await res.text();
        modelCache[mUri.toString()] = editor.createModel(
          content,
          "typescript",
          mUri,
        );
      }
    }));
  } catch (error) {
    console.error("Error fetching extra models:", error);
    throw error;
  }
}

// Editor configuration object
const editorOptions: Editor.IStandaloneEditorConstructionOptions = {
  scrollbar: {
    vertical: "auto",
    horizontal: "auto",
    scrollByPage: false,
    alwaysConsumeMouseWheel: true,
  },
  scrollBeyondLastLine: true,
  scrollPredominantAxis: true,
  automaticLayout: true,
  wordWrap: "off",
  wordWrapColumn: 80,
  links: true,
  tabSize: 2,
  insertSpaces: true,
  minimap: {
    enabled: true,
    autohide: false,
    side: "right",
    showSlider: "mouseover",
  },
  bracketPairColorization: {
    enabled: true,
    independentColorPoolPerBracketType: true,
  },
  definitionLinkOpensInPeek: true,
  theme: "vs-dark",
  autoClosingBrackets: "languageDefined",
  autoIndent: "advanced",
  formatOnType: true,
  formatOnPaste: true,
  renderWhitespace: "boundary",
  cursorBlinking: "blink",
  smoothScrolling: true,
  suggestOnTriggerCharacters: true,
  acceptSuggestionOnEnter: "on",
  fontFamily: "monospace",
  fontSize: 14,
  lineNumbers: "on",
  folding: true,
  codeLens: true,
};

const monacoContribution = async (code: string): Promise<string> => {
  languages.typescript.typescriptDefaults.setCompilerOptions({
    baseUrl: originToUse + "/",
    target: languages.typescript.ScriptTarget.Latest,
    allowNonTsExtensions: true,
    moduleResolution: languages.typescript.ModuleResolutionKind.NodeJs,
    module: languages.typescript.ModuleKind.ESNext,
    importHelpers: true,
    lib,
    esModuleInterop: false,
    strictNullChecks: false,
    strict: false,
    strictFunctionTypes: false,
    strictPropertyInitialization: false,
    strictBindCallApply: false,
    noImplicitAny: false,
    noImplicitThis: false,
    noImplicitReturns: false,
    checkJs: false,
    allowJs: false,
    experimentalDecorators: false,
    emitDecoratorMetadata: false,
    skipLibCheck: false,
    downlevelIteration: true,
    allowSyntheticDefaultImports: true,
    forceConsistentCasingInFileNames: true,
    noFallthroughCasesInSwitch: true,
    resolveJsonModule: true,
    noEmit: true,
    traceResolution: true,
    declaration: true,
    noEmitOnError: true,
    sourceMap: true,
    maxNodeModuleJsDepth: 20,
    rootDir: `${originToUse}/`,
    typeRoots: ["@types"],
    paths: {
      "tslib": ["/tslib"],
      "./*": ["/live/*"],
      "@/": [`${originToUse}/@/`],
      "/*": [`${originToUse}/`],
    },
    jsxImportSource: "@emotion/react",
    jsx: languages.typescript.JsxEmit.ReactJSX,
    allowUmdGlobalAccess: false,
    include: [`${originToUse}/`],
  });

  languages.typescript.typescriptDefaults.setDiagnosticsOptions({
    noSuggestionDiagnostics: true,
    noSemanticValidation: true,
    noSyntaxValidation: true,
    diagnosticCodesToIgnore: [2691],
  });

  fetchAndCreateExtraModels(code, originToUse);
  refreshAta(code);

  return code;
};

const mod: Record<string, EditorModel> = {};

export const startMonaco = async ({
  code,
  container,
  codeSpace,
  onChange,
}: EditorConfig): Promise<EditorModel> => {
  if (!mod[codeSpace]) {
    mod[codeSpace] = await startMonacoPristine({
      code,
      container,
      codeSpace,
      onChange,
    });
  }
  return mod[codeSpace];
};

async function startMonacoPristine({
  code,
  container,
  codeSpace,
  onChange,
}: EditorConfig): Promise<EditorModel> {
  const replacedCode = await monacoContribution(code);
  const uri = Uri.parse(`${originToUse}/live/${codeSpace}.tsx`);
  let model = editor.getModel(uri);

  if (model) {
    model.setValue(replacedCode);
  } else {
    model = editor.createModel(replacedCode, "typescript", uri);
  }

  languages.registerDocumentFormattingEditProvider("typescript", {
    provideDocumentFormattingEdits: async (model) => {
      try {
        const formattedText = await prettierToThrow({
          code: model.getValue(),
          toThrow: false,
        });
        return [
          {
            range: model.getFullModelRange(),
            text: formattedText,
          },
        ];
      } catch (error) {
        console.error("Error formatting document:", error);
        return [];
      }
    },
  });

  const link = document.createElement("link");
  const promiseIsResolved = new Promise<void>((resolve) => {
    link.onload = () => resolve();
  });

  link.rel = "stylesheet";
  link.href = `${originToUse}/monaco-editor@${version}/min/vs/editor/editor.main.css`;
  document.head.appendChild(link);

  await promiseIsResolved;

  const myEditor = editor.create(container, {
    ...editorOptions,
    model: model, // Explicitly set the model when creating the editor
  });

  let abortController = new AbortController();
  const ttt = { checking: 0 };

  const tsCheck = async () => {
    if (ttt.checking) return;
    ttt.checking = 1;

    try {
      console.log("Running TypeScript check");
      const typeScriptWorker = await (await languages.typescript.getTypeScriptWorker())(uri);

      const [syntacticDiagnostics, semanticDiagnostics, suggestionDiagnostics] = await Promise.all([
        typeScriptWorker.getSyntacticDiagnostics(uri.toString()),
        typeScriptWorker.getSemanticDiagnostics(uri.toString()),
        typeScriptWorker.getSuggestionDiagnostics(uri.toString()),
      ]);

      syntacticDiagnostics.forEach((d) => console.error("Syntactic diagnostic:", d));

      const needNewAta = semanticDiagnostics.some((d) =>
        d.messageText.toString().includes("Cannot find module")
      );

      if (needNewAta) {
        await refreshAta(model.getValue());
      }

      console.log("Suggestion diagnostics:", suggestionDiagnostics);
    } catch (error) {
      console.error("Error during TypeScript check:", error);
    } finally {
      ttt.checking = 0;
    }
  };

  const editorModel: EditorModel = {
    getValue: () => model.getValue(),
    silent: false,
    getErrors: async () => {
      try {
        const worker = await languages.typescript.getTypeScriptWorker();
        const typeScriptWorker = await worker(uri);
        const diagnostics = await typeScriptWorker.getSuggestionDiagnostics(
          uri.toString(),
        );
        return diagnostics.map((d) => d.messageText.toString());
      } catch (error) {
        console.error("Error getting diagnostics:", error);
        return ["Error fetching diagnostics"];
      }
    },
    isEdit: false,
    setValue: (newCode: string) => {
      editorModel.silent = true;
      const state = myEditor.saveViewState();

      try {
        model.setValue(newCode);
        if (state) {
          console.log("Restoring editor state");
          myEditor.restoreViewState(state);
        }
      } catch (error) {
        console.error("Error setting editor value:", error);
      } finally {
        model.setValue(newCode);
        editorModel.silent = false;
      }
    },
  };

  myEditor.getDomNode()?.blur();

  myEditor.onDidFocusEditorText(() => {
    editorModel.isEdit = true;
    abortController.abort();
    abortController = new AbortController();
    setTimeout(() => {
      if (abortController.signal.aborted) return;
      editorModel.isEdit = false;
    }, 50);
  });

  myEditor.onDidBlurEditorText(() => {
    editorModel.isEdit = false;
  });

  const throttledTsCheck = throttle(() => tsCheck(), 10000);
  // Increase throttle time and add debounce for editor changes
  const throttledOnChange = throttle(
    () => {
      const value = model.getValue();
      onChange(value);
    },
    300, // Reduce throttle time to 300ms for better responsiveness
    {
      edges: ["leading", "trailing"], // Trigger on both edges for faster initial response
    },
  );

  model.onDidChangeContent(() => {
    if (!editorModel.silent) {
      throttledOnChange();
      throttledTsCheck();
    }
  });

  return editorModel;
}

```

# src/my-ata.ts

```ts
import { QueuedFetch } from "@/lib/queued-fetch";
import { setupTypeAcquisition } from "@typescript/ata";
import ts from "typescript";

const limitedFetch = new QueuedFetch(4, 1000);

export const myATA = async (code: string) => {
  const myPromise = new Promise<Map<string, string>>((resolve) => {
    const ata = setupTypeAcquisition({
      projectName: "My ATA Project,",
      logger: console,
      fetcher: limitedFetch.fetch.bind(limitedFetch) as unknown as typeof fetch,
      typescript: ts,
      delegate: {
        receivedFile: (code: string, path: string) => {
          // Add code to your runtime at the path...
          console.log("ATA received file", { code, path });
        },
        started: () => {
          console.log("ATA start");
        },
        progress: (downloaded: number, total: number) => {
          console.log(`Got ${downloaded} out of ${total}`);
        },
        finished: (vfs) => {
          resolve(vfs);
          console.log("ATA done", vfs);
        },
      },
    });

    ata(code);
  });

  const filed = await myPromise;

  const monacoExtraLibs: Array<{ filePath: string; content: string; }> = [];

  for (const [filePath, content] of filed.entries()) {
    monacoExtraLibs.push({
      filePath: filePath.slice(13).split("@types/").join(""),
      content,
    });
  }
  return monacoExtraLibs;
};

// Run that function with the new sourcefile

```

# src/recharts.ts

```ts
export * from "recharts";

```

# src/routes/__root.tsx

```tsx
export default function App() {
  return (
    <div>
      <h1>App</h1>
    </div>
  );
}

```

# src/routes/router.tsx

```tsx
import { Wrapper } from "@/components/app/wrapper";
import { getCodeSpace } from "@/hooks/use-code-space";
import { ICode, ICodeSession } from "@/lib/interfaces";
import { routes } from "@/lib/routes";
import { init } from "@/lib/tw-dev-setup";
import { ClerkProvider } from "@clerk/clerk-react";
import {
  createRootRoute,
  createRoute,
  createRouter,
  Outlet,
  type RegisteredRouter,
  RouterProvider,
} from "@tanstack/react-router";
import { createContext, useEffect, useState } from "react";
import { AppToRender } from "../AppToRender";
import { Code } from "../services/CodeSession";
import { CodeSessionBC } from "../services/CodeSessionBc";

// Define route types
interface RouteWithPageParams {
  codeSpace: string;
  page: string;
}

interface RouteParams {
  codeSpace: string;
}

type SearchParams = Record<string, string>;

// Root layout component
const RootLayout: React.FC = () => {
  return <Outlet />;
};

// Define root route
export const rootRoute = createRootRoute({
  component: RootLayout,
});

const dynamicRoutes = [];

Object.keys(routes).forEach((path) => {
  // Landing page route
  const landingRoute = createRoute({
    getParentRoute: () => rootRoute,
    path,
    component: () => <Wrapper codeSpace={routes[path as keyof typeof routes]} />,
  });

  dynamicRoutes.push(landingRoute);
});

const App: React.FC = () => {
  const [cSess, setState] = useState<ICode | null>(null);
  const codeSpace = getCodeSpace(location.pathname);

  useEffect(() => {
    if (codeSpace && location.pathname === `/live/${codeSpace}`) {
      (async () => {
        await init();
        const cSess = new Code(codeSpace);
        const baseUrl = import.meta.env.DEV ? "" : "https://testing.spike.land";
        const session = await fetch(`${baseUrl}/live/${codeSpace}/session.json`)
          .then((res) => res.json()) as ICodeSession;
        await cSess.init(session);

        setState(cSess);

        const { initializeApp } = await import("@/lib/hydrate");
        await initializeApp();
      })();
    }
  }, []);

  useEffect(() => {
    let unSub: () => void = () => {};

    if (cSess) {
      (async () => {
        Object.assign(globalThis, { cSess });
        const cSessBr = new CodeSessionBC(codeSpace);
        cSessBr.init(await cSess.getSession());

        unSub = cSessBr.sub((sess) => {
          cSess.setSession(sess);
          setState(cSess);
        });
      })();
    }
    return () => unSub();
  }, [cSess]);

  return cSess
    ? (
      <>
        <ClerkProvider
          publishableKey="pk_live_Y2xlcmsuc3Bpa2UubGFuZCQ"
          afterSignOutUrl="/"
        >
          <AppToRender codeSpace={codeSpace} cSess={cSess} />
        </ClerkProvider>
      </>
    )
    : (
      <>
        <Wrapper codeSpace={codeSpace} />
      </>
    );
};

// Live page route with code space and page parameters
const liveRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/live/$codeSpace/$page",
  parseParams: (params): RouteWithPageParams => ({
    codeSpace: params.codeSpace || "",
    page: params.page || "",
  }),
  stringifyParams: (params: RouteWithPageParams) => ({
    codeSpace: params.codeSpace,
    page: params.page,
  }),
  loader: async ({ params: { codeSpace } }) => ({
    codeSpace: getCodeSpace(`/live/${codeSpace}`),
    page: "",
  }),
  component: () => <App />,
});
dynamicRoutes.push(liveRoute);

// Editor route with just code space parameter
const EditorRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/live/$codeSpace",
  parseParams: (params): RouteParams => ({
    codeSpace: params.codeSpace || "",
  }),
  stringifyParams: (params: RouteParams) => ({
    codeSpace: params.codeSpace,
  }),
  loader: async ({ params: { codeSpace } }) => ({
    codeSpace: getCodeSpace(`/live/${codeSpace}`),
  }),
  component: () => <App />,
});
dynamicRoutes.push(EditorRoute);

const routeTree = rootRoute.addChildren([...dynamicRoutes]);

// Create and configure the router instance
export const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  context: createContext<
    {
      params: RouteParams | RouteWithPageParams;
      search: SearchParams;
    } | null
  >(null),
});

// Export types
export interface RouterState {
  resolvedLocation: {
    pathname: string;
    params: RouteParams | RouteWithPageParams;
  };
}

export type AppRouter = typeof router;

// Re-export RouterProvider
export { RouterProvider };

// Export RouterComponent with proper types
interface RouterComponentProps {
  router: RegisteredRouter;
}

export const RouterComponent: React.FC<RouterComponentProps> = ({ router }) => {
  return <RouterProvider router={router} />;
};

// Export wrapped App Router component
export const AppRouter: React.FC = () => {
  return <RouterComponent router={router} />;
};

```

# src/routeTree.gen.ts

```ts
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as RouterImport } from './routes/router'
import { Route as testsRouterTestImport } from './routes/__tests__/router.test'

// Create/Update Routes

const RouterRoute = RouterImport.update({
  id: '/router',
  path: '/router',
  getParentRoute: () => rootRoute,
} as any)

const testsRouterTestRoute = testsRouterTestImport.update({
  id: '/__tests__/router/test',
  path: '/router/test',
  getParentRoute: () => rootRoute,
} as any)

// Populate the FileRoutesByPath interface

declare module '@tanstack/react-router' {
  interface FileRoutesByPath {
    '/router': {
      id: '/router'
      path: '/router'
      fullPath: '/router'
      preLoaderRoute: typeof RouterImport
      parentRoute: typeof rootRoute
    }
    '/__tests__/router/test': {
      id: '/__tests__/router/test'
      path: '/router/test'
      fullPath: '/router/test'
      preLoaderRoute: typeof testsRouterTestImport
      parentRoute: typeof rootRoute
    }
  }
}

// Create and export the route tree

export interface FileRoutesByFullPath {
  '/router': typeof RouterRoute
  '/router/test': typeof testsRouterTestRoute
}

export interface FileRoutesByTo {
  '/router': typeof RouterRoute
  '/router/test': typeof testsRouterTestRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/router': typeof RouterRoute
  '/__tests__/router/test': typeof testsRouterTestRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths: '/router' | '/router/test'
  fileRoutesByTo: FileRoutesByTo
  to: '/router' | '/router/test'
  id: '__root__' | '/router' | '/__tests__/router/test'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  RouterRoute: typeof RouterRoute
  testsRouterTestRoute: typeof testsRouterTestRoute
}

const rootRouteChildren: RootRouteChildren = {
  RouterRoute: RouterRoute,
  testsRouterTestRoute: testsRouterTestRoute,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

/* ROUTE_MANIFEST_START
{
  "routes": {
    "__root__": {
      "filePath": "__root.tsx",
      "children": [
        "/router",
        "/__tests__/router/test"
      ]
    },
    "/router": {
      "filePath": "router.tsx"
    },
    "/__tests__/router/test": {
      "filePath": "__tests__/router.test.tsx"
    }
  }
}
ROUTE_MANIFEST_END */

```

# src/sab.ts

```ts
export function sab2str(buf: SharedArrayBuffer) {
  const array = new Uint16Array(buf);
  return String.fromCharCode.apply(null, array as unknown as number[]);
}

export function str2sab(str: string) {
  // 2 bytes for each char
  const bytes = str.length * 2;
  const buffer = new SharedArrayBuffer(bytes);
  const arrayBuffer = new Uint16Array(buffer);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    arrayBuffer[i] = str.charCodeAt(i);
  }
  return { array: arrayBuffer, buffer: buffer };
}

// function encodeUf8StringToSharedArrayBuffer(string) {
// 	// Calculate the byte size of the UTF-8 string
// 	let bytes = string.length;
// 	for (let i = string.length -1; i <= 0; i--) {
// 		const code = string.charCodeAt(i);
// 		if (code > 0x7f && code <= 0x7ff) {
// 			bytes++;
// 		else if (code > 0x7ff && code <= 0xffff) {
// 			bytes+=2;
// 		if (code >= 0xdc00 && code <= 0xdfff) {
// 			i--; // trail surrogate
// 		}
// 	}
// 	const buffer = new SharedArrayBuffer(bytes);
// 	const arrayBuffer = new Uint8Array(buffer);
// 	const encoded = unescape(encodeURIComponent(string));
// 	for (var i = 0; i < encoded.length; i++) {
// 		arrayBuffer[i] = encoded[i].charCodeAt(0);
// 	}
// 	return { array: arrayBuffer, buffer: buffer };
// }

// function decodeUtf8StringFromSharedArrayBuffer(array) {
// 	var encodedString = String.fromCharCode.apply(null, array);
// 	var decodedString = decodeURIComponent(escape(encodedString));
// 	return decodedString;
// }

export function ab2str(buf: ArrayBuffer) {
  // @ts-expect-error: Argument of type 'Uint16Array' is not assignable to parameter of type 'number[]'.
  return String.fromCharCode.apply(null, new Uint16Array(buf));
}

export function str2ab(str: string) {
  const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
  const bufView = new Uint16Array(buf);
  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }
  return buf;
}

```

# src/serve-with-cache.ts

```ts
/**
 * Serves assets with caching using the Cache API
 * @param url The URL of the asset to serve
 * @returns A Promise that resolves to a Response
 */
export async function serveWithCache(url: string): Promise<Response> {
  const cache = await caches.open("asset-cache");

  try {
    // Try to get from cache first
    const cachedResponse = await cache.match(url);
    if (cachedResponse) {
      return cachedResponse;
    }

    // If not in cache, fetch and cache
    try {
      const fetchedResponse = await fetch(url);
      const responseToCache = fetchedResponse.clone();

      try {
        await cache.put(url, responseToCache);
      } catch (error) {
        console.error("Cache put error:", error);
        throw error;
      }

      return fetchedResponse;
    } catch (error) {
      console.error("Asset fetch error:", error);
      throw error;
    }
  } catch (error) {
    console.error("Cache match error:", error);
    throw error;
  }
}

```

# src/services/code/CodeProcessor.ts

```ts
import { ICodeSession } from "@/lib/interfaces";
import { formatCode, transpileCode } from "../../components/editorUtils";
import { RenderService } from "../render/RenderService";
import { IWebSocketManager, RunMessageResult } from "../websocket/types";

export class CodeProcessor {
  private static renderService: RenderService;

  constructor(codeSpace: string) {
    if (!CodeProcessor.renderService) {
      CodeProcessor.renderService = new RenderService(codeSpace);
    }
  }

  /**
   * Formats and transpiles the code (optionally runs it),
   * then returns updated session info or false on failure.
   */
  async process(
    rawCode: string,
    skipRunning: boolean,
    signal: AbortSignal,
    getSession: () => ICodeSession,
  ): Promise<ICodeSession | false> {
    if (signal.aborted) return false;
    try {
      const code = await this.formatCode(rawCode);
      if (signal.aborted) return false;

      if (code === getSession().code) {
        return getSession();
      }

      const transpiled = await this.transpileCode(code);
      if (signal.aborted) return false;
      if (getSession().transpiled === transpiled) {
        return getSession();
      }

      const processedSession = {
        html: getSession().html,
        css: getSession().css,
      };

      if (!skipRunning) {
        const runResult = await (window.frames[0] as unknown as {
          webSocketManager: IWebSocketManager;
        }).webSocketManager.handleRunMessage(transpiled);
        if (!runResult) {
          return false;
        }
        if (runResult.html && runResult.html !== processedSession.html) {
          processedSession.html = runResult.html;
        }
        if (runResult.css && runResult.css !== processedSession.css) {
          processedSession.css = runResult.css;
        }
      }

      if (signal.aborted) {
        return false;
      }

      return {
        ...getSession(),
        ...processedSession,
        code,
        transpiled,
      };
    } catch (error) {
      console.error("Error processing code:", error);
      return false;
    }
  }

  private async formatCode(code: string): Promise<string> {
    try {
      return await formatCode(code);
    } catch (error) {
      console.error("Error formatting code:", { code });
      throw new Error(`Error formatting code: ${error}`);
    }
  }

  private async transpileCode(code: string): Promise<string> {
    try {
      const transpiled = await transpileCode(code);
      if (!transpiled) {
        console.log("Error Transpiled code:", { code });
        throw new Error("Transpilation resulted in empty output");
      }
      return transpiled;
    } catch (error) {
      console.log("Error Transpiled code:", { code });
      throw new Error(`Error transpiling code: ${error}`);
    }
  }

  async runCode(transpiled: string): Promise<RunMessageResult> {
    try {
      // Update the rendered app first
      const renderedApp = await CodeProcessor.renderService.updateRenderedApp({
        transpiled,
      });
      const result = await CodeProcessor.renderService.handleRender(
        renderedApp,
      );

      if (!result) {
        throw new Error("Running code produced no output");
      }

      return {
        html: result.html || "<div></div>",
        css: result.css || "",
      };
    } catch (error) {
      console.error("Error running code:", { transpiled });
      throw new Error(`Error running code: ${error}`);
    }
  }
}

```

# src/services/code/ModelManager.ts

```ts
import { Code } from "../CodeSession";
import type { IExtraModelsResult, IModelManager } from "../interfaces/IModelManager";

export class ModelManager implements IModelManager {
  private models = new Map<string, Code>();
  private currentCodeSpace: string;

  constructor(codeSpace: string, initialModel: Code) {
    this.currentCodeSpace = codeSpace;
    this.models.set(codeSpace, initialModel);
  }

  getModel(codeSpace: string): Code | undefined {
    return this.models.get(codeSpace);
  }

  setModel(codeSpace: string, model: Code): void {
    this.models.set(codeSpace, model);
  }

  async updateModelsByCode(newCodes: string): Promise<string> {
    const sections = newCodes.split(/^#\s+/gm).filter(Boolean);
    const errors: string[] = [];

    for (const section of sections) {
      const lines = section.trim().split("\n");
      const codeSpaceLine = lines.shift();
      if (!codeSpaceLine) continue;

      const codeSpaceMatch = codeSpaceLine.match(/^([\w-.]+)\.tsx$/);
      if (!codeSpaceMatch) continue;
      const codeSpace = codeSpaceMatch[1];

      const codeContentMatch = lines.join("\n").match(
        /\`\`\`tsx\s*([\s\S]*?)\s*\`\`\`/m,
      );
      if (!codeContentMatch) continue;
      const codeContent = codeContentMatch[1];

      let codeInstance = this.models.get(codeSpace);
      if (!codeInstance) {
        codeInstance = new Code(codeSpace);
        await codeInstance.init();
        this.models.set(codeSpace, codeInstance);
      }

      const session = await codeInstance.getSession();
      if (session.code !== codeContent) {
        const updatedCode = await codeInstance.setCode(
          codeContent + "\n\n\n",
          codeSpace !== this.currentCodeSpace,
        );

        if (!updatedCode) {
          errors.push(`Failed to update code for ${codeSpace}`);
        }
      }
    }

    // Re-transpile current model's code to ensure everything is fresh
    const currentModel = this.models.get(this.currentCodeSpace);
    if (currentModel) {
      const currentSession = await currentModel.getSession();
      await currentModel.setCode(currentSession.code, true);
    }

    return errors.join("\n");
  }

  async getCurrentCodeWithExtraModels(): Promise<string> {
    const currentModel = this.models.get(this.currentCodeSpace);
    if (!currentModel) {
      throw new Error("Current model not found");
    }

    const currentSession = await currentModel.getSession();
    const extraModels = await this.fetchAndCreateExtraModels(
      currentSession.code,
      location.origin,
    );

    const extraCodeSections = Object.entries(extraModels)
      .filter(([codeSpace]) => codeSpace !== this.currentCodeSpace)
      .map(([codeSpace, code]) => this.formatCodeAsSection(codeSpace, code));

    const currentCodeSection = this.formatCodeAsSection(
      this.currentCodeSpace,
      currentSession.code,
    );

    return [currentCodeSection, ...extraCodeSections].join("\n");
  }

  private async fetchAndCreateExtraModels(
    code: string,
    origin: string,
    extraModels: IExtraModelsResult = {},
  ): Promise<IExtraModelsResult> {
    const patterns = [
      ` from "(${origin})/live/[\\w-]+"`,
      ` from "\\./((?!@/)[\\w-]+)"`,
      ` from "/live/[\\w-]+"`,
    ];

    const regex = new RegExp(patterns.join("|"), "gm");
    const matches = code.matchAll(regex);

    for (const match of matches) {
      const matchedPath = match[0];
      const codeSpace = matchedPath.split("/").pop()?.replace(/"$/, "");
      if (!codeSpace || extraModels[codeSpace]) {
        continue;
      }
      const extraModelUrl = new URL(`/live/${codeSpace}/index.tsx`, origin)
        .toString();
      const response = await fetch(extraModelUrl);
      const fetchedCode = await response.text();

      extraModels[codeSpace] = fetchedCode;
      // Recursive call to find any further references
      await this.fetchAndCreateExtraModels(fetchedCode, origin, extraModels);
    }

    return extraModels;
  }

  private formatCodeAsSection(codeSpace: string, code: string): string {
    return `# ${codeSpace}.tsx\n\n\`\`\`tsx\n${code.trim()}\n\`\`\`\n`;
  }

  async release(): Promise<void> {
    for (const model of this.models.values()) {
      await model.release();
    }
    this.models.clear();
  }
}

```

# src/services/code/SessionManager.ts

```ts
import type { ICodeSession, Message } from "@/lib/interfaces";
import { sanitizeSession } from "@/lib/make-sess";
import { md5 } from "@/lib/md5";
import { CodeSessionBC } from "../CodeSessionBc";
import type { ISessionManager } from "../interfaces/ISessionManager";

interface BroadcastMessage extends ICodeSession {
  sender: string;
}

export class SessionManager implements ISessionManager {
  private session: ICodeSession;
  private user: string;
  private broadcastChannel: CodeSessionBC;

  constructor(codeSpace: string) {
    this.session = sanitizeSession({
      code: "",
      html: "",
      css: "",
      messages: [],
      codeSpace,
      transpiled: "",
    });

    // Determine the user ID (anonymous hashing if needed)
    this.user = localStorage.getItem(`${codeSpace} user`) ||
      md5(crypto.randomUUID());
    localStorage.setItem(`${codeSpace} user`, this.user);

    // Setup broadcast channel to synchronize with other clients
    this.broadcastChannel = new CodeSessionBC(codeSpace);
    this.broadcastChannel.sub((session) => {
      this.session = session;
    });
  }

  async init(initialSession?: ICodeSession): Promise<ICodeSession> {
    this.session = await this.broadcastChannel.init(initialSession);
    return this.session;
  }

  addMessageChunk(chunk: string): void {
    const oldSession = sanitizeSession(this.session);
    if (this.session.messages.length === 0) {
      this.setMessages([{
        id: Date.now().toString(),
        role: "assistant",
        content: chunk,
      }]);
      return;
    }

    const lastMessage = this.session.messages[this.session.messages.length - 1];
    if (lastMessage.role !== "assistant") {
      this.setMessages([
        ...this.session.messages,
        { id: Date.now().toString(), role: "assistant", content: chunk },
      ]);
      return;
    }

    lastMessage.content += chunk;
    this.broadcastSession(oldSession);
  }

  setMessages(messages: Message[]): boolean {
    const oldSession = sanitizeSession(this.session);
    const currentMessages = this.session.messages;

    if (messages.length === currentMessages.length) {
      // No changes if both are empty
      if (!messages.length) return false;

      // Compare last messages, then check hashes
      if (
        messages[messages.length - 1].content ===
          currentMessages[currentMessages.length - 1].content
      ) {
        const before = md5(JSON.stringify(currentMessages));
        const after = md5(JSON.stringify(messages));
        if (before === after) return false;
      }
    }

    this.session = sanitizeSession({
      ...this.session,
      messages,
    });

    this.broadcastSession(oldSession);
    return true;
  }

  subscribe(callback: (session: ICodeSession) => void): () => void {
    return this.broadcastChannel.sub(callback);
  }

  getSession(): ICodeSession {
    return this.session;
  }

  updateSession(sessionData: Partial<ICodeSession>): void {
    const oldSession = sanitizeSession(this.session);
    const newSession = sanitizeSession({
      ...this.session,
      ...sessionData,
    });
    if (md5(JSON.stringify(newSession)) === md5(JSON.stringify(this.session))) {
      return;
    }
    this.session = newSession;
    this.broadcastSession(oldSession);
  }

  /**
   * Computes the difference between two sessions, returning only changed fields
   */
  private computeSessionDiff(
    oldSession: ICodeSession,
    newSession: ICodeSession,
  ): Partial<ICodeSession> {
    const diff: Partial<ICodeSession> = {
      codeSpace: newSession.codeSpace,
    };

    // Compare simple fields
    if (oldSession.code !== newSession.code) {
      diff.code = newSession.code;
    }
    if (oldSession.html !== newSession.html) {
      diff.html = newSession.html;
    }
    if (oldSession.css !== newSession.css) {
      diff.css = newSession.css;
    }
    if (oldSession.transpiled !== newSession.transpiled) {
      diff.transpiled = newSession.transpiled;
    }

    // Compare messages with optimized diffing
    if (
      JSON.stringify(oldSession.messages) !==
        JSON.stringify(newSession.messages)
    ) {
      if (newSession.messages.length === 0) {
        diff.messages = [];
      } else if (oldSession.messages.length === newSession.messages.length) {
        // If same length, only send the modified message (usually the last one)
        const lastIndex = newSession.messages.length - 1;
        if (
          JSON.stringify(oldSession.messages[lastIndex]) !==
            JSON.stringify(newSession.messages[lastIndex])
        ) {
          diff.messages = [newSession.messages[lastIndex]];
        }
      } else {
        // If message count changed, only send the new messages
        diff.messages = newSession.messages.slice(oldSession.messages.length);
      }
    }

    return diff;
  }

  private broadcastSession(oldSession: ICodeSession): void {
    const diff = this.computeSessionDiff(oldSession, this.session);

    // Only broadcast if there are actual changes beyond just codeSpace
    if (Object.keys(diff).length > 1) {
      const broadcastData: BroadcastMessage = {
        code: this.session.code,
        html: this.session.html,
        css: this.session.css,
        messages: diff.messages || this.session.messages,
        codeSpace: this.session.codeSpace,
        transpiled: this.session.transpiled,
        sender: "Editor",
      };

      this.broadcastChannel.postMessage(broadcastData);
    }
  }

  async release(): Promise<void> {
    this.broadcastChannel.close();
  }
}

```

# src/services/CodeSession.ts

```ts
import type { ICode, ICodeSession, ImageData, Message } from "@/lib/interfaces";
import { computeSessionHash } from "@/lib/make-sess";
import { connect } from "@/lib/shared";
import { wait } from "@/lib/wait";
import { Mutex } from "async-mutex";
import { screenshot } from "../components/editorUtils";
import { CodeProcessor } from "./code/CodeProcessor";
import { ModelManager } from "./code/ModelManager";
import { SessionManager } from "./code/SessionManager";

// Mutex for thread-safe code access
const mutex = new Mutex();

/**
 * Main class that coordinates code processing, session management,
 * and model relationships.
 */
export class Code implements ICode {
  // private sessionManager: SessionManager
  // private codeSpace = getCodeSpace(location.pathname);
  private modelManager: ModelManager;
  private codeProcessor: CodeProcessor;
  private releaseWorker: () => void = () => {};
  private setCodeController: AbortController | null = null;
  private isRunning = false;
  private pendingRun: string | null = null;
  private session: ICodeSession = {
    code: "",
    codeSpace: "",
    html: "",
    css: "",
    messages: [],
    transpiled: "",
  };
  private sessionManager: SessionManager;

  constructor(private codeSpace: string) {
    this.session = {
      code: "",
      codeSpace: codeSpace,
      html: "",
      css: "",
      messages: [],
      transpiled: "",
    };
    this.sessionManager = new SessionManager(codeSpace);
    this.session.codeSpace = codeSpace;
    this.codeProcessor = new CodeProcessor(codeSpace);
    this.modelManager = new ModelManager(codeSpace, this);
    this.setSession({
      ...this.session,
      codeSpace,
    });
  }

  async getSession(): Promise<ICodeSession> {
    return this.sessionManager.getSession();
  }

  setSession(session: ICodeSession): void {
    this.session = session;
    this.sessionManager.updateSession(session);
  }

  async init(session: ICodeSession | null = null): Promise<ICodeSession> {
    const initializedSession: ICodeSession = await this.sessionManager.init(
      session ??
        await fetch(`/api/room/${this.codeSpace}/session.json`).then((res) => res.json()),
    );
    this.releaseWorker = await connect({
      signal: `${this.codeSpace} ${initializedSession.codeSpace}`,
      sess: initializedSession,
    });

    this.setSession(initializedSession);

    return initializedSession;
  }

  computeSessionHash(session: ICodeSession): string {
    return computeSessionHash(session);
  }

  getCodeSpace(): string {
    return this.codeSpace;
  }

  getMessages(): Message[] {
    return [...this.session.messages];
  }

  async getCode(): Promise<string> {
    if (mutex.isLocked()) {
      await mutex.waitForUnlock();
    }
    return this.session.code;
  }

  addMessageChunk(chunk: string): void {
    this.sessionManager.addMessageChunk(chunk);
  }

  setMessages(messages: Message[]): boolean {
    return this.sessionManager.setMessages(messages);
  }

  async setCode(
    rawCode: string,
    skipRunning = false,
  ): Promise<string | boolean> {
    if (this.isRunning) {
      this.pendingRun = rawCode;
      while (this.isRunning) {
        await wait(100);
      }
      if (this.pendingRun !== rawCode) {
        console.log("Skipping outdated run request");
        return false;
      }
    }

    this.isRunning = true;
    this.pendingRun = null;

    try {
      return await this.updateCodeInternal(rawCode, skipRunning);
    } catch (error) {
      console.error("Error setting code:", error);
      return false;
    } finally {
      this.isRunning = false;
    }
  }

  private async updateCodeInternal(
    rawCode: string,
    skipRunning: boolean,
  ): Promise<string> {
    if (rawCode === this.session.code) {
      return this.session.code;
    }

    if (skipRunning) {
      this.setSession({
        ...this.session,
        code: rawCode,
      });
      return rawCode;
    }

    if (this.setCodeController) {
      this.setCodeController.abort();
    }

    this.setCodeController = new AbortController();
    const signal = this.setCodeController.signal;

    const result = await this.codeProcessor.process(
      rawCode,
      skipRunning,
      signal,
      () => this.session,
    );

    if (!result) {
      return this.session.code;
    }

    this.sessionManager.updateSession(result);
    return this.session.code;
  }

  async setModelsByCurrentCode(newCodes: string): Promise<string> {
    return this.modelManager.updateModelsByCode(newCodes);
  }

  async currentCodeWithExtraModels(): Promise<string> {
    return this.modelManager.getCurrentCodeWithExtraModels();
  }

  sub(callback: (session: ICodeSession) => void): () => void {
    return this.sessionManager.subscribe(callback);
  }

  async release(): Promise<void> {
    this.releaseWorker();
    await Promise.all([
      this.sessionManager.release(),
      this.modelManager.release(),
    ]);
  }

  screenshot(): Promise<ImageData> {
    return screenshot();
  }

  async run(): Promise<void> {
    await this.init();
  }
}

```

# src/services/CodeSessionBc.ts

```ts
import { getBroadcastChannel } from "@/lib/broadcast-channel";
import { sanitizeSession } from "@/lib/make-sess";
import { ICodeSession } from "src/modules";
import { ICodeSessionBC } from "./websocket/types";

export class CodeSessionBC implements ICodeSessionBC {
  private broadcastChannel: BroadcastChannel;
  session: ICodeSession | null = null;
  subscribers: Array<(session: ICodeSession) => void> = [];

  constructor(private codeSpace: string, session?: ICodeSession) {
    if (session) {
      this.session = session;
    }

    this.broadcastChannel = getBroadcastChannel(this.codeSpace);

    this.broadcastChannel.onmessage = (
      { data }: MessageEvent<ICodeSession>,
    ) => {
      if (!this.session) {
        this.session = sanitizeSession(data);
      }

      // console.log("broadcastChannel.onmessage", data);

      const newSession = this.session = sanitizeSession({
        ...this.session,
        ...data,
      });

      this.subscribers.forEach((cb) => cb(newSession));
    };
  }

  async getCode() {
    if (!this.session) {
      this.session = await this.init();
    }
    return this.session.code;
  }

  async init(session?: ICodeSession): Promise<ICodeSession> {
    return this.session = session || this.session ||
      (await fetch(`/live/${this.codeSpace}/session.json`).then((
        response,
      ) => response.json())) as ICodeSession;
  }

  sub(callback: (session: ICodeSession) => void): () => void {
    this.subscribers.push(callback);
    return () => {
      this.subscribers = this.subscribers.filter((cb) => cb !== callback);
      return;
    };
  }
  postMessage(session: ICodeSession): void {
    this.subscribers.forEach((cb) => {
      try {
        cb(session);
      } catch (error) {
        console.error("Error in CodeSessionBC.postMessage", error);
      }
    });
    this.broadcastChannel.postMessage(session);
  }
  close(): void {
    this.broadcastChannel.close();
  }
}

```

# src/services/interfaces/ICodeProcessor.ts

```ts
import { RunMessageResult } from "../websocket/types";

export interface ICodeProcessor {
  /**
   * Processes the code by formatting, transpiling, and optionally running it
   * @param rawCode The code to process
   * @param skipRunning Whether to skip the code execution step
   * @param signal AbortSignal for cancellation
   * @returns Updated session data or false if processing failed
   */
  process(
    rawCode: string,
    skipRunning: boolean,
    signal: AbortSignal,
  ): Promise<RunMessageResult | false>;

  runCode(code: string): Promise<RunMessageResult>;
}

```

# src/services/interfaces/IModelManager.ts

```ts
import type { Code } from "../CodeSession";

export interface IModelManager {
  /**
   * Get a code model by its codeSpace
   * @param codeSpace The code space identifier
   */
  getModel(codeSpace: string): Code | undefined;

  /**
   * Add or update a model
   * @param codeSpace The code space identifier
   * @param model The code model instance
   */
  setModel(codeSpace: string, model: Code): void;

  /**
   * Update models based on code sections
   * @param newCodes Code sections to process
   * @returns Error message if any updates failed
   */
  updateModelsByCode(newCodes: string): Promise<string>;

  /**
   * Get current code with referenced models
   * @returns Formatted code sections including extra models
   */
  getCurrentCodeWithExtraModels(): Promise<string>;

  /**
   * Clean up resources for all models
   */
  release(): Promise<void>;
}

export type IExtraModelsResult = Record<string, string>;

```

# src/services/interfaces/ISessionManager.ts

```ts
import type { ICodeSession, Message } from "@/lib/interfaces";

export interface ISessionManager {
  /**
   * Initialize the session
   * @param initialSession Optional initial session data
   */
  init(initialSession?: ICodeSession): Promise<ICodeSession>;

  /**
   * Add a message chunk to the current session
   * @param chunk Message content to add
   */
  addMessageChunk(chunk: string): void;

  /**
   * Update session messages
   * @param messages New messages array
   * @returns true if messages were updated, false if no changes
   */
  setMessages(messages: Message[]): boolean;

  /**
   * Subscribe to session changes
   * @param callback Function to call when session changes
   * @returns Unsubscribe function
   */
  subscribe(callback: (session: ICodeSession) => void): () => void;

  /**
   * Get the current session
   */
  getSession(): ICodeSession;

  /**
   * Update the session and broadcast changes
   * @param sessionData Updated session data
   */
  updateSession(sessionData: Partial<ICodeSession>): void;

  /**
   * Clean up resources
   */
  release(): Promise<void>;
}

```

# src/services/message/MessageHandlerService.ts

```ts
import type {
  Message,
  MessageContent,
  MessageHandlerConfig,
  MessageResponse,
} from "@/lib/interfaces";

import { MessageType } from "@/lib/interfaces";

/**
 * Service for handling and processing different types of messages
 * with support for text, command, and status messages.
 */
export class MessageHandlerService {
  private config: MessageHandlerConfig;

  /**
   * Creates a new MessageHandlerService instance
   * @param config Optional configuration for the service
   */
  constructor(config: MessageHandlerConfig = {}) {
    this.config = {
      logErrors: true,
      maxRetries: 3,
      timeout: 5000,
      ...config,
    };
  }

  /**
   * Validates if an unknown object is a valid Message
   * @param message The object to validate
   * @returns Type guard indicating if the object is a valid Message
   */
  public validateMessage(message: unknown): message is Message {
    if (!message || typeof message !== "object") {
      return false;
    }

    const msg = message as Message;
    return (
      "id" in msg &&
      "type" in msg &&
      "role" in msg
    );
  }

  /**
   * Type guard to check if content is a TextPart
   * @param content The content to check
   * @returns True if content is a TextPart
   */
  private isTextPart(part: unknown): part is { type: "text"; text: string; } {
    return (
      typeof part === "object" &&
      part !== null &&
      "type" in part &&
      part.type === "text" &&
      "text" in part &&
      typeof (part as { text: unknown; }).text === "string"
    );
  }

  /**
   * Extracts text content from different MessageContent types
   * @param content The message content to process
   * @returns The extracted text string
   * @throws Error if no valid text content is found
   */
  private getTextFromContent(content: MessageContent): string {
    if (typeof content === "string") {
      return content;
    }

    if (!Array.isArray(content)) {
      throw new Error("Invalid message content type");
    }

    const textPart = content.find(this.isTextPart);
    if (!textPart) {
      throw new Error("No text content found in message parts");
    }
    return textPart.text;
  }

  /**
   * Main method for handling messages
   * @param message The message to process
   * @returns A promise resolving to a MessageResponse
   */
  public async handleMessage(message: Message): Promise<MessageResponse> {
    try {
      if (!this.validateMessage(message)) {
        throw new Error("Invalid message format");
      }

      if (!message.content) {
        throw new Error("Missing message content");
      }

      if (!Object.values(MessageType).includes(message.type as MessageType)) {
        console.error("Unhandled message type:", message.type);
        return {
          success: false,
          error: "Unhandled message type",
        };
      }

      const result = await this.processMessage(message);
      if (typeof result === "object" && result !== null && "error" in result) {
        return {
          success: false,
          error: String(result.error),
        };
      }

      return {
        success: true,
        data: result,
      };
    } catch (error) {
      if (this.config.logErrors) {
        console.error("Error processing message:", error);
      }

      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  /**
   * Processes a message based on its type
   * @param message The message to process
   * @returns A promise resolving to the processed result
   * @throws Error if message processing fails
   */
  private async processMessage(
    message: Message,
  ): Promise<Record<string, unknown>> {
    try {
      const text = this.getTextFromContent(message.content);

      switch (message.type) {
        case MessageType.TEXT:
          return { text };
        case MessageType.COMMAND:
          return { command: text, executed: true };
        case MessageType.STATUS:
          return { status: text, timestamp: new Date().toISOString() };
        default:
          throw new Error("Unhandled message type");
      }
    } catch {
      throw new Error("Invalid message content type");
    }
  }
}

```

# src/services/message/types.ts

```ts

```

# src/services/render/RenderService.ts

```ts
import type { RenderedApp } from "@/lib/interfaces";
import { md5 } from "@/lib/md5";
import { Mutex } from "async-mutex";

export class RenderService {
  private rendered: RenderedApp | null = null;
  private renderedMd5 = "";
  private readonly mutex = new Mutex();
  private readonly codeSpace: string;

  constructor(codeSpace: string) {
    this.codeSpace = codeSpace;
  }

  public async updateRenderedApp(
    { transpiled }: { transpiled: string; },
  ): Promise<RenderedApp | null> {
    let hashed = md5(transpiled);
    if (hashed === this.renderedMd5 && !transpiled.includes(`cn("`)) {
      console.log("Skipping update as md5 is the same");
      return this.rendered;
    } else if (transpiled.includes(`cn("`)) {
      const cnArr = transpiled.split(`cn("`);
      for (let i = 1; i < cnArr.length; i++) {
        cnArr[i] = cnArr[i].split(" ").join("  ");
      }
      transpiled = cnArr.join(`cn( "`);
      hashed = md5(transpiled);
    }

    this.renderedMd5 = hashed;
    // console.log("Updating rendered app...");

    await this.mutex.runExclusive(async () => {
      const myEl = document.createElement("div");
      document.body.appendChild(myEl);

      this.cleanup();

      const { renderApp } = await import("@/external/render-app");
      this.rendered = await renderApp({
        transpiled,
        codeSpace: this.codeSpace,
        rootElement: myEl,
      });

      document.getElementById("embed")?.replaceWith(myEl);
      document.getElementById("embed")?.remove();
      myEl.id = "embed";
    });

    return this.rendered;
  }

  public async handleRender(
    renderedNew: RenderedApp | null,
  ): Promise<{ css: string; html: string; } | false> {
    if (renderedNew === null) {
      return {
        css: "",
        html: "",
      };
    }

    const { cssCache, rootElement } = renderedNew;

    const html = this.htmlDecode(rootElement.innerHTML).split(cssCache.key)
      .join("x");
    const emotionGlobalStyles = [
      ...document.querySelectorAll<HTMLStyleElement>(
        `style[data-emotion='${cssCache.key}-global']`,
      )
        .values(),
    ].map((x) => (Array.from(x.sheet!.cssRules).map((x) => x.cssText)).join("\n"));

    const emotionStyles = [
      ...emotionGlobalStyles,
      ...[...cssCache.sheet.tags].map((
        tag: HTMLStyleElement,
      ) => ([...tag.sheet!.cssRules!].map((x) => x.cssText))).flat(),
    ].join("\n")
      .split(cssCache.key).join("x");

    console.log("Emotion styles:", emotionStyles);

    const tailWindClasses = [
      ...document.querySelectorAll<HTMLStyleElement>("head > style"),
    ].map(
      (z) => z.innerHTML,
    ).join("\n");

    const tailWindClassesXWithoutComments = tailWindClasses.replace(
      /\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm,
      "",
    );
    const tailWindClassesX = tailWindClassesXWithoutComments.split(`\\\\[`)
      .join(`\\[`).split(
        `\\\\]`,
      ).join(`\\]`);

    const cssStrings = [emotionStyles, tailWindClassesX].join("\n");

    return {
      css: cssStrings,
      html,
    };
  }

  public cleanup(): void {
    this.rendered?.cleanup();
    this.rendered = null;
  }

  private htmlDecode(input: string): string {
    return input
      .split("><").join(">\n<")
      .replace(/&amp;/g, "&")
      .replace(/&gt;/g, ">")
      .replace(/&lt;/g, "<")
      .replace(/&quot;/g, '"')
      .replace(/&apos;/g, "'")
      .replace(/&nbsp;/g, " ");
  }
}

```

# src/services/screenshot/ScreenshotService.ts

```ts
import type { IframeMessage, ImageData } from "@/lib/interfaces";
import { processImage } from "@/lib/process-image";

export class ScreenshotService {
  private readonly codeSpace: string;

  constructor(codeSpace: string) {
    this.codeSpace = codeSpace;
  }

  public async takeScreenshot(): Promise<void> {
    try {
      const html2canvas = (await import("@/external/html2canvas")).default;
      const canvas = await html2canvas(document.body, { imageTimeout: 100 });

      const blob = await this.canvasToBlob(canvas);
      const file = this.createScreenshotFile(blob);
      const imageData = await processImage(file);
      this.postScreenshotMessage(imageData);
    } catch (error) {
      console.error("Error taking screenshot:", error);
      throw error;
    }
  }

  private canvasToBlob(canvas: HTMLCanvasElement): Promise<Blob> {
    return new Promise<Blob>((resolve, reject) => {
      canvas.toBlob(
        (blob) =>
          blob
            ? resolve(blob)
            : reject(new Error("Failed to create blob from canvas")),
        "image/png",
      );
    });
  }

  private createScreenshotFile(blob: Blob): File {
    return new File([blob], `screenshot-${this.codeSpace}.png`, {
      type: "image/png",
    });
  }

  private postScreenshotMessage(imageData: ImageData): void {
    const message: IframeMessage = {
      type: "screenshot",
      requestId: crypto.randomUUID(),
      imageData,
    };
    window.parent.postMessage(message, "*");
  }
}

```

# src/services/websocket/enums.ts

```ts
/**
 * WebSocket connection states
 */
export enum WebSocketState {
  CONNECTING = "connecting",
  CONNECTED = "connected",
  DISCONNECTED = "disconnected",
  RECONNECTING = "reconnecting",
  ERROR = "error",
}

/**
 * WebSocket event types
 */
export enum WebSocketEventType {
  MESSAGE = "message",
  ERROR = "error",
  CLOSE = "close",
  OPEN = "open",
}

```

# src/services/websocket/types.ts

```ts
// Using built-in MessageEvent type from lib.dom.d.ts

/**
 * Message data structure for WebSocket communication
 */
export interface MessageData {
  /** HTML content of the message */
  html: string;
  /** CSS content of the message */
  css: string;
  /** Optional source code */
  code?: string;
  /** Optional transpiled code */
  transpiled?: string;
}

/**
 * Result structure for run message operations
 */
export interface RunMessageResult {
  /** Generated HTML content */
  html: string;
  /** Generated CSS content */
  css: string;
}

/**
 * Configuration options for WebSocket manager
 */
export interface WebSocketConfig {
  /** Retry attempts for failed connections */
  maxRetries?: number;
  /** Delay between retry attempts in milliseconds */
  retryDelay?: number;
  /** Timeout for connection attempts in milliseconds */
  connectionTimeout?: number;
}

/**
 * Dependencies required by WebSocket manager
 */
export interface WebSocketDependencies {
  /** Message handler service */
  messageHandler: IMessageHandlerService;
  /** Service worker manager */
  serviceWorker: IServiceWorkerManager;
  /** Code session broadcast channel */
  codeSessionBC: ICodeSessionBC;
}

/**
 * Interface for message handler service
 */
export interface IMessageHandlerService {
  /** Handle incoming message */
  handleMessage(event: Message): Promise<MessageResponse>;
  /** Handle run message with transpiled code */
  handleRunMessage(transpiled: string): Promise<RunMessageResult | false>;
  /** Cleanup resources */
  cleanup(): void;
}

/**
 * Interface for service worker manager
 */
export interface IServiceWorkerManager {
  /** Setup service worker */
  setup(): Promise<ServiceWorker | undefined>;
}

/**
 * Interface for code session broadcast channel
 */
export interface ICodeSessionBC {
  /** Initialize broadcast channel */
  init(): Promise<ICodeSession>;
  /** Subscribe to broadcast channel */
  sub(callback: (data: MessageData) => void): () => void;
}

/**
 * Interface for WebSocket manager
 */
export interface IWebSocketManager {
  /** Initialize WebSocket connection */
  init(): Promise<void>;
  /** Handle run message */
  handleRunMessage(transpiled: string): Promise<RunMessageResult | false>;
  /** Cleanup resources */
  cleanup(): void;
}

import { ICodeSession, Message, MessageResponse } from "@/lib/interfaces";
import { WebSocketEventType } from "./enums";

/**
 * WebSocket event handler type
 */
export type WebSocketEventHandler = (event: MessageEvent | Event) => void;

/**
 * WebSocket event subscription
 */
export interface WebSocketSubscription {
  /** Event type */
  type: WebSocketEventType;
  /** Event handler */
  handler: WebSocketEventHandler;
  /** Unsubscribe function */
  unsubscribe: () => void;
}

/**
 * Re-export enums from separate file
 */
export { WebSocketEventType, WebSocketState } from "./enums";

```

# src/services/websocket/WebSocketManager.ts

```ts
import { getCodeSpace } from "@/hooks/use-code-space";
import { DOMError, getErrorMessage, MessageHandlingError, WebSocketError } from "@/lib/errors";
import { Message } from "@/lib/interfaces";
import { init } from "@/lib/tw-dev-setup";
import { ROUTES } from "../../config/routes";
import { WebSocketEventType, WebSocketState } from "./enums";
import {
  IWebSocketManager,
  MessageData,
  RunMessageResult,
  WebSocketConfig,
  WebSocketDependencies,
  WebSocketSubscription,
} from "./types";

const DEFAULT_CONFIG: Required<WebSocketConfig> = {
  maxRetries: 3,
  retryDelay: 1000,
  connectionTimeout: 5000,
};

/**
 * WebSocket manager for handling real-time code synchronization
 * and communication between client and server.
 */
export class WebSocketManager implements IWebSocketManager {
  private readonly codeSpace: string;
  private readonly dependencies: WebSocketDependencies;
  private readonly config: Required<WebSocketConfig>;
  private state = WebSocketState.DISCONNECTED;
  private retryCount = 0;
  private readonly subscriptions = new Set<WebSocketSubscription>();

  constructor(
    dependencies: WebSocketDependencies,
    config: WebSocketConfig = {},
  ) {
    this.codeSpace = getCodeSpace(location.pathname);
    this.dependencies = dependencies;
    this.config = { ...DEFAULT_CONFIG, ...config };

    // Initialize service worker with delay
    setTimeout(() => {
      this.dependencies.serviceWorker.setup().catch(this.handleError);
    }, 0);
  }

  /**
   * Initializes the WebSocket connection and sets up message handlers
   * @throws {WebSocketError} If initialization fails
   */
  public async init(): Promise<void> {
    try {
      await this.initializeResources();
      await this.setupRouteHandlers();
    } catch (error) {
      this.handleError(error);
      console.error("WebSocket initialization error:", {
        error: getErrorMessage(error),
        state: this.state,
      });
      throw new WebSocketError(
        `Failed to initialize WebSocket: ${getErrorMessage(error)}`,
        error instanceof Error ? error : undefined,
      );
    }
  }

  /**
   * Handles code transpilation and returns the rendered result
   * @param transpiled - Transpiled code to run
   * @returns Promise resolving to rendered HTML/CSS or false if failed
   */
  public async handleRunMessage(
    transpiled: string,
  ): Promise<RunMessageResult | false> {
    return this.dependencies.messageHandler.handleRunMessage(transpiled);
  }

  /**
   * Cleans up resources and event listeners
   */
  public cleanup(): void {
    try {
      this.dependencies.messageHandler.cleanup();
      window.onmessage = null;
      this.unsubscribeAll();
    } catch (error) {
      this.handleError(error);
      throw new WebSocketError(`Cleanup failed: ${getErrorMessage(error)}`);
    }
  }

  /**
   * Initialize required resources
   * @private
   */
  private async initializeResources(): Promise<void> {
    try {
      await init();
      // console.log("Resource loading complete");
    } catch (error) {
      console.error("Resource initialization error:", error);
      // Continue execution as this is non-critical
    }
  }

  /**
   * Set up route-specific handlers
   * @private
   */
  private async setupRouteHandlers(): Promise<void> {
    const currentPath = location.pathname;

    if (currentPath === ROUTES.LIVE(this.codeSpace)) {
      await this.handleLivePage();
    } else if (currentPath === ROUTES.LIVE_CMS(this.codeSpace)) {
      await this.handleLivePage();
    } else if (currentPath === ROUTES.DEHYDRATED(this.codeSpace)) {
      await this.handleDehydratedPage();
    } else {
      await this.handleDefaultPage();
    }
  }

  /**
   * Handle live page setup and initialization
   * @private
   */
  private async handleLivePage(): Promise<void> {
    try {
      await this.dependencies.codeSessionBC.init();

      // Subscribe to code session updates
      this.dependencies.codeSessionBC.sub((data: MessageData) => {
        console.log("Code session update:", data);
        // Additional live page specific handling can be added here
      });

      this.state = WebSocketState.CONNECTED;
    } catch (error) {
      this.handleError(error);
      throw new WebSocketError(
        `Failed to initialize live page: ${getErrorMessage(error)}`,
        error instanceof Error ? error : undefined,
      );
    }
  }

  /**
   * Handle dehydrated page rendering
   * @private
   */
  private async handleDehydratedPage(): Promise<void> {
    const handleDehydratedContent = (event: MessageEvent | Event): void => {
      if (!(event instanceof MessageEvent)) return;
      const { html, css } = event.data as MessageData;
      try {
        const embedElement = document.getElementById("embed");
        if (!embedElement) {
          throw new DOMError("Embed element not found", "embed");
        }

        embedElement.innerHTML = `
          <style type="text/css">${css}</style>
          <div>${html}</div>
        `;
      } catch (error) {
        this.handleError(error);
        if (error instanceof DOMError) {
          throw error;
        }
        throw new WebSocketError(
          `Failed to handle dehydrated content: ${getErrorMessage(error)}`,
        );
      }
    };

    this.subscribe(WebSocketEventType.MESSAGE, handleDehydratedContent);
  }

  /**
   * Handle default page message routing
   * @private
   */
  private async handleDefaultPage(): Promise<void> {
    const messageHandler = (event: unknown): void => {
      const data = (event as MessageEvent).data;
      try {
        this.dependencies.messageHandler.handleMessage(data)
          .catch((error) => {
            this.handleError(error);
            throw new MessageHandlingError("Failed to handle message", data);
          });
      } catch (error) {
        this.handleError(error);
        if (error instanceof MessageHandlingError) {
          throw error;
        }
        throw new WebSocketError(
          `Message handler failed: ${getErrorMessage(error)}`,
        );
      }
    };

    this.subscribe(WebSocketEventType.MESSAGE, messageHandler);

    // Set up window message handler
    window.onmessage = (event: unknown): void => {
      this.dependencies.messageHandler.handleMessage(event as Message)
        .catch((error) => {
          this.handleError(error);
          throw new MessageHandlingError("Failed to handle window message", {
            event,
          });
        });
    };
  }

  /**
   * Subscribe to WebSocket events
   * @private
   */
  private subscribe(
    type: WebSocketEventType,
    handler: (event: MessageEvent | Event) => void,
  ): () => void {
    const subscription: WebSocketSubscription = {
      type,
      handler,
      unsubscribe: () => this.subscriptions.delete(subscription),
    };
    this.subscriptions.add(subscription);
    return subscription.unsubscribe;
  }

  /**
   * Unsubscribe all event handlers
   * @private
   */
  private unsubscribeAll(): void {
    this.subscriptions.forEach((subscription) => subscription.unsubscribe());
    this.subscriptions.clear();
  }

  /**
   * Handle errors with proper logging and state management
   * @private
   */
  private readonly handleError = (error: unknown): void => {
    const errorMessage = getErrorMessage(error);
    console.error("WebSocket error:", errorMessage);
    this.state = WebSocketState.ERROR;

    // Implement retry logic for recoverable errors
    if (this.retryCount < this.config.maxRetries) {
      this.retryCount++;
      this.state = WebSocketState.RECONNECTING;
      setTimeout(() => {
        console.log(
          `Retrying connection (${this.retryCount}/${this.config.maxRetries})...`,
        );
        this.init().catch(console.error);
      }, this.config.retryDelay);
    }
  };
}

```

# src/services/worker/ServiceWorkerManager.ts

```ts
import { setupServiceWorker } from "@/lib/hydrate";
import { IServiceWorkerManager } from "../websocket/types";

interface IExtendedWindow extends Window {
  __IS_IFRAME__: boolean;
}

export class ServiceWorkerManager implements IServiceWorkerManager {
  async setup(): Promise<ServiceWorker | undefined> {
    // Do not setup service worker when running in an iframe.
    // Additionally, allow tests to simulate iframe mode via window.__IS_IFRAME__
    if (
      (window as unknown as IExtendedWindow).__IS_IFRAME__ === true ||
      window.self !== window.parent
    ) {
      return;
    }
    try {
      await setupServiceWorker();
    } catch (setupError) {
      console.error("Error setting up service worker:", { setupError });
      throw setupError;
    }
  }
}

```

# src/setupTests.ts

```ts
import "@testing-library/jest-dom";

// Mock window.matchMedia
// Object.defineProperty(window, "matchMedia", {
//   writable: true,
//   value: vi.fn().mockImplementation((query) => ({
//     matches: false,
//     media: query,
//     onchange: null,
//     addListener: vi.fn(), // Deprecated
//     removeListener: vi.fn(), // Deprecated
//     addEventListener: vi.fn(),
//     removeEventListener: vi.fn(),
//     dispatchEvent: vi.fn(),
//   })),
// });

// Mock Worker
class MockWorker implements Worker {
  onmessage: ((event: MessageEvent) => void) | null = null;
  onmessageerror: ((event: MessageEvent) => void) | null = null;
  onerror: ((error: ErrorEvent) => void) | null = null;

  constructor(
    private _stringUrl: string | URL,
    private options?: WorkerOptions,
  ) {
    console.log("MockWorker created:", this._stringUrl, this.options);

    // Constructor implementation
  }

  addEventListener(type: string, listener: EventListener): void {
    if (type === "message") {
      this.onmessage = listener as (event: MessageEvent) => void;
    } else if (type === "error") {
      this.onerror = listener as (error: ErrorEvent) => void;
    }
  }

  removeEventListener(type: string): void {
    if (type === "message") {
      this.onmessage = null;
    } else if (type === "error") {
      this.onerror = null;
    }
  }

  postMessage(data: unknown): void {
    if (this.onmessage) {
      const messageEvent = new MessageEvent("message", { data });
      this.onmessage(messageEvent);
    }
  }

  terminate(): void {
    this.onmessage = null;
    this.onerror = null;
  }

  dispatchEvent(): boolean {
    return true;
  }
}

// Mock SharedWorker
class MockSharedWorker implements SharedWorker {
  private url: string;
  private options: string | WorkerOptions;

  port: MessagePort = {
    onmessage: null,
    onmessageerror: null,
    close: vi.fn(),
    start: vi.fn(),
    addEventListener: vi.fn(),
    removeEventListener: vi.fn(),
    dispatchEvent: vi.fn().mockReturnValue(true),
    postMessage: vi.fn(),
  };

  onerror: ((event: ErrorEvent) => void) | null = null;

  constructor(stringUrl: string | URL, options?: string | WorkerOptions) {
    this.url = stringUrl as string;
    this.options = options || "";
    // console.log("MockSharedWorker created:", this.url, this.options);
    // Constructor implementation
  }

  addEventListener(type: string, listener: EventListener): void {
    if (type === "error") {
      this.onerror = listener as (error: ErrorEvent) => void;
    }
  }

  removeEventListener(type: string, _listener: EventListener): void {
    if (type === "error") {
      this.onerror = null;
    }
  }

  dispatchEvent(_event: Event): boolean {
    return true;
  }
}

// Define type for Web Workers
declare global {
  interface Window {
    Worker: typeof MockWorker;
    SharedWorker: typeof MockSharedWorker;
  }
}

// Implement Web Worker mocks
window.Worker = MockWorker;
window.SharedWorker = MockSharedWorker;

// Mock Location API
const mockLocation = {
  href: "http://localhost:3000",
  pathname: "/",
  search: "",
  hash: "",
  assign: vi.fn(),
  replace: vi.fn(),
  reload: vi.fn(),
};

// Object.defineProperty(window, "location", {
//   value: mockLocation,
//   writable: true,
// });

// Define type for Navigation API
interface NavigationAPI {
  navigate: (url: string) => Promise<void>;
  reload: () => Promise<void>;
  traverseTo: (key: string) => Promise<void>;
  back: () => Promise<void>;
  forward: () => Promise<void>;
}

// Mock Navigation API when using JSDOM
declare global {
  interface Window {
    navigation: NavigationAPI;
  }
}

// Mock Navigation API
window.navigation = {
  navigate: vi.fn().mockResolvedValue(undefined),
  reload: vi.fn().mockResolvedValue(undefined),
  traverseTo: vi.fn().mockResolvedValue(undefined),
  back: vi.fn().mockResolvedValue(undefined),
  forward: vi.fn().mockResolvedValue(undefined),
};

// Mock ResizeObserver
class MockResizeObserver {
  observe = vi.fn();
  unobserve = vi.fn();
  disconnect = vi.fn();
}

window.ResizeObserver = MockResizeObserver;
window.scrollTo = vi.fn();

// Mock fetch
global.fetch = vi.fn();

// Add Vitest beforeEach hook
import { beforeEach, vi } from "vitest";

beforeEach(() => {
  vi.clearAllMocks();
  mockLocation.pathname = "/";
  mockLocation.search = "";
  mockLocation.hash = "";
});

```

# src/start.ts

```ts
import { renderApp } from "@/lib/render-app";
import { App } from "./App";
import { router } from "./routes/router";
import "./index.css";
import { getCodeSpace } from "@/hooks/use-code-space";
import { RouterError } from "@/lib/errors";

// TypeScript interfaces
interface RouterLocation {
  pathname: string;
}

interface RouterResolvedEvent {
  toLocation: RouterLocation;
}

// Route checking utilities
const isLiveRoute = (pathname: string): boolean => pathname.startsWith("/live/");
const isLiveCMSRoute = (pathname: string): boolean => pathname.startsWith("/live-cms/");
const isDehydratedRoute = (pathname: string): boolean => pathname.endsWith("dehydrated");
const shouldRenderApp = (pathname: string): boolean =>
  (isLiveRoute(pathname) || isLiveCMSRoute(pathname)) &&
  !isDehydratedRoute(pathname) &&
  !pathname.endsWith("/");

// Error handling
const handleError = (error: unknown): void => {
  console.error("Application initialization failed:", error);
  // Here we could add more sophisticated error handling
  // Like error reporting to a service or showing user feedback
};

/**
 * Initialize the WebSocket connection for live code spaces
 */
const initializeWebSocket = async (codeSpace: string): Promise<void> => {
  try {
    const { main } = await import("./ws");

    if (process.env.NODE_ENV !== "test") {
      await main(codeSpace);
    }
  } catch (error) {
    handleError(error);
  }
};

/**
 * Handle route resolution and app rendering
 */
const handleRouteResolution = async (
  codeSpace: string | null,
  { toLocation }: RouterResolvedEvent,
): Promise<void> => {
  if (!codeSpace) return;

  try {
    const { pathname } = toLocation;

    if (shouldRenderApp(pathname)) {
      const rendered = await renderApp({ codeSpace });
      Object.assign(window, { rendered });
    }
  } catch (error) {
    handleError(error);
  }
};

// Handle .tsx extension removal
if (location.pathname.endsWith(".tsx")) {
  location.href = location.href.replace(".tsx", "");
}

// Initialize application
router.load().then(async () => {
  try {
    const codeSpace = getCodeSpace(location.pathname);
    await renderApp({ App });

    if (location.pathname === `/live/${codeSpace}/iframe`) {
      try {
        await initializeWebSocket(codeSpace);
      } catch (error) {
        console.error("WebSocket initialization failed:", error);
        throw new RouterError(
          "WebSocket initialization failed",
          `/live/${codeSpace}/iframe`,
        );
      }
    }

    // Setup router subscriptions
    router.subscribe(
      "onResolved",
      (event: RouterResolvedEvent) => handleRouteResolution(codeSpace, event),
    );
  } catch (error) {
    handleError(error);
  }
}).catch(handleError);

```

# src/sw-deps.ts

```ts
import { QueuedFetch } from "@/lib/queued-fetch";
import { serveWithCache } from "@/lib/serve-with-cache";
import { fakeServer } from "./sw-local-fake-server";

export type { fakeServer, QueuedFetch, serveWithCache };

Object.assign(globalThis, {
  serveWithCache,
  QueuedFetch,
  fakeServer,
});

```

# src/sw-local-fake-server.ts

```ts
import { getCodeSpace } from "@/hooks/use-code-space";
import importMap, { importMapReplace } from "@/lib/importmap-utils";
import { routes } from "@/lib/routes";
import { transpile } from "@/lib/shared";
import { CodeSessionBC } from "./services/CodeSessionBc";
import type {} from "./def";
import HTML from "./index.html";

import type { ICodeSession } from "@/lib/interfaces";
import { sessionToJSON } from "@/lib/make-sess";

const cSessions: Record<string, CodeSessionBC> = {};

export async function fakeServer(request: Request) {
  const { pathname } = new URL(request.url.replace("api/room/", "live/"));
  const codeSpace = getCodeSpace(pathname);
  console.log("CodeSpace:", codeSpace);

  cSessions[codeSpace] = cSessions[codeSpace] ||
    new CodeSessionBC(
      codeSpace,
      await fetch(`/api/room/${codeSpace}/session.json`).then(
        (r) => r.json(),
      ),
    );

  const session = await cSessions[codeSpace].init();

  if (
    request.url.includes("/session.json")
  ) {
    return handleSessionJson(request, session);
  } else if (
    request.url.includes("/index.tsx")
  ) {
    return handleIndexTsx(request, session);
  } else if (
    request.url.includes("/index.js")
  ) {
    return await handleIndexJs(request, session, codeSpace);
  } else if (
    request.url.includes("/index.css")
  ) {
    return handleIndexCss(request, session);
  } else if (
    pathname in Object.keys(routes) ||
    request.url.includes("/hydrated") ||
    request.url.includes("/worker") ||
    request.url.includes("/dehydrated") ||
    request.url.includes("/iframe") ||
    request.url.endsWith("/") ||
    !request.url.includes("/live") ||
    request.url.includes("/embed") ||
    request.url.includes("/public") ||
    request.url.endsWith(`/live/${codeSpace}/xxx`) ||
    request.url.endsWith(`/live/${codeSpace}/`)
  ) {
    // let html = HTML;
    // if (request.url.includes("localhost")) {
    // html = await fetch(HTML).then((resp) => resp.text());
    // }
    return handleHtmlResponse(session, HTML);
  } else if (
    request.url.endsWith(`/live/${codeSpace}`)
  ) {
    return handleEditorResponse(codeSpace);
  } else {
    console.log("Default request:", request.url);

    return fetch(request);
  }
}

function handleEditorResponse(codeSpace: string) {
  const respText = HTML.replace(
    `<script type="importmap"></script>`,
    `<script type="importmap">${JSON.stringify(importMap)}</script>`,
  ).replace(
    '<div id="embed"></div>',
    `<div id="embed"><iframe title="Live preview" src="/live/${codeSpace}/iframe"></iframe></div>`,
  );

  const headers = new Headers({
    "Access-Control-Allow-Origin": "*",
    "Cross-Origin-Embedder-Policy": "require-corp",
    "Cross-Origin-Resource-Policy": "cross-origin",
    "Cross-Origin-Opener-Policy": "same-origin",
    "Cache-Control": "no-cache",
    "Content-Encoding": "gzip",
    "Content-Type": "text/html; charset=UTF-8",
  });

  return new Response(respText, { status: 200, headers });
}

function handleHtmlResponse(session: ICodeSession, HTML: string) {
  const { codeSpace } = session;
  const respText = HTML.replace(
    `<script type="importmap"></script>`,
    `<script type="importmap">${JSON.stringify(importMap)}</script>`,
  ).replace(
    `<!-- Inline LINK for initial theme -->`,
    `<link rel="preload" href="/live/${codeSpace}/index.css" as="style" />
     <link rel="stylesheet" href="/live/${codeSpace}/index.css" />`,
  ).replace(
    '<div id="embed"></div>',
    `<div id="embed">${session.html}</div>`,
  );

  const headers = new Headers({
    "Access-Control-Allow-Origin": "*",
    "Cross-Origin-Embedder-Policy": "require-corp",
    "Cross-Origin-Resource-Policy": "cross-origin",
    "Cross-Origin-Opener-Policy": "same-origin",
    "Cache-Control": "no-cache",
    "Content-Encoding": "gzip",
    "Content-Type": "text/html; charset=UTF-8",
  });

  return new Response(respText, { status: 200, headers });
}

function handleIndexCss(
  request: Request,
  session: ICodeSession,
) {
  console.log("css request:", request.url);

  return new Response(session.css, {
    headers: {
      "Content-Type": "text/css; charset=UTF-8",
      ...request.headers,
    },
  });
}

async function handleIndexJs(
  request: Request,
  session: ICodeSession,
  codeSpace: string,
) {
  console.log("Transpiled request:", request.url);

  if (typeof session.transpiled !== "string" || session.transpiled === "") {
    const transpiled = await transpile({
      code: session.code,
      originToUse: "",
    }) as unknown as string;
    session.transpiled = transpiled;
    await cSessions[codeSpace].postMessage({
      ...session,
      transpiled,
    });
  }

  return new Response(
    importMapReplace(session.transpiled, ""),
    {
      headers: {
        "Content-Type": "application/javascript; charset=UTF-8",
        ...request.headers,
      },
    },
  );
}

function handleIndexTsx(
  request: Request,
  session: ICodeSession,
) {
  console.log("Index request:", request.url);

  return new Response(session.code, {
    headers: {
      "Content-Type": "application/javascript; charset=UTF-8",
      ...request.headers,
    },
  });
}

function handleSessionJson(
  request: Request,
  session: ICodeSession,
) {
  console.log("Session request:", request.url);

  return new Response(sessionToJSON(session), {
    headers: {
      "Content-Type": "application/json",
      ...request.headers,
    },
  });
}

```

# src/sw.ts

```ts
import { ServiceWorkerHandlers } from "./@/handlers/sw-handlers";
import { CustomServiceWorkerGlobalScope } from "./@/types/service-worker";
import { CACHE_VERSION } from "./@/utils/cache-utils";

// Import service worker script version
importScripts("/swVersion.js");

const sw = self as unknown as CustomServiceWorkerGlobalScope;

// Initialize cache name with version
sw.fileCacheName = `sw-file-cache-${sw.swVersion}-${CACHE_VERSION}`;

// Load required scripts with hash versioning
const swDepsInFiles = sw.files["sw-deps.js"].split(".");
swDepsInFiles.pop(); // js
const hash = swDepsInFiles.pop(); // hash

const transpileWorker = sw.files["@/workers/transpile.worker.js"].split(".");
transpileWorker.pop(); // js
const transpileWorkerHash = transpileWorker.pop(); // hash

importScripts(
  "/@/workers/transpile.worker.js" + "?hash=" + transpileWorkerHash,
  "/sw-deps.js" + "?hash=" + hash,
);

// Initialize handlers
const handlers = new ServiceWorkerHandlers(sw);

// Register event handlers
sw.addEventListener("install", (event) => {
  event.waitUntil(handlers.handleInstall());
});

sw.addEventListener("activate", (event) => {
  event.waitUntil(handlers.handleActivate());
});

sw.addEventListener("fetch", (event) => {
  handlers.handleFetch(event);
});

```

# src/swUtils.ts

```ts
async function testRegistration() {
  if ("serviceWorker" in navigator) {
    try {
      const registration = await navigator.serviceWorker.register("/sw.js");
      console.log("SW registered:", registration);

      await new Promise<void>((resolve) => {
        if (registration.installing) {
          registration.installing.addEventListener("statechange", (e) => {
            if (e.target && (e.target as ServiceWorker).state === "activated") {
              console.log("SW activated");
              resolve();
            }
          });
        } else {
          resolve();
        }
      });
    } catch (error) {
      console.error("SW registration failed:", error);
    }
  }
}

// 2. Caching Behavior
async function testCaching(swVersion: string) {
  const cacheName = "file-cache-" + swVersion;
  const cache = await caches.open(cacheName);
  const cachedResponses = await cache.matchAll();
  console.log("Cached resources:", cachedResponses.map((r) => r.url));

  // Test offline functionality
  await new Promise<void>((resolve) => {
    const iframe = document.createElement("iframe");
    iframe.src = "/some-cached-page";
    iframe.onload = () => {
      console.log("Page loaded from cache while offline");
      document.body.removeChild(iframe);
      resolve();
    };
    document.body.appendChild(iframe);
  });
}

// 3. Update Mechanism
async function testUpdate() {
  const registration = await navigator.serviceWorker.getRegistration();
  if (registration) {
    registration.addEventListener("updatefound", () => {
      console.log("New SW version found");
      const newWorker = registration.installing;
      if (newWorker) {
        newWorker.addEventListener("statechange", (e: Event) => {
          const target = e.target as ServiceWorker;
          if (target.state === "installed") {
            console.log("New SW installed and will activate on next load");
          }
        });
      }
    });

    // Trigger an update check
    await registration.update();
  }
}

// 4. Performance Monitoring
async function testPerformance() {
  const cachedUrl = "/some-cached-resource";
  const uncachedUrl = "/some-uncached-resource";

  async function timeRequest(url: string) {
    const start = performance.now();
    await fetch(url);
    return performance.now() - start;
  }

  const cachedTime = await timeRequest(cachedUrl);
  const uncachedTime = await timeRequest(uncachedUrl);

  console.log(`Cached resource load time: ${cachedTime}ms`);
  console.log(`Uncached resource load time: ${uncachedTime}ms`);
}

export async function deleteAllServiceWorkers() {
  if ("serviceWorker" in navigator) {
    try {
      const cacheNames = await caches.keys();
      const fileCaches = cacheNames.filter((cacheName) => cacheName.startsWith("file-cache-"));
      const currentCache = "file-cache-" + swVersion;
      const isCurrentFilesInCache = fileCaches.includes(currentCache);
      if (isCurrentFilesInCache) {
        try {
          const deleteCachePromises = fileCaches.filter((cacheName) => cacheName !== currentCache)
            .map(
              (cacheName) => caches.delete(cacheName),
            );

          // Wait for all cache delete operations to complete
          await Promise.allSettled(deleteCachePromises);

          console.log("All caches have been cleared.");
        } catch (error) {
          console.error("Error during cache cleanup:", error);
        }
      }

      // Get all service worker registrations
      const registrations = await navigator.serviceWorker.getRegistrations();

      // Unregister each service worker
      const unregisterPromises = registrations.map((registration) => {
        if (registration.active && !isCurrentFilesInCache) {
          registration.unregister();
        }

        if (registration.waiting && isCurrentFilesInCache) {
          return registration.waiting.postMessage("skipWaiting");
        }
      });

      // Wait for all unregister operations to complete
      await Promise.all(unregisterPromises);

      console.log("All Service Workers have been unregistered.");

      console.log(
        "Service Worker cleanup complete. You may need to reload the page or close all tabs of this site for changes to take full effect.",
      );
    } catch (error) {
      console.error("Error during Service Worker cleanup:", error);
    }
  } else {
    console.log("Service Workers are not supported in this browser.");
  }
}

export async function runTests(swVersion: string) {
  await testRegistration();
  await testCaching(swVersion);
  await testUpdate();
  await testPerformance();
}

```

# src/swVersion.ts

```ts
export const swVersion = "localTests";

```

# src/transpile.ts

```ts
export { build, transpile, wasmFile } from "@/lib/transpile";

```

# src/types/langraph.ts

```ts
import { AIMessage } from "@langchain/core/messages";
import {
  RunnableConfig,
  RunnableInterface
} from "@langchain/core/runnables";
import { AgentState } from "./workflow-types";
import { StateGraph } from "@langchain/langgraph/web";

/**
 * Interface for iterable readable stream
 */
interface IterableReadableStreamInterface<T> extends AsyncIterable<T> {
  getReader(): {
    read: () => Promise<{ done: boolean; value: T | undefined }>;
    releaseLock: () => void;
  };
}

/**
 * Create an iterable readable stream from an async value
 */
async function createIterableStream<T>(getValue: () => Promise<T>): Promise<IterableReadableStreamInterface<T>> {
  let value: T;
  return {
    [Symbol.asyncIterator]: async function* () {
      if (!value) {
        value = await getValue();
      }
      yield value;
    },
    getReader() {
      let consumed = false;
      return {
        read: async () => {
          if (consumed) {
            return { done: true, value: undefined };
          }
          consumed = true;
          if (!value) {
            value = await getValue();
          }
          return { done: false, value };
        },
        releaseLock() {}
      };
    }
  };
}

/**
 * Node state and update types
 */
export type NodeState = AgentState;
export type NodeUpdate = Partial<AgentState>;

/**
 * Configuration for workflow nodes
 */
export interface NodeConfig extends RunnableConfig {
  configurable: { thread_id: string };
}

/**
 * Interface for workflow graph nodes
 */
export interface WorkflowNode {
  invoke: (state: NodeState, config?: NodeConfig) => Promise<NodeUpdate>;
  lc_namespace: string[];
  lc_serializable: boolean;
  batch: (states: NodeState[]) => Promise<NodeUpdate[]>;
  stream: (
    input: NodeState,
    options?: Partial<NodeConfig>
  ) => Promise<IterableReadableStreamInterface<NodeUpdate>>;
  transform: (input: AsyncGenerator<unknown>) => AsyncGenerator<NodeState>;
  getName(): string;
  lc_id: string[];
  getRuntimeEnvironment(): Record<string, unknown>;
}

/**
 * Create a workflow node with LangGraph compatibility
 */
export function createNode(
  name: string,
  processFunc: (state: NodeState) => Promise<NodeUpdate>
): WorkflowNode {
  return {
    invoke: processFunc,
    lc_namespace: ["langchain", "graph"],
    lc_serializable: true,
    batch: async (states: NodeState[]) => Promise.all(states.map(processFunc)),
    stream: async (input: NodeState) => {
      return createIterableStream(() => processFunc(input));
    },
    transform: async function* (generator: AsyncGenerator<unknown>) {
      for await (const value of generator) {
        yield value as NodeState;
      }
    },
    getName: () => name,
    lc_id: [name],
    getRuntimeEnvironment: () => ({})
  };
}

/**
 * Type for compiled workflow graph
 */
export interface CompiledGraph {
  invoke: (
    state: NodeState,
    options?: Partial<NodeConfig>
  ) => Promise<NodeState>;
}

/**
 * Default state initialization
 */
export const createInitialState = (): NodeState => ({
  messages: [],
  codeSpace: '',
  origin: '',
  code: undefined,
  lastError: undefined,
  isStreaming: false,
  documentHash: undefined,
  filePath: undefined
});

```

# src/types/workflow-types.ts

```ts
import { AIMessage } from "@langchain/core/messages";

export interface AgentState {
  messages: AIMessage[];
  code?: string;
  origin: string;
  codeSpace: string;
  lastError?: string;
  documentHash?: string;
  filePath?: string;
  isStreaming?: boolean;
}

export type WorkflowContinueResult = "process" | "tools" | "end";

export type CompiledWorkflow = {
  invoke: (state: AgentState, config: { configurable: { thread_id: string } }) => Promise<AgentState>;
};

export interface WorkflowHandler {
  processMessage: (state: AgentState) => Promise<Partial<AgentState>>;
  shouldContinue: (state: AgentState) => Promise<WorkflowContinueResult>;
}

export interface WorkflowChannels {
  messages: { reducer: (prev: AIMessage[], next: AIMessage[]) => AIMessage[] };
  codeSpace: { reducer: (prev: string, next: string) => string };
  origin: { reducer: (prev: string, next: string) => string };
  code: { reducer: (prev: string, next: unknown) => string };
  lastError: { reducer: (prev: string, next: unknown) => string };
  isStreaming: { reducer: (prev: boolean, next: boolean) => boolean };
  documentHash: { reducer: (prev: string | undefined, next: string) => string };
  filePath: { reducer: (prev: string | undefined, next: string | undefined) => string | undefined };
}

```

# src/unpkg-path-plugin.tsx

```tsx
import type * as esbuild from "esbuild-wasm";

export const unpkgPathPlugin = (origin: string) => ({
  name: "unpkg-path-plugin",
  setup(build: esbuild.PluginBuild) {
    // handle rel paths in module :  includes ./ || ../
    build.onResolve({ filter: /^\.+\// }, (args: { path: string; }) => {
      const url = new URL(args.path, location.origin).toString();

      return {
        path: url,
        namespace: "http-url",
      };
    });

    build.onResolve({ filter: /^\[a-z]+\// }, (args: { path: string; }) => {
      if (args.path.indexOf(origin) !== -1) {
        return {
          namespace: "http-url",
          path: args.path,
        };
      }

      return {
        path: args.path,
        namespace: "http-url",
      };
    });
  },
});

```

# src/utils/code-analysis.ts

```ts
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import * as t from '@babel/types';
import { codeAnalysisCache } from '../lib/caching';

// Helper type for semantic diff to handle nullable component names
type ComponentMetadata = Omit<CodeAnalysis, 'componentName'> & {
  componentName: string;
};

export interface CodeAnalysis {
  componentName: string | null;
  hooks: string[];
  props: string[];
  imports: string[];
  state: {
    variables: string[];
    setters: string[];
  };
  styling: {
    type: 'css' | 'tailwind' | 'styled-components' | 'emotion' | 'inline' | 'unknown';
    classes: string[];
  };
  functions: {
    name: string;
    params: string[];
    isAsync: boolean;
  }[];
}

/**
 * Analyze React component code to extract key information
 */
function createEmptyAnalysis(): CodeAnalysis {
  return {
    componentName: null,
    hooks: [],
    props: [],
    imports: [],
    state: {
      variables: [],
      setters: [],
    },
    styling: {
      type: 'unknown',
      classes: [],
    },
    functions: [],
  };
}

export function analyzeReactCode(code: string): CodeAnalysis {
  // Check cache first
  if (!code) return createEmptyAnalysis();

  const cacheKey = code;
  const cached = codeAnalysisCache.get(cacheKey);
  if (cached) {
    return cached;
  }

  const analysis = createEmptyAnalysis();

  try {
    const ast = parse(code, {
      sourceType: 'module',
      plugins: ['jsx', 'typescript'],
    });

    // Visitor for AST traversal
    traverse(ast, {
      // Find imports
      ImportDeclaration(path) {
        analysis.imports.push(path.node.source.value);

        // Detect styling approach
        const importPath = path.node.source.value;
        if (importPath.includes('tailwind')) {
          analysis.styling.type = 'tailwind';
        } else if (importPath.includes('styled-components')) {
          analysis.styling.type = 'styled-components';
        } else if (importPath.includes('@emotion')) {
          analysis.styling.type = 'emotion';
        }
      },

      // Find component declaration
      ExportDefaultDeclaration(path) {
        if (t.isFunctionDeclaration(path.node.declaration) && path.node.declaration.id) {
          analysis.componentName = path.node.declaration.id.name;
        } else if (t.isIdentifier(path.node.declaration)) {
          analysis.componentName = path.node.declaration.name;
        }
      },

      // Find function components
      FunctionDeclaration(path) {
        if (path.node.id) {
          const name = path.node.id.name;
          const params = path.node.params.map(param => {
            if (t.isIdentifier(param)) return param.name;
            if (t.isObjectPattern(param)) {
              return param.properties
                .map(prop => {
                  if (t.isObjectProperty(prop) && t.isIdentifier(prop.key)) {
                    analysis.props.push(prop.key.name);
                    return prop.key.name;
                  }
                  return '';
                })
                .filter(Boolean)
                .join(', ');
            }
            return '';
          });

          analysis.functions.push({
            name,
            params,
            isAsync: path.node.async,
          });
        }
      },

      // Find hooks usage
      CallExpression(path) {
        if (t.isIdentifier(path.node.callee) && path.node.callee.name.startsWith('use')) {
          const hookName = path.node.callee.name;
          if (!analysis.hooks.includes(hookName)) {
            analysis.hooks.push(hookName);
          }

          // Extract state variables from useState
          if (hookName === 'useState' && t.isArrayPattern(path.parent)) {
            const [stateVar, setterVar] = path.parent.elements;
            if (t.isIdentifier(stateVar) && t.isIdentifier(setterVar)) {
              analysis.state.variables.push(stateVar.name);
              analysis.state.setters.push(setterVar.name);
            }
          }
        }
      },

      // Find JSX class names for styling analysis
      JSXAttribute(path) {
        if (t.isJSXIdentifier(path.node.name)) {
          if (path.node.name.name === 'className' && t.isStringLiteral(path.node.value)) {
            const classes = path.node.value.value.split(' ');
            analysis.styling.classes.push(...classes);

            // Detect Tailwind usage
            if (classes.some(cls => /^(bg-|text-|p-|m-|flex|grid|w-|h-)/.test(cls))) {
              analysis.styling.type = 'tailwind';
            }
          } else if (path.node.name.name === 'css') {
            analysis.styling.type = 'emotion';
          } else if (path.node.name.name === 'style') {
            analysis.styling.type = 'inline';
          }
        }
      },
    });

    // Cache the results
    codeAnalysisCache.set(code, analysis);

    return analysis;
  } catch (error) {
    console.error('Failed to analyze React code:', error);
    return analysis;
  }
}

/**
 * Generate a semantic diff between two versions of a component
 */
export function generateSemanticDiff(originalCode: string, modifiedCode: string) {
  // Get analysis and ensure component names are present
  const original = analyzeReactCode(originalCode);
  const modified = analyzeReactCode(modifiedCode);

  if (!original.componentName || !modified.componentName) {
    throw new Error('Unable to analyze component name');
  }

  // Cast to type without null since we've verified component names
  const originalMeta = original.componentName ? {
    ...original,
    componentName: original.componentName
  } : null;

  const modifiedMeta = modified.componentName ? {
    ...modified,
    componentName: modified.componentName
  } : null;

  if (!originalMeta || !modifiedMeta) {
    throw new Error('Unable to analyze component name');
  }

  return {
    componentRenamed: originalMeta.componentName !== modifiedMeta.componentName,
    addedHooks: modifiedMeta.hooks.filter(h => !originalMeta.hooks.includes(h)),
    removedHooks: originalMeta.hooks.filter(h => !modifiedMeta.hooks.includes(h)),
    addedProps: modified.props.filter(p => !original.props.includes(p)),
    removedProps: original.props.filter(p => !modified.props.includes(p)),
    addedImports: modified.imports.filter(i => !original.imports.includes(i)),
    removedImports: original.imports.filter(i => !modified.imports.includes(i)),
    stateChanges: {
      added: modified.state.variables.filter(v => !original.state.variables.includes(v)),
      removed: original.state.variables.filter(v => !modified.state.variables.includes(v)),
    },
    stylingChanges: {
      typeChanged: original.styling.type !== modified.styling.type,
      addedClasses: modified.styling.classes.filter(c => !original.styling.classes.includes(c)),
      removedClasses: original.styling.classes.filter(c => !modified.styling.classes.includes(c)),
    },
  };
}

/**
 * Check if code changes maintain semantic integrity
 */
export function verifySemanticIntegrity(originalCode: string, modifiedCode: string): { 
  valid: boolean;
  reason?: string;
} {
  try {
    const diff = generateSemanticDiff(originalCode, modifiedCode);

    // Critical changes that could break the component
    if (diff.componentRenamed) {
      return {
        valid: false,
        reason: `Component name changed from ${analyzeReactCode(originalCode).componentName || 'unknown'} to ${analyzeReactCode(modifiedCode).componentName || 'unknown'}`,
      };
    }

    const criticalImportsRemoved = diff.removedImports.filter(imp => 
      imp.startsWith('.') || // Internal project imports
      imp.includes("'") || // Aliased internal imports
      /^react(-dom)?$/.test(imp) // React core imports
    );

    if (criticalImportsRemoved.length > 0) {
      return {
        valid: false,
        reason: `Critical imports removed: ${criticalImportsRemoved.join(', ')}`,
      };
    }

    // Check for potentially breaking changes
    const breakingChanges = [];

    if (diff.removedProps.length > 0) {
      breakingChanges.push(`Props removed: ${diff.removedProps.join(', ')}`);
    }

    if (diff.removedHooks.length > 0) {
      breakingChanges.push(`Hooks removed: ${diff.removedHooks.join(', ')}`);
    }

    if (diff.stateChanges.removed.length > 0) {
      breakingChanges.push(`State variables removed: ${diff.stateChanges.removed.join(', ')}`);
    }

    if (breakingChanges.length > 0) {
      return {
        valid: false,
        reason: `Potentially breaking changes detected:\n${breakingChanges.join('\n')}`,
      };
    }

    return { valid: true };
  } catch (error) {
    console.error('Error in semantic integrity check:', error);
    return { 
      valid: false,
      reason: 'Failed to analyze code integrity',
    };
  }
}

```

# src/utils/contextUtils.ts

```ts
// contextUtils.ts

export function extractCurrentTask(aiResponse: string): string {
  const taskMatch = aiResponse.match(/Current task: (.*)/);
  return taskMatch ? taskMatch[1] : "";
}

export function extractCodeStructure(code: string): string {
  // This is a basic implementation. You might want to enhance this
  // to provide a more detailed code structure analysis.
  const lines = code.split("\n");
  const structure = lines
    .filter((line) => /^(class|function|const|let|var|import|export)/.test(line.trim()))
    .map((line) => line.trim())
    .join("\n");
  return structure;
}

```

# src/utils/extractArtifacts.ts

```ts
interface Artifact {
  identifier: string;
  type: string;
  language: string;
  title: string;
  content: string;
}

export const extractArtifacts = (content: string): Artifact[] => {
  const artifactRegex =
    /<antArtifact\s+identifier="([^"]+)"\s+type="([^"]+)"\s+language="([^"]+)"\s+title="([^"]+)">([\s\S]*?)<\/antArtifact>/g;
  const extractedArtifacts: Artifact[] = [];
  let match;

  while ((match = artifactRegex.exec(content)) !== null) {
    extractedArtifacts.push({
      identifier: match[1],
      type: match[2],
      language: match[3],
      title: match[4],
      content: match[5].trim(),
    });
  }

  return extractedArtifacts;
};

```

# src/utils/getParts.ts

```ts

```

# src/utils/mineCss.ts

```ts
import type { EmotionCache } from "@emotion/cache";

/**
 * Extracts CSS styles from various sources in the document.
 * @param cache - The Emotion cache object.
 * @param html - The HTML string of the document.
 * @returns A string containing the extracted CSS styles.
 */
function mineFromCaches(cache: EmotionCache): string[] {
  const key = cache.key || "css";

  try {
    return [...extractStylesFromDOM(key), ...extractStylesFromStylesheets(key)];
  } catch (error) {
    console.warn(
      "Failed to extract styles from DOM, falling back to stylesheet parsing:",
      error,
    );
    return extractStylesFromStylesheets(key);
  }
}

/**
 * Extracts styles from DOM elements.
 * @param key - The Emotion key to look for.
 * @returns A string of concatenated styles.
 */
function extractStylesFromDOM(key: string): string[] {
  const styledJSXStyles = getStyledJSXStyles();
  const emotionStyles = getEmotionStyles(key);
  return styledJSXStyles.concat(emotionStyles);
}

/**
 * Gets styled-jsx styles from the DOM.
 * @returns An array of style contents.
 */
function getStyledJSXStyles(): string[] {
  return Array.from(
    document.querySelectorAll("style[data-styled-jsx]"),
  ).map((style) => style.textContent || "");
}

/**
 * Gets Emotion styles from the DOM.
 * @param key - The Emotion key to look for.
 * @returns A string of concatenated unique styles.
 */
function getEmotionStyles(key: string): string[] {
  const styles = Array.from(
    document.querySelectorAll(`style[data-emotion="${key}"]`),
  ).map((style) => style.textContent || "");

  return Array.from(new Set(styles));
}

/**
 * Extracts styles from stylesheets when DOM extraction fails.
 * @param key - The Emotion key to look for.
 * @param html - The HTML string of the document.
 * @returns A string of concatenated styles.
 */
function extractStylesFromStylesheets(key: string): string[] {
  try {
    return [
      ...new Set([
        ...Array.from(document.styleSheets)
          .map((sheet) => {
            try {
              return Array.from(sheet.cssRules).map((x) => x.cssText).filter(
                (x) => x.includes(key),
              );
            } catch (e) {
              console.log(e);
              return [];
            }
          }).flat(),
      ]),
    ];
  } catch (error) {
    console.warn("Failed to extract styles from stylesheets:", error);
    return [];
  }
}

export { mineFromCaches };

```

# src/utils/retry.ts

```ts
/**
 * Error types that are safe to retry
 */
export const RETRYABLE_ERRORS = [
  "ECONNRESET",
  "ETIMEDOUT",
  "ECONNABORTED",
  "RATE_LIMIT_EXCEEDED",
  "429",
  "500",
  "503",
] as const;

export interface RetryOptions {
  maxRetries?: number;
  initialDelay?: number;
  maxDelay?: number;
  retryableErrors?: string[];
  onRetry?: (attempt: number, error: Error, nextDelay: number) => void;
}

/**
 * Generic retry function with exponential backoff
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const {
    maxRetries = 3,
    initialDelay = 1000,
    maxDelay = 10000,
    retryableErrors = RETRYABLE_ERRORS,
    onRetry = (attempt, error, delay) =>
      console.warn(
        `Retry ${attempt}/${maxRetries} after error: ${error.message}. Next attempt in ${delay}ms`
      )
  } = options;

  let attempt = 0;
  let delay = initialDelay;

  while (true) {
    try {
      return await fn();
    } catch (error) {
      attempt++;
      
      if (!(error instanceof Error) ||
          attempt >= maxRetries ||
          !retryableErrors.some(e => error.message.includes(e))) {
        throw error;
      }

      onRetry(attempt, error, delay);
      await new Promise(resolve => setTimeout(resolve, delay));
      
      // Exponential backoff with max delay cap
      delay = Math.min(delay * 2, maxDelay);
    }
  }
}

/**
 * Helper to determine if an error should be retried
 */
export function isRetryableError(error: unknown): boolean {
  return error instanceof Error &&
    RETRYABLE_ERRORS.some(e => error.message.includes(e));
}

```

# src/utils/types.ts

```ts
export type LanguageMap = Record<string, string>;

```

# src/utils/versionHistoryUtils.ts

```ts
// src/utils/versionHistoryUtils.ts

// This file is now empty as all functions have been moved to src/codeHistoryUtils.ts

```

# src/ws.ts

```ts
import { CodeSessionBC } from "./services/CodeSessionBc";
import { RenderService } from "./services/render/RenderService";
import type { IWebSocketManager, WebSocketDependencies } from "./services/websocket/types";
import { WebSocketManager } from "./services/websocket/WebSocketManager";
import { ServiceWorkerManager } from "./services/worker/ServiceWorkerManager";

export const main = async (codeSpace: string) => {
  try {
    const renderService = new RenderService(codeSpace);
    // const cSess = new Code(codeSpace);
    // await cSess.init();
    const codeSessionBC = new CodeSessionBC(codeSpace);

    const websocketDependencies: WebSocketDependencies = {
      codeSessionBC,
      messageHandler: {
        handleRunMessage: async (transpiled: string) => {
          try {
            if (window.self !== window.parent) {
              return await renderService.handleRender(
                await renderService.updateRenderedApp({ transpiled }),
              );
            } else {
              console.warn(
                "Not in iframe: skipping code processing to prevent main window re-render.",
              );
              const { css, html } = codeSessionBC.session ||
                await codeSessionBC.init();
              return Promise.resolve({
                css,
                html,
              });
            }
          } catch (error) {
            console.error("Error handling run message:", error);
            return false;
          }
        },
        handleMessage: (event) => {
          console.log("Message received:", event);
          return Promise.resolve({ success: true });
        },
        cleanup: () => {
          console.log("Cleaning up message handler");
        },
      },

      serviceWorker: new ServiceWorkerManager(),
    };

    const webSocketManager = new WebSocketManager(websocketDependencies, {
      maxRetries: 3,
      retryDelay: 1000,
      connectionTimeout: 5000,
    });
    await webSocketManager.init();

    Object.assign(window, { webSocketManager });

    return webSocketManager;
  } catch (error) {
    console.error("Error in main function:", error);
    throw error;
  }
};

// Export for global access

export const testHandleRunMessage = async (
  transpiled: string,
  webSocketManager: IWebSocketManager,
) => {
  if (window.self !== window.parent) {
    return await webSocketManager.handleRunMessage(transpiled);
  } else {
    console.warn(
      "Not in iframe: skipping code processing to prevent main window re-render.",
    );
    return false;
  }
};

```

# tsconfig.app.json

```json
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "forceConsistentCasingInFileNames": true,
    "composite": true,
    "declaration": true,
    "declarationDir": "./dts",
    "outDir": "./dts",
    "emitDeclarationOnly": true,
    "isolatedModules": true,
    "noEmit": false,
    "paths": {
      "@/*": ["./src/@/*"]
    },
    "types": ["vite/client"],
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "moduleDetection": "force",
    "jsxImportSource": "@emotion/react",
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": [
    "node_modules",
    "dts",
    "**/*.spec.ts",
    "**/*.test.ts",
    "**/*.spec.tsx",
    "**/*.test.tsx",
    "src/routes/__tests__/*"
  ]
}

```

# tsconfig.node.json

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/@/*"]
    },
    "target": "ES2022",
    "forceConsistentCasingInFileNames": true,
    "lib": ["ESNext", "DOM"],
    "module": "ESNext",
    "skipLibCheck": true,
    "outDir": "dist",
    "composite": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "declaration": true,
    "declarationDir": "./dts",
    "emitDeclarationOnly": true,
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["vite.config.ts", "src/@/lib/importmap-utils.ts"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"]
}

```

# tsconfig.spec.json

```json
{
  "extends": "./tsconfig.json",
  "include": [
    "src/**/*.ts",
    "src/**/*.tsx",
    "src/**/*.spec.ts",
    "src/**/*.spec.tsx",
    "src/**/*.test.ts",
    "src/**/*.test.tsx",
    "src/__tests__/**/*.test.ts",
    "src/__tests__/**/*.test.tsx"
  ],
  "exclude": ["node_modules", "dts"],
  "compilerOptions": {
    "types": ["vitest/globals"],
    "noEmit": true
  }
}

```

# twConf.ts

```ts
import config from "./tailwind.config.ts";

const tailwind = {
  config,
};
Object.assign(window, { tailwind });

```

# vite.config.ts

```ts
import tailwindcss from "@tailwindcss/vite";
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import react from "@vitejs/plugin-react-swc";
import fs from "fs";
import path from "path";
import { AppType, defineConfig, ProxyOptions } from "vite";
import { importMap } from "./src/@/lib/importmap-utils";

/* ========================================================
   Utility: Get external files with proper extension
   */
const getExternalFiles = (dir: string) => {
  const directoryPath = path.resolve(__dirname, `./src/${dir}`);
  return fs.readdirSync(directoryPath).map((filename) => {
    // Use path.parse for clearer filename handling
    const { name } = path.parse(filename);
    // If the filename includes "worker", use .js; otherwise, .mjs
    const extension = "mjs"; // filename.includes("worker") ? "js" : "mjs";
    return { type: "external", file: `/${dir}/${name}.${extension}` };
  });
};

/* ========================================================
   Build external file list and alias mappings
   ======================================================== */
const externalDirs = ["@/workers", "@/external"];
const externalFiles = externalDirs.map(getExternalFiles).flat();

const createExternalAliases = (
  files: Array<{ file: string; }>,
  isBuild = true,
): Record<string, string> =>
  files.reduce<Record<string, string>>((aliases, { file }) => {
    // Remove the extension from the file path
    const aliasKey = file.replace(/\.[^.]+$/, "").replace(/^\/@\//, "@/");
    if (isBuild) {
      aliases[aliasKey] = `/${aliasKey}.mjs`;
      // if (file.includes("worker")) {
      //   aliases[aliasKey] = `/${aliasKey}.js`;
      // }
    }
    return aliases;
  }, {});

/* ========================================================
   (Optional) Utility: Create proxy config from importMap
   ======================================================== */
// const createImportMapProxy = (imports: Record<string, string>): Record<string, ProxyOptions> => {
//   const proxy: Record<string, ProxyOptions> = {};
//   for (const [key, value] of Object.entries(imports)) {
//     proxy[key] = {
//       target: `https://testing.spike.land${value}`,
//       changeOrigin: true,
//       rewrite: (url: string) => url.replace(key, ""),
//     };
//   }
//   return proxy;
// };
// const importMapProxy = createImportMapProxy(importMap.imports);

/* ========================================================
   Vite Configuration
   ======================================================== */
export default defineConfig((config) => {
  const isBuild = config.command === "build";
  console.log("Building:", { config, isBuild });

  const externalAliases = createExternalAliases(externalFiles, isBuild);

  // Merge importMap aliases into our externalAliases
  if (isBuild) Object.assign(externalAliases, importMap.imports);

  // Rollup external files (values of our alias mapping)
  const rollupExternal = isBuild
    ? [
      ...Object.values(externalAliases),
    ]
    : [];

  // Server proxy configuration
  const proxyConfig: Record<string, ProxyOptions> = {
    "^/live/.*/": {
      target: "https://testing.spike.land/live",
      changeOrigin: true,
      rewrite: (url: string) => {
        console.log("Proxying path:", url);
        return url.replace(/^\/live/, "");
      },
    },
    "/sw.js": {
      target: "https://testing.spike.land/sw.js",
      changeOrigin: true,
    },
    "/swVersion.mjs": {
      target: "https://testing.spike.land/swVersion.mjs",
      changeOrigin: true,
      rewrite: (url: string) => url.replace(/^\/swVersion.mjs/, ""),
    },
  };

  // Include additional proxy only when building, if needed
  if (!isBuild) {
    proxyConfig["/@"] = {
      target: "https://testing.spike.land/@",
      changeOrigin: true,
      rewrite: (url: string) => url.replace(/^\/@/, ""),
    };
  }

  return {
    plugins: [
      TanStackRouterVite(),
      // Uncomment the visualizer if you need bundle analysis:
      // visualizer({
      //   open: true,
      //   filename: "dist/stats.html",
      // }),
      tailwindcss(),
      react({ jsxImportSource: "@emotion/react" }),
    ],
    experimental: {
      skipSsrTransform: true,
    },
    build: {
      rollupOptions: {
        external: rollupExternal,
      },
      outDir: "dist-vite",
    },
    appType: "spa" as AppType,
    assetsInclude: [],
    server: {
      proxy: proxyConfig,
    },
    resolve: {
      alias: {
        ...externalAliases,
        "@": path.resolve(__dirname, "./src/@"),
      },
    },
  };
});

```

# vitest.config.ts

```ts
/// <reference types="vitest" />

import react from "@vitejs/plugin-react-swc";
import { resolve } from "path";
import { defineConfig } from "vitest/config";

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: "jsdom",
    setupFiles: ["./src/setupTests.ts"],
    include: ["src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}"],
    alias: {
      "@": resolve(__dirname, "./src/@"),
    },
  },
});

```

