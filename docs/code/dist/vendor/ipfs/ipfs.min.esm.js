var ze = (E, m) => () => (m || (m = { exports: {} }, E(m.exports, m)), m.exports), Fe = ze((exports, module) => {
    !function (E, m) { typeof exports == "object" && typeof module == "object" ? module.exports = m() : typeof define == "function" && define.amd ? define([], m) : typeof exports == "object" ? exports.IpfsCore = m() : E.IpfsCore = m(); }(self, function () {
        return function (E) { var m = {}; function f(d) { if (m[d])
            return m[d].exports; var r = m[d] = { i: d, l: !1, exports: {} }; return E[d].call(r.exports, r, r.exports, f), r.l = !0, r.exports; } return f.m = E, f.c = m, f.d = function (d, r, e) { f.o(d, r) || Object.defineProperty(d, r, { enumerable: !0, get: e }); }, f.r = function (d) { typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 }); }, f.t = function (d, r) { if (1 & r && (d = f(d)), 8 & r)
            return d; if (4 & r && typeof d == "object" && d && d.__esModule)
            return d; var e = Object.create(null); if (f.r(e), Object.defineProperty(e, "default", { enumerable: !0, value: d }), 2 & r && typeof d != "string")
            for (var c in d)
                f.d(e, c, function (n) { return d[n]; }.bind(null, c)); return e; }, f.n = function (d) { var r = d && d.__esModule ? function () { return d.default; } : function () { return d; }; return f.d(r, "a", r), r; }, f.o = function (d, r) { return Object.prototype.hasOwnProperty.call(d, r); }, f.p = "", f(f.s = 391); }([function (E, m, f) {
                "use strict";
                function d(r, e) { for (const c in e)
                    Object.defineProperty(r, c, { value: e[c], enumerable: !0, configurable: !0 }); return r; }
                E.exports = function (r, e, c) { if (!r || typeof r == "string")
                    throw new TypeError("Please pass an Error to err-code"); c || (c = {}), typeof e == "object" && (c = e, e = void 0), e != null && (c.code = e); try {
                    return d(r, c);
                }
                catch (n) {
                    c.message = r.message, c.stack = r.stack;
                    const t = function () { };
                    return t.prototype = Object.create(Object.getPrototypeOf(r)), d(new t, c);
                } };
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.formatArgs = function (e) { if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + E.exports.humanize(this.diff), !this.useColors)
                    return; const c = "color: " + this.color; e.splice(1, 0, c, "color: inherit"); let n = 0, t = 0; e[0].replace(/%[a-zA-Z%]/g, s => { s !== "%%" && (n++, s === "%c" && (t = n)); }), e.splice(t, 0, c); }, m.save = function (e) { try {
                    e ? m.storage.setItem("debug", e) : m.storage.removeItem("debug");
                }
                catch (c) { } }, m.load = function () { let e; try {
                    e = m.storage.getItem("debug");
                }
                catch (c) { } return !e && d !== void 0 && "env" in d && (e = { NODE_ENV: "production" }.DEBUG), e; }, m.useColors = function () { return typeof window != "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/); }, m.storage = function () { try {
                    return localStorage;
                }
                catch (e) { } }(), m.destroy = (() => { let e = !1; return () => { e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")); }; })(), m.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], m.log = console.debug || console.log || (() => { }), E.exports = f(525)(m); const { formatters: r } = E.exports; r.j = function (e) { try {
                    return JSON.stringify(e);
                }
                catch (c) {
                    return "[UnexpectedJSONParseError]: " + c.message;
                } }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                const d = f(249), { anySignal: r } = f(137), e = f(153).default, { TimeoutError: c } = f(524);
                E.exports = function (n, t) { return (...s) => { const u = s[t !== null && t !== void 0 ? t : s.length - 1]; if (!u || !u.timeout)
                    return n(...s); const i = typeof u.timeout == "string" ? e(u.timeout) : u.timeout, o = new d(i); u.signal = r([u.signal, o.signal]); const h = n(...s), a = new Promise((g, b) => { o.signal.addEventListener("abort", () => { b(new c); }); }), l = Date.now(), p = () => { if (o.signal.aborted)
                    throw new c; if (Date.now() - l > i)
                    throw o.abort(), new c; }; return h[Symbol.asyncIterator] ? async function* () { const g = h[Symbol.asyncIterator](); try {
                    for (;;) {
                        const { value: b, done: I } = await Promise.race([g.next(), a]);
                        if (I)
                            break;
                        p(), yield b;
                    }
                }
                catch (b) {
                    throw p(), b;
                }
                finally {
                    o.clear(), g.return && g.return();
                } }() : (async () => { try {
                    const g = await Promise.race([h, a]);
                    return p(), g;
                }
                catch (g) {
                    throw p(), g;
                }
                finally {
                    o.clear();
                } })(); }; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(447), e = f(225), c = f(226); function n() { return s.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823; } function t(A, U) { if (n() < U)
                    throw new RangeError("Invalid typed array length"); return s.TYPED_ARRAY_SUPPORT ? (A = new Uint8Array(U)).__proto__ = s.prototype : (A === null && (A = new s(U)), A.length = U), A; } function s(A, U, z) { if (!(s.TYPED_ARRAY_SUPPORT || this instanceof s))
                    return new s(A, U, z); if (typeof A == "number") {
                    if (typeof U == "string")
                        throw new Error("If encoding is specified then the first argument must be a string");
                    return o(this, A);
                } return u(this, A, U, z); } function u(A, U, z, w) { if (typeof U == "number")
                    throw new TypeError('"value" argument must not be a number'); return typeof ArrayBuffer != "undefined" && U instanceof ArrayBuffer ? function (O, q, H, V) { if (q.byteLength, H < 0 || q.byteLength < H)
                    throw new RangeError("'offset' is out of bounds"); if (q.byteLength < H + (V || 0))
                    throw new RangeError("'length' is out of bounds"); return q = H === void 0 && V === void 0 ? new Uint8Array(q) : V === void 0 ? new Uint8Array(q, H) : new Uint8Array(q, H, V), s.TYPED_ARRAY_SUPPORT ? (O = q).__proto__ = s.prototype : O = h(O, q), O; }(A, U, z, w) : typeof U == "string" ? function (O, q, H) { if (typeof H == "string" && H !== "" || (H = "utf8"), !s.isEncoding(H))
                    throw new TypeError('"encoding" must be a valid string encoding'); var V = 0 | l(q, H), J = (O = t(O, V)).write(q, H); return J !== V && (O = O.slice(0, J)), O; }(A, U, z) : function (O, q) { if (s.isBuffer(q)) {
                    var H = 0 | a(q.length);
                    return (O = t(O, H)).length === 0 || q.copy(O, 0, 0, H), O;
                } if (q) {
                    if (typeof ArrayBuffer != "undefined" && q.buffer instanceof ArrayBuffer || "length" in q)
                        return typeof q.length != "number" || (V = q.length) != V ? t(O, 0) : h(O, q);
                    if (q.type === "Buffer" && c(q.data))
                        return h(O, q.data);
                } var V; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."); }(A, U); } function i(A) { if (typeof A != "number")
                    throw new TypeError('"size" argument must be a number'); if (A < 0)
                    throw new RangeError('"size" argument must not be negative'); } function o(A, U) { if (i(U), A = t(A, U < 0 ? 0 : 0 | a(U)), !s.TYPED_ARRAY_SUPPORT)
                    for (var z = 0; z < U; ++z)
                        A[z] = 0; return A; } function h(A, U) { var z = U.length < 0 ? 0 : 0 | a(U.length); A = t(A, z); for (var w = 0; w < z; w += 1)
                    A[w] = 255 & U[w]; return A; } function a(A) { if (A >= n())
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n().toString(16) + " bytes"); return 0 | A; } function l(A, U) { if (s.isBuffer(A))
                    return A.length; if (typeof ArrayBuffer != "undefined" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(A) || A instanceof ArrayBuffer))
                    return A.byteLength; typeof A != "string" && (A = "" + A); var z = A.length; if (z === 0)
                    return 0; for (var w = !1;;)
                    switch (U) {
                        case "ascii":
                        case "latin1":
                        case "binary": return z;
                        case "utf8":
                        case "utf-8":
                        case void 0: return $(A).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le": return 2 * z;
                        case "hex": return z >>> 1;
                        case "base64": return y(A).length;
                        default:
                            if (w)
                                return $(A).length;
                            U = ("" + U).toLowerCase(), w = !0;
                    } } function p(A, U, z) { var w = !1; if ((U === void 0 || U < 0) && (U = 0), U > this.length)
                    return ""; if ((z === void 0 || z > this.length) && (z = this.length), z <= 0)
                    return ""; if ((z >>>= 0) <= (U >>>= 0))
                    return ""; for (A || (A = "utf8");;)
                    switch (A) {
                        case "hex": return P(this, U, z);
                        case "utf8":
                        case "utf-8": return S(this, U, z);
                        case "ascii": return T(this, U, z);
                        case "latin1":
                        case "binary": return B(this, U, z);
                        case "base64": return N(this, U, z);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le": return L(this, U, z);
                        default:
                            if (w)
                                throw new TypeError("Unknown encoding: " + A);
                            A = (A + "").toLowerCase(), w = !0;
                    } } function g(A, U, z) { var w = A[U]; A[U] = A[z], A[z] = w; } function b(A, U, z, w, O) { if (A.length === 0)
                    return -1; if (typeof z == "string" ? (w = z, z = 0) : z > 2147483647 ? z = 2147483647 : z < -2147483648 && (z = -2147483648), z = +z, isNaN(z) && (z = O ? 0 : A.length - 1), z < 0 && (z = A.length + z), z >= A.length) {
                    if (O)
                        return -1;
                    z = A.length - 1;
                }
                else if (z < 0) {
                    if (!O)
                        return -1;
                    z = 0;
                } if (typeof U == "string" && (U = s.from(U, w)), s.isBuffer(U))
                    return U.length === 0 ? -1 : I(A, U, z, w, O); if (typeof U == "number")
                    return U &= 255, s.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? O ? Uint8Array.prototype.indexOf.call(A, U, z) : Uint8Array.prototype.lastIndexOf.call(A, U, z) : I(A, [U], z, w, O); throw new TypeError("val must be string, number or Buffer"); } function I(A, U, z, w, O) { var q, H = 1, V = A.length, J = U.length; if (w !== void 0 && ((w = String(w).toLowerCase()) === "ucs2" || w === "ucs-2" || w === "utf16le" || w === "utf-16le")) {
                    if (A.length < 2 || U.length < 2)
                        return -1;
                    H = 2, V /= 2, J /= 2, z /= 2;
                } function Z(it, st) { return H === 1 ? it[st] : it.readUInt16BE(st * H); } if (O) {
                    var tt = -1;
                    for (q = z; q < V; q++)
                        if (Z(A, q) === Z(U, tt === -1 ? 0 : q - tt)) {
                            if (tt === -1 && (tt = q), q - tt + 1 === J)
                                return tt * H;
                        }
                        else
                            tt !== -1 && (q -= q - tt), tt = -1;
                }
                else
                    for (z + J > V && (z = V - J), q = z; q >= 0; q--) {
                        for (var nt = !0, rt = 0; rt < J; rt++)
                            if (Z(A, q + rt) !== Z(U, rt)) {
                                nt = !1;
                                break;
                            }
                        if (nt)
                            return q;
                    } return -1; } function v(A, U, z, w) { z = Number(z) || 0; var O = A.length - z; w ? (w = Number(w)) > O && (w = O) : w = O; var q = U.length; if (q % 2 != 0)
                    throw new TypeError("Invalid hex string"); w > q / 2 && (w = q / 2); for (var H = 0; H < w; ++H) {
                    var V = parseInt(U.substr(2 * H, 2), 16);
                    if (isNaN(V))
                        return H;
                    A[z + H] = V;
                } return H; } function R(A, U, z, w) { return C($(U, A.length - z), A, z, w); } function _(A, U, z, w) { return C(function (O) { for (var q = [], H = 0; H < O.length; ++H)
                    q.push(255 & O.charCodeAt(H)); return q; }(U), A, z, w); } function k(A, U, z, w) { return _(A, U, z, w); } function x(A, U, z, w) { return C(y(U), A, z, w); } function M(A, U, z, w) { return C(function (O, q) { for (var H, V, J, Z = [], tt = 0; tt < O.length && !((q -= 2) < 0); ++tt)
                    H = O.charCodeAt(tt), V = H >> 8, J = H % 256, Z.push(J), Z.push(V); return Z; }(U, A.length - z), A, z, w); } function N(A, U, z) { return U === 0 && z === A.length ? r.fromByteArray(A) : r.fromByteArray(A.slice(U, z)); } function S(A, U, z) { z = Math.min(A.length, z); for (var w = [], O = U; O < z;) {
                    var q, H, V, J, Z = A[O], tt = null, nt = Z > 239 ? 4 : Z > 223 ? 3 : Z > 191 ? 2 : 1;
                    if (O + nt <= z)
                        switch (nt) {
                            case 1:
                                Z < 128 && (tt = Z);
                                break;
                            case 2:
                                (192 & (q = A[O + 1])) == 128 && (J = (31 & Z) << 6 | 63 & q) > 127 && (tt = J);
                                break;
                            case 3:
                                q = A[O + 1], H = A[O + 2], (192 & q) == 128 && (192 & H) == 128 && (J = (15 & Z) << 12 | (63 & q) << 6 | 63 & H) > 2047 && (J < 55296 || J > 57343) && (tt = J);
                                break;
                            case 4: q = A[O + 1], H = A[O + 2], V = A[O + 3], (192 & q) == 128 && (192 & H) == 128 && (192 & V) == 128 && (J = (15 & Z) << 18 | (63 & q) << 12 | (63 & H) << 6 | 63 & V) > 65535 && J < 1114112 && (tt = J);
                        }
                    tt === null ? (tt = 65533, nt = 1) : tt > 65535 && (tt -= 65536, w.push(tt >>> 10 & 1023 | 55296), tt = 56320 | 1023 & tt), w.push(tt), O += nt;
                } return function (rt) { var it = rt.length; if (it <= 4096)
                    return String.fromCharCode.apply(String, rt); for (var st = "", at = 0; at < it;)
                    st += String.fromCharCode.apply(String, rt.slice(at, at += 4096)); return st; }(w); } m.Buffer = s, m.SlowBuffer = function (A) { return +A != A && (A = 0), s.alloc(+A); }, m.INSPECT_MAX_BYTES = 50, s.TYPED_ARRAY_SUPPORT = d.TYPED_ARRAY_SUPPORT !== void 0 ? d.TYPED_ARRAY_SUPPORT : function () { try {
                    var A = new Uint8Array(1);
                    return A.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } }, A.foo() === 42 && typeof A.subarray == "function" && A.subarray(1, 1).byteLength === 0;
                }
                catch (U) {
                    return !1;
                } }(), m.kMaxLength = n(), s.poolSize = 8192, s._augment = function (A) { return A.__proto__ = s.prototype, A; }, s.from = function (A, U, z) { return u(null, A, U, z); }, s.TYPED_ARRAY_SUPPORT && (s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, typeof Symbol != "undefined" && Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: !0 })), s.alloc = function (A, U, z) { return function (w, O, q, H) { return i(O), O <= 0 ? t(w, O) : q !== void 0 ? typeof H == "string" ? t(w, O).fill(q, H) : t(w, O).fill(q) : t(w, O); }(null, A, U, z); }, s.allocUnsafe = function (A) { return o(null, A); }, s.allocUnsafeSlow = function (A) { return o(null, A); }, s.isBuffer = function (A) { return !(A == null || !A._isBuffer); }, s.compare = function (A, U) { if (!s.isBuffer(A) || !s.isBuffer(U))
                    throw new TypeError("Arguments must be Buffers"); if (A === U)
                    return 0; for (var z = A.length, w = U.length, O = 0, q = Math.min(z, w); O < q; ++O)
                    if (A[O] !== U[O]) {
                        z = A[O], w = U[O];
                        break;
                    } return z < w ? -1 : w < z ? 1 : 0; }, s.isEncoding = function (A) { switch (String(A).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le": return !0;
                    default: return !1;
                } }, s.concat = function (A, U) { if (!c(A))
                    throw new TypeError('"list" argument must be an Array of Buffers'); if (A.length === 0)
                    return s.alloc(0); var z; if (U === void 0)
                    for (U = 0, z = 0; z < A.length; ++z)
                        U += A[z].length; var w = s.allocUnsafe(U), O = 0; for (z = 0; z < A.length; ++z) {
                    var q = A[z];
                    if (!s.isBuffer(q))
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    q.copy(w, O), O += q.length;
                } return w; }, s.byteLength = l, s.prototype._isBuffer = !0, s.prototype.swap16 = function () { var A = this.length; if (A % 2 != 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var U = 0; U < A; U += 2)
                    g(this, U, U + 1); return this; }, s.prototype.swap32 = function () { var A = this.length; if (A % 4 != 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var U = 0; U < A; U += 4)
                    g(this, U, U + 3), g(this, U + 1, U + 2); return this; }, s.prototype.swap64 = function () { var A = this.length; if (A % 8 != 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var U = 0; U < A; U += 8)
                    g(this, U, U + 7), g(this, U + 1, U + 6), g(this, U + 2, U + 5), g(this, U + 3, U + 4); return this; }, s.prototype.toString = function () { var A = 0 | this.length; return A === 0 ? "" : arguments.length === 0 ? S(this, 0, A) : p.apply(this, arguments); }, s.prototype.equals = function (A) { if (!s.isBuffer(A))
                    throw new TypeError("Argument must be a Buffer"); return this === A || s.compare(this, A) === 0; }, s.prototype.inspect = function () { var A = "", U = m.INSPECT_MAX_BYTES; return this.length > 0 && (A = this.toString("hex", 0, U).match(/.{2}/g).join(" "), this.length > U && (A += " ... ")), "<Buffer " + A + ">"; }, s.prototype.compare = function (A, U, z, w, O) { if (!s.isBuffer(A))
                    throw new TypeError("Argument must be a Buffer"); if (U === void 0 && (U = 0), z === void 0 && (z = A ? A.length : 0), w === void 0 && (w = 0), O === void 0 && (O = this.length), U < 0 || z > A.length || w < 0 || O > this.length)
                    throw new RangeError("out of range index"); if (w >= O && U >= z)
                    return 0; if (w >= O)
                    return -1; if (U >= z)
                    return 1; if (this === A)
                    return 0; for (var q = (O >>>= 0) - (w >>>= 0), H = (z >>>= 0) - (U >>>= 0), V = Math.min(q, H), J = this.slice(w, O), Z = A.slice(U, z), tt = 0; tt < V; ++tt)
                    if (J[tt] !== Z[tt]) {
                        q = J[tt], H = Z[tt];
                        break;
                    } return q < H ? -1 : H < q ? 1 : 0; }, s.prototype.includes = function (A, U, z) { return this.indexOf(A, U, z) !== -1; }, s.prototype.indexOf = function (A, U, z) { return b(this, A, U, z, !0); }, s.prototype.lastIndexOf = function (A, U, z) { return b(this, A, U, z, !1); }, s.prototype.write = function (A, U, z, w) { if (U === void 0)
                    w = "utf8", z = this.length, U = 0;
                else if (z === void 0 && typeof U == "string")
                    w = U, z = this.length, U = 0;
                else {
                    if (!isFinite(U))
                        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    U |= 0, isFinite(z) ? (z |= 0, w === void 0 && (w = "utf8")) : (w = z, z = void 0);
                } var O = this.length - U; if ((z === void 0 || z > O) && (z = O), A.length > 0 && (z < 0 || U < 0) || U > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds"); w || (w = "utf8"); for (var q = !1;;)
                    switch (w) {
                        case "hex": return v(this, A, U, z);
                        case "utf8":
                        case "utf-8": return R(this, A, U, z);
                        case "ascii": return _(this, A, U, z);
                        case "latin1":
                        case "binary": return k(this, A, U, z);
                        case "base64": return x(this, A, U, z);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le": return M(this, A, U, z);
                        default:
                            if (q)
                                throw new TypeError("Unknown encoding: " + w);
                            w = ("" + w).toLowerCase(), q = !0;
                    } }, s.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) }; }; function T(A, U, z) { var w = ""; z = Math.min(A.length, z); for (var O = U; O < z; ++O)
                    w += String.fromCharCode(127 & A[O]); return w; } function B(A, U, z) { var w = ""; z = Math.min(A.length, z); for (var O = U; O < z; ++O)
                    w += String.fromCharCode(A[O]); return w; } function P(A, U, z) { var w = A.length; (!U || U < 0) && (U = 0), (!z || z < 0 || z > w) && (z = w); for (var O = "", q = U; q < z; ++q)
                    O += Y(A[q]); return O; } function L(A, U, z) { for (var w = A.slice(U, z), O = "", q = 0; q < w.length; q += 2)
                    O += String.fromCharCode(w[q] + 256 * w[q + 1]); return O; } function j(A, U, z) { if (A % 1 != 0 || A < 0)
                    throw new RangeError("offset is not uint"); if (A + U > z)
                    throw new RangeError("Trying to access beyond buffer length"); } function D(A, U, z, w, O, q) { if (!s.isBuffer(A))
                    throw new TypeError('"buffer" argument must be a Buffer instance'); if (U > O || U < q)
                    throw new RangeError('"value" argument is out of bounds'); if (z + w > A.length)
                    throw new RangeError("Index out of range"); } function G(A, U, z, w) { U < 0 && (U = 65535 + U + 1); for (var O = 0, q = Math.min(A.length - z, 2); O < q; ++O)
                    A[z + O] = (U & 255 << 8 * (w ? O : 1 - O)) >>> 8 * (w ? O : 1 - O); } function W(A, U, z, w) { U < 0 && (U = 4294967295 + U + 1); for (var O = 0, q = Math.min(A.length - z, 4); O < q; ++O)
                    A[z + O] = U >>> 8 * (w ? O : 3 - O) & 255; } function X(A, U, z, w, O, q) { if (z + w > A.length)
                    throw new RangeError("Index out of range"); if (z < 0)
                    throw new RangeError("Index out of range"); } function Q(A, U, z, w, O) { return O || X(A, 0, z, 4), e.write(A, U, z, w, 23, 4), z + 4; } function K(A, U, z, w, O) { return O || X(A, 0, z, 8), e.write(A, U, z, w, 52, 8), z + 8; } s.prototype.slice = function (A, U) { var z, w = this.length; if ((A = ~~A) < 0 ? (A += w) < 0 && (A = 0) : A > w && (A = w), (U = U === void 0 ? w : ~~U) < 0 ? (U += w) < 0 && (U = 0) : U > w && (U = w), U < A && (U = A), s.TYPED_ARRAY_SUPPORT)
                    (z = this.subarray(A, U)).__proto__ = s.prototype;
                else {
                    var O = U - A;
                    z = new s(O, void 0);
                    for (var q = 0; q < O; ++q)
                        z[q] = this[q + A];
                } return z; }, s.prototype.readUIntLE = function (A, U, z) { A |= 0, U |= 0, z || j(A, U, this.length); for (var w = this[A], O = 1, q = 0; ++q < U && (O *= 256);)
                    w += this[A + q] * O; return w; }, s.prototype.readUIntBE = function (A, U, z) { A |= 0, U |= 0, z || j(A, U, this.length); for (var w = this[A + --U], O = 1; U > 0 && (O *= 256);)
                    w += this[A + --U] * O; return w; }, s.prototype.readUInt8 = function (A, U) { return U || j(A, 1, this.length), this[A]; }, s.prototype.readUInt16LE = function (A, U) { return U || j(A, 2, this.length), this[A] | this[A + 1] << 8; }, s.prototype.readUInt16BE = function (A, U) { return U || j(A, 2, this.length), this[A] << 8 | this[A + 1]; }, s.prototype.readUInt32LE = function (A, U) { return U || j(A, 4, this.length), (this[A] | this[A + 1] << 8 | this[A + 2] << 16) + 16777216 * this[A + 3]; }, s.prototype.readUInt32BE = function (A, U) { return U || j(A, 4, this.length), 16777216 * this[A] + (this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]); }, s.prototype.readIntLE = function (A, U, z) { A |= 0, U |= 0, z || j(A, U, this.length); for (var w = this[A], O = 1, q = 0; ++q < U && (O *= 256);)
                    w += this[A + q] * O; return w >= (O *= 128) && (w -= Math.pow(2, 8 * U)), w; }, s.prototype.readIntBE = function (A, U, z) { A |= 0, U |= 0, z || j(A, U, this.length); for (var w = U, O = 1, q = this[A + --w]; w > 0 && (O *= 256);)
                    q += this[A + --w] * O; return q >= (O *= 128) && (q -= Math.pow(2, 8 * U)), q; }, s.prototype.readInt8 = function (A, U) { return U || j(A, 1, this.length), 128 & this[A] ? -1 * (255 - this[A] + 1) : this[A]; }, s.prototype.readInt16LE = function (A, U) { U || j(A, 2, this.length); var z = this[A] | this[A + 1] << 8; return 32768 & z ? 4294901760 | z : z; }, s.prototype.readInt16BE = function (A, U) { U || j(A, 2, this.length); var z = this[A + 1] | this[A] << 8; return 32768 & z ? 4294901760 | z : z; }, s.prototype.readInt32LE = function (A, U) { return U || j(A, 4, this.length), this[A] | this[A + 1] << 8 | this[A + 2] << 16 | this[A + 3] << 24; }, s.prototype.readInt32BE = function (A, U) { return U || j(A, 4, this.length), this[A] << 24 | this[A + 1] << 16 | this[A + 2] << 8 | this[A + 3]; }, s.prototype.readFloatLE = function (A, U) { return U || j(A, 4, this.length), e.read(this, A, !0, 23, 4); }, s.prototype.readFloatBE = function (A, U) { return U || j(A, 4, this.length), e.read(this, A, !1, 23, 4); }, s.prototype.readDoubleLE = function (A, U) { return U || j(A, 8, this.length), e.read(this, A, !0, 52, 8); }, s.prototype.readDoubleBE = function (A, U) { return U || j(A, 8, this.length), e.read(this, A, !1, 52, 8); }, s.prototype.writeUIntLE = function (A, U, z, w) { (A = +A, U |= 0, z |= 0, w) || D(this, A, U, z, Math.pow(2, 8 * z) - 1, 0); var O = 1, q = 0; for (this[U] = 255 & A; ++q < z && (O *= 256);)
                    this[U + q] = A / O & 255; return U + z; }, s.prototype.writeUIntBE = function (A, U, z, w) { (A = +A, U |= 0, z |= 0, w) || D(this, A, U, z, Math.pow(2, 8 * z) - 1, 0); var O = z - 1, q = 1; for (this[U + O] = 255 & A; --O >= 0 && (q *= 256);)
                    this[U + O] = A / q & 255; return U + z; }, s.prototype.writeUInt8 = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 1, 255, 0), s.TYPED_ARRAY_SUPPORT || (A = Math.floor(A)), this[U] = 255 & A, U + 1; }, s.prototype.writeUInt16LE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 2, 65535, 0), s.TYPED_ARRAY_SUPPORT ? (this[U] = 255 & A, this[U + 1] = A >>> 8) : G(this, A, U, !0), U + 2; }, s.prototype.writeUInt16BE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 2, 65535, 0), s.TYPED_ARRAY_SUPPORT ? (this[U] = A >>> 8, this[U + 1] = 255 & A) : G(this, A, U, !1), U + 2; }, s.prototype.writeUInt32LE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 4, 4294967295, 0), s.TYPED_ARRAY_SUPPORT ? (this[U + 3] = A >>> 24, this[U + 2] = A >>> 16, this[U + 1] = A >>> 8, this[U] = 255 & A) : W(this, A, U, !0), U + 4; }, s.prototype.writeUInt32BE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 4, 4294967295, 0), s.TYPED_ARRAY_SUPPORT ? (this[U] = A >>> 24, this[U + 1] = A >>> 16, this[U + 2] = A >>> 8, this[U + 3] = 255 & A) : W(this, A, U, !1), U + 4; }, s.prototype.writeIntLE = function (A, U, z, w) { if (A = +A, U |= 0, !w) {
                    var O = Math.pow(2, 8 * z - 1);
                    D(this, A, U, z, O - 1, -O);
                } var q = 0, H = 1, V = 0; for (this[U] = 255 & A; ++q < z && (H *= 256);)
                    A < 0 && V === 0 && this[U + q - 1] !== 0 && (V = 1), this[U + q] = (A / H >> 0) - V & 255; return U + z; }, s.prototype.writeIntBE = function (A, U, z, w) { if (A = +A, U |= 0, !w) {
                    var O = Math.pow(2, 8 * z - 1);
                    D(this, A, U, z, O - 1, -O);
                } var q = z - 1, H = 1, V = 0; for (this[U + q] = 255 & A; --q >= 0 && (H *= 256);)
                    A < 0 && V === 0 && this[U + q + 1] !== 0 && (V = 1), this[U + q] = (A / H >> 0) - V & 255; return U + z; }, s.prototype.writeInt8 = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 1, 127, -128), s.TYPED_ARRAY_SUPPORT || (A = Math.floor(A)), A < 0 && (A = 255 + A + 1), this[U] = 255 & A, U + 1; }, s.prototype.writeInt16LE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 2, 32767, -32768), s.TYPED_ARRAY_SUPPORT ? (this[U] = 255 & A, this[U + 1] = A >>> 8) : G(this, A, U, !0), U + 2; }, s.prototype.writeInt16BE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 2, 32767, -32768), s.TYPED_ARRAY_SUPPORT ? (this[U] = A >>> 8, this[U + 1] = 255 & A) : G(this, A, U, !1), U + 2; }, s.prototype.writeInt32LE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 4, 2147483647, -2147483648), s.TYPED_ARRAY_SUPPORT ? (this[U] = 255 & A, this[U + 1] = A >>> 8, this[U + 2] = A >>> 16, this[U + 3] = A >>> 24) : W(this, A, U, !0), U + 4; }, s.prototype.writeInt32BE = function (A, U, z) { return A = +A, U |= 0, z || D(this, A, U, 4, 2147483647, -2147483648), A < 0 && (A = 4294967295 + A + 1), s.TYPED_ARRAY_SUPPORT ? (this[U] = A >>> 24, this[U + 1] = A >>> 16, this[U + 2] = A >>> 8, this[U + 3] = 255 & A) : W(this, A, U, !1), U + 4; }, s.prototype.writeFloatLE = function (A, U, z) { return Q(this, A, U, !0, z); }, s.prototype.writeFloatBE = function (A, U, z) { return Q(this, A, U, !1, z); }, s.prototype.writeDoubleLE = function (A, U, z) { return K(this, A, U, !0, z); }, s.prototype.writeDoubleBE = function (A, U, z) { return K(this, A, U, !1, z); }, s.prototype.copy = function (A, U, z, w) { if (z || (z = 0), w || w === 0 || (w = this.length), U >= A.length && (U = A.length), U || (U = 0), w > 0 && w < z && (w = z), w === z)
                    return 0; if (A.length === 0 || this.length === 0)
                    return 0; if (U < 0)
                    throw new RangeError("targetStart out of bounds"); if (z < 0 || z >= this.length)
                    throw new RangeError("sourceStart out of bounds"); if (w < 0)
                    throw new RangeError("sourceEnd out of bounds"); w > this.length && (w = this.length), A.length - U < w - z && (w = A.length - U + z); var O, q = w - z; if (this === A && z < U && U < w)
                    for (O = q - 1; O >= 0; --O)
                        A[O + U] = this[O + z];
                else if (q < 1e3 || !s.TYPED_ARRAY_SUPPORT)
                    for (O = 0; O < q; ++O)
                        A[O + U] = this[O + z];
                else
                    Uint8Array.prototype.set.call(A, this.subarray(z, z + q), U); return q; }, s.prototype.fill = function (A, U, z, w) { if (typeof A == "string") {
                    if (typeof U == "string" ? (w = U, U = 0, z = this.length) : typeof z == "string" && (w = z, z = this.length), A.length === 1) {
                        var O = A.charCodeAt(0);
                        O < 256 && (A = O);
                    }
                    if (w !== void 0 && typeof w != "string")
                        throw new TypeError("encoding must be a string");
                    if (typeof w == "string" && !s.isEncoding(w))
                        throw new TypeError("Unknown encoding: " + w);
                }
                else
                    typeof A == "number" && (A &= 255); if (U < 0 || this.length < U || this.length < z)
                    throw new RangeError("Out of range index"); if (z <= U)
                    return this; var q; if (U >>>= 0, z = z === void 0 ? this.length : z >>> 0, A || (A = 0), typeof A == "number")
                    for (q = U; q < z; ++q)
                        this[q] = A;
                else {
                    var H = s.isBuffer(A) ? A : $(new s(A, w).toString()), V = H.length;
                    for (q = 0; q < z - U; ++q)
                        this[q + U] = H[q % V];
                } return this; }; var F = /[^+\/0-9A-Za-z-_]/g; function Y(A) { return A < 16 ? "0" + A.toString(16) : A.toString(16); } function $(A, U) { var z; U = U || 1 / 0; for (var w = A.length, O = null, q = [], H = 0; H < w; ++H) {
                    if ((z = A.charCodeAt(H)) > 55295 && z < 57344) {
                        if (!O) {
                            if (z > 56319) {
                                (U -= 3) > -1 && q.push(239, 191, 189);
                                continue;
                            }
                            if (H + 1 === w) {
                                (U -= 3) > -1 && q.push(239, 191, 189);
                                continue;
                            }
                            O = z;
                            continue;
                        }
                        if (z < 56320) {
                            (U -= 3) > -1 && q.push(239, 191, 189), O = z;
                            continue;
                        }
                        z = 65536 + (O - 55296 << 10 | z - 56320);
                    }
                    else
                        O && (U -= 3) > -1 && q.push(239, 191, 189);
                    if (O = null, z < 128) {
                        if ((U -= 1) < 0)
                            break;
                        q.push(z);
                    }
                    else if (z < 2048) {
                        if ((U -= 2) < 0)
                            break;
                        q.push(z >> 6 | 192, 63 & z | 128);
                    }
                    else if (z < 65536) {
                        if ((U -= 3) < 0)
                            break;
                        q.push(z >> 12 | 224, z >> 6 & 63 | 128, 63 & z | 128);
                    }
                    else {
                        if (!(z < 1114112))
                            throw new Error("Invalid code point");
                        if ((U -= 4) < 0)
                            break;
                        q.push(z >> 18 | 240, z >> 12 & 63 | 128, z >> 6 & 63 | 128, 63 & z | 128);
                    }
                } return q; } function y(A) { return r.toByteArray(function (U) { if ((U = function (z) { return z.trim ? z.trim() : z.replace(/^\s+|\s+$/g, ""); }(U).replace(F, "")).length < 2)
                    return ""; for (; U.length % 4 != 0;)
                    U += "="; return U; }(A)); } function C(A, U, z, w) { for (var O = 0; O < w && !(O + z >= U.length || O >= A.length); ++O)
                    U[O + z] = A[O]; return O; } }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = f(48), r = f(25), e = f(18), { baseTable: c } = f(81), n = f(421), t = f(31), s = f(5), u = f(20), i = Object.keys(c).reduce((a, l) => (a[c[l]] = l, a), {}), o = Symbol.for("@ipld/js-cid/CID");
                class h {
                    constructor(l, p, g, b) { if (Object.defineProperty(this, o, { value: !0 }), h.isCID(l)) {
                        const I = l;
                        return this.version = I.version, this.codec = I.codec, this.multihash = I.multihash, void (this.multibaseName = I.multibaseName || (I.version === 0 ? "base58btc" : "base32"));
                    } if (typeof l == "string") {
                        const I = r.isEncoded(l);
                        if (I) {
                            const v = r.decode(l);
                            this.version = parseInt(v[0].toString(), 16), this.codec = e.getCodec(v.slice(1)), this.multihash = e.rmPrefix(v.slice(1)), this.multibaseName = I;
                        }
                        else
                            this.version = 0, this.codec = "dag-pb", this.multihash = d.fromB58String(l), this.multibaseName = "base58btc";
                        return h.validateCID(this), void Object.defineProperty(this, "string", { value: l });
                    } if (l instanceof Uint8Array) {
                        const I = parseInt(l[0].toString(), 16);
                        if (I === 1) {
                            const v = l;
                            this.version = I, this.codec = e.getCodec(v.slice(1)), this.multihash = e.rmPrefix(v.slice(1)), this.multibaseName = "base32";
                        }
                        else
                            this.version = 0, this.codec = "dag-pb", this.multihash = l, this.multibaseName = "base58btc";
                        h.validateCID(this);
                    }
                    else
                        this.version = l, typeof p == "number" && (p = i[p]), this.codec = p, this.multihash = g, this.multibaseName = b || (l === 0 ? "base58btc" : "base32"), h.validateCID(this); }
                    get bytes() { let l = this._bytes; if (!l) {
                        if (this.version === 0)
                            l = this.multihash;
                        else {
                            if (this.version !== 1)
                                throw new Error("unsupported version");
                            {
                                const p = e.getCodeVarint(this.codec);
                                l = t([[1], p, this.multihash], 1 + p.byteLength + this.multihash.byteLength);
                            }
                        }
                        Object.defineProperty(this, "_bytes", { value: l });
                    } return l; }
                    get prefix() { const l = e.getCodeVarint(this.codec), p = d.prefix(this.multihash); return t([[this.version], l, p], 1 + l.byteLength + p.byteLength); }
                    get code() { return c[this.codec]; }
                    toV0() { if (this.codec !== "dag-pb")
                        throw new Error("Cannot convert a non dag-pb CID to CIDv0"); const { name: l, length: p } = d.decode(this.multihash); if (l !== "sha2-256")
                        throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0"); if (p !== 32)
                        throw new Error("Cannot convert non 32 byte multihash CID to CIDv0"); return new h(0, this.codec, this.multihash); }
                    toV1() { return new h(1, this.codec, this.multihash); }
                    toBaseEncodedString(l = this.multibaseName) { if (this.string && this.string.length !== 0 && l === this.multibaseName)
                        return this.string; let p; if (this.version === 0) {
                        if (l !== "base58btc")
                            throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
                        p = d.toB58String(this.multihash);
                    }
                    else {
                        if (this.version !== 1)
                            throw new Error("unsupported version");
                        p = s(r.encode(l, this.bytes));
                    } return l === this.multibaseName && Object.defineProperty(this, "string", { value: p }), p; }
                    [Symbol.for("nodejs.util.inspect.custom")]() { return "CID(" + this.toString() + ")"; }
                    toString(l) { return this.toBaseEncodedString(l); }
                    toJSON() { return { codec: this.codec, version: this.version, hash: this.multihash }; }
                    equals(l) { return this.codec === l.codec && this.version === l.version && u(this.multihash, l.multihash); }
                    static validateCID(l) { const p = n.checkCIDComponents(l); if (p)
                        throw new Error(p); }
                    static isCID(l) { return l instanceof h || Boolean(l && l[o]); }
                }
                h.codecs = c, E.exports = h;
            }, function (E, m, f) {
                "use strict";
                const { names: d } = f(138), { TextDecoder: r } = f(80), e = new r("utf8");
                E.exports = function (c, n = "utf8") { if (n === "utf8" || n === "utf-8")
                    return e.decode(c); if (n === "ascii")
                    return function (s) { let u = ""; for (let i = 0; i < s.length; i++)
                        u += String.fromCharCode(s[i]); return u; }(c); const t = d[n]; if (!t)
                    throw new Error("Unknown base"); return t.encode(c); };
            }, function (E, m, f) {
                "use strict";
                const { names: d } = f(138), { TextEncoder: r } = f(80), e = new r;
                E.exports = function (c, n = "utf8") { if (n === "utf8" || n === "utf-8")
                    return e.encode(c); if (n === "ascii")
                    return function (s) { const u = new Uint8Array(s.length); for (let i = 0; i < s.length; i++)
                        u[i] = s.charCodeAt(i); return u; }(c); const t = d[n]; if (!t)
                    throw new Error("Unknown base"); return t.decode(c); };
            }, function (E, m, f) {
                "use strict";
                const d = f(48), r = f(4), e = f(140), c = f(26), { PeerIdProto: n } = f(496), t = f(20), s = f(6), u = f(5), i = c(class {
                    constructor(l, p, g) { if (!(l instanceof Uint8Array))
                        throw new Error("invalid id provided"); if (p && g && !t(p.public.bytes, g.bytes))
                        throw new Error("inconsistent arguments"); this._id = l, this._idB58String = d.toB58String(this.id), this._privKey = p, this._pubKey = g; }
                    get id() { return this._id; }
                    set id(l) { throw new Error("Id is immutable"); }
                    get privKey() { return this._privKey; }
                    set privKey(l) { this._privKey = l; }
                    get pubKey() { if (this._pubKey)
                        return this._pubKey; if (this._privKey)
                        return this._privKey.public; try {
                        const l = d.decode(this.id);
                        l.name === "identity" && (this._pubKey = e.unmarshalPublicKey(l.digest));
                    }
                    catch (l) { } return this._pubKey; }
                    set pubKey(l) { this._pubKey = l; }
                    marshalPubKey() { if (this.pubKey)
                        return e.marshalPublicKey(this.pubKey); }
                    marshalPrivKey() { if (this.privKey)
                        return e.marshalPrivateKey(this.privKey); }
                    marshal(l) { return n.encode({ id: this.toBytes(), pubKey: this.marshalPubKey(), privKey: l ? null : this.marshalPrivKey() }); }
                    toPrint() { let l = this.toB58String(); l.startsWith("Qm") && (l = l.slice(2)); let p = 6; return l.length < p && (p = l.length), "<peer.ID " + l.substr(0, p) + ">"; }
                    toJSON() { return { id: this.toB58String(), privKey: a(this.marshalPrivKey()), pubKey: a(this.marshalPubKey()) }; }
                    toHexString() { return d.toHexString(this.id); }
                    toBytes() { return this.id; }
                    toB58String() { return this._idB58String; }
                    toString() { if (!this._idCIDString) {
                        const l = new r(1, "libp2p-key", this.id, "base32");
                        this._idCIDString = l.toBaseEncodedString("base32");
                    } return this._idCIDString; }
                    equals(l) { if (l instanceof Uint8Array)
                        return t(this.id, l); if (l.id)
                        return t(this.id, l.id); throw new Error("not valid Id"); }
                    isEqual(l) { return this.equals(l); }
                    isValid() { return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && t(this.privKey.public.bytes, this.pubKey.bytes)); }
                    hasInlinePublicKey() { try {
                        if (d.decode(this.id).name === "identity")
                            return !0;
                    }
                    catch (l) { } return !1; }
                }, { className: "PeerId", symbolName: "@libp2p/js-peer-id/PeerId" });
                m = E.exports = i;
                const o = l => l.bytes.length <= 42 ? d.encode(l.bytes, "identity") : l.hash(), h = async (l, p) => { const g = await o(p); return new i(g, l, p); };
                m.create = async (l) => { (l = l || {}).bits = l.bits || 2048, l.keyType = l.keyType || "RSA"; const p = await e.generateKeyPair(l.keyType, l.bits); return h(p, p.public); }, m.createFromHexString = l => new i(d.fromHexString(l)), m.createFromBytes = l => new i(l), m.createFromB58String = l => m.createFromCID(l);
                function a(l) { if (l)
                    return u(l, "base64pad"); }
                m.createFromCID = l => { if (!(p => p.codec === "libp2p-key" || p.codec === "dag-pb")(l = r.isCID(l) ? l : new r(l)))
                    throw new Error("Supplied PeerID CID has invalid multicodec: " + l.codec); return new i(l.multihash); }, m.createFromPubKey = async (l) => { let p = l; if (typeof p == "string" && (p = s(l, "base64pad")), !(p instanceof Uint8Array))
                    throw new Error("Supplied key is neither a base64 string nor a Uint8Array"); const g = await e.unmarshalPublicKey(p); return h(null, g); }, m.createFromPrivKey = async (l) => { if (typeof l == "string" && (l = s(l, "base64pad")), !(l instanceof Uint8Array))
                    throw new Error("Supplied key is neither a base64 string nor a Uint8Array"); const p = await e.unmarshalPrivateKey(l); return h(p, p.public); }, m.createFromJSON = async (l) => { const p = d.fromB58String(l.id), g = l.privKey && s(l.privKey, "base64pad"), b = l.pubKey && s(l.pubKey, "base64pad"), I = b && await e.unmarshalPublicKey(b); if (!g)
                    return new i(p, null, I); const v = await e.unmarshalPrivateKey(g), R = await o(v.public); let _; if (I && (_ = await o(I)), I && !t(R, _))
                    throw new Error("Public and private key do not match"); if (p && !t(R, p))
                    throw new Error("Id and private key do not match"); return new i(p, v, I); }, m.createFromProtobuf = async (l) => { typeof l == "string" && (l = s(l, "base16")); let p, g, { id: b, privKey: I, pubKey: v } = n.decode(l); if (I = !!I && await e.unmarshalPrivateKey(I), v = !!v && await e.unmarshalPublicKey(v), I && (g = await o(I.public)), v && (p = await o(v)), I) {
                    if (v && !t(g, p))
                        throw new Error("Public and private key do not match");
                    return new i(g, I, I.public);
                } if (v)
                    return new i(p, null, v); if (b)
                    return new i(b); throw new Error("Protobuf did not contain any usable key material"); }, m.isPeerId = l => Boolean(typeof l == "object" && l._id && l._idB58String);
            }, function (E, m, f) {
                "use strict";
                E.exports = { options: { usePureJavaScript: !1 } };
            }, function (E, m, f) {
                "use strict";
                var d, r, e = E.exports = {};
                function c() { throw new Error("setTimeout has not been defined"); }
                function n() { throw new Error("clearTimeout has not been defined"); }
                function t(g) { if (d === setTimeout)
                    return setTimeout(g, 0); if ((d === c || !d) && setTimeout)
                    return d = setTimeout, setTimeout(g, 0); try {
                    return d(g, 0);
                }
                catch (b) {
                    try {
                        return d.call(null, g, 0);
                    }
                    catch (I) {
                        return d.call(this, g, 0);
                    }
                } }
                !function () { try {
                    d = typeof setTimeout == "function" ? setTimeout : c;
                }
                catch (g) {
                    d = c;
                } try {
                    r = typeof clearTimeout == "function" ? clearTimeout : n;
                }
                catch (g) {
                    r = n;
                } }();
                var s, u = [], i = !1, o = -1;
                function h() { i && s && (i = !1, s.length ? u = s.concat(u) : o = -1, u.length && a()); }
                function a() { if (!i) {
                    var g = t(h);
                    i = !0;
                    for (var b = u.length; b;) {
                        for (s = u, u = []; ++o < b;)
                            s && s[o].run();
                        o = -1, b = u.length;
                    }
                    s = null, i = !1, function (I) { if (r === clearTimeout)
                        return clearTimeout(I); if ((r === n || !r) && clearTimeout)
                        return r = clearTimeout, clearTimeout(I); try {
                        r(I);
                    }
                    catch (v) {
                        try {
                            return r.call(null, I);
                        }
                        catch (R) {
                            return r.call(this, I);
                        }
                    } }(g);
                } }
                function l(g, b) { this.fun = g, this.array = b; }
                function p() { }
                e.nextTick = function (g) { var b = new Array(arguments.length - 1); if (arguments.length > 1)
                    for (var I = 1; I < arguments.length; I++)
                        b[I - 1] = arguments[I]; u.push(new l(g, b)), u.length !== 1 || i || t(a); }, l.prototype.run = function () { this.fun.apply(null, this.array); }, e.title = "browser", e.browser = !0, e.env = {}, e.argv = [], e.version = "", e.versions = {}, e.on = p, e.addListener = p, e.once = p, e.off = p, e.removeListener = p, e.removeAllListeners = p, e.emit = p, e.prependListener = p, e.prependOnceListener = p, e.listeners = function (g) { return []; }, e.binding = function (g) { throw new Error("process.binding is not supported"); }, e.cwd = function () { return "/"; }, e.chdir = function (g) { throw new Error("process.chdir is not supported"); }, e.umask = function () { return 0; };
            }, function (E, m, f) {
                "use strict";
                var d;
                d = function () { return this; }();
                try {
                    d = d || new Function("return this")();
                }
                catch (r) {
                    typeof window == "object" && (d = window);
                }
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(242), r = f(522), e = f(151), c = f(248), n = f(246);
                m.Key = d, m.MemoryDatastore = r, m.utils = e, m.Errors = c, m.Adapter = n;
            }, function (E, m, f) {
                "use strict";
                var d, r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function (g, b, I) { return Function.prototype.apply.call(g, b, I); };
                d = r && typeof r.ownKeys == "function" ? r.ownKeys : Object.getOwnPropertySymbols ? function (g) { return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g)); } : function (g) { return Object.getOwnPropertyNames(g); };
                var c = Number.isNaN || function (g) { return g != g; };
                function n() { n.init.call(this); }
                E.exports = n, E.exports.once = function (g, b) { return new Promise(function (I, v) { function R() { _ !== void 0 && g.removeListener("error", _), I([].slice.call(arguments)); } var _; b !== "error" && (_ = function (k) { g.removeListener(b, R), v(k); }, g.once("error", _)), g.once(b, R); }); }, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._eventsCount = 0, n.prototype._maxListeners = void 0;
                var t = 10;
                function s(g) { if (typeof g != "function")
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof g); }
                function u(g) { return g._maxListeners === void 0 ? n.defaultMaxListeners : g._maxListeners; }
                function i(g, b, I, v) { var R, _, k, x; if (s(I), (_ = g._events) === void 0 ? (_ = g._events = Object.create(null), g._eventsCount = 0) : (_.newListener !== void 0 && (g.emit("newListener", b, I.listener ? I.listener : I), _ = g._events), k = _[b]), k === void 0)
                    k = _[b] = I, ++g._eventsCount;
                else if (typeof k == "function" ? k = _[b] = v ? [I, k] : [k, I] : v ? k.unshift(I) : k.push(I), (R = u(g)) > 0 && k.length > R && !k.warned) {
                    k.warned = !0;
                    var M = new Error("Possible EventEmitter memory leak detected. " + k.length + " " + String(b) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    M.name = "MaxListenersExceededWarning", M.emitter = g, M.type = b, M.count = k.length, x = M, console && console.warn && console.warn(x);
                } return g; }
                function o() { if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments); }
                function h(g, b, I) { var v = { fired: !1, wrapFn: void 0, target: g, type: b, listener: I }, R = o.bind(v); return R.listener = I, v.wrapFn = R, R; }
                function a(g, b, I) { var v = g._events; if (v === void 0)
                    return []; var R = v[b]; return R === void 0 ? [] : typeof R == "function" ? I ? [R.listener || R] : [R] : I ? function (_) { for (var k = new Array(_.length), x = 0; x < k.length; ++x)
                    k[x] = _[x].listener || _[x]; return k; }(R) : p(R, R.length); }
                function l(g) { var b = this._events; if (b !== void 0) {
                    var I = b[g];
                    if (typeof I == "function")
                        return 1;
                    if (I !== void 0)
                        return I.length;
                } return 0; }
                function p(g, b) { for (var I = new Array(b), v = 0; v < b; ++v)
                    I[v] = g[v]; return I; }
                Object.defineProperty(n, "defaultMaxListeners", { enumerable: !0, get: function () { return t; }, set: function (g) { if (typeof g != "number" || g < 0 || c(g))
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + g + "."); t = g; } }), n.init = function () { this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0; }, n.prototype.setMaxListeners = function (g) { if (typeof g != "number" || g < 0 || c(g))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + g + "."); return this._maxListeners = g, this; }, n.prototype.getMaxListeners = function () { return u(this); }, n.prototype.emit = function (g) { for (var b = [], I = 1; I < arguments.length; I++)
                    b.push(arguments[I]); var v = g === "error", R = this._events; if (R !== void 0)
                    v = v && R.error === void 0;
                else if (!v)
                    return !1; if (v) {
                    var _;
                    if (b.length > 0 && (_ = b[0]), _ instanceof Error)
                        throw _;
                    var k = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
                    throw k.context = _, k;
                } var x = R[g]; if (x === void 0)
                    return !1; if (typeof x == "function")
                    e(x, this, b);
                else {
                    var M = x.length, N = p(x, M);
                    for (I = 0; I < M; ++I)
                        e(N[I], this, b);
                } return !0; }, n.prototype.addListener = function (g, b) { return i(this, g, b, !1); }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function (g, b) { return i(this, g, b, !0); }, n.prototype.once = function (g, b) { return s(b), this.on(g, h(this, g, b)), this; }, n.prototype.prependOnceListener = function (g, b) { return s(b), this.prependListener(g, h(this, g, b)), this; }, n.prototype.removeListener = function (g, b) { var I, v, R, _, k; if (s(b), (v = this._events) === void 0)
                    return this; if ((I = v[g]) === void 0)
                    return this; if (I === b || I.listener === b)
                    --this._eventsCount == 0 ? this._events = Object.create(null) : (delete v[g], v.removeListener && this.emit("removeListener", g, I.listener || b));
                else if (typeof I != "function") {
                    for (R = -1, _ = I.length - 1; _ >= 0; _--)
                        if (I[_] === b || I[_].listener === b) {
                            k = I[_].listener, R = _;
                            break;
                        }
                    if (R < 0)
                        return this;
                    R === 0 ? I.shift() : function (x, M) { for (; M + 1 < x.length; M++)
                        x[M] = x[M + 1]; x.pop(); }(I, R), I.length === 1 && (v[g] = I[0]), v.removeListener !== void 0 && this.emit("removeListener", g, k || b);
                } return this; }, n.prototype.off = n.prototype.removeListener, n.prototype.removeAllListeners = function (g) { var b, I, v; if ((I = this._events) === void 0)
                    return this; if (I.removeListener === void 0)
                    return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : I[g] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete I[g]), this; if (arguments.length === 0) {
                    var R, _ = Object.keys(I);
                    for (v = 0; v < _.length; ++v)
                        (R = _[v]) !== "removeListener" && this.removeAllListeners(R);
                    return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
                } if (typeof (b = I[g]) == "function")
                    this.removeListener(g, b);
                else if (b !== void 0)
                    for (v = b.length - 1; v >= 0; v--)
                        this.removeListener(g, b[v]); return this; }, n.prototype.listeners = function (g) { return a(this, g, !0); }, n.prototype.rawListeners = function (g) { return a(this, g, !1); }, n.listenerCount = function (g, b) { return typeof g.listenerCount == "function" ? g.listenerCount(b) : l.call(g, b); }, n.prototype.listenerCount = l, n.prototype.eventNames = function () { return this._eventsCount > 0 ? d(this._events) : []; };
            }, function (E, m, f) {
                "use strict";
                const d = f(501), r = f(109), e = f(19), c = f(4), n = f(26), t = f(0), s = Symbol.for("nodejs.util.inspect.custom"), u = f(5), i = f(20), o = new Map, h = n.proto(function (a) { if (!(this instanceof h))
                    return new h(a); if (a == null && (a = ""), a instanceof Uint8Array)
                    this.bytes = d.fromBytes(a);
                else if (typeof a == "string" || a instanceof String) {
                    if (a.length > 0 && a.charAt(0) !== "/")
                        throw new Error(`multiaddr "${a}" must start with a "/"`);
                    this.bytes = d.fromString(a);
                }
                else {
                    if (!(a.bytes && a.protos && a.protoCodes))
                        throw new Error("addr must be a string, Buffer, or another Multiaddr");
                    this.bytes = d.fromBytes(a.bytes);
                } }, { className: "Multiaddr", symbolName: "@multiformats/js-multiaddr/multiaddr" });
                h.prototype.toString = function () { return d.bytesToString(this.bytes); }, h.prototype.toJSON = h.prototype.toString, h.prototype.toOptions = function () { const a = {}, l = this.toString().split("/"); return a.family = l[1] === "ip4" ? "ipv4" : "ipv6", a.host = l[2], a.transport = l[3], a.port = parseInt(l[4]), a; }, h.prototype[s] = function () { return "<Multiaddr " + u(this.bytes, "base16") + " - " + d.bytesToString(this.bytes) + ">"; }, h.prototype.inspect = function () { return "<Multiaddr " + u(this.bytes, "base16") + " - " + d.bytesToString(this.bytes) + ">"; }, h.prototype.protos = function () { return this.protoCodes().map(a => Object.assign({}, r(a))); }, h.prototype.protoCodes = function () { const a = [], l = this.bytes; let p = 0; for (; p < l.length;) {
                    const g = e.decode(l, p), b = e.decode.bytes, I = r(g);
                    p += d.sizeForAddr(I, l.slice(p + b)) + b, a.push(g);
                } return a; }, h.prototype.protoNames = function () { return this.protos().map(a => a.name); }, h.prototype.tuples = function () { return d.bytesToTuples(this.bytes); }, h.prototype.stringTuples = function () { const a = d.bytesToTuples(this.bytes); return d.tuplesToStringTuples(a); }, h.prototype.encapsulate = function (a) { return a = h(a), h(this.toString() + a.toString()); }, h.prototype.decapsulate = function (a) { a = a.toString(); const l = this.toString(), p = l.lastIndexOf(a); if (p < 0)
                    throw new Error("Address " + this + " does not contain subaddress: " + a); return h(l.slice(0, p)); }, h.prototype.decapsulateCode = function (a) { const l = this.tuples(); for (let p = l.length - 1; p >= 0; p--)
                    if (l[p][0] === a)
                        return h(d.tuplesToBytes(l.slice(0, p))); return this; }, h.prototype.getPeerId = function () { let a = null; try {
                    a = this.stringTuples().filter(l => { if (l[0] === r.names.ipfs.code)
                        return !0; }).pop()[1], a = u(new c(a).multihash, "base58btc");
                }
                catch (l) {
                    a = null;
                } return a; }, h.prototype.getPath = function () { let a = null; try {
                    a = this.stringTuples().filter(l => { if (r(l[0]).path)
                        return !0; })[0][1];
                }
                catch (l) {
                    a = null;
                } return a; }, h.prototype.equals = function (a) { return i(this.bytes, a.bytes); }, h.prototype.resolve = async function () { const a = this.protos().find(p => p.resolvable); if (!a)
                    return [this]; const l = o.get(a.name); if (!l)
                    throw t(new Error("no available resolver for " + a.name), "ERR_NO_AVAILABLE_RESOLVER"); return (await l(this)).map(p => h(p)); }, h.prototype.nodeAddress = function () { const a = this.protoCodes(), l = this.protoNames(), p = this.toString().split("/").slice(1); if (p.length < 4)
                    throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'); if (a[0] !== 4 && a[0] !== 41 && a[0] !== 54 && a[0] !== 55)
                    throw new Error(`no protocol with name: "'${l[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`); if (p[2] !== "tcp" && p[2] !== "udp")
                    throw new Error(`no protocol with name: "'${l[1]}'". Must have a valid transport protocol: "{tcp, udp}".`); return { family: a[0] === 41 || a[0] === 55 ? 6 : 4, address: p[1], port: parseInt(p[3]) }; }, h.fromNodeAddress = function (a, l) { if (!a)
                    throw new Error("requires node address object"); if (!l)
                    throw new Error("requires transport protocol"); let p; switch (a.family) {
                    case "IPv4":
                        p = "ip4";
                        break;
                    case "IPv6":
                        p = "ip6";
                        break;
                    default: throw Error(`Invalid addr family. Got '${a.family}' instead of 'IPv4' or 'IPv6'`);
                } return h("/" + [p, a.address, l, a.port].join("/")); }, h.prototype.isThinWaistAddress = function (a) { const l = (a || this).protos(); return l.length === 2 && (l[0].code === 4 || l[0].code === 41) && (l[1].code === 6 || l[1].code === 273); }, h.protocols = r, h.isName = function (a) { return !!h.isMultiaddr(a) && a.protos().some(l => l.resolvable); }, h.resolve = function (a) { return h.isMultiaddr(a) && h.isName(a) ? Promise.reject(new Error("not implemented yet")) : Promise.reject(Error("not a valid name")); }, h.resolvers = o, E.exports = h;
            }, function (E, m, f) {
                "use strict";
                (function (d, r, e) {
                    var c = f(8), n = f(448), t = E.exports = c.util = c.util || {};
                    function s(_) { if (_ !== 8 && _ !== 16 && _ !== 24 && _ !== 32)
                        throw new Error("Only 8, 16, 24, or 32 bits supported: " + _); }
                    function u(_) { if (this.data = "", this.read = 0, typeof _ == "string")
                        this.data = _;
                    else if (t.isArrayBuffer(_) || t.isArrayBufferView(_))
                        if (e !== void 0 && _ instanceof e)
                            this.data = _.toString("binary");
                        else {
                            var k = new Uint8Array(_);
                            try {
                                this.data = String.fromCharCode.apply(null, k);
                            }
                            catch (M) {
                                for (var x = 0; x < k.length; ++x)
                                    this.putByte(k[x]);
                            }
                        }
                    else
                        (_ instanceof u || typeof _ == "object" && typeof _.data == "string" && typeof _.read == "number") && (this.data = _.data, this.read = _.read); this._constructedStringLength = 0; }
                    !function () { if (d !== void 0 && d.nextTick && !d.browser)
                        return t.nextTick = d.nextTick, void (typeof setImmediate == "function" ? t.setImmediate = setImmediate : t.setImmediate = t.nextTick); if (typeof setImmediate == "function")
                        return t.setImmediate = function () { return setImmediate.apply(void 0, arguments); }, void (t.nextTick = function (T) { return setImmediate(T); }); if (t.setImmediate = function (T) { setTimeout(T, 0); }, typeof window != "undefined" && typeof window.postMessage == "function") {
                        var _ = "forge.setImmediate", k = [];
                        t.setImmediate = function (T) { k.push(T), k.length === 1 && window.postMessage(_, "*"); }, window.addEventListener("message", function (T) { if (T.source === window && T.data === _) {
                            T.stopPropagation();
                            var B = k.slice();
                            k.length = 0, B.forEach(function (P) { P(); });
                        } }, !0);
                    } if (typeof MutationObserver != "undefined") {
                        var x = Date.now(), M = !0, N = document.createElement("div");
                        k = [], new MutationObserver(function () { var T = k.slice(); k.length = 0, T.forEach(function (B) { B(); }); }).observe(N, { attributes: !0 });
                        var S = t.setImmediate;
                        t.setImmediate = function (T) { Date.now() - x > 15 ? (x = Date.now(), S(T)) : (k.push(T), k.length === 1 && N.setAttribute("a", M = !M)); };
                    } t.nextTick = t.setImmediate; }(), t.isNodejs = d !== void 0 && d.versions && d.versions.node, t.globalScope = t.isNodejs ? r : typeof self == "undefined" ? window : self, t.isArray = Array.isArray || function (_) { return Object.prototype.toString.call(_) === "[object Array]"; }, t.isArrayBuffer = function (_) { return typeof ArrayBuffer != "undefined" && _ instanceof ArrayBuffer; }, t.isArrayBufferView = function (_) { return _ && t.isArrayBuffer(_.buffer) && _.byteLength !== void 0; }, t.ByteBuffer = u, t.ByteStringBuffer = u, t.ByteStringBuffer.prototype._optimizeConstructedString = function (_) { this._constructedStringLength += _, this._constructedStringLength > 4096 && (this.data.substr(0, 1), this._constructedStringLength = 0); }, t.ByteStringBuffer.prototype.length = function () { return this.data.length - this.read; }, t.ByteStringBuffer.prototype.isEmpty = function () { return this.length() <= 0; }, t.ByteStringBuffer.prototype.putByte = function (_) { return this.putBytes(String.fromCharCode(_)); }, t.ByteStringBuffer.prototype.fillWithByte = function (_, k) { _ = String.fromCharCode(_); for (var x = this.data; k > 0;)
                        1 & k && (x += _), (k >>>= 1) > 0 && (_ += _); return this.data = x, this._optimizeConstructedString(k), this; }, t.ByteStringBuffer.prototype.putBytes = function (_) { return this.data += _, this._optimizeConstructedString(_.length), this; }, t.ByteStringBuffer.prototype.putString = function (_) { return this.putBytes(t.encodeUtf8(_)); }, t.ByteStringBuffer.prototype.putInt16 = function (_) { return this.putBytes(String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(255 & _)); }, t.ByteStringBuffer.prototype.putInt24 = function (_) { return this.putBytes(String.fromCharCode(_ >> 16 & 255) + String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(255 & _)); }, t.ByteStringBuffer.prototype.putInt32 = function (_) { return this.putBytes(String.fromCharCode(_ >> 24 & 255) + String.fromCharCode(_ >> 16 & 255) + String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(255 & _)); }, t.ByteStringBuffer.prototype.putInt16Le = function (_) { return this.putBytes(String.fromCharCode(255 & _) + String.fromCharCode(_ >> 8 & 255)); }, t.ByteStringBuffer.prototype.putInt24Le = function (_) { return this.putBytes(String.fromCharCode(255 & _) + String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(_ >> 16 & 255)); }, t.ByteStringBuffer.prototype.putInt32Le = function (_) { return this.putBytes(String.fromCharCode(255 & _) + String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(_ >> 16 & 255) + String.fromCharCode(_ >> 24 & 255)); }, t.ByteStringBuffer.prototype.putInt = function (_, k) { s(k); var x = ""; do
                        k -= 8, x += String.fromCharCode(_ >> k & 255);
                    while (k > 0); return this.putBytes(x); }, t.ByteStringBuffer.prototype.putSignedInt = function (_, k) { return _ < 0 && (_ += 2 << k - 1), this.putInt(_, k); }, t.ByteStringBuffer.prototype.putBuffer = function (_) { return this.putBytes(_.getBytes()); }, t.ByteStringBuffer.prototype.getByte = function () { return this.data.charCodeAt(this.read++); }, t.ByteStringBuffer.prototype.getInt16 = function () { var _ = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1); return this.read += 2, _; }, t.ByteStringBuffer.prototype.getInt24 = function () { var _ = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2); return this.read += 3, _; }, t.ByteStringBuffer.prototype.getInt32 = function () { var _ = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3); return this.read += 4, _; }, t.ByteStringBuffer.prototype.getInt16Le = function () { var _ = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8; return this.read += 2, _; }, t.ByteStringBuffer.prototype.getInt24Le = function () { var _ = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16; return this.read += 3, _; }, t.ByteStringBuffer.prototype.getInt32Le = function () { var _ = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24; return this.read += 4, _; }, t.ByteStringBuffer.prototype.getInt = function (_) { s(_); var k = 0; do
                        k = (k << 8) + this.data.charCodeAt(this.read++), _ -= 8;
                    while (_ > 0); return k; }, t.ByteStringBuffer.prototype.getSignedInt = function (_) { var k = this.getInt(_), x = 2 << _ - 2; return k >= x && (k -= x << 1), k; }, t.ByteStringBuffer.prototype.getBytes = function (_) { var k; return _ ? (_ = Math.min(this.length(), _), k = this.data.slice(this.read, this.read + _), this.read += _) : _ === 0 ? k = "" : (k = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), k; }, t.ByteStringBuffer.prototype.bytes = function (_) { return _ === void 0 ? this.data.slice(this.read) : this.data.slice(this.read, this.read + _); }, t.ByteStringBuffer.prototype.at = function (_) { return this.data.charCodeAt(this.read + _); }, t.ByteStringBuffer.prototype.setAt = function (_, k) { return this.data = this.data.substr(0, this.read + _) + String.fromCharCode(k) + this.data.substr(this.read + _ + 1), this; }, t.ByteStringBuffer.prototype.last = function () { return this.data.charCodeAt(this.data.length - 1); }, t.ByteStringBuffer.prototype.copy = function () { var _ = t.createBuffer(this.data); return _.read = this.read, _; }, t.ByteStringBuffer.prototype.compact = function () { return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this; }, t.ByteStringBuffer.prototype.clear = function () { return this.data = "", this.read = 0, this; }, t.ByteStringBuffer.prototype.truncate = function (_) { var k = Math.max(0, this.length() - _); return this.data = this.data.substr(this.read, k), this.read = 0, this; }, t.ByteStringBuffer.prototype.toHex = function () { for (var _ = "", k = this.read; k < this.data.length; ++k) {
                        var x = this.data.charCodeAt(k);
                        x < 16 && (_ += "0"), _ += x.toString(16);
                    } return _; }, t.ByteStringBuffer.prototype.toString = function () { return t.decodeUtf8(this.bytes()); }, t.DataBuffer = function (_, k) { k = k || {}, this.read = k.readOffset || 0, this.growSize = k.growSize || 1024; var x = t.isArrayBuffer(_), M = t.isArrayBufferView(_); if (x || M)
                        return this.data = x ? new DataView(_) : new DataView(_.buffer, _.byteOffset, _.byteLength), void (this.write = "writeOffset" in k ? k.writeOffset : this.data.byteLength); this.data = new DataView(new ArrayBuffer(0)), this.write = 0, _ != null && this.putBytes(_), "writeOffset" in k && (this.write = k.writeOffset); }, t.DataBuffer.prototype.length = function () { return this.write - this.read; }, t.DataBuffer.prototype.isEmpty = function () { return this.length() <= 0; }, t.DataBuffer.prototype.accommodate = function (_, k) { if (this.length() >= _)
                        return this; k = Math.max(k || this.growSize, _); var x = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength), M = new Uint8Array(this.length() + k); return M.set(x), this.data = new DataView(M.buffer), this; }, t.DataBuffer.prototype.putByte = function (_) { return this.accommodate(1), this.data.setUint8(this.write++, _), this; }, t.DataBuffer.prototype.fillWithByte = function (_, k) { this.accommodate(k); for (var x = 0; x < k; ++x)
                        this.data.setUint8(_); return this; }, t.DataBuffer.prototype.putBytes = function (_, k) { if (t.isArrayBufferView(_)) {
                        var x = (M = new Uint8Array(_.buffer, _.byteOffset, _.byteLength)).byteLength - M.byteOffset;
                        return this.accommodate(x), new Uint8Array(this.data.buffer, this.write).set(M), this.write += x, this;
                    } if (t.isArrayBuffer(_)) {
                        var M = new Uint8Array(_);
                        return this.accommodate(M.byteLength), new Uint8Array(this.data.buffer).set(M, this.write), this.write += M.byteLength, this;
                    } if (_ instanceof t.DataBuffer || typeof _ == "object" && typeof _.read == "number" && typeof _.write == "number" && t.isArrayBufferView(_.data))
                        return M = new Uint8Array(_.data.byteLength, _.read, _.length()), this.accommodate(M.byteLength), new Uint8Array(_.data.byteLength, this.write).set(M), this.write += M.byteLength, this; if (_ instanceof t.ByteStringBuffer && (_ = _.data, k = "binary"), k = k || "binary", typeof _ == "string") {
                        var N;
                        if (k === "hex")
                            return this.accommodate(Math.ceil(_.length / 2)), N = new Uint8Array(this.data.buffer, this.write), this.write += t.binary.hex.decode(_, N, this.write), this;
                        if (k === "base64")
                            return this.accommodate(3 * Math.ceil(_.length / 4)), N = new Uint8Array(this.data.buffer, this.write), this.write += t.binary.base64.decode(_, N, this.write), this;
                        if (k === "utf8" && (_ = t.encodeUtf8(_), k = "binary"), k === "binary" || k === "raw")
                            return this.accommodate(_.length), N = new Uint8Array(this.data.buffer, this.write), this.write += t.binary.raw.decode(N), this;
                        if (k === "utf16")
                            return this.accommodate(2 * _.length), N = new Uint16Array(this.data.buffer, this.write), this.write += t.text.utf16.encode(N), this;
                        throw new Error("Invalid encoding: " + k);
                    } throw Error("Invalid parameter: " + _); }, t.DataBuffer.prototype.putBuffer = function (_) { return this.putBytes(_), _.clear(), this; }, t.DataBuffer.prototype.putString = function (_) { return this.putBytes(_, "utf16"); }, t.DataBuffer.prototype.putInt16 = function (_) { return this.accommodate(2), this.data.setInt16(this.write, _), this.write += 2, this; }, t.DataBuffer.prototype.putInt24 = function (_) { return this.accommodate(3), this.data.setInt16(this.write, _ >> 8 & 65535), this.data.setInt8(this.write, _ >> 16 & 255), this.write += 3, this; }, t.DataBuffer.prototype.putInt32 = function (_) { return this.accommodate(4), this.data.setInt32(this.write, _), this.write += 4, this; }, t.DataBuffer.prototype.putInt16Le = function (_) { return this.accommodate(2), this.data.setInt16(this.write, _, !0), this.write += 2, this; }, t.DataBuffer.prototype.putInt24Le = function (_) { return this.accommodate(3), this.data.setInt8(this.write, _ >> 16 & 255), this.data.setInt16(this.write, _ >> 8 & 65535, !0), this.write += 3, this; }, t.DataBuffer.prototype.putInt32Le = function (_) { return this.accommodate(4), this.data.setInt32(this.write, _, !0), this.write += 4, this; }, t.DataBuffer.prototype.putInt = function (_, k) { s(k), this.accommodate(k / 8); do
                        k -= 8, this.data.setInt8(this.write++, _ >> k & 255);
                    while (k > 0); return this; }, t.DataBuffer.prototype.putSignedInt = function (_, k) { return s(k), this.accommodate(k / 8), _ < 0 && (_ += 2 << k - 1), this.putInt(_, k); }, t.DataBuffer.prototype.getByte = function () { return this.data.getInt8(this.read++); }, t.DataBuffer.prototype.getInt16 = function () { var _ = this.data.getInt16(this.read); return this.read += 2, _; }, t.DataBuffer.prototype.getInt24 = function () { var _ = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2); return this.read += 3, _; }, t.DataBuffer.prototype.getInt32 = function () { var _ = this.data.getInt32(this.read); return this.read += 4, _; }, t.DataBuffer.prototype.getInt16Le = function () { var _ = this.data.getInt16(this.read, !0); return this.read += 2, _; }, t.DataBuffer.prototype.getInt24Le = function () { var _ = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8; return this.read += 3, _; }, t.DataBuffer.prototype.getInt32Le = function () { var _ = this.data.getInt32(this.read, !0); return this.read += 4, _; }, t.DataBuffer.prototype.getInt = function (_) { s(_); var k = 0; do
                        k = (k << 8) + this.data.getInt8(this.read++), _ -= 8;
                    while (_ > 0); return k; }, t.DataBuffer.prototype.getSignedInt = function (_) { var k = this.getInt(_), x = 2 << _ - 2; return k >= x && (k -= x << 1), k; }, t.DataBuffer.prototype.getBytes = function (_) { var k; return _ ? (_ = Math.min(this.length(), _), k = this.data.slice(this.read, this.read + _), this.read += _) : _ === 0 ? k = "" : (k = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), k; }, t.DataBuffer.prototype.bytes = function (_) { return _ === void 0 ? this.data.slice(this.read) : this.data.slice(this.read, this.read + _); }, t.DataBuffer.prototype.at = function (_) { return this.data.getUint8(this.read + _); }, t.DataBuffer.prototype.setAt = function (_, k) { return this.data.setUint8(_, k), this; }, t.DataBuffer.prototype.last = function () { return this.data.getUint8(this.write - 1); }, t.DataBuffer.prototype.copy = function () { return new t.DataBuffer(this); }, t.DataBuffer.prototype.compact = function () { if (this.read > 0) {
                        var _ = new Uint8Array(this.data.buffer, this.read), k = new Uint8Array(_.byteLength);
                        k.set(_), this.data = new DataView(k), this.write -= this.read, this.read = 0;
                    } return this; }, t.DataBuffer.prototype.clear = function () { return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this; }, t.DataBuffer.prototype.truncate = function (_) { return this.write = Math.max(0, this.length() - _), this.read = Math.min(this.read, this.write), this; }, t.DataBuffer.prototype.toHex = function () { for (var _ = "", k = this.read; k < this.data.byteLength; ++k) {
                        var x = this.data.getUint8(k);
                        x < 16 && (_ += "0"), _ += x.toString(16);
                    } return _; }, t.DataBuffer.prototype.toString = function (_) { var k = new Uint8Array(this.data, this.read, this.length()); if ((_ = _ || "utf8") === "binary" || _ === "raw")
                        return t.binary.raw.encode(k); if (_ === "hex")
                        return t.binary.hex.encode(k); if (_ === "base64")
                        return t.binary.base64.encode(k); if (_ === "utf8")
                        return t.text.utf8.decode(k); if (_ === "utf16")
                        return t.text.utf16.decode(k); throw new Error("Invalid encoding: " + _); }, t.createBuffer = function (_, k) { return k = k || "raw", _ !== void 0 && k === "utf8" && (_ = t.encodeUtf8(_)), new t.ByteBuffer(_); }, t.fillString = function (_, k) { for (var x = ""; k > 0;)
                        1 & k && (x += _), (k >>>= 1) > 0 && (_ += _); return x; }, t.xorBytes = function (_, k, x) { for (var M = "", N = "", S = "", T = 0, B = 0; x > 0; --x, ++T)
                        N = _.charCodeAt(T) ^ k.charCodeAt(T), B >= 10 && (M += S, S = "", B = 0), S += String.fromCharCode(N), ++B; return M += S; }, t.hexToBytes = function (_) { var k = "", x = 0; for (!0 & _.length && (x = 1, k += String.fromCharCode(parseInt(_[0], 16))); x < _.length; x += 2)
                        k += String.fromCharCode(parseInt(_.substr(x, 2), 16)); return k; }, t.bytesToHex = function (_) { return t.createBuffer(_).toHex(); }, t.int32ToBytes = function (_) { return String.fromCharCode(_ >> 24 & 255) + String.fromCharCode(_ >> 16 & 255) + String.fromCharCode(_ >> 8 & 255) + String.fromCharCode(255 & _); };
                    var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", o = [62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], h = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
                    t.encode64 = function (_, k) {
                        for (var x, M, N, S = "", T = "", B = 0; B < _.length;)
                            x = _.charCodeAt(B++), M = _.charCodeAt(B++), N = _.charCodeAt(B++), S += i.charAt(x >> 2), S += i.charAt((3 & x) << 4 | M >> 4), isNaN(M) ? S += "==" : (S += i.charAt((15 & M) << 2 | N >> 6), S += isNaN(N) ? "=" : i.charAt(63 & N)), k && S.length > k && (T += S.substr(0, k) + `\r
`, S = S.substr(k));
                        return T += S;
                    }, t.decode64 = function (_) { _ = _.replace(/[^A-Za-z0-9\+\/\=]/g, ""); for (var k, x, M, N, S = "", T = 0; T < _.length;)
                        k = o[_.charCodeAt(T++) - 43], x = o[_.charCodeAt(T++) - 43], M = o[_.charCodeAt(T++) - 43], N = o[_.charCodeAt(T++) - 43], S += String.fromCharCode(k << 2 | x >> 4), M !== 64 && (S += String.fromCharCode((15 & x) << 4 | M >> 2), N !== 64 && (S += String.fromCharCode((3 & M) << 6 | N))); return S; }, t.encodeUtf8 = function (_) { return unescape(encodeURIComponent(_)); }, t.decodeUtf8 = function (_) { return decodeURIComponent(escape(_)); }, t.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: n.encode, decode: n.decode } }, t.binary.raw.encode = function (_) { return String.fromCharCode.apply(null, _); }, t.binary.raw.decode = function (_, k, x) { var M = k; M || (M = new Uint8Array(_.length)); for (var N = x = x || 0, S = 0; S < _.length; ++S)
                        M[N++] = _.charCodeAt(S); return k ? N - x : M; }, t.binary.hex.encode = t.bytesToHex, t.binary.hex.decode = function (_, k, x) { var M = k; M || (M = new Uint8Array(Math.ceil(_.length / 2))); var N = 0, S = x = x || 0; for (1 & _.length && (N = 1, M[S++] = parseInt(_[0], 16)); N < _.length; N += 2)
                        M[S++] = parseInt(_.substr(N, 2), 16); return k ? S - x : M; }, t.binary.base64.encode = function (_, k) {
                        for (var x, M, N, S = "", T = "", B = 0; B < _.byteLength;)
                            x = _[B++], M = _[B++], N = _[B++], S += i.charAt(x >> 2), S += i.charAt((3 & x) << 4 | M >> 4), isNaN(M) ? S += "==" : (S += i.charAt((15 & M) << 2 | N >> 6), S += isNaN(N) ? "=" : i.charAt(63 & N)), k && S.length > k && (T += S.substr(0, k) + `\r
`, S = S.substr(k));
                        return T += S;
                    }, t.binary.base64.decode = function (_, k, x) { var M, N, S, T, B = k; B || (B = new Uint8Array(3 * Math.ceil(_.length / 4))), _ = _.replace(/[^A-Za-z0-9\+\/\=]/g, ""); for (var P = 0, L = x = x || 0; P < _.length;)
                        M = o[_.charCodeAt(P++) - 43], N = o[_.charCodeAt(P++) - 43], S = o[_.charCodeAt(P++) - 43], T = o[_.charCodeAt(P++) - 43], B[L++] = M << 2 | N >> 4, S !== 64 && (B[L++] = (15 & N) << 4 | S >> 2, T !== 64 && (B[L++] = (3 & S) << 6 | T)); return k ? L - x : B.subarray(0, L); }, t.binary.base58.encode = function (_, k) { return t.binary.baseN.encode(_, h, k); }, t.binary.base58.decode = function (_, k) { return t.binary.baseN.decode(_, h, k); }, t.text = { utf8: {}, utf16: {} }, t.text.utf8.encode = function (_, k, x) { _ = t.encodeUtf8(_); var M = k; M || (M = new Uint8Array(_.length)); for (var N = x = x || 0, S = 0; S < _.length; ++S)
                        M[N++] = _.charCodeAt(S); return k ? N - x : M; }, t.text.utf8.decode = function (_) { return t.decodeUtf8(String.fromCharCode.apply(null, _)); }, t.text.utf16.encode = function (_, k, x) { var M = k; M || (M = new Uint8Array(2 * _.length)); for (var N = new Uint16Array(M.buffer), S = x = x || 0, T = x, B = 0; B < _.length; ++B)
                        N[T++] = _.charCodeAt(B), S += 2; return k ? S - x : M; }, t.text.utf16.decode = function (_) { return String.fromCharCode.apply(null, new Uint16Array(_.buffer)); }, t.deflate = function (_, k, x) { if (k = t.decode64(_.deflate(t.encode64(k)).rval), x) {
                        var M = 2;
                        32 & k.charCodeAt(1) && (M = 6), k = k.substring(M, k.length - 4);
                    } return k; }, t.inflate = function (_, k, x) { var M = _.inflate(t.encode64(k)).rval; return M === null ? null : t.decode64(M); };
                    var a = function (_, k, x) { if (!_)
                        throw new Error("WebStorage not available."); var M; if (x === null ? M = _.removeItem(k) : (x = t.encode64(JSON.stringify(x)), M = _.setItem(k, x)), M !== void 0 && M.rval !== !0) {
                        var N = new Error(M.error.message);
                        throw N.id = M.error.id, N.name = M.error.name, N;
                    } }, l = function (_, k) { if (!_)
                        throw new Error("WebStorage not available."); var x = _.getItem(k); if (_.init)
                        if (x.rval === null) {
                            if (x.error) {
                                var M = new Error(x.error.message);
                                throw M.id = x.error.id, M.name = x.error.name, M;
                            }
                            x = null;
                        }
                        else
                            x = x.rval; return x !== null && (x = JSON.parse(t.decode64(x))), x; }, p = function (_, k, x, M) { var N = l(_, k); N === null && (N = {}), N[x] = M, a(_, k, N); }, g = function (_, k, x) { var M = l(_, k); return M !== null && (M = x in M ? M[x] : null), M; }, b = function (_, k, x) { var M = l(_, k); if (M !== null && x in M) {
                        delete M[x];
                        var N = !0;
                        for (var S in M) {
                            N = !1;
                            break;
                        }
                        N && (M = null), a(_, k, M);
                    } }, I = function (_, k) { a(_, k, null); }, v = function (_, k, x) { var M, N = null; x === void 0 && (x = ["web", "flash"]); var S = !1, T = null; for (var B in x) {
                        M = x[B];
                        try {
                            if (M === "flash" || M === "both") {
                                if (k[0] === null)
                                    throw new Error("Flash local storage not available.");
                                N = _.apply(this, k), S = M === "flash";
                            }
                            M !== "web" && M !== "both" || (k[0] = localStorage, N = _.apply(this, k), S = !0);
                        }
                        catch (P) {
                            T = P;
                        }
                        if (S)
                            break;
                    } if (!S)
                        throw T; return N; };
                    t.setItem = function (_, k, x, M, N) { v(p, arguments, N); }, t.getItem = function (_, k, x, M) { return v(g, arguments, M); }, t.removeItem = function (_, k, x, M) { v(b, arguments, M); }, t.clearItems = function (_, k, x) { v(I, arguments, x); }, t.parseUrl = function (_) { var k = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g; k.lastIndex = 0; var x = k.exec(_), M = x === null ? null : { full: _, scheme: x[1], host: x[2], port: x[3], path: x[4] }; return M && (M.fullHost = M.host, M.port ? (M.port !== 80 && M.scheme === "http" || M.port !== 443 && M.scheme === "https") && (M.fullHost += ":" + M.port) : M.scheme === "http" ? M.port = 80 : M.scheme === "https" && (M.port = 443), M.full = M.scheme + "://" + M.fullHost), M; };
                    var R = null;
                    t.getQueryVariables = function (_) { var k, x = function (M) { for (var N = {}, S = M.split("&"), T = 0; T < S.length; T++) {
                        var B, P, L = S[T].indexOf("=");
                        L > 0 ? (B = S[T].substring(0, L), P = S[T].substring(L + 1)) : (B = S[T], P = null), B in N || (N[B] = []), B in Object.prototype || P === null || N[B].push(unescape(P));
                    } return N; }; return _ === void 0 ? (R === null && (R = typeof window != "undefined" && window.location && window.location.search ? x(window.location.search.substring(1)) : {}), k = R) : k = x(_), k; }, t.parseFragment = function (_) { var k = _, x = "", M = _.indexOf("?"); M > 0 && (k = _.substring(0, M), x = _.substring(M + 1)); var N = k.split("/"); return N.length > 0 && N[0] === "" && N.shift(), { pathString: k, queryString: x, path: N, query: x === "" ? {} : t.getQueryVariables(x) }; }, t.makeRequest = function (_) { var k = t.parseFragment(_), x = { path: k.pathString, query: k.queryString, getPath: function (M) { return M === void 0 ? k.path : k.path[M]; }, getQuery: function (M, N) { var S; return M === void 0 ? S = k.query : (S = k.query[M]) && N !== void 0 && (S = S[N]), S; }, getQueryLast: function (M, N) { var S = x.getQuery(M); return S ? S[S.length - 1] : N; } }; return x; }, t.makeLink = function (_, k, x) { _ = jQuery.isArray(_) ? _.join("/") : _; var M = jQuery.param(k || {}); return x = x || "", _ + (M.length > 0 ? "?" + M : "") + (x.length > 0 ? "#" + x : ""); }, t.setPath = function (_, k, x) { if (typeof _ == "object" && _ !== null)
                        for (var M = 0, N = k.length; M < N;) {
                            var S = k[M++];
                            if (M == N)
                                _[S] = x;
                            else {
                                var T = S in _;
                                (!T || T && typeof _[S] != "object" || T && _[S] === null) && (_[S] = {}), _ = _[S];
                            }
                        } }, t.getPath = function (_, k, x) { for (var M = 0, N = k.length, S = !0; S && M < N && typeof _ == "object" && _ !== null;) {
                        var T = k[M++];
                        (S = T in _) && (_ = _[T]);
                    } return S ? _ : x; }, t.deletePath = function (_, k) { if (typeof _ == "object" && _ !== null)
                        for (var x = 0, M = k.length; x < M;) {
                            var N = k[x++];
                            if (x == M)
                                delete _[N];
                            else {
                                if (!(N in _) || typeof _[N] != "object" || _[N] === null)
                                    break;
                                _ = _[N];
                            }
                        } }, t.isEmpty = function (_) { for (var k in _)
                        if (_.hasOwnProperty(k))
                            return !1; return !0; }, t.format = function (_) { for (var k, x, M = /%./g, N = 0, S = [], T = 0; k = M.exec(_);) {
                        (x = _.substring(T, M.lastIndex - 2)).length > 0 && S.push(x), T = M.lastIndex;
                        var B = k[0][1];
                        switch (B) {
                            case "s":
                            case "o":
                                N < arguments.length ? S.push(arguments[1 + N++]) : S.push("<?>");
                                break;
                            case "%":
                                S.push("%");
                                break;
                            default: S.push("<%" + B + "?>");
                        }
                    } return S.push(_.substring(T)), S.join(""); }, t.formatNumber = function (_, k, x, M) { var N = _, S = isNaN(k = Math.abs(k)) ? 2 : k, T = x === void 0 ? "," : x, B = M === void 0 ? "." : M, P = N < 0 ? "-" : "", L = parseInt(N = Math.abs(+N || 0).toFixed(S), 10) + "", j = L.length > 3 ? L.length % 3 : 0; return P + (j ? L.substr(0, j) + B : "") + L.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + B) + (S ? T + Math.abs(N - L).toFixed(S).slice(2) : ""); }, t.formatSize = function (_) { return _ = _ >= 1073741824 ? t.formatNumber(_ / 1073741824, 2, ".", "") + " GiB" : _ >= 1048576 ? t.formatNumber(_ / 1048576, 2, ".", "") + " MiB" : _ >= 1024 ? t.formatNumber(_ / 1024, 0) + " KiB" : t.formatNumber(_, 0) + " bytes"; }, t.bytesFromIP = function (_) { return _.indexOf(".") !== -1 ? t.bytesFromIPv4(_) : _.indexOf(":") !== -1 ? t.bytesFromIPv6(_) : null; }, t.bytesFromIPv4 = function (_) { if ((_ = _.split(".")).length !== 4)
                        return null; for (var k = t.createBuffer(), x = 0; x < _.length; ++x) {
                        var M = parseInt(_[x], 10);
                        if (isNaN(M))
                            return null;
                        k.putByte(M);
                    } return k.getBytes(); }, t.bytesFromIPv6 = function (_) { for (var k = 0, x = 2 * (8 - (_ = _.split(":").filter(function (T) { return T.length === 0 && ++k, !0; })).length + k), M = t.createBuffer(), N = 0; N < 8; ++N)
                        if (_[N] && _[N].length !== 0) {
                            var S = t.hexToBytes(_[N]);
                            S.length < 2 && M.putByte(0), M.putBytes(S);
                        }
                        else
                            M.fillWithByte(0, x), x = 0; return M.getBytes(); }, t.bytesToIP = function (_) { return _.length === 4 ? t.bytesToIPv4(_) : _.length === 16 ? t.bytesToIPv6(_) : null; }, t.bytesToIPv4 = function (_) { if (_.length !== 4)
                        return null; for (var k = [], x = 0; x < _.length; ++x)
                        k.push(_.charCodeAt(x)); return k.join("."); }, t.bytesToIPv6 = function (_) { if (_.length !== 16)
                        return null; for (var k = [], x = [], M = 0, N = 0; N < _.length; N += 2) {
                        for (var S = t.bytesToHex(_[N] + _[N + 1]); S[0] === "0" && S !== "0";)
                            S = S.substr(1);
                        if (S === "0") {
                            var T = x[x.length - 1], B = k.length;
                            T && B === T.end + 1 ? (T.end = B, T.end - T.start > x[M].end - x[M].start && (M = x.length - 1)) : x.push({ start: B, end: B });
                        }
                        k.push(S);
                    } if (x.length > 0) {
                        var P = x[M];
                        P.end - P.start > 0 && (k.splice(P.start, P.end - P.start + 1, ""), P.start === 0 && k.unshift(""), P.end === 7 && k.push(""));
                    } return k.join(":"); }, t.estimateCores = function (_, k) { if (typeof _ == "function" && (k = _, _ = {}), _ = _ || {}, "cores" in t && !_.update)
                        return k(null, t.cores); if (typeof navigator != "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
                        return t.cores = navigator.hardwareConcurrency, k(null, t.cores); if (typeof Worker == "undefined")
                        return t.cores = 1, k(null, t.cores); if (typeof Blob == "undefined")
                        return t.cores = 2, k(null, t.cores); var x = URL.createObjectURL(new Blob(["(", function () { self.addEventListener("message", function (M) { for (var N = Date.now(), S = N + 4; Date.now() < S;)
                            ; self.postMessage({ st: N, et: S }); }); }.toString(), ")()"], { type: "application/javascript" })); !function M(N, S, T) { if (S === 0) {
                        var B = Math.floor(N.reduce(function (P, L) { return P + L; }, 0) / N.length);
                        return t.cores = Math.max(1, B), URL.revokeObjectURL(x), k(null, t.cores);
                    } !function (P, L) { for (var j = [], D = [], G = 0; G < P; ++G) {
                        var W = new Worker(x);
                        W.addEventListener("message", function (X) { if (D.push(X.data), D.length === P) {
                            for (var Q = 0; Q < P; ++Q)
                                j[Q].terminate();
                            L(null, D);
                        } }), j.push(W);
                    } for (G = 0; G < P; ++G)
                        j[G].postMessage(G); }(T, function (P, L) { N.push(function (j, D) { for (var G = [], W = 0; W < j; ++W)
                        for (var X = D[W], Q = G[W] = [], K = 0; K < j; ++K)
                            if (W !== K) {
                                var F = D[K];
                                (X.st > F.st && X.st < F.et || F.st > X.st && F.st < X.et) && Q.push(K);
                            } return G.reduce(function (Y, $) { return Math.max(Y, $.length); }, 0); }(T, L)), M(N, S - 1, T); }); }([], 5, 16); };
                }).call(this, f(9), f(10), f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                typeof Object.create == "function" ? E.exports = function (d, r) { r && (d.super_ = r, d.prototype = Object.create(r.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } })); } : E.exports = function (d, r) { if (r) {
                    d.super_ = r;
                    var e = function () { };
                    e.prototype = r.prototype, d.prototype = new e, d.prototype.constructor = d;
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(48), e = f(508), c = f(20);
                async function n(t, s, u) { const i = await n.digest(t, s, u); return r.encode(i, s, u); }
                n.multihash = r, n.digest = async (t, s, u) => { const i = n.createHash(s), o = await i(t); return u ? o.slice(0, u) : o; }, n.createHash = function (t) { if (!t)
                    throw d(new Error("hash algorithm must be specified"), "ERR_HASH_ALGORITHM_NOT_SPECIFIED"); if (t = r.coerceCode(t), !n.functions[t])
                    throw d(new Error(`multihash function '${t}' not yet supported`), "ERR_HASH_ALGORITHM_NOT_SUPPORTED"); return n.functions[t]; }, n.functions = { 0: e.identity, 17: e.sha1, 18: e.sha2256, 19: e.sha2512, 20: e.sha3512, 21: e.sha3384, 22: e.sha3256, 23: e.sha3224, 24: e.shake128, 25: e.shake256, 26: e.keccak224, 27: e.keccak256, 28: e.keccak384, 29: e.keccak512, 34: e.murmur3128, 35: e.murmur332, 86: e.dblSha2256 }, e.addBlake(n.functions), n.validate = async (t, s) => { const u = await n(t, r.decode(s).name); return c(s, u); }, E.exports = n;
            }, function (E, m, f) {
                "use strict";
                m.DAGNode = f(527), m.DAGLink = f(256), m.resolver = f(533), m.util = f(257), m.codec = m.util.codec, m.defaultHashAlg = m.util.defaultHashAlg;
            }, function (E, m, f) {
                "use strict";
                const d = f(223), r = f(417), e = f(418), c = f(224), n = f(31), t = f(419), s = f(420);
                E.exports = { addPrefix: function (u, i) { let o; if (u instanceof Uint8Array)
                        o = c.varintUint8ArrayEncode(u);
                    else {
                        if (!e[u])
                            throw new Error("multicodec not recognized");
                        o = e[u];
                    } return n([o, i], o.length + i.length); }, rmPrefix: function (u) { return d.decode(u), u.slice(d.decode.bytes); }, getCodec: function (u) { const i = d.decode(u), o = r.get(i); if (o === void 0)
                        throw new Error(`Code ${i} not found`); return o; }, getName: function (u) { return r.get(u); }, getNumber: function (u) { const i = e[u]; if (i === void 0)
                        throw new Error("Codec `" + u + "` not found"); return d.decode(i); }, getCode: function (u) { return d.decode(u); }, getCodeVarint: function (u) { const i = e[u]; if (i === void 0)
                        throw new Error("Codec `" + u + "` not found"); return i; }, getVarint: function (u) { return d.encode(u); }, print: s, ...t };
            }, function (E, m, f) {
                "use strict";
                E.exports = { encode: f(429), decode: f(430), encodingLength: f(431) };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { if (d === r)
                    return !0; if (d.byteLength !== r.byteLength)
                    return !1; for (let e = 0; e < d.byteLength; e++)
                    if (d[e] !== r[e])
                        return !1; return !0; };
            }, function (E, m, f) {
                "use strict";
                var d = f(422), r = f(426);
                E.exports = function (e, c) { if (c || (c = {}), !e)
                    throw new Error("Pass in a .proto string or a protobuf-schema parsed object"); var n = typeof e != "object" || e instanceof Uint8Array ? d.parse(e) : e, t = function () { var s = this; r(n, c.encodings || {}).forEach(function (u) { s[u.name] = function (i) { if (!i)
                    return null; var o = {}; return Object.keys(i).forEach(function (h) { o[h] = i[h].value; }), o; }(u.values) || u; }); }; return t.prototype.toString = function () { return d.stringify(n); }, t.prototype.toJSON = function () { return n; }, new t; };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(16), e = r.multihash, { Key: c } = f(11), n = f(1041), t = f(212), s = f(213), { Record: u } = f(66), i = f(7), o = f(0), h = f(31), a = f(6), l = f(5);
                m.convertBuffer = p => r.digest(p, "sha2-256"), m.convertPeerId = p => r.digest(p.id, "sha2-256"), m.bufferToKey = p => new c("/" + m.encodeBase32(p), !1), m.keyForPublicKey = p => h([a("/pk/"), p.id]), m.isPublicKeyKey = p => l(p.slice(0, 4)) === "/pk/", m.fromPublicKeyKey = p => new i(p.slice(4)), m.now = () => Date.now(), m.encodeBase32 = p => new n.Encoder().write(p).finalize(), m.decodeBase32 = p => { const g = new n.Decoder; return Uint8Array.from(g.write(p).finalize()); }, m.sortClosestPeers = async (p, g) => (await s(p, async (b) => { const I = await m.convertPeerId(b); return { peer: b, distance: t(I, g) }; })).sort(m.xorCompare).map(b => b.peer), m.xorCompare = (p, g) => t.compare(p.distance, g.distance), m.pathSize = (p, g) => Math.ceil(p / g), m.createPutRecord = (p, g) => { const b = new Date; return new u(p, g, b).serialize(); }, m.logger = (p, g) => { const b = ["libp2p", "dht"]; g && b.push(g), p && b.push("" + p.toB58String().slice(0, 8)), d.formatters.b = v => e.toB58String(v); const I = d(b.join(":")); return I.error = d(b.concat(["error"]).join(":")), I; }, m.TimeoutError = class extends Error {
                    get code() { return "ETIMEDOUT"; }
                }, m.withTimeout = (p, g) => async (...b) => Promise.race([p(...b), new Promise((I, v) => { setTimeout(() => { v(o(new Error("Async function did not complete before timeout"), "ETIMEDOUT")); }, g); })]), m.mapParallel = async function (p, g) { const b = []; for await (const I of p)
                    b.push(g(I)); return Promise.all(b); };
            }, function (E, m, f) {
                "use strict";
                const d = f(52), r = f(4), e = f(11).Key, c = f(0), n = f(110), t = f(2), s = f(24);
                m.mergeOptions = s, m.OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.", m.MFS_ROOT_KEY = new e("/local/filesroot"), m.MFS_MAX_CHUNK_SIZE = 262144, m.MFS_MAX_LINKS = 174;
                const u = t(async (i, o) => await i);
                m.normalizePath = i => { if (d.cid(i))
                    return "/ipfs/" + new r(i); if (d.path(i))
                    return i; throw c(new Error("invalid path: " + i), "ERR_BAD_PATH"); }, m.normalizeCidPath = i => i instanceof Uint8Array ? new r(i).toString() : r.isCID(i) ? i.toString() : (i.indexOf("/ipfs/") === 0 && (i = i.substring("/ipfs/".length)), i.charAt(i.length - 1) === "/" && (i = i.substring(0, i.length - 1)), i), m.resolvePath = async function (i, o, h = {}) { if (d.cid(o))
                    return new r(o); const { cid: a, path: l } = n(o); return l ? (await i.resolve(a, { ...h, path: l })).cid : a; }, m.mapFile = (i, o = {}) => { const h = { cid: i.cid, path: i.path, name: i.name, depth: i.path.split("/").length, size: 0, type: "file" }; return i.unixfs && (h.type = i.unixfs.type === "directory" ? "dir" : "file", i.unixfs.type === "file" && (h.size = i.unixfs.fileSize(), o.includeContent && (h.content = i.content())), h.mode = i.unixfs.mode, h.mtime = i.unixfs.mtime), h; }, m.withTimeoutOption = t, m.withTimeout = u;
            }, function (E, m, f) {
                "use strict";
                const d = f(134), { hasOwnProperty: r } = Object.prototype, { propertyIsEnumerable: e } = Object, c = (o, h, a) => Object.defineProperty(o, h, { value: a, writable: !0, enumerable: !0, configurable: !0 }), n = { concatArrays: !1, ignoreUndefined: !1 }, t = o => { const h = []; for (const a in o)
                    r.call(o, a) && h.push(a); if (Object.getOwnPropertySymbols) {
                    const a = Object.getOwnPropertySymbols(o);
                    for (const l of a)
                        e.call(o, l) && h.push(l);
                } return h; };
                function s(o) { return Array.isArray(o) ? function (h) { const a = h.slice(0, 0); return t(h).forEach(l => { c(a, l, s(h[l])); }), a; }(o) : d(o) ? function (h) { const a = Object.getPrototypeOf(h) === null ? Object.create(null) : {}; return t(h).forEach(l => { c(a, l, s(h[l])); }), a; }(o) : o; }
                const u = (o, h, a, l) => (a.forEach(p => { h[p] === void 0 && l.ignoreUndefined || (p in o && o[p] !== Object.getPrototypeOf(o) ? c(o, p, i(o[p], h[p], l)) : c(o, p, s(h[p]))); }), o);
                function i(o, h, a) { return a.concatArrays && Array.isArray(o) && Array.isArray(h) ? ((l, p, g) => { let b = l.slice(0, 0), I = 0; return [l, p].forEach(v => { const R = []; for (let _ = 0; _ < v.length; _++)
                    r.call(v, _) && (R.push(String(_)), c(b, I++, v === l ? v[_] : s(v[_]))); b = u(b, v, t(v).filter(_ => !R.includes(_)), g); }), b; })(o, h, a) : d(h) && d(o) ? u(o, h, t(h), a) : s(h); }
                E.exports = function (...o) { const h = i(s(n), this !== void 0 && this || {}, n); let a = { _: {} }; for (const l of o)
                    if (l !== void 0) {
                        if (!d(l))
                            throw new TypeError("`" + l + "` is not an Option Object");
                        a = i(a, { _: l }, h);
                    } return a._; };
            }, function (E, m, f) {
                "use strict";
                const d = f(138), { encodeText: r, decodeText: e, concat: c } = f(139);
                function n(t) { if (d.names[t])
                    return d.names[t]; if (d.codes[t])
                    return d.codes[t]; throw new Error("Unsupported encoding: " + t); }
                (m = E.exports = function (t, s) { if (!s)
                    throw new Error("requires an encoded Uint8Array"); const { name: u, codeBuf: i } = n(t); return function (o, h) { n(o).decode(e(h)); }(u, s), c([i, s], i.length + s.length); }).encode = function (t, s) { const u = n(t), i = r(u.encode(s)); return c([u.codeBuf, i], u.codeBuf.length + i.length); }, m.decode = function (t) { t instanceof Uint8Array && (t = e(t)); const s = t[0]; return ["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(s) && (t = t.toLowerCase()), n(t[0]).decode(t.substring(1)); }, m.isEncoded = function (t) { if (t instanceof Uint8Array && (t = e(t)), Object.prototype.toString.call(t) !== "[object String]")
                    return !1; try {
                    return n(t[0]).name;
                }
                catch (s) {
                    return !1;
                } }, m.encoding = n, m.encodingFromData = function (t) { return t instanceof Uint8Array && (t = e(t)), n(t[0]); }, m.names = Object.freeze(d.names), m.codes = Object.freeze(d.codes);
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, { className: r, symbolName: e }) { const c = Symbol.for(e), n = { [r]: class extends d {
                        constructor(...t) { super(...t), Object.defineProperty(this, c, { value: !0 }); }
                        get [Symbol.toStringTag]() { return r; }
                    } }[r]; return n["is" + r] = t => !(!t || !t[c]), n; }, E.exports.proto = function (d, { className: r, symbolName: e, withoutNew: c }) { const n = Symbol.for(e), t = { [r]: function (...s) { if (c && !(this instanceof t))
                        return new t(...s); const u = d.call(this, ...s) || this; return u && !u[n] && Object.defineProperty(u, n, { value: !0 }), u; } }[r]; return t.prototype = Object.create(d.prototype), t.prototype.constructor = t, Object.defineProperty(t.prototype, Symbol.toStringTag, { get: () => r }), t["is" + r] = s => !(!s || !s[n]), t; };
            }, function (E, m, f) {
                "use strict";
                const d = (...t) => { let s; for (; t.length;)
                    s = t.shift()(s); return s; }, r = t => t && (typeof t[Symbol.asyncIterator] == "function" || typeof t[Symbol.iterator] == "function" || typeof t.next == "function"), e = t => t && typeof t.sink == "function" && r(t.source), c = t => s => (t.sink(s), t.source), n = (...t) => { if (e(t[0])) {
                    const s = t[0];
                    t[0] = () => s.source;
                }
                else if (r(t[0])) {
                    const s = t[0];
                    t[0] = () => s;
                } if (t.length > 1 && e(t[t.length - 1]) && (t[t.length - 1] = t[t.length - 1].sink), t.length > 2)
                    for (let s = 1; s < t.length - 1; s++)
                        e(t[s]) && (t[s] = c(t[s])); return d(...t); };
                E.exports = n, E.exports.pipe = n, E.exports.rawPipe = d, E.exports.isIterable = r, E.exports.isDuplex = e;
            }, function (E, m, f) {
                "use strict";
                m.messages = { NOT_STARTED_YET: "The libp2p node is not started yet", DHT_DISABLED: "DHT is not available", CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required" }, m.codes = { DHT_DISABLED: "ERR_DHT_DISABLED", PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED", DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED", CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED", ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED", ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED", ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED", ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED", ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES", ERR_DIALED_SELF: "ERR_DIALED_SELF", ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF", ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT", ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED", ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED", ERR_INVALID_KEY: "ERR_INVALID_KEY", ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE", ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS", ERR_INVALID_PEER: "ERR_INVALID_PEER", ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE", ERR_TIMEOUT: "ERR_TIMEOUT", ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE", ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED", ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL", ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR", ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID" };
            }, function (E, m, f) {
                "use strict";
                const d = f(21)(f(534)).Data, r = f(0), e = ["raw", "directory", "file", "metadata", "symlink", "hamt-sharded-directory"], c = ["directory", "hamt-sharded-directory"], n = parseInt("0644", 8), t = parseInt("0755", 8);
                function s(o) { if (o != null) {
                    if (Object.prototype.hasOwnProperty.call(o, "secs") && (o = { secs: o.secs, nsecs: o.nsecs }), Object.prototype.hasOwnProperty.call(o, "Seconds") && (o = { secs: o.Seconds, nsecs: o.FractionalNanoseconds }), Array.isArray(o) && (o = { secs: o[0], nsecs: o[1] }), o instanceof Date) {
                        const h = o.getTime(), a = Math.floor(h / 1e3);
                        o = { secs: a, nsecs: 1e3 * (h - 1e3 * a) };
                    }
                    if (Object.prototype.hasOwnProperty.call(o, "secs")) {
                        if (o.nsecs < 0 || o.nsecs > 999999999)
                            throw r(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
                        return o;
                    }
                } }
                function u(o) { if (o != null)
                    return (typeof o == "string" || o instanceof String) && (o = parseInt(o, 8)), 4095 & o; }
                class i {
                    static unmarshal(h) { const a = d.decode(h), l = new i({ type: e[a.Type], data: a.hasData() ? a.Data : void 0, blockSizes: a.blocksizes, mode: a.hasMode() ? a.mode : void 0, mtime: a.hasMtime() ? a.mtime : void 0 }); return l._originalMode = a.hasMode() ? a.mode : void 0, l; }
                    constructor(...h) { const { type: a, data: l, blockSizes: p, hashType: g, fanout: b, mtime: I, mode: v } = function (k) { return k.length === 0 ? { type: "file" } : k.length === 2 ? { type: k[0], data: k[1] } : typeof k[0] == "string" || k[0] instanceof String ? { type: k[0] } : k[0]; }(h); if (!e.includes(a))
                        throw r(new Error("Type: " + a + " is not valid"), "ERR_INVALID_TYPE"); this.type = a, this.data = l, this.hashType = g, this.fanout = b, this.blockSizes = p || []; const R = u(v); R !== void 0 && (this.mode = R), this.mode === void 0 && a === "file" && (this.mode = n), this.mode === void 0 && this.isDirectory() && (this.mode = t); const _ = s(I); _ && (this.mtime = _); }
                    isDirectory() { return c.includes(this.type); }
                    addBlockSize(h) { this.blockSizes.push(h); }
                    removeBlockSize(h) { this.blockSizes.splice(h, 1); }
                    fileSize() { if (this.isDirectory())
                        return; let h = 0; return this.blockSizes.forEach(a => { h += a; }), this.data && (h += this.data.length), h; }
                    marshal() { let h; switch (this.type) {
                        case "raw":
                            h = d.DataType.Raw;
                            break;
                        case "directory":
                            h = d.DataType.Directory;
                            break;
                        case "file":
                            h = d.DataType.File;
                            break;
                        case "metadata":
                            h = d.DataType.Metadata;
                            break;
                        case "symlink":
                            h = d.DataType.Symlink;
                            break;
                        case "hamt-sharded-directory":
                            h = d.DataType.HAMTShard;
                            break;
                        default: throw r(new Error("Type: " + h + " is not valid"), "ERR_INVALID_TYPE");
                    } let a = this.data; this.data && this.data.length || (a = void 0); let l, p, g = this.blockSizes; if (this.blockSizes && this.blockSizes.length || (g = void 0), this.mode != null && (l = 4294963200 & this._originalMode | u(this.mode), l === n && this.type === "file" && (l = void 0), l === t && this.isDirectory() && (l = void 0)), this.mtime != null) {
                        const b = s(this.mtime);
                        b && (p = { Seconds: b.secs, FractionalNanoseconds: b.nsecs }, p.FractionalNanoseconds === 0 && delete p.FractionalNanoseconds);
                    } return d.encode({ Type: h, Data: a, filesize: this.fileSize(), blocksizes: g, hashType: this.hashType, fanout: this.fanout, mode: l, mtime: p }); }
                }
                E.exports = i;
            }, function (E, m, f) {
                "use strict";
                var d;
                !function (r) { var e, c = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, n = Math.ceil, t = Math.floor, s = "[BigNumber Error] ", u = s + "Number primitive has more than 15 significant digits: ", i = 1e14, o = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], h = 1e9; function a(R) { var _ = 0 | R; return R > 0 || R === _ ? _ : _ - 1; } function l(R) { for (var _, k, x = 1, M = R.length, N = R[0] + ""; x < M;) {
                    for (k = 14 - (_ = R[x++] + "").length; k--; _ = "0" + _)
                        ;
                    N += _;
                } for (M = N.length; N.charCodeAt(--M) === 48;)
                    ; return N.slice(0, M + 1 || 1); } function p(R, _) { var k, x, M = R.c, N = _.c, S = R.s, T = _.s, B = R.e, P = _.e; if (!S || !T)
                    return null; if (k = M && !M[0], x = N && !N[0], k || x)
                    return k ? x ? 0 : -T : S; if (S != T)
                    return S; if (k = S < 0, x = B == P, !M || !N)
                    return x ? 0 : !M ^ k ? 1 : -1; if (!x)
                    return B > P ^ k ? 1 : -1; for (T = (B = M.length) < (P = N.length) ? B : P, S = 0; S < T; S++)
                    if (M[S] != N[S])
                        return M[S] > N[S] ^ k ? 1 : -1; return B == P ? 0 : B > P ^ k ? 1 : -1; } function g(R, _, k, x) { if (R < _ || R > k || R !== t(R))
                    throw Error(s + (x || "Argument") + (typeof R == "number" ? R < _ || R > k ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(R)); } function b(R) { var _ = R.c.length - 1; return a(R.e / 14) == _ && R.c[_] % 2 != 0; } function I(R, _) { return (R.length > 1 ? R.charAt(0) + "." + R.slice(1) : R) + (_ < 0 ? "e" : "e+") + _; } function v(R, _, k) { var x, M; if (_ < 0) {
                    for (M = k + "."; ++_; M += k)
                        ;
                    R = M + R;
                }
                else if (++_ > (x = R.length)) {
                    for (M = k, _ -= x; --_; M += k)
                        ;
                    R += M;
                }
                else
                    _ < x && (R = R.slice(0, _) + "." + R.slice(_)); return R; } (e = function R(_) { var k, x, M, N, S, T, B, P, L, j = U.prototype = { constructor: U, toString: null, valueOf: null }, D = new U(1), G = 20, W = 4, X = -7, Q = 21, K = -1e7, F = 1e7, Y = !1, $ = 1, y = 0, C = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, A = "0123456789abcdefghijklmnopqrstuvwxyz"; function U(V, J) { var Z, tt, nt, rt, it, st, at, ct, lt = this; if (!(lt instanceof U))
                    return new U(V, J); if (J == null) {
                    if (V && V._isBigNumber === !0)
                        return lt.s = V.s, void (!V.c || V.e > F ? lt.c = lt.e = null : V.e < K ? lt.c = [lt.e = 0] : (lt.e = V.e, lt.c = V.c.slice()));
                    if ((st = typeof V == "number") && 0 * V == 0) {
                        if (lt.s = 1 / V < 0 ? (V = -V, -1) : 1, V === ~~V) {
                            for (rt = 0, it = V; it >= 10; it /= 10, rt++)
                                ;
                            return void (rt > F ? lt.c = lt.e = null : (lt.e = rt, lt.c = [V]));
                        }
                        ct = String(V);
                    }
                    else {
                        if (!c.test(ct = String(V)))
                            return M(lt, ct, st);
                        lt.s = ct.charCodeAt(0) == 45 ? (ct = ct.slice(1), -1) : 1;
                    }
                    (rt = ct.indexOf(".")) > -1 && (ct = ct.replace(".", "")), (it = ct.search(/e/i)) > 0 ? (rt < 0 && (rt = it), rt += +ct.slice(it + 1), ct = ct.substring(0, it)) : rt < 0 && (rt = ct.length);
                }
                else {
                    if (g(J, 2, A.length, "Base"), J == 10)
                        return q(lt = new U(V), G + lt.e + 1, W);
                    if (ct = String(V), st = typeof V == "number") {
                        if (0 * V != 0)
                            return M(lt, ct, st, J);
                        if (lt.s = 1 / V < 0 ? (ct = ct.slice(1), -1) : 1, U.DEBUG && ct.replace(/^0\.0*|\./, "").length > 15)
                            throw Error(u + V);
                    }
                    else
                        lt.s = ct.charCodeAt(0) === 45 ? (ct = ct.slice(1), -1) : 1;
                    for (Z = A.slice(0, J), rt = it = 0, at = ct.length; it < at; it++)
                        if (Z.indexOf(tt = ct.charAt(it)) < 0) {
                            if (tt == ".") {
                                if (it > rt) {
                                    rt = at;
                                    continue;
                                }
                            }
                            else if (!nt && (ct == ct.toUpperCase() && (ct = ct.toLowerCase()) || ct == ct.toLowerCase() && (ct = ct.toUpperCase()))) {
                                nt = !0, it = -1, rt = 0;
                                continue;
                            }
                            return M(lt, String(V), st, J);
                        }
                    st = !1, (rt = (ct = x(ct, J, 10, lt.s)).indexOf(".")) > -1 ? ct = ct.replace(".", "") : rt = ct.length;
                } for (it = 0; ct.charCodeAt(it) === 48; it++)
                    ; for (at = ct.length; ct.charCodeAt(--at) === 48;)
                    ; if (ct = ct.slice(it, ++at)) {
                    if (at -= it, st && U.DEBUG && at > 15 && (V > 9007199254740991 || V !== t(V)))
                        throw Error(u + lt.s * V);
                    if ((rt = rt - it - 1) > F)
                        lt.c = lt.e = null;
                    else if (rt < K)
                        lt.c = [lt.e = 0];
                    else {
                        if (lt.e = rt, lt.c = [], it = (rt + 1) % 14, rt < 0 && (it += 14), it < at) {
                            for (it && lt.c.push(+ct.slice(0, it)), at -= 14; it < at;)
                                lt.c.push(+ct.slice(it, it += 14));
                            it = 14 - (ct = ct.slice(it)).length;
                        }
                        else
                            it -= at;
                        for (; it--; ct += "0")
                            ;
                        lt.c.push(+ct);
                    }
                }
                else
                    lt.c = [lt.e = 0]; } function z(V, J, Z, tt) { var nt, rt, it, st, at; if (Z == null ? Z = W : g(Z, 0, 8), !V.c)
                    return V.toString(); if (nt = V.c[0], it = V.e, J == null)
                    at = l(V.c), at = tt == 1 || tt == 2 && (it <= X || it >= Q) ? I(at, it) : v(at, it, "0");
                else if (rt = (V = q(new U(V), J, Z)).e, st = (at = l(V.c)).length, tt == 1 || tt == 2 && (J <= rt || rt <= X)) {
                    for (; st < J; at += "0", st++)
                        ;
                    at = I(at, rt);
                }
                else if (J -= it, at = v(at, rt, "0"), rt + 1 > st) {
                    if (--J > 0)
                        for (at += "."; J--; at += "0")
                            ;
                }
                else if ((J += rt - st) > 0)
                    for (rt + 1 == st && (at += "."); J--; at += "0")
                        ; return V.s < 0 && nt ? "-" + at : at; } function w(V, J) { for (var Z, tt = 1, nt = new U(V[0]); tt < V.length; tt++) {
                    if (!(Z = new U(V[tt])).s) {
                        nt = Z;
                        break;
                    }
                    J.call(nt, Z) && (nt = Z);
                } return nt; } function O(V, J, Z) { for (var tt = 1, nt = J.length; !J[--nt]; J.pop())
                    ; for (nt = J[0]; nt >= 10; nt /= 10, tt++)
                    ; return (Z = tt + 14 * Z - 1) > F ? V.c = V.e = null : Z < K ? V.c = [V.e = 0] : (V.e = Z, V.c = J), V; } function q(V, J, Z, tt) { var nt, rt, it, st, at, ct, lt, pt = V.c, mt = o; if (pt) {
                    t: {
                        for (nt = 1, st = pt[0]; st >= 10; st /= 10, nt++)
                            ;
                        if ((rt = J - nt) < 0)
                            rt += 14, it = J, lt = (at = pt[ct = 0]) / mt[nt - it - 1] % 10 | 0;
                        else if ((ct = n((rt + 1) / 14)) >= pt.length) {
                            if (!tt)
                                break t;
                            for (; pt.length <= ct; pt.push(0))
                                ;
                            at = lt = 0, nt = 1, it = (rt %= 14) - 14 + 1;
                        }
                        else {
                            for (at = st = pt[ct], nt = 1; st >= 10; st /= 10, nt++)
                                ;
                            lt = (it = (rt %= 14) - 14 + nt) < 0 ? 0 : at / mt[nt - it - 1] % 10 | 0;
                        }
                        if (tt = tt || J < 0 || pt[ct + 1] != null || (it < 0 ? at : at % mt[nt - it - 1]), tt = Z < 4 ? (lt || tt) && (Z == 0 || Z == (V.s < 0 ? 3 : 2)) : lt > 5 || lt == 5 && (Z == 4 || tt || Z == 6 && (rt > 0 ? it > 0 ? at / mt[nt - it] : 0 : pt[ct - 1]) % 10 & 1 || Z == (V.s < 0 ? 8 : 7)), J < 1 || !pt[0])
                            return pt.length = 0, tt ? (J -= V.e + 1, pt[0] = mt[(14 - J % 14) % 14], V.e = -J || 0) : pt[0] = V.e = 0, V;
                        if (rt == 0 ? (pt.length = ct, st = 1, ct--) : (pt.length = ct + 1, st = mt[14 - rt], pt[ct] = it > 0 ? t(at / mt[nt - it] % mt[it]) * st : 0), tt)
                            for (;;) {
                                if (ct == 0) {
                                    for (rt = 1, it = pt[0]; it >= 10; it /= 10, rt++)
                                        ;
                                    for (it = pt[0] += st, st = 1; it >= 10; it /= 10, st++)
                                        ;
                                    rt != st && (V.e++, pt[0] == i && (pt[0] = 1));
                                    break;
                                }
                                if (pt[ct] += st, pt[ct] != i)
                                    break;
                                pt[ct--] = 0, st = 1;
                            }
                        for (rt = pt.length; pt[--rt] === 0; pt.pop())
                            ;
                    }
                    V.e > F ? V.c = V.e = null : V.e < K && (V.c = [V.e = 0]);
                } return V; } function H(V) { var J, Z = V.e; return Z === null ? V.toString() : (J = l(V.c), J = Z <= X || Z >= Q ? I(J, Z) : v(J, Z, "0"), V.s < 0 ? "-" + J : J); } return U.clone = R, U.ROUND_UP = 0, U.ROUND_DOWN = 1, U.ROUND_CEIL = 2, U.ROUND_FLOOR = 3, U.ROUND_HALF_UP = 4, U.ROUND_HALF_DOWN = 5, U.ROUND_HALF_EVEN = 6, U.ROUND_HALF_CEIL = 7, U.ROUND_HALF_FLOOR = 8, U.EUCLID = 9, U.config = U.set = function (V) { var J, Z; if (V != null) {
                    if (typeof V != "object")
                        throw Error(s + "Object expected: " + V);
                    if (V.hasOwnProperty(J = "DECIMAL_PLACES") && (g(Z = V[J], 0, h, J), G = Z), V.hasOwnProperty(J = "ROUNDING_MODE") && (g(Z = V[J], 0, 8, J), W = Z), V.hasOwnProperty(J = "EXPONENTIAL_AT") && ((Z = V[J]) && Z.pop ? (g(Z[0], -h, 0, J), g(Z[1], 0, h, J), X = Z[0], Q = Z[1]) : (g(Z, -h, h, J), X = -(Q = Z < 0 ? -Z : Z))), V.hasOwnProperty(J = "RANGE"))
                        if ((Z = V[J]) && Z.pop)
                            g(Z[0], -h, -1, J), g(Z[1], 1, h, J), K = Z[0], F = Z[1];
                        else {
                            if (g(Z, -h, h, J), !Z)
                                throw Error(s + J + " cannot be zero: " + Z);
                            K = -(F = Z < 0 ? -Z : Z);
                        }
                    if (V.hasOwnProperty(J = "CRYPTO")) {
                        if ((Z = V[J]) !== !!Z)
                            throw Error(s + J + " not true or false: " + Z);
                        if (Z) {
                            if (typeof crypto == "undefined" || !crypto || !crypto.getRandomValues && !crypto.randomBytes)
                                throw Y = !Z, Error(s + "crypto unavailable");
                            Y = Z;
                        }
                        else
                            Y = Z;
                    }
                    if (V.hasOwnProperty(J = "MODULO_MODE") && (g(Z = V[J], 0, 9, J), $ = Z), V.hasOwnProperty(J = "POW_PRECISION") && (g(Z = V[J], 0, h, J), y = Z), V.hasOwnProperty(J = "FORMAT")) {
                        if (typeof (Z = V[J]) != "object")
                            throw Error(s + J + " not an object: " + Z);
                        C = Z;
                    }
                    if (V.hasOwnProperty(J = "ALPHABET")) {
                        if (typeof (Z = V[J]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(Z))
                            throw Error(s + J + " invalid: " + Z);
                        A = Z;
                    }
                } return { DECIMAL_PLACES: G, ROUNDING_MODE: W, EXPONENTIAL_AT: [X, Q], RANGE: [K, F], CRYPTO: Y, MODULO_MODE: $, POW_PRECISION: y, FORMAT: C, ALPHABET: A }; }, U.isBigNumber = function (V) { if (!V || V._isBigNumber !== !0)
                    return !1; if (!U.DEBUG)
                    return !0; var J, Z, tt = V.c, nt = V.e, rt = V.s; t: if ({}.toString.call(tt) == "[object Array]") {
                    if ((rt === 1 || rt === -1) && nt >= -h && nt <= h && nt === t(nt)) {
                        if (tt[0] === 0) {
                            if (nt === 0 && tt.length === 1)
                                return !0;
                            break t;
                        }
                        if ((J = (nt + 1) % 14) < 1 && (J += 14), String(tt[0]).length == J) {
                            for (J = 0; J < tt.length; J++)
                                if ((Z = tt[J]) < 0 || Z >= i || Z !== t(Z))
                                    break t;
                            if (Z !== 0)
                                return !0;
                        }
                    }
                }
                else if (tt === null && nt === null && (rt === null || rt === 1 || rt === -1))
                    return !0; throw Error(s + "Invalid BigNumber: " + V); }, U.maximum = U.max = function () { return w(arguments, j.lt); }, U.minimum = U.min = function () { return w(arguments, j.gt); }, U.random = (N = 9007199254740992 * Math.random() & 2097151 ? function () { return t(9007199254740992 * Math.random()); } : function () { return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0); }, function (V) { var J, Z, tt, nt, rt, it = 0, st = [], at = new U(D); if (V == null ? V = G : g(V, 0, h), nt = n(V / 14), Y)
                    if (crypto.getRandomValues) {
                        for (J = crypto.getRandomValues(new Uint32Array(nt *= 2)); it < nt;)
                            (rt = 131072 * J[it] + (J[it + 1] >>> 11)) >= 9e15 ? (Z = crypto.getRandomValues(new Uint32Array(2)), J[it] = Z[0], J[it + 1] = Z[1]) : (st.push(rt % 1e14), it += 2);
                        it = nt / 2;
                    }
                    else {
                        if (!crypto.randomBytes)
                            throw Y = !1, Error(s + "crypto unavailable");
                        for (J = crypto.randomBytes(nt *= 7); it < nt;)
                            (rt = 281474976710656 * (31 & J[it]) + 1099511627776 * J[it + 1] + 4294967296 * J[it + 2] + 16777216 * J[it + 3] + (J[it + 4] << 16) + (J[it + 5] << 8) + J[it + 6]) >= 9e15 ? crypto.randomBytes(7).copy(J, it) : (st.push(rt % 1e14), it += 7);
                        it = nt / 7;
                    } if (!Y)
                    for (; it < nt;)
                        (rt = N()) < 9e15 && (st[it++] = rt % 1e14); for (V %= 14, (nt = st[--it]) && V && (rt = o[14 - V], st[it] = t(nt / rt) * rt); st[it] === 0; st.pop(), it--)
                    ; if (it < 0)
                    st = [tt = 0];
                else {
                    for (tt = -1; st[0] === 0; st.splice(0, 1), tt -= 14)
                        ;
                    for (it = 1, rt = st[0]; rt >= 10; rt /= 10, it++)
                        ;
                    it < 14 && (tt -= 14 - it);
                } return at.e = tt, at.c = st, at; }), U.sum = function () { for (var V = 1, J = arguments, Z = new U(J[0]); V < J.length;)
                    Z = Z.plus(J[V++]); return Z; }, x = function () { function V(J, Z, tt, nt) { for (var rt, it, st = [0], at = 0, ct = J.length; at < ct;) {
                    for (it = st.length; it--; st[it] *= Z)
                        ;
                    for (st[0] += nt.indexOf(J.charAt(at++)), rt = 0; rt < st.length; rt++)
                        st[rt] > tt - 1 && (st[rt + 1] == null && (st[rt + 1] = 0), st[rt + 1] += st[rt] / tt | 0, st[rt] %= tt);
                } return st.reverse(); } return function (J, Z, tt, nt, rt) { var it, st, at, ct, lt, pt, mt, Tt, vt = J.indexOf("."), Rt = G, Bt = W; for (vt >= 0 && (ct = y, y = 0, J = J.replace(".", ""), pt = (Tt = new U(Z)).pow(J.length - vt), y = ct, Tt.c = V(v(l(pt.c), pt.e, "0"), 10, tt, "0123456789"), Tt.e = Tt.c.length), at = ct = (mt = V(J, Z, tt, rt ? (it = A, "0123456789") : (it = "0123456789", A))).length; mt[--ct] == 0; mt.pop())
                    ; if (!mt[0])
                    return it.charAt(0); if (vt < 0 ? --at : (pt.c = mt, pt.e = at, pt.s = nt, mt = (pt = k(pt, Tt, Rt, Bt, tt)).c, lt = pt.r, at = pt.e), vt = mt[st = at + Rt + 1], ct = tt / 2, lt = lt || st < 0 || mt[st + 1] != null, lt = Bt < 4 ? (vt != null || lt) && (Bt == 0 || Bt == (pt.s < 0 ? 3 : 2)) : vt > ct || vt == ct && (Bt == 4 || lt || Bt == 6 && 1 & mt[st - 1] || Bt == (pt.s < 0 ? 8 : 7)), st < 1 || !mt[0])
                    J = lt ? v(it.charAt(1), -Rt, it.charAt(0)) : it.charAt(0);
                else {
                    if (mt.length = st, lt)
                        for (--tt; ++mt[--st] > tt;)
                            mt[st] = 0, st || (++at, mt = [1].concat(mt));
                    for (ct = mt.length; !mt[--ct];)
                        ;
                    for (vt = 0, J = ""; vt <= ct; J += it.charAt(mt[vt++]))
                        ;
                    J = v(J, at, it.charAt(0));
                } return J; }; }(), k = function () { function V(tt, nt, rt) { var it, st, at, ct, lt = 0, pt = tt.length, mt = nt % 1e7, Tt = nt / 1e7 | 0; for (tt = tt.slice(); pt--;)
                    lt = ((st = mt * (at = tt[pt] % 1e7) + (it = Tt * at + (ct = tt[pt] / 1e7 | 0) * mt) % 1e7 * 1e7 + lt) / rt | 0) + (it / 1e7 | 0) + Tt * ct, tt[pt] = st % rt; return lt && (tt = [lt].concat(tt)), tt; } function J(tt, nt, rt, it) { var st, at; if (rt != it)
                    at = rt > it ? 1 : -1;
                else
                    for (st = at = 0; st < rt; st++)
                        if (tt[st] != nt[st]) {
                            at = tt[st] > nt[st] ? 1 : -1;
                            break;
                        } return at; } function Z(tt, nt, rt, it) { for (var st = 0; rt--;)
                    tt[rt] -= st, st = tt[rt] < nt[rt] ? 1 : 0, tt[rt] = st * it + tt[rt] - nt[rt]; for (; !tt[0] && tt.length > 1; tt.splice(0, 1))
                    ; } return function (tt, nt, rt, it, st) { var at, ct, lt, pt, mt, Tt, vt, Rt, Bt, wt, kt, Wt, Ct, Ft, te, jt, Kt, re = tt.s == nt.s ? 1 : -1, St = tt.c, Nt = nt.c; if (!(St && St[0] && Nt && Nt[0]))
                    return new U(tt.s && nt.s && (St ? !Nt || St[0] != Nt[0] : Nt) ? St && St[0] == 0 || !Nt ? 0 * re : re / 0 : NaN); for (Bt = (Rt = new U(re)).c = [], re = rt + (ct = tt.e - nt.e) + 1, st || (st = i, ct = a(tt.e / 14) - a(nt.e / 14), re = re / 14 | 0), lt = 0; Nt[lt] == (St[lt] || 0); lt++)
                    ; if (Nt[lt] > (St[lt] || 0) && ct--, re < 0)
                    Bt.push(1), pt = !0;
                else {
                    for (Ft = St.length, jt = Nt.length, lt = 0, re += 2, (mt = t(st / (Nt[0] + 1))) > 1 && (Nt = V(Nt, mt, st), St = V(St, mt, st), jt = Nt.length, Ft = St.length), Ct = jt, kt = (wt = St.slice(0, jt)).length; kt < jt; wt[kt++] = 0)
                        ;
                    Kt = Nt.slice(), Kt = [0].concat(Kt), te = Nt[0], Nt[1] >= st / 2 && te++;
                    do {
                        if (mt = 0, (at = J(Nt, wt, jt, kt)) < 0) {
                            if (Wt = wt[0], jt != kt && (Wt = Wt * st + (wt[1] || 0)), (mt = t(Wt / te)) > 1)
                                for (mt >= st && (mt = st - 1), vt = (Tt = V(Nt, mt, st)).length, kt = wt.length; J(Tt, wt, vt, kt) == 1;)
                                    mt--, Z(Tt, jt < vt ? Kt : Nt, vt, st), vt = Tt.length, at = 1;
                            else
                                mt == 0 && (at = mt = 1), vt = (Tt = Nt.slice()).length;
                            if (vt < kt && (Tt = [0].concat(Tt)), Z(wt, Tt, kt, st), kt = wt.length, at == -1)
                                for (; J(Nt, wt, jt, kt) < 1;)
                                    mt++, Z(wt, jt < kt ? Kt : Nt, kt, st), kt = wt.length;
                        }
                        else
                            at === 0 && (mt++, wt = [0]);
                        Bt[lt++] = mt, wt[0] ? wt[kt++] = St[Ct] || 0 : (wt = [St[Ct]], kt = 1);
                    } while ((Ct++ < Ft || wt[0] != null) && re--);
                    pt = wt[0] != null, Bt[0] || Bt.splice(0, 1);
                } if (st == i) {
                    for (lt = 1, re = Bt[0]; re >= 10; re /= 10, lt++)
                        ;
                    q(Rt, rt + (Rt.e = lt + 14 * ct - 1) + 1, it, pt);
                }
                else
                    Rt.e = ct, Rt.r = +pt; return Rt; }; }(), S = /^(-?)0([xbo])(?=\w[\w.]*$)/i, T = /^([^.]+)\.$/, B = /^\.([^.]+)$/, P = /^-?(Infinity|NaN)$/, L = /^\s*\+(?=[\w.])|^\s+|\s+$/g, M = function (V, J, Z, tt) { var nt, rt = Z ? J : J.replace(L, ""); if (P.test(rt))
                    V.s = isNaN(rt) ? null : rt < 0 ? -1 : 1;
                else {
                    if (!Z && (rt = rt.replace(S, function (it, st, at) { return nt = (at = at.toLowerCase()) == "x" ? 16 : at == "b" ? 2 : 8, tt && tt != nt ? it : st; }), tt && (nt = tt, rt = rt.replace(T, "$1").replace(B, "0.$1")), J != rt))
                        return new U(rt, nt);
                    if (U.DEBUG)
                        throw Error(s + "Not a" + (tt ? " base " + tt : "") + " number: " + J);
                    V.s = null;
                } V.c = V.e = null; }, j.absoluteValue = j.abs = function () { var V = new U(this); return V.s < 0 && (V.s = 1), V; }, j.comparedTo = function (V, J) { return p(this, new U(V, J)); }, j.decimalPlaces = j.dp = function (V, J) { var Z, tt, nt, rt = this; if (V != null)
                    return g(V, 0, h), J == null ? J = W : g(J, 0, 8), q(new U(rt), V + rt.e + 1, J); if (!(Z = rt.c))
                    return null; if (tt = 14 * ((nt = Z.length - 1) - a(this.e / 14)), nt = Z[nt])
                    for (; nt % 10 == 0; nt /= 10, tt--)
                        ; return tt < 0 && (tt = 0), tt; }, j.dividedBy = j.div = function (V, J) { return k(this, new U(V, J), G, W); }, j.dividedToIntegerBy = j.idiv = function (V, J) { return k(this, new U(V, J), 0, 1); }, j.exponentiatedBy = j.pow = function (V, J) { var Z, tt, nt, rt, it, st, at, ct, lt = this; if ((V = new U(V)).c && !V.isInteger())
                    throw Error(s + "Exponent not an integer: " + H(V)); if (J != null && (J = new U(J)), it = V.e > 14, !lt.c || !lt.c[0] || lt.c[0] == 1 && !lt.e && lt.c.length == 1 || !V.c || !V.c[0])
                    return ct = new U(Math.pow(+H(lt), it ? 2 - b(V) : +H(V))), J ? ct.mod(J) : ct; if (st = V.s < 0, J) {
                    if (J.c ? !J.c[0] : !J.s)
                        return new U(NaN);
                    (tt = !st && lt.isInteger() && J.isInteger()) && (lt = lt.mod(J));
                }
                else {
                    if (V.e > 9 && (lt.e > 0 || lt.e < -1 || (lt.e == 0 ? lt.c[0] > 1 || it && lt.c[1] >= 24e7 : lt.c[0] < 8e13 || it && lt.c[0] <= 9999975e7)))
                        return rt = (lt.s < 0 && b(V), -0), lt.e > -1 && (rt = 1 / rt), new U(st ? 1 / rt : rt);
                    y && (rt = n(y / 14 + 2));
                } for (it ? (Z = new U(.5), st && (V.s = 1), at = b(V)) : at = (nt = Math.abs(+H(V))) % 2, ct = new U(D);;) {
                    if (at) {
                        if (!(ct = ct.times(lt)).c)
                            break;
                        rt ? ct.c.length > rt && (ct.c.length = rt) : tt && (ct = ct.mod(J));
                    }
                    if (nt) {
                        if ((nt = t(nt / 2)) === 0)
                            break;
                        at = nt % 2;
                    }
                    else if (q(V = V.times(Z), V.e + 1, 1), V.e > 14)
                        at = b(V);
                    else {
                        if ((nt = +H(V)) === 0)
                            break;
                        at = nt % 2;
                    }
                    lt = lt.times(lt), rt ? lt.c && lt.c.length > rt && (lt.c.length = rt) : tt && (lt = lt.mod(J));
                } return tt ? ct : (st && (ct = D.div(ct)), J ? ct.mod(J) : rt ? q(ct, y, W, void 0) : ct); }, j.integerValue = function (V) { var J = new U(this); return V == null ? V = W : g(V, 0, 8), q(J, J.e + 1, V); }, j.isEqualTo = j.eq = function (V, J) { return p(this, new U(V, J)) === 0; }, j.isFinite = function () { return !!this.c; }, j.isGreaterThan = j.gt = function (V, J) { return p(this, new U(V, J)) > 0; }, j.isGreaterThanOrEqualTo = j.gte = function (V, J) { return (J = p(this, new U(V, J))) === 1 || J === 0; }, j.isInteger = function () { return !!this.c && a(this.e / 14) > this.c.length - 2; }, j.isLessThan = j.lt = function (V, J) { return p(this, new U(V, J)) < 0; }, j.isLessThanOrEqualTo = j.lte = function (V, J) { return (J = p(this, new U(V, J))) === -1 || J === 0; }, j.isNaN = function () { return !this.s; }, j.isNegative = function () { return this.s < 0; }, j.isPositive = function () { return this.s > 0; }, j.isZero = function () { return !!this.c && this.c[0] == 0; }, j.minus = function (V, J) { var Z, tt, nt, rt, it = this, st = it.s; if (J = (V = new U(V, J)).s, !st || !J)
                    return new U(NaN); if (st != J)
                    return V.s = -J, it.plus(V); var at = it.e / 14, ct = V.e / 14, lt = it.c, pt = V.c; if (!at || !ct) {
                    if (!lt || !pt)
                        return lt ? (V.s = -J, V) : new U(pt ? it : NaN);
                    if (!lt[0] || !pt[0])
                        return pt[0] ? (V.s = -J, V) : new U(lt[0] ? it : (W == 3, -0));
                } if (at = a(at), ct = a(ct), lt = lt.slice(), st = at - ct) {
                    for ((rt = st < 0) ? (st = -st, nt = lt) : (ct = at, nt = pt), nt.reverse(), J = st; J--; nt.push(0))
                        ;
                    nt.reverse();
                }
                else
                    for (tt = (rt = (st = lt.length) < (J = pt.length)) ? st : J, st = J = 0; J < tt; J++)
                        if (lt[J] != pt[J]) {
                            rt = lt[J] < pt[J];
                            break;
                        } if (rt && (nt = lt, lt = pt, pt = nt, V.s = -V.s), (J = (tt = pt.length) - (Z = lt.length)) > 0)
                    for (; J--; lt[Z++] = 0)
                        ; for (J = i - 1; tt > st;) {
                    if (lt[--tt] < pt[tt]) {
                        for (Z = tt; Z && !lt[--Z]; lt[Z] = J)
                            ;
                        --lt[Z], lt[tt] += i;
                    }
                    lt[tt] -= pt[tt];
                } for (; lt[0] == 0; lt.splice(0, 1), --ct)
                    ; return lt[0] ? O(V, lt, ct) : (V.s = W == 3 ? -1 : 1, V.c = [V.e = 0], V); }, j.modulo = j.mod = function (V, J) { var Z, tt, nt = this; return V = new U(V, J), !nt.c || !V.s || V.c && !V.c[0] ? new U(NaN) : !V.c || nt.c && !nt.c[0] ? new U(nt) : ($ == 9 ? (tt = V.s, V.s = 1, Z = k(nt, V, 0, 3), V.s = tt, Z.s *= tt) : Z = k(nt, V, 0, $), (V = nt.minus(Z.times(V))).c[0] || $ != 1 || (V.s = nt.s), V); }, j.multipliedBy = j.times = function (V, J) { var Z, tt, nt, rt, it, st, at, ct, lt, pt, mt, Tt, vt, Rt, Bt = this, wt = Bt.c, kt = (V = new U(V, J)).c; if (!(wt && kt && wt[0] && kt[0]))
                    return !Bt.s || !V.s || wt && !wt[0] && !kt || kt && !kt[0] && !wt ? V.c = V.e = V.s = null : (V.s *= Bt.s, wt && kt ? (V.c = [0], V.e = 0) : V.c = V.e = null), V; for (tt = a(Bt.e / 14) + a(V.e / 14), V.s *= Bt.s, (at = wt.length) < (pt = kt.length) && (vt = wt, wt = kt, kt = vt, nt = at, at = pt, pt = nt), nt = at + pt, vt = []; nt--; vt.push(0))
                    ; for (Rt = i, nt = pt; --nt >= 0;) {
                    for (Z = 0, mt = kt[nt] % 1e7, Tt = kt[nt] / 1e7 | 0, rt = nt + (it = at); rt > nt;)
                        Z = ((ct = mt * (ct = wt[--it] % 1e7) + (st = Tt * ct + (lt = wt[it] / 1e7 | 0) * mt) % 1e7 * 1e7 + vt[rt] + Z) / Rt | 0) + (st / 1e7 | 0) + Tt * lt, vt[rt--] = ct % Rt;
                    vt[rt] = Z;
                } return Z ? ++tt : vt.splice(0, 1), O(V, vt, tt); }, j.negated = function () { var V = new U(this); return V.s = -V.s || null, V; }, j.plus = function (V, J) { var Z, tt = this, nt = tt.s; if (J = (V = new U(V, J)).s, !nt || !J)
                    return new U(NaN); if (nt != J)
                    return V.s = -J, tt.minus(V); var rt = tt.e / 14, it = V.e / 14, st = tt.c, at = V.c; if (!rt || !it) {
                    if (!st || !at)
                        return new U(nt / 0);
                    if (!st[0] || !at[0])
                        return at[0] ? V : new U(st[0] ? tt : 0 * nt);
                } if (rt = a(rt), it = a(it), st = st.slice(), nt = rt - it) {
                    for (nt > 0 ? (it = rt, Z = at) : (nt = -nt, Z = st), Z.reverse(); nt--; Z.push(0))
                        ;
                    Z.reverse();
                } for ((nt = st.length) - (J = at.length) < 0 && (Z = at, at = st, st = Z, J = nt), nt = 0; J;)
                    nt = (st[--J] = st[J] + at[J] + nt) / i | 0, st[J] = i === st[J] ? 0 : st[J] % i; return nt && (st = [nt].concat(st), ++it), O(V, st, it); }, j.precision = j.sd = function (V, J) { var Z, tt, nt, rt = this; if (V != null && V !== !!V)
                    return g(V, 1, h), J == null ? J = W : g(J, 0, 8), q(new U(rt), V, J); if (!(Z = rt.c))
                    return null; if (tt = 14 * (nt = Z.length - 1) + 1, nt = Z[nt]) {
                    for (; nt % 10 == 0; nt /= 10, tt--)
                        ;
                    for (nt = Z[0]; nt >= 10; nt /= 10, tt++)
                        ;
                } return V && rt.e + 1 > tt && (tt = rt.e + 1), tt; }, j.shiftedBy = function (V) { return g(V, -9007199254740991, 9007199254740991), this.times("1e" + V); }, j.squareRoot = j.sqrt = function () { var V, J, Z, tt, nt, rt = this, it = rt.c, st = rt.s, at = rt.e, ct = G + 4, lt = new U("0.5"); if (st !== 1 || !it || !it[0])
                    return new U(!st || st < 0 && (!it || it[0]) ? NaN : it ? rt : 1 / 0); if ((st = Math.sqrt(+H(rt))) == 0 || st == 1 / 0 ? (((J = l(it)).length + at) % 2 == 0 && (J += "0"), st = Math.sqrt(+J), at = a((at + 1) / 2) - (at < 0 || at % 2), Z = new U(J = st == 1 / 0 ? "5e" + at : (J = st.toExponential()).slice(0, J.indexOf("e") + 1) + at)) : Z = new U(st + ""), Z.c[0]) {
                    for ((st = (at = Z.e) + ct) < 3 && (st = 0);;)
                        if (nt = Z, Z = lt.times(nt.plus(k(rt, nt, ct, 1))), l(nt.c).slice(0, st) === (J = l(Z.c)).slice(0, st)) {
                            if (Z.e < at && --st, (J = J.slice(st - 3, st + 1)) != "9999" && (tt || J != "4999")) {
                                +J && (+J.slice(1) || J.charAt(0) != "5") || (q(Z, Z.e + G + 2, 1), V = !Z.times(Z).eq(rt));
                                break;
                            }
                            if (!tt && (q(nt, nt.e + G + 2, 0), nt.times(nt).eq(rt))) {
                                Z = nt;
                                break;
                            }
                            ct += 4, st += 4, tt = 1;
                        }
                } return q(Z, Z.e + G + 1, W, V); }, j.toExponential = function (V, J) { return V != null && (g(V, 0, h), V++), z(this, V, J, 1); }, j.toFixed = function (V, J) { return V != null && (g(V, 0, h), V = V + this.e + 1), z(this, V, J); }, j.toFormat = function (V, J, Z) { var tt, nt = this; if (Z == null)
                    V != null && J && typeof J == "object" ? (Z = J, J = null) : V && typeof V == "object" ? (Z = V, V = J = null) : Z = C;
                else if (typeof Z != "object")
                    throw Error(s + "Argument not an object: " + Z); if (tt = nt.toFixed(V, J), nt.c) {
                    var rt, it = tt.split("."), st = +Z.groupSize, at = +Z.secondaryGroupSize, ct = Z.groupSeparator || "", lt = it[0], pt = it[1], mt = nt.s < 0, Tt = mt ? lt.slice(1) : lt, vt = Tt.length;
                    if (at && (rt = st, st = at, at = rt, vt -= rt), st > 0 && vt > 0) {
                        for (rt = vt % st || st, lt = Tt.substr(0, rt); rt < vt; rt += st)
                            lt += ct + Tt.substr(rt, st);
                        at > 0 && (lt += ct + Tt.slice(rt)), mt && (lt = "-" + lt);
                    }
                    tt = pt ? lt + (Z.decimalSeparator || "") + ((at = +Z.fractionGroupSize) ? pt.replace(new RegExp("\\d{" + at + "}\\B", "g"), "$&" + (Z.fractionGroupSeparator || "")) : pt) : lt;
                } return (Z.prefix || "") + tt + (Z.suffix || ""); }, j.toFraction = function (V) { var J, Z, tt, nt, rt, it, st, at, ct, lt, pt, mt, Tt = this, vt = Tt.c; if (V != null && (!(st = new U(V)).isInteger() && (st.c || st.s !== 1) || st.lt(D)))
                    throw Error(s + "Argument " + (st.isInteger() ? "out of range: " : "not an integer: ") + H(st)); if (!vt)
                    return new U(Tt); for (J = new U(D), ct = Z = new U(D), tt = at = new U(D), mt = l(vt), rt = J.e = mt.length - Tt.e - 1, J.c[0] = o[(it = rt % 14) < 0 ? 14 + it : it], V = !V || st.comparedTo(J) > 0 ? rt > 0 ? J : ct : st, it = F, F = 1 / 0, st = new U(mt), at.c[0] = 0; lt = k(st, J, 0, 1), (nt = Z.plus(lt.times(tt))).comparedTo(V) != 1;)
                    Z = tt, tt = nt, ct = at.plus(lt.times(nt = ct)), at = nt, J = st.minus(lt.times(nt = J)), st = nt; return nt = k(V.minus(Z), tt, 0, 1), at = at.plus(nt.times(ct)), Z = Z.plus(nt.times(tt)), at.s = ct.s = Tt.s, pt = k(ct, tt, rt *= 2, W).minus(Tt).abs().comparedTo(k(at, Z, rt, W).minus(Tt).abs()) < 1 ? [ct, tt] : [at, Z], F = it, pt; }, j.toNumber = function () { return +H(this); }, j.toPrecision = function (V, J) { return V != null && g(V, 1, h), z(this, V, J, 2); }, j.toString = function (V) { var J, Z = this, tt = Z.s, nt = Z.e; return nt === null ? tt ? (J = "Infinity", tt < 0 && (J = "-" + J)) : J = "NaN" : (V == null ? J = nt <= X || nt >= Q ? I(l(Z.c), nt) : v(l(Z.c), nt, "0") : V === 10 ? J = v(l((Z = q(new U(Z), G + nt + 1, W)).c), Z.e, "0") : (g(V, 2, A.length, "Base"), J = x(v(l(Z.c), nt, "0"), 10, V, tt, !0)), tt < 0 && Z.c[0] && (J = "-" + J)), J; }, j.valueOf = j.toJSON = function () { return H(this); }, j._isBigNumber = !0, _ != null && U.set(_), U; }()).default = e.BigNumber = e, (d = function () { return e; }.call(m, f, m, E)) === void 0 || (E.exports = d); }();
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { r || (r = d.reduce((n, t) => n + t.length, 0)); const e = new Uint8Array(r); let c = 0; for (const n of d)
                    e.set(n, c), c += n.length; return e; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e, c) { return r.bytes = e.bytes = 0, { type: d, encode: r, decode: e, encodingLength: c }; };
            }, function (E, m, f) {
                "use strict";
                var d = m, r = f(38), e = f(51), c = f(233);
                d.assert = e, d.toArray = c.toArray, d.zero2 = c.zero2, d.toHex = c.toHex, d.encode = c.encode, d.getNAF = function (n, t, s) { var u = new Array(Math.max(n.bitLength(), s) + 1); u.fill(0); for (var i = 1 << t + 1, o = n.clone(), h = 0; h < u.length; h++) {
                    var a, l = o.andln(i - 1);
                    o.isOdd() ? (a = l > (i >> 1) - 1 ? (i >> 1) - l : l, o.isubn(a)) : a = 0, u[h] = a, o.iushrn(1);
                } return u; }, d.getJSF = function (n, t) { var s = [[], []]; n = n.clone(), t = t.clone(); for (var u = 0, i = 0; n.cmpn(-u) > 0 || t.cmpn(-i) > 0;) {
                    var o, h, a, l = n.andln(3) + u & 3, p = t.andln(3) + i & 3;
                    (l === 3 && (l = -1), p === 3 && (p = -1), (1 & l) == 0) ? o = 0 : o = (a = n.andln(7) + u & 7) !== 3 && a !== 5 || p !== 2 ? l : -l, (s[0].push(o), (1 & p) == 0) ? h = 0 : h = (a = t.andln(7) + i & 7) !== 3 && a !== 5 || l !== 2 ? p : -p, s[1].push(h), 2 * u === o + 1 && (u = 1 - u), 2 * i === h + 1 && (i = 1 - i), n.iushrn(1), t.iushrn(1);
                } return s; }, d.cachedProperty = function (n, t, s) { var u = "_" + t; n.prototype[t] = function () { return this[u] !== void 0 ? this[u] : this[u] = s.call(this); }; }, d.parseBytes = function (n) { return typeof n == "string" ? d.toArray(n, "hex") : n; }, d.intFromLE = function (n) { return new r(n, "hex", "le"); };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = Symbol.for("BufferList");
                function e(c) { if (!(this instanceof e))
                    return new e(c); e._init.call(this, c); }
                e._init = function (c) { Object.defineProperty(this, r, { value: !0 }), this._bufs = [], this.length = 0, c && this.append(c); }, e.prototype._new = function (c) { return new e(c); }, e.prototype._offset = function (c) { if (c === 0)
                    return [0, 0]; let n = 0; for (let t = 0; t < this._bufs.length; t++) {
                    const s = n + this._bufs[t].length;
                    if (c < s || t === this._bufs.length - 1)
                        return [t, c - n];
                    n = s;
                } }, e.prototype._reverseOffset = function (c) { const n = c[0]; let t = c[1]; for (let s = 0; s < n; s++)
                    t += this._bufs[s].length; return t; }, e.prototype.get = function (c) { if (c > this.length || c < 0)
                    return; const n = this._offset(c); return this._bufs[n[0]][n[1]]; }, e.prototype.slice = function (c, n) { return typeof c == "number" && c < 0 && (c += this.length), typeof n == "number" && n < 0 && (n += this.length), this.copy(null, 0, c, n); }, e.prototype.copy = function (c, n, t, s) { if ((typeof t != "number" || t < 0) && (t = 0), (typeof s != "number" || s > this.length) && (s = this.length), t >= this.length)
                    return c || d.alloc(0); if (s <= 0)
                    return c || d.alloc(0); const u = !!c, i = this._offset(t), o = s - t; let h = o, a = u && n || 0, l = i[1]; if (t === 0 && s === this.length) {
                    if (!u)
                        return this._bufs.length === 1 ? this._bufs[0] : d.concat(this._bufs, this.length);
                    for (let p = 0; p < this._bufs.length; p++)
                        this._bufs[p].copy(c, a), a += this._bufs[p].length;
                    return c;
                } if (h <= this._bufs[i[0]].length - l)
                    return u ? this._bufs[i[0]].copy(c, n, l, l + h) : this._bufs[i[0]].slice(l, l + h); u || (c = d.allocUnsafe(o)); for (let p = i[0]; p < this._bufs.length; p++) {
                    const g = this._bufs[p].length - l;
                    if (!(h > g)) {
                        this._bufs[p].copy(c, a, l, l + h), a += g;
                        break;
                    }
                    this._bufs[p].copy(c, a, l), a += g, h -= g, l && (l = 0);
                } return c.length > a ? c.slice(0, a) : c; }, e.prototype.shallowSlice = function (c, n) { if (c = c || 0, n = typeof n != "number" ? this.length : n, c < 0 && (c += this.length), n < 0 && (n += this.length), c === n)
                    return this._new(); const t = this._offset(c), s = this._offset(n), u = this._bufs.slice(t[0], s[0] + 1); return s[1] === 0 ? u.pop() : u[u.length - 1] = u[u.length - 1].slice(0, s[1]), t[1] !== 0 && (u[0] = u[0].slice(t[1])), this._new(u); }, e.prototype.toString = function (c, n, t) { return this.slice(n, t).toString(c); }, e.prototype.consume = function (c) { if (c = Math.trunc(c), Number.isNaN(c) || c <= 0)
                    return this; for (; this._bufs.length;) {
                    if (!(c >= this._bufs[0].length)) {
                        this._bufs[0] = this._bufs[0].slice(c), this.length -= c;
                        break;
                    }
                    c -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
                } return this; }, e.prototype.duplicate = function () { const c = this._new(); for (let n = 0; n < this._bufs.length; n++)
                    c.append(this._bufs[n]); return c; }, e.prototype.append = function (c) { if (c == null)
                    return this; if (c.buffer)
                    this._appendBuffer(d.from(c.buffer, c.byteOffset, c.byteLength));
                else if (Array.isArray(c))
                    for (let n = 0; n < c.length; n++)
                        this.append(c[n]);
                else if (this._isBufferList(c))
                    for (let n = 0; n < c._bufs.length; n++)
                        this.append(c._bufs[n]);
                else
                    typeof c == "number" && (c = c.toString()), this._appendBuffer(d.from(c)); return this; }, e.prototype._appendBuffer = function (c) { this._bufs.push(c), this.length += c.length; }, e.prototype.indexOf = function (c, n, t) { if (t === void 0 && typeof n == "string" && (t = n, n = void 0), typeof c == "function" || Array.isArray(c))
                    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.'); if (typeof c == "number" ? c = d.from([c]) : typeof c == "string" ? c = d.from(c, t) : this._isBufferList(c) ? c = c.slice() : Array.isArray(c.buffer) ? c = d.from(c.buffer, c.byteOffset, c.byteLength) : d.isBuffer(c) || (c = d.from(c)), n = Number(n || 0), isNaN(n) && (n = 0), n < 0 && (n = this.length + n), n < 0 && (n = 0), c.length === 0)
                    return n > this.length ? this.length : n; const s = this._offset(n); let u = s[0], i = s[1]; for (; u < this._bufs.length; u++) {
                    const o = this._bufs[u];
                    for (; i < o.length;)
                        if (o.length - i >= c.length) {
                            const h = o.indexOf(c, i);
                            if (h !== -1)
                                return this._reverseOffset([u, h]);
                            i = o.length - c.length + 1;
                        }
                        else {
                            const h = this._reverseOffset([u, i]);
                            if (this._match(h, c))
                                return h;
                            i++;
                        }
                    i = 0;
                } return -1; }, e.prototype._match = function (c, n) { if (this.length - c < n.length)
                    return !1; for (let t = 0; t < n.length; t++)
                    if (this.get(c + t) !== n[t])
                        return !1; return !0; }, function () { const c = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null }; for (const n in c)
                    !function (t) { e.prototype[t] = c[t] === null ? function (s, u) { return this.slice(s, s + u)[t](0, u); } : function (s) { return this.slice(s, s + c[t])[t](0); }; }(n); }(), e.prototype._isBufferList = function (c) { return c instanceof e || e.isBufferList(c); }, e.isBufferList = function (c) { return c != null && c[r]; }, E.exports = e;
            }, function (E, m, f) {
                "use strict";
                m.encode = f(824), m.decode = f(825), m.varintEncode = f(327), m.varintDecode = f(328), m.int32BEEncode = f(826), m.int32BEDecode = f(827);
            }, function (E, m, f) {
                "use strict";
                var d = f(51), r = f(15);
                function e(s, u) { return (64512 & s.charCodeAt(u)) == 55296 && !(u < 0 || u + 1 >= s.length) && (64512 & s.charCodeAt(u + 1)) == 56320; }
                function c(s) { return (s >>> 24 | s >>> 8 & 65280 | s << 8 & 16711680 | (255 & s) << 24) >>> 0; }
                function n(s) { return s.length === 1 ? "0" + s : s; }
                function t(s) { return s.length === 7 ? "0" + s : s.length === 6 ? "00" + s : s.length === 5 ? "000" + s : s.length === 4 ? "0000" + s : s.length === 3 ? "00000" + s : s.length === 2 ? "000000" + s : s.length === 1 ? "0000000" + s : s; }
                m.inherits = r, m.toArray = function (s, u) { if (Array.isArray(s))
                    return s.slice(); if (!s)
                    return []; var i = []; if (typeof s == "string")
                    if (u) {
                        if (u === "hex")
                            for ((s = s.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (s = "0" + s), h = 0; h < s.length; h += 2)
                                i.push(parseInt(s[h] + s[h + 1], 16));
                    }
                    else
                        for (var o = 0, h = 0; h < s.length; h++) {
                            var a = s.charCodeAt(h);
                            a < 128 ? i[o++] = a : a < 2048 ? (i[o++] = a >> 6 | 192, i[o++] = 63 & a | 128) : e(s, h) ? (a = 65536 + ((1023 & a) << 10) + (1023 & s.charCodeAt(++h)), i[o++] = a >> 18 | 240, i[o++] = a >> 12 & 63 | 128, i[o++] = a >> 6 & 63 | 128, i[o++] = 63 & a | 128) : (i[o++] = a >> 12 | 224, i[o++] = a >> 6 & 63 | 128, i[o++] = 63 & a | 128);
                        }
                else
                    for (h = 0; h < s.length; h++)
                        i[h] = 0 | s[h]; return i; }, m.toHex = function (s) { for (var u = "", i = 0; i < s.length; i++)
                    u += n(s[i].toString(16)); return u; }, m.htonl = c, m.toHex32 = function (s, u) { for (var i = "", o = 0; o < s.length; o++) {
                    var h = s[o];
                    u === "little" && (h = c(h)), i += t(h.toString(16));
                } return i; }, m.zero2 = n, m.zero8 = t, m.join32 = function (s, u, i, o) { var h = i - u; d(h % 4 == 0); for (var a = new Array(h / 4), l = 0, p = u; l < a.length; l++, p += 4) {
                    var g;
                    g = o === "big" ? s[p] << 24 | s[p + 1] << 16 | s[p + 2] << 8 | s[p + 3] : s[p + 3] << 24 | s[p + 2] << 16 | s[p + 1] << 8 | s[p], a[l] = g >>> 0;
                } return a; }, m.split32 = function (s, u) { for (var i = new Array(4 * s.length), o = 0, h = 0; o < s.length; o++, h += 4) {
                    var a = s[o];
                    u === "big" ? (i[h] = a >>> 24, i[h + 1] = a >>> 16 & 255, i[h + 2] = a >>> 8 & 255, i[h + 3] = 255 & a) : (i[h + 3] = a >>> 24, i[h + 2] = a >>> 16 & 255, i[h + 1] = a >>> 8 & 255, i[h] = 255 & a);
                } return i; }, m.rotr32 = function (s, u) { return s >>> u | s << 32 - u; }, m.rotl32 = function (s, u) { return s << u | s >>> 32 - u; }, m.sum32 = function (s, u) { return s + u >>> 0; }, m.sum32_3 = function (s, u, i) { return s + u + i >>> 0; }, m.sum32_4 = function (s, u, i, o) { return s + u + i + o >>> 0; }, m.sum32_5 = function (s, u, i, o, h) { return s + u + i + o + h >>> 0; }, m.sum64 = function (s, u, i, o) { var h = s[u], a = o + s[u + 1] >>> 0, l = (a < o ? 1 : 0) + i + h; s[u] = l >>> 0, s[u + 1] = a; }, m.sum64_hi = function (s, u, i, o) { return (u + o >>> 0 < u ? 1 : 0) + s + i >>> 0; }, m.sum64_lo = function (s, u, i, o) { return u + o >>> 0; }, m.sum64_4_hi = function (s, u, i, o, h, a, l, p) { var g = 0, b = u; return g += (b = b + o >>> 0) < u ? 1 : 0, g += (b = b + a >>> 0) < a ? 1 : 0, s + i + h + l + (g += (b = b + p >>> 0) < p ? 1 : 0) >>> 0; }, m.sum64_4_lo = function (s, u, i, o, h, a, l, p) { return u + o + a + p >>> 0; }, m.sum64_5_hi = function (s, u, i, o, h, a, l, p, g, b) { var I = 0, v = u; return I += (v = v + o >>> 0) < u ? 1 : 0, I += (v = v + a >>> 0) < a ? 1 : 0, I += (v = v + p >>> 0) < p ? 1 : 0, s + i + h + l + g + (I += (v = v + b >>> 0) < b ? 1 : 0) >>> 0; }, m.sum64_5_lo = function (s, u, i, o, h, a, l, p, g, b) { return u + o + a + p + b >>> 0; }, m.rotr64_hi = function (s, u, i) { return (u << 32 - i | s >>> i) >>> 0; }, m.rotr64_lo = function (s, u, i) { return (s << 32 - i | u >>> i) >>> 0; }, m.shr64_hi = function (s, u, i) { return s >>> i; }, m.shr64_lo = function (s, u, i) { return (s << 32 - i | u >>> i) >>> 0; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(4), e = f(669), c = f(40), n = u => { if (u instanceof Uint8Array)
                    return { cid: new r(u), toResolve: [] }; if (r.isCID(u))
                    return { cid: u, toResolve: [] }; if (typeof u == "string") {
                    u.indexOf("/ipfs/") === 0 && (u = u.substring(6));
                    const i = ((o = "") => (o.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean))(u);
                    return { cid: new r(i[0]), toResolve: i.slice(1) };
                } throw d(new Error("Unknown path type " + u), "ERR_BAD_PATH"); }, t = async function* (u, i, o) { let { cid: h, toResolve: a } = n(u), l = h.toBaseEncodedString(), p = l; const g = a.length; for (;;) {
                    const b = await e(h, l, p, a, g, i, o);
                    if (!b.entry && !b.next)
                        throw d(new Error("Could not resolve " + u), "ERR_NOT_FOUND");
                    if (b.entry && (yield b.entry), !b.next)
                        return;
                    a = b.next.toResolve, h = b.next.cid, l = b.next.name, p = b.next.path;
                } }, s = (u, i, o) => c(t(u, i, o));
                E.exports = s, E.exports.path = t, E.exports.recursive = async function* (u, i, o) { const h = await s(u, i, o); if (yield h, h.unixfs && h.unixfs.type.includes("dir"))
                    for await (const a of async function* l(p, g) { for await (const b of p.content(g))
                        if (yield b, b.unixfs.type.includes("dir"))
                            for await (const I of l(b, g))
                                yield I; }(h, o))
                        yield a; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { !function (r, e) { function c(S, T) { if (!S)
                    throw new Error(T || "Assertion failed"); } function n(S, T) { S.super_ = T; var B = function () { }; B.prototype = T.prototype, S.prototype = new B, S.prototype.constructor = S; } function t(S, T, B) { if (t.isBN(S))
                    return S; this.negative = 0, this.words = null, this.length = 0, this.red = null, S !== null && (T !== "le" && T !== "be" || (B = T, T = 10), this._init(S || 0, T || 10, B || "be")); } var s; typeof r == "object" ? r.exports = t : (void 0).BN = t, t.BN = t, t.wordSize = 26; try {
                    s = f(472).Buffer;
                }
                catch (S) { } function u(S, T, B) { for (var P = 0, L = Math.min(S.length, B), j = T; j < L; j++) {
                    var D = S.charCodeAt(j) - 48;
                    P <<= 4, P |= D >= 49 && D <= 54 ? D - 49 + 10 : D >= 17 && D <= 22 ? D - 17 + 10 : 15 & D;
                } return P; } function i(S, T, B, P) { for (var L = 0, j = Math.min(S.length, B), D = T; D < j; D++) {
                    var G = S.charCodeAt(D) - 48;
                    L *= P, L += G >= 49 ? G - 49 + 10 : G >= 17 ? G - 17 + 10 : G;
                } return L; } t.isBN = function (S) { return S instanceof t || S !== null && typeof S == "object" && S.constructor.wordSize === t.wordSize && Array.isArray(S.words); }, t.max = function (S, T) { return S.cmp(T) > 0 ? S : T; }, t.min = function (S, T) { return S.cmp(T) < 0 ? S : T; }, t.prototype._init = function (S, T, B) { if (typeof S == "number")
                    return this._initNumber(S, T, B); if (typeof S == "object")
                    return this._initArray(S, T, B); T === "hex" && (T = 16), c(T === (0 | T) && T >= 2 && T <= 36); var P = 0; (S = S.toString().replace(/\s+/g, ""))[0] === "-" && P++, T === 16 ? this._parseHex(S, P) : this._parseBase(S, T, P), S[0] === "-" && (this.negative = 1), this.strip(), B === "le" && this._initArray(this.toArray(), T, B); }, t.prototype._initNumber = function (S, T, B) { S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [67108863 & S], this.length = 1) : S < 4503599627370496 ? (this.words = [67108863 & S, S / 67108864 & 67108863], this.length = 2) : (c(S < 9007199254740992), this.words = [67108863 & S, S / 67108864 & 67108863, 1], this.length = 3), B === "le" && this._initArray(this.toArray(), T, B); }, t.prototype._initArray = function (S, T, B) { if (c(typeof S.length == "number"), S.length <= 0)
                    return this.words = [0], this.length = 1, this; this.length = Math.ceil(S.length / 3), this.words = new Array(this.length); for (var P = 0; P < this.length; P++)
                    this.words[P] = 0; var L, j, D = 0; if (B === "be")
                    for (P = S.length - 1, L = 0; P >= 0; P -= 3)
                        j = S[P] | S[P - 1] << 8 | S[P - 2] << 16, this.words[L] |= j << D & 67108863, this.words[L + 1] = j >>> 26 - D & 67108863, (D += 24) >= 26 && (D -= 26, L++);
                else if (B === "le")
                    for (P = 0, L = 0; P < S.length; P += 3)
                        j = S[P] | S[P + 1] << 8 | S[P + 2] << 16, this.words[L] |= j << D & 67108863, this.words[L + 1] = j >>> 26 - D & 67108863, (D += 24) >= 26 && (D -= 26, L++); return this.strip(); }, t.prototype._parseHex = function (S, T) { this.length = Math.ceil((S.length - T) / 6), this.words = new Array(this.length); for (var B = 0; B < this.length; B++)
                    this.words[B] = 0; var P, L, j = 0; for (B = S.length - 6, P = 0; B >= T; B -= 6)
                    L = u(S, B, B + 6), this.words[P] |= L << j & 67108863, this.words[P + 1] |= L >>> 26 - j & 4194303, (j += 24) >= 26 && (j -= 26, P++); B + 6 !== T && (L = u(S, T, B + 6), this.words[P] |= L << j & 67108863, this.words[P + 1] |= L >>> 26 - j & 4194303), this.strip(); }, t.prototype._parseBase = function (S, T, B) { this.words = [0], this.length = 1; for (var P = 0, L = 1; L <= 67108863; L *= T)
                    P++; P--, L = L / T | 0; for (var j = S.length - B, D = j % P, G = Math.min(j, j - D) + B, W = 0, X = B; X < G; X += P)
                    W = i(S, X, X + P, T), this.imuln(L), this.words[0] + W < 67108864 ? this.words[0] += W : this._iaddn(W); if (D !== 0) {
                    var Q = 1;
                    for (W = i(S, X, S.length, T), X = 0; X < D; X++)
                        Q *= T;
                    this.imuln(Q), this.words[0] + W < 67108864 ? this.words[0] += W : this._iaddn(W);
                } }, t.prototype.copy = function (S) { S.words = new Array(this.length); for (var T = 0; T < this.length; T++)
                    S.words[T] = this.words[T]; S.length = this.length, S.negative = this.negative, S.red = this.red; }, t.prototype.clone = function () { var S = new t(null); return this.copy(S), S; }, t.prototype._expand = function (S) { for (; this.length < S;)
                    this.words[this.length++] = 0; return this; }, t.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)
                    this.length--; return this._normSign(); }, t.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this; }, t.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"; }; var o = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], h = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], a = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; function l(S, T, B) { B.negative = T.negative ^ S.negative; var P = S.length + T.length | 0; B.length = P, P = P - 1 | 0; var L = 0 | S.words[0], j = 0 | T.words[0], D = L * j, G = 67108863 & D, W = D / 67108864 | 0; B.words[0] = G; for (var X = 1; X < P; X++) {
                    for (var Q = W >>> 26, K = 67108863 & W, F = Math.min(X, T.length - 1), Y = Math.max(0, X - S.length + 1); Y <= F; Y++) {
                        var $ = X - Y | 0;
                        Q += (D = (L = 0 | S.words[$]) * (j = 0 | T.words[Y]) + K) / 67108864 | 0, K = 67108863 & D;
                    }
                    B.words[X] = 0 | K, W = 0 | Q;
                } return W !== 0 ? B.words[X] = 0 | W : B.length--, B.strip(); } t.prototype.toString = function (S, T) { var B; if (T = 0 | T || 1, (S = S || 10) === 16 || S === "hex") {
                    B = "";
                    for (var P = 0, L = 0, j = 0; j < this.length; j++) {
                        var D = this.words[j], G = (16777215 & (D << P | L)).toString(16);
                        B = (L = D >>> 24 - P & 16777215) !== 0 || j !== this.length - 1 ? o[6 - G.length] + G + B : G + B, (P += 2) >= 26 && (P -= 26, j--);
                    }
                    for (L !== 0 && (B = L.toString(16) + B); B.length % T != 0;)
                        B = "0" + B;
                    return this.negative !== 0 && (B = "-" + B), B;
                } if (S === (0 | S) && S >= 2 && S <= 36) {
                    var W = h[S], X = a[S];
                    B = "";
                    var Q = this.clone();
                    for (Q.negative = 0; !Q.isZero();) {
                        var K = Q.modn(X).toString(S);
                        B = (Q = Q.idivn(X)).isZero() ? K + B : o[W - K.length] + K + B;
                    }
                    for (this.isZero() && (B = "0" + B); B.length % T != 0;)
                        B = "0" + B;
                    return this.negative !== 0 && (B = "-" + B), B;
                } c(!1, "Base should be between 2 and 36"); }, t.prototype.toNumber = function () { var S = this.words[0]; return this.length === 2 ? S += 67108864 * this.words[1] : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && c(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S; }, t.prototype.toJSON = function () { return this.toString(16); }, t.prototype.toBuffer = function (S, T) { return c(s !== void 0), this.toArrayLike(s, S, T); }, t.prototype.toArray = function (S, T) { return this.toArrayLike(Array, S, T); }, t.prototype.toArrayLike = function (S, T, B) { var P = this.byteLength(), L = B || Math.max(1, P); c(P <= L, "byte array longer than desired length"), c(L > 0, "Requested array length <= 0"), this.strip(); var j, D, G = T === "le", W = new S(L), X = this.clone(); if (G) {
                    for (D = 0; !X.isZero(); D++)
                        j = X.andln(255), X.iushrn(8), W[D] = j;
                    for (; D < L; D++)
                        W[D] = 0;
                }
                else {
                    for (D = 0; D < L - P; D++)
                        W[D] = 0;
                    for (D = 0; !X.isZero(); D++)
                        j = X.andln(255), X.iushrn(8), W[L - D - 1] = j;
                } return W; }, Math.clz32 ? t.prototype._countBits = function (S) { return 32 - Math.clz32(S); } : t.prototype._countBits = function (S) { var T = S, B = 0; return T >= 4096 && (B += 13, T >>>= 13), T >= 64 && (B += 7, T >>>= 7), T >= 8 && (B += 4, T >>>= 4), T >= 2 && (B += 2, T >>>= 2), B + T; }, t.prototype._zeroBits = function (S) { if (S === 0)
                    return 26; var T = S, B = 0; return (8191 & T) == 0 && (B += 13, T >>>= 13), (127 & T) == 0 && (B += 7, T >>>= 7), (15 & T) == 0 && (B += 4, T >>>= 4), (3 & T) == 0 && (B += 2, T >>>= 2), (1 & T) == 0 && B++, B; }, t.prototype.bitLength = function () { var S = this.words[this.length - 1], T = this._countBits(S); return 26 * (this.length - 1) + T; }, t.prototype.zeroBits = function () { if (this.isZero())
                    return 0; for (var S = 0, T = 0; T < this.length; T++) {
                    var B = this._zeroBits(this.words[T]);
                    if (S += B, B !== 26)
                        break;
                } return S; }, t.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8); }, t.prototype.toTwos = function (S) { return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone(); }, t.prototype.fromTwos = function (S) { return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone(); }, t.prototype.isNeg = function () { return this.negative !== 0; }, t.prototype.neg = function () { return this.clone().ineg(); }, t.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this; }, t.prototype.iuor = function (S) { for (; this.length < S.length;)
                    this.words[this.length++] = 0; for (var T = 0; T < S.length; T++)
                    this.words[T] = this.words[T] | S.words[T]; return this.strip(); }, t.prototype.ior = function (S) { return c((this.negative | S.negative) == 0), this.iuor(S); }, t.prototype.or = function (S) { return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this); }, t.prototype.uor = function (S) { return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this); }, t.prototype.iuand = function (S) { var T; T = this.length > S.length ? S : this; for (var B = 0; B < T.length; B++)
                    this.words[B] = this.words[B] & S.words[B]; return this.length = T.length, this.strip(); }, t.prototype.iand = function (S) { return c((this.negative | S.negative) == 0), this.iuand(S); }, t.prototype.and = function (S) { return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this); }, t.prototype.uand = function (S) { return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this); }, t.prototype.iuxor = function (S) { var T, B; this.length > S.length ? (T = this, B = S) : (T = S, B = this); for (var P = 0; P < B.length; P++)
                    this.words[P] = T.words[P] ^ B.words[P]; if (this !== T)
                    for (; P < T.length; P++)
                        this.words[P] = T.words[P]; return this.length = T.length, this.strip(); }, t.prototype.ixor = function (S) { return c((this.negative | S.negative) == 0), this.iuxor(S); }, t.prototype.xor = function (S) { return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this); }, t.prototype.uxor = function (S) { return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this); }, t.prototype.inotn = function (S) { c(typeof S == "number" && S >= 0); var T = 0 | Math.ceil(S / 26), B = S % 26; this._expand(T), B > 0 && T--; for (var P = 0; P < T; P++)
                    this.words[P] = 67108863 & ~this.words[P]; return B > 0 && (this.words[P] = ~this.words[P] & 67108863 >> 26 - B), this.strip(); }, t.prototype.notn = function (S) { return this.clone().inotn(S); }, t.prototype.setn = function (S, T) { c(typeof S == "number" && S >= 0); var B = S / 26 | 0, P = S % 26; return this._expand(B + 1), this.words[B] = T ? this.words[B] | 1 << P : this.words[B] & ~(1 << P), this.strip(); }, t.prototype.iadd = function (S) { var T, B, P; if (this.negative !== 0 && S.negative === 0)
                    return this.negative = 0, T = this.isub(S), this.negative ^= 1, this._normSign(); if (this.negative === 0 && S.negative !== 0)
                    return S.negative = 0, T = this.isub(S), S.negative = 1, T._normSign(); this.length > S.length ? (B = this, P = S) : (B = S, P = this); for (var L = 0, j = 0; j < P.length; j++)
                    T = (0 | B.words[j]) + (0 | P.words[j]) + L, this.words[j] = 67108863 & T, L = T >>> 26; for (; L !== 0 && j < B.length; j++)
                    T = (0 | B.words[j]) + L, this.words[j] = 67108863 & T, L = T >>> 26; if (this.length = B.length, L !== 0)
                    this.words[this.length] = L, this.length++;
                else if (B !== this)
                    for (; j < B.length; j++)
                        this.words[j] = B.words[j]; return this; }, t.prototype.add = function (S) { var T; return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, T = this.sub(S), S.negative ^= 1, T) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, T = S.sub(this), this.negative = 1, T) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this); }, t.prototype.isub = function (S) { if (S.negative !== 0) {
                    S.negative = 0;
                    var T = this.iadd(S);
                    return S.negative = 1, T._normSign();
                } if (this.negative !== 0)
                    return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign(); var B, P, L = this.cmp(S); if (L === 0)
                    return this.negative = 0, this.length = 1, this.words[0] = 0, this; L > 0 ? (B = this, P = S) : (B = S, P = this); for (var j = 0, D = 0; D < P.length; D++)
                    j = (T = (0 | B.words[D]) - (0 | P.words[D]) + j) >> 26, this.words[D] = 67108863 & T; for (; j !== 0 && D < B.length; D++)
                    j = (T = (0 | B.words[D]) + j) >> 26, this.words[D] = 67108863 & T; if (j === 0 && D < B.length && B !== this)
                    for (; D < B.length; D++)
                        this.words[D] = B.words[D]; return this.length = Math.max(this.length, D), B !== this && (this.negative = 1), this.strip(); }, t.prototype.sub = function (S) { return this.clone().isub(S); }; var p = function (S, T, B) { var P, L, j, D = S.words, G = T.words, W = B.words, X = 0, Q = 0 | D[0], K = 8191 & Q, F = Q >>> 13, Y = 0 | D[1], $ = 8191 & Y, y = Y >>> 13, C = 0 | D[2], A = 8191 & C, U = C >>> 13, z = 0 | D[3], w = 8191 & z, O = z >>> 13, q = 0 | D[4], H = 8191 & q, V = q >>> 13, J = 0 | D[5], Z = 8191 & J, tt = J >>> 13, nt = 0 | D[6], rt = 8191 & nt, it = nt >>> 13, st = 0 | D[7], at = 8191 & st, ct = st >>> 13, lt = 0 | D[8], pt = 8191 & lt, mt = lt >>> 13, Tt = 0 | D[9], vt = 8191 & Tt, Rt = Tt >>> 13, Bt = 0 | G[0], wt = 8191 & Bt, kt = Bt >>> 13, Wt = 0 | G[1], Ct = 8191 & Wt, Ft = Wt >>> 13, te = 0 | G[2], jt = 8191 & te, Kt = te >>> 13, re = 0 | G[3], St = 8191 & re, Nt = re >>> 13, ne = 0 | G[4], Vt = 8191 & ne, qt = ne >>> 13, ee = 0 | G[5], Ot = 8191 & ee, ft = ee >>> 13, gt = 0 | G[6], bt = 8191 & gt, _t = gt >>> 13, Lt = 0 | G[7], Pt = 8191 & Lt, Mt = Lt >>> 13, Yt = 0 | G[8], Dt = 8191 & Yt, zt = Yt >>> 13, he = 0 | G[9], Gt = 8191 & he, Ut = he >>> 13; B.negative = S.negative ^ T.negative, B.length = 19; var de = (X + (P = Math.imul(K, wt)) | 0) + ((8191 & (L = (L = Math.imul(K, kt)) + Math.imul(F, wt) | 0)) << 13) | 0; X = ((j = Math.imul(F, kt)) + (L >>> 13) | 0) + (de >>> 26) | 0, de &= 67108863, P = Math.imul($, wt), L = (L = Math.imul($, kt)) + Math.imul(y, wt) | 0, j = Math.imul(y, kt); var Zt = (X + (P = P + Math.imul(K, Ct) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, Ft) | 0) + Math.imul(F, Ct) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, Ft) | 0) + (L >>> 13) | 0) + (Zt >>> 26) | 0, Zt &= 67108863, P = Math.imul(A, wt), L = (L = Math.imul(A, kt)) + Math.imul(U, wt) | 0, j = Math.imul(U, kt), P = P + Math.imul($, Ct) | 0, L = (L = L + Math.imul($, Ft) | 0) + Math.imul(y, Ct) | 0, j = j + Math.imul(y, Ft) | 0; var Xt = (X + (P = P + Math.imul(K, jt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, Kt) | 0) + Math.imul(F, jt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, Kt) | 0) + (L >>> 13) | 0) + (Xt >>> 26) | 0, Xt &= 67108863, P = Math.imul(w, wt), L = (L = Math.imul(w, kt)) + Math.imul(O, wt) | 0, j = Math.imul(O, kt), P = P + Math.imul(A, Ct) | 0, L = (L = L + Math.imul(A, Ft) | 0) + Math.imul(U, Ct) | 0, j = j + Math.imul(U, Ft) | 0, P = P + Math.imul($, jt) | 0, L = (L = L + Math.imul($, Kt) | 0) + Math.imul(y, jt) | 0, j = j + Math.imul(y, Kt) | 0; var ie = (X + (P = P + Math.imul(K, St) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, Nt) | 0) + Math.imul(F, St) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, Nt) | 0) + (L >>> 13) | 0) + (ie >>> 26) | 0, ie &= 67108863, P = Math.imul(H, wt), L = (L = Math.imul(H, kt)) + Math.imul(V, wt) | 0, j = Math.imul(V, kt), P = P + Math.imul(w, Ct) | 0, L = (L = L + Math.imul(w, Ft) | 0) + Math.imul(O, Ct) | 0, j = j + Math.imul(O, Ft) | 0, P = P + Math.imul(A, jt) | 0, L = (L = L + Math.imul(A, Kt) | 0) + Math.imul(U, jt) | 0, j = j + Math.imul(U, Kt) | 0, P = P + Math.imul($, St) | 0, L = (L = L + Math.imul($, Nt) | 0) + Math.imul(y, St) | 0, j = j + Math.imul(y, Nt) | 0; var Qt = (X + (P = P + Math.imul(K, Vt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, qt) | 0) + Math.imul(F, Vt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, qt) | 0) + (L >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, P = Math.imul(Z, wt), L = (L = Math.imul(Z, kt)) + Math.imul(tt, wt) | 0, j = Math.imul(tt, kt), P = P + Math.imul(H, Ct) | 0, L = (L = L + Math.imul(H, Ft) | 0) + Math.imul(V, Ct) | 0, j = j + Math.imul(V, Ft) | 0, P = P + Math.imul(w, jt) | 0, L = (L = L + Math.imul(w, Kt) | 0) + Math.imul(O, jt) | 0, j = j + Math.imul(O, Kt) | 0, P = P + Math.imul(A, St) | 0, L = (L = L + Math.imul(A, Nt) | 0) + Math.imul(U, St) | 0, j = j + Math.imul(U, Nt) | 0, P = P + Math.imul($, Vt) | 0, L = (L = L + Math.imul($, qt) | 0) + Math.imul(y, Vt) | 0, j = j + Math.imul(y, qt) | 0; var $t = (X + (P = P + Math.imul(K, Ot) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, ft) | 0) + Math.imul(F, Ot) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, ft) | 0) + (L >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(rt, wt), L = (L = Math.imul(rt, kt)) + Math.imul(it, wt) | 0, j = Math.imul(it, kt), P = P + Math.imul(Z, Ct) | 0, L = (L = L + Math.imul(Z, Ft) | 0) + Math.imul(tt, Ct) | 0, j = j + Math.imul(tt, Ft) | 0, P = P + Math.imul(H, jt) | 0, L = (L = L + Math.imul(H, Kt) | 0) + Math.imul(V, jt) | 0, j = j + Math.imul(V, Kt) | 0, P = P + Math.imul(w, St) | 0, L = (L = L + Math.imul(w, Nt) | 0) + Math.imul(O, St) | 0, j = j + Math.imul(O, Nt) | 0, P = P + Math.imul(A, Vt) | 0, L = (L = L + Math.imul(A, qt) | 0) + Math.imul(U, Vt) | 0, j = j + Math.imul(U, qt) | 0, P = P + Math.imul($, Ot) | 0, L = (L = L + Math.imul($, ft) | 0) + Math.imul(y, Ot) | 0, j = j + Math.imul(y, ft) | 0; var ye = (X + (P = P + Math.imul(K, bt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, _t) | 0) + Math.imul(F, bt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, _t) | 0) + (L >>> 13) | 0) + (ye >>> 26) | 0, ye &= 67108863, P = Math.imul(at, wt), L = (L = Math.imul(at, kt)) + Math.imul(ct, wt) | 0, j = Math.imul(ct, kt), P = P + Math.imul(rt, Ct) | 0, L = (L = L + Math.imul(rt, Ft) | 0) + Math.imul(it, Ct) | 0, j = j + Math.imul(it, Ft) | 0, P = P + Math.imul(Z, jt) | 0, L = (L = L + Math.imul(Z, Kt) | 0) + Math.imul(tt, jt) | 0, j = j + Math.imul(tt, Kt) | 0, P = P + Math.imul(H, St) | 0, L = (L = L + Math.imul(H, Nt) | 0) + Math.imul(V, St) | 0, j = j + Math.imul(V, Nt) | 0, P = P + Math.imul(w, Vt) | 0, L = (L = L + Math.imul(w, qt) | 0) + Math.imul(O, Vt) | 0, j = j + Math.imul(O, qt) | 0, P = P + Math.imul(A, Ot) | 0, L = (L = L + Math.imul(A, ft) | 0) + Math.imul(U, Ot) | 0, j = j + Math.imul(U, ft) | 0, P = P + Math.imul($, bt) | 0, L = (L = L + Math.imul($, _t) | 0) + Math.imul(y, bt) | 0, j = j + Math.imul(y, _t) | 0; var se = (X + (P = P + Math.imul(K, Pt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, Mt) | 0) + Math.imul(F, Pt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, Mt) | 0) + (L >>> 13) | 0) + (se >>> 26) | 0, se &= 67108863, P = Math.imul(pt, wt), L = (L = Math.imul(pt, kt)) + Math.imul(mt, wt) | 0, j = Math.imul(mt, kt), P = P + Math.imul(at, Ct) | 0, L = (L = L + Math.imul(at, Ft) | 0) + Math.imul(ct, Ct) | 0, j = j + Math.imul(ct, Ft) | 0, P = P + Math.imul(rt, jt) | 0, L = (L = L + Math.imul(rt, Kt) | 0) + Math.imul(it, jt) | 0, j = j + Math.imul(it, Kt) | 0, P = P + Math.imul(Z, St) | 0, L = (L = L + Math.imul(Z, Nt) | 0) + Math.imul(tt, St) | 0, j = j + Math.imul(tt, Nt) | 0, P = P + Math.imul(H, Vt) | 0, L = (L = L + Math.imul(H, qt) | 0) + Math.imul(V, Vt) | 0, j = j + Math.imul(V, qt) | 0, P = P + Math.imul(w, Ot) | 0, L = (L = L + Math.imul(w, ft) | 0) + Math.imul(O, Ot) | 0, j = j + Math.imul(O, ft) | 0, P = P + Math.imul(A, bt) | 0, L = (L = L + Math.imul(A, _t) | 0) + Math.imul(U, bt) | 0, j = j + Math.imul(U, _t) | 0, P = P + Math.imul($, Pt) | 0, L = (L = L + Math.imul($, Mt) | 0) + Math.imul(y, Pt) | 0, j = j + Math.imul(y, Mt) | 0; var Ht = (X + (P = P + Math.imul(K, Dt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, zt) | 0) + Math.imul(F, Dt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, zt) | 0) + (L >>> 13) | 0) + (Ht >>> 26) | 0, Ht &= 67108863, P = Math.imul(vt, wt), L = (L = Math.imul(vt, kt)) + Math.imul(Rt, wt) | 0, j = Math.imul(Rt, kt), P = P + Math.imul(pt, Ct) | 0, L = (L = L + Math.imul(pt, Ft) | 0) + Math.imul(mt, Ct) | 0, j = j + Math.imul(mt, Ft) | 0, P = P + Math.imul(at, jt) | 0, L = (L = L + Math.imul(at, Kt) | 0) + Math.imul(ct, jt) | 0, j = j + Math.imul(ct, Kt) | 0, P = P + Math.imul(rt, St) | 0, L = (L = L + Math.imul(rt, Nt) | 0) + Math.imul(it, St) | 0, j = j + Math.imul(it, Nt) | 0, P = P + Math.imul(Z, Vt) | 0, L = (L = L + Math.imul(Z, qt) | 0) + Math.imul(tt, Vt) | 0, j = j + Math.imul(tt, qt) | 0, P = P + Math.imul(H, Ot) | 0, L = (L = L + Math.imul(H, ft) | 0) + Math.imul(V, Ot) | 0, j = j + Math.imul(V, ft) | 0, P = P + Math.imul(w, bt) | 0, L = (L = L + Math.imul(w, _t) | 0) + Math.imul(O, bt) | 0, j = j + Math.imul(O, _t) | 0, P = P + Math.imul(A, Pt) | 0, L = (L = L + Math.imul(A, Mt) | 0) + Math.imul(U, Pt) | 0, j = j + Math.imul(U, Mt) | 0, P = P + Math.imul($, Dt) | 0, L = (L = L + Math.imul($, zt) | 0) + Math.imul(y, Dt) | 0, j = j + Math.imul(y, zt) | 0; var dt = (X + (P = P + Math.imul(K, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(K, Ut) | 0) + Math.imul(F, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(F, Ut) | 0) + (L >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, P = Math.imul(vt, Ct), L = (L = Math.imul(vt, Ft)) + Math.imul(Rt, Ct) | 0, j = Math.imul(Rt, Ft), P = P + Math.imul(pt, jt) | 0, L = (L = L + Math.imul(pt, Kt) | 0) + Math.imul(mt, jt) | 0, j = j + Math.imul(mt, Kt) | 0, P = P + Math.imul(at, St) | 0, L = (L = L + Math.imul(at, Nt) | 0) + Math.imul(ct, St) | 0, j = j + Math.imul(ct, Nt) | 0, P = P + Math.imul(rt, Vt) | 0, L = (L = L + Math.imul(rt, qt) | 0) + Math.imul(it, Vt) | 0, j = j + Math.imul(it, qt) | 0, P = P + Math.imul(Z, Ot) | 0, L = (L = L + Math.imul(Z, ft) | 0) + Math.imul(tt, Ot) | 0, j = j + Math.imul(tt, ft) | 0, P = P + Math.imul(H, bt) | 0, L = (L = L + Math.imul(H, _t) | 0) + Math.imul(V, bt) | 0, j = j + Math.imul(V, _t) | 0, P = P + Math.imul(w, Pt) | 0, L = (L = L + Math.imul(w, Mt) | 0) + Math.imul(O, Pt) | 0, j = j + Math.imul(O, Mt) | 0, P = P + Math.imul(A, Dt) | 0, L = (L = L + Math.imul(A, zt) | 0) + Math.imul(U, Dt) | 0, j = j + Math.imul(U, zt) | 0; var yt = (X + (P = P + Math.imul($, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul($, Ut) | 0) + Math.imul(y, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(y, Ut) | 0) + (L >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, P = Math.imul(vt, jt), L = (L = Math.imul(vt, Kt)) + Math.imul(Rt, jt) | 0, j = Math.imul(Rt, Kt), P = P + Math.imul(pt, St) | 0, L = (L = L + Math.imul(pt, Nt) | 0) + Math.imul(mt, St) | 0, j = j + Math.imul(mt, Nt) | 0, P = P + Math.imul(at, Vt) | 0, L = (L = L + Math.imul(at, qt) | 0) + Math.imul(ct, Vt) | 0, j = j + Math.imul(ct, qt) | 0, P = P + Math.imul(rt, Ot) | 0, L = (L = L + Math.imul(rt, ft) | 0) + Math.imul(it, Ot) | 0, j = j + Math.imul(it, ft) | 0, P = P + Math.imul(Z, bt) | 0, L = (L = L + Math.imul(Z, _t) | 0) + Math.imul(tt, bt) | 0, j = j + Math.imul(tt, _t) | 0, P = P + Math.imul(H, Pt) | 0, L = (L = L + Math.imul(H, Mt) | 0) + Math.imul(V, Pt) | 0, j = j + Math.imul(V, Mt) | 0, P = P + Math.imul(w, Dt) | 0, L = (L = L + Math.imul(w, zt) | 0) + Math.imul(O, Dt) | 0, j = j + Math.imul(O, zt) | 0; var ot = (X + (P = P + Math.imul(A, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(A, Ut) | 0) + Math.imul(U, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(U, Ut) | 0) + (L >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, P = Math.imul(vt, St), L = (L = Math.imul(vt, Nt)) + Math.imul(Rt, St) | 0, j = Math.imul(Rt, Nt), P = P + Math.imul(pt, Vt) | 0, L = (L = L + Math.imul(pt, qt) | 0) + Math.imul(mt, Vt) | 0, j = j + Math.imul(mt, qt) | 0, P = P + Math.imul(at, Ot) | 0, L = (L = L + Math.imul(at, ft) | 0) + Math.imul(ct, Ot) | 0, j = j + Math.imul(ct, ft) | 0, P = P + Math.imul(rt, bt) | 0, L = (L = L + Math.imul(rt, _t) | 0) + Math.imul(it, bt) | 0, j = j + Math.imul(it, _t) | 0, P = P + Math.imul(Z, Pt) | 0, L = (L = L + Math.imul(Z, Mt) | 0) + Math.imul(tt, Pt) | 0, j = j + Math.imul(tt, Mt) | 0, P = P + Math.imul(H, Dt) | 0, L = (L = L + Math.imul(H, zt) | 0) + Math.imul(V, Dt) | 0, j = j + Math.imul(V, zt) | 0; var Et = (X + (P = P + Math.imul(w, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(w, Ut) | 0) + Math.imul(O, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(O, Ut) | 0) + (L >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(vt, Vt), L = (L = Math.imul(vt, qt)) + Math.imul(Rt, Vt) | 0, j = Math.imul(Rt, qt), P = P + Math.imul(pt, Ot) | 0, L = (L = L + Math.imul(pt, ft) | 0) + Math.imul(mt, Ot) | 0, j = j + Math.imul(mt, ft) | 0, P = P + Math.imul(at, bt) | 0, L = (L = L + Math.imul(at, _t) | 0) + Math.imul(ct, bt) | 0, j = j + Math.imul(ct, _t) | 0, P = P + Math.imul(rt, Pt) | 0, L = (L = L + Math.imul(rt, Mt) | 0) + Math.imul(it, Pt) | 0, j = j + Math.imul(it, Mt) | 0, P = P + Math.imul(Z, Dt) | 0, L = (L = L + Math.imul(Z, zt) | 0) + Math.imul(tt, Dt) | 0, j = j + Math.imul(tt, zt) | 0; var It = (X + (P = P + Math.imul(H, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(H, Ut) | 0) + Math.imul(V, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(V, Ut) | 0) + (L >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(vt, Ot), L = (L = Math.imul(vt, ft)) + Math.imul(Rt, Ot) | 0, j = Math.imul(Rt, ft), P = P + Math.imul(pt, bt) | 0, L = (L = L + Math.imul(pt, _t) | 0) + Math.imul(mt, bt) | 0, j = j + Math.imul(mt, _t) | 0, P = P + Math.imul(at, Pt) | 0, L = (L = L + Math.imul(at, Mt) | 0) + Math.imul(ct, Pt) | 0, j = j + Math.imul(ct, Mt) | 0, P = P + Math.imul(rt, Dt) | 0, L = (L = L + Math.imul(rt, zt) | 0) + Math.imul(it, Dt) | 0, j = j + Math.imul(it, zt) | 0; var At = (X + (P = P + Math.imul(Z, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(Z, Ut) | 0) + Math.imul(tt, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(tt, Ut) | 0) + (L >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(vt, bt), L = (L = Math.imul(vt, _t)) + Math.imul(Rt, bt) | 0, j = Math.imul(Rt, _t), P = P + Math.imul(pt, Pt) | 0, L = (L = L + Math.imul(pt, Mt) | 0) + Math.imul(mt, Pt) | 0, j = j + Math.imul(mt, Mt) | 0, P = P + Math.imul(at, Dt) | 0, L = (L = L + Math.imul(at, zt) | 0) + Math.imul(ct, Dt) | 0, j = j + Math.imul(ct, zt) | 0; var ut = (X + (P = P + Math.imul(rt, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(rt, Ut) | 0) + Math.imul(it, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(it, Ut) | 0) + (L >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, P = Math.imul(vt, Pt), L = (L = Math.imul(vt, Mt)) + Math.imul(Rt, Pt) | 0, j = Math.imul(Rt, Mt), P = P + Math.imul(pt, Dt) | 0, L = (L = L + Math.imul(pt, zt) | 0) + Math.imul(mt, Dt) | 0, j = j + Math.imul(mt, zt) | 0; var et = (X + (P = P + Math.imul(at, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(at, Ut) | 0) + Math.imul(ct, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(ct, Ut) | 0) + (L >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, P = Math.imul(vt, Dt), L = (L = Math.imul(vt, zt)) + Math.imul(Rt, Dt) | 0, j = Math.imul(Rt, zt); var ht = (X + (P = P + Math.imul(pt, Gt) | 0) | 0) + ((8191 & (L = (L = L + Math.imul(pt, Ut) | 0) + Math.imul(mt, Gt) | 0)) << 13) | 0; X = ((j = j + Math.imul(mt, Ut) | 0) + (L >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863; var xt = (X + (P = Math.imul(vt, Gt)) | 0) + ((8191 & (L = (L = Math.imul(vt, Ut)) + Math.imul(Rt, Gt) | 0)) << 13) | 0; return X = ((j = Math.imul(Rt, Ut)) + (L >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, W[0] = de, W[1] = Zt, W[2] = Xt, W[3] = ie, W[4] = Qt, W[5] = $t, W[6] = ye, W[7] = se, W[8] = Ht, W[9] = dt, W[10] = yt, W[11] = ot, W[12] = Et, W[13] = It, W[14] = At, W[15] = ut, W[16] = et, W[17] = ht, W[18] = xt, X !== 0 && (W[19] = X, B.length++), B; }; function g(S, T, B) { return new b().mulp(S, T, B); } function b(S, T) { this.x = S, this.y = T; } Math.imul || (p = l), t.prototype.mulTo = function (S, T) { var B = this.length + S.length; return this.length === 10 && S.length === 10 ? p(this, S, T) : B < 63 ? l(this, S, T) : B < 1024 ? function (P, L, j) { j.negative = L.negative ^ P.negative, j.length = P.length + L.length; for (var D = 0, G = 0, W = 0; W < j.length - 1; W++) {
                    var X = G;
                    G = 0;
                    for (var Q = 67108863 & D, K = Math.min(W, L.length - 1), F = Math.max(0, W - P.length + 1); F <= K; F++) {
                        var Y = W - F, $ = (0 | P.words[Y]) * (0 | L.words[F]), y = 67108863 & $;
                        Q = 67108863 & (y = y + Q | 0), G += (X = (X = X + ($ / 67108864 | 0) | 0) + (y >>> 26) | 0) >>> 26, X &= 67108863;
                    }
                    j.words[W] = Q, D = X, X = G;
                } return D !== 0 ? j.words[W] = D : j.length--, j.strip(); }(this, S, T) : g(this, S, T); }, b.prototype.makeRBT = function (S) { for (var T = new Array(S), B = t.prototype._countBits(S) - 1, P = 0; P < S; P++)
                    T[P] = this.revBin(P, B, S); return T; }, b.prototype.revBin = function (S, T, B) { if (S === 0 || S === B - 1)
                    return S; for (var P = 0, L = 0; L < T; L++)
                    P |= (1 & S) << T - L - 1, S >>= 1; return P; }, b.prototype.permute = function (S, T, B, P, L, j) { for (var D = 0; D < j; D++)
                    P[D] = T[S[D]], L[D] = B[S[D]]; }, b.prototype.transform = function (S, T, B, P, L, j) { this.permute(j, S, T, B, P, L); for (var D = 1; D < L; D <<= 1)
                    for (var G = D << 1, W = Math.cos(2 * Math.PI / G), X = Math.sin(2 * Math.PI / G), Q = 0; Q < L; Q += G)
                        for (var K = W, F = X, Y = 0; Y < D; Y++) {
                            var $ = B[Q + Y], y = P[Q + Y], C = B[Q + Y + D], A = P[Q + Y + D], U = K * C - F * A;
                            A = K * A + F * C, C = U, B[Q + Y] = $ + C, P[Q + Y] = y + A, B[Q + Y + D] = $ - C, P[Q + Y + D] = y - A, Y !== G && (U = W * K - X * F, F = W * F + X * K, K = U);
                        } }, b.prototype.guessLen13b = function (S, T) { var B = 1 | Math.max(T, S), P = 1 & B, L = 0; for (B = B / 2 | 0; B; B >>>= 1)
                    L++; return 1 << L + 1 + P; }, b.prototype.conjugate = function (S, T, B) { if (!(B <= 1))
                    for (var P = 0; P < B / 2; P++) {
                        var L = S[P];
                        S[P] = S[B - P - 1], S[B - P - 1] = L, L = T[P], T[P] = -T[B - P - 1], T[B - P - 1] = -L;
                    } }, b.prototype.normalize13b = function (S, T) { for (var B = 0, P = 0; P < T / 2; P++) {
                    var L = 8192 * Math.round(S[2 * P + 1] / T) + Math.round(S[2 * P] / T) + B;
                    S[P] = 67108863 & L, B = L < 67108864 ? 0 : L / 67108864 | 0;
                } return S; }, b.prototype.convert13b = function (S, T, B, P) { for (var L = 0, j = 0; j < T; j++)
                    L += 0 | S[j], B[2 * j] = 8191 & L, L >>>= 13, B[2 * j + 1] = 8191 & L, L >>>= 13; for (j = 2 * T; j < P; ++j)
                    B[j] = 0; c(L === 0), c((-8192 & L) == 0); }, b.prototype.stub = function (S) { for (var T = new Array(S), B = 0; B < S; B++)
                    T[B] = 0; return T; }, b.prototype.mulp = function (S, T, B) { var P = 2 * this.guessLen13b(S.length, T.length), L = this.makeRBT(P), j = this.stub(P), D = new Array(P), G = new Array(P), W = new Array(P), X = new Array(P), Q = new Array(P), K = new Array(P), F = B.words; F.length = P, this.convert13b(S.words, S.length, D, P), this.convert13b(T.words, T.length, X, P), this.transform(D, j, G, W, P, L), this.transform(X, j, Q, K, P, L); for (var Y = 0; Y < P; Y++) {
                    var $ = G[Y] * Q[Y] - W[Y] * K[Y];
                    W[Y] = G[Y] * K[Y] + W[Y] * Q[Y], G[Y] = $;
                } return this.conjugate(G, W, P), this.transform(G, W, F, j, P, L), this.conjugate(F, j, P), this.normalize13b(F, P), B.negative = S.negative ^ T.negative, B.length = S.length + T.length, B.strip(); }, t.prototype.mul = function (S) { var T = new t(null); return T.words = new Array(this.length + S.length), this.mulTo(S, T); }, t.prototype.mulf = function (S) { var T = new t(null); return T.words = new Array(this.length + S.length), g(this, S, T); }, t.prototype.imul = function (S) { return this.clone().mulTo(S, this); }, t.prototype.imuln = function (S) { c(typeof S == "number"), c(S < 67108864); for (var T = 0, B = 0; B < this.length; B++) {
                    var P = (0 | this.words[B]) * S, L = (67108863 & P) + (67108863 & T);
                    T >>= 26, T += P / 67108864 | 0, T += L >>> 26, this.words[B] = 67108863 & L;
                } return T !== 0 && (this.words[B] = T, this.length++), this; }, t.prototype.muln = function (S) { return this.clone().imuln(S); }, t.prototype.sqr = function () { return this.mul(this); }, t.prototype.isqr = function () { return this.imul(this.clone()); }, t.prototype.pow = function (S) { var T = function (j) { for (var D = new Array(j.bitLength()), G = 0; G < D.length; G++) {
                    var W = G / 26 | 0, X = G % 26;
                    D[G] = (j.words[W] & 1 << X) >>> X;
                } return D; }(S); if (T.length === 0)
                    return new t(1); for (var B = this, P = 0; P < T.length && T[P] === 0; P++, B = B.sqr())
                    ; if (++P < T.length)
                    for (var L = B.sqr(); P < T.length; P++, L = L.sqr())
                        T[P] !== 0 && (B = B.mul(L)); return B; }, t.prototype.iushln = function (S) { c(typeof S == "number" && S >= 0); var T, B = S % 26, P = (S - B) / 26, L = 67108863 >>> 26 - B << 26 - B; if (B !== 0) {
                    var j = 0;
                    for (T = 0; T < this.length; T++) {
                        var D = this.words[T] & L, G = (0 | this.words[T]) - D << B;
                        this.words[T] = G | j, j = D >>> 26 - B;
                    }
                    j && (this.words[T] = j, this.length++);
                } if (P !== 0) {
                    for (T = this.length - 1; T >= 0; T--)
                        this.words[T + P] = this.words[T];
                    for (T = 0; T < P; T++)
                        this.words[T] = 0;
                    this.length += P;
                } return this.strip(); }, t.prototype.ishln = function (S) { return c(this.negative === 0), this.iushln(S); }, t.prototype.iushrn = function (S, T, B) { var P; c(typeof S == "number" && S >= 0), P = T ? (T - T % 26) / 26 : 0; var L = S % 26, j = Math.min((S - L) / 26, this.length), D = 67108863 ^ 67108863 >>> L << L, G = B; if (P -= j, P = Math.max(0, P), G) {
                    for (var W = 0; W < j; W++)
                        G.words[W] = this.words[W];
                    G.length = j;
                } if (!(j === 0))
                    if (this.length > j)
                        for (this.length -= j, W = 0; W < this.length; W++)
                            this.words[W] = this.words[W + j];
                    else
                        this.words[0] = 0, this.length = 1; var X = 0; for (W = this.length - 1; W >= 0 && (X !== 0 || W >= P); W--) {
                    var Q = 0 | this.words[W];
                    this.words[W] = X << 26 - L | Q >>> L, X = Q & D;
                } return G && X !== 0 && (G.words[G.length++] = X), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip(); }, t.prototype.ishrn = function (S, T, B) { return c(this.negative === 0), this.iushrn(S, T, B); }, t.prototype.shln = function (S) { return this.clone().ishln(S); }, t.prototype.ushln = function (S) { return this.clone().iushln(S); }, t.prototype.shrn = function (S) { return this.clone().ishrn(S); }, t.prototype.ushrn = function (S) { return this.clone().iushrn(S); }, t.prototype.testn = function (S) { c(typeof S == "number" && S >= 0); var T = S % 26, B = (S - T) / 26, P = 1 << T; return !(this.length <= B) && !!(this.words[B] & P); }, t.prototype.imaskn = function (S) { c(typeof S == "number" && S >= 0); var T = S % 26, B = (S - T) / 26; if (c(this.negative === 0, "imaskn works only with positive numbers"), this.length <= B)
                    return this; if (T !== 0 && B++, this.length = Math.min(B, this.length), T !== 0) {
                    var P = 67108863 ^ 67108863 >>> T << T;
                    this.words[this.length - 1] &= P;
                } return this.strip(); }, t.prototype.maskn = function (S) { return this.clone().imaskn(S); }, t.prototype.iaddn = function (S) { return c(typeof S == "number"), c(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (0 | this.words[0]) < S ? (this.words[0] = S - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S); }, t.prototype._iaddn = function (S) { this.words[0] += S; for (var T = 0; T < this.length && this.words[T] >= 67108864; T++)
                    this.words[T] -= 67108864, T === this.length - 1 ? this.words[T + 1] = 1 : this.words[T + 1]++; return this.length = Math.max(this.length, T + 1), this; }, t.prototype.isubn = function (S) { if (c(typeof S == "number"), c(S < 67108864), S < 0)
                    return this.iaddn(-S); if (this.negative !== 0)
                    return this.negative = 0, this.iaddn(S), this.negative = 1, this; if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
                    this.words[0] = -this.words[0], this.negative = 1;
                else
                    for (var T = 0; T < this.length && this.words[T] < 0; T++)
                        this.words[T] += 67108864, this.words[T + 1] -= 1; return this.strip(); }, t.prototype.addn = function (S) { return this.clone().iaddn(S); }, t.prototype.subn = function (S) { return this.clone().isubn(S); }, t.prototype.iabs = function () { return this.negative = 0, this; }, t.prototype.abs = function () { return this.clone().iabs(); }, t.prototype._ishlnsubmul = function (S, T, B) { var P, L, j = S.length + B; this._expand(j); var D = 0; for (P = 0; P < S.length; P++) {
                    L = (0 | this.words[P + B]) + D;
                    var G = (0 | S.words[P]) * T;
                    D = ((L -= 67108863 & G) >> 26) - (G / 67108864 | 0), this.words[P + B] = 67108863 & L;
                } for (; P < this.length - B; P++)
                    D = (L = (0 | this.words[P + B]) + D) >> 26, this.words[P + B] = 67108863 & L; if (D === 0)
                    return this.strip(); for (c(D === -1), D = 0, P = 0; P < this.length; P++)
                    D = (L = -(0 | this.words[P]) + D) >> 26, this.words[P] = 67108863 & L; return this.negative = 1, this.strip(); }, t.prototype._wordDiv = function (S, T) { var B = (this.length, S.length), P = this.clone(), L = S, j = 0 | L.words[L.length - 1]; (B = 26 - this._countBits(j)) !== 0 && (L = L.ushln(B), P.iushln(B), j = 0 | L.words[L.length - 1]); var D, G = P.length - L.length; if (T !== "mod") {
                    (D = new t(null)).length = G + 1, D.words = new Array(D.length);
                    for (var W = 0; W < D.length; W++)
                        D.words[W] = 0;
                } var X = P.clone()._ishlnsubmul(L, 1, G); X.negative === 0 && (P = X, D && (D.words[G] = 1)); for (var Q = G - 1; Q >= 0; Q--) {
                    var K = 67108864 * (0 | P.words[L.length + Q]) + (0 | P.words[L.length + Q - 1]);
                    for (K = Math.min(K / j | 0, 67108863), P._ishlnsubmul(L, K, Q); P.negative !== 0;)
                        K--, P.negative = 0, P._ishlnsubmul(L, 1, Q), P.isZero() || (P.negative ^= 1);
                    D && (D.words[Q] = K);
                } return D && D.strip(), P.strip(), T !== "div" && B !== 0 && P.iushrn(B), { div: D || null, mod: P }; }, t.prototype.divmod = function (S, T, B) { return c(!S.isZero()), this.isZero() ? { div: new t(0), mod: new t(0) } : this.negative !== 0 && S.negative === 0 ? (j = this.neg().divmod(S, T), T !== "mod" && (P = j.div.neg()), T !== "div" && (L = j.mod.neg(), B && L.negative !== 0 && L.iadd(S)), { div: P, mod: L }) : this.negative === 0 && S.negative !== 0 ? (j = this.divmod(S.neg(), T), T !== "mod" && (P = j.div.neg()), { div: P, mod: j.mod }) : (this.negative & S.negative) != 0 ? (j = this.neg().divmod(S.neg(), T), T !== "div" && (L = j.mod.neg(), B && L.negative !== 0 && L.isub(S)), { div: j.div, mod: L }) : S.length > this.length || this.cmp(S) < 0 ? { div: new t(0), mod: this } : S.length === 1 ? T === "div" ? { div: this.divn(S.words[0]), mod: null } : T === "mod" ? { div: null, mod: new t(this.modn(S.words[0])) } : { div: this.divn(S.words[0]), mod: new t(this.modn(S.words[0])) } : this._wordDiv(S, T); var P, L, j; }, t.prototype.div = function (S) { return this.divmod(S, "div", !1).div; }, t.prototype.mod = function (S) { return this.divmod(S, "mod", !1).mod; }, t.prototype.umod = function (S) { return this.divmod(S, "mod", !0).mod; }, t.prototype.divRound = function (S) { var T = this.divmod(S); if (T.mod.isZero())
                    return T.div; var B = T.div.negative !== 0 ? T.mod.isub(S) : T.mod, P = S.ushrn(1), L = S.andln(1), j = B.cmp(P); return j < 0 || L === 1 && j === 0 ? T.div : T.div.negative !== 0 ? T.div.isubn(1) : T.div.iaddn(1); }, t.prototype.modn = function (S) { c(S <= 67108863); for (var T = (1 << 26) % S, B = 0, P = this.length - 1; P >= 0; P--)
                    B = (T * B + (0 | this.words[P])) % S; return B; }, t.prototype.idivn = function (S) { c(S <= 67108863); for (var T = 0, B = this.length - 1; B >= 0; B--) {
                    var P = (0 | this.words[B]) + 67108864 * T;
                    this.words[B] = P / S | 0, T = P % S;
                } return this.strip(); }, t.prototype.divn = function (S) { return this.clone().idivn(S); }, t.prototype.egcd = function (S) { c(S.negative === 0), c(!S.isZero()); var T = this, B = S.clone(); T = T.negative !== 0 ? T.umod(S) : T.clone(); for (var P = new t(1), L = new t(0), j = new t(0), D = new t(1), G = 0; T.isEven() && B.isEven();)
                    T.iushrn(1), B.iushrn(1), ++G; for (var W = B.clone(), X = T.clone(); !T.isZero();) {
                    for (var Q = 0, K = 1; (T.words[0] & K) == 0 && Q < 26; ++Q, K <<= 1)
                        ;
                    if (Q > 0)
                        for (T.iushrn(Q); Q-- > 0;)
                            (P.isOdd() || L.isOdd()) && (P.iadd(W), L.isub(X)), P.iushrn(1), L.iushrn(1);
                    for (var F = 0, Y = 1; (B.words[0] & Y) == 0 && F < 26; ++F, Y <<= 1)
                        ;
                    if (F > 0)
                        for (B.iushrn(F); F-- > 0;)
                            (j.isOdd() || D.isOdd()) && (j.iadd(W), D.isub(X)), j.iushrn(1), D.iushrn(1);
                    T.cmp(B) >= 0 ? (T.isub(B), P.isub(j), L.isub(D)) : (B.isub(T), j.isub(P), D.isub(L));
                } return { a: j, b: D, gcd: B.iushln(G) }; }, t.prototype._invmp = function (S) { c(S.negative === 0), c(!S.isZero()); var T = this, B = S.clone(); T = T.negative !== 0 ? T.umod(S) : T.clone(); for (var P, L = new t(1), j = new t(0), D = B.clone(); T.cmpn(1) > 0 && B.cmpn(1) > 0;) {
                    for (var G = 0, W = 1; (T.words[0] & W) == 0 && G < 26; ++G, W <<= 1)
                        ;
                    if (G > 0)
                        for (T.iushrn(G); G-- > 0;)
                            L.isOdd() && L.iadd(D), L.iushrn(1);
                    for (var X = 0, Q = 1; (B.words[0] & Q) == 0 && X < 26; ++X, Q <<= 1)
                        ;
                    if (X > 0)
                        for (B.iushrn(X); X-- > 0;)
                            j.isOdd() && j.iadd(D), j.iushrn(1);
                    T.cmp(B) >= 0 ? (T.isub(B), L.isub(j)) : (B.isub(T), j.isub(L));
                } return (P = T.cmpn(1) === 0 ? L : j).cmpn(0) < 0 && P.iadd(S), P; }, t.prototype.gcd = function (S) { if (this.isZero())
                    return S.abs(); if (S.isZero())
                    return this.abs(); var T = this.clone(), B = S.clone(); T.negative = 0, B.negative = 0; for (var P = 0; T.isEven() && B.isEven(); P++)
                    T.iushrn(1), B.iushrn(1); for (;;) {
                    for (; T.isEven();)
                        T.iushrn(1);
                    for (; B.isEven();)
                        B.iushrn(1);
                    var L = T.cmp(B);
                    if (L < 0) {
                        var j = T;
                        T = B, B = j;
                    }
                    else if (L === 0 || B.cmpn(1) === 0)
                        break;
                    T.isub(B);
                } return B.iushln(P); }, t.prototype.invm = function (S) { return this.egcd(S).a.umod(S); }, t.prototype.isEven = function () { return (1 & this.words[0]) == 0; }, t.prototype.isOdd = function () { return (1 & this.words[0]) == 1; }, t.prototype.andln = function (S) { return this.words[0] & S; }, t.prototype.bincn = function (S) { c(typeof S == "number"); var T = S % 26, B = (S - T) / 26, P = 1 << T; if (this.length <= B)
                    return this._expand(B + 1), this.words[B] |= P, this; for (var L = P, j = B; L !== 0 && j < this.length; j++) {
                    var D = 0 | this.words[j];
                    L = (D += L) >>> 26, D &= 67108863, this.words[j] = D;
                } return L !== 0 && (this.words[j] = L, this.length++), this; }, t.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0; }, t.prototype.cmpn = function (S) { var T, B = S < 0; if (this.negative !== 0 && !B)
                    return -1; if (this.negative === 0 && B)
                    return 1; if (this.strip(), this.length > 1)
                    T = 1;
                else {
                    B && (S = -S), c(S <= 67108863, "Number is too big");
                    var P = 0 | this.words[0];
                    T = P === S ? 0 : P < S ? -1 : 1;
                } return this.negative !== 0 ? 0 | -T : T; }, t.prototype.cmp = function (S) { if (this.negative !== 0 && S.negative === 0)
                    return -1; if (this.negative === 0 && S.negative !== 0)
                    return 1; var T = this.ucmp(S); return this.negative !== 0 ? 0 | -T : T; }, t.prototype.ucmp = function (S) { if (this.length > S.length)
                    return 1; if (this.length < S.length)
                    return -1; for (var T = 0, B = this.length - 1; B >= 0; B--) {
                    var P = 0 | this.words[B], L = 0 | S.words[B];
                    if (P !== L) {
                        P < L ? T = -1 : P > L && (T = 1);
                        break;
                    }
                } return T; }, t.prototype.gtn = function (S) { return this.cmpn(S) === 1; }, t.prototype.gt = function (S) { return this.cmp(S) === 1; }, t.prototype.gten = function (S) { return this.cmpn(S) >= 0; }, t.prototype.gte = function (S) { return this.cmp(S) >= 0; }, t.prototype.ltn = function (S) { return this.cmpn(S) === -1; }, t.prototype.lt = function (S) { return this.cmp(S) === -1; }, t.prototype.lten = function (S) { return this.cmpn(S) <= 0; }, t.prototype.lte = function (S) { return this.cmp(S) <= 0; }, t.prototype.eqn = function (S) { return this.cmpn(S) === 0; }, t.prototype.eq = function (S) { return this.cmp(S) === 0; }, t.red = function (S) { return new M(S); }, t.prototype.toRed = function (S) { return c(!this.red, "Already a number in reduction context"), c(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S); }, t.prototype.fromRed = function () { return c(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this); }, t.prototype._forceRed = function (S) { return this.red = S, this; }, t.prototype.forceRed = function (S) { return c(!this.red, "Already a number in reduction context"), this._forceRed(S); }, t.prototype.redAdd = function (S) { return c(this.red, "redAdd works only with red numbers"), this.red.add(this, S); }, t.prototype.redIAdd = function (S) { return c(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S); }, t.prototype.redSub = function (S) { return c(this.red, "redSub works only with red numbers"), this.red.sub(this, S); }, t.prototype.redISub = function (S) { return c(this.red, "redISub works only with red numbers"), this.red.isub(this, S); }, t.prototype.redShl = function (S) { return c(this.red, "redShl works only with red numbers"), this.red.shl(this, S); }, t.prototype.redMul = function (S) { return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S); }, t.prototype.redIMul = function (S) { return c(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S); }, t.prototype.redSqr = function () { return c(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this); }, t.prototype.redISqr = function () { return c(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this); }, t.prototype.redSqrt = function () { return c(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this); }, t.prototype.redInvm = function () { return c(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this); }, t.prototype.redNeg = function () { return c(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this); }, t.prototype.redPow = function (S) { return c(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S); }; var I = { k256: null, p224: null, p192: null, p25519: null }; function v(S, T) { this.name = S, this.p = new t(T, 16), this.n = this.p.bitLength(), this.k = new t(1).iushln(this.n).isub(this.p), this.tmp = this._tmp(); } function R() { v.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"); } function _() { v.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"); } function k() { v.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"); } function x() { v.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"); } function M(S) { if (typeof S == "string") {
                    var T = t._prime(S);
                    this.m = T.p, this.prime = T;
                }
                else
                    c(S.gtn(1), "modulus must be greater than 1"), this.m = S, this.prime = null; } function N(S) { M.call(this, S), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new t(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv); } v.prototype._tmp = function () { var S = new t(null); return S.words = new Array(Math.ceil(this.n / 13)), S; }, v.prototype.ireduce = function (S) { var T, B = S; do
                    this.split(B, this.tmp), T = (B = (B = this.imulK(B)).iadd(this.tmp)).bitLength();
                while (T > this.n); var P = T < this.n ? -1 : B.ucmp(this.p); return P === 0 ? (B.words[0] = 0, B.length = 1) : P > 0 ? B.isub(this.p) : B.strip !== void 0 ? B.strip() : B._strip(), B; }, v.prototype.split = function (S, T) { S.iushrn(this.n, 0, T); }, v.prototype.imulK = function (S) { return S.imul(this.k); }, n(R, v), R.prototype.split = function (S, T) { for (var B = Math.min(S.length, 9), P = 0; P < B; P++)
                    T.words[P] = S.words[P]; if (T.length = B, S.length <= 9)
                    return S.words[0] = 0, void (S.length = 1); var L = S.words[9]; for (T.words[T.length++] = 4194303 & L, P = 10; P < S.length; P++) {
                    var j = 0 | S.words[P];
                    S.words[P - 10] = (4194303 & j) << 4 | L >>> 22, L = j;
                } L >>>= 22, S.words[P - 10] = L, L === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9; }, R.prototype.imulK = function (S) { S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2; for (var T = 0, B = 0; B < S.length; B++) {
                    var P = 0 | S.words[B];
                    T += 977 * P, S.words[B] = 67108863 & T, T = 64 * P + (T / 67108864 | 0);
                } return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S; }, n(_, v), n(k, v), n(x, v), x.prototype.imulK = function (S) { for (var T = 0, B = 0; B < S.length; B++) {
                    var P = 19 * (0 | S.words[B]) + T, L = 67108863 & P;
                    P >>>= 26, S.words[B] = L, T = P;
                } return T !== 0 && (S.words[S.length++] = T), S; }, t._prime = function (S) { if (I[S])
                    return I[S]; var T; if (S === "k256")
                    T = new R;
                else if (S === "p224")
                    T = new _;
                else if (S === "p192")
                    T = new k;
                else {
                    if (S !== "p25519")
                        throw new Error("Unknown prime " + S);
                    T = new x;
                } return I[S] = T, T; }, M.prototype._verify1 = function (S) { c(S.negative === 0, "red works only with positives"), c(S.red, "red works only with red numbers"); }, M.prototype._verify2 = function (S, T) { c((S.negative | T.negative) == 0, "red works only with positives"), c(S.red && S.red === T.red, "red works only with red numbers"); }, M.prototype.imod = function (S) { return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this); }, M.prototype.neg = function (S) { return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this); }, M.prototype.add = function (S, T) { this._verify2(S, T); var B = S.add(T); return B.cmp(this.m) >= 0 && B.isub(this.m), B._forceRed(this); }, M.prototype.iadd = function (S, T) { this._verify2(S, T); var B = S.iadd(T); return B.cmp(this.m) >= 0 && B.isub(this.m), B; }, M.prototype.sub = function (S, T) { this._verify2(S, T); var B = S.sub(T); return B.cmpn(0) < 0 && B.iadd(this.m), B._forceRed(this); }, M.prototype.isub = function (S, T) { this._verify2(S, T); var B = S.isub(T); return B.cmpn(0) < 0 && B.iadd(this.m), B; }, M.prototype.shl = function (S, T) { return this._verify1(S), this.imod(S.ushln(T)); }, M.prototype.imul = function (S, T) { return this._verify2(S, T), this.imod(S.imul(T)); }, M.prototype.mul = function (S, T) { return this._verify2(S, T), this.imod(S.mul(T)); }, M.prototype.isqr = function (S) { return this.imul(S, S.clone()); }, M.prototype.sqr = function (S) { return this.mul(S, S); }, M.prototype.sqrt = function (S) { if (S.isZero())
                    return S.clone(); var T = this.m.andln(3); if (c(T % 2 == 1), T === 3) {
                    var B = this.m.add(new t(1)).iushrn(2);
                    return this.pow(S, B);
                } for (var P = this.m.subn(1), L = 0; !P.isZero() && P.andln(1) === 0;)
                    L++, P.iushrn(1); c(!P.isZero()); var j = new t(1).toRed(this), D = j.redNeg(), G = this.m.subn(1).iushrn(1), W = this.m.bitLength(); for (W = new t(2 * W * W).toRed(this); this.pow(W, G).cmp(D) !== 0;)
                    W.redIAdd(D); for (var X = this.pow(W, P), Q = this.pow(S, P.addn(1).iushrn(1)), K = this.pow(S, P), F = L; K.cmp(j) !== 0;) {
                    for (var Y = K, $ = 0; Y.cmp(j) !== 0; $++)
                        Y = Y.redSqr();
                    c($ < F);
                    var y = this.pow(X, new t(1).iushln(F - $ - 1));
                    Q = Q.redMul(y), X = y.redSqr(), K = K.redMul(X), F = $;
                } return Q; }, M.prototype.invm = function (S) { var T = S._invmp(this.m); return T.negative !== 0 ? (T.negative = 0, this.imod(T).redNeg()) : this.imod(T); }, M.prototype.pow = function (S, T) { if (T.isZero())
                    return new t(1).toRed(this); if (T.cmpn(1) === 0)
                    return S.clone(); var B = new Array(16); B[0] = new t(1).toRed(this), B[1] = S; for (var P = 2; P < B.length; P++)
                    B[P] = this.mul(B[P - 1], S); var L = B[0], j = 0, D = 0, G = T.bitLength() % 26; for (G === 0 && (G = 26), P = T.length - 1; P >= 0; P--) {
                    for (var W = T.words[P], X = G - 1; X >= 0; X--) {
                        var Q = W >> X & 1;
                        L !== B[0] && (L = this.sqr(L)), Q !== 0 || j !== 0 ? (j <<= 1, j |= Q, (++D === 4 || P === 0 && X === 0) && (L = this.mul(L, B[j]), D = 0, j = 0)) : D = 0;
                    }
                    G = 26;
                } return L; }, M.prototype.convertTo = function (S) { var T = S.umod(this.m); return T === S ? T.clone() : T; }, M.prototype.convertFrom = function (S) { var T = S.clone(); return T.red = null, T; }, t.mont = function (S) { return new N(S); }, n(N, M), N.prototype.convertTo = function (S) { return this.imod(S.ushln(this.shift)); }, N.prototype.convertFrom = function (S) { var T = this.imod(S.mul(this.rinv)); return T.red = null, T; }, N.prototype.imul = function (S, T) { if (S.isZero() || T.isZero())
                    return S.words[0] = 0, S.length = 1, S; var B = S.imul(T), P = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = B.isub(P).iushrn(this.shift), j = L; return L.cmp(this.m) >= 0 ? j = L.isub(this.m) : L.cmpn(0) < 0 && (j = L.iadd(this.m)), j._forceRed(this); }, N.prototype.mul = function (S, T) { if (S.isZero() || T.isZero())
                    return new t(0)._forceRed(this); var B = S.mul(T), P = B.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = B.isub(P).iushrn(this.shift), j = L; return L.cmp(this.m) >= 0 ? j = L.isub(this.m) : L.cmpn(0) < 0 && (j = L.iadd(this.m)), j._forceRed(this); }, N.prototype.invm = function (S) { return this.imod(S._invmp(this.m).mul(this.r2))._forceRed(this); }; }(d); }).call(this, f(107)(E));
            }, function (E, m, f) {
                "use strict";
                const d = f(239), r = f(497), e = f(140);
                m.aes = r, m.hmac = d, m.keys = e, m.randomBytes = f(106), m.pbkdf2 = f(500);
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { let r; for await (const e of d)
                    r = e; return r; };
            }, function (E, m, f) {
                "use strict";
                const d = f(295), r = f(177), e = f(37), c = f(0), n = f(4);
                E.exports = async (t, s, u) => { const i = Array.isArray(s); let o = Array.isArray(s) ? s : [s]; const h = await d(t, u); return o = o.map(a => { if (n.isCID(a) && (a = "/ipfs/" + a), (a = (a = (a || "").trim()).replace(/(\/\/+)/g, "/")).endsWith("/") && a.length > 1 && (a = a.substring(0, a.length - 1)), !a)
                    throw c(new Error("paths must not be empty"), "ERR_NO_PATH"); if (a.substring(0, 1) !== "/")
                    throw c(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH"); a.substring(a.length - 1) === "/" && (a = a.substring(0, a.length - 1)); const l = r(a); if (l[0] === "ipfs") {
                    let b;
                    return b = l.length === 2 ? "/" + l.join("/") : "/" + l.slice(0, l.length - 1).join("/"), { type: "ipfs", depth: l.length - 2, mfsPath: "/" + l.join("/"), mfsDirectory: b, parts: l, path: "/" + l.join("/"), name: l[l.length - 1] };
                } const p = `/ipfs/${h}${l.length ? "/" + l.join("/") : ""}`, g = `/ipfs/${h}/${l.slice(0, l.length - 1).join("/")}`; return { type: "mfs", depth: l.length, mfsDirectory: g, mfsPath: p, parts: l, path: "/" + l.join("/"), name: l[l.length - 1] }; }), await Promise.all(o.map(async (a) => { const l = a.type === "mfs" ? a.mfsPath : a.path; try {
                    const p = await e(l, t.ipld);
                    a.cid = p.cid, a.mfsPath = "/ipfs/" + p.path, a.unixfs = p.unixfs, a.content = p.content;
                }
                catch (p) {
                    if (p.code !== "ERR_NOT_FOUND")
                        throw p;
                } a.exists = Boolean(a.cid); })), i ? o : o[0]; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function d(r, e) { if (!r) {
                    const c = new Error(e || "Assertion failed");
                    throw Error.captureStackTrace && Error.captureStackTrace(c, d), c;
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(13), e = f(21), { Record: c } = f(66), n = e(f(1046)), t = n.Message.MessageType, s = n.Message.ConnectionType;
                class u {
                    constructor(a, l, p) { if (l && !(l instanceof Uint8Array))
                        throw new Error("Key must be a Uint8Array"); this.type = a, this.key = l, this._clusterLevelRaw = p, this.closerPeers = [], this.providerPeers = [], this.record = null; }
                    get clusterLevel() { const a = this._clusterLevelRaw - 1; return a < 0 ? 0 : a; }
                    set clusterLevel(a) { this._clusterLevelRaw = a; }
                    serialize() { const a = { key: this.key, type: this.type, clusterLevelRaw: this._clusterLevelRaw, closerPeers: this.closerPeers.map(i), providerPeers: this.providerPeers.map(i) }; return this.record && (this.record instanceof Uint8Array ? a.record = this.record : a.record = this.record.serialize()), n.Message.encode(a); }
                    static deserialize(a) { const l = n.Message.decode(a), p = new u(l.type, l.key, l.clusterLevelRaw); return p.closerPeers = l.closerPeers.map(o), p.providerPeers = l.providerPeers.map(o), l.record && (p.record = c.deserialize(l.record)), p; }
                }
                function i(h) { return { id: h.id.id, addrs: (h.multiaddrs || []).map(a => a.bytes), connection: s.CONNECTED }; }
                function o(h) { return { id: new d(h.id), multiaddrs: h.addrs.map(a => r(a)) }; }
                u.TYPES = t, u.CONNECTION_TYPES = s, E.exports = u;
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), f(82);
                var r = E.exports = d.asn1 = d.asn1 || {};
                function e(n, t, s) { if (s > t) {
                    var u = new Error("Too few bytes to parse DER.");
                    throw u.available = n.length(), u.remaining = t, u.requested = s, u;
                } }
                r.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 }, r.Type = { NONE: 0, BOOLEAN: 1, INTEGER: 2, BITSTRING: 3, OCTETSTRING: 4, NULL: 5, OID: 6, ODESC: 7, EXTERNAL: 8, REAL: 9, ENUMERATED: 10, EMBEDDED: 11, UTF8: 12, ROID: 13, SEQUENCE: 16, SET: 17, PRINTABLESTRING: 19, IA5STRING: 22, UTCTIME: 23, GENERALIZEDTIME: 24, BMPSTRING: 30 }, r.create = function (n, t, s, u, i) { if (d.util.isArray(u)) {
                    for (var o = [], h = 0; h < u.length; ++h)
                        u[h] !== void 0 && o.push(u[h]);
                    u = o;
                } var a = { tagClass: n, type: t, constructed: s, composed: s || d.util.isArray(u), value: u }; return i && "bitStringContents" in i && (a.bitStringContents = i.bitStringContents, a.original = r.copy(a)), a; }, r.copy = function (n, t) { var s; if (d.util.isArray(n)) {
                    s = [];
                    for (var u = 0; u < n.length; ++u)
                        s.push(r.copy(n[u], t));
                    return s;
                } return typeof n == "string" ? n : (s = { tagClass: n.tagClass, type: n.type, constructed: n.constructed, composed: n.composed, value: r.copy(n.value, t) }, t && !t.excludeBitStringContents && (s.bitStringContents = n.bitStringContents), s); }, r.equals = function (n, t, s) { if (d.util.isArray(n)) {
                    if (!d.util.isArray(t))
                        return !1;
                    if (n.length !== t.length)
                        return !1;
                    for (var u = 0; u < n.length; ++u)
                        if (!r.equals(n[u], t[u]))
                            return !1;
                    return !0;
                } if (typeof n != typeof t)
                    return !1; if (typeof n == "string")
                    return n === t; var i = n.tagClass === t.tagClass && n.type === t.type && n.constructed === t.constructed && n.composed === t.composed && r.equals(n.value, t.value); return s && s.includeBitStringContents && (i = i && n.bitStringContents === t.bitStringContents), i; }, r.getBerValueLength = function (n) { var t = n.getByte(); if (t !== 128)
                    return 128 & t ? n.getInt((127 & t) << 3) : t; }, r.fromDer = function (n, t) { return t === void 0 && (t = { strict: !0, decodeBitStrings: !0 }), typeof t == "boolean" && (t = { strict: t, decodeBitStrings: !0 }), "strict" in t || (t.strict = !0), "decodeBitStrings" in t || (t.decodeBitStrings = !0), typeof n == "string" && (n = d.util.createBuffer(n)), function s(u, i, o, h) { var a; e(u, i, 2); var l = u.getByte(); i--; var p = 192 & l, g = 31 & l; a = u.length(); var b, I, v = function (L, j) { var D = L.getByte(); if (j--, D !== 128) {
                    var G;
                    if (128 & D) {
                        var W = 127 & D;
                        e(L, j, W), G = L.getInt(W << 3);
                    }
                    else
                        G = D;
                    if (G < 0)
                        throw new Error("Negative length: " + G);
                    return G;
                } }(u, i); if (i -= a - u.length(), v !== void 0 && v > i) {
                    if (h.strict) {
                        var R = new Error("Too few bytes to read ASN.1 value.");
                        throw R.available = u.length(), R.remaining = i, R.requested = v, R;
                    }
                    v = i;
                } var _ = (32 & l) == 32; if (_)
                    if (b = [], v === void 0)
                        for (;;) {
                            if (e(u, i, 2), u.bytes(2) === String.fromCharCode(0, 0)) {
                                u.getBytes(2), i -= 2;
                                break;
                            }
                            a = u.length(), b.push(s(u, i, o + 1, h)), i -= a - u.length();
                        }
                    else
                        for (; v > 0;)
                            a = u.length(), b.push(s(u, v, o + 1, h)), i -= a - u.length(), v -= a - u.length(); if (b === void 0 && p === r.Class.UNIVERSAL && g === r.Type.BITSTRING && (I = u.bytes(v)), b === void 0 && h.decodeBitStrings && p === r.Class.UNIVERSAL && g === r.Type.BITSTRING && v > 1) {
                    var k = u.read, x = i, M = 0;
                    if (g === r.Type.BITSTRING && (e(u, i, 1), M = u.getByte(), i--), M === 0)
                        try {
                            a = u.length();
                            var N = { verbose: h.verbose, strict: !0, decodeBitStrings: !0 }, S = s(u, i, o + 1, N), T = a - u.length();
                            i -= T, g == r.Type.BITSTRING && T++;
                            var B = S.tagClass;
                            T !== v || B !== r.Class.UNIVERSAL && B !== r.Class.CONTEXT_SPECIFIC || (b = [S]);
                        }
                        catch (L) { }
                    b === void 0 && (u.read = k, i = x);
                } if (b === void 0) {
                    if (v === void 0) {
                        if (h.strict)
                            throw new Error("Non-constructed ASN.1 object of indefinite length.");
                        v = i;
                    }
                    if (g === r.Type.BMPSTRING)
                        for (b = ""; v > 0; v -= 2)
                            e(u, i, 2), b += String.fromCharCode(u.getInt16()), i -= 2;
                    else
                        b = u.getBytes(v);
                } var P = I === void 0 ? null : { bitStringContents: I }; return r.create(p, g, _, b, P); }(n, n.length(), 0, t); }, r.toDer = function (n) { var t = d.util.createBuffer(), s = n.tagClass | n.type, u = d.util.createBuffer(), i = !1; if ("bitStringContents" in n && (i = !0, n.original && (i = r.equals(n, n.original))), i)
                    u.putBytes(n.bitStringContents);
                else if (n.composed) {
                    n.constructed ? s |= 32 : u.putByte(0);
                    for (var o = 0; o < n.value.length; ++o)
                        n.value[o] !== void 0 && u.putBuffer(r.toDer(n.value[o]));
                }
                else if (n.type === r.Type.BMPSTRING)
                    for (o = 0; o < n.value.length; ++o)
                        u.putInt16(n.value.charCodeAt(o));
                else
                    n.type === r.Type.INTEGER && n.value.length > 1 && (n.value.charCodeAt(0) === 0 && (128 & n.value.charCodeAt(1)) == 0 || n.value.charCodeAt(0) === 255 && (128 & n.value.charCodeAt(1)) == 128) ? u.putBytes(n.value.substr(1)) : u.putBytes(n.value); if (t.putByte(s), u.length() <= 127)
                    t.putByte(127 & u.length());
                else {
                    var h = u.length(), a = "";
                    do
                        a += String.fromCharCode(255 & h), h >>>= 8;
                    while (h > 0);
                    for (t.putByte(128 | a.length), o = a.length - 1; o >= 0; --o)
                        t.putByte(a.charCodeAt(o));
                } return t.putBuffer(u), t; }, r.oidToDer = function (n) { var t, s, u, i, o = n.split("."), h = d.util.createBuffer(); h.putByte(40 * parseInt(o[0], 10) + parseInt(o[1], 10)); for (var a = 2; a < o.length; ++a) {
                    t = !0, s = [], u = parseInt(o[a], 10);
                    do
                        i = 127 & u, u >>>= 7, t || (i |= 128), s.push(i), t = !1;
                    while (u > 0);
                    for (var l = s.length - 1; l >= 0; --l)
                        h.putByte(s[l]);
                } return h; }, r.derToOid = function (n) { var t; typeof n == "string" && (n = d.util.createBuffer(n)); var s = n.getByte(); t = Math.floor(s / 40) + "." + s % 40; for (var u = 0; n.length() > 0;)
                    u <<= 7, 128 & (s = n.getByte()) ? u += 127 & s : (t += "." + (u + s), u = 0); return t; }, r.utcTimeToDate = function (n) { var t = new Date, s = parseInt(n.substr(0, 2), 10); s = s >= 50 ? 1900 + s : 2e3 + s; var u = parseInt(n.substr(2, 2), 10) - 1, i = parseInt(n.substr(4, 2), 10), o = parseInt(n.substr(6, 2), 10), h = parseInt(n.substr(8, 2), 10), a = 0; if (n.length > 11) {
                    var l = n.charAt(10), p = 10;
                    l !== "+" && l !== "-" && (a = parseInt(n.substr(10, 2), 10), p += 2);
                } if (t.setUTCFullYear(s, u, i), t.setUTCHours(o, h, a, 0), p && ((l = n.charAt(p)) === "+" || l === "-")) {
                    var g = 60 * parseInt(n.substr(p + 1, 2), 10) + parseInt(n.substr(p + 4, 2), 10);
                    g *= 6e4, l === "+" ? t.setTime(+t - g) : t.setTime(+t + g);
                } return t; }, r.generalizedTimeToDate = function (n) { var t = new Date, s = parseInt(n.substr(0, 4), 10), u = parseInt(n.substr(4, 2), 10) - 1, i = parseInt(n.substr(6, 2), 10), o = parseInt(n.substr(8, 2), 10), h = parseInt(n.substr(10, 2), 10), a = parseInt(n.substr(12, 2), 10), l = 0, p = 0, g = !1; n.charAt(n.length - 1) === "Z" && (g = !0); var b = n.length - 5, I = n.charAt(b); return I !== "+" && I !== "-" || (p = 60 * parseInt(n.substr(b + 1, 2), 10) + parseInt(n.substr(b + 4, 2), 10), p *= 6e4, I === "+" && (p *= -1), g = !0), n.charAt(14) === "." && (l = 1e3 * parseFloat(n.substr(14), 10)), g ? (t.setUTCFullYear(s, u, i), t.setUTCHours(o, h, a, l), t.setTime(+t + p)) : (t.setFullYear(s, u, i), t.setHours(o, h, a, l)), t; }, r.dateToUtcTime = function (n) { if (typeof n == "string")
                    return n; var t = "", s = []; s.push(("" + n.getUTCFullYear()).substr(2)), s.push("" + (n.getUTCMonth() + 1)), s.push("" + n.getUTCDate()), s.push("" + n.getUTCHours()), s.push("" + n.getUTCMinutes()), s.push("" + n.getUTCSeconds()); for (var u = 0; u < s.length; ++u)
                    s[u].length < 2 && (t += "0"), t += s[u]; return t += "Z"; }, r.dateToGeneralizedTime = function (n) { if (typeof n == "string")
                    return n; var t = "", s = []; s.push("" + n.getUTCFullYear()), s.push("" + (n.getUTCMonth() + 1)), s.push("" + n.getUTCDate()), s.push("" + n.getUTCHours()), s.push("" + n.getUTCMinutes()), s.push("" + n.getUTCSeconds()); for (var u = 0; u < s.length; ++u)
                    s[u].length < 2 && (t += "0"), t += s[u]; return t += "Z"; }, r.integerToDer = function (n) { var t = d.util.createBuffer(); if (n >= -128 && n < 128)
                    return t.putSignedInt(n, 8); if (n >= -32768 && n < 32768)
                    return t.putSignedInt(n, 16); if (n >= -8388608 && n < 8388608)
                    return t.putSignedInt(n, 24); if (n >= -2147483648 && n < 2147483648)
                    return t.putSignedInt(n, 32); var s = new Error("Integer too large; max is 32-bits."); throw s.integer = n, s; }, r.derToInteger = function (n) { typeof n == "string" && (n = d.util.createBuffer(n)); var t = 8 * n.length(); if (t > 32)
                    throw new Error("Integer too large; max is 32-bits."); return n.getSignedInt(t); }, r.validate = function (n, t, s, u) { var i = !1; if (n.tagClass !== t.tagClass && t.tagClass !== void 0 || n.type !== t.type && t.type !== void 0)
                    u && (n.tagClass !== t.tagClass && u.push("[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + n.tagClass + '"'), n.type !== t.type && u.push("[" + t.name + '] Expected type "' + t.type + '", got "' + n.type + '"'));
                else if (n.constructed === t.constructed || t.constructed === void 0) {
                    if (i = !0, t.value && d.util.isArray(t.value))
                        for (var o = 0, h = 0; i && h < t.value.length; ++h)
                            i = t.value[h].optional || !1, n.value[o] && ((i = r.validate(n.value[o], t.value[h], s, u)) ? ++o : t.value[h].optional && (i = !0)), !i && u && u.push("[" + t.name + '] Tag class "' + t.tagClass + '", type "' + t.type + '" expected value length "' + t.value.length + '", got "' + n.value.length + '"');
                    if (i && s && (t.capture && (s[t.capture] = n.value), t.captureAsn1 && (s[t.captureAsn1] = n), t.captureBitStringContents && "bitStringContents" in n && (s[t.captureBitStringContents] = n.bitStringContents), t.captureBitStringValue && "bitStringContents" in n))
                        if (n.bitStringContents.length < 2)
                            s[t.captureBitStringValue] = "";
                        else {
                            if (n.bitStringContents.charCodeAt(0) !== 0)
                                throw new Error("captureBitStringValue only supported for zero unused bits");
                            s[t.captureBitStringValue] = n.bitStringContents.slice(1);
                        }
                }
                else
                    u && u.push("[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + n.constructed + '"'); return i; };
                var c = /[^\\u0000-\\u00ff]/;
                r.prettyPrint = function (n, t, s) {
                    var u = "";
                    s = s || 2, (t = t || 0) > 0 && (u += `
`);
                    for (var i = "", o = 0; o < t * s; ++o)
                        i += " ";
                    switch (u += i + "Tag: ", n.tagClass) {
                        case r.Class.UNIVERSAL:
                            u += "Universal:";
                            break;
                        case r.Class.APPLICATION:
                            u += "Application:";
                            break;
                        case r.Class.CONTEXT_SPECIFIC:
                            u += "Context-Specific:";
                            break;
                        case r.Class.PRIVATE: u += "Private:";
                    }
                    if (n.tagClass === r.Class.UNIVERSAL)
                        switch (u += n.type, n.type) {
                            case r.Type.NONE:
                                u += " (None)";
                                break;
                            case r.Type.BOOLEAN:
                                u += " (Boolean)";
                                break;
                            case r.Type.INTEGER:
                                u += " (Integer)";
                                break;
                            case r.Type.BITSTRING:
                                u += " (Bit string)";
                                break;
                            case r.Type.OCTETSTRING:
                                u += " (Octet string)";
                                break;
                            case r.Type.NULL:
                                u += " (Null)";
                                break;
                            case r.Type.OID:
                                u += " (Object Identifier)";
                                break;
                            case r.Type.ODESC:
                                u += " (Object Descriptor)";
                                break;
                            case r.Type.EXTERNAL:
                                u += " (External or Instance of)";
                                break;
                            case r.Type.REAL:
                                u += " (Real)";
                                break;
                            case r.Type.ENUMERATED:
                                u += " (Enumerated)";
                                break;
                            case r.Type.EMBEDDED:
                                u += " (Embedded PDV)";
                                break;
                            case r.Type.UTF8:
                                u += " (UTF8)";
                                break;
                            case r.Type.ROID:
                                u += " (Relative Object Identifier)";
                                break;
                            case r.Type.SEQUENCE:
                                u += " (Sequence)";
                                break;
                            case r.Type.SET:
                                u += " (Set)";
                                break;
                            case r.Type.PRINTABLESTRING:
                                u += " (Printable String)";
                                break;
                            case r.Type.IA5String:
                                u += " (IA5String (ASCII))";
                                break;
                            case r.Type.UTCTIME:
                                u += " (UTC time)";
                                break;
                            case r.Type.GENERALIZEDTIME:
                                u += " (Generalized time)";
                                break;
                            case r.Type.BMPSTRING: u += " (BMP String)";
                        }
                    else
                        u += n.type;
                    if (u += `
`, u += i + "Constructed: " + n.constructed + `
`, n.composed) {
                        var h = 0, a = "";
                        for (o = 0; o < n.value.length; ++o)
                            n.value[o] !== void 0 && (h += 1, a += r.prettyPrint(n.value[o], t + 1, s), o + 1 < n.value.length && (a += ","));
                        u += i + "Sub values: " + h + a;
                    }
                    else {
                        if (u += i + "Value: ", n.type === r.Type.OID) {
                            var l = r.derToOid(n.value);
                            u += l, d.pki && d.pki.oids && l in d.pki.oids && (u += " (" + d.pki.oids[l] + ") ");
                        }
                        if (n.type === r.Type.INTEGER)
                            try {
                                u += r.derToInteger(n.value);
                            }
                            catch (g) {
                                u += "0x" + d.util.bytesToHex(n.value);
                            }
                        else if (n.type === r.Type.BITSTRING) {
                            if (n.value.length > 1 ? u += "0x" + d.util.bytesToHex(n.value.slice(1)) : u += "(none)", n.value.length > 0) {
                                var p = n.value.charCodeAt(0);
                                p == 1 ? u += " (1 unused bit shown)" : p > 1 && (u += " (" + p + " unused bits shown)");
                            }
                        }
                        else
                            n.type === r.Type.OCTETSTRING ? (c.test(n.value) || (u += "(" + n.value + ") "), u += "0x" + d.util.bytesToHex(n.value)) : n.type === r.Type.UTF8 ? u += d.util.decodeUtf8(n.value) : n.type === r.Type.PRINTABLESTRING || n.type === r.Type.IA5String ? u += n.value : c.test(n.value) ? u += "0x" + d.util.bytesToHex(n.value) : n.value.length === 0 ? u += "[null]" : u += n.value;
                    }
                    return u;
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(192), r = f(828), e = (u, i, o) => c(u, Array.isArray(i) ? i : [{ signal: i, options: o }]), c = (u, i) => (u = d(u), i = i.map(({ signal: o, options: h }) => ({ signal: o, options: h || {} })), async function* () { let o; const h = () => { o && o(); }; for (const { signal: a } of i)
                    a.addEventListener("abort", h); for (;;) {
                    let a;
                    try {
                        for (const { signal: p, options: g } of i)
                            if (p.aborted) {
                                const { abortMessage: b, abortCode: I } = g;
                                throw new r(b, I);
                            }
                        const l = new Promise((p, g) => { o = () => { const { options: b } = i.find(({ signal: R }) => R.aborted), { abortMessage: I, abortCode: v } = b; g(new r(I, v)); }; });
                        a = await Promise.race([l, u.next()]), o = null;
                    }
                    catch (l) {
                        for (const { signal: b } of i)
                            b.removeEventListener("abort", h);
                        const p = i.find(({ signal: b }) => b.aborted), g = l.type === "aborted" && p;
                        if (g && p.options.onAbort && await p.options.onAbort(u), typeof u.return == "function" && await u.return(), g && p.options.returnOnAbort)
                            return;
                        throw l;
                    }
                    if (a.done)
                        break;
                    yield a.value;
                } for (const { signal: a } of i)
                    a.removeEventListener("abort", h); }()), n = (u, i, o) => t(u, Array.isArray(i) ? i : [{ signal: i, options: o }]), t = (u, i) => o => u(c(o, i)), s = (u, i) => ({ sink: t(u.sink, i), source: c(u.source, i) });
                E.exports = e, E.exports.AbortError = r, E.exports.source = e, E.exports.sink = n, E.exports.transform = n, E.exports.duplex = (u, i, o) => s(u, Array.isArray(i) ? i : [{ signal: i, options: o }]);
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(20), e = (c, n, t) => { let s = 0; const u = t.length; for (; s < u;) {
                    if (c(n, t[s]))
                        return !0;
                    s += 1;
                } return !1; };
                E.exports = { logger: (c, n) => { const t = ["bitswap"]; n && t.push(n), c && t.push("" + c.toB58String().slice(0, 8)); const s = d(t.join(":")); return s.error = d(t.concat(["error"]).join(":")), s; }, includesWith: e, uniqWith: (c, n) => { let t = 0; const s = n.length, u = []; let i; for (; t < s;)
                        i = n[t], e(c, i, u) || (u[u.length] = i), t += 1; return u; }, groupBy: (c, n) => n.reduce((t, s) => { const u = c(s); return t[u] ? t[u].push(s) : t[u] = [s], t; }, {}), pullAllWith: (c, n, t) => n.filter(s => !e(c, s, t)), sortBy: (c, n) => Array.prototype.slice.call(n, 0).sort((t, s) => { const u = c(t), i = c(s); return u < i ? -1 : u > i ? 1 : 0; }), isMapEqual: (c, n) => { if (c.size !== n.size)
                        return !1; for (const [t, s] of c) {
                        if (!n.has(t))
                            return !1;
                        const u = n.get(t);
                        if (typeof s.equals == "function" && !s.equals(u))
                            return !1;
                        if (s._data && !r(s._data, u._data))
                            return !1;
                    } return !0; } };
            }, function (E, m, f) {
                "use strict";
                const { AbortController: d, AbortSignal: r } = typeof self != "undefined" ? self : typeof window != "undefined" ? window : void 0;
                E.exports = d, E.exports.AbortSignal = r, E.exports.default = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(25), r = f(409), { names: e } = f(413), c = f(5), n = f(6), t = f(31), s = {};
                for (const l in e)
                    s[e[l]] = l;
                function u(l) { if (!(l instanceof Uint8Array))
                    throw new Error("multihash must be a Uint8Array"); if (l.length < 2)
                    throw new Error("multihash too short. must be > 2 bytes."); const p = r.decode(l); if (!h(p))
                    throw new Error("multihash unknown function code: 0x" + p.toString(16)); l = l.slice(r.decode.bytes); const g = r.decode(l); if (g < 0)
                    throw new Error("multihash invalid length: " + g); if ((l = l.slice(r.decode.bytes)).length !== g)
                    throw new Error("multihash length inconsistent: 0x" + c(l, "base16")); return { code: p, name: s[p], length: g, digest: l }; }
                function i(l) { let p = l; if (typeof l == "string") {
                    if (e[l] === void 0)
                        throw new Error("Unrecognized hash function named: " + l);
                    p = e[l];
                } if (typeof p != "number")
                    throw new Error("Hash function code should be a number. Got: " + p); if (s[p] === void 0 && !o(p))
                    throw new Error("Unrecognized function code: " + p); return p; }
                function o(l) { return l > 0 && l < 16; }
                function h(l) { return !!o(l) || !!s[l]; }
                function a(l) { u(l); }
                E.exports = { names: e, codes: Object.freeze(s), toHexString: function (l) { if (!(l instanceof Uint8Array))
                        throw new Error("must be passed a Uint8Array"); return c(l, "base16"); }, fromHexString: function (l) { return n(l, "base16"); }, toB58String: function (l) { if (!(l instanceof Uint8Array))
                        throw new Error("must be passed a Uint8Array"); return c(d.encode("base58btc", l)).slice(1); }, fromB58String: function (l) { const p = l instanceof Uint8Array ? c(l) : l; return d.decode("z" + p); }, decode: u, encode: function (l, p, g) { if (!l || p === void 0)
                        throw new Error("multihash encode requires at least two args: digest, code"); const b = i(p); if (!(l instanceof Uint8Array))
                        throw new Error("digest should be a Uint8Array"); if (g == null && (g = l.length), g && l.length !== g)
                        throw new Error("digest length should be equal to specified length."); const I = r.encode(b), v = r.encode(g); return t([I, v, l], I.length + v.length + l.length); }, coerceCode: i, isAppCode: o, validate: a, prefix: function (l) { return a(l), l.subarray(0, 2); }, isValidCode: h };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                E.exports = d.md = d.md || {}, d.md.algorithms = d.md.algorithms || {};
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(83), f(450), f(451), f(14), d.random && d.random.getBytes ? E.exports = d.random : function (r) { var e = {}, c = new Array(4), n = d.util.createBuffer(); function t() { var l = d.prng.create(e); return l.getBytes = function (p, g) { return l.generate(p, g); }, l.getBytesSync = function (p) { return l.generate(p); }, l; } e.formatKey = function (l) { var p = d.util.createBuffer(l); return (l = new Array(4))[0] = p.getInt32(), l[1] = p.getInt32(), l[2] = p.getInt32(), l[3] = p.getInt32(), d.aes._expandKey(l, !1); }, e.formatSeed = function (l) { var p = d.util.createBuffer(l); return (l = new Array(4))[0] = p.getInt32(), l[1] = p.getInt32(), l[2] = p.getInt32(), l[3] = p.getInt32(), l; }, e.cipher = function (l, p) { return d.aes._updateBlock(l, p, c, !1), n.putInt32(c[0]), n.putInt32(c[1]), n.putInt32(c[2]), n.putInt32(c[3]), n.getBytes(); }, e.increment = function (l) { return ++l[3], l; }, e.md = d.md.sha256; var s = t(), u = null, i = d.util.globalScope, o = i.crypto || i.msCrypto; if (o && o.getRandomValues && (u = function (l) { return o.getRandomValues(l); }), d.options.usePureJavaScript || !d.util.isNodejs && !u) {
                    if (typeof window == "undefined" || window.document, s.collectInt(+new Date, 32), typeof navigator != "undefined") {
                        var h = "";
                        for (var a in navigator)
                            try {
                                typeof navigator[a] == "string" && (h += navigator[a]);
                            }
                            catch (l) { }
                        s.collect(h), h = null;
                    }
                    r && (r().mousemove(function (l) { s.collectInt(l.clientX, 16), s.collectInt(l.clientY, 16); }), r().keypress(function (l) { s.collectInt(l.charCode, 8); }));
                } if (d.random)
                    for (var a in s)
                        d.random[a] = s[a];
                else
                    d.random = s; d.random.createInstance = t, E.exports = d.random; }(typeof jQuery != "undefined" ? jQuery : null);
            }, function (E, m, f) {
                "use strict";
                function d(r, e) { if (!r)
                    throw new Error(e || "Assertion failed"); }
                E.exports = d, d.equal = function (r, e, c) { if (r != e)
                    throw new Error(c || "Assertion failed: " + r + " != " + e); };
            }, function (E, m, f) {
                "use strict";
                const d = f(48), r = f(25), e = f(13), c = f(60), n = f(4), { URL: t } = f(506), s = f(5), u = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/, i = /^\/(ip[fn]s)\/([^/?#]+)/, o = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/, h = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
                function a(S) { try {
                    return new n(S), !0;
                }
                catch (T) {
                    return !1;
                } }
                function l(S) { if (!S)
                    return !1; if (e.isMultiaddr(S))
                    return !0; try {
                    return new e(S), !0;
                }
                catch (T) {
                    return !1;
                } }
                function p(S, T, B = 1, P = 2) { const L = I(S); if (!L)
                    return !1; const j = L.match(T); if (!j)
                    return !1; if (j[B] !== "ipfs")
                    return !1; let D = j[P]; return D && T === o && (D = D.toLowerCase()), a(D); }
                function g(S, T, B = 1, P) { const L = I(S); if (!L)
                    return !1; const j = L.match(T); if (!j)
                    return !1; if (j[B] !== "ipns")
                    return !1; let D = j[P]; if (D && T === o) {
                    if (D = D.toLowerCase(), a(D))
                        return !0;
                    try {
                        const { hostname: G } = new t("http://" + D);
                        return h.test(G);
                    }
                    catch (G) {
                        return !1;
                    }
                } return !0; }
                function b(S) { return typeof S == "string"; }
                function I(S) { return S instanceof Uint8Array ? s(S, "base58btc") : !!b(S) && S; }
                const v = S => p(S, o, 2, 1), R = S => g(S, o, 2, 1), _ = S => v(S) || R(S), k = S => p(S, u) || v(S), x = S => g(S, u) || R(S), M = S => k(S) || x(S) || _(S), N = S => p(S, i) || g(S, i);
                E.exports = { multihash: function (S) { const T = I(S); try {
                        return d.decode(r.decode("z" + T)), !0;
                    }
                    catch (B) {
                        return !1;
                    } }, multiaddr: l, peerMultiaddr: function (S) { return l(S) && c.IPFS.matches(S); }, cid: a, base32cid: S => function (T) { try {
                        return r.isEncoded(T);
                    }
                    catch (B) {
                        return !1;
                    } }(S) === "base32" && a(S), ipfsSubdomain: v, ipnsSubdomain: R, subdomain: _, subdomainGatewayPattern: o, ipfsUrl: k, ipnsUrl: x, url: M, pathGatewayPattern: u, ipfsPath: S => p(S, i), ipnsPath: S => g(S, i), path: N, pathPattern: i, urlOrPath: S => M(S) || N(S), cidPath: S => b(S) && !a(S) && p("/ipfs/" + S, i) };
            }, function (E, m, f) {
                "use strict";
                var d = f(114), r = Object.keys || function (a) { var l = []; for (var p in a)
                    l.push(p); return l; };
                E.exports = i;
                var e = Object.create(f(89));
                e.inherits = f(15);
                var c = f(268), n = f(158);
                e.inherits(i, c);
                for (var t = r(n.prototype), s = 0; s < t.length; s++) {
                    var u = t[s];
                    i.prototype[u] || (i.prototype[u] = n.prototype[u]);
                }
                function i(a) { if (!(this instanceof i))
                    return new i(a); c.call(this, a), n.call(this, a), a && a.readable === !1 && (this.readable = !1), a && a.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, a && a.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", o); }
                function o() { this.allowHalfOpen || this._writableState.ended || d.nextTick(h, this); }
                function h(a) { a.end(); }
                Object.defineProperty(i.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), Object.defineProperty(i.prototype, "destroyed", { get: function () { return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed; }, set: function (a) { this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = a, this._writableState.destroyed = a); } }), i.prototype._destroy = function (a, l) { this.push(null), this.end(), d.nextTick(l, a); };
            }, function (E, m, f) {
                "use strict";
                const d = f(30).BigNumber;
                m.MT = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 }, m.TAG = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, REGEXP: 35, MIME: 36 }, m.NUMBYTES = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 }, m.SIMPLE = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 }, m.SYMS = { NULL: Symbol("null"), UNDEFINED: Symbol("undef"), PARENT: Symbol("parent"), BREAK: Symbol("break"), STREAM: Symbol("stream") }, m.SHIFT32 = 4294967296, m.BI = { MINUS_ONE: -1, MAXINT32: 4294967295, MAXINT64: "0xffffffffffffffff", SHIFT32: m.SHIFT32 };
                const r = new d(-1);
                m.BN = { MINUS_ONE: r, NEG_MAX: r.minus(new d(Number.MAX_SAFE_INTEGER.toString(16), 16)), MAXINT: new d("0x20000000000000"), MAXINT32: new d(4294967295), MAXINT64: new d("0xffffffffffffffff"), SHIFT32: new d(m.SHIFT32) };
            }, function (E, m, f) {
                "use strict";
                function d(Q, K) { return K === void 0 ? F => d(Q, F) : K[Symbol.asyncIterator] ? async function* (F, Y) { let $ = []; for await (const y of Y)
                    $.push(y), $.length === F && (yield $, $ = []); $.length > 0 && (yield $); }(Q, K) : function* (F, Y) { let $ = []; for (const y of Y)
                    $.push(y), $.length === F && (yield $, $ = []); $.length > 0 && (yield $); }(Q, K); }
                function r(Q) { if (typeof Q.next == "function")
                    return Q; if (typeof Q[Symbol.iterator] == "function")
                    return Q[Symbol.iterator](); if (typeof Q[Symbol.asyncIterator] == "function")
                    return Q[Symbol.asyncIterator](); throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols'); }
                function e() { let Q, K; return { promise: new Promise((F, Y) => { K = F, Q = Y; }), reject: Q, resolve: K }; }
                function c(Q, K) { const F = r(K), Y = [], $ = []; let y = !1, C = !1; async function A() { if (!C && !(y || Y.length >= Q)) {
                    y = !0;
                    try {
                        const { done: z, value: w } = await F.next();
                        z ? C = !0 : Y.push({ value: w });
                    }
                    catch (z) {
                        C = !0, Y.push({ error: z });
                    }
                    !function () { for (; $.length > 0 && Y.length > 0;) {
                        const z = $.shift(), { error: w, value: O } = Y.shift();
                        w ? z.reject(w) : z.resolve({ done: !1, value: O });
                    } for (; $.length > 0 && C;) {
                        const { resolve: z } = $.shift();
                        z({ done: !0, value: void 0 });
                    } }(), y = !1, A();
                } } const U = { next: async function () { if (Y.length > 0) {
                        const { error: w, value: O } = Y.shift();
                        if (w)
                            throw w;
                        return A(), { done: !1, value: O };
                    } if (C)
                        return { done: !0, value: void 0 }; const z = e(); return $.push(z), A(), z.promise; }, [Symbol.asyncIterator]: () => U }; return U; }
                function n(Q, K) { return K === void 0 ? F => n(Q, F) : Q === 0 ? K : K[Symbol.asyncIterator] ? c(Q, K) : function* (F, Y) { const $ = []; let y; try {
                    for (const C of Y)
                        $.push(C), $.length <= F || (yield $.shift());
                }
                catch (C) {
                    y = C;
                } for (const C of $)
                    yield C; if (y)
                    throw y; }(Q, K); }
                function t(Q) { return Q[Symbol.asyncIterator] ? async function (K) { const F = []; for await (const Y of K)
                    F.push(Y); return F; }(Q) : Array.from(Q); }
                function s(...Q) { return Q.find(K => K[Symbol.asyncIterator] !== void 0) ? async function* (K) { for await (const F of K)
                    yield* F; }(Q) : function* (K) { for (const F of K)
                    yield* F; }(Q); }
                function u(Q) { if (Q[Symbol.asyncIterator])
                    return async function (K) { for await (const F of K)
                        ; }(Q); for (const K of Q)
                    ; }
                async function* i(Q, K) { for await (const F of K)
                    await Q(F) && (yield F); }
                function o(Q, K) { return K === void 0 ? F => i(Q, F) : i(Q, K); }
                async function* h(Q) { for await (const K of Q)
                    K && typeof K != "string" && (K[Symbol.iterator] || K[Symbol.asyncIterator]) ? yield* h(K) : yield K; }
                async function* a(Q, K) { for await (const F of K)
                    yield await Q(F); }
                function l(Q, K) { return K === void 0 ? F => a(Q, F) : a(Q, K); }
                function p(Q, K) { return K === void 0 ? F => p(Q, F) : o(F => F != null, h(l(Q, K))); }
                function g(Q, K, F) { const Y = r(F), $ = [], y = []; let C = !1, A = !1, U = 0, z = null; function w() { for (; y.length > 0 && $.length > 0;) {
                    const { resolve: H } = y.shift();
                    H({ done: !1, value: $.shift() });
                } for (; y.length > 0 && U === 0 && C;) {
                    const { resolve: H, reject: V } = y.shift();
                    z ? (V(z), z = null) : H({ done: !0, value: void 0 });
                } } async function O() { if (C)
                    w();
                else if (!(A || U + $.length >= Q)) {
                    A = !0, U++;
                    try {
                        const { done: H, value: V } = await Y.next();
                        H ? (C = !0, U--, w()) : async function (J) { try {
                            const Z = await K(J);
                            if (Z && Z[Symbol.asyncIterator])
                                for await (const tt of Z)
                                    $.push(tt);
                            else
                                $.push(Z);
                        }
                        catch (Z) {
                            C = !0, z = Z;
                        } U--, w(), O(); }(V);
                    }
                    catch (H) {
                        C = !0, U--, z = H, w();
                    }
                    A = !1, O();
                } } const q = { next: async function () { if ($.length === 0) {
                        const V = e();
                        return y.push(V), O(), V.promise;
                    } const H = $.shift(); return O(), { done: !1, value: H }; }, [Symbol.asyncIterator]: () => q }; return q; }
                function b(Q, K, F) { return K === void 0 ? (Y, $) => $ ? b(Q, Y, $) : b(Q, Y) : F === void 0 ? Y => b(Q, K, Y) : o(Y => Y != null, h(g(Q, K, F))); }
                async function I(Q) { return new Promise(K => { Q.once("readable", () => { K(); }); }); }
                function v(Q) { return typeof Q[Symbol.asyncIterator] == "function" ? Q : async function* (K) { for (;;) {
                    const F = K.read();
                    if (F === null) {
                        if (K._readableState.ended)
                            break;
                        await I(K);
                    }
                    else
                        yield F;
                } }(Q); }
                async function* R(...Q) { const K = new Set(Q.map(r)); for (; K.size > 0;)
                    for (const F of K) {
                        const Y = await F.next();
                        Y.done ? K.delete(F) : yield Y.value;
                    } }
                function _(Q, ...K) { let F = Q(); for (const Y of K)
                    F = Y(F); return F; }
                function k(Q, K, F) { return K === void 0 ? (Y, $) => k(Q, Y, $) : F === void 0 ? Y => k(Q, K, Y) : Q === 1 ? l(K, F) : async function* (Y, $, y) { let C = null; const A = r(_(() => y, n(1), async function* (U) { for await (const z of U) {
                    if (C)
                        return;
                    yield z;
                } }, l(U => ({ value: $(U) })), n(Y - 1))); for (;;) {
                    const { value: U, done: z } = await A.next();
                    if (z)
                        break;
                    try {
                        const w = await U.value;
                        C || (yield w);
                    }
                    catch (w) {
                        C = w;
                    }
                } if (C)
                    throw C; }(Q, K, F); }
                function x(Q, K, F) { return K === void 0 ? (Y, $) => $ ? x(Q, Y, $) : x(Q, Y) : F === void 0 ? Y => x(Q, K, Y) : o(Y => Y != null, h(k(Q, K, F))); }
                async function* M(...Q) { const K = Q.map(r), F = new Set, Y = new Map; let $ = null, y = null, C = null; const A = w => { $ = w, y && y(w); }, U = w => { C && C(w); }, z = w => { const O = Promise.resolve(w.next()).then(async ({ done: q, value: H }) => { q || Y.set(w, H), F.delete(O); }); F.add(O), O.then(U, A); }; for (const w of K)
                    z(w); for (;;) {
                    if (F.size === 0 && Y.size === 0)
                        return;
                    await new Promise((w, O) => { if ($ && O($), Y.size > 0)
                        return w(); C = w, y = O; });
                    for (const [w, O] of Y)
                        Y.delete(w), yield O, z(w);
                } }
                async function N(Q, K, F) { let Y = K; for await (const $ of F)
                    Y = await Q(Y, $); return Y; }
                function S(Q, K, F) { return K === void 0 ? (Y, $) => $ ? N(Q, Y, $) : S(Q, Y) : F === void 0 ? Y => S(Q, K, Y) : N(Q, K, F); }
                function T(Q, K) { return K === void 0 ? F => T(Q, F) : K[Symbol.asyncIterator] ? async function* (F, Y) { let $ = 0; for await (const y of Y)
                    if (yield await y, $++, $ >= F)
                        break; }(Q, K) : function* (F, Y) { let $ = 0; for (const y of Y)
                    if (yield y, $++, $ >= F)
                        break; }(Q, K); }
                async function* B(Q, K) { for await (const F of K)
                    await Q(F), yield F; }
                function P(Q, K) { return K === void 0 ? F => B(Q, F) : B(Q, K); }
                function L(Q, K) { let F = Q[0] + K[0], Y = Q[1] + K[1]; if (Y >= 1e9) {
                    const $ = Y % 1e9;
                    F += (Y - $) / 1e9, Y = $;
                } return [F, Y]; }
                function j(Q = {}, K) { return K === void 0 ? F => j(Q, F) : K[Symbol.asyncIterator] !== void 0 ? async function* (F, Y) { const $ = Y[Symbol.asyncIterator](); let y = [0, 0]; for (;;) {
                    const C = process.hrtime(), { value: A, done: U } = await $.next(), z = process.hrtime(C);
                    if (y = L(y, z), F.progress && F.progress(z, y), U)
                        return F.total && F.total(y), A;
                    yield A;
                } }(Q, K) : function* (F, Y) { const $ = Y[Symbol.iterator](); let y = [0, 0]; for (;;) {
                    const C = process.hrtime(), { value: A, done: U } = $.next(), z = process.hrtime(C);
                    if (y = L(y, z), F.progress && F.progress(z, y), U)
                        return F.total && F.total(y), A;
                    yield A;
                } }(Q, K); }
                function D(Q, K, F) { const Y = r(F), $ = [], y = []; let C = !1, A = !1, U = 0, z = null; function w() { for (; y.length > 0 && $.length > 0;) {
                    const { resolve: H } = y.shift();
                    H({ done: !1, value: $.shift() });
                } for (; y.length > 0 && U === 0 && C;) {
                    const { resolve: H, reject: V } = y.shift();
                    z ? (V(z), z = null) : H({ done: !0, value: void 0 });
                } } async function O() { if (C)
                    w();
                else if (!(A || U + $.length >= Q)) {
                    A = !0, U++;
                    try {
                        const { done: H, value: V } = await Y.next();
                        H ? (C = !0, U--, w()) : async function (J) { try {
                            const Z = await K(J);
                            $.push(Z);
                        }
                        catch (Z) {
                            C = !0, z = Z;
                        } U--, w(), O(); }(V);
                    }
                    catch (H) {
                        C = !0, U--, z = H, w();
                    }
                    A = !1, O();
                } } const q = { next: async function () { if ($.length === 0) {
                        const V = e();
                        return y.push(V), O(), V.promise;
                    } const H = $.shift(); return O(), { done: !1, value: H }; }, [Symbol.asyncIterator]: () => q }; return q; }
                function G(Q, K, F) { return K === void 0 ? (Y, $) => $ ? G(Q, Y, $) : G(Q, Y) : F === void 0 ? Y => G(Q, K, Y) : D(Q, K, F); }
                async function W(Q, K) { let F = null, Y = null, $ = null; const y = A => { F = A, Y && Y(A); }, C = () => { $ && $(); }; Q.once("error", y); for await (const A of K)
                    if (Q.write(A) === !1 && await new Promise((U, z) => { if (F)
                        return z(F); Q.once("drain", C), $ = U, Y = z; }), F)
                        break; if (Q.removeListener("error", y), Q.removeListener("drain", C), F)
                    throw F; }
                function X(Q, K) { return K === void 0 ? F => W(Q, F) : W(Q, K); }
                f.r(m), f.d(m, "batch", function () { return d; }), f.d(m, "buffer", function () { return n; }), f.d(m, "collect", function () { return t; }), f.d(m, "concat", function () { return s; }), f.d(m, "consume", function () { return u; }), f.d(m, "filter", function () { return o; }), f.d(m, "flatMap", function () { return p; }), f.d(m, "flatTransform", function () { return b; }), f.d(m, "flatten", function () { return h; }), f.d(m, "fromStream", function () { return v; }), f.d(m, "getIterator", function () { return r; }), f.d(m, "map", function () { return l; }), f.d(m, "merge", function () { return R; }), f.d(m, "parallelFlatMap", function () { return x; }), f.d(m, "parallelMap", function () { return k; }), f.d(m, "parallelMerge", function () { return M; }), f.d(m, "pipeline", function () { return _; }), f.d(m, "reduce", function () { return S; }), f.d(m, "take", function () { return T; }), f.d(m, "tap", function () { return P; }), f.d(m, "time", function () { return j; }), f.d(m, "transform", function () { return G; }), f.d(m, "writeToStream", function () { return X; });
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), e = f(2), c = f(6);
                E.exports = ({ ipld: n, preload: t }) => e(async function (s, u = {}) { let i, o; try {
                    i = function (h, a) { if (typeof h == "string")
                        return a !== "base58" && a ? c(h, a) : h; if (h instanceof Uint8Array)
                        return h; if (d.isCID(h))
                        return h.bytes; throw new Error("unsupported multihash"); }(s, u.enc);
                }
                catch (h) {
                    throw r(h, "ERR_INVALID_MULTIHASH");
                } try {
                    o = new d(i);
                }
                catch (h) {
                    throw r(h, "ERR_INVALID_CID");
                } return u.cidVersion === 1 && (o = o.toV1()), u.preload !== !1 && t(o), n.get(o, { signal: u.signal }); });
            }, function (E, m, f) {
                "use strict";
                var d = function (p) { return p && p.__esModule ? p : { default: p }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.isValidPublicKey = m.getHkdf = m.verifySignedPayload = m.getHandshakePayload = m.decodePayload = m.getPeerIdFromPayload = m.signPayload = m.createHandshakePayload = m.getPayload = m.generateKeypair = void 0;
                const r = d(f(1010)), e = d(f(210)), c = d(f(384)), n = f(3), t = d(f(7)), s = f(39), u = f(1013), i = d(f(20)), o = u.pb.NoiseHandshakePayload;
                function h(p, g, b) { const I = o.create({ identityKey: n.Buffer.from(p), identitySig: g, data: b || null }); return n.Buffer.from(o.encode(I).finish()); }
                async function a(p, g) { return n.Buffer.from(await p.privKey.sign(g)); }
                function l(p) { return n.Buffer.concat([n.Buffer.from("noise-libp2p-static-key:"), p]); }
                m.generateKeypair = function () { const p = e.default.privateKeyGenerate(); return { publicKey: e.default.publicKeyCreate(p), privateKey: p }; }, m.getPayload = async function (p, g, b) { const I = await a(p, l(g)), v = b || n.Buffer.alloc(0); return await h(p.marshalPubKey(), I, v); }, m.createHandshakePayload = h, m.signPayload = a, m.getPeerIdFromPayload = async function (p) { return await t.default.createFromPubKey(n.Buffer.from(p.identityKey)); }, m.decodePayload = function (p) { return o.toObject(o.decode(n.Buffer.from(p))); }, m.getHandshakePayload = l, m.verifySignedPayload = async function (p, g, b) { const I = n.Buffer.from(g.identityKey); if (!await async function (_, k) { const x = await t.default.createFromPubKey(k); return i.default(x.id, _); }(b.id, I))
                    throw new Error("Peer ID doesn't match libp2p public key."); const v = l(p), R = s.keys.unmarshalPublicKey(I); if (!g.identitySig || !R.verify(v, n.Buffer.from(g.identitySig)))
                    throw new Error("Static key doesn't match to peer that signed payload!"); return t.default.createFromPubKey(I); }, m.getHkdf = function (p, g) { const b = n.Buffer.alloc(0), I = r.default.extract(c.default, g, p), v = r.default.expand(c.default, I, b, 96); return [v.slice(0, 32), v.slice(32, 64), v.slice(64, 96)]; }, m.isValidPublicKey = function (p) { return e.default.publicKeyVerify(p.slice(0, 32)); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = m; function e(n, t, s) { for (var u = Object.keys(t), i = 0; i < u.length; ++i)
                    n[u[i]] !== void 0 && s || (n[u[i]] = t[u[i]]); return n; } function c(n) { function t(s, u) { if (!(this instanceof t))
                    return new t(s, u); Object.defineProperty(this, "message", { get: function () { return s; } }), Error.captureStackTrace ? Error.captureStackTrace(this, t) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), u && e(this, u); } return (t.prototype = Object.create(Error.prototype)).constructor = t, Object.defineProperty(t.prototype, "name", { get: function () { return n; } }), t.prototype.toString = function () { return this.name + ": " + this.message; }, t; } r.asPromise = f(1016), r.base64 = f(1017), r.EventEmitter = f(1018), r.float = f(1019), r.inquire = f(1020), r.utf8 = f(1021), r.pool = f(1022), r.LongBits = f(1023), r.isNode = Boolean(d !== void 0 && d && d.process && d.process.versions && d.process.versions.node), r.global = r.isNode && d || typeof window != "undefined" && window || typeof self != "undefined" && self || void 0, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function (n) { return typeof n == "number" && isFinite(n) && Math.floor(n) === n; }, r.isString = function (n) { return typeof n == "string" || n instanceof String; }, r.isObject = function (n) { return n && typeof n == "object"; }, r.isset = r.isSet = function (n, t) { var s = n[t]; return !(s == null || !n.hasOwnProperty(t)) && (typeof s != "object" || (Array.isArray(s) ? s.length : Object.keys(s).length) > 0); }, r.Buffer = function () { try {
                    var n = r.inquire("buffer").Buffer;
                    return n.prototype.utf8Write ? n : null;
                }
                catch (t) {
                    return null;
                } }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function (n) { return typeof n == "number" ? r.Buffer ? r._Buffer_allocUnsafe(n) : new r.Array(n) : r.Buffer ? r._Buffer_from(n) : typeof Uint8Array == "undefined" ? n : new Uint8Array(n); }, r.Array = typeof Uint8Array != "undefined" ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function (n) { return n ? r.LongBits.from(n).toHash() : r.LongBits.zeroHash; }, r.longFromHash = function (n, t) { var s = r.LongBits.fromHash(n); return r.Long ? r.Long.fromBits(s.lo, s.hi, t) : s.toNumber(Boolean(t)); }, r.merge = e, r.lcFirst = function (n) { return n.charAt(0).toLowerCase() + n.substring(1); }, r.newError = c, r.ProtocolError = c("ProtocolError"), r.oneOfGetter = function (n) { for (var t = {}, s = 0; s < n.length; ++s)
                    t[n[s]] = 1; return function () { for (var u = Object.keys(this), i = u.length - 1; i > -1; --i)
                    if (t[u[i]] === 1 && this[u[i]] !== void 0 && this[u[i]] !== null)
                        return u[i]; }; }, r.oneOfSetter = function (n) { return function (t) { for (var s = 0; s < n.length; ++s)
                    n[s] !== t && delete this[n[s]]; }; }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }, r._configure = function () { var n = r.Buffer; n ? (r._Buffer_from = n.from !== Uint8Array.from && n.from || function (t, s) { return new n(t, s); }, r._Buffer_allocUnsafe = n.allocUnsafe || function (t) { return new n(t); }) : r._Buffer_from = r._Buffer_allocUnsafe = null; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = m.second = 1e3, r = m.minute = 60 * d, e = m.hour = 60 * r;
                m.MAX_RECORD_AGE = 36 * e, m.PROTOCOL_DHT = "/kad/1.0.0", m.PROVIDERS_KEY_PREFIX = "/providers/", m.PROVIDERS_LRU_CACHE_SIZE = 256, m.PROVIDERS_VALIDITY = 24 * e, m.PROVIDERS_CLEANUP_INTERVAL = e, m.READ_MESSAGE_TIMEOUT = 10 * d, m.GET_MANY_RECORD_COUNT = 16, m.K = 20, m.ALPHA = 3, m.defaultRandomWalk = { enabled: !0, queriesPerPeriod: 1, interval: 5 * r, timeout: 10 * d, delay: 10 * d };
            }, function (E, m, f) {
                "use strict";
                const d = f(13), r = B("dns4"), e = B("dns6"), c = B("dnsaddr"), n = T(B("dns"), c, r, e), t = T(B("ip4"), B("ip6")), s = T(S(t, B("tcp")), S(n, B("tcp"))), u = S(t, B("udp")), i = S(u, B("utp")), o = T(S(s, B("ws")), S(n, B("ws"))), h = T(S(s, B("wss")), S(n, B("wss"))), a = T(S(s, B("http")), S(t, B("http")), S(n, B("http"))), l = T(S(s, B("https")), S(t, B("https")), S(n, B("https"))), p = T(S(o, B("p2p-webrtc-star"), B("p2p")), S(h, B("p2p-webrtc-star"), B("p2p")), S(o, B("p2p-webrtc-star")), S(h, B("p2p-webrtc-star"))), g = T(S(o, B("p2p-websocket-star"), B("p2p")), S(h, B("p2p-websocket-star"), B("p2p")), S(o, B("p2p-websocket-star")), S(h, B("p2p-websocket-star"))), b = T(S(a, B("p2p-webrtc-direct")), S(l, B("p2p-webrtc-direct"))), I = T(o, h, a, l, p, b, s, i, n), v = T(S(I, B("p2p-stardust"), B("p2p")), S(I, B("p2p-stardust"))), R = T(S(I, B("p2p")), p, B("p2p")), _ = T(S(R, B("p2p-circuit"), R), S(R, B("p2p-circuit")), S(B("p2p-circuit"), R), S(I, B("p2p-circuit")), S(B("p2p-circuit"), I), B("p2p-circuit")), k = () => T(S(_, k), _), x = k(), M = T(S(x, R, x), S(R, x), S(x, R), x, R);
                function N(P) { return function (L) { if (!d.isMultiaddr(L))
                    try {
                        L = d(L);
                    }
                    catch (D) {
                        return !1;
                    } const j = P(L.protoNames()); return j !== null && j.length === 0; }; }
                function S() { const P = Array.from(arguments); function L(j) { return j.length < P.length ? null : (P.some(D => { if ((j = typeof D == "function" ? D().partialMatch(j) : D.partialMatch(j)) === null)
                    return !0; }), j); } return { toString: function () { return "{ " + P.join(" ") + " }"; }, input: P, matches: N(L), partialMatch: L }; }
                function T() { const P = Array.from(arguments); function L(D) { let G = null; return P.some(W => { const X = typeof W == "function" ? W().partialMatch(D) : W.partialMatch(D); if (X)
                    return G = X, !0; }), G; } const j = { toString: function () { return "{ " + P.join(" ") + " }"; }, input: P, matches: N(L), partialMatch: L }; return j; }
                function B(P) { const L = P; return { toString: function () { return L; }, matches: function (j) { if (typeof j == "string")
                        try {
                            j = d(j);
                        }
                        catch (G) {
                            return !1;
                        } const D = j.protoNames(); return D.length === 1 && D[0] === L; }, partialMatch: function (j) { return j.length === 0 ? null : j[0] === L ? j.slice(1) : null; } }; }
                m.DNS = n, m.DNS4 = r, m.DNS6 = e, m.DNSADDR = c, m.IP = t, m.TCP = s, m.UDP = u, m.UTP = i, m.HTTP = a, m.HTTPS = l, m.WebSockets = o, m.WebSocketsSecure = h, m.WebSocketStar = g, m.WebRTCStar = p, m.WebRTCDirect = b, m.Reliable = I, m.Stardust = v, m.Circuit = x, m.P2P = M, m.IPFS = M;
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(26), e = f(6);
                E.exports = r(class {
                    constructor(c, n, t) { if (!t)
                        throw new Error("A link requires a cid to point to"); Object.defineProperties(this, { Name: { value: c || "", writable: !1, enumerable: !0 }, Tsize: { value: n, writable: !1, enumerable: !0 }, Hash: { value: new d(t), writable: !1, enumerable: !0 }, _nameBuf: { value: null, writable: !0, enumerable: !1 } }); }
                    toString() { return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`; }
                    toJSON() { return this._json || (this._json = Object.freeze({ name: this.Name, size: this.Tsize, cid: this.Hash.toBaseEncodedString() })), Object.assign({}, this._json); }
                    get nameAsBuffer() { return this._nameBuf !== null || (this._nameBuf = e(this.Name)), this._nameBuf; }
                }, { className: "DAGLink", symbolName: "@ipld/js-ipld-dag-pb/daglink" });
            }, function (E, m, f) {
                "use strict";
                const d = f(541);
                class r extends Error {
                    constructor(n) { super(n), this.name = "TimeoutError"; }
                }
                const e = (c, n, t) => new Promise((s, u) => { if (typeof n != "number" || n < 0)
                    throw new TypeError("Expected `milliseconds` to be a positive number"); if (n === 1 / 0)
                    return void s(c); const i = setTimeout(() => { if (typeof t == "function") {
                    try {
                        s(t());
                    }
                    catch (h) {
                        u(h);
                    }
                    return;
                } const o = t instanceof Error ? t : new r(typeof t == "string" ? t : `Promise timed out after ${n} milliseconds`); typeof c.cancel == "function" && c.cancel(), u(o); }, n); d(c.then(s, u), () => { clearTimeout(i); }); });
                E.exports = e, E.exports.default = e, E.exports.TimeoutError = r;
            }, function (E, m, f) {
                "use strict";
                E.exports = r;
                var d = f(12).EventEmitter;
                function r() { d.call(this); }
                f(15)(r, d), r.Readable = f(157), r.Writable = f(563), r.Duplex = f(564), r.Transform = f(565), r.PassThrough = f(566), r.Stream = r, r.prototype.pipe = function (e, c) { var n = this; function t(l) { e.writable && e.write(l) === !1 && n.pause && n.pause(); } function s() { n.readable && n.resume && n.resume(); } n.on("data", t), e.on("drain", s), e._isStdio || c && c.end === !1 || (n.on("end", i), n.on("close", o)); var u = !1; function i() { u || (u = !0, e.end()); } function o() { u || (u = !0, typeof e.destroy == "function" && e.destroy()); } function h(l) { if (a(), d.listenerCount(this, "error") === 0)
                    throw l; } function a() { n.removeListener("data", t), e.removeListener("drain", s), n.removeListener("end", i), n.removeListener("close", o), n.removeListener("error", h), e.removeListener("error", h), n.removeListener("end", a), n.removeListener("close", a), e.removeListener("close", a); } return n.on("error", h), e.on("error", h), n.on("end", a), n.on("close", a), e.on("close", a), e.emit("pipe", n), e; };
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    var r = Object.getOwnPropertyDescriptors || function (j) { for (var D = Object.keys(j), G = {}, W = 0; W < D.length; W++)
                        G[D[W]] = Object.getOwnPropertyDescriptor(j, D[W]); return G; }, e = /%[sdj%]/g;
                    m.format = function (j) { if (!b(j)) {
                        for (var D = [], G = 0; G < arguments.length; G++)
                            D.push(t(arguments[G]));
                        return D.join(" ");
                    } G = 1; for (var W = arguments, X = W.length, Q = String(j).replace(e, function (F) { if (F === "%%")
                        return "%"; if (G >= X)
                        return F; switch (F) {
                        case "%s": return String(W[G++]);
                        case "%d": return Number(W[G++]);
                        case "%j": try {
                            return JSON.stringify(W[G++]);
                        }
                        catch (Y) {
                            return "[Circular]";
                        }
                        default: return F;
                    } }), K = W[G]; G < X; K = W[++G])
                        p(K) || !R(K) ? Q += " " + K : Q += " " + t(K); return Q; }, m.deprecate = function (j, D) { if (d !== void 0 && d.noDeprecation === !0)
                        return j; if (d === void 0)
                        return function () { return m.deprecate(j, D).apply(this, arguments); }; var G = !1; return function () { if (!G) {
                        if (d.throwDeprecation)
                            throw new Error(D);
                        d.traceDeprecation ? console.trace(D) : console.error(D), G = !0;
                    } return j.apply(this, arguments); }; };
                    var c, n = {};
                    function t(j, D) { var G = { seen: [], stylize: u }; return arguments.length >= 3 && (G.depth = arguments[2]), arguments.length >= 4 && (G.colors = arguments[3]), l(D) ? G.showHidden = D : D && m._extend(G, D), I(G.showHidden) && (G.showHidden = !1), I(G.depth) && (G.depth = 2), I(G.colors) && (G.colors = !1), I(G.customInspect) && (G.customInspect = !0), G.colors && (G.stylize = s), i(G, j, G.depth); }
                    function s(j, D) { var G = t.styles[D]; return G ? "[" + t.colors[G][0] + "m" + j + "[" + t.colors[G][1] + "m" : j; }
                    function u(j, D) { return j; }
                    function i(j, D, G) {
                        if (j.customInspect && D && x(D.inspect) && D.inspect !== m.inspect && (!D.constructor || D.constructor.prototype !== D)) {
                            var W = D.inspect(G, j);
                            return b(W) || (W = i(j, W, G)), W;
                        }
                        var X = function (A, U) { if (I(U))
                            return A.stylize("undefined", "undefined"); if (b(U)) {
                            var z = "'" + JSON.stringify(U).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                            return A.stylize(z, "string");
                        } if (g(U))
                            return A.stylize("" + U, "number"); if (l(U))
                            return A.stylize("" + U, "boolean"); if (p(U))
                            return A.stylize("null", "null"); }(j, D);
                        if (X)
                            return X;
                        var Q = Object.keys(D), K = function (A) { var U = {}; return A.forEach(function (z, w) { U[z] = !0; }), U; }(Q);
                        if (j.showHidden && (Q = Object.getOwnPropertyNames(D)), k(D) && (Q.indexOf("message") >= 0 || Q.indexOf("description") >= 0))
                            return o(D);
                        if (Q.length === 0) {
                            if (x(D)) {
                                var F = D.name ? ": " + D.name : "";
                                return j.stylize("[Function" + F + "]", "special");
                            }
                            if (v(D))
                                return j.stylize(RegExp.prototype.toString.call(D), "regexp");
                            if (_(D))
                                return j.stylize(Date.prototype.toString.call(D), "date");
                            if (k(D))
                                return o(D);
                        }
                        var Y, $ = "", y = !1, C = ["{", "}"];
                        return (a(D) && (y = !0, C = ["[", "]"]), x(D)) && ($ = " [Function" + (D.name ? ": " + D.name : "") + "]"), v(D) && ($ = " " + RegExp.prototype.toString.call(D)), _(D) && ($ = " " + Date.prototype.toUTCString.call(D)), k(D) && ($ = " " + o(D)), Q.length !== 0 || y && D.length != 0 ? G < 0 ? v(D) ? j.stylize(RegExp.prototype.toString.call(D), "regexp") : j.stylize("[Object]", "special") : (j.seen.push(D), Y = y ? function (A, U, z, w, O) { for (var q = [], H = 0, V = U.length; H < V; ++H)
                            B(U, String(H)) ? q.push(h(A, U, z, w, String(H), !0)) : q.push(""); return O.forEach(function (J) { J.match(/^\d+$/) || q.push(h(A, U, z, w, J, !0)); }), q; }(j, D, G, K, Q) : Q.map(function (A) { return h(j, D, G, K, A, y); }), j.seen.pop(), function (A, U, z) {
                            return A.reduce(function (w, O) {
                                return O.indexOf(`
`) >= 0, w + O.replace(/\u001b\[\d\d?m/g, "").length + 1;
                            }, 0) > 60 ? z[0] + (U === "" ? "" : U + `
 `) + " " + A.join(`,
  `) + " " + z[1] : z[0] + U + " " + A.join(", ") + " " + z[1];
                        }(Y, $, C)) : C[0] + $ + C[1];
                    }
                    function o(j) { return "[" + Error.prototype.toString.call(j) + "]"; }
                    function h(j, D, G, W, X, Q) {
                        var K, F, Y;
                        if ((Y = Object.getOwnPropertyDescriptor(D, X) || { value: D[X] }).get ? F = Y.set ? j.stylize("[Getter/Setter]", "special") : j.stylize("[Getter]", "special") : Y.set && (F = j.stylize("[Setter]", "special")), B(W, X) || (K = "[" + X + "]"), F || (j.seen.indexOf(Y.value) < 0 ? (F = p(G) ? i(j, Y.value, null) : i(j, Y.value, G - 1)).indexOf(`
`) > -1 && (F = Q ? F.split(`
`).map(function ($) { return "  " + $; }).join(`
`).substr(2) : `
` + F.split(`
`).map(function ($) { return "   " + $; }).join(`
`)) : F = j.stylize("[Circular]", "special")), I(K)) {
                            if (Q && X.match(/^\d+$/))
                                return F;
                            (K = JSON.stringify("" + X)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (K = K.substr(1, K.length - 2), K = j.stylize(K, "name")) : (K = K.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), K = j.stylize(K, "string"));
                        }
                        return K + ": " + F;
                    }
                    function a(j) { return Array.isArray(j); }
                    function l(j) { return typeof j == "boolean"; }
                    function p(j) { return j === null; }
                    function g(j) { return typeof j == "number"; }
                    function b(j) { return typeof j == "string"; }
                    function I(j) { return j === void 0; }
                    function v(j) { return R(j) && M(j) === "[object RegExp]"; }
                    function R(j) { return typeof j == "object" && j !== null; }
                    function _(j) { return R(j) && M(j) === "[object Date]"; }
                    function k(j) { return R(j) && (M(j) === "[object Error]" || j instanceof Error); }
                    function x(j) { return typeof j == "function"; }
                    function M(j) { return Object.prototype.toString.call(j); }
                    function N(j) { return j < 10 ? "0" + j.toString(10) : j.toString(10); }
                    m.debuglog = function (j) { if (I(c) && (c = { NODE_ENV: "production" }.NODE_DEBUG || ""), j = j.toUpperCase(), !n[j])
                        if (new RegExp("\\b" + j + "\\b", "i").test(c)) {
                            var D = d.pid;
                            n[j] = function () { var G = m.format.apply(m, arguments); console.error("%s %d: %s", j, D, G); };
                        }
                        else
                            n[j] = function () { }; return n[j]; }, m.inspect = t, t.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, t.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, m.isArray = a, m.isBoolean = l, m.isNull = p, m.isNullOrUndefined = function (j) { return j == null; }, m.isNumber = g, m.isString = b, m.isSymbol = function (j) { return typeof j == "symbol"; }, m.isUndefined = I, m.isRegExp = v, m.isObject = R, m.isDate = _, m.isError = k, m.isFunction = x, m.isPrimitive = function (j) { return j === null || typeof j == "boolean" || typeof j == "number" || typeof j == "string" || typeof j == "symbol" || j === void 0; }, m.isBuffer = f(567);
                    var S = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                    function T() { var j = new Date, D = [N(j.getHours()), N(j.getMinutes()), N(j.getSeconds())].join(":"); return [j.getDate(), S[j.getMonth()], D].join(" "); }
                    function B(j, D) { return Object.prototype.hasOwnProperty.call(j, D); }
                    m.log = function () { console.log("%s - %s", T(), m.format.apply(m, arguments)); }, m.inherits = f(568), m._extend = function (j, D) { if (!D || !R(D))
                        return j; for (var G = Object.keys(D), W = G.length; W--;)
                        j[G[W]] = D[G[W]]; return j; };
                    var P = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
                    function L(j, D) { if (!j) {
                        var G = new Error("Promise was rejected with a falsy value");
                        G.reason = j, j = G;
                    } return D(j); }
                    m.promisify = function (j) { if (typeof j != "function")
                        throw new TypeError('The "original" argument must be of type Function'); if (P && j[P]) {
                        var D;
                        if (typeof (D = j[P]) != "function")
                            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        return Object.defineProperty(D, P, { value: D, enumerable: !1, writable: !1, configurable: !0 }), D;
                    } function D() { for (var G, W, X = new Promise(function (F, Y) { G = F, W = Y; }), Q = [], K = 0; K < arguments.length; K++)
                        Q.push(arguments[K]); Q.push(function (F, Y) { F ? W(F) : G(Y); }); try {
                        j.apply(this, Q);
                    }
                    catch (F) {
                        W(F);
                    } return X; } return Object.setPrototypeOf(D, Object.getPrototypeOf(j)), P && Object.defineProperty(D, P, { value: D, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(D, r(j)); }, m.promisify.custom = P, m.callbackify = function (j) { if (typeof j != "function")
                        throw new TypeError('The "original" argument must be of type Function'); function D() { for (var G = [], W = 0; W < arguments.length; W++)
                        G.push(arguments[W]); var X = G.pop(); if (typeof X != "function")
                        throw new TypeError("The last argument must be of type Function"); var Q = this, K = function () { return X.apply(Q, arguments); }; j.apply(this, G).then(function (F) { d.nextTick(K, null, F); }, function (F) { d.nextTick(L, F, K); }); } return Object.setPrototypeOf(D, Object.getPrototypeOf(j)), Object.defineProperties(D, r(j)), D; };
                }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(64), e = f(30).BigNumber, c = f(54), n = c.NUMBYTES, t = c.SHIFT32; m.hasBigInt = typeof BigInt == "function"; const s = typeof TextDecoder == "function" ? TextDecoder : r.TextDecoder; if (s) {
                    const u = new s("utf8", { fatal: !0, ignoreBOM: !0 });
                    m.utf8 = i => u.decode(i), m.utf8.checksUTF8 = !0;
                }
                else
                    m.utf8 = u => u.toString("utf8"), m.utf8.checksUTF8 = !1; m.parseCBORint = function (u, i) { switch (u) {
                    case n.ONE: return i.readUInt8(0);
                    case n.TWO: return i.readUInt16BE(0);
                    case n.FOUR: return i.readUInt32BE(0);
                    case n.EIGHT:
                        const o = i.readUInt32BE(0), h = i.readUInt32BE(4);
                        return o > 2097151 ? new e(o).times(t).plus(h) : o * t + h;
                    default: throw new Error("Invalid additional info for int: " + u);
                } }, m.writeHalf = function (u, i) { const o = d.allocUnsafe(4); o.writeFloatBE(i, 0); const h = o.readUInt32BE(0); if ((8191 & h) != 0)
                    return !1; let a = h >> 16 & 32768; const l = h >> 23 & 255, p = 8388607 & h; if (l >= 113 && l <= 142)
                    a += (l - 112 << 10) + (p >> 13);
                else {
                    if (!(l >= 103 && l < 113))
                        return !1;
                    if (p & (1 << 126 - l) - 1)
                        return !1;
                    a += p + 8388608 >> 126 - l;
                } return u.writeUInt16BE(a), !0; }, m.parseHalf = function (u) { const i = 128 & u[0] ? -1 : 1, o = (124 & u[0]) >> 2, h = (3 & u[0]) << 8 | u[1]; return o ? o === 31 ? i * (h ? NaN : Infinity) : i * Math.pow(2, o - 25) * (1024 + h) : 5960464477539063e-23 * i * h; }, m.parseCBORfloat = function (u) { switch (u.length) {
                    case 2: return m.parseHalf(u);
                    case 4: return u.readFloatBE(0);
                    case 8: return u.readDoubleBE(0);
                    default: throw new Error("Invalid float size: " + u.length);
                } }, m.hex = function (u) { return d.from(u.replace(/^0x/, ""), "hex"); }, m.bin = function (u) { let i = 0, o = (u = u.replace(/\s/g, "")).length % 8 || 8; const h = []; for (; o <= u.length;)
                    h.push(parseInt(u.slice(i, o), 2)), i = o, o += 8; return d.from(h); }, m.extend = function (u = {}, ...i) { const o = i.length; for (let h = 0; h < o; h++) {
                    const a = i[h];
                    for (const l in a) {
                        const p = a[l];
                        u[l] = p;
                    }
                } return u; }, m.arrayEqual = function (u, i) { return u == null && i == null || u != null && i != null && u.length === i.length && u.every((o, h) => o === i[h]); }, m.bufferEqual = function (u, i) { if (u == null && i == null)
                    return !0; if (u == null || i == null)
                    return !1; if (!d.isBuffer(u) || !d.isBuffer(i) || u.length !== i.length)
                    return !1; const o = u.length; let h, a, l = !0; for (h = a = 0; a < o; h = ++a) {
                    const p = u[h];
                    l = l && i[h] === p;
                } return !!l; }, m.bufferToBignumber = function (u) { return new e(u.toString("hex"), 16); }, m.toBigInt = function (u) { return m.hasBigInt ? BigInt(u) : Number(u); }, m.bigIntize = function (u) { const i = {}; for (const o in u)
                    i[o] = m.toBigInt(u[o]); return i; }, m.bufferToBigInt = function (u) { return m.toBigInt("0x" + u.toString("hex")); }, m.guessEncoding = function (u) { if (typeof u == "string")
                    return "hex"; if (!d.isBuffer(u))
                    throw new Error("Unknown input type"); }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = { Record: f(602), validator: f(605), selection: f(608) };
            }, function (E, m, f) {
                "use strict";
                const d = f(16), r = f(4);
                E.exports = async (e, c, n) => { n.codec || (n.codec = "dag-pb"), n.cidVersion || (n.cidVersion = 0), n.hashAlg || (n.hashAlg = "sha2-256"), n.hashAlg !== "sha2-256" && (n.cidVersion = 1); const t = await d(e, n.hashAlg), s = new r(n.cidVersion, n.codec, t); return n.onlyHash || await c.put(e, { ...n, cid: s }), s; };
            }, function (E, m, f) {
                "use strict";
                const { DAGLink: d, DAGNode: r } = f(17), e = f(4), c = f(1)("ipfs:mfs:core:utils:add-link"), n = f(29), t = f(171), { updateHamtDirectory: s, recreateHamtLevel: u, createShard: i, toPrefix: o, addLinksToHamtBucket: h } = f(296), a = f(0), l = f(18), p = f(16).multihash, g = f(40), b = async (k, x) => { const M = await i(k, x.parent.Links.map(N => ({ name: N.Name, size: N.Tsize, cid: N.Hash })).concat({ name: x.name, size: x.size, cid: x.cid }), x); return c("Converted directory to sharded directory " + M.cid), M; }, I = async (k, x) => { x.parent.rmLink(x.name), x.parent.addLink(new d(x.name, x.size, x.cid)); const M = n.unmarshal(x.parent.Data); M.mtime && (M.mtime = new Date, x.parent = new r(M.marshal(), x.parent.Links)); const N = p.names[x.hashAlg], S = await k.ipld.put(x.parent, l.DAG_PB, { cidVersion: x.cidVersion, hashAlg: N, onlyHash: !x.flush }); return { node: x.parent, cid: S, size: x.parent.size }; }, v = async (k, x) => { const { shard: M, path: N } = await R(k, x), S = await g(M.flush("", k.block)), T = await k.ipld.get(S.cid), B = x.parent.Links.find(L => L.Name.substring(0, 2) === N[0].prefix), P = T.Links.find(L => L.Name.substring(0, 2) === N[0].prefix); return B && x.parent.rmLink(B.Name), x.parent.addLink(P), s(k, x.parent.Links, N[0].bucket, x); }, R = async (k, x) => { const M = { name: x.name, cid: x.cid, size: x.size }, N = await u(x.parent.Links), S = n.unmarshal(x.parent.Data), T = new t({ root: !0, dir: !0, parent: null, parentKey: null, path: "", dirty: !0, flat: !1, mode: S.mode }, x); T._bucket = N, S.mtime && (T.mtime = new Date); const B = await N._findNewBucketAndPos(M.name), P = _(B); P[0].node = x.parent; let L = 0; for (; L < P.length;) {
                    const j = P[L];
                    L++;
                    const D = j.node.Links.find(X => X.Name.substring(0, 2) === j.prefix);
                    if (!D) {
                        c(`Link ${j.prefix}${M.name} will be added`), L = P.length;
                        break;
                    }
                    if (D.Name === `${j.prefix}${M.name}`) {
                        c(`Link ${j.prefix}${M.name} will be replaced`), L = P.length;
                        break;
                    }
                    if (D.Name.length > 2) {
                        c(`Link ${D.Name} ${D.Hash} will be replaced with a subshard`), L = P.length;
                        break;
                    }
                    c("Found subshard " + j.prefix);
                    const G = await k.ipld.get(D.Hash);
                    if (!P[L]) {
                        c("Loaded new subshard " + j.prefix), await u(G.Links, N, j.bucket, parseInt(j.prefix, 16));
                        const X = await N._findNewBucketAndPos(M.name);
                        P.push({ bucket: X.bucket, prefix: o(X.pos), node: G });
                        break;
                    }
                    const W = P[L];
                    await h(G.Links, W.bucket, N), W.node = G;
                } return await T._bucket.put(M.name, { size: M.size, cid: M.cid }), { shard: T, path: P }; }, _ = k => { let x = k.bucket, M = k.pos; const N = [{ bucket: x, prefix: o(M) }]; for (x = k.bucket._parent, M = k.bucket._posAtParent; x;)
                    N.push({ bucket: x, prefix: o(M) }), M = x._posAtParent, x = x._parent; return N.reverse(), N; };
                E.exports = async (k, x) => { if (!x.parentCid && !x.parent)
                    throw a(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT"); if (x.parentCid && !e.isCID(x.parentCid))
                    throw a(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID"); if (x.parent || (c("Loading parent node " + x.parentCid), x.parent = await k.ipld.get(x.parentCid)), !x.cid)
                    throw a(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID"); if (!x.name)
                    throw a(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME"); if (e.isCID(x.cid) || (x.cid = new e(x.cid)), !x.size && x.size !== 0)
                    throw a(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE"); const M = n.unmarshal(x.parent.Data); return M.type === "hamt-sharded-directory" ? (c("Adding link to sharded directory"), v(k, x)) : x.parent.Links.length >= x.shardSplitThreshold ? (c("Converting directory to sharded directory"), b(k, { ...x, mtime: M.mtime, mode: M.mode })) : (c(`Adding ${x.name} (${x.cid}) to regular directory`), I(k, x)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:mfs:utils:update-tree"), r = f(68), e = { shardSplitThreshold: 1e3 };
                E.exports = async (c, n, t) => { t = Object.assign({}, e, t), d("Trail", n), n = n.slice().reverse(); let s, u = 0; for await (const o of c.ipld.getMany(n.map(h => h.cid))) {
                    const h = n[u].cid, a = n[u].name;
                    if (u++, !s) {
                        s = { cid: h, name: a, size: o.size };
                        continue;
                    }
                    const l = await r(c, { parent: o, name: s.name, cid: s.cid, size: s.size, flush: t.flush, shardSplitThreshold: t.shardSplitThreshold, hashAlg: t.hashAlg, cidVersion: t.cidVersion });
                    s = { cid: l.cid, name: a, size: l.size };
                } const { cid: i } = s; return d("Final CID " + i), i; };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:mfs:utils:update-mfs-root"), { MFS_ROOT_KEY: r } = f(23), e = f(0);
                E.exports = async (c, n, t) => { if (t && t.signal && t.signal.aborted)
                    throw e(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" }); return d("New MFS root will be " + n), await c.repo.datastore.put(r, n.bytes), n; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { for (var r = {}, e = 0; e < arguments.length; e++) {
                    var c = arguments[e];
                    for (var n in c)
                        d.call(c, n) && (r[n] = c[n]);
                } return r; };
                var d = Object.prototype.hasOwnProperty;
            }, function (E, m, f) {
                "use strict";
                var d = {};
                function r(c, n, t) { t || (t = Error); var s = function (u) { var i, o; function h(a, l, p) { return u.call(this, function (g, b, I) { return typeof n == "string" ? n : n(g, b, I); }(a, l, p)) || this; } return o = u, (i = h).prototype = Object.create(o.prototype), i.prototype.constructor = i, i.__proto__ = o, h; }(t); s.prototype.name = t.name, s.prototype.code = c, d[c] = s; }
                function e(c, n) { if (Array.isArray(c)) {
                    var t = c.length;
                    return c = c.map(function (s) { return String(s); }), t > 2 ? "one of ".concat(n, " ").concat(c.slice(0, t - 1).join(", "), ", or ") + c[t - 1] : t === 2 ? "one of ".concat(n, " ").concat(c[0], " or ").concat(c[1]) : "of ".concat(n, " ").concat(c[0]);
                } return "of ".concat(n, " ").concat(String(c)); }
                r("ERR_INVALID_OPT_VALUE", function (c, n) { return 'The value "' + n + '" is invalid for option "' + c + '"'; }, TypeError), r("ERR_INVALID_ARG_TYPE", function (c, n, t) { var s, u, i, o; if (typeof n == "string" && (u = "not ", n.substr(!i || i < 0 ? 0 : +i, u.length) === u) ? (s = "must not be", n = n.replace(/^not /, "")) : s = "must be", function (a, l, p) { return (p === void 0 || p > a.length) && (p = a.length), a.substring(p - l.length, p) === l; }(c, " argument"))
                    o = "The ".concat(c, " ").concat(s, " ").concat(e(n, "type"));
                else {
                    var h = function (a, l, p) { return typeof p != "number" && (p = 0), !(p + l.length > a.length) && a.indexOf(l, p) !== -1; }(c, ".") ? "property" : "argument";
                    o = 'The "'.concat(c, '" ').concat(h, " ").concat(s, " ").concat(e(n, "type"));
                } return o += ". Received type ".concat(typeof t); }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function (c) { return "The " + c + " method is not implemented"; }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function (c) { return "Cannot call " + c + " after a stream was destroyed"; }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function (c) { return "Unknown encoding: " + c; }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), E.exports.codes = d;
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = Object.keys || function (h) { var a = []; for (var l in h)
                    a.push(l); return a; }; E.exports = u; var e = f(307), c = f(311); f(15)(u, e); for (var n = r(c.prototype), t = 0; t < n.length; t++) {
                    var s = n[t];
                    u.prototype[s] || (u.prototype[s] = c.prototype[s]);
                } function u(h) { if (!(this instanceof u))
                    return new u(h); e.call(this, h), c.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", i))); } function i() { this._writableState.ended || d.nextTick(o, this); } function o(h) { h.end(); } Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer(); } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length; } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed; }, set: function (h) { this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = h, this._writableState.destroyed = h); } }); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = Object.create ? function (e, c, n, t) { t === void 0 && (t = n), Object.defineProperty(e, t, { enumerable: !0, get: function () { return c[n]; } }); } : function (e, c, n, t) { t === void 0 && (t = n), e[t] = c[n]; }, r = function (e, c) { for (var n in e)
                    n === "default" || c.hasOwnProperty(n) || d(c, e, n); };
                Object.defineProperty(m, "__esModule", { value: !0 }), r(f(832), m), r(f(833), m), r(f(834), m), r(f(835), m);
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.ERR_TOPIC_VALIDATOR_IGNORE = m.ERR_TOPIC_VALIDATOR_REJECT = m.TimeCacheDuration = m.GossipsubIWantFollowupTime = m.GossipsubMaxIHaveMessages = m.GossipsubMaxIHaveLength = m.GossipsubGraftFloodThreshold = m.GossipsubOpportunisticGraftPeers = m.GossipsubOpportunisticGraftTicks = m.GossipsubDirectConnectInitialDelay = m.GossipsubDirectConnectTicks = m.GossipsubConnectionTimeout = m.GossipsubMaxPendingConnections = m.GossipsubConnectors = m.GossipsubPruneBackoffTicks = m.GossipsubPruneBackoff = m.GossipsubPrunePeers = m.GossipsubFanoutTTL = m.GossipsubHeartbeatInterval = m.GossipsubHeartbeatInitialDelay = m.GossipsubGossipRetransmission = m.GossipsubGossipFactor = m.GossipsubDlazy = m.GossipsubHistoryGossip = m.GossipsubHistoryLength = m.GossipsubDout = m.GossipsubDscore = m.GossipsubDhi = m.GossipsubDlo = m.GossipsubD = m.GossipsubIDv11 = m.GossipsubIDv10 = m.FloodsubID = m.minute = m.second = void 0, m.second = 1e3, m.minute = 60 * m.second, m.FloodsubID = "/floodsub/1.0.0", m.GossipsubIDv10 = "/meshsub/1.0.0", m.GossipsubIDv11 = "/meshsub/1.1.0", m.GossipsubD = 6, m.GossipsubDlo = 4, m.GossipsubDhi = 12, m.GossipsubDscore = 4, m.GossipsubDout = 2, m.GossipsubHistoryLength = 5, m.GossipsubHistoryGossip = 3, m.GossipsubDlazy = 6, m.GossipsubGossipFactor = .25, m.GossipsubGossipRetransmission = 3, m.GossipsubHeartbeatInitialDelay = 100, m.GossipsubHeartbeatInterval = m.second, m.GossipsubFanoutTTL = m.minute, m.GossipsubPrunePeers = 16, m.GossipsubPruneBackoff = m.minute, m.GossipsubPruneBackoffTicks = 15, m.GossipsubConnectors = 8, m.GossipsubMaxPendingConnections = 128, m.GossipsubConnectionTimeout = 30 * m.second, m.GossipsubDirectConnectTicks = 300, m.GossipsubDirectConnectInitialDelay = m.second, m.GossipsubOpportunisticGraftTicks = 60, m.GossipsubOpportunisticGraftPeers = 2, m.GossipsubGraftFloodThreshold = 10 * m.second, m.GossipsubMaxIHaveLength = 5e3, m.GossipsubMaxIHaveMessages = 10, m.GossipsubIWantFollowupTime = 3 * m.second, m.TimeCacheDuration = 12e4, m.ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT", m.ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
            }, function (E, m, f) {
                "use strict";
                var d = {};
                function r(c, n, t) { t || (t = Error); var s = function (u) { var i, o; function h(a, l, p) { return u.call(this, function (g, b, I) { return typeof n == "string" ? n : n(g, b, I); }(a, l, p)) || this; } return o = u, (i = h).prototype = Object.create(o.prototype), i.prototype.constructor = i, i.__proto__ = o, h; }(t); s.prototype.name = t.name, s.prototype.code = c, d[c] = s; }
                function e(c, n) { if (Array.isArray(c)) {
                    var t = c.length;
                    return c = c.map(function (s) { return String(s); }), t > 2 ? "one of ".concat(n, " ").concat(c.slice(0, t - 1).join(", "), ", or ") + c[t - 1] : t === 2 ? "one of ".concat(n, " ").concat(c[0], " or ").concat(c[1]) : "of ".concat(n, " ").concat(c[0]);
                } return "of ".concat(n, " ").concat(String(c)); }
                r("ERR_INVALID_OPT_VALUE", function (c, n) { return 'The value "' + n + '" is invalid for option "' + c + '"'; }, TypeError), r("ERR_INVALID_ARG_TYPE", function (c, n, t) { var s, u, i, o; if (typeof n == "string" && (u = "not ", n.substr(!i || i < 0 ? 0 : +i, u.length) === u) ? (s = "must not be", n = n.replace(/^not /, "")) : s = "must be", function (a, l, p) { return (p === void 0 || p > a.length) && (p = a.length), a.substring(p - l.length, p) === l; }(c, " argument"))
                    o = "The ".concat(c, " ").concat(s, " ").concat(e(n, "type"));
                else {
                    var h = function (a, l, p) { return typeof p != "number" && (p = 0), !(p + l.length > a.length) && a.indexOf(l, p) !== -1; }(c, ".") ? "property" : "argument";
                    o = 'The "'.concat(c, '" ').concat(h, " ").concat(s, " ").concat(e(n, "type"));
                } return o += ". Received type ".concat(typeof t); }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function (c) { return "The " + c + " method is not implemented"; }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function (c) { return "Cannot call " + c + " after a stream was destroyed"; }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function (c) { return "Unknown encoding: " + c; }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), E.exports.codes = d;
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = Object.keys || function (h) { var a = []; for (var l in h)
                    a.push(l); return a; }; E.exports = u; var e = f(357), c = f(361); f(15)(u, e); for (var n = r(c.prototype), t = 0; t < n.length; t++) {
                    var s = n[t];
                    u.prototype[s] || (u.prototype[s] = c.prototype[s]);
                } function u(h) { if (!(this instanceof u))
                    return new u(h); e.call(this, h), c.call(this, h), this.allowHalfOpen = !0, h && (h.readable === !1 && (this.readable = !1), h.writable === !1 && (this.writable = !1), h.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", i))); } function i() { this._writableState.ended || d.nextTick(o, this); } function o(h) { h.end(); } Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer(); } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length; } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed; }, set: function (h) { this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = h, this._writableState.destroyed = h); } }); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                function d(r) { if (r)
                    return function (e) { for (var c in d.prototype)
                        e[c] = d.prototype[c]; return e; }(r); }
                E.exports = d, d.prototype.on = d.prototype.addEventListener = function (r, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(e), this; }, d.prototype.once = function (r, e) { function c() { this.off(r, c), e.apply(this, arguments); } return c.fn = e, this.on(r, c), this; }, d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function (r, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0)
                    return this._callbacks = {}, this; var c, n = this._callbacks["$" + r]; if (!n)
                    return this; if (arguments.length == 1)
                    return delete this._callbacks["$" + r], this; for (var t = 0; t < n.length; t++)
                    if ((c = n[t]) === e || c.fn === e) {
                        n.splice(t, 1);
                        break;
                    } return n.length === 0 && delete this._callbacks["$" + r], this; }, d.prototype.emit = function (r) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), c = this._callbacks["$" + r], n = 1; n < arguments.length; n++)
                    e[n - 1] = arguments[n]; if (c) {
                    n = 0;
                    for (var t = (c = c.slice(0)).length; n < t; ++n)
                        c[n].apply(this, e);
                } return this; }, d.prototype.listeners = function (r) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + r] || []; }, d.prototype.hasListeners = function (r) { return !!this.listeners(r).length; };
            }, function (E, m, f) {
                "use strict";
                var d, r = f(974), e = f(369), c = f(976), n = f(977), t = f(978);
                typeof ArrayBuffer != "undefined" && (d = f(979));
                var s = typeof navigator != "undefined" && /Android/i.test(navigator.userAgent), u = typeof navigator != "undefined" && /PhantomJS/i.test(navigator.userAgent), i = s || u;
                m.protocol = 3;
                var o = m.packets = { open: 0, close: 1, ping: 2, pong: 3, message: 4, upgrade: 5, noop: 6 }, h = r(o), a = { type: "error", data: "parser error" }, l = f(980);
                function p(g, b, I) { for (var v = new Array(g.length), R = n(g.length, I), _ = function (x, M, N) { b(M, function (S, T) { v[x] = T, N(S, v); }); }, k = 0; k < g.length; k++)
                    _(k, g[k], R); }
                m.encodePacket = function (g, b, I, v) { typeof b == "function" && (v = b, b = !1), typeof I == "function" && (v = I, I = null); var R = g.data === void 0 ? void 0 : g.data.buffer || g.data; if (typeof ArrayBuffer != "undefined" && R instanceof ArrayBuffer)
                    return function (k, x, M) { if (!x)
                        return m.encodeBase64Packet(k, M); var N = k.data, S = new Uint8Array(N), T = new Uint8Array(1 + N.byteLength); T[0] = o[k.type]; for (var B = 0; B < S.length; B++)
                        T[B + 1] = S[B]; return M(T.buffer); }(g, b, v); if (l !== void 0 && R instanceof l)
                    return function (k, x, M) { if (!x)
                        return m.encodeBase64Packet(k, M); if (i)
                        return function (T, B, P) { if (!B)
                            return m.encodeBase64Packet(T, P); var L = new FileReader; return L.onload = function () { m.encodePacket({ type: T.type, data: L.result }, B, !0, P); }, L.readAsArrayBuffer(T.data); }(k, x, M); var N = new Uint8Array(1); N[0] = o[k.type]; var S = new l([N.buffer, k.data]); return M(S); }(g, b, v); if (R && R.base64)
                    return function (k, x) { var M = "b" + m.packets[k.type] + k.data.data; return x(M); }(g, v); var _ = o[g.type]; return g.data !== void 0 && (_ += I ? t.encode(String(g.data), { strict: !1 }) : String(g.data)), v("" + _); }, m.encodeBase64Packet = function (g, b) { var I, v = "b" + m.packets[g.type]; if (l !== void 0 && g.data instanceof l) {
                    var R = new FileReader;
                    return R.onload = function () { var M = R.result.split(",")[1]; b(v + M); }, R.readAsDataURL(g.data);
                } try {
                    I = String.fromCharCode.apply(null, new Uint8Array(g.data));
                }
                catch (M) {
                    for (var _ = new Uint8Array(g.data), k = new Array(_.length), x = 0; x < _.length; x++)
                        k[x] = _[x];
                    I = String.fromCharCode.apply(null, k);
                } return v += btoa(I), b(v); }, m.decodePacket = function (g, b, I) { if (g === void 0)
                    return a; if (typeof g == "string") {
                    if (g.charAt(0) === "b")
                        return m.decodeBase64Packet(g.substr(1), b);
                    if (I && (g = function (_) { try {
                        _ = t.decode(_, { strict: !1 });
                    }
                    catch (k) {
                        return !1;
                    } return _; }(g)) === !1)
                        return a;
                    var v = g.charAt(0);
                    return Number(v) == v && h[v] ? g.length > 1 ? { type: h[v], data: g.substring(1) } : { type: h[v] } : a;
                } v = new Uint8Array(g)[0]; var R = c(g, 1); return l && b === "blob" && (R = new l([R])), { type: h[v], data: R }; }, m.decodeBase64Packet = function (g, b) { var I = h[g.charAt(0)]; if (!d)
                    return { type: I, data: { base64: !0, data: g.substr(1) } }; var v = d.decode(g.substr(1)); return b === "blob" && l && (v = new l([v])), { type: I, data: v }; }, m.encodePayload = function (g, b, I) { typeof b == "function" && (I = b, b = null); var v = e(g); if (b && v)
                    return l && !i ? m.encodePayloadAsBlob(g, I) : m.encodePayloadAsArrayBuffer(g, I); if (!g.length)
                    return I("0:"); p(g, function (R, _) { m.encodePacket(R, !!v && b, !1, function (k) { _(null, function (x) { return x.length + ":" + x; }(k)); }); }, function (R, _) { return I(_.join("")); }); }, m.decodePayload = function (g, b, I) { if (typeof g != "string")
                    return m.decodePayloadAsBinary(g, b, I); var v; if (typeof b == "function" && (I = b, b = null), g === "")
                    return I(a, 0, 1); for (var R, _, k = "", x = 0, M = g.length; x < M; x++) {
                    var N = g.charAt(x);
                    if (N === ":") {
                        if (k === "" || k != (R = Number(k)))
                            return I(a, 0, 1);
                        if (k != (_ = g.substr(x + 1, R)).length)
                            return I(a, 0, 1);
                        if (_.length) {
                            if (v = m.decodePacket(_, b, !1), a.type === v.type && a.data === v.data)
                                return I(a, 0, 1);
                            if (I(v, x + R, M) === !1)
                                return;
                        }
                        x += R, k = "";
                    }
                    else
                        k += N;
                } return k !== "" ? I(a, 0, 1) : void 0; }, m.encodePayloadAsArrayBuffer = function (g, b) { if (!g.length)
                    return b(new ArrayBuffer(0)); p(g, function (I, v) { m.encodePacket(I, !0, !0, function (R) { return v(null, R); }); }, function (I, v) { var R = v.reduce(function (x, M) { var N; return x + (N = typeof M == "string" ? M.length : M.byteLength).toString().length + N + 2; }, 0), _ = new Uint8Array(R), k = 0; return v.forEach(function (x) { var M = typeof x == "string", N = x; if (M) {
                    for (var S = new Uint8Array(x.length), T = 0; T < x.length; T++)
                        S[T] = x.charCodeAt(T);
                    N = S.buffer;
                } _[k++] = M ? 0 : 1; var B = N.byteLength.toString(); for (T = 0; T < B.length; T++)
                    _[k++] = parseInt(B[T]); for (_[k++] = 255, S = new Uint8Array(N), T = 0; T < S.length; T++)
                    _[k++] = S[T]; }), b(_.buffer); }); }, m.encodePayloadAsBlob = function (g, b) { p(g, function (I, v) { m.encodePacket(I, !0, !0, function (R) { var _ = new Uint8Array(1); if (_[0] = 1, typeof R == "string") {
                    for (var k = new Uint8Array(R.length), x = 0; x < R.length; x++)
                        k[x] = R.charCodeAt(x);
                    R = k.buffer, _[0] = 0;
                } var M = (R instanceof ArrayBuffer ? R.byteLength : R.size).toString(), N = new Uint8Array(M.length + 1); for (x = 0; x < M.length; x++)
                    N[x] = parseInt(M[x]); if (N[M.length] = 255, l) {
                    var S = new l([_.buffer, N.buffer, R]);
                    v(null, S);
                } }); }, function (I, v) { return b(new l(v)); }); }, m.decodePayloadAsBinary = function (g, b, I) { typeof b == "function" && (I = b, b = null); for (var v = g, R = []; v.byteLength > 0;) {
                    for (var _ = new Uint8Array(v), k = _[0] === 0, x = "", M = 1; _[M] !== 255; M++) {
                        if (x.length > 310)
                            return I(a, 0, 1);
                        x += _[M];
                    }
                    v = c(v, 2 + x.length), x = parseInt(x);
                    var N = c(v, 0, x);
                    if (k)
                        try {
                            N = String.fromCharCode.apply(null, new Uint8Array(N));
                        }
                        catch (B) {
                            var S = new Uint8Array(N);
                            for (N = "", M = 0; M < S.length; M++)
                                N += String.fromCharCode(S[M]);
                        }
                    R.push(N), v = c(v, x);
                } var T = R.length; R.forEach(function (B, P) { I(m.decodePacket(B, b, !0), P, T); }); };
            }, function (E, m, f) {
                "use strict";
                m.TextEncoder = TextEncoder, m.TextDecoder = TextDecoder;
            }, function (E, m, f) {
                "use strict";
                const d = Object.freeze({ identity: 0, cidv1: 1, cidv2: 2, cidv3: 3, ip4: 4, tcp: 6, sha1: 17, "sha2-256": 18, "sha2-512": 19, "sha3-512": 20, "sha3-384": 21, "sha3-256": 22, "sha3-224": 23, "shake-128": 24, "shake-256": 25, "keccak-224": 26, "keccak-256": 27, "keccak-384": 28, "keccak-512": 29, blake3: 30, dccp: 33, "murmur3-128": 34, "murmur3-32": 35, ip6: 41, ip6zone: 42, path: 47, multicodec: 48, multihash: 49, multiaddr: 50, multibase: 51, dns: 53, dns4: 54, dns6: 55, dnsaddr: 56, protobuf: 80, cbor: 81, raw: 85, "dbl-sha2-256": 86, rlp: 96, bencode: 99, "dag-pb": 112, "dag-cbor": 113, "libp2p-key": 114, "git-raw": 120, "torrent-info": 123, "torrent-file": 124, "leofcoin-block": 129, "leofcoin-tx": 130, "leofcoin-pr": 131, sctp: 132, "dag-jose": 133, "dag-cose": 134, "eth-block": 144, "eth-block-list": 145, "eth-tx-trie": 146, "eth-tx": 147, "eth-tx-receipt-trie": 148, "eth-tx-receipt": 149, "eth-state-trie": 150, "eth-account-snapshot": 151, "eth-storage-trie": 152, "bitcoin-block": 176, "bitcoin-tx": 177, "bitcoin-witness-commitment": 178, "zcash-block": 192, "zcash-tx": 193, docid: 206, "stellar-block": 208, "stellar-tx": 209, md4: 212, md5: 213, bmt: 214, "decred-block": 224, "decred-tx": 225, "ipld-ns": 226, "ipfs-ns": 227, "swarm-ns": 228, "ipns-ns": 229, zeronet: 230, "secp256k1-pub": 231, "bls12_381-g1-pub": 234, "bls12_381-g2-pub": 235, "x25519-pub": 236, "ed25519-pub": 237, "bls12_381-g1g2-pub": 238, "dash-block": 240, "dash-tx": 241, "swarm-manifest": 250, "swarm-feed": 251, udp: 273, "p2p-webrtc-star": 275, "p2p-webrtc-direct": 276, "p2p-stardust": 277, "p2p-circuit": 290, "dag-json": 297, udt: 301, utp: 302, unix: 400, p2p: 421, ipfs: 421, https: 443, onion: 444, onion3: 445, garlic64: 446, garlic32: 447, tls: 448, quic: 460, ws: 477, wss: 478, "p2p-websocket-star": 479, http: 480, json: 512, messagepack: 513, "libp2p-peer-record": 769, "sha2-256-trunc254-padded": 4114, "ripemd-128": 4178, "ripemd-160": 4179, "ripemd-256": 4180, "ripemd-320": 4181, x11: 4352, "p256-pub": 4608, "p384-pub": 4609, "p521-pub": 4610, "ed448-pub": 4611, "x448-pub": 4612, "ed25519-priv": 4864, kangarootwelve: 7425, "sm3-256": 21325, "blake2b-8": 45569, "blake2b-16": 45570, "blake2b-24": 45571, "blake2b-32": 45572, "blake2b-40": 45573, "blake2b-48": 45574, "blake2b-56": 45575, "blake2b-64": 45576, "blake2b-72": 45577, "blake2b-80": 45578, "blake2b-88": 45579, "blake2b-96": 45580, "blake2b-104": 45581, "blake2b-112": 45582, "blake2b-120": 45583, "blake2b-128": 45584, "blake2b-136": 45585, "blake2b-144": 45586, "blake2b-152": 45587, "blake2b-160": 45588, "blake2b-168": 45589, "blake2b-176": 45590, "blake2b-184": 45591, "blake2b-192": 45592, "blake2b-200": 45593, "blake2b-208": 45594, "blake2b-216": 45595, "blake2b-224": 45596, "blake2b-232": 45597, "blake2b-240": 45598, "blake2b-248": 45599, "blake2b-256": 45600, "blake2b-264": 45601, "blake2b-272": 45602, "blake2b-280": 45603, "blake2b-288": 45604, "blake2b-296": 45605, "blake2b-304": 45606, "blake2b-312": 45607, "blake2b-320": 45608, "blake2b-328": 45609, "blake2b-336": 45610, "blake2b-344": 45611, "blake2b-352": 45612, "blake2b-360": 45613, "blake2b-368": 45614, "blake2b-376": 45615, "blake2b-384": 45616, "blake2b-392": 45617, "blake2b-400": 45618, "blake2b-408": 45619, "blake2b-416": 45620, "blake2b-424": 45621, "blake2b-432": 45622, "blake2b-440": 45623, "blake2b-448": 45624, "blake2b-456": 45625, "blake2b-464": 45626, "blake2b-472": 45627, "blake2b-480": 45628, "blake2b-488": 45629, "blake2b-496": 45630, "blake2b-504": 45631, "blake2b-512": 45632, "blake2s-8": 45633, "blake2s-16": 45634, "blake2s-24": 45635, "blake2s-32": 45636, "blake2s-40": 45637, "blake2s-48": 45638, "blake2s-56": 45639, "blake2s-64": 45640, "blake2s-72": 45641, "blake2s-80": 45642, "blake2s-88": 45643, "blake2s-96": 45644, "blake2s-104": 45645, "blake2s-112": 45646, "blake2s-120": 45647, "blake2s-128": 45648, "blake2s-136": 45649, "blake2s-144": 45650, "blake2s-152": 45651, "blake2s-160": 45652, "blake2s-168": 45653, "blake2s-176": 45654, "blake2s-184": 45655, "blake2s-192": 45656, "blake2s-200": 45657, "blake2s-208": 45658, "blake2s-216": 45659, "blake2s-224": 45660, "blake2s-232": 45661, "blake2s-240": 45662, "blake2s-248": 45663, "blake2s-256": 45664, "skein256-8": 45825, "skein256-16": 45826, "skein256-24": 45827, "skein256-32": 45828, "skein256-40": 45829, "skein256-48": 45830, "skein256-56": 45831, "skein256-64": 45832, "skein256-72": 45833, "skein256-80": 45834, "skein256-88": 45835, "skein256-96": 45836, "skein256-104": 45837, "skein256-112": 45838, "skein256-120": 45839, "skein256-128": 45840, "skein256-136": 45841, "skein256-144": 45842, "skein256-152": 45843, "skein256-160": 45844, "skein256-168": 45845, "skein256-176": 45846, "skein256-184": 45847, "skein256-192": 45848, "skein256-200": 45849, "skein256-208": 45850, "skein256-216": 45851, "skein256-224": 45852, "skein256-232": 45853, "skein256-240": 45854, "skein256-248": 45855, "skein256-256": 45856, "skein512-8": 45857, "skein512-16": 45858, "skein512-24": 45859, "skein512-32": 45860, "skein512-40": 45861, "skein512-48": 45862, "skein512-56": 45863, "skein512-64": 45864, "skein512-72": 45865, "skein512-80": 45866, "skein512-88": 45867, "skein512-96": 45868, "skein512-104": 45869, "skein512-112": 45870, "skein512-120": 45871, "skein512-128": 45872, "skein512-136": 45873, "skein512-144": 45874, "skein512-152": 45875, "skein512-160": 45876, "skein512-168": 45877, "skein512-176": 45878, "skein512-184": 45879, "skein512-192": 45880, "skein512-200": 45881, "skein512-208": 45882, "skein512-216": 45883, "skein512-224": 45884, "skein512-232": 45885, "skein512-240": 45886, "skein512-248": 45887, "skein512-256": 45888, "skein512-264": 45889, "skein512-272": 45890, "skein512-280": 45891, "skein512-288": 45892, "skein512-296": 45893, "skein512-304": 45894, "skein512-312": 45895, "skein512-320": 45896, "skein512-328": 45897, "skein512-336": 45898, "skein512-344": 45899, "skein512-352": 45900, "skein512-360": 45901, "skein512-368": 45902, "skein512-376": 45903, "skein512-384": 45904, "skein512-392": 45905, "skein512-400": 45906, "skein512-408": 45907, "skein512-416": 45908, "skein512-424": 45909, "skein512-432": 45910, "skein512-440": 45911, "skein512-448": 45912, "skein512-456": 45913, "skein512-464": 45914, "skein512-472": 45915, "skein512-480": 45916, "skein512-488": 45917, "skein512-496": 45918, "skein512-504": 45919, "skein512-512": 45920, "skein1024-8": 45921, "skein1024-16": 45922, "skein1024-24": 45923, "skein1024-32": 45924, "skein1024-40": 45925, "skein1024-48": 45926, "skein1024-56": 45927, "skein1024-64": 45928, "skein1024-72": 45929, "skein1024-80": 45930, "skein1024-88": 45931, "skein1024-96": 45932, "skein1024-104": 45933, "skein1024-112": 45934, "skein1024-120": 45935, "skein1024-128": 45936, "skein1024-136": 45937, "skein1024-144": 45938, "skein1024-152": 45939, "skein1024-160": 45940, "skein1024-168": 45941, "skein1024-176": 45942, "skein1024-184": 45943, "skein1024-192": 45944, "skein1024-200": 45945, "skein1024-208": 45946, "skein1024-216": 45947, "skein1024-224": 45948, "skein1024-232": 45949, "skein1024-240": 45950, "skein1024-248": 45951, "skein1024-256": 45952, "skein1024-264": 45953, "skein1024-272": 45954, "skein1024-280": 45955, "skein1024-288": 45956, "skein1024-296": 45957, "skein1024-304": 45958, "skein1024-312": 45959, "skein1024-320": 45960, "skein1024-328": 45961, "skein1024-336": 45962, "skein1024-344": 45963, "skein1024-352": 45964, "skein1024-360": 45965, "skein1024-368": 45966, "skein1024-376": 45967, "skein1024-384": 45968, "skein1024-392": 45969, "skein1024-400": 45970, "skein1024-408": 45971, "skein1024-416": 45972, "skein1024-424": 45973, "skein1024-432": 45974, "skein1024-440": 45975, "skein1024-448": 45976, "skein1024-456": 45977, "skein1024-464": 45978, "skein1024-472": 45979, "skein1024-480": 45980, "skein1024-488": 45981, "skein1024-496": 45982, "skein1024-504": 45983, "skein1024-512": 45984, "skein1024-520": 45985, "skein1024-528": 45986, "skein1024-536": 45987, "skein1024-544": 45988, "skein1024-552": 45989, "skein1024-560": 45990, "skein1024-568": 45991, "skein1024-576": 45992, "skein1024-584": 45993, "skein1024-592": 45994, "skein1024-600": 45995, "skein1024-608": 45996, "skein1024-616": 45997, "skein1024-624": 45998, "skein1024-632": 45999, "skein1024-640": 46e3, "skein1024-648": 46001, "skein1024-656": 46002, "skein1024-664": 46003, "skein1024-672": 46004, "skein1024-680": 46005, "skein1024-688": 46006, "skein1024-696": 46007, "skein1024-704": 46008, "skein1024-712": 46009, "skein1024-720": 46010, "skein1024-728": 46011, "skein1024-736": 46012, "skein1024-744": 46013, "skein1024-752": 46014, "skein1024-760": 46015, "skein1024-768": 46016, "skein1024-776": 46017, "skein1024-784": 46018, "skein1024-792": 46019, "skein1024-800": 46020, "skein1024-808": 46021, "skein1024-816": 46022, "skein1024-824": 46023, "skein1024-832": 46024, "skein1024-840": 46025, "skein1024-848": 46026, "skein1024-856": 46027, "skein1024-864": 46028, "skein1024-872": 46029, "skein1024-880": 46030, "skein1024-888": 46031, "skein1024-896": 46032, "skein1024-904": 46033, "skein1024-912": 46034, "skein1024-920": 46035, "skein1024-928": 46036, "skein1024-936": 46037, "skein1024-944": 46038, "skein1024-952": 46039, "skein1024-960": 46040, "skein1024-968": 46041, "skein1024-976": 46042, "skein1024-984": 46043, "skein1024-992": 46044, "skein1024-1000": 46045, "skein1024-1008": 46046, "skein1024-1016": 46047, "skein1024-1024": 46048, "poseidon-bls12_381-a2-fc1": 46081, "poseidon-bls12_381-a2-fc1-sc": 46082, "zeroxcert-imprint-256": 52753, "fil-commitment-unsealed": 61697, "fil-commitment-sealed": 61698, "holochain-adr-v0": 8417572, "holochain-adr-v1": 8483108, "holochain-key-v0": 9728292, "holochain-key-v1": 9793828, "holochain-sig-v0": 10645796, "holochain-sig-v1": 10711332, "skynet-ns": 11639056 });
                E.exports = { baseTable: d };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                d.pki = d.pki || {};
                var r = E.exports = d.pki.oids = d.oids = d.oids || {};
                function e(n, t) { r[n] = t, r[t] = n; }
                function c(n, t) { r[n] = t; }
                e("1.2.840.113549.1.1.1", "rsaEncryption"), e("1.2.840.113549.1.1.4", "md5WithRSAEncryption"), e("1.2.840.113549.1.1.5", "sha1WithRSAEncryption"), e("1.2.840.113549.1.1.7", "RSAES-OAEP"), e("1.2.840.113549.1.1.8", "mgf1"), e("1.2.840.113549.1.1.9", "pSpecified"), e("1.2.840.113549.1.1.10", "RSASSA-PSS"), e("1.2.840.113549.1.1.11", "sha256WithRSAEncryption"), e("1.2.840.113549.1.1.12", "sha384WithRSAEncryption"), e("1.2.840.113549.1.1.13", "sha512WithRSAEncryption"), e("1.3.101.112", "EdDSA25519"), e("1.2.840.10040.4.3", "dsa-with-sha1"), e("1.3.14.3.2.7", "desCBC"), e("1.3.14.3.2.26", "sha1"), e("2.16.840.1.101.3.4.2.1", "sha256"), e("2.16.840.1.101.3.4.2.2", "sha384"), e("2.16.840.1.101.3.4.2.3", "sha512"), e("1.2.840.113549.2.5", "md5"), e("1.2.840.113549.1.7.1", "data"), e("1.2.840.113549.1.7.2", "signedData"), e("1.2.840.113549.1.7.3", "envelopedData"), e("1.2.840.113549.1.7.4", "signedAndEnvelopedData"), e("1.2.840.113549.1.7.5", "digestedData"), e("1.2.840.113549.1.7.6", "encryptedData"), e("1.2.840.113549.1.9.1", "emailAddress"), e("1.2.840.113549.1.9.2", "unstructuredName"), e("1.2.840.113549.1.9.3", "contentType"), e("1.2.840.113549.1.9.4", "messageDigest"), e("1.2.840.113549.1.9.5", "signingTime"), e("1.2.840.113549.1.9.6", "counterSignature"), e("1.2.840.113549.1.9.7", "challengePassword"), e("1.2.840.113549.1.9.8", "unstructuredAddress"), e("1.2.840.113549.1.9.14", "extensionRequest"), e("1.2.840.113549.1.9.20", "friendlyName"), e("1.2.840.113549.1.9.21", "localKeyId"), e("1.2.840.113549.1.9.22.1", "x509Certificate"), e("1.2.840.113549.1.12.10.1.1", "keyBag"), e("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag"), e("1.2.840.113549.1.12.10.1.3", "certBag"), e("1.2.840.113549.1.12.10.1.4", "crlBag"), e("1.2.840.113549.1.12.10.1.5", "secretBag"), e("1.2.840.113549.1.12.10.1.6", "safeContentsBag"), e("1.2.840.113549.1.5.13", "pkcs5PBES2"), e("1.2.840.113549.1.5.12", "pkcs5PBKDF2"), e("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4"), e("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4"), e("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC"), e("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC"), e("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC"), e("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC"), e("1.2.840.113549.2.7", "hmacWithSHA1"), e("1.2.840.113549.2.8", "hmacWithSHA224"), e("1.2.840.113549.2.9", "hmacWithSHA256"), e("1.2.840.113549.2.10", "hmacWithSHA384"), e("1.2.840.113549.2.11", "hmacWithSHA512"), e("1.2.840.113549.3.7", "des-EDE3-CBC"), e("2.16.840.1.101.3.4.1.2", "aes128-CBC"), e("2.16.840.1.101.3.4.1.22", "aes192-CBC"), e("2.16.840.1.101.3.4.1.42", "aes256-CBC"), e("2.5.4.3", "commonName"), e("2.5.4.5", "serialName"), e("2.5.4.6", "countryName"), e("2.5.4.7", "localityName"), e("2.5.4.8", "stateOrProvinceName"), e("2.5.4.9", "streetAddress"), e("2.5.4.10", "organizationName"), e("2.5.4.11", "organizationalUnitName"), e("2.5.4.13", "description"), e("2.5.4.15", "businessCategory"), e("2.5.4.17", "postalCode"), e("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName"), e("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName"), e("2.16.840.1.113730.1.1", "nsCertType"), e("2.16.840.1.113730.1.13", "nsComment"), c("2.5.29.1", "authorityKeyIdentifier"), c("2.5.29.2", "keyAttributes"), c("2.5.29.3", "certificatePolicies"), c("2.5.29.4", "keyUsageRestriction"), c("2.5.29.5", "policyMapping"), c("2.5.29.6", "subtreesConstraint"), c("2.5.29.7", "subjectAltName"), c("2.5.29.8", "issuerAltName"), c("2.5.29.9", "subjectDirectoryAttributes"), c("2.5.29.10", "basicConstraints"), c("2.5.29.11", "nameConstraints"), c("2.5.29.12", "policyConstraints"), c("2.5.29.13", "basicConstraints"), e("2.5.29.14", "subjectKeyIdentifier"), e("2.5.29.15", "keyUsage"), c("2.5.29.16", "privateKeyUsagePeriod"), e("2.5.29.17", "subjectAltName"), e("2.5.29.18", "issuerAltName"), e("2.5.29.19", "basicConstraints"), c("2.5.29.20", "cRLNumber"), c("2.5.29.21", "cRLReason"), c("2.5.29.22", "expirationDate"), c("2.5.29.23", "instructionCode"), c("2.5.29.24", "invalidityDate"), c("2.5.29.25", "cRLDistributionPoints"), c("2.5.29.26", "issuingDistributionPoint"), c("2.5.29.27", "deltaCRLIndicator"), c("2.5.29.28", "issuingDistributionPoint"), c("2.5.29.29", "certificateIssuer"), c("2.5.29.30", "nameConstraints"), e("2.5.29.31", "cRLDistributionPoints"), e("2.5.29.32", "certificatePolicies"), c("2.5.29.33", "policyMappings"), c("2.5.29.34", "policyConstraints"), e("2.5.29.35", "authorityKeyIdentifier"), c("2.5.29.36", "policyConstraints"), e("2.5.29.37", "extKeyUsage"), c("2.5.29.46", "freshestCRL"), c("2.5.29.54", "inhibitAnyPolicy"), e("1.3.6.1.4.1.11129.2.4.2", "timestampList"), e("1.3.6.1.5.5.7.1.1", "authorityInfoAccess"), e("1.3.6.1.5.5.7.3.1", "serverAuth"), e("1.3.6.1.5.5.7.3.2", "clientAuth"), e("1.3.6.1.5.5.7.3.3", "codeSigning"), e("1.3.6.1.5.5.7.3.4", "emailProtection"), e("1.3.6.1.5.5.7.3.8", "timeStamping");
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                function r(l, p) { d.cipher.registerAlgorithm(l, function () { return new d.aes.Algorithm(l, p); }); }
                f(228), f(229), f(14), E.exports = d.aes = d.aes || {}, d.aes.startEncrypting = function (l, p, g, b) { var I = a({ key: l, output: g, decrypt: !1, mode: b }); return I.start(p), I; }, d.aes.createEncryptionCipher = function (l, p) { return a({ key: l, output: null, decrypt: !1, mode: p }); }, d.aes.startDecrypting = function (l, p, g, b) { var I = a({ key: l, output: g, decrypt: !0, mode: b }); return I.start(p), I; }, d.aes.createDecryptionCipher = function (l, p) { return a({ key: l, output: null, decrypt: !0, mode: p }); }, d.aes.Algorithm = function (l, p) { u || i(); var g = this; g.name = l, g.mode = new p({ blockSize: 16, cipher: { encrypt: function (b, I) { return h(g._w, b, I, !1); }, decrypt: function (b, I) { return h(g._w, b, I, !0); } } }), g._init = !1; }, d.aes.Algorithm.prototype.initialize = function (l) { if (!this._init) {
                    var p, g = l.key;
                    if (typeof g != "string" || g.length !== 16 && g.length !== 24 && g.length !== 32) {
                        if (d.util.isArray(g) && (g.length === 16 || g.length === 24 || g.length === 32)) {
                            p = g, g = d.util.createBuffer();
                            for (var b = 0; b < p.length; ++b)
                                g.putByte(p[b]);
                        }
                    }
                    else
                        g = d.util.createBuffer(g);
                    if (!d.util.isArray(g)) {
                        p = g, g = [];
                        var I = p.length();
                        if (I === 16 || I === 24 || I === 32)
                            for (I >>>= 2, b = 0; b < I; ++b)
                                g.push(p.getInt32());
                    }
                    if (!d.util.isArray(g) || g.length !== 4 && g.length !== 6 && g.length !== 8)
                        throw new Error("Invalid key parameter.");
                    var v = this.mode.name, R = ["CFB", "OFB", "CTR", "GCM"].indexOf(v) !== -1;
                    this._w = o(g, l.decrypt && !R), this._init = !0;
                } }, d.aes._expandKey = function (l, p) { return u || i(), o(l, p); }, d.aes._updateBlock = h, r("AES-ECB", d.cipher.modes.ecb), r("AES-CBC", d.cipher.modes.cbc), r("AES-CFB", d.cipher.modes.cfb), r("AES-OFB", d.cipher.modes.ofb), r("AES-CTR", d.cipher.modes.ctr), r("AES-GCM", d.cipher.modes.gcm);
                var e, c, n, t, s, u = !1;
                function i() { u = !0, n = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54]; for (var l = new Array(256), p = 0; p < 128; ++p)
                    l[p] = p << 1, l[p + 128] = p + 128 << 1 ^ 283; for (e = new Array(256), c = new Array(256), t = new Array(4), s = new Array(4), p = 0; p < 4; ++p)
                    t[p] = new Array(256), s[p] = new Array(256); var g, b, I, v, R, _, k, x = 0, M = 0; for (p = 0; p < 256; ++p) {
                    v = (v = M ^ M << 1 ^ M << 2 ^ M << 3 ^ M << 4) >> 8 ^ 255 & v ^ 99, e[x] = v, c[v] = x, _ = (R = l[v]) << 24 ^ v << 16 ^ v << 8 ^ v ^ R, k = ((g = l[x]) ^ (b = l[g]) ^ (I = l[b])) << 24 ^ (x ^ I) << 16 ^ (x ^ b ^ I) << 8 ^ x ^ g ^ I;
                    for (var N = 0; N < 4; ++N)
                        t[N][x] = _, s[N][v] = k, _ = _ << 24 | _ >>> 8, k = k << 24 | k >>> 8;
                    x === 0 ? x = M = 1 : (x = g ^ l[l[l[g ^ I]]], M ^= l[l[M]]);
                } }
                function o(l, p) { for (var g, b = l.slice(0), I = 1, v = b.length, R = 4 * (v + 6 + 1), _ = v; _ < R; ++_)
                    g = b[_ - 1], _ % v == 0 ? (g = e[g >>> 16 & 255] << 24 ^ e[g >>> 8 & 255] << 16 ^ e[255 & g] << 8 ^ e[g >>> 24] ^ n[I] << 24, I++) : v > 6 && _ % v == 4 && (g = e[g >>> 24] << 24 ^ e[g >>> 16 & 255] << 16 ^ e[g >>> 8 & 255] << 8 ^ e[255 & g]), b[_] = b[_ - v] ^ g; if (p) {
                    for (var k, x = s[0], M = s[1], N = s[2], S = s[3], T = b.slice(0), B = (_ = 0, (R = b.length) - 4); _ < R; _ += 4, B -= 4)
                        if (_ === 0 || _ === R - 4)
                            T[_] = b[B], T[_ + 1] = b[B + 3], T[_ + 2] = b[B + 2], T[_ + 3] = b[B + 1];
                        else
                            for (var P = 0; P < 4; ++P)
                                k = b[B + P], T[_ + (3 & -P)] = x[e[k >>> 24]] ^ M[e[k >>> 16 & 255]] ^ N[e[k >>> 8 & 255]] ^ S[e[255 & k]];
                    b = T;
                } return b; }
                function h(l, p, g, b) { var I, v, R, _, k, x, M, N, S, T, B, P, L = l.length / 4 - 1; b ? (I = s[0], v = s[1], R = s[2], _ = s[3], k = c) : (I = t[0], v = t[1], R = t[2], _ = t[3], k = e), x = p[0] ^ l[0], M = p[b ? 3 : 1] ^ l[1], N = p[2] ^ l[2], S = p[b ? 1 : 3] ^ l[3]; for (var j = 3, D = 1; D < L; ++D)
                    T = I[x >>> 24] ^ v[M >>> 16 & 255] ^ R[N >>> 8 & 255] ^ _[255 & S] ^ l[++j], B = I[M >>> 24] ^ v[N >>> 16 & 255] ^ R[S >>> 8 & 255] ^ _[255 & x] ^ l[++j], P = I[N >>> 24] ^ v[S >>> 16 & 255] ^ R[x >>> 8 & 255] ^ _[255 & M] ^ l[++j], S = I[S >>> 24] ^ v[x >>> 16 & 255] ^ R[M >>> 8 & 255] ^ _[255 & N] ^ l[++j], x = T, M = B, N = P; g[0] = k[x >>> 24] << 24 ^ k[M >>> 16 & 255] << 16 ^ k[N >>> 8 & 255] << 8 ^ k[255 & S] ^ l[++j], g[b ? 3 : 1] = k[M >>> 24] << 24 ^ k[N >>> 16 & 255] << 16 ^ k[S >>> 8 & 255] << 8 ^ k[255 & x] ^ l[++j], g[2] = k[N >>> 24] << 24 ^ k[S >>> 16 & 255] << 16 ^ k[x >>> 8 & 255] << 8 ^ k[255 & M] ^ l[++j], g[b ? 1 : 3] = k[S >>> 24] << 24 ^ k[x >>> 16 & 255] << 16 ^ k[M >>> 8 & 255] << 8 ^ k[255 & N] ^ l[++j]; }
                function a(l) { var p, g = "AES-" + ((l = l || {}).mode || "CBC").toUpperCase(), b = (p = l.decrypt ? d.cipher.createDecipher(g, l.key) : d.cipher.createCipher(g, l.key)).start; return p.start = function (I, v) { var R = null; v instanceof d.util.ByteBuffer && (R = v, v = {}), (v = v || {}).output = R, v.iv = I, b.call(p, v); }, p; }
            }, function (E, m, f) {
                "use strict";
                const d = f(48), r = self.crypto || self.msCrypto, e = async (c, n) => { if (typeof self == "undefined" || !self.crypto && !self.msCrypto)
                    throw new Error("Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context"); switch (n) {
                    case "sha1": return new Uint8Array(await r.subtle.digest({ name: "SHA-1" }, c));
                    case "sha2-256": return new Uint8Array(await r.subtle.digest({ name: "SHA-256" }, c));
                    case "sha2-512": return new Uint8Array(await r.subtle.digest({ name: "SHA-512" }, c));
                    case "dbl-sha2-256": {
                        const t = await r.subtle.digest({ name: "SHA-256" }, c);
                        return new Uint8Array(await r.subtle.digest({ name: "SHA-256" }, t));
                    }
                    default: throw new Error(n + " is not a supported algorithm");
                } };
                E.exports = { factory: c => async (n) => e(n, c), digest: e, multihashing: async (c, n, t) => { const s = await e(c, n); return d.encode(s, n, t); } };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(51);
                function e() { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32; }
                m.BlockHash = e, e.prototype.update = function (c, n) { if (c = d.toArray(c, n), this.pending ? this.pending = this.pending.concat(c) : this.pending = c, this.pendingTotal += c.length, this.pending.length >= this._delta8) {
                    var t = (c = this.pending).length % this._delta8;
                    this.pending = c.slice(c.length - t, c.length), this.pending.length === 0 && (this.pending = null), c = d.join32(c, 0, c.length - t, this.endian);
                    for (var s = 0; s < c.length; s += this._delta32)
                        this._update(c, s, s + this._delta32);
                } return this; }, e.prototype.digest = function (c) { return this.update(this._pad()), r(this.pending === null), this._digest(c); }, e.prototype._pad = function () { var c = this.pendingTotal, n = this._delta8, t = n - (c + this.padLength) % n, s = new Array(t + this.padLength); s[0] = 128; for (var u = 1; u < t; u++)
                    s[u] = 0; if (c <<= 3, this.endian === "big") {
                    for (var i = 8; i < this.padLength; i++)
                        s[u++] = 0;
                    s[u++] = 0, s[u++] = 0, s[u++] = 0, s[u++] = 0, s[u++] = c >>> 24 & 255, s[u++] = c >>> 16 & 255, s[u++] = c >>> 8 & 255, s[u++] = 255 & c;
                }
                else
                    for (s[u++] = 255 & c, s[u++] = c >>> 8 & 255, s[u++] = c >>> 16 & 255, s[u++] = c >>> 24 & 255, s[u++] = 0, s[u++] = 0, s[u++] = 0, s[u++] = 0, i = 8; i < this.padLength; i++)
                        s[u++] = 0; return s; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 });
                const d = f(540), r = f(62), e = f(542), c = () => { }, n = new r.TimeoutError;
                m.default = class extends d {
                    constructor(t) { var s, u, i, o; if (super(), this._intervalCount = 0, this._intervalEnd = 0, this._pendingCount = 0, this._resolveEmpty = c, this._resolveIdle = c, !(typeof (t = Object.assign({ carryoverConcurrencyCount: !1, intervalCap: 1 / 0, interval: 0, concurrency: 1 / 0, autoStart: !0, queueClass: e.default }, t)).intervalCap == "number" && t.intervalCap >= 1))
                        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(u = (s = t.intervalCap) === null || s === void 0 ? void 0 : s.toString()) !== null && u !== void 0 ? u : ""}\` (${typeof t.intervalCap})`); if (t.interval === void 0 || !(Number.isFinite(t.interval) && t.interval >= 0))
                        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(o = (i = t.interval) === null || i === void 0 ? void 0 : i.toString()) !== null && o !== void 0 ? o : ""}\` (${typeof t.interval})`); this._carryoverConcurrencyCount = t.carryoverConcurrencyCount, this._isIntervalIgnored = t.intervalCap === 1 / 0 || t.interval === 0, this._intervalCap = t.intervalCap, this._interval = t.interval, this._queue = new t.queueClass, this._queueClass = t.queueClass, this.concurrency = t.concurrency, this._timeout = t.timeout, this._throwOnTimeout = t.throwOnTimeout === !0, this._isPaused = t.autoStart === !1; }
                    get _doesIntervalAllowAnother() { return this._isIntervalIgnored || this._intervalCount < this._intervalCap; }
                    get _doesConcurrentAllowAnother() { return this._pendingCount < this._concurrency; }
                    _next() { this._pendingCount--, this._tryToStartAnother(), this.emit("next"); }
                    _resolvePromises() { this._resolveEmpty(), this._resolveEmpty = c, this._pendingCount === 0 && (this._resolveIdle(), this._resolveIdle = c, this.emit("idle")); }
                    _onResumeInterval() { this._onInterval(), this._initializeIntervalIfNeeded(), this._timeoutId = void 0; }
                    _isIntervalPaused() { const t = Date.now(); if (this._intervalId === void 0) {
                        const s = this._intervalEnd - t;
                        if (!(s < 0))
                            return this._timeoutId === void 0 && (this._timeoutId = setTimeout(() => { this._onResumeInterval(); }, s)), !0;
                        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
                    } return !1; }
                    _tryToStartAnother() { if (this._queue.size === 0)
                        return this._intervalId && clearInterval(this._intervalId), this._intervalId = void 0, this._resolvePromises(), !1; if (!this._isPaused) {
                        const t = !this._isIntervalPaused();
                        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                            const s = this._queue.dequeue();
                            return !!s && (this.emit("active"), s(), t && this._initializeIntervalIfNeeded(), !0);
                        }
                    } return !1; }
                    _initializeIntervalIfNeeded() { this._isIntervalIgnored || this._intervalId !== void 0 || (this._intervalId = setInterval(() => { this._onInterval(); }, this._interval), this._intervalEnd = Date.now() + this._interval); }
                    _onInterval() { this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId && (clearInterval(this._intervalId), this._intervalId = void 0), this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0, this._processQueue(); }
                    _processQueue() { for (; this._tryToStartAnother();)
                        ; }
                    get concurrency() { return this._concurrency; }
                    set concurrency(t) { if (!(typeof t == "number" && t >= 1))
                        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${t}\` (${typeof t})`); this._concurrency = t, this._processQueue(); }
                    async add(t, s = {}) { return new Promise((u, i) => { this._queue.enqueue(async () => { this._pendingCount++, this._intervalCount++; try {
                        const o = this._timeout === void 0 && s.timeout === void 0 ? t() : r.default(Promise.resolve(t()), s.timeout === void 0 ? this._timeout : s.timeout, () => { (s.throwOnTimeout === void 0 ? this._throwOnTimeout : s.throwOnTimeout) && i(n); });
                        u(await o);
                    }
                    catch (o) {
                        i(o);
                    } this._next(); }, s), this._tryToStartAnother(), this.emit("add"); }); }
                    async addAll(t, s) { return Promise.all(t.map(async (u) => this.add(u, s))); }
                    start() { return this._isPaused ? (this._isPaused = !1, this._processQueue(), this) : this; }
                    pause() { this._isPaused = !0; }
                    clear() { this._queue = new this._queueClass; }
                    async onEmpty() { if (this._queue.size !== 0)
                        return new Promise(t => { const s = this._resolveEmpty; this._resolveEmpty = () => { s(), t(); }; }); }
                    async onIdle() { if (this._pendingCount !== 0 || this._queue.size !== 0)
                        return new Promise(t => { const s = this._resolveIdle; this._resolveIdle = () => { s(), t(); }; }); }
                    get size() { return this._queue.size; }
                    sizeBy(t) { return this._queue.filter(t).length; }
                    get pending() { return this._pendingCount; }
                    get isPaused() { return this._isPaused; }
                    get timeout() { return this._timeout; }
                    set timeout(t) { this._timeout = t; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), e = f(549), c = f(1), n = f(266), t = f(88), s = f(267), u = f(25), i = f(18), o = u.encoding("base32upper");
                function h(g) { return "/" + o.encode(g.multihash); }
                function a(g) { return o.decode(g.toString().slice(1)); }
                const l = { direct: "direct", recursive: "recursive", indirect: "indirect", all: "all" };
                class p {
                    constructor({ repo: b, dagReader: I }) { this.repo = b, this.dag = I, this.log = c("ipfs:pin"), this.directPins = new Set, this.recursivePins = new Set; }
                    async *_walkDag(b, { preload: I = !1 }) { const { value: v } = await this.dag.get(b, { preload: I }); if (b.codec === "dag-pb")
                        for (const R of v.Links)
                            yield R.Hash, yield* this._walkDag(R.Hash, { preload: I });
                    else if (b.codec === "dag-cbor")
                        for (const [, R] of e(v))
                            yield R, yield* this._walkDag(R, { preload: I }); }
                    async pinDirectly(b, I = {}) { await this.dag.get(b, I); const v = { depth: 0 }; return b.version !== 0 && (v.version = b.version), b.codec !== "dag-pb" && (v.codec = i.getNumber(b.codec)), I.metadata && (v.metadata = I.metadata), this.repo.pins.put(h(b), s.encode(v)); }
                    async unpin(b, I) { return this.repo.pins.delete(h(b)); }
                    async pinRecursively(b, I = {}) { await this.fetchCompleteDag(b, I); const v = { depth: 1 / 0 }; b.version !== 0 && (v.version = b.version), b.codec !== "dag-pb" && (v.codec = i.getNumber(b.codec)), I.metadata && (v.metadata = I.metadata), await this.repo.pins.put(h(b), s.encode(v)); }
                    async *directKeys(b) { for await (const I of this.repo.pins.query({ filters: [v => s.decode(v.value).depth === 0] })) {
                        const v = s.decode(I.value), R = v.version || 0, _ = v.codec ? i.getName(v.codec) : "dag-pb", k = a(I.key);
                        yield { cid: new d(R, _, k), metadata: v.metadata };
                    } }
                    async *recursiveKeys(b) { for await (const I of this.repo.pins.query({ filters: [v => s.decode(v.value).depth === 1 / 0] })) {
                        const v = s.decode(I.value), R = v.version || 0, _ = v.codec ? i.getName(v.codec) : "dag-pb", k = a(I.key);
                        yield { cid: new d(R, _, k), metadata: v.metadata };
                    } }
                    async *indirectKeys({ preload: b }) { for await (const { cid: I } of this.recursiveKeys())
                        for await (const v of this._walkDag(I, { preload: b })) {
                            const R = [l.recursive];
                            (await this.isPinnedWithType(v, R)).pinned || (yield v);
                        } }
                    async isPinnedWithType(b, I, v) { Array.isArray(I) || (I = [I]); const R = I.includes(l.all), _ = I.includes(l.direct), k = I.includes(l.recursive), x = I.includes(l.indirect); if (k || _ || R) {
                        const N = await n(this.repo.pins.query({ prefix: h(b), filters: [S => { if (R)
                                    return !0; const T = s.decode(S.value); return I.includes(T.depth === 0 ? l.direct : l.recursive); }], limit: 1 }));
                        if (N) {
                            const S = s.decode(N.value);
                            return { cid: b, pinned: !0, reason: S.depth === 0 ? l.direct : l.recursive, metadata: S.metadata };
                        }
                    } const M = this; if (R || x) {
                        const N = await n(async function* (S, T) { for await (const { cid: B } of T)
                            for await (const P of M._walkDag(B, { preload: !1 }))
                                if (P.equals(S))
                                    return void (yield B); }(b, this.recursiveKeys()));
                        if (N)
                            return { cid: b, pinned: !0, reason: l.indirect, parent: N };
                    } return { cid: b, pinned: !1 }; }
                    async fetchCompleteDag(b, I) { await t(this._walkDag(b, { preload: I.preload })); }
                    static checkPinType(b) { if (typeof b != "string" || !Object.keys(l).includes(b))
                        throw function (I) { return r(new Error(`Invalid type '${I}', must be one of {direct, indirect, recursive, all}`), "ERR_INVALID_PIN_TYPE"); }(b); return !0; }
                }
                p.PinTypes = l, E.exports = p;
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { const r = []; for await (const e of d)
                    r.push(e); return r; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(e) { return Object.prototype.toString.call(e); } m.isArray = function (e) { return Array.isArray ? Array.isArray(e) : r(e) === "[object Array]"; }, m.isBoolean = function (e) { return typeof e == "boolean"; }, m.isNull = function (e) { return e === null; }, m.isNullOrUndefined = function (e) { return e == null; }, m.isNumber = function (e) { return typeof e == "number"; }, m.isString = function (e) { return typeof e == "string"; }, m.isSymbol = function (e) { return typeof e == "symbol"; }, m.isUndefined = function (e) { return e === void 0; }, m.isRegExp = function (e) { return r(e) === "[object RegExp]"; }, m.isObject = function (e) { return typeof e == "object" && e !== null; }, m.isDate = function (e) { return r(e) === "[object Date]"; }, m.isError = function (e) { return r(e) === "[object Error]" || e instanceof Error; }, m.isFunction = function (e) { return typeof e == "function"; }, m.isPrimitive = function (e) { return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || e === void 0; }, m.isBuffer = d.isBuffer; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(64), r = f(54), e = r.MT, c = r.SIMPLE, n = r.SYMS;
                class t {
                    constructor(u) { if (typeof u != "number")
                        throw new Error("Invalid Simple type: " + typeof u); if (u < 0 || u > 255 || (0 | u) !== u)
                        throw new Error("value must be a small positive integer: " + u); this.value = u; }
                    toString() { return "simple(" + this.value + ")"; }
                    [d.inspect.custom](u, i) { return "simple(" + this.value + ")"; }
                    inspect(u, i) { return "simple(" + this.value + ")"; }
                    encodeCBOR(u) { return u._pushInt(this.value, e.SIMPLE_FLOAT); }
                    static isSimple(u) { return u instanceof t; }
                    static decode(u, i = !0, o = !1) { switch (u) {
                        case c.FALSE: return !1;
                        case c.TRUE: return !0;
                        case c.NULL: return i ? null : n.NULL;
                        case c.UNDEFINED: return i ? void 0 : n.UNDEFINED;
                        case -1:
                            if (!i || !o)
                                throw new Error("Invalid BREAK");
                            return n.BREAK;
                        default: return new t(u);
                    } }
                }
                E.exports = t;
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(63), e = f(64); class c extends r.Transform {
                    constructor(u, i, o) { let h, a; switch (o == null && (o = {}), typeof u) {
                        case "object":
                            d.isBuffer(u) ? (h = u, i != null && typeof i == "object" && (o = i)) : o = u;
                            break;
                        case "string": h = u, i != null && typeof i == "object" ? o = i : a = i;
                    } o == null && (o = {}), h == null && (h = o.input), a == null && (a = o.inputEncoding), delete o.input, delete o.inputEncoding; const l = o.watchPipe == null || o.watchPipe; delete o.watchPipe; const p = !!o.readError; delete o.readError, super(o), this.readError = p, l && this.on("pipe", g => { const b = g._readableState.objectMode; if (this.length > 0 && b !== this._readableState.objectMode)
                        throw new Error("Do not switch objectMode in the middle of the stream"); return this._readableState.objectMode = b, this._writableState.objectMode = b; }), h != null && this.end(h, a); }
                    static isNoFilter(u) { return u instanceof this; }
                    static compare(u, i) { if (!(u instanceof this))
                        throw new TypeError("Arguments must be NoFilters"); return u === i ? 0 : u.compare(i); }
                    static concat(u, i) { if (!Array.isArray(u))
                        throw new TypeError("list argument must be an Array of NoFilters"); if (u.length === 0 || i === 0)
                        return d.alloc(0); i == null && (i = u.reduce((l, p) => { if (!(p instanceof c))
                        throw new TypeError("list argument must be an Array of NoFilters"); return l + p.length; }, 0)); let o = !0, h = !0; const a = u.map(l => { if (!(l instanceof c))
                        throw new TypeError("list argument must be an Array of NoFilters"); const p = l.slice(); return d.isBuffer(p) ? h = !1 : o = !1, p; }); if (o)
                        return d.concat(a, i); if (h)
                        return [].concat(...a).slice(0, i); throw new Error("Concatenating mixed object and byte streams not supported"); }
                    _transform(u, i, o) { this._readableState.objectMode || d.isBuffer(u) || (u = d.from(u, i)), this.push(u), o(); }
                    _bufArray() { let u = this._readableState.buffer; if (!Array.isArray(u)) {
                        let i = u.head;
                        for (u = []; i != null;)
                            u.push(i.data), i = i.next;
                    } return u; }
                    read(u) { const i = super.read(u); if (i != null) {
                        if (this.emit("read", i), this.readError && i.length < u)
                            throw new Error(`Read ${i.length}, wanted ${u}`);
                    }
                    else if (this.readError)
                        throw new Error("No data available, wanted " + u); return i; }
                    promise(u) { let i = !1; return new Promise((o, h) => { this.on("finish", () => { const a = this.read(); u == null || i || (i = !0, u(null, a)), o(a); }), this.on("error", a => { u == null || i || (i = !0, u(a)), h(a); }); }); }
                    compare(u) { if (!(u instanceof c))
                        throw new TypeError("Arguments must be NoFilters"); if (this === u)
                        return 0; {
                        const i = this.slice(), o = u.slice();
                        if (d.isBuffer(i) && d.isBuffer(o))
                            return i.compare(o);
                        throw new Error("Cannot compare streams in object mode");
                    } }
                    equals(u) { return this.compare(u) === 0; }
                    slice(u, i) { if (this._readableState.objectMode)
                        return this._bufArray().slice(u, i); const o = this._bufArray(); switch (o.length) {
                        case 0: return d.alloc(0);
                        case 1: return o[0].slice(u, i);
                        default: return d.concat(o).slice(u, i);
                    } }
                    get(u) { return this.slice()[u]; }
                    toJSON() { const u = this.slice(); return d.isBuffer(u) ? u.toJSON() : u; }
                    toString(u, i, o) { const h = this.slice(i, o); return d.isBuffer(h) ? (!u || u === "utf8") && e.TextDecoder ? new e.TextDecoder("utf8", { fatal: !0, ignoreBOM: !0 }).decode(h) : h.toString(u, i, o) : JSON.stringify(h); }
                    inspect(u, i) { return this[e.inspect.custom](u, i); }
                    [e.inspect.custom](u, i) { const o = this._bufArray().map(h => d.isBuffer(h) ? (i != null ? i.stylize : void 0) ? i.stylize(h.toString("hex"), "string") : h.toString("hex") : e.inspect(h, i)).join(", "); return `${this.constructor.name} [${o}]`; }
                    get length() { return this._readableState.length; }
                    writeBigInt(u) { let i = u.toString(16); if (u < 0) {
                        const o = BigInt(Math.floor(i.length / 2));
                        i = (u = (BigInt(1) << o * BigInt(8)) + u).toString(16);
                    } return i.length % 2 && (i = "0" + i), this.push(d.from(i, "hex")); }
                    readUBigInt(u) { const i = this.read(u); return d.isBuffer(i) ? BigInt("0x" + i.toString("hex")) : null; }
                    readBigInt(u) { const i = this.read(u); if (!d.isBuffer(i))
                        return null; let o = BigInt("0x" + i.toString("hex")); return 128 & i[0] && (o -= BigInt(1) << BigInt(i.length) * BigInt(8)), o; }
                } function n(s, u) { return function (i) { const o = this.read(u); return d.isBuffer(o) ? o[s].call(o, 0, !0) : null; }; } function t(s, u) { return function (i) { const o = d.alloc(u); return o[s].call(o, i, 0, !0), this.push(o); }; } Object.assign(c.prototype, { writeUInt8: t("writeUInt8", 1), writeUInt16LE: t("writeUInt16LE", 2), writeUInt16BE: t("writeUInt16BE", 2), writeUInt32LE: t("writeUInt32LE", 4), writeUInt32BE: t("writeUInt32BE", 4), writeInt8: t("writeInt8", 1), writeInt16LE: t("writeInt16LE", 2), writeInt16BE: t("writeInt16BE", 2), writeInt32LE: t("writeInt32LE", 4), writeInt32BE: t("writeInt32BE", 4), writeFloatLE: t("writeFloatLE", 4), writeFloatBE: t("writeFloatBE", 4), writeDoubleLE: t("writeDoubleLE", 8), writeDoubleBE: t("writeDoubleBE", 8), readUInt8: n("readUInt8", 1), readUInt16LE: n("readUInt16LE", 2), readUInt16BE: n("readUInt16BE", 2), readUInt32LE: n("readUInt32LE", 4), readUInt32BE: n("readUInt32BE", 4), readInt8: n("readInt8", 1), readInt16LE: n("readInt16LE", 2), readInt16BE: n("readInt16BE", 2), readInt32LE: n("readInt32LE", 4), readInt32BE: n("readInt32BE", 4), readFloatLE: n("readFloatLE", 4), readFloatBE: n("readFloatBE", 4), readDoubleLE: n("readDoubleLE", 8), readDoubleBE: n("readDoubleBE", 8) }), E.exports = c; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(583), { Key: r } = f(11), e = f(39), c = f(7), n = f(48), t = f(0), s = f(25), u = f(584), i = f(585), o = f(586), h = f(1), a = h("jsipns");
                a.error = h("jsipns:error");
                const l = f(587), { parseRFC3339: p } = f(588), g = f(589), b = n.names.id, I = async (B, P, L, j, D) => { const G = await k(B, P, D, j), W = { value: u(P), signature: G, validityType: D, validity: u(j), sequence: L }; return a(`ipns entry for ${P} created`), W; }, v = async (B, P) => { const { value: L, validityType: j, validity: D } = P, G = x(L, j, D); let W; try {
                    W = await B.verify(G, P.signature);
                }
                catch (X) {
                    W = !1;
                } if (!W)
                    throw a.error("record signature verification failed"), t(new Error("record signature verification failed"), g.ERR_SIGNATURE_VERIFICATION); if (j === l.ValidityType.EOL) {
                    let X;
                    try {
                        X = p(i(D));
                    }
                    catch (Q) {
                        throw a.error("unrecognized validity format (not an rfc3339 format)"), t(new Error("unrecognized validity format (not an rfc3339 format)"), g.ERR_UNRECOGNIZED_FORMAT);
                    }
                    if (X < Date.now())
                        throw a.error("record has expired"), t(new Error("record has expired"), g.ERR_IPNS_EXPIRED_RECORD);
                }
                else if (j)
                    throw a.error("unrecognized validity type"), t(new Error("unrecognized validity type"), g.ERR_UNRECOGNIZED_VALIDITY); a(`ipns entry for ${L} is valid`); }, R = (B, P) => { if (!P || !B) {
                    const L = new Error("one or more of the provided parameters are not defined");
                    throw a.error(L), t(L, g.ERR_UNDEFINED_PARAMETER);
                } if (P.pubKey) {
                    let L;
                    try {
                        L = e.keys.unmarshalPublicKey(P.pubKey);
                    }
                    catch (j) {
                        throw a.error(j), j;
                    }
                    return L;
                } if (B.pubKey)
                    return B.pubKey; throw Object.assign(new Error("no public key is available"), { code: g.ERR_UNDEFINED_PARAMETER }); }, _ = B => s.encode("base32", B).toString().slice(1).toUpperCase(), k = (B, P, L, j) => { try {
                    const D = x(P, L, j);
                    return B.sign(D);
                }
                catch (D) {
                    throw a.error("record signature creation failed"), t(new Error("record signature creation failed: " + D.message), g.ERR_SIGNATURE_CREATION);
                } }, x = (B, P, L) => { B instanceof Uint8Array || (B = u(B)), L instanceof Uint8Array || (L = u(L)); const j = u((D => { if (D.toString() === "0")
                    return "EOL"; const G = new Error("unrecognized validity type " + D.toString()); throw a.error(G), t(G, g.ERR_UNRECOGNIZED_VALIDITY); })(P)); return o([B, L, j]); }, M = B => { const P = n.decode(B.id); return P.code !== b ? null : e.keys.unmarshalPublicKey(P.digest); }, N = l.encode, S = l.decode, T = { validate: async (B, P) => { const L = S(B), j = P.slice("/ipns/".length), D = c.createFromBytes(j), G = R(D, L); return await v(G, L), !0; }, select: (B, P) => { const L = S(B), j = S(P); return L.sequence > j.sequence ? 0 : 1; } };
                E.exports = { create: (B, P, L, j) => { const D = new d(Date.now() + Number(j)).toString(), G = l.ValidityType.EOL; return I(B, P, L, D, G); }, createWithExpiration: (B, P, L, j) => { const D = l.ValidityType.EOL; return I(B, P, L, j, D); }, validate: v, embedPublicKey: async (B, P) => { if (!B || !B.bytes || !P) {
                        const D = new Error("one or more of the provided parameters are not defined");
                        throw a.error(D), t(D, g.ERR_UNDEFINED_PARAMETER);
                    } let L, j; try {
                        L = await c.createFromPubKey(B.bytes);
                    }
                    catch (D) {
                        throw t(D, g.ERR_PEER_ID_FROM_PUBLIC_KEY);
                    } try {
                        j = M(L);
                    }
                    catch (D) {
                        throw a.error(D), t(D, g.ERR_PUBLIC_KEY_FROM_ID);
                    } if (j)
                        return null; try {
                        P.pubKey = e.keys.marshalPublicKey(B);
                    }
                    catch (D) {
                        throw a.error(D), D;
                    } return P; }, extractPublicKey: R, getLocalKey: B => new r("/ipns/" + _(B)), getIdKeys: B => { const P = u("/pk/"), L = u("/ipns/"); return { routingPubKey: new r(o([P, B]), !1), pkKey: new r(_(o([P, B]))), routingKey: new r(o([L, B]), !1), ipnsKey: new r(_(o([L, B]))) }; }, marshal: N, unmarshal: S, validator: T, namespace: "/ipns/", namespaceLength: "/ipns/".length };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), { version: r } = f(635), e = Symbol.for("@ipld/js-ipld-block/block"), c = { writable: !1, configurable: !1, enumerable: !0 };
                class n {
                    constructor(o, h) { if (!(o && o instanceof Uint8Array))
                        throw new Error("first argument  must be a Uint8Array"); if (!h || !d.isCID(h))
                        throw new Error("second argument must be a CID"); this.data = o, this.cid = h, Object.defineProperties(this, { data: c, cid: c }); }
                    get _data() { return u(), this.data; }
                    get _cid() { return s(), this.cid; }
                    get [Symbol.toStringTag]() { return "Block"; }
                    get [e]() { return !0; }
                    static isBlock(o) { return Boolean(o && o[e]); }
                }
                const t = (i, o) => { let h = !1; return () => { if (!i.test(r))
                    throw new Error(o); h || (h = !0, console.warn(o)); }; }, s = t(/^0\.10|^0\.11/, "block._cid is deprecated and will be removed in 0.12 release. Please use block.cid instead"), u = t(/^0\.10|^0.11/, "block._data is deprecated and will be removed in 0.12 release. Please use block.data instead");
                E.exports = n;
            }, function (E, m, f) {
                "use strict";
                const d = f(37), r = f(1)("ipfs:mfs:utils:to-trail");
                E.exports = async (e, c) => { r("Creating trail for path " + c); const n = []; for await (const t of d.path(c, e.ipld))
                    n.push({ name: t.name, cid: t.cid, size: t.node.size, type: t.unixfs ? t.unixfs.type : void 0 }); return n; };
            }, function (E, m, f) {
                "use strict";
                const d = f(17), r = d.DAGNode, e = d.DAGLink, c = f(16).multihash, n = f(18), t = f(2), s = f(5), u = f(6);
                function i(o, h) { switch (h) {
                    case "json": return function (a) { let l, p; try {
                        const g = JSON.parse(s(a));
                        p = (g.Links || []).map(b => new e(b.Name || b.name, b.Size || b.size, c.fromB58String(b.Hash || b.hash || b.multihash))), l = u(g.Data);
                    }
                    catch (g) {
                        throw new Error("failed to parse JSON: " + g);
                    } return new r(l, p); }(o);
                    case "protobuf": return function (a) { return d.util.deserialize(a); }(o);
                    default: throw new Error("unkown encoding: " + h);
                } }
                E.exports = ({ ipld: o, gcLock: h, preload: a }) => t(async function (l, p = {}) { const g = p.enc; let b; if (l instanceof Uint8Array)
                    b = g ? await i(l, g) : new r(l);
                else if (r.isDAGNode(l))
                    b = l;
                else {
                    if (typeof l != "object")
                        throw new Error("obj not recognized");
                    b = new r(l.Data, l.Links);
                } const I = await h.readLock(); try {
                    const v = await o.put(b, n.DAG_PB, { cidVersion: 0, hashAlg: n.SHA2_256 });
                    return p.preload !== !1 && a(v), v;
                }
                finally {
                    I();
                } });
            }, function (E, m, f) {
                "use strict";
                const d = f(302);
                E.exports = r => { let e; typeof (r = r || {}) == "function" ? (e = r, r = {}) : e = r.onEnd; let c, n, t, s = new d; const u = a => n ? n(a) : (s.push(a), c), i = a => t ? c : u({ done: !1, value: a }), o = a => t ? c : (t = !0, a ? (l => (s = new d, n ? n({ error: l }) : (s.push({ error: l }), c)))(a) : u({ done: !0 })); if (c = { [Symbol.asyncIterator]() { return this; }, next: () => { if (!s.isEmpty()) {
                        if (r.writev) {
                            let l;
                            const p = [];
                            for (; !s.isEmpty();) {
                                if (l = s.shift(), l.error)
                                    throw l.error;
                                p.push(l.value);
                            }
                            return { done: l.done, value: p };
                        }
                        const a = s.shift();
                        if (a.error)
                            throw a.error;
                        return a;
                    } return t ? { done: !0 } : new Promise((a, l) => { n = p => (n = null, p.error ? l(p.error) : r.writev && !p.done ? a({ done: p.done, value: [p.value] }) : a(p), c); }); }, return: () => (s = new d, o(), { done: !0 }), throw: a => (o(a), { done: !0 }), push: i, end: o }, !e)
                    return c; const h = c; return c = { [Symbol.asyncIterator]() { return this; }, next: () => h.next(), throw: a => (h.throw(a), e && (e(a), e = null), { done: !0 }), return: () => (h.return(), e && (e(), e = null), { done: !0 }), push: i, end: a => (h.end(a), e && (e(a), e = null), c) }, c; };
            }, function (E, m, f) {
                "use strict";
                const { Key: d, Errors: r, Adapter: e, utils: { filter: c, map: n, take: t, sortAll: s } } = f(11);
                E.exports = class extends e {
                    constructor(u, i) { let o; super(), i && i.db ? (o = i.db, delete i.db) : o = f(758), this.db = this._initDb(o, u, i); }
                    _initDb(u, i, o) { return u(i, { ...o, valueEncoding: "binary", compression: !1 }); }
                    async open() { try {
                        await this.db.open();
                    }
                    catch (u) {
                        throw r.dbOpenFailedError(u);
                    } }
                    async put(u, i) { try {
                        await this.db.put(u.toString(), i);
                    }
                    catch (o) {
                        throw r.dbWriteFailedError(o);
                    } }
                    async get(u) { let i; try {
                        i = await this.db.get(u.toString());
                    }
                    catch (o) {
                        throw o.notFound ? r.notFoundError(o) : r.dbWriteFailedError(o);
                    } return i; }
                    async has(u) { try {
                        await this.db.get(u.toString());
                    }
                    catch (i) {
                        if (i.notFound)
                            return !1;
                        throw i;
                    } return !0; }
                    async delete(u) { try {
                        await this.db.del(u.toString());
                    }
                    catch (i) {
                        throw r.dbDeleteFailedError(i);
                    } }
                    close() { return this.db.close(); }
                    batch() { const u = []; return { put: (i, o) => { u.push({ type: "put", key: i.toString(), value: o }); }, delete: i => { u.push({ type: "del", key: i.toString() }); }, commit: () => this.db.batch(u) }; }
                    query(u) { let i = !0; u.keysOnly != null && (i = !u.keysOnly); const o = { keys: !0, values: i, keyAsBuffer: !0 }; if (u.prefix != null) {
                        const l = u.prefix.toString();
                        o.gte = l, o.lt = l + "\xFF";
                    } let h = (a = this.db.iterator(o), { next: () => new Promise((l, p) => { a.next((g, b, I) => g ? p(g) : b == null ? a.end(v => { if (v)
                            return p(v); l({ done: !0 }); }) : void l({ done: !1, value: { key: b, value: I } })); }), return: () => new Promise((l, p) => { a.end(g => { if (g)
                            return p(g); l({ done: !0 }); }); }), [Symbol.asyncIterator]() { return this; } }); var a; if (h = n(h, ({ key: l, value: p }) => { const g = { key: new d(l, !1) }; return i && (g.value = p), g; }), Array.isArray(u.filters) && (h = u.filters.reduce((l, p) => c(l, p), h)), Array.isArray(u.orders) && (h = u.orders.reduce((l, p) => s(l, p), h)), u.offset != null) {
                        let l = 0;
                        h = c(h, () => l++ >= u.offset);
                    } return u.limit != null && (h = t(h, u.limit)), h; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message CircuitRelay {

  enum Status {
    SUCCESS                    = 100;
    HOP_SRC_ADDR_TOO_LONG      = 220;
    HOP_DST_ADDR_TOO_LONG      = 221;
    HOP_SRC_MULTIADDR_INVALID  = 250;
    HOP_DST_MULTIADDR_INVALID  = 251;
    HOP_NO_CONN_TO_DST         = 260;
    HOP_CANT_DIAL_DST          = 261;
    HOP_CANT_OPEN_DST_STREAM   = 262;
    HOP_CANT_SPEAK_RELAY       = 270;
    HOP_CANT_RELAY_TO_SELF     = 280;
    STOP_SRC_ADDR_TOO_LONG     = 320;
    STOP_DST_ADDR_TOO_LONG     = 321;
    STOP_SRC_MULTIADDR_INVALID = 350;
    STOP_DST_MULTIADDR_INVALID = 351;
    STOP_RELAY_REFUSED         = 390;
    MALFORMED_MESSAGE          = 400;
  }

  enum Type { // RPC identifier, either HOP, STOP or STATUS
    HOP = 1;
    STOP = 2;
    STATUS = 3;
    CAN_HOP = 4;
  }

  message Peer {
    required bytes id = 1;    // peer id
    repeated bytes addrs = 2; // peer's known addresses
  }

  optional Type type = 1;     // Type of the message

  optional Peer srcPeer = 2;  // srcPeer and dstPeer are used when Type is HOP or STATUS
  optional Peer dstPeer = 3;

  optional Status code = 4;   // Status code, used when Type is STATUS
}
`);
            }, function (E, m, f) {
                "use strict";
                const d = f(338), r = f(96), e = f(199);
                E.exports = c => { const n = r(), t = d(c.source), s = e(); let u; const i = c.sink(async function* () { yield* n; const o = await s.promise; yield* o; }()); return i.catch(o => { u = o; }), { reader: t, writer: n, stream: { sink: o => u ? Promise.reject(u) : (s.resolve(o), i), source: t }, rest: () => n.end(), write: n.push, read: async () => (await t.next()).value }; };
            }, function (E, m, f) {
                "use strict";
                var d;
                !function () { var r = { not_string: /[^s]/, not_bool: /[^t]/, not_type: /[^T]/, not_primitive: /[^v]/, number: /[diefg]/, numeric_arg: /[bcdiefguxX]/, json: /[j]/, not_json: /[^j]/, text: /^[^\x25]+/, modulo: /^\x25{2}/, placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/, key: /^([a-z_][a-z_\d]*)/i, key_access: /^\.([a-z_][a-z_\d]*)/i, index_access: /^\[(\d+)\]/, sign: /^[+-]/ }; function e(u) { return n(s(u), arguments); } function c(u, i) { return e.apply(null, [u].concat(i || [])); } function n(u, i) { var o, h, a, l, p, g, b, I, v, R = 1, _ = u.length, k = ""; for (h = 0; h < _; h++)
                    if (typeof u[h] == "string")
                        k += u[h];
                    else if (typeof u[h] == "object") {
                        if ((l = u[h]).keys)
                            for (o = i[R], a = 0; a < l.keys.length; a++) {
                                if (o == null)
                                    throw new Error(e('[sprintf] Cannot access property "%s" of undefined value "%s"', l.keys[a], l.keys[a - 1]));
                                o = o[l.keys[a]];
                            }
                        else
                            o = l.param_no ? i[l.param_no] : i[R++];
                        if (r.not_type.test(l.type) && r.not_primitive.test(l.type) && o instanceof Function && (o = o()), r.numeric_arg.test(l.type) && typeof o != "number" && isNaN(o))
                            throw new TypeError(e("[sprintf] expecting number but found %T", o));
                        switch (r.number.test(l.type) && (I = o >= 0), l.type) {
                            case "b":
                                o = parseInt(o, 10).toString(2);
                                break;
                            case "c":
                                o = String.fromCharCode(parseInt(o, 10));
                                break;
                            case "d":
                            case "i":
                                o = parseInt(o, 10);
                                break;
                            case "j":
                                o = JSON.stringify(o, null, l.width ? parseInt(l.width) : 0);
                                break;
                            case "e":
                                o = l.precision ? parseFloat(o).toExponential(l.precision) : parseFloat(o).toExponential();
                                break;
                            case "f":
                                o = l.precision ? parseFloat(o).toFixed(l.precision) : parseFloat(o);
                                break;
                            case "g":
                                o = l.precision ? String(Number(o.toPrecision(l.precision))) : parseFloat(o);
                                break;
                            case "o":
                                o = (parseInt(o, 10) >>> 0).toString(8);
                                break;
                            case "s":
                                o = String(o), o = l.precision ? o.substring(0, l.precision) : o;
                                break;
                            case "t":
                                o = String(!!o), o = l.precision ? o.substring(0, l.precision) : o;
                                break;
                            case "T":
                                o = Object.prototype.toString.call(o).slice(8, -1).toLowerCase(), o = l.precision ? o.substring(0, l.precision) : o;
                                break;
                            case "u":
                                o = parseInt(o, 10) >>> 0;
                                break;
                            case "v":
                                o = o.valueOf(), o = l.precision ? o.substring(0, l.precision) : o;
                                break;
                            case "x":
                                o = (parseInt(o, 10) >>> 0).toString(16);
                                break;
                            case "X": o = (parseInt(o, 10) >>> 0).toString(16).toUpperCase();
                        }
                        r.json.test(l.type) ? k += o : (!r.number.test(l.type) || I && !l.sign ? v = "" : (v = I ? "+" : "-", o = o.toString().replace(r.sign, "")), g = l.pad_char ? l.pad_char === "0" ? "0" : l.pad_char.charAt(1) : " ", b = l.width - (v + o).length, p = l.width && b > 0 ? g.repeat(b) : "", k += l.align ? v + o + p : g === "0" ? v + p + o : p + v + o);
                    } return k; } var t = Object.create(null); function s(u) { if (t[u])
                    return t[u]; for (var i, o = u, h = [], a = 0; o;) {
                    if ((i = r.text.exec(o)) !== null)
                        h.push(i[0]);
                    else if ((i = r.modulo.exec(o)) !== null)
                        h.push("%");
                    else {
                        if ((i = r.placeholder.exec(o)) === null)
                            throw new SyntaxError("[sprintf] unexpected placeholder");
                        if (i[2]) {
                            a |= 1;
                            var l = [], p = i[2], g = [];
                            if ((g = r.key.exec(p)) === null)
                                throw new SyntaxError("[sprintf] failed to parse named argument key");
                            for (l.push(g[1]); (p = p.substring(g[0].length)) !== "";)
                                if ((g = r.key_access.exec(p)) !== null)
                                    l.push(g[1]);
                                else {
                                    if ((g = r.index_access.exec(p)) === null)
                                        throw new SyntaxError("[sprintf] failed to parse named argument key");
                                    l.push(g[1]);
                                }
                            i[2] = l;
                        }
                        else
                            a |= 2;
                        if (a === 3)
                            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
                        h.push({ placeholder: i[0], param_no: i[1], keys: i[2], sign: i[3], pad_char: i[4], align: i[5], width: i[6], precision: i[7], type: i[8] });
                    }
                    o = o.substring(i[0].length);
                } return t[u] = h; } m.sprintf = e, m.vsprintf = c, typeof window != "undefined" && (window.sprintf = e, window.vsprintf = c, (d = function () { return { sprintf: e, vsprintf: c }; }.call(m, f, m, E)) === void 0 || (E.exports = d)); }();
            }, function (E, m, f) {
                "use strict";
                var d = function (n) { return n && n.__esModule ? n : { default: n }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.logCipherState = m.logRemoteEphemeralKey = m.logRemoteStaticKey = m.logLocalEphemeralKeys = m.logLocalStaticKeys = m.logger = void 0;
                const r = d(f(1)), e = f(211);
                let c;
                m.logger = r.default("libp2p:noise"), c = e.DUMP_SESSION_KEYS ? m.logger : () => { }, m.logLocalStaticKeys = function (n) { c("LOCAL_STATIC_PUBLIC_KEY " + n.publicKey.toString("hex")), c("LOCAL_STATIC_PRIVATE_KEY " + n.privateKey.toString("hex")); }, m.logLocalEphemeralKeys = function (n) { n ? (c("LOCAL_PUBLIC_EPHEMERAL_KEY " + n.publicKey.toString("hex")), c("LOCAL_PRIVATE_EPHEMERAL_KEY " + n.privateKey.toString("hex"))) : c("Missing local ephemeral keys."); }, m.logRemoteStaticKey = function (n) { c("REMOTE_STATIC_PUBLIC_KEY " + n.toString("hex")); }, m.logRemoteEphemeralKey = function (n) { c("REMOTE_EPHEMERAL_PUBLIC_KEY " + n.toString("hex")); }, m.logCipherState = function (n) { n.cs1 && n.cs2 ? (c(`CIPHER_STATE_1 ${n.cs1.n} ${n.cs1.k.toString("hex")}`), c(`CIPHER_STATE_2 ${n.cs2.n} ${n.cs2.k.toString("hex")}`)) : c("Missing cipher state."); };
            }, function (E, m, f) {
                "use strict";
                const d = f(93), r = f(4), { getName: e } = f(18), c = f(1090), n = f(16), { isMapEqual: t } = f(46), { Message: s } = f(1091), u = f(1092);
                class i {
                    constructor(h) { this.full = h, this.wantlist = new Map, this.blocks = new Map, this.blockPresences = new Map, this.pendingBytes = 0; }
                    get empty() { return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0; }
                    addEntry(h, a, l, p, g) { l == null && (l = i.WantType.Block); const b = h.toString("base58btc"), I = this.wantlist.get(b); I ? (I.wantType === l && (I.priority = a), p && (I.cancel = Boolean(p)), g && (I.sendDontHave = Boolean(g)), l === i.WantType.Block && I.wantType === i.WantType.Have && (I.wantType = l)) : this.wantlist.set(b, new u(h, a, l, p, g)); }
                    addBlock(h) { const a = h.cid.toString("base58btc"); this.blocks.set(a, h); }
                    addHave(h) { const a = h.toString("base58btc"); this.blockPresences.has(a) || this.blockPresences.set(a, i.BlockPresenceType.Have); }
                    addDontHave(h) { const a = h.toString("base58btc"); this.blockPresences.has(a) || this.blockPresences.set(a, i.BlockPresenceType.DontHave); }
                    cancel(h) { const a = h.toString("base58btc"); this.wantlist.delete(a), this.addEntry(h, 0, i.WantType.Block, !0, !1); }
                    setPendingBytes(h) { this.pendingBytes = h; }
                    serializeToBitswap100() { const h = { wantlist: { entries: Array.from(this.wantlist.values()).map(a => ({ block: a.cid.bytes, priority: Number(a.priority), cancel: Boolean(a.cancel) })) }, blocks: Array.from(this.blocks.values()).map(a => a.data) }; return this.full && (h.wantlist.full = !0), s.encode(h); }
                    serializeToBitswap110() { const h = { wantlist: { entries: Array.from(this.wantlist.values()).map(a => ({ block: a.cid.bytes, priority: Number(a.priority), wantType: a.wantType, cancel: Boolean(a.cancel), sendDontHave: Boolean(a.sendDontHave) })) }, blockPresences: [], payload: [] }; this.full && (h.wantlist.full = !0), this.blocks.forEach(a => { h.payload.push({ prefix: a.cid.prefix, data: a.data }); }); for (const [a, l] of this.blockPresences)
                        h.blockPresences.push({ cid: new r(a).bytes, type: l }); return this.pendingBytes > 0 && (h.pendingBytes = this.pendingBytes), s.encode(h); }
                    equals(h) { return !!(this.full === h.full && this.pendingBytes === h.pendingBytes && t(this.wantlist, h.wantlist) && t(this.blocks, h.blocks) && t(this.blockPresences, h.blockPresences)); }
                    get [Symbol.toStringTag]() { const h = Array.from(this.wantlist.keys()), a = Array.from(this.blocks.keys()); return `BitswapMessage <full: ${this.full}, list: ${h}, blocks: ${a}>`; }
                }
                i.deserialize = async (o) => { const h = s.decode(o), a = h.wantlist && h.wantlist.full || !1, l = new i(a); return h.wantlist && h.wantlist.entries.forEach(p => { const g = new r(p.block); l.addEntry(g, p.priority, p.wantType, p.cancel, p.sendDontHave); }), h.blockPresences && h.blockPresences.forEach(p => { const g = new r(p.cid); p.type === i.BlockPresenceType.Have ? l.addHave(g) : l.addDontHave(g); }), h.blocks.length > 0 ? (await Promise.all(h.blocks.map(async (p) => { const g = await n(p, "sha2-256"), b = new r(g); l.addBlock(new d(p, b)); })), l) : (h.payload.length > 0 && (await Promise.all(h.payload.map(async (p) => { if (!p.prefix || !p.data)
                    return; const g = c(p.prefix), b = g[0], I = g[1], v = g[2], R = await n(p.data, v), _ = new r(b, e(I), R); l.addBlock(new d(p.data, _)); })), l.setPendingBytes(h.pendingBytes)), l); }, i.blockPresenceSize = o => o.bytes.length + 1, i.Entry = u, i.WantType = { Block: s.Wantlist.WantType.Block, Have: s.Wantlist.WantType.Have }, i.BlockPresenceType = { Have: s.BlockPresenceType.Have, DontHave: s.BlockPresenceType.DontHave }, E.exports = i;
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                if (f(44), f(104), f(82), f(453), f(455), f(50), f(14), r === void 0)
                    var r = d.jsbn.BigInteger;
                var e = d.util.isNodejs ? f(144) : null, c = d.asn1, n = d.util;
                d.pki = d.pki || {}, E.exports = d.pki.rsa = d.rsa = d.rsa || {};
                var t = d.pki, s = [6, 4, 2, 4, 2, 4, 6, 2], u = { name: "PrivateKeyInfo", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, value: [{ name: "PrivateKeyInfo.version", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: c.Class.UNIVERSAL, type: c.Type.OID, constructed: !1, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: c.Class.UNIVERSAL, type: c.Type.OCTETSTRING, constructed: !1, capture: "privateKey" }] }, i = { name: "RSAPrivateKey", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, value: [{ name: "RSAPrivateKey.version", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyVersion" }, { name: "RSAPrivateKey.modulus", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyModulus" }, { name: "RSAPrivateKey.publicExponent", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyPublicExponent" }, { name: "RSAPrivateKey.privateExponent", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyPrivateExponent" }, { name: "RSAPrivateKey.prime1", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyPrime1" }, { name: "RSAPrivateKey.prime2", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyPrime2" }, { name: "RSAPrivateKey.exponent1", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyExponent1" }, { name: "RSAPrivateKey.exponent2", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyExponent2" }, { name: "RSAPrivateKey.coefficient", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "privateKeyCoefficient" }] }, o = { name: "RSAPublicKey", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, value: [{ name: "RSAPublicKey.modulus", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "publicKeyModulus" }, { name: "RSAPublicKey.exponent", tagClass: c.Class.UNIVERSAL, type: c.Type.INTEGER, constructed: !1, capture: "publicKeyExponent" }] }, h = d.pki.rsa.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: c.Class.UNIVERSAL, type: c.Type.OID, constructed: !1, capture: "publicKeyOid" }] }, { name: "SubjectPublicKeyInfo.subjectPublicKey", tagClass: c.Class.UNIVERSAL, type: c.Type.BITSTRING, constructed: !1, value: [{ name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey", tagClass: c.Class.UNIVERSAL, type: c.Type.SEQUENCE, constructed: !0, optional: !0, captureAsn1: "rsaPublicKey" }] }] }, a = function (M) { var N; if (!(M.algorithm in t.oids)) {
                    var S = new Error("Unknown message digest algorithm.");
                    throw S.algorithm = M.algorithm, S;
                } N = t.oids[M.algorithm]; var T = c.oidToDer(N).getBytes(), B = c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, []), P = c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, []); P.value.push(c.create(c.Class.UNIVERSAL, c.Type.OID, !1, T)), P.value.push(c.create(c.Class.UNIVERSAL, c.Type.NULL, !1, "")); var L = c.create(c.Class.UNIVERSAL, c.Type.OCTETSTRING, !1, M.digest().getBytes()); return B.value.push(P), B.value.push(L), c.toDer(B).getBytes(); }, l = function (M, N, S) { if (S)
                    return M.modPow(N.e, N.n); if (!N.p || !N.q)
                    return M.modPow(N.d, N.n); var T; N.dP || (N.dP = N.d.mod(N.p.subtract(r.ONE))), N.dQ || (N.dQ = N.d.mod(N.q.subtract(r.ONE))), N.qInv || (N.qInv = N.q.modInverse(N.p)); do
                    T = new r(d.util.bytesToHex(d.random.getBytes(N.n.bitLength() / 8)), 16);
                while (T.compareTo(N.n) >= 0 || !T.gcd(N.n).equals(r.ONE)); for (var B = (M = M.multiply(T.modPow(N.e, N.n)).mod(N.n)).mod(N.p).modPow(N.dP, N.p), P = M.mod(N.q).modPow(N.dQ, N.q); B.compareTo(P) < 0;)
                    B = B.add(N.p); var L = B.subtract(P).multiply(N.qInv).mod(N.p).multiply(N.q).add(P); return L = L.multiply(T.modInverse(N.n)).mod(N.n); };
                function p(M, N, S) { var T = d.util.createBuffer(), B = Math.ceil(N.n.bitLength() / 8); if (M.length > B - 11) {
                    var P = new Error("Message is too long for PKCS#1 v1.5 padding.");
                    throw P.length = M.length, P.max = B - 11, P;
                } T.putByte(0), T.putByte(S); var L, j = B - 3 - M.length; if (S === 0 || S === 1) {
                    L = S === 0 ? 0 : 255;
                    for (var D = 0; D < j; ++D)
                        T.putByte(L);
                }
                else
                    for (; j > 0;) {
                        var G = 0, W = d.random.getBytes(j);
                        for (D = 0; D < j; ++D)
                            (L = W.charCodeAt(D)) === 0 ? ++G : T.putByte(L);
                        j = G;
                    } return T.putByte(0), T.putBytes(M), T; }
                function g(M, N, S, T) { var B = Math.ceil(N.n.bitLength() / 8), P = d.util.createBuffer(M), L = P.getByte(), j = P.getByte(); if (L !== 0 || S && j !== 0 && j !== 1 || !S && j != 2 || S && j === 0 && T === void 0)
                    throw new Error("Encryption block is invalid."); var D = 0; if (j === 0) {
                    D = B - 3 - T;
                    for (var G = 0; G < D; ++G)
                        if (P.getByte() !== 0)
                            throw new Error("Encryption block is invalid.");
                }
                else if (j === 1)
                    for (D = 0; P.length() > 1;) {
                        if (P.getByte() !== 255) {
                            --P.read;
                            break;
                        }
                        ++D;
                    }
                else if (j === 2)
                    for (D = 0; P.length() > 1;) {
                        if (P.getByte() === 0) {
                            --P.read;
                            break;
                        }
                        ++D;
                    } if (P.getByte() !== 0 || D !== B - 3 - P.length())
                    throw new Error("Encryption block is invalid."); return P.getBytes(); }
                function b(M, N, S) { typeof N == "function" && (S = N, N = {}); var T = { algorithm: { name: (N = N || {}).algorithm || "PRIMEINC", options: { workers: N.workers || 2, workLoad: N.workLoad || 100, workerScript: N.workerScript } } }; function B() { P(M.pBits, function (j, D) { return j ? S(j) : (M.p = D, M.q !== null ? L(j, M.q) : void P(M.qBits, L)); }); } function P(j, D) { d.prime.generateProbablePrime(j, T, D); } function L(j, D) { if (j)
                    return S(j); if (M.q = D, M.p.compareTo(M.q) < 0) {
                    var G = M.p;
                    M.p = M.q, M.q = G;
                } if (M.p.subtract(r.ONE).gcd(M.e).compareTo(r.ONE) !== 0)
                    return M.p = null, void B(); if (M.q.subtract(r.ONE).gcd(M.e).compareTo(r.ONE) !== 0)
                    return M.q = null, void P(M.qBits, L); if (M.p1 = M.p.subtract(r.ONE), M.q1 = M.q.subtract(r.ONE), M.phi = M.p1.multiply(M.q1), M.phi.gcd(M.e).compareTo(r.ONE) !== 0)
                    return M.p = M.q = null, void B(); if (M.n = M.p.multiply(M.q), M.n.bitLength() !== M.bits)
                    return M.q = null, void P(M.qBits, L); var W = M.e.modInverse(M.phi); M.keys = { privateKey: t.rsa.setPrivateKey(M.n, M.e, W, M.p, M.q, W.mod(M.p1), W.mod(M.q1), M.q.modInverse(M.p)), publicKey: t.rsa.setPublicKey(M.n, M.e) }, S(null, M.keys); } "prng" in N && (T.prng = N.prng), B(); }
                function I(M) { var N = M.toString(16); N[0] >= "8" && (N = "00" + N); var S = d.util.hexToBytes(N); return S.length > 1 && (S.charCodeAt(0) === 0 && (128 & S.charCodeAt(1)) == 0 || S.charCodeAt(0) === 255 && (128 & S.charCodeAt(1)) == 128) ? S.substr(1) : S; }
                function v(M) { return M <= 100 ? 27 : M <= 150 ? 18 : M <= 200 ? 15 : M <= 250 ? 12 : M <= 300 ? 9 : M <= 350 ? 8 : M <= 400 ? 7 : M <= 500 ? 6 : M <= 600 ? 5 : M <= 800 ? 4 : M <= 1250 ? 3 : 2; }
                function R(M) { return d.util.isNodejs && typeof e[M] == "function"; }
                function _(M) { return n.globalScope !== void 0 && typeof n.globalScope.crypto == "object" && typeof n.globalScope.crypto.subtle == "object" && typeof n.globalScope.crypto.subtle[M] == "function"; }
                function k(M) { return n.globalScope !== void 0 && typeof n.globalScope.msCrypto == "object" && typeof n.globalScope.msCrypto.subtle == "object" && typeof n.globalScope.msCrypto.subtle[M] == "function"; }
                function x(M) { for (var N = d.util.hexToBytes(M.toString(16)), S = new Uint8Array(N.length), T = 0; T < N.length; ++T)
                    S[T] = N.charCodeAt(T); return S; }
                t.rsa.encrypt = function (M, N, S) { var T, B = S, P = Math.ceil(N.n.bitLength() / 8); S !== !1 && S !== !0 ? (B = S === 2, T = p(M, N, S)) : (T = d.util.createBuffer()).putBytes(M); for (var L = new r(T.toHex(), 16), j = l(L, N, B).toString(16), D = d.util.createBuffer(), G = P - Math.ceil(j.length / 2); G > 0;)
                    D.putByte(0), --G; return D.putBytes(d.util.hexToBytes(j)), D.getBytes(); }, t.rsa.decrypt = function (M, N, S, T) { var B = Math.ceil(N.n.bitLength() / 8); if (M.length !== B) {
                    var P = new Error("Encrypted message length is invalid.");
                    throw P.length = M.length, P.expected = B, P;
                } var L = new r(d.util.createBuffer(M).toHex(), 16); if (L.compareTo(N.n) >= 0)
                    throw new Error("Encrypted message is invalid."); for (var j = l(L, N, S).toString(16), D = d.util.createBuffer(), G = B - Math.ceil(j.length / 2); G > 0;)
                    D.putByte(0), --G; return D.putBytes(d.util.hexToBytes(j)), T !== !1 ? g(D.getBytes(), N, S) : D.getBytes(); }, t.rsa.createKeyPairGenerationState = function (M, N, S) { typeof M == "string" && (M = parseInt(M, 10)), M = M || 2048; var T, B = (S = S || {}).prng || d.random, P = { nextBytes: function (j) { for (var D = B.getBytesSync(j.length), G = 0; G < j.length; ++G)
                        j[G] = D.charCodeAt(G); } }, L = S.algorithm || "PRIMEINC"; if (L !== "PRIMEINC")
                    throw new Error("Invalid key generation algorithm: " + L); return (T = { algorithm: L, state: 0, bits: M, rng: P, eInt: N || 65537, e: new r(null), p: null, q: null, qBits: M >> 1, pBits: M - (M >> 1), pqState: 0, num: null, keys: null }).e.fromInt(T.eInt), T; }, t.rsa.stepKeyPairGenerationState = function (M, N) { "algorithm" in M || (M.algorithm = "PRIMEINC"); var S = new r(null); S.fromInt(30); for (var T, B = 0, P = function (X, Q) { return X | Q; }, L = +new Date, j = 0; M.keys === null && (N <= 0 || j < N);) {
                    if (M.state === 0) {
                        var D = M.p === null ? M.pBits : M.qBits, G = D - 1;
                        M.pqState === 0 ? (M.num = new r(D, M.rng), M.num.testBit(G) || M.num.bitwiseTo(r.ONE.shiftLeft(G), P, M.num), M.num.dAddOffset(31 - M.num.mod(S).byteValue(), 0), B = 0, ++M.pqState) : M.pqState === 1 ? M.num.bitLength() > D ? M.pqState = 0 : M.num.isProbablePrime(v(M.num.bitLength())) ? ++M.pqState : M.num.dAddOffset(s[B++ % 8], 0) : M.pqState === 2 ? M.pqState = M.num.subtract(r.ONE).gcd(M.e).compareTo(r.ONE) === 0 ? 3 : 0 : M.pqState === 3 && (M.pqState = 0, M.p === null ? M.p = M.num : M.q = M.num, M.p !== null && M.q !== null && ++M.state, M.num = null);
                    }
                    else if (M.state === 1)
                        M.p.compareTo(M.q) < 0 && (M.num = M.p, M.p = M.q, M.q = M.num), ++M.state;
                    else if (M.state === 2)
                        M.p1 = M.p.subtract(r.ONE), M.q1 = M.q.subtract(r.ONE), M.phi = M.p1.multiply(M.q1), ++M.state;
                    else if (M.state === 3)
                        M.phi.gcd(M.e).compareTo(r.ONE) === 0 ? ++M.state : (M.p = null, M.q = null, M.state = 0);
                    else if (M.state === 4)
                        M.n = M.p.multiply(M.q), M.n.bitLength() === M.bits ? ++M.state : (M.q = null, M.state = 0);
                    else if (M.state === 5) {
                        var W = M.e.modInverse(M.phi);
                        M.keys = { privateKey: t.rsa.setPrivateKey(M.n, M.e, W, M.p, M.q, W.mod(M.p1), W.mod(M.q1), M.q.modInverse(M.p)), publicKey: t.rsa.setPublicKey(M.n, M.e) };
                    }
                    j += (T = +new Date) - L, L = T;
                } return M.keys !== null; }, t.rsa.generateKeyPair = function (M, N, S, T) { if (arguments.length === 1 ? typeof M == "object" ? (S = M, M = void 0) : typeof M == "function" && (T = M, M = void 0) : arguments.length === 2 ? typeof M == "number" ? typeof N == "function" ? (T = N, N = void 0) : typeof N != "number" && (S = N, N = void 0) : (S = M, T = N, M = void 0, N = void 0) : arguments.length === 3 && (typeof N == "number" ? typeof S == "function" && (T = S, S = void 0) : (T = S, S = N, N = void 0)), S = S || {}, M === void 0 && (M = S.bits || 2048), N === void 0 && (N = S.e || 65537), !d.options.usePureJavaScript && !S.prng && M >= 256 && M <= 16384 && (N === 65537 || N === 3)) {
                    if (T) {
                        if (R("generateKeyPair"))
                            return e.generateKeyPair("rsa", { modulusLength: M, publicExponent: N, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } }, function (j, D, G) { if (j)
                                return T(j); T(null, { privateKey: t.privateKeyFromPem(G), publicKey: t.publicKeyFromPem(D) }); });
                        if (_("generateKey") && _("exportKey"))
                            return n.globalScope.crypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: M, publicExponent: x(N), hash: { name: "SHA-256" } }, !0, ["sign", "verify"]).then(function (j) { return n.globalScope.crypto.subtle.exportKey("pkcs8", j.privateKey); }).then(void 0, function (j) { T(j); }).then(function (j) { if (j) {
                                var D = t.privateKeyFromAsn1(c.fromDer(d.util.createBuffer(j)));
                                T(null, { privateKey: D, publicKey: t.setRsaPublicKey(D.n, D.e) });
                            } });
                        if (k("generateKey") && k("exportKey")) {
                            var B = n.globalScope.msCrypto.subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: M, publicExponent: x(N), hash: { name: "SHA-256" } }, !0, ["sign", "verify"]);
                            return B.oncomplete = function (j) { var D = j.target.result, G = n.globalScope.msCrypto.subtle.exportKey("pkcs8", D.privateKey); G.oncomplete = function (W) { var X = W.target.result, Q = t.privateKeyFromAsn1(c.fromDer(d.util.createBuffer(X))); T(null, { privateKey: Q, publicKey: t.setRsaPublicKey(Q.n, Q.e) }); }, G.onerror = function (W) { T(W); }; }, void (B.onerror = function (j) { T(j); });
                        }
                    }
                    else if (R("generateKeyPairSync")) {
                        var P = e.generateKeyPairSync("rsa", { modulusLength: M, publicExponent: N, publicKeyEncoding: { type: "spki", format: "pem" }, privateKeyEncoding: { type: "pkcs8", format: "pem" } });
                        return { privateKey: t.privateKeyFromPem(P.privateKey), publicKey: t.publicKeyFromPem(P.publicKey) };
                    }
                } var L = t.rsa.createKeyPairGenerationState(M, N, S); if (!T)
                    return t.rsa.stepKeyPairGenerationState(L, 0), L.keys; b(L, S, T); }, t.setRsaPublicKey = t.rsa.setPublicKey = function (M, N) { var S = { n: M, e: N, encrypt: function (T, B, P) { if (typeof B == "string" ? B = B.toUpperCase() : B === void 0 && (B = "RSAES-PKCS1-V1_5"), B === "RSAES-PKCS1-V1_5")
                        B = { encode: function (j, D, G) { return p(j, D, 2).getBytes(); } };
                    else if (B === "RSA-OAEP" || B === "RSAES-OAEP")
                        B = { encode: function (j, D) { return d.pkcs1.encode_rsa_oaep(D, j, P); } };
                    else if (["RAW", "NONE", "NULL", null].indexOf(B) !== -1)
                        B = { encode: function (j) { return j; } };
                    else if (typeof B == "string")
                        throw new Error('Unsupported encryption scheme: "' + B + '".'); var L = B.encode(T, S, !0); return t.rsa.encrypt(L, S, !0); }, verify: function (T, B, P) { typeof P == "string" ? P = P.toUpperCase() : P === void 0 && (P = "RSASSA-PKCS1-V1_5"), P === "RSASSA-PKCS1-V1_5" ? P = { verify: function (j, D) { return D = g(D, S, !0), j === c.fromDer(D).value[1].value; } } : P !== "NONE" && P !== "NULL" && P !== null || (P = { verify: function (j, D) { return j === (D = g(D, S, !0)); } }); var L = t.rsa.decrypt(B, S, !0, !1); return P.verify(T, L, S.n.bitLength()); } }; return S; }, t.setRsaPrivateKey = t.rsa.setPrivateKey = function (M, N, S, T, B, P, L, j) { var D = { n: M, e: N, d: S, p: T, q: B, dP: P, dQ: L, qInv: j, decrypt: function (G, W, X) { typeof W == "string" ? W = W.toUpperCase() : W === void 0 && (W = "RSAES-PKCS1-V1_5"); var Q = t.rsa.decrypt(G, D, !1, !1); if (W === "RSAES-PKCS1-V1_5")
                        W = { decode: g };
                    else if (W === "RSA-OAEP" || W === "RSAES-OAEP")
                        W = { decode: function (K, F) { return d.pkcs1.decode_rsa_oaep(F, K, X); } };
                    else {
                        if (["RAW", "NONE", "NULL", null].indexOf(W) === -1)
                            throw new Error('Unsupported encryption scheme: "' + W + '".');
                        W = { decode: function (K) { return K; } };
                    } return W.decode(Q, D, !1); }, sign: function (G, W) { var X = !1; typeof W == "string" && (W = W.toUpperCase()), W === void 0 || W === "RSASSA-PKCS1-V1_5" ? (W = { encode: a }, X = 1) : W !== "NONE" && W !== "NULL" && W !== null || (W = { encode: function () { return G; } }, X = 1); var Q = W.encode(G, D.n.bitLength()); return t.rsa.encrypt(Q, D, X); } }; return D; }, t.wrapRsaPrivateKey = function (M) { return c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, c.integerToDer(0).getBytes()), c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.OID, !1, c.oidToDer(t.oids.rsaEncryption).getBytes()), c.create(c.Class.UNIVERSAL, c.Type.NULL, !1, "")]), c.create(c.Class.UNIVERSAL, c.Type.OCTETSTRING, !1, c.toDer(M).getBytes())]); }, t.privateKeyFromAsn1 = function (M) { var N, S, T, B, P, L, j, D, G = {}, W = []; if (c.validate(M, u, G, W) && (M = c.fromDer(d.util.createBuffer(G.privateKey))), G = {}, W = [], !c.validate(M, i, G, W)) {
                    var X = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
                    throw X.errors = W, X;
                } return N = d.util.createBuffer(G.privateKeyModulus).toHex(), S = d.util.createBuffer(G.privateKeyPublicExponent).toHex(), T = d.util.createBuffer(G.privateKeyPrivateExponent).toHex(), B = d.util.createBuffer(G.privateKeyPrime1).toHex(), P = d.util.createBuffer(G.privateKeyPrime2).toHex(), L = d.util.createBuffer(G.privateKeyExponent1).toHex(), j = d.util.createBuffer(G.privateKeyExponent2).toHex(), D = d.util.createBuffer(G.privateKeyCoefficient).toHex(), t.setRsaPrivateKey(new r(N, 16), new r(S, 16), new r(T, 16), new r(B, 16), new r(P, 16), new r(L, 16), new r(j, 16), new r(D, 16)); }, t.privateKeyToAsn1 = t.privateKeyToRSAPrivateKey = function (M) { return c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, c.integerToDer(0).getBytes()), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.n)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.e)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.d)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.p)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.q)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.dP)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.dQ)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.qInv))]); }, t.publicKeyFromAsn1 = function (M) { var N = {}, S = []; if (c.validate(M, h, N, S)) {
                    var T, B = c.derToOid(N.publicKeyOid);
                    if (B !== t.oids.rsaEncryption)
                        throw (T = new Error("Cannot read public key. Unknown OID.")).oid = B, T;
                    M = N.rsaPublicKey;
                } if (S = [], !c.validate(M, o, N, S))
                    throw (T = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.")).errors = S, T; var P = d.util.createBuffer(N.publicKeyModulus).toHex(), L = d.util.createBuffer(N.publicKeyExponent).toHex(); return t.setRsaPublicKey(new r(P, 16), new r(L, 16)); }, t.publicKeyToAsn1 = t.publicKeyToSubjectPublicKeyInfo = function (M) { return c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.OID, !1, c.oidToDer(t.oids.rsaEncryption).getBytes()), c.create(c.Class.UNIVERSAL, c.Type.NULL, !1, "")]), c.create(c.Class.UNIVERSAL, c.Type.BITSTRING, !1, [t.publicKeyToRSAPublicKey(M)])]); }, t.publicKeyToRSAPublicKey = function (M) { return c.create(c.Class.UNIVERSAL, c.Type.SEQUENCE, !0, [c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.n)), c.create(c.Class.UNIVERSAL, c.Type.INTEGER, !1, I(M.e))]); };
            }, function (E, m, f) {
                "use strict";
                var d, r = f(8);
                E.exports = r.jsbn = r.jsbn || {};
                function e(T, B, P) { this.data = [], T != null && (typeof T == "number" ? this.fromNumber(T, B, P) : B == null && typeof T != "string" ? this.fromString(T, 256) : this.fromString(T, B)); }
                function c() { return new e(null); }
                function n(T, B, P, L, j, D) { for (var G = 16383 & B, W = B >> 14; --D >= 0;) {
                    var X = 16383 & this.data[T], Q = this.data[T++] >> 14, K = W * X + Q * G;
                    j = ((X = G * X + ((16383 & K) << 14) + P.data[L] + j) >> 28) + (K >> 14) + W * Q, P.data[L++] = 268435455 & X;
                } return j; }
                r.jsbn.BigInteger = e, typeof navigator == "undefined" ? (e.prototype.am = n, d = 28) : navigator.appName == "Microsoft Internet Explorer" ? (e.prototype.am = function (T, B, P, L, j, D) { for (var G = 32767 & B, W = B >> 15; --D >= 0;) {
                    var X = 32767 & this.data[T], Q = this.data[T++] >> 15, K = W * X + Q * G;
                    j = ((X = G * X + ((32767 & K) << 15) + P.data[L] + (1073741823 & j)) >>> 30) + (K >>> 15) + W * Q + (j >>> 30), P.data[L++] = 1073741823 & X;
                } return j; }, d = 30) : navigator.appName != "Netscape" ? (e.prototype.am = function (T, B, P, L, j, D) { for (; --D >= 0;) {
                    var G = B * this.data[T++] + P.data[L] + j;
                    j = Math.floor(G / 67108864), P.data[L++] = 67108863 & G;
                } return j; }, d = 26) : (e.prototype.am = n, d = 28), e.prototype.DB = d, e.prototype.DM = (1 << d) - 1, e.prototype.DV = 1 << d, e.prototype.FV = Math.pow(2, 52), e.prototype.F1 = 52 - d, e.prototype.F2 = 2 * d - 52;
                var t, s, u = new Array;
                for (t = "0".charCodeAt(0), s = 0; s <= 9; ++s)
                    u[t++] = s;
                for (t = "a".charCodeAt(0), s = 10; s < 36; ++s)
                    u[t++] = s;
                for (t = "A".charCodeAt(0), s = 10; s < 36; ++s)
                    u[t++] = s;
                function i(T) { return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(T); }
                function o(T, B) { var P = u[T.charCodeAt(B)]; return P !== null && P !== void 0 ? P : -1; }
                function h(T) { var B = c(); return B.fromInt(T), B; }
                function a(T) { var B, P = 1; return (B = T >>> 16) != 0 && (T = B, P += 16), (B = T >> 8) != 0 && (T = B, P += 8), (B = T >> 4) != 0 && (T = B, P += 4), (B = T >> 2) != 0 && (T = B, P += 2), (B = T >> 1) != 0 && (T = B, P += 1), P; }
                function l(T) { this.m = T; }
                function p(T) { this.m = T, this.mp = T.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << T.DB - 15) - 1, this.mt2 = 2 * T.t; }
                function g(T, B) { return T & B; }
                function b(T, B) { return T | B; }
                function I(T, B) { return T ^ B; }
                function v(T, B) { return T & ~B; }
                function R(T) { if (T == 0)
                    return -1; var B = 0; return (65535 & T) == 0 && (T >>= 16, B += 16), (255 & T) == 0 && (T >>= 8, B += 8), (15 & T) == 0 && (T >>= 4, B += 4), (3 & T) == 0 && (T >>= 2, B += 2), (1 & T) == 0 && ++B, B; }
                function _(T) { for (var B = 0; T != 0;)
                    T &= T - 1, ++B; return B; }
                function k() { }
                function x(T) { return T; }
                function M(T) { this.r2 = c(), this.q3 = c(), e.ONE.dlShiftTo(2 * T.t, this.r2), this.mu = this.r2.divide(T), this.m = T; }
                l.prototype.convert = function (T) { return T.s < 0 || T.compareTo(this.m) >= 0 ? T.mod(this.m) : T; }, l.prototype.revert = function (T) { return T; }, l.prototype.reduce = function (T) { T.divRemTo(this.m, null, T); }, l.prototype.mulTo = function (T, B, P) { T.multiplyTo(B, P), this.reduce(P); }, l.prototype.sqrTo = function (T, B) { T.squareTo(B), this.reduce(B); }, p.prototype.convert = function (T) { var B = c(); return T.abs().dlShiftTo(this.m.t, B), B.divRemTo(this.m, null, B), T.s < 0 && B.compareTo(e.ZERO) > 0 && this.m.subTo(B, B), B; }, p.prototype.revert = function (T) { var B = c(); return T.copyTo(B), this.reduce(B), B; }, p.prototype.reduce = function (T) { for (; T.t <= this.mt2;)
                    T.data[T.t++] = 0; for (var B = 0; B < this.m.t; ++B) {
                    var P = 32767 & T.data[B], L = P * this.mpl + ((P * this.mph + (T.data[B] >> 15) * this.mpl & this.um) << 15) & T.DM;
                    for (P = B + this.m.t, T.data[P] += this.m.am(0, L, T, B, 0, this.m.t); T.data[P] >= T.DV;)
                        T.data[P] -= T.DV, T.data[++P]++;
                } T.clamp(), T.drShiftTo(this.m.t, T), T.compareTo(this.m) >= 0 && T.subTo(this.m, T); }, p.prototype.mulTo = function (T, B, P) { T.multiplyTo(B, P), this.reduce(P); }, p.prototype.sqrTo = function (T, B) { T.squareTo(B), this.reduce(B); }, e.prototype.copyTo = function (T) { for (var B = this.t - 1; B >= 0; --B)
                    T.data[B] = this.data[B]; T.t = this.t, T.s = this.s; }, e.prototype.fromInt = function (T) { this.t = 1, this.s = T < 0 ? -1 : 0, T > 0 ? this.data[0] = T : T < -1 ? this.data[0] = T + this.DV : this.t = 0; }, e.prototype.fromString = function (T, B) { var P; if (B == 16)
                    P = 4;
                else if (B == 8)
                    P = 3;
                else if (B == 256)
                    P = 8;
                else if (B == 2)
                    P = 1;
                else if (B == 32)
                    P = 5;
                else {
                    if (B != 4)
                        return void this.fromRadix(T, B);
                    P = 2;
                } this.t = 0, this.s = 0; for (var L = T.length, j = !1, D = 0; --L >= 0;) {
                    var G = P == 8 ? 255 & T[L] : o(T, L);
                    G < 0 ? T.charAt(L) == "-" && (j = !0) : (j = !1, D == 0 ? this.data[this.t++] = G : D + P > this.DB ? (this.data[this.t - 1] |= (G & (1 << this.DB - D) - 1) << D, this.data[this.t++] = G >> this.DB - D) : this.data[this.t - 1] |= G << D, (D += P) >= this.DB && (D -= this.DB));
                } P == 8 && (128 & T[0]) != 0 && (this.s = -1, D > 0 && (this.data[this.t - 1] |= (1 << this.DB - D) - 1 << D)), this.clamp(), j && e.ZERO.subTo(this, this); }, e.prototype.clamp = function () { for (var T = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == T;)
                    --this.t; }, e.prototype.dlShiftTo = function (T, B) { var P; for (P = this.t - 1; P >= 0; --P)
                    B.data[P + T] = this.data[P]; for (P = T - 1; P >= 0; --P)
                    B.data[P] = 0; B.t = this.t + T, B.s = this.s; }, e.prototype.drShiftTo = function (T, B) { for (var P = T; P < this.t; ++P)
                    B.data[P - T] = this.data[P]; B.t = Math.max(this.t - T, 0), B.s = this.s; }, e.prototype.lShiftTo = function (T, B) { var P, L = T % this.DB, j = this.DB - L, D = (1 << j) - 1, G = Math.floor(T / this.DB), W = this.s << L & this.DM; for (P = this.t - 1; P >= 0; --P)
                    B.data[P + G + 1] = this.data[P] >> j | W, W = (this.data[P] & D) << L; for (P = G - 1; P >= 0; --P)
                    B.data[P] = 0; B.data[G] = W, B.t = this.t + G + 1, B.s = this.s, B.clamp(); }, e.prototype.rShiftTo = function (T, B) { B.s = this.s; var P = Math.floor(T / this.DB); if (P >= this.t)
                    B.t = 0;
                else {
                    var L = T % this.DB, j = this.DB - L, D = (1 << L) - 1;
                    B.data[0] = this.data[P] >> L;
                    for (var G = P + 1; G < this.t; ++G)
                        B.data[G - P - 1] |= (this.data[G] & D) << j, B.data[G - P] = this.data[G] >> L;
                    L > 0 && (B.data[this.t - P - 1] |= (this.s & D) << j), B.t = this.t - P, B.clamp();
                } }, e.prototype.subTo = function (T, B) { for (var P = 0, L = 0, j = Math.min(T.t, this.t); P < j;)
                    L += this.data[P] - T.data[P], B.data[P++] = L & this.DM, L >>= this.DB; if (T.t < this.t) {
                    for (L -= T.s; P < this.t;)
                        L += this.data[P], B.data[P++] = L & this.DM, L >>= this.DB;
                    L += this.s;
                }
                else {
                    for (L += this.s; P < T.t;)
                        L -= T.data[P], B.data[P++] = L & this.DM, L >>= this.DB;
                    L -= T.s;
                } B.s = L < 0 ? -1 : 0, L < -1 ? B.data[P++] = this.DV + L : L > 0 && (B.data[P++] = L), B.t = P, B.clamp(); }, e.prototype.multiplyTo = function (T, B) { var P = this.abs(), L = T.abs(), j = P.t; for (B.t = j + L.t; --j >= 0;)
                    B.data[j] = 0; for (j = 0; j < L.t; ++j)
                    B.data[j + P.t] = P.am(0, L.data[j], B, j, 0, P.t); B.s = 0, B.clamp(), this.s != T.s && e.ZERO.subTo(B, B); }, e.prototype.squareTo = function (T) { for (var B = this.abs(), P = T.t = 2 * B.t; --P >= 0;)
                    T.data[P] = 0; for (P = 0; P < B.t - 1; ++P) {
                    var L = B.am(P, B.data[P], T, 2 * P, 0, 1);
                    (T.data[P + B.t] += B.am(P + 1, 2 * B.data[P], T, 2 * P + 1, L, B.t - P - 1)) >= B.DV && (T.data[P + B.t] -= B.DV, T.data[P + B.t + 1] = 1);
                } T.t > 0 && (T.data[T.t - 1] += B.am(P, B.data[P], T, 2 * P, 0, 1)), T.s = 0, T.clamp(); }, e.prototype.divRemTo = function (T, B, P) { var L = T.abs(); if (!(L.t <= 0)) {
                    var j = this.abs();
                    if (j.t < L.t)
                        return B != null && B.fromInt(0), void (P != null && this.copyTo(P));
                    P == null && (P = c());
                    var D = c(), G = this.s, W = T.s, X = this.DB - a(L.data[L.t - 1]);
                    X > 0 ? (L.lShiftTo(X, D), j.lShiftTo(X, P)) : (L.copyTo(D), j.copyTo(P));
                    var Q = D.t, K = D.data[Q - 1];
                    if (K != 0) {
                        var F = K * (1 << this.F1) + (Q > 1 ? D.data[Q - 2] >> this.F2 : 0), Y = this.FV / F, $ = (1 << this.F1) / F, y = 1 << this.F2, C = P.t, A = C - Q, U = B !== null && B !== void 0 ? B : c();
                        for (D.dlShiftTo(A, U), P.compareTo(U) >= 0 && (P.data[P.t++] = 1, P.subTo(U, P)), e.ONE.dlShiftTo(Q, U), U.subTo(D, D); D.t < Q;)
                            D.data[D.t++] = 0;
                        for (; --A >= 0;) {
                            var z = P.data[--C] == K ? this.DM : Math.floor(P.data[C] * Y + (P.data[C - 1] + y) * $);
                            if ((P.data[C] += D.am(0, z, P, A, 0, Q)) < z)
                                for (D.dlShiftTo(A, U), P.subTo(U, P); P.data[C] < --z;)
                                    P.subTo(U, P);
                        }
                        B != null && (P.drShiftTo(Q, B), G != W && e.ZERO.subTo(B, B)), P.t = Q, P.clamp(), X > 0 && P.rShiftTo(X, P), G < 0 && e.ZERO.subTo(P, P);
                    }
                } }, e.prototype.invDigit = function () { if (this.t < 1)
                    return 0; var T = this.data[0]; if ((1 & T) == 0)
                    return 0; var B = 3 & T; return (B = (B = (B = (B = B * (2 - (15 & T) * B) & 15) * (2 - (255 & T) * B) & 255) * (2 - ((65535 & T) * B & 65535)) & 65535) * (2 - T * B % this.DV) % this.DV) > 0 ? this.DV - B : -B; }, e.prototype.isEven = function () { return (this.t > 0 ? 1 & this.data[0] : this.s) == 0; }, e.prototype.exp = function (T, B) { if (T > 4294967295 || T < 1)
                    return e.ONE; var P = c(), L = c(), j = B.convert(this), D = a(T) - 1; for (j.copyTo(P); --D >= 0;)
                    if (B.sqrTo(P, L), (T & 1 << D) > 0)
                        B.mulTo(L, j, P);
                    else {
                        var G = P;
                        P = L, L = G;
                    } return B.revert(P); }, e.prototype.toString = function (T) { if (this.s < 0)
                    return "-" + this.negate().toString(T); var B; if (T == 16)
                    B = 4;
                else if (T == 8)
                    B = 3;
                else if (T == 2)
                    B = 1;
                else if (T == 32)
                    B = 5;
                else {
                    if (T != 4)
                        return this.toRadix(T);
                    B = 2;
                } var P, L = (1 << B) - 1, j = !1, D = "", G = this.t, W = this.DB - G * this.DB % B; if (G-- > 0)
                    for (W < this.DB && (P = this.data[G] >> W) > 0 && (j = !0, D = i(P)); G >= 0;)
                        W < B ? (P = (this.data[G] & (1 << W) - 1) << B - W, P |= this.data[--G] >> (W += this.DB - B)) : (P = this.data[G] >> (W -= B) & L, W <= 0 && (W += this.DB, --G)), P > 0 && (j = !0), j && (D += i(P)); return j ? D : "0"; }, e.prototype.negate = function () { var T = c(); return e.ZERO.subTo(this, T), T; }, e.prototype.abs = function () { return this.s < 0 ? this.negate() : this; }, e.prototype.compareTo = function (T) { var B = this.s - T.s; if (B != 0)
                    return B; var P = this.t; if ((B = P - T.t) != 0)
                    return this.s < 0 ? -B : B; for (; --P >= 0;)
                    if ((B = this.data[P] - T.data[P]) != 0)
                        return B; return 0; }, e.prototype.bitLength = function () { return this.t <= 0 ? 0 : this.DB * (this.t - 1) + a(this.data[this.t - 1] ^ this.s & this.DM); }, e.prototype.mod = function (T) { var B = c(); return this.abs().divRemTo(T, null, B), this.s < 0 && B.compareTo(e.ZERO) > 0 && T.subTo(B, B), B; }, e.prototype.modPowInt = function (T, B) { var P; return P = T < 256 || B.isEven() ? new l(B) : new p(B), this.exp(T, P); }, e.ZERO = h(0), e.ONE = h(1), k.prototype.convert = x, k.prototype.revert = x, k.prototype.mulTo = function (T, B, P) { T.multiplyTo(B, P); }, k.prototype.sqrTo = function (T, B) { T.squareTo(B); }, M.prototype.convert = function (T) { if (T.s < 0 || T.t > 2 * this.m.t)
                    return T.mod(this.m); if (T.compareTo(this.m) < 0)
                    return T; var B = c(); return T.copyTo(B), this.reduce(B), B; }, M.prototype.revert = function (T) { return T; }, M.prototype.reduce = function (T) { for (T.drShiftTo(this.m.t - 1, this.r2), T.t > this.m.t + 1 && (T.t = this.m.t + 1, T.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); T.compareTo(this.r2) < 0;)
                    T.dAddOffset(1, this.m.t + 1); for (T.subTo(this.r2, T); T.compareTo(this.m) >= 0;)
                    T.subTo(this.m, T); }, M.prototype.mulTo = function (T, B, P) { T.multiplyTo(B, P), this.reduce(P); }, M.prototype.sqrTo = function (T, B) { T.squareTo(B), this.reduce(B); };
                var N = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], S = (1 << 26) / N[N.length - 1];
                e.prototype.chunkSize = function (T) { return Math.floor(Math.LN2 * this.DB / Math.log(T)); }, e.prototype.toRadix = function (T) { if (T == null && (T = 10), this.signum() == 0 || T < 2 || T > 36)
                    return "0"; var B = this.chunkSize(T), P = Math.pow(T, B), L = h(P), j = c(), D = c(), G = ""; for (this.divRemTo(L, j, D); j.signum() > 0;)
                    G = (P + D.intValue()).toString(T).substr(1) + G, j.divRemTo(L, j, D); return D.intValue().toString(T) + G; }, e.prototype.fromRadix = function (T, B) { this.fromInt(0), B == null && (B = 10); for (var P = this.chunkSize(B), L = Math.pow(B, P), j = !1, D = 0, G = 0, W = 0; W < T.length; ++W) {
                    var X = o(T, W);
                    X < 0 ? T.charAt(W) == "-" && this.signum() == 0 && (j = !0) : (G = B * G + X, ++D >= P && (this.dMultiply(L), this.dAddOffset(G, 0), D = 0, G = 0));
                } D > 0 && (this.dMultiply(Math.pow(B, D)), this.dAddOffset(G, 0)), j && e.ZERO.subTo(this, this); }, e.prototype.fromNumber = function (T, B, P) { if (typeof B == "number")
                    if (T < 2)
                        this.fromInt(1);
                    else
                        for (this.fromNumber(T, P), this.testBit(T - 1) || this.bitwiseTo(e.ONE.shiftLeft(T - 1), b, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(B);)
                            this.dAddOffset(2, 0), this.bitLength() > T && this.subTo(e.ONE.shiftLeft(T - 1), this);
                else {
                    var L = new Array, j = 7 & T;
                    L.length = 1 + (T >> 3), B.nextBytes(L), j > 0 ? L[0] &= (1 << j) - 1 : L[0] = 0, this.fromString(L, 256);
                } }, e.prototype.bitwiseTo = function (T, B, P) { var L, j, D = Math.min(T.t, this.t); for (L = 0; L < D; ++L)
                    P.data[L] = B(this.data[L], T.data[L]); if (T.t < this.t) {
                    for (j = T.s & this.DM, L = D; L < this.t; ++L)
                        P.data[L] = B(this.data[L], j);
                    P.t = this.t;
                }
                else {
                    for (j = this.s & this.DM, L = D; L < T.t; ++L)
                        P.data[L] = B(j, T.data[L]);
                    P.t = T.t;
                } P.s = B(this.s, T.s), P.clamp(); }, e.prototype.changeBit = function (T, B) { var P = e.ONE.shiftLeft(T); return this.bitwiseTo(P, B, P), P; }, e.prototype.addTo = function (T, B) { for (var P = 0, L = 0, j = Math.min(T.t, this.t); P < j;)
                    L += this.data[P] + T.data[P], B.data[P++] = L & this.DM, L >>= this.DB; if (T.t < this.t) {
                    for (L += T.s; P < this.t;)
                        L += this.data[P], B.data[P++] = L & this.DM, L >>= this.DB;
                    L += this.s;
                }
                else {
                    for (L += this.s; P < T.t;)
                        L += T.data[P], B.data[P++] = L & this.DM, L >>= this.DB;
                    L += T.s;
                } B.s = L < 0 ? -1 : 0, L > 0 ? B.data[P++] = L : L < -1 && (B.data[P++] = this.DV + L), B.t = P, B.clamp(); }, e.prototype.dMultiply = function (T) { this.data[this.t] = this.am(0, T - 1, this, 0, 0, this.t), ++this.t, this.clamp(); }, e.prototype.dAddOffset = function (T, B) { if (T != 0) {
                    for (; this.t <= B;)
                        this.data[this.t++] = 0;
                    for (this.data[B] += T; this.data[B] >= this.DV;)
                        this.data[B] -= this.DV, ++B >= this.t && (this.data[this.t++] = 0), ++this.data[B];
                } }, e.prototype.multiplyLowerTo = function (T, B, P) { var L, j = Math.min(this.t + T.t, B); for (P.s = 0, P.t = j; j > 0;)
                    P.data[--j] = 0; for (L = P.t - this.t; j < L; ++j)
                    P.data[j + this.t] = this.am(0, T.data[j], P, j, 0, this.t); for (L = Math.min(T.t, B); j < L; ++j)
                    this.am(0, T.data[j], P, j, 0, B - j); P.clamp(); }, e.prototype.multiplyUpperTo = function (T, B, P) { --B; var L = P.t = this.t + T.t - B; for (P.s = 0; --L >= 0;)
                    P.data[L] = 0; for (L = Math.max(B - this.t, 0); L < T.t; ++L)
                    P.data[this.t + L - B] = this.am(B - L, T.data[L], P, 0, 0, this.t + L - B); P.clamp(), P.drShiftTo(1, P); }, e.prototype.modInt = function (T) { if (T <= 0)
                    return 0; var B = this.DV % T, P = this.s < 0 ? T - 1 : 0; if (this.t > 0)
                    if (B == 0)
                        P = this.data[0] % T;
                    else
                        for (var L = this.t - 1; L >= 0; --L)
                            P = (B * P + this.data[L]) % T; return P; }, e.prototype.millerRabin = function (T) { var B = this.subtract(e.ONE), P = B.getLowestSetBit(); if (P <= 0)
                    return !1; for (var L, j = B.shiftRight(P), D = { nextBytes: function (Q) { for (var K = 0; K < Q.length; ++K)
                        Q[K] = Math.floor(256 * Math.random()); } }, G = 0; G < T; ++G) {
                    do
                        L = new e(this.bitLength(), D);
                    while (L.compareTo(e.ONE) <= 0 || L.compareTo(B) >= 0);
                    var W = L.modPow(j, this);
                    if (W.compareTo(e.ONE) != 0 && W.compareTo(B) != 0) {
                        for (var X = 1; X++ < P && W.compareTo(B) != 0;)
                            if ((W = W.modPowInt(2, this)).compareTo(e.ONE) == 0)
                                return !1;
                        if (W.compareTo(B) != 0)
                            return !1;
                    }
                } return !0; }, e.prototype.clone = function () { var T = c(); return this.copyTo(T), T; }, e.prototype.intValue = function () { if (this.s < 0) {
                    if (this.t == 1)
                        return this.data[0] - this.DV;
                    if (this.t == 0)
                        return -1;
                }
                else {
                    if (this.t == 1)
                        return this.data[0];
                    if (this.t == 0)
                        return 0;
                } return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0]; }, e.prototype.byteValue = function () { return this.t == 0 ? this.s : this.data[0] << 24 >> 24; }, e.prototype.shortValue = function () { return this.t == 0 ? this.s : this.data[0] << 16 >> 16; }, e.prototype.signum = function () { return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1; }, e.prototype.toByteArray = function () { var T = this.t, B = new Array; B[0] = this.s; var P, L = this.DB - T * this.DB % 8, j = 0; if (T-- > 0)
                    for (L < this.DB && (P = this.data[T] >> L) != (this.s & this.DM) >> L && (B[j++] = P | this.s << this.DB - L); T >= 0;)
                        L < 8 ? (P = (this.data[T] & (1 << L) - 1) << 8 - L, P |= this.data[--T] >> (L += this.DB - 8)) : (P = this.data[T] >> (L -= 8) & 255, L <= 0 && (L += this.DB, --T)), (128 & P) != 0 && (P |= -256), j == 0 && (128 & this.s) != (128 & P) && ++j, (j > 0 || P != this.s) && (B[j++] = P); return B; }, e.prototype.equals = function (T) { return this.compareTo(T) == 0; }, e.prototype.min = function (T) { return this.compareTo(T) < 0 ? this : T; }, e.prototype.max = function (T) { return this.compareTo(T) > 0 ? this : T; }, e.prototype.and = function (T) { var B = c(); return this.bitwiseTo(T, g, B), B; }, e.prototype.or = function (T) { var B = c(); return this.bitwiseTo(T, b, B), B; }, e.prototype.xor = function (T) { var B = c(); return this.bitwiseTo(T, I, B), B; }, e.prototype.andNot = function (T) { var B = c(); return this.bitwiseTo(T, v, B), B; }, e.prototype.not = function () { for (var T = c(), B = 0; B < this.t; ++B)
                    T.data[B] = this.DM & ~this.data[B]; return T.t = this.t, T.s = ~this.s, T; }, e.prototype.shiftLeft = function (T) { var B = c(); return T < 0 ? this.rShiftTo(-T, B) : this.lShiftTo(T, B), B; }, e.prototype.shiftRight = function (T) { var B = c(); return T < 0 ? this.lShiftTo(-T, B) : this.rShiftTo(T, B), B; }, e.prototype.getLowestSetBit = function () { for (var T = 0; T < this.t; ++T)
                    if (this.data[T] != 0)
                        return T * this.DB + R(this.data[T]); return this.s < 0 ? this.t * this.DB : -1; }, e.prototype.bitCount = function () { for (var T = 0, B = this.s & this.DM, P = 0; P < this.t; ++P)
                    T += _(this.data[P] ^ B); return T; }, e.prototype.testBit = function (T) { var B = Math.floor(T / this.DB); return B >= this.t ? this.s != 0 : (this.data[B] & 1 << T % this.DB) != 0; }, e.prototype.setBit = function (T) { return this.changeBit(T, b); }, e.prototype.clearBit = function (T) { return this.changeBit(T, v); }, e.prototype.flipBit = function (T) { return this.changeBit(T, I); }, e.prototype.add = function (T) { var B = c(); return this.addTo(T, B), B; }, e.prototype.subtract = function (T) { var B = c(); return this.subTo(T, B), B; }, e.prototype.multiply = function (T) { var B = c(); return this.multiplyTo(T, B), B; }, e.prototype.divide = function (T) { var B = c(); return this.divRemTo(T, B, null), B; }, e.prototype.remainder = function (T) { var B = c(); return this.divRemTo(T, null, B), B; }, e.prototype.divideAndRemainder = function (T) { var B = c(), P = c(); return this.divRemTo(T, B, P), new Array(B, P); }, e.prototype.modPow = function (T, B) { var P, L, j = T.bitLength(), D = h(1); if (j <= 0)
                    return D; P = j < 18 ? 1 : j < 48 ? 3 : j < 144 ? 4 : j < 768 ? 5 : 6, L = j < 8 ? new l(B) : B.isEven() ? new M(B) : new p(B); var G = new Array, W = 3, X = P - 1, Q = (1 << P) - 1; if (G[1] = L.convert(this), P > 1) {
                    var K = c();
                    for (L.sqrTo(G[1], K); W <= Q;)
                        G[W] = c(), L.mulTo(K, G[W - 2], G[W]), W += 2;
                } var F, Y, $ = T.t - 1, y = !0, C = c(); for (j = a(T.data[$]) - 1; $ >= 0;) {
                    for (j >= X ? F = T.data[$] >> j - X & Q : (F = (T.data[$] & (1 << j + 1) - 1) << X - j, $ > 0 && (F |= T.data[$ - 1] >> this.DB + j - X)), W = P; (1 & F) == 0;)
                        F >>= 1, --W;
                    if ((j -= W) < 0 && (j += this.DB, --$), y)
                        G[F].copyTo(D), y = !1;
                    else {
                        for (; W > 1;)
                            L.sqrTo(D, C), L.sqrTo(C, D), W -= 2;
                        W > 0 ? L.sqrTo(D, C) : (Y = D, D = C, C = Y), L.mulTo(C, G[F], D);
                    }
                    for (; $ >= 0 && (T.data[$] & 1 << j) == 0;)
                        L.sqrTo(D, C), Y = D, D = C, C = Y, --j < 0 && (j = this.DB - 1, --$);
                } return L.revert(D); }, e.prototype.modInverse = function (T) { var B = T.isEven(); if (this.isEven() && B || T.signum() == 0)
                    return e.ZERO; for (var P = T.clone(), L = this.clone(), j = h(1), D = h(0), G = h(0), W = h(1); P.signum() != 0;) {
                    for (; P.isEven();)
                        P.rShiftTo(1, P), B ? (j.isEven() && D.isEven() || (j.addTo(this, j), D.subTo(T, D)), j.rShiftTo(1, j)) : D.isEven() || D.subTo(T, D), D.rShiftTo(1, D);
                    for (; L.isEven();)
                        L.rShiftTo(1, L), B ? (G.isEven() && W.isEven() || (G.addTo(this, G), W.subTo(T, W)), G.rShiftTo(1, G)) : W.isEven() || W.subTo(T, W), W.rShiftTo(1, W);
                    P.compareTo(L) >= 0 ? (P.subTo(L, P), B && j.subTo(G, j), D.subTo(W, D)) : (L.subTo(P, L), B && G.subTo(j, G), W.subTo(D, W));
                } return L.compareTo(e.ONE) != 0 ? e.ZERO : W.compareTo(T) >= 0 ? W.subtract(T) : W.signum() < 0 ? (W.addTo(T, W), W.signum() < 0 ? W.add(T) : W) : W; }, e.prototype.pow = function (T) { return this.exp(T, new k); }, e.prototype.gcd = function (T) { var B = this.s < 0 ? this.negate() : this.clone(), P = T.s < 0 ? T.negate() : T.clone(); if (B.compareTo(P) < 0) {
                    var L = B;
                    B = P, P = L;
                } var j = B.getLowestSetBit(), D = P.getLowestSetBit(); if (D < 0)
                    return B; for (j < D && (D = j), D > 0 && (B.rShiftTo(D, B), P.rShiftTo(D, P)); B.signum() > 0;)
                    (j = B.getLowestSetBit()) > 0 && B.rShiftTo(j, B), (j = P.getLowestSetBit()) > 0 && P.rShiftTo(j, P), B.compareTo(P) >= 0 ? (B.subTo(P, B), B.rShiftTo(1, B)) : (P.subTo(B, P), P.rShiftTo(1, P)); return D > 0 && P.lShiftTo(D, P), P; }, e.prototype.isProbablePrime = function (T) { var B, P = this.abs(); if (P.t == 1 && P.data[0] <= N[N.length - 1]) {
                    for (B = 0; B < N.length; ++B)
                        if (P.data[0] == N[B])
                            return !0;
                    return !1;
                } if (P.isEven())
                    return !1; for (B = 1; B < N.length;) {
                    for (var L = N[B], j = B + 1; j < N.length && L < S;)
                        L *= N[j++];
                    for (L = P.modInt(L); B < j;)
                        if (L % N[B++] == 0)
                            return !1;
                } return P.millerRabin(T); };
            }, function (E, m, f) {
                "use strict";
                m.get = (d = self) => { const r = d.crypto || d.msCrypto; if (!r || !r.subtle)
                    throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" }); return r; };
            }, function (E, m, f) {
                "use strict";
                const d = f(460), r = f(0);
                E.exports = function (e) { if (isNaN(e) || e <= 0)
                    throw r(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH"); return d(e); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { return d.webpackPolyfill || (d.deprecate = function () { }, d.paths = [], d.children || (d.children = []), Object.defineProperty(d, "loaded", { enumerable: !0, get: function () { return d.l; } }), Object.defineProperty(d, "id", { enumerable: !0, get: function () { return d.i; } }), d.webpackPolyfill = 1), d; };
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(33), e = r.getNAF, c = r.getJSF, n = r.assert;
                function t(u, i) { this.type = u, this.p = new d(i.p, 16), this.red = i.prime ? d.red(i.prime) : d.mont(this.p), this.zero = new d(0).toRed(this.red), this.one = new d(1).toRed(this.red), this.two = new d(2).toRed(this.red), this.n = i.n && new d(i.n, 16), this.g = i.g && this.pointFromJSON(i.g, i.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0; var o = this.n && this.p.div(this.n); !o || o.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red)); }
                function s(u, i) { this.curve = u, this.type = i, this.precomputed = null; }
                E.exports = t, t.prototype.point = function () { throw new Error("Not implemented"); }, t.prototype.validate = function () { throw new Error("Not implemented"); }, t.prototype._fixedNafMul = function (u, i) { n(u.precomputed); var o = u._getDoubles(), h = e(i, 1, this._bitLength), a = (1 << o.step + 1) - (o.step % 2 == 0 ? 2 : 1); a /= 3; for (var l = [], p = 0; p < h.length; p += o.step) {
                    var g = 0;
                    for (i = p + o.step - 1; i >= p; i--)
                        g = (g << 1) + h[i];
                    l.push(g);
                } for (var b = this.jpoint(null, null, null), I = this.jpoint(null, null, null), v = a; v > 0; v--) {
                    for (p = 0; p < l.length; p++)
                        (g = l[p]) === v ? I = I.mixedAdd(o.points[p]) : g === -v && (I = I.mixedAdd(o.points[p].neg()));
                    b = b.add(I);
                } return b.toP(); }, t.prototype._wnafMul = function (u, i) { var o = 4, h = u._getNAFPoints(o); o = h.wnd; for (var a = h.points, l = e(i, o, this._bitLength), p = this.jpoint(null, null, null), g = l.length - 1; g >= 0; g--) {
                    for (i = 0; g >= 0 && l[g] === 0; g--)
                        i++;
                    if (g >= 0 && i++, p = p.dblp(i), g < 0)
                        break;
                    var b = l[g];
                    n(b !== 0), p = u.type === "affine" ? b > 0 ? p.mixedAdd(a[b - 1 >> 1]) : p.mixedAdd(a[-b - 1 >> 1].neg()) : b > 0 ? p.add(a[b - 1 >> 1]) : p.add(a[-b - 1 >> 1].neg());
                } return u.type === "affine" ? p.toP() : p; }, t.prototype._wnafMulAdd = function (u, i, o, h, a) { for (var l = this._wnafT1, p = this._wnafT2, g = this._wnafT3, b = 0, I = 0; I < h; I++) {
                    var v = (D = i[I])._getNAFPoints(u);
                    l[I] = v.wnd, p[I] = v.points;
                } for (I = h - 1; I >= 1; I -= 2) {
                    var R = I - 1, _ = I;
                    if (l[R] === 1 && l[_] === 1) {
                        var k = [i[R], null, null, i[_]];
                        i[R].y.cmp(i[_].y) === 0 ? (k[1] = i[R].add(i[_]), k[2] = i[R].toJ().mixedAdd(i[_].neg())) : i[R].y.cmp(i[_].y.redNeg()) === 0 ? (k[1] = i[R].toJ().mixedAdd(i[_]), k[2] = i[R].add(i[_].neg())) : (k[1] = i[R].toJ().mixedAdd(i[_]), k[2] = i[R].toJ().mixedAdd(i[_].neg()));
                        var x = [-3, -1, -5, -7, 0, 7, 5, 1, 3], M = c(o[R], o[_]);
                        b = Math.max(M[0].length, b), g[R] = new Array(b), g[_] = new Array(b);
                        for (var N = 0; N < b; N++) {
                            var S = 0 | M[0][N], T = 0 | M[1][N];
                            g[R][N] = x[3 * (S + 1) + (T + 1)], g[_][N] = 0, p[R] = k;
                        }
                    }
                    else
                        g[R] = e(o[R], l[R], this._bitLength), g[_] = e(o[_], l[_], this._bitLength), b = Math.max(g[R].length, b), b = Math.max(g[_].length, b);
                } var B = this.jpoint(null, null, null), P = this._wnafT4; for (I = b; I >= 0; I--) {
                    for (var L = 0; I >= 0;) {
                        var j = !0;
                        for (N = 0; N < h; N++)
                            P[N] = 0 | g[N][I], P[N] !== 0 && (j = !1);
                        if (!j)
                            break;
                        L++, I--;
                    }
                    if (I >= 0 && L++, B = B.dblp(L), I < 0)
                        break;
                    for (N = 0; N < h; N++) {
                        var D, G = P[N];
                        G !== 0 && (G > 0 ? D = p[N][G - 1 >> 1] : G < 0 && (D = p[N][-G - 1 >> 1].neg()), B = D.type === "affine" ? B.mixedAdd(D) : B.add(D));
                    }
                } for (I = 0; I < h; I++)
                    p[I] = null; return a ? B : B.toP(); }, t.BasePoint = s, s.prototype.eq = function () { throw new Error("Not implemented"); }, s.prototype.validate = function () { return this.curve.validate(this); }, t.prototype.decodePoint = function (u, i) { u = r.toArray(u, i); var o = this.p.byteLength(); if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 == 2 * o)
                    return u[0] === 6 ? n(u[u.length - 1] % 2 == 0) : u[0] === 7 && n(u[u.length - 1] % 2 == 1), this.point(u.slice(1, 1 + o), u.slice(1 + o, 1 + 2 * o)); if ((u[0] === 2 || u[0] === 3) && u.length - 1 === o)
                    return this.pointFromX(u.slice(1, 1 + o), u[0] === 3); throw new Error("Unknown point format"); }, s.prototype.encodeCompressed = function (u) { return this.encode(u, !0); }, s.prototype._encode = function (u) { var i = this.curve.p.byteLength(), o = this.getX().toArray("be", i); return u ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", i)); }, s.prototype.encode = function (u, i) { return r.encode(this._encode(i), u); }, s.prototype.precompute = function (u) { if (this.precomputed)
                    return this; var i = { doubles: null, naf: null, beta: null }; return i.naf = this._getNAFPoints(8), i.doubles = this._getDoubles(4, u), i.beta = this._getBeta(), this.precomputed = i, this; }, s.prototype._hasDoubles = function (u) { if (!this.precomputed)
                    return !1; var i = this.precomputed.doubles; return !!i && i.points.length >= Math.ceil((u.bitLength() + 1) / i.step); }, s.prototype._getDoubles = function (u, i) { if (this.precomputed && this.precomputed.doubles)
                    return this.precomputed.doubles; for (var o = [this], h = this, a = 0; a < i; a += u) {
                    for (var l = 0; l < u; l++)
                        h = h.dbl();
                    o.push(h);
                } return { step: u, points: o }; }, s.prototype._getNAFPoints = function (u) { if (this.precomputed && this.precomputed.naf)
                    return this.precomputed.naf; for (var i = [this], o = (1 << u) - 1, h = o === 1 ? null : this.dbl(), a = 1; a < o; a++)
                    i[a] = i[a - 1].add(h); return { wnd: u, points: i }; }, s.prototype._getBeta = function () { return null; }, s.prototype.dblp = function (u) { for (var i = this, o = 0; o < u; o++)
                    i = i.dbl(); return i; };
            }, function (E, m, f) {
                "use strict";
                function d(c) { if (typeof c == "number") {
                    if (d.codes[c])
                        return d.codes[c];
                    throw new Error("no protocol with code: " + c);
                } if (typeof c == "string" || c instanceof String) {
                    if (d.names[c])
                        return d.names[c];
                    throw new Error("no protocol with name: " + c);
                } throw new Error("invalid protocol id type: " + c); }
                const r = -1;
                function e(c, n, t, s, u) { return { code: c, size: n, name: t, resolvable: Boolean(s), path: Boolean(u) }; }
                d.lengthPrefixedVarSize = r, d.V = r, d.table = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, r, "ip6zone"], [53, r, "dns", "resolvable"], [54, r, "dns4", "resolvable"], [55, r, "dns6", "resolvable"], [56, r, "dnsaddr", "resolvable"], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, r, "unix", !1, "path"], [421, r, "ipfs"], [421, r, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, r, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, r, "memory"]], d.names = {}, d.codes = {}, d.table.map(c => { const n = e.apply(null, c); d.codes[n.code] = n, d.names[n.name] = n; }), d.object = e, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0);
                E.exports = e => { if (e instanceof Uint8Array)
                    try {
                        e = new d(e);
                    }
                    catch (s) {
                        throw r(s, "ERR_INVALID_CID");
                    } if (d.isCID(e))
                    return { cid: e, path: void 0 }; e.startsWith("/ipfs/") && (e = e.substring("/ipfs/".length)); const c = e.split("/"); let n, t; try {
                    n = new d(c.shift());
                }
                catch (s) {
                    throw r(s, "ERR_INVALID_CID");
                } return c.length && (t = "/" + c.join("/")), { cid: n, path: t }; };
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(i = "not initialized") { super(i), this.name = "NotInitializedError", this.code = d.code; }
                }
                d.code = "ERR_NOT_INITIALIZED", m.NotInitializedError = d;
                class r extends Error {
                    constructor(i = "cannot initialize an initializing node") { super(i), this.name = "AlreadyInitializingError", this.code = e.code; }
                }
                r.code = "ERR_ALREADY_INITIALIZING", m.AlreadyInitializingError = r;
                class e extends Error {
                    constructor(i = "cannot re-initialize an initialized node") { super(i), this.name = "AlreadyInitializedError", this.code = e.code; }
                }
                e.code = "ERR_ALREADY_INITIALIZED", m.AlreadyInitializedError = e;
                class c extends Error {
                    constructor(i = "not started") { super(i), this.name = "NotStartedError", this.code = c.code; }
                }
                c.code = "ERR_NOT_STARTED", m.NotStartedError = c;
                class n extends Error {
                    constructor(i = "cannot start, already startin") { super(i), this.name = "AlreadyStartingError", this.code = n.code; }
                }
                n.code = "ERR_ALREADY_STARTING", m.AlreadyStartingError = n;
                class t extends Error {
                    constructor(i = "cannot start, already started") { super(i), this.name = "AlreadyStartedError", this.code = t.code; }
                }
                t.code = "ERR_ALREADY_STARTED", m.AlreadyStartedError = t;
                class s extends Error {
                    constructor(i = "not enabled") { super(i), this.name = "NotEnabledError", this.code = s.code; }
                }
                s.code = "ERR_NOT_ENABLED", m.NotEnabledError = s;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { if (!d)
                    throw Error("hashlru must have a max value, of type number, greater than 0"); var r = 0, e = Object.create(null), c = Object.create(null); function n(t, s) { e[t] = s, ++r >= d && (r = 0, c = e, e = Object.create(null)); } return { has: function (t) { return e[t] !== void 0 || c[t] !== void 0; }, remove: function (t) { e[t] !== void 0 && (e[t] = void 0), c[t] !== void 0 && (c[t] = void 0); }, get: function (t) { var s = e[t]; return s !== void 0 ? s : (s = c[t]) !== void 0 ? (n(t, s), s) : void 0; }, set: function (t, s) { e[t] !== void 0 ? e[t] = s : n(t, s); }, clear: function () { e = Object.create(null), c = Object.create(null); } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(30).BigNumber;
                m.MT = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 }, m.TAG = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, REGEXP: 35, MIME: 36 }, m.NUMBYTES = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 }, m.SIMPLE = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 }, m.SYMS = { NULL: Symbol("null"), UNDEFINED: Symbol("undef"), PARENT: Symbol("parent"), BREAK: Symbol("break"), STREAM: Symbol("stream") }, m.SHIFT32 = Math.pow(2, 32), m.SHIFT16 = Math.pow(2, 16), m.MAX_SAFE_HIGH = 2097151, m.NEG_ONE = new d(-1), m.TEN = new d(10), m.TWO = new d(2), m.PARENT = { ARRAY: 0, OBJECT: 1, MAP: 2, TAG: 3, BYTE_STRING: 4, UTF8_STRING: 5 };
            }, function (E, m, f) {
                "use strict";
                (function (d) { d === void 0 || !d.version || d.version.indexOf("v0.") === 0 || d.version.indexOf("v1.") === 0 && d.version.indexOf("v1.8.") !== 0 ? E.exports = { nextTick: function (r, e, c, n) { if (typeof r != "function")
                        throw new TypeError('"callback" argument must be a function'); var t, s, u = arguments.length; switch (u) {
                        case 0:
                        case 1: return d.nextTick(r);
                        case 2: return d.nextTick(function () { r.call(null, e); });
                        case 3: return d.nextTick(function () { r.call(null, e, c); });
                        case 4: return d.nextTick(function () { r.call(null, e, c, n); });
                        default:
                            for (t = new Array(u - 1), s = 0; s < t.length;)
                                t[s++] = arguments[s];
                            return d.nextTick(function () { r.apply(null, t); });
                    } } } : E.exports = d; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(3), r = d.Buffer;
                function e(n, t) { for (var s in n)
                    t[s] = n[s]; }
                function c(n, t, s) { return r(n, t, s); }
                r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? E.exports = d : (e(d, m), m.Buffer = c), e(r, c), c.from = function (n, t, s) { if (typeof n == "number")
                    throw new TypeError("Argument must not be a number"); return r(n, t, s); }, c.alloc = function (n, t, s) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); var u = r(n); return t !== void 0 ? typeof s == "string" ? u.fill(t, s) : u.fill(t) : u.fill(0), u; }, c.allocUnsafe = function (n) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); return r(n); }, c.allocUnsafeSlow = function (n) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); return d.SlowBuffer(n); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(63), e = f(569), c = f(160), n = f(90), t = f(65), s = f(30).BigNumber, u = f(91), i = f(54), o = i.MT, h = i.NUMBYTES, a = (i.SIMPLE, i.SYMS), l = t.bigIntize(i.BI), p = i.BN, g = Symbol("count"), b = (Symbol("pending_key"), Symbol("major type")), I = Symbol("error"), v = Symbol("not found"); function R(N, S, T) { const B = []; return B[g] = T, B[a.PARENT] = N, B[b] = S, B; } function _(N, S) { const T = new u; return T[g] = -1, T[a.PARENT] = N, T[b] = S, T; } function k(N) { return t.bufferToBigInt(N); } function x(N) { return l.MINUS_ONE - t.bufferToBigInt(N); } class M extends e {
                    constructor(S) { const T = (S = S || {}).tags; delete S.tags; const B = S.max_depth != null ? S.max_depth : -1; delete S.max_depth; const P = !!t.hasBigInt && !!S.bigint; delete S.bigint, super(S), this.running = !0, this.max_depth = B, this.tags = T, P && (this.tags == null && (this.tags = {}), this.tags[2] == null && (this.tags[2] = k), this.tags[3] == null && (this.tags[3] = x)); }
                    static nullcheck(S) { switch (S) {
                        case a.NULL: return null;
                        case a.UNDEFINED: return;
                        case v: throw new Error("Value not found");
                        default: return S;
                    } }
                    static decodeFirstSync(S, T) { let B, P = {}; switch (typeof (T = T || { encoding: "hex" })) {
                        case "string":
                            B = T;
                            break;
                        case "object": P = t.extend({}, T), B = P.encoding, delete P.encoding;
                    } const L = new M(P), j = S instanceof r.Readable ? S : new u(S, B !== null && B !== void 0 ? B : t.guessEncoding(S)), D = L._parse(); let G = D.next(); for (; !G.done;) {
                        const X = j.read(G.value);
                        if (X == null || X.length !== G.value)
                            throw new Error("Insufficient data");
                        G = D.next(X);
                    } const W = M.nullcheck(G.value); if (j.length > 0) {
                        const X = j.read(1);
                        j.unshift(X);
                        const Q = new Error("Unexpected data: 0x" + X[0].toString(16));
                        throw Q.value = W, Q;
                    } return W; }
                    static decodeAllSync(S, T) { let B, P = {}; switch (typeof (T = T || { encoding: "hex" })) {
                        case "string":
                            B = T;
                            break;
                        case "object": P = t.extend({}, T), B = P.encoding, delete P.encoding;
                    } const L = new M(P), j = S instanceof r.Readable ? S : new u(S, B !== null && B !== void 0 ? B : t.guessEncoding(S)), D = []; for (; j.length > 0;) {
                        const G = L._parse();
                        let W = G.next();
                        for (; !W.done;) {
                            const X = j.read(W.value);
                            if (X == null || X.length !== W.value)
                                throw new Error("Insufficient data");
                            W = G.next(X);
                        }
                        D.push(M.nullcheck(W.value));
                    } return D; }
                    static decodeFirst(S, T, B) { let P = {}, L = !1, j = "hex"; switch (typeof T) {
                        case "function":
                            B = T, j = t.guessEncoding(S);
                            break;
                        case "string":
                            j = T;
                            break;
                        case "object": P = t.extend({}, T), j = P.encoding != null ? P.encoding : t.guessEncoding(S), delete P.encoding, L = P.required != null && P.required, delete P.required;
                    } const D = new M(P); let G = v; const W = new Promise((X, Q) => { D.on("data", K => { G = M.nullcheck(K), D.close(); }), D.once("error", K => (G !== v && (K.value = G), G = I, D.close(), Q(K))), D.once("end", () => { switch (G) {
                        case v: return L ? Q(new Error("No CBOR found")) : X(G);
                        case I: return;
                        default: return X(G);
                    } }); }); return typeof B == "function" && W.then(X => B(null, X), B), D.end(S, j), W; }
                    static decodeAll(S, T, B) { let P = {}, L = "hex"; switch (typeof T) {
                        case "function":
                            B = T, L = t.guessEncoding(S);
                            break;
                        case "string":
                            L = T;
                            break;
                        case "object": P = t.extend({}, T), L = P.encoding != null ? P.encoding : t.guessEncoding(S), delete P.encoding;
                    } const j = new M(P), D = []; j.on("data", W => D.push(M.nullcheck(W))); const G = new Promise((W, X) => { j.on("error", X), j.on("end", () => W(D)); }); return typeof B == "function" && G.then(W => B(null, W), B), j.end(S, L), G; }
                    close() { this.running = !1, this.__fresh = !0; }
                    *_parse() { let S = null, T = 0, B = null; for (;;) {
                        if (this.max_depth >= 0 && T > this.max_depth)
                            throw new Error("Maximum depth " + this.max_depth + " exceeded");
                        const P = (yield 1)[0];
                        if (!this.running)
                            throw new Error("Unexpected data: 0x" + P.toString(16));
                        const L = P >> 5, j = 31 & P, D = S != null ? S[b] : void 0, G = S != null ? S.length : void 0;
                        switch (j) {
                            case h.ONE:
                                this.emit("more-bytes", L, 1, D, G), B = (yield 1)[0];
                                break;
                            case h.TWO:
                            case h.FOUR:
                            case h.EIGHT:
                                const X = 1 << j - 24;
                                this.emit("more-bytes", L, X, D, G);
                                const Q = yield X;
                                B = L === o.SIMPLE_FLOAT ? Q : t.parseCBORint(j, Q);
                                break;
                            case 28:
                            case 29:
                            case 30: throw this.running = !1, new Error("Additional info not implemented: " + j);
                            case h.INDEFINITE:
                                switch (L) {
                                    case o.POS_INT:
                                    case o.NEG_INT:
                                    case o.TAG: throw new Error("Invalid indefinite encoding for MT " + L);
                                }
                                B = -1;
                                break;
                            default: B = j;
                        }
                        switch (L) {
                            case o.POS_INT: break;
                            case o.NEG_INT:
                                B = B === Number.MAX_SAFE_INTEGER ? p.NEG_MAX : B instanceof s ? p.MINUS_ONE.minus(B) : -1 - B;
                                break;
                            case o.BYTE_STRING:
                            case o.UTF8_STRING:
                                switch (B) {
                                    case 0:
                                        this.emit("start-string", L, B, D, G), B = L === o.BYTE_STRING ? d.allocUnsafe(0) : "";
                                        break;
                                    case -1:
                                        this.emit("start", L, a.STREAM, D, G), S = _(S, L), T++;
                                        continue;
                                    default: this.emit("start-string", L, B, D, G), B = yield B, L === o.UTF8_STRING && (B = t.utf8(B));
                                }
                                break;
                            case o.ARRAY:
                            case o.MAP:
                                switch (B) {
                                    case 0:
                                        B = L === o.MAP ? {} : [];
                                        break;
                                    case -1:
                                        this.emit("start", L, a.STREAM, D, G), S = R(S, L, -1), T++;
                                        continue;
                                    default:
                                        this.emit("start", L, B, D, G), S = R(S, L, B * (L - 3)), T++;
                                        continue;
                                }
                                break;
                            case o.TAG:
                                this.emit("start", L, B, D, G), S = R(S, L, 1), S.push(B), T++;
                                continue;
                            case o.SIMPLE_FLOAT: if (typeof B == "number") {
                                if (j === h.ONE && B < 32)
                                    throw new Error("Invalid two-byte encoding of simple value " + B);
                                const X = S != null;
                                B = n.decode(B, X, X && S[g] < 0);
                            }
                            else
                                B = t.parseCBORfloat(B);
                        }
                        this.emit("value", B, D, G, j);
                        let W = !1;
                        for (; S != null;) {
                            switch (!1) {
                                case B !== a.BREAK:
                                    S[g] = 1;
                                    break;
                                case !Array.isArray(S):
                                    S.push(B);
                                    break;
                                case !(S instanceof u):
                                    const Q = S[b];
                                    if (Q != null && Q !== L)
                                        throw this.running = !1, new Error("Invalid major type in indefinite encoding");
                                    S.write(B);
                            }
                            if (--S[g] != 0) {
                                W = !0;
                                break;
                            }
                            if (--T, delete S[g], this.emit("stop", S[b]), Array.isArray(S))
                                switch (S[b]) {
                                    case o.ARRAY:
                                        B = S;
                                        break;
                                    case o.MAP:
                                        let Q = !0;
                                        if (S.length % 2 != 0)
                                            throw new Error("Invalid map length: " + S.length);
                                        for (let K = 0, F = S.length; K < F; K += 2)
                                            if (typeof S[K] != "string") {
                                                Q = !1;
                                                break;
                                            }
                                        if (Q) {
                                            B = {};
                                            for (let K = 0, F = S.length; K < F; K += 2)
                                                B[S[K]] = S[K + 1];
                                        }
                                        else {
                                            B = new Map;
                                            for (let K = 0, F = S.length; K < F; K += 2)
                                                B.set(S[K], S[K + 1]);
                                        }
                                        break;
                                    case o.TAG: B = new c(S[0], S[1]).convert(this.tags);
                                }
                            else if (S instanceof u)
                                switch (S[b]) {
                                    case o.BYTE_STRING:
                                        B = S.slice();
                                        break;
                                    case o.UTF8_STRING: B = S.toString("utf-8");
                                }
                            const X = S;
                            S = S[a.PARENT], delete X[a.PARENT], delete X[b];
                        }
                        if (!W)
                            return B;
                    } }
                } M.NOT_FOUND = v, E.exports = M; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const { Adapter: d, utils: r } = f(11), e = r.map;
                E.exports = class extends d {
                    constructor(c, n) { super(), this.child = c, this.transform = n; }
                    open() { return this.child.open(); }
                    put(c, n, t) { return this.child.put(this.transform.convert(c), n, t); }
                    get(c, n) { return this.child.get(this.transform.convert(c), n); }
                    has(c, n) { return this.child.has(this.transform.convert(c), n); }
                    delete(c, n) { return this.child.delete(this.transform.convert(c), n); }
                    batch() { const c = this.child.batch(); return { put: (n, t) => { c.put(this.transform.convert(n), t); }, delete: n => { c.delete(this.transform.convert(n)); }, commit: n => c.commit(n) }; }
                    query(c, n) { return e(this.child.query(c, n), t => (t.key = this.transform.invert(t.key), t)); }
                    close() { return this.child.close(); }
                };
            }, function (E, m, f) {
                "use strict";
                var d, r, e, c = f(693), n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
                function t() { e = !1; }
                function s(i) { if (i) {
                    if (i !== d) {
                        if (i.length !== n.length)
                            throw new Error("Custom alphabet for shortid must be " + n.length + " unique characters. You submitted " + i.length + " characters: " + i);
                        var o = i.split("").filter(function (h, a, l) { return a !== l.lastIndexOf(h); });
                        if (o.length)
                            throw new Error("Custom alphabet for shortid must be " + n.length + " unique characters. These characters were not unique: " + o.join(", "));
                        d = i, t();
                    }
                }
                else
                    d !== n && (d = n, t()); }
                function u() { return e || (e = function () { d || s(n); for (var i, o = d.split(""), h = [], a = c.nextValue(); o.length > 0;)
                    a = c.nextValue(), i = Math.floor(a * o.length), h.push(o.splice(i, 1)[0]); return h.join(""); }()); }
                E.exports = { get: function () { return d || n; }, characters: function (i) { return s(i), d; }, seed: function (i) { c.seed(i), r !== i && (t(), r = i); }, lookup: function (i) { return u()[i]; }, shuffled: u };
            }, function (E, m, f) {
                "use strict";
                const d = f(24).bind({ ignoreUndefined: !0 }), r = f(41), e = f(37), c = f(1)("ipfs:mfs:stat"), n = f(0), t = f(2), s = { withLocal: !1, signal: void 0 };
                E.exports = i => t(async function (o, h) { h = d(s, h), c("Fetching stats for " + o); const { type: a, cid: l, mfsPath: p } = await r(i, o, h), g = a === "ipfs" && l ? l : p; let b; try {
                    b = await e(g, i.ipld);
                }
                catch (I) {
                    throw I.code === "ERR_NOT_FOUND" ? n(new Error(o + " does not exist"), "ERR_NOT_FOUND") : I;
                } if (!u[b.cid.codec])
                    throw new Error("Cannot stat codec " + b.cid.codec); return u[b.cid.codec](b); });
                const u = { raw: i => ({ cid: i.cid, size: i.node.length, cumulativeSize: i.node.length, blocks: 0, type: "file", local: void 0, sizeLocal: void 0, withLocality: !1 }), "dag-pb": i => { const o = i.node.Links.length, h = i.node.size, a = i.node.size, l = { cid: i.cid, type: "file", size: h, cumulativeSize: a, blocks: o, local: void 0, sizeLocal: void 0, withLocality: !1 }; return i.unixfs && (l.size = i.unixfs.fileSize(), i.unixfs.type === "hamt-sharded-directory" ? l.type = "directory" : l.type = i.unixfs.type, l.mode = i.unixfs.mode, i.unixfs.isDirectory() && (l.size = 0, l.cumulativeSize = i.node.size), l.type === "file" && (l.blocks = i.unixfs.blockSizes.length), i.unixfs.mtime && (l.mtime = i.unixfs.mtime)), l; }, "dag-cbor": i => ({ cid: i.cid, local: void 0, sizeLocal: void 0, withLocality: !1 }), identity: i => ({ cid: i.cid, size: i.node.digest.length, cumulativeSize: i.node.digest.length, blocks: 0, type: "file", local: void 0, sizeLocal: void 0, withLocality: !1 }) };
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, r = f(163), e = r.ShardingDatastore;
                m.CONFIG_KEY = new d("/config"), m.VERSION_KEY = new d("/version"), m.createStore = async function (c, n, t) { const { StorageBackend: s, storageOptions: u } = function (o, h) { if (!h || !h.storageBackends)
                    throw new Error("Please pass storage backend definitions"); if (!h.storageBackends[o])
                    throw new Error(`Storage backend '${o}' not defined in config`); const a = h.storageBackends[o]; let l = {}; return h.storageBackendOptions !== void 0 && h.storageBackendOptions[o] !== void 0 && (l = h.storageBackendOptions[o]), { StorageBackend: a, storageOptions: l }; }(n, t); n !== "root" && (c = `${c}/${n}`); let i = new s(c, u); if (u.sharding) {
                    const o = new r.shard.NextToLast(2);
                    i = await e.createOrOpen(i, o);
                } return await i.close(), i; }, m.containsIrreversibleMigration = function (c, n, t) { return t.filter(s => s.version > c && s.version <= n).some(s => s.revert === void 0); };
            }, function (E, m, f) {
                "use strict";
                var d = f(312).Buffer, r = d.isEncoding || function (a) { switch ((a = "" + a) && a.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw": return !0;
                    default: return !1;
                } };
                function e(a) { var l; switch (this.encoding = function (p) { var g = function (b) { if (!b)
                    return "utf8"; for (var I;;)
                    switch (b) {
                        case "utf8":
                        case "utf-8": return "utf8";
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le": return "utf16le";
                        case "latin1":
                        case "binary": return "latin1";
                        case "base64":
                        case "ascii":
                        case "hex": return b;
                        default:
                            if (I)
                                return;
                            b = ("" + b).toLowerCase(), I = !0;
                    } }(p); if (typeof g != "string" && (d.isEncoding === r || !r(p)))
                    throw new Error("Unknown encoding: " + p); return g || p; }(a), this.encoding) {
                    case "utf16le":
                        this.text = t, this.end = s, l = 4;
                        break;
                    case "utf8":
                        this.fillLast = n, l = 4;
                        break;
                    case "base64":
                        this.text = u, this.end = i, l = 3;
                        break;
                    default: return this.write = o, void (this.end = h);
                } this.lastNeed = 0, this.lastTotal = 0, this.lastChar = d.allocUnsafe(l); }
                function c(a) { return a <= 127 ? 0 : a >> 5 == 6 ? 2 : a >> 4 == 14 ? 3 : a >> 3 == 30 ? 4 : a >> 6 == 2 ? -1 : -2; }
                function n(a) { var l = this.lastTotal - this.lastNeed, p = function (g, b, I) { if ((192 & b[0]) != 128)
                    return g.lastNeed = 0, "\uFFFD"; if (g.lastNeed > 1 && b.length > 1) {
                    if ((192 & b[1]) != 128)
                        return g.lastNeed = 1, "\uFFFD";
                    if (g.lastNeed > 2 && b.length > 2 && (192 & b[2]) != 128)
                        return g.lastNeed = 2, "\uFFFD";
                } }(this, a); return p !== void 0 ? p : this.lastNeed <= a.length ? (a.copy(this.lastChar, l, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (a.copy(this.lastChar, l, 0, a.length), void (this.lastNeed -= a.length)); }
                function t(a, l) { if ((a.length - l) % 2 == 0) {
                    var p = a.toString("utf16le", l);
                    if (p) {
                        var g = p.charCodeAt(p.length - 1);
                        if (g >= 55296 && g <= 56319)
                            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], p.slice(0, -1);
                    }
                    return p;
                } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", l, a.length - 1); }
                function s(a) { var l = a && a.length ? this.write(a) : ""; if (this.lastNeed) {
                    var p = this.lastTotal - this.lastNeed;
                    return l + this.lastChar.toString("utf16le", 0, p);
                } return l; }
                function u(a, l) { var p = (a.length - l) % 3; return p === 0 ? a.toString("base64", l) : (this.lastNeed = 3 - p, this.lastTotal = 3, p === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", l, a.length - p)); }
                function i(a) { var l = a && a.length ? this.write(a) : ""; return this.lastNeed ? l + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : l; }
                function o(a) { return a.toString(this.encoding); }
                function h(a) { return a && a.length ? this.write(a) : ""; }
                m.StringDecoder = e, e.prototype.write = function (a) { if (a.length === 0)
                    return ""; var l, p; if (this.lastNeed) {
                    if ((l = this.fillLast(a)) === void 0)
                        return "";
                    p = this.lastNeed, this.lastNeed = 0;
                }
                else
                    p = 0; return p < a.length ? l ? l + this.text(a, p) : this.text(a, p) : l || ""; }, e.prototype.end = function (a) { var l = a && a.length ? this.write(a) : ""; return this.lastNeed ? l + "\uFFFD" : l; }, e.prototype.text = function (a, l) { var p = function (b, I, v) { var R = I.length - 1; if (R < v)
                    return 0; var _ = c(I[R]); return _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 1), _) : --R < v || _ === -2 ? 0 : (_ = c(I[R])) >= 0 ? (_ > 0 && (b.lastNeed = _ - 2), _) : --R < v || _ === -2 ? 0 : (_ = c(I[R])) >= 0 ? (_ > 0 && (_ === 2 ? _ = 0 : b.lastNeed = _ - 3), _) : 0; }(this, a, l); if (!this.lastNeed)
                    return a.toString("utf8", l); this.lastTotal = p; var g = a.length - (p - this.lastNeed); return a.copy(this.lastChar, 0, g), a.toString("utf8", l, g); }, e.prototype.fillLast = function (a) { if (this.lastNeed <= a.length)
                    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length; };
            }, function (E, m, f) {
                "use strict";
                m.getCallback = function (d, r) { return typeof d == "function" ? d : r; }, m.getOptions = function (d) { return typeof d == "object" && d !== null ? d : {}; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(7), { codes: { ERR_INVALID_PARAMETERS: e } } = f(28), c = n => n;
                E.exports = class {
                    constructor({ peerStore: n, eventName: t, eventProperty: s, eventTransformer: u = c }) { this._ps = n, this.eventName = t, this.eventProperty = s, this.eventTransformer = u, this.data = new Map; }
                    set(n, t) { throw d(new Error("set must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED"); }
                    _setData(n, t, { emit: s = !0 } = {}) { const u = n.toB58String(); this.data.set(u, t), s && this._emit(n, t); }
                    _emit(n, t) { this._ps.emit(this.eventName, { peerId: n, [this.eventProperty]: this.eventTransformer(t) }); }
                    get(n) { if (!r.isPeerId(n))
                        throw d(new Error("peerId must be an instance of peer-id"), e); const t = this.data.get(n.toB58String()); return t ? [...t] : void 0; }
                    delete(n) { if (!r.isPeerId(n))
                        throw d(new Error("peerId must be an instance of peer-id"), e); return !!this.data.delete(n.toB58String()) && (this._emit(n, []), !0); }
                };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(34);
                E.exports = async function* (e) { for await (const c of e)
                    d.isBuffer(c) ? yield c : r.isBufferList(c) ? yield c.slice() : yield d.from(c); }, E.exports.toBuffer = E.exports, E.exports.toList = async function* (e) { for await (const c of e)
                    d.isBuffer(c) ? yield new r().append(c) : r.isBufferList(c) ? yield c : yield new r().append(d.from(c)); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r() { var e; try {
                    e = m.storage.debug;
                }
                catch (c) { } return !e && d !== void 0 && "env" in d && (e = { NODE_ENV: "production" }.DEBUG), e; } (m = E.exports = f(964)).log = function () { return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments); }, m.formatArgs = function (e) { var c = this.useColors; if (e[0] = (c ? "%c" : "") + this.namespace + (c ? " %c" : " ") + e[0] + (c ? "%c " : " ") + "+" + m.humanize(this.diff), !c)
                    return; var n = "color: " + this.color; e.splice(1, 0, n, "color: inherit"); var t = 0, s = 0; e[0].replace(/%[a-zA-Z%]/g, function (u) { u !== "%%" && (t++, u === "%c" && (s = t)); }), e.splice(s, 0, n); }, m.save = function (e) { try {
                    e == null ? m.storage.removeItem("debug") : m.storage.debug = e;
                }
                catch (c) { } }, m.load = r, m.useColors = function () { return typeof window != "undefined" && window.process && window.process.type === "renderer" ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/); }, m.storage = typeof chrome != "undefined" && chrome.storage !== void 0 ? chrome.storage.local : function () { try {
                    return window.localStorage;
                }
                catch (e) { } }(), m.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], m.formatters.j = function (e) { try {
                    return JSON.stringify(e);
                }
                catch (c) {
                    return "[UnexpectedJSONParseError]: " + c.message;
                } }, m.enable(r()); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                m.encode = function (d) { var r = ""; for (var e in d)
                    d.hasOwnProperty(e) && (r.length && (r += "&"), r += encodeURIComponent(e) + "=" + encodeURIComponent(d[e])); return r; }, m.decode = function (d) { for (var r = {}, e = d.split("&"), c = 0, n = e.length; c < n; c++) {
                    var t = e[c].split("=");
                    r[decodeURIComponent(t[0])] = decodeURIComponent(t[1]);
                } return r; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { var e = function () { }; e.prototype = r.prototype, d.prototype = new e, d.prototype.constructor = d; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r() { var e; try {
                    e = m.storage.debug;
                }
                catch (c) { } return !e && d !== void 0 && "env" in d && (e = { NODE_ENV: "production" }.DEBUG), e; } (m = E.exports = f(981)).log = function () { return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments); }, m.formatArgs = function (e) { var c = this.useColors; if (e[0] = (c ? "%c" : "") + this.namespace + (c ? " %c" : " ") + e[0] + (c ? "%c " : " ") + "+" + m.humanize(this.diff), !c)
                    return; var n = "color: " + this.color; e.splice(1, 0, n, "color: inherit"); var t = 0, s = 0; e[0].replace(/%[a-zA-Z%]/g, function (u) { u !== "%%" && (t++, u === "%c" && (s = t)); }), e.splice(s, 0, n); }, m.save = function (e) { try {
                    e == null ? m.storage.removeItem("debug") : m.storage.debug = e;
                }
                catch (c) { } }, m.load = r, m.useColors = function () { return typeof window != "undefined" && window.process && window.process.type === "renderer" ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/); }, m.storage = typeof chrome != "undefined" && chrome.storage !== void 0 ? chrome.storage.local : function () { try {
                    return window.localStorage;
                }
                catch (e) { } }(), m.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], m.formatters.j = function (e) { try {
                    return JSON.stringify(e);
                }
                catch (c) {
                    return "[UnexpectedJSONParseError]: " + c.message;
                } }, m.enable(r()); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.decode2 = m.decode1 = m.decode0 = m.encode2 = m.encode1 = m.encode0 = m.uint16BEDecode = m.uint16BEEncode = void 0;
                const d = f(3);
                m.uint16BEEncode = (r, e, c) => ((e = e || d.Buffer.allocUnsafe(2)).writeUInt16BE(r, c), e), m.uint16BEEncode.bytes = 2, m.uint16BEDecode = r => { if (r.length < 2)
                    throw RangeError("Could not decode int16BE"); return r.readUInt16BE(0); }, m.uint16BEDecode.bytes = 2, m.encode0 = function (r) { return d.Buffer.concat([r.ne, r.ciphertext]); }, m.encode1 = function (r) { return d.Buffer.concat([r.ne, r.ns, r.ciphertext]); }, m.encode2 = function (r) { return d.Buffer.concat([r.ns, r.ciphertext]); }, m.decode0 = function (r) { if (r.length < 32)
                    throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes."); return { ne: r.slice(0, 32), ciphertext: r.slice(32, r.length), ns: d.Buffer.alloc(0) }; }, m.decode1 = function (r) { if (r.length < 80)
                    throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes."); return { ne: r.slice(0, 32), ns: r.slice(32, 80), ciphertext: r.slice(80, r.length) }; }, m.decode2 = function (r) { if (r.length < 48)
                    throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes."); return { ne: d.Buffer.alloc(0), ns: r.slice(0, 48), ciphertext: r.slice(48, r.length) }; };
            }, function (E, m, f) {
                "use strict";
                const { sortBy: d } = f(46), r = f(1093);
                class e {
                    constructor(n) { this.set = new Map, this._stats = n; }
                    get length() { return this.set.size; }
                    add(n, t, s) { const u = f(102), i = n.toString("base58btc"), o = this.set.get(i); o ? (o.inc(), o.priority = t, o.wantType === u.WantType.Have && s === u.WantType.Block && (o.wantType = s)) : (this.set.set(i, new r(n, t, s)), this._stats && this._stats.push(null, "wantListSize", 1)); }
                    remove(n) { const t = n.toString("base58btc"), s = this.set.get(t); s && (s.dec(), s.hasRefs() || (this.set.delete(t), this._stats && this._stats.push(null, "wantListSize", -1))); }
                    removeForce(n) { this.set.has(n) && this.set.delete(n); }
                    forEach(n) { return this.set.forEach(n); }
                    entries() { return this.set.entries(); }
                    sortedEntries() { return new Map(d(n => n[1].key, Array.from(this.set.entries()))); }
                    contains(n) { const t = n.toString("base58btc"); return this.set.get(t); }
                }
                e.Entry = r, E.exports = e;
            }, function (E, m, f) {
                "use strict";
                E.exports = { maxProvidersPerRequest: 3, providerRequestTimeout: 1e4, hasBlockTimeout: 15e3, provideTimeout: 15e3, kMaxPriority: Math.pow(2, 31) - 1, maxListeners: 1e3, wantlistSendDebounceMs: 1 };
            }, function (E, m, f) {
                "use strict";
                const { fetch: d, Request: r, Headers: e } = f(395), { TimeoutError: c, HTTPError: n } = f(215), t = f(24).bind({ ignoreUndefined: !0 }), { URL: s, URLSearchParams: u } = f(403), i = f(405), o = f(136), h = f(137), a = { headers: {}, throwHttpErrors: !0, credentials: "same-origin", transformSearchParams: I => I };
                class l {
                    constructor(v = {}) { this.opts = t(a, v); }
                    async fetch(v, R = {}) { const _ = t(this.opts, R); if (_.headers = new e(_.headers), typeof v != "string" && !(v instanceof s || v instanceof r))
                        throw new TypeError("`resource` must be a string, URL, or Request"); if (_.base && typeof _.base == "string" && typeof v == "string") {
                        if (v.startsWith("/"))
                            throw new Error("`resource` must not begin with a slash when using `base`");
                        _.base.endsWith("/") || (_.base += "/"), v = _.base + v;
                    } const k = new s(v, _.base); _.searchParams && (k.search = _.transformSearchParams(new u(_.searchParams))), _.json !== void 0 && (_.body = JSON.stringify(_.json), _.headers.set("content-type", "application/json")); const x = new o, M = h([x.signal, _.signal]), N = await ((S, T, B) => { if (T === void 0)
                        return S; const P = Date.now(), L = () => Date.now() - P >= T; return new Promise((j, D) => { const G = setTimeout(() => { L() && (D(new c), B.abort()); }, T), W = X => Q => { clearTimeout(G), L() ? D(new c) : X(Q); }; S.then(W(j), W(D)); }); })(d(k.toString(), { ..._, signal: M, timeout: void 0 }), _.timeout, x); if (!N.ok && _.throwHttpErrors)
                        throw _.handleError && await _.handleError(N), new n(N); return N.iterator = function () { const S = g(N.body); if (!b(S))
                        throw new Error("Can't convert fetch body into a Async Iterator:"); return S; }, N.ndjson = async function* () { for await (const S of p(N.iterator()))
                        R.transform ? yield R.transform(S) : yield S; }, N; }
                    post(v, R = {}) { return this.fetch(v, { ...R, method: "POST" }); }
                    get(v, R = {}) { return this.fetch(v, { ...R, method: "GET" }); }
                    put(v, R = {}) { return this.fetch(v, { ...R, method: "PUT" }); }
                    delete(v, R = {}) { return this.fetch(v, { ...R, method: "DELETE" }); }
                    options(v, R = {}) { return this.fetch(v, { ...R, method: "OPTIONS" }); }
                }
                const p = async function* (I) { const v = new i; let R = ""; for await (const _ of I) {
                    R += v.decode(_, { stream: !0 });
                    const k = R.split(/\r?\n/);
                    for (let x = 0; x < k.length - 1; x++) {
                        const M = k[x].trim();
                        M.length > 0 && (yield JSON.parse(M));
                    }
                    R = k[k.length - 1];
                } R += v.decode(), R = R.trim(), R.length !== 0 && (yield JSON.parse(R)); }, g = function (I) { if (b(I)) {
                    if (Object.prototype.hasOwnProperty.call(I, "readable") && Object.prototype.hasOwnProperty.call(I, "writable")) {
                        const R = I[Symbol.asyncIterator](), _ = { next: R.next.bind(R), return: () => (I.destroy(), R.return()), [Symbol.asyncIterator]: () => _ };
                        return _;
                    }
                    return I;
                } const v = I.getReader(); return { next: () => v.read(), return: () => (v.releaseLock(), {}), [Symbol.asyncIterator]() { return this; } }; }, b = I => typeof I == "object" && I !== null && typeof I[Symbol.asyncIterator] == "function";
                l.HTTPError = n, l.TimeoutError = c, l.streamToAsyncIterator = g, l.post = (I, v) => new l(v).post(I, v), l.get = (I, v) => new l(v).get(I, v), l.put = (I, v) => new l(v).put(I, v), l.delete = (I, v) => new l(v).delete(I, v), l.options = (I, v) => new l(v).options(I, v), E.exports = l;
            }, function (E, m, f) {
                "use strict";
                var d = f(218), r = f(220), e = f(221), c = f(401), n = e(), t = function () { return n; };
                d(t, { getPolyfill: e, implementation: r, shim: c }), E.exports = t;
            }, function (E, m, f) {
                "use strict";
                E.exports = d => { if (Object.prototype.toString.call(d) !== "[object Object]")
                    return !1; const r = Object.getPrototypeOf(d); return r === null || r === Object.prototype; };
            }, function (E, m, f) {
                "use strict";
                typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this; }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__), E.exports = globalThis;
            }, function (E, m, f) {
                "use strict";
                const d = f(133)();
                d.AbortController && d.AbortSignal ? (E.exports = class extends d.AbortController {
                }, E.exports.AbortSignal = d.AbortSignal, E.exports.default = E.exports) : E.exports = f(47);
            }, function (E, m, f) {
                "use strict";
                const d = f(136);
                function r(e) { const c = new d; function n() { c.abort(); for (const t of e)
                    t && t.removeEventListener && t.removeEventListener("abort", n); } for (const t of e)
                    if (t && t.addEventListener) {
                        if (t.aborted) {
                            n();
                            break;
                        }
                        t.addEventListener("abort", n);
                    } return c.signal; }
                E.exports = r, E.exports.anySignal = r;
            }, function (E, m, f) {
                "use strict";
                const d = f(406), r = f(407), { rfc4648: e } = f(408), { decodeText: c, encodeText: n } = f(139), t = [["identity", "\0", () => ({ encode: c, decode: n }), ""], ["base2", "0", e(1), "01"], ["base8", "7", e(3), "01234567"], ["base10", "9", d, "0123456789"], ["base16", "f", e(4), "0123456789abcdef"], ["base16upper", "F", e(4), "0123456789ABCDEF"], ["base32hex", "v", e(5), "0123456789abcdefghijklmnopqrstuv"], ["base32hexupper", "V", e(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"], ["base32hexpad", "t", e(5), "0123456789abcdefghijklmnopqrstuv="], ["base32hexpadupper", "T", e(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="], ["base32", "b", e(5), "abcdefghijklmnopqrstuvwxyz234567"], ["base32upper", "B", e(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"], ["base32pad", "c", e(5), "abcdefghijklmnopqrstuvwxyz234567="], ["base32padupper", "C", e(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="], ["base32z", "h", e(5), "ybndrfg8ejkmcpqxot1uwisza345h769"], ["base36", "k", d, "0123456789abcdefghijklmnopqrstuvwxyz"], ["base36upper", "K", d, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"], ["base58btc", "z", d, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"], ["base58flickr", "Z", d, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"], ["base64", "m", e(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"], ["base64pad", "M", e(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="], ["base64url", "u", e(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"], ["base64urlpad", "U", e(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]], s = t.reduce((i, o) => (i[o[0]] = new r(o[0], o[1], o[2], o[3]), i), {}), u = t.reduce((i, o) => (i[o[1]] = s[o[0]], i), {});
                E.exports = { names: s, codes: u };
            }, function (E, m, f) {
                "use strict";
                const { TextEncoder: d, TextDecoder: r } = f(80), e = new r, c = new d;
                E.exports = { decodeText: n => e.decode(n), encodeText: n => c.encode(n), concat: function (n, t) { const s = new Uint8Array(t); let u = 0; for (const i of n)
                        s.set(i, u), u += i.length; return s; } };
            }, function (E, m, f) {
                "use strict";
                const d = f(21)(f(142));
                f(44), f(227);
                const r = f(8), e = f(0), c = f(6), n = f(456);
                m = E.exports;
                const t = { rsa: f(457), ed25519: f(463), secp256k1: f(465)(d, f(106)) };
                m.supportedKeys = t, m.keysPBM = d;
                const s = "secp256k1 support requires libp2p-crypto-secp256k1 package", u = "ERR_MISSING_PACKAGE";
                function i(o) { const h = t[o.toLowerCase()]; if (!h) {
                    const a = Object.keys(t).join(" / ");
                    throw e(new Error(`invalid or unsupported key type ${o}. Must be ${a}`), "ERR_UNSUPPORTED_KEY_TYPE");
                } return h; }
                m.keyStretcher = f(491), m.generateEphemeralKeyPair = f(493), m.generateKeyPair = async (o, h) => i(o).generateKeyPair(h), m.generateKeyPairFromSeed = async (o, h, a) => { const l = i(o); if (o.toLowerCase() !== "ed25519")
                    throw e(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE"); return l.generateKeyPairFromSeed(h, a); }, m.unmarshalPublicKey = o => { const h = d.PublicKey.decode(o), a = h.Data; switch (h.Type) {
                    case d.KeyType.RSA: return t.rsa.unmarshalRsaPublicKey(a);
                    case d.KeyType.Ed25519: return t.ed25519.unmarshalEd25519PublicKey(a);
                    case d.KeyType.Secp256k1:
                        if (t.secp256k1)
                            return t.secp256k1.unmarshalSecp256k1PublicKey(a);
                        throw e(new Error(s), u);
                    default: i(h.Type);
                } }, m.marshalPublicKey = (o, h) => (i(h = (h || "rsa").toLowerCase()), o.bytes), m.unmarshalPrivateKey = async (o) => { const h = d.PrivateKey.decode(o), a = h.Data; switch (h.Type) {
                    case d.KeyType.RSA: return t.rsa.unmarshalRsaPrivateKey(a);
                    case d.KeyType.Ed25519: return t.ed25519.unmarshalEd25519PrivateKey(a);
                    case d.KeyType.Secp256k1:
                        if (t.secp256k1)
                            return t.secp256k1.unmarshalSecp256k1PrivateKey(a);
                        throw e(new Error(s), u);
                    default: i(h.Type);
                } }, m.marshalPrivateKey = (o, h) => (i(h = (h || "rsa").toLowerCase()), o.bytes), m.import = async (o, h) => { try {
                    const p = await n.import(o, h);
                    return m.unmarshalPrivateKey(p);
                }
                catch (p) { } const a = r.pki.decryptRsaPrivateKey(o, h); if (a === null)
                    throw e(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM"); let l = r.asn1.toDer(r.pki.privateKeyToAsn1(a)); return l = c(l.getBytes(), "ascii"), t.rsa.unmarshalRsaPrivateKey(l); };
            }, function (E, m, f) {
                "use strict";
                m.defined = function (d) { return d != null && (typeof d != "number" || !isNaN(d)); };
            }, function (E, m, f) {
                "use strict";
                E.exports = `enum KeyType {
  RSA = 0;
  Ed25519 = 1;
  Secp256k1 = 2;
}
message PublicKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}
message PrivateKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}`;
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                function r(l, p) { d.cipher.registerAlgorithm(l, function () { return new d.des.Algorithm(l, p); }); }
                f(228), f(229), f(14), E.exports = d.des = d.des || {}, d.des.startEncrypting = function (l, p, g, b) { var I = a({ key: l, output: g, decrypt: !1, mode: b || (p === null ? "ECB" : "CBC") }); return I.start(p), I; }, d.des.createEncryptionCipher = function (l, p) { return a({ key: l, output: null, decrypt: !1, mode: p }); }, d.des.startDecrypting = function (l, p, g, b) { var I = a({ key: l, output: g, decrypt: !0, mode: b || (p === null ? "ECB" : "CBC") }); return I.start(p), I; }, d.des.createDecryptionCipher = function (l, p) { return a({ key: l, output: null, decrypt: !0, mode: p }); }, d.des.Algorithm = function (l, p) { var g = this; g.name = l, g.mode = new p({ blockSize: 8, cipher: { encrypt: function (b, I) { return h(g._keys, b, I, !1); }, decrypt: function (b, I) { return h(g._keys, b, I, !0); } } }), g._init = !1; }, d.des.Algorithm.prototype.initialize = function (l) { if (!this._init) {
                    var p = d.util.createBuffer(l.key);
                    if (this.name.indexOf("3DES") === 0 && p.length() !== 24)
                        throw new Error("Invalid Triple-DES key size: " + 8 * p.length());
                    this._keys = function (g) { for (var b, I = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], v = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], R = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], _ = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], k = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], x = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], M = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], N = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], S = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], T = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], B = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], P = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], L = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], j = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], D = g.length() > 8 ? 3 : 1, G = [], W = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], X = 0, Q = 0; Q < D; Q++) {
                        var K = g.getInt32(), F = g.getInt32();
                        K ^= (b = 252645135 & (K >>> 4 ^ F)) << 4, K ^= b = 65535 & ((F ^= b) >>> -16 ^ K), K ^= (b = 858993459 & (K >>> 2 ^ (F ^= b << -16))) << 2, K ^= b = 65535 & ((F ^= b) >>> -16 ^ K), K ^= (b = 1431655765 & (K >>> 1 ^ (F ^= b << -16))) << 1, K ^= b = 16711935 & ((F ^= b) >>> 8 ^ K), b = (K ^= (b = 1431655765 & (K >>> 1 ^ (F ^= b << 8))) << 1) << 8 | (F ^= b) >>> 20 & 240, K = F << 24 | F << 8 & 16711680 | F >>> 8 & 65280 | F >>> 24 & 240, F = b;
                        for (var Y = 0; Y < W.length; ++Y) {
                            W[Y] ? (K = K << 2 | K >>> 26, F = F << 2 | F >>> 26) : (K = K << 1 | K >>> 27, F = F << 1 | F >>> 27);
                            var $ = I[(K &= -15) >>> 28] | v[K >>> 24 & 15] | R[K >>> 20 & 15] | _[K >>> 16 & 15] | k[K >>> 12 & 15] | x[K >>> 8 & 15] | M[K >>> 4 & 15], y = N[(F &= -15) >>> 28] | S[F >>> 24 & 15] | T[F >>> 20 & 15] | B[F >>> 16 & 15] | P[F >>> 12 & 15] | L[F >>> 8 & 15] | j[F >>> 4 & 15];
                            b = 65535 & (y >>> 16 ^ $), G[X++] = $ ^ b, G[X++] = y ^ b << 16;
                        }
                    } return G; }(p), this._init = !0;
                } }, r("DES-ECB", d.cipher.modes.ecb), r("DES-CBC", d.cipher.modes.cbc), r("DES-CFB", d.cipher.modes.cfb), r("DES-OFB", d.cipher.modes.ofb), r("DES-CTR", d.cipher.modes.ctr), r("3DES-ECB", d.cipher.modes.ecb), r("3DES-CBC", d.cipher.modes.cbc), r("3DES-CFB", d.cipher.modes.cfb), r("3DES-OFB", d.cipher.modes.ofb), r("3DES-CTR", d.cipher.modes.ctr);
                var e = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], c = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], n = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], t = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], s = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], u = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], i = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], o = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
                function h(l, p, g, b) { var I, v, R = l.length === 32 ? 3 : 9; I = R === 3 ? b ? [30, -2, -2] : [0, 32, 2] : b ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2]; var _ = p[0], k = p[1]; _ ^= (v = 252645135 & (_ >>> 4 ^ k)) << 4, _ ^= (v = 65535 & (_ >>> 16 ^ (k ^= v))) << 16, _ ^= v = 858993459 & ((k ^= v) >>> 2 ^ _), _ ^= v = 16711935 & ((k ^= v << 2) >>> 8 ^ _), _ = (_ ^= (v = 1431655765 & (_ >>> 1 ^ (k ^= v << 8))) << 1) << 1 | _ >>> 31, k = (k ^= v) << 1 | k >>> 31; for (var x = 0; x < R; x += 3) {
                    for (var M = I[x + 1], N = I[x + 2], S = I[x]; S != M; S += N) {
                        var T = k ^ l[S], B = (k >>> 4 | k << 28) ^ l[S + 1];
                        v = _, _ = k, k = v ^ (c[T >>> 24 & 63] | t[T >>> 16 & 63] | u[T >>> 8 & 63] | o[63 & T] | e[B >>> 24 & 63] | n[B >>> 16 & 63] | s[B >>> 8 & 63] | i[63 & B]);
                    }
                    v = _, _ = k, k = v;
                } k = k >>> 1 | k << 31, k ^= v = 1431655765 & ((_ = _ >>> 1 | _ << 31) >>> 1 ^ k), k ^= (v = 16711935 & (k >>> 8 ^ (_ ^= v << 1))) << 8, k ^= (v = 858993459 & (k >>> 2 ^ (_ ^= v))) << 2, k ^= v = 65535 & ((_ ^= v) >>> 16 ^ k), k ^= v = 252645135 & ((_ ^= v << 16) >>> 4 ^ k), _ ^= v << 4, g[0] = _, g[1] = k; }
                function a(l) { var p, g = "DES-" + ((l = l || {}).mode || "CBC").toUpperCase(), b = (p = l.decrypt ? d.cipher.createDecipher(g, l.key) : d.cipher.createCipher(g, l.key)).start; return p.start = function (I, v) { var R = null; v instanceof d.util.ByteBuffer && (R = v, v = {}), (v = v || {}).output = R, v.iv = I, b.call(p, v); }, p; }
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14);
                var r = E.exports = d.pem = d.pem || {};
                function e(n) {
                    for (var t = n.name + ": ", s = [], u = function (l, p) { return " " + p; }, i = 0; i < n.values.length; ++i)
                        s.push(n.values[i].replace(/^(\S+\r\n)/, u));
                    t += s.join(",") + `\r
`;
                    var o = 0, h = -1;
                    for (i = 0; i < t.length; ++i, ++o)
                        if (o > 65 && h !== -1) {
                            var a = t[h];
                            a === "," ? (++h, t = t.substr(0, h) + `\r
 ` + t.substr(h)) : t = t.substr(0, h) + `\r
` + a + t.substr(h + 1), o = i - h - 1, h = -1, ++i;
                        }
                        else
                            t[i] !== " " && t[i] !== "	" && t[i] !== "," || (h = i);
                    return t;
                }
                function c(n) { return n.replace(/^\s+/, ""); }
                r.encode = function (n, t) {
                    t = t || {};
                    var s, u = "-----BEGIN " + n.type + `-----\r
`;
                    if (n.procType && (u += e(s = { name: "Proc-Type", values: [String(n.procType.version), n.procType.type] })), n.contentDomain && (u += e(s = { name: "Content-Domain", values: [n.contentDomain] })), n.dekInfo && (s = { name: "DEK-Info", values: [n.dekInfo.algorithm] }, n.dekInfo.parameters && s.values.push(n.dekInfo.parameters), u += e(s)), n.headers)
                        for (var i = 0; i < n.headers.length; ++i)
                            u += e(n.headers[i]);
                    return n.procType && (u += `\r
`), u += d.util.encode64(n.body, t.maxline || 64) + `\r
`, u += "-----END " + n.type + `-----\r
`;
                }, r.decode = function (n) { for (var t, s = [], u = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, i = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, o = /\r?\n/; t = u.exec(n);) {
                    var h = { type: t[1], procType: null, contentDomain: null, dekInfo: null, headers: [], body: d.util.decode64(t[3]) };
                    if (s.push(h), t[2]) {
                        for (var a = t[2].split(o), l = 0; t && l < a.length;) {
                            for (var p = a[l].replace(/\s+$/, ""), g = l + 1; g < a.length; ++g) {
                                var b = a[g];
                                if (!/\s/.test(b[0]))
                                    break;
                                p += b, l = g;
                            }
                            if (t = p.match(i)) {
                                for (var I = { name: t[1], values: [] }, v = t[2].split(","), R = 0; R < v.length; ++R)
                                    I.values.push(c(v[R]));
                                if (h.procType)
                                    if (h.contentDomain || I.name !== "Content-Domain")
                                        if (h.dekInfo || I.name !== "DEK-Info")
                                            h.headers.push(I);
                                        else {
                                            if (I.values.length === 0)
                                                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                                            h.dekInfo = { algorithm: v[0], parameters: v[1] || null };
                                        }
                                    else
                                        h.contentDomain = v[0] || "";
                                else {
                                    if (I.name !== "Proc-Type")
                                        throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                                    if (I.values.length !== 2)
                                        throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                                    h.procType = { version: v[0], type: v[1] };
                                }
                            }
                            ++l;
                        }
                        if (h.procType === "ENCRYPTED" && !h.dekInfo)
                            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
                    }
                } if (s.length === 0)
                    throw new Error("Invalid PEM formatted message."); return s; };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(49), f(14);
                var r = E.exports = d.sha512 = d.sha512 || {};
                d.md.sha512 = d.md.algorithms.sha512 = r;
                var e = d.sha384 = d.sha512.sha384 = d.sha512.sha384 || {};
                e.create = function () { return r.create("SHA-384"); }, d.md.sha384 = d.md.algorithms.sha384 = e, d.sha512.sha256 = d.sha512.sha256 || { create: function () { return r.create("SHA-512/256"); } }, d.md["sha512/256"] = d.md.algorithms["sha512/256"] = d.sha512.sha256, d.sha512.sha224 = d.sha512.sha224 || { create: function () { return r.create("SHA-512/224"); } }, d.md["sha512/224"] = d.md.algorithms["sha512/224"] = d.sha512.sha224, r.create = function (i) { if (n || (c = String.fromCharCode(128), c += d.util.fillString(String.fromCharCode(0), 128), t = [[1116352408, 3609767458], [1899447441, 602891725], [3049323471, 3964484399], [3921009573, 2173295548], [961987163, 4081628472], [1508970993, 3053834265], [2453635748, 2937671579], [2870763221, 3664609560], [3624381080, 2734883394], [310598401, 1164996542], [607225278, 1323610764], [1426881987, 3590304994], [1925078388, 4068182383], [2162078206, 991336113], [2614888103, 633803317], [3248222580, 3479774868], [3835390401, 2666613458], [4022224774, 944711139], [264347078, 2341262773], [604807628, 2007800933], [770255983, 1495990901], [1249150122, 1856431235], [1555081692, 3175218132], [1996064986, 2198950837], [2554220882, 3999719339], [2821834349, 766784016], [2952996808, 2566594879], [3210313671, 3203337956], [3336571891, 1034457026], [3584528711, 2466948901], [113926993, 3758326383], [338241895, 168717936], [666307205, 1188179964], [773529912, 1546045734], [1294757372, 1522805485], [1396182291, 2643833823], [1695183700, 2343527390], [1986661051, 1014477480], [2177026350, 1206759142], [2456956037, 344077627], [2730485921, 1290863460], [2820302411, 3158454273], [3259730800, 3505952657], [3345764771, 106217008], [3516065817, 3606008344], [3600352804, 1432725776], [4094571909, 1467031594], [275423344, 851169720], [430227734, 3100823752], [506948616, 1363258195], [659060556, 3750685593], [883997877, 3785050280], [958139571, 3318307427], [1322822218, 3812723403], [1537002063, 2003034995], [1747873779, 3602036899], [1955562222, 1575990012], [2024104815, 1125592928], [2227730452, 2716904306], [2361852424, 442776044], [2428436474, 593698344], [2756734187, 3733110249], [3204031479, 2999351573], [3329325298, 3815920427], [3391569614, 3928383900], [3515267271, 566280711], [3940187606, 3454069534], [4118630271, 4000239992], [116418474, 1914138554], [174292421, 2731055270], [289380356, 3203993006], [460393269, 320620315], [685471733, 587496836], [852142971, 1086792851], [1017036298, 365543100], [1126000580, 2618297676], [1288033470, 3409855158], [1501505948, 4234509866], [1607167915, 987167468], [1816402316, 1246189591]], (s = {})["SHA-512"] = [[1779033703, 4089235720], [3144134277, 2227873595], [1013904242, 4271175723], [2773480762, 1595750129], [1359893119, 2917565137], [2600822924, 725511199], [528734635, 4215389547], [1541459225, 327033209]], s["SHA-384"] = [[3418070365, 3238371032], [1654270250, 914150663], [2438529370, 812702999], [355462360, 4144912697], [1731405415, 4290775857], [2394180231, 1750603025], [3675008525, 1694076839], [1203062813, 3204075428]], s["SHA-512/256"] = [[573645204, 4230739756], [2673172387, 3360449730], [596883563, 1867755857], [2520282905, 1497426621], [2519219938, 2827943907], [3193839141, 1401305490], [721525244, 746961066], [246885852, 2177182882]], s["SHA-512/224"] = [[2352822216, 424955298], [1944164710, 2312950998], [502970286, 855612546], [1738396948, 1479516111], [258812777, 2077511080], [2011393907, 79989058], [1067287976, 1780299464], [286451373, 2446758561]], n = !0), i === void 0 && (i = "SHA-512"), !(i in s))
                    throw new Error("Invalid SHA-512 algorithm: " + i); for (var o = s[i], h = null, a = d.util.createBuffer(), l = new Array(80), p = 0; p < 80; ++p)
                    l[p] = new Array(2); var g = 64; switch (i) {
                    case "SHA-384":
                        g = 48;
                        break;
                    case "SHA-512/256":
                        g = 32;
                        break;
                    case "SHA-512/224": g = 28;
                } var b = { algorithm: i.replace("-", "").toLowerCase(), blockLength: 128, digestLength: g, messageLength: 0, fullMessageLength: null, messageLengthSize: 16, start: function () { b.messageLength = 0, b.fullMessageLength = b.messageLength128 = []; for (var I = b.messageLengthSize / 4, v = 0; v < I; ++v)
                        b.fullMessageLength.push(0); for (a = d.util.createBuffer(), h = new Array(o.length), v = 0; v < o.length; ++v)
                        h[v] = o[v].slice(0); return b; } }; return b.start(), b.update = function (I, v) { v === "utf8" && (I = d.util.encodeUtf8(I)); var R = I.length; b.messageLength += R, R = [R / 4294967296 >>> 0, R >>> 0]; for (var _ = b.fullMessageLength.length - 1; _ >= 0; --_)
                    b.fullMessageLength[_] += R[1], R[1] = R[0] + (b.fullMessageLength[_] / 4294967296 >>> 0), b.fullMessageLength[_] = b.fullMessageLength[_] >>> 0, R[0] = R[1] / 4294967296 >>> 0; return a.putBytes(I), u(h, l, a), (a.read > 2048 || a.length() === 0) && a.compact(), b; }, b.digest = function () { var I = d.util.createBuffer(); I.putBytes(a.bytes()); var v, R = b.fullMessageLength[b.fullMessageLength.length - 1] + b.messageLengthSize & b.blockLength - 1; I.putBytes(c.substr(0, b.blockLength - R)); for (var _ = 8 * b.fullMessageLength[0], k = 0; k < b.fullMessageLength.length - 1; ++k)
                    _ += (v = 8 * b.fullMessageLength[k + 1]) / 4294967296 >>> 0, I.putInt32(_ >>> 0), _ = v >>> 0; I.putInt32(_); var x = new Array(h.length); for (k = 0; k < h.length; ++k)
                    x[k] = h[k].slice(0); u(x, l, I); var M, N = d.util.createBuffer(); for (M = i === "SHA-512" ? x.length : i === "SHA-384" ? x.length - 2 : x.length - 4, k = 0; k < M; ++k)
                    N.putInt32(x[k][0]), k === M - 1 && i === "SHA-512/224" || N.putInt32(x[k][1]); return N; }, b; };
                var c = null, n = !1, t = null, s = null;
                function u(i, o, h) { for (var a, l, p, g, b, I, v, R, _, k, x, M, N, S, T, B, P, L, j, D, G, W, X, Q, K, F, Y, $, y, C, A, U, z, w = h.length(); w >= 128;) {
                    for (Y = 0; Y < 16; ++Y)
                        o[Y][0] = h.getInt32() >>> 0, o[Y][1] = h.getInt32() >>> 0;
                    for (; Y < 80; ++Y)
                        a = ((($ = (C = o[Y - 2])[0]) >>> 19 | (y = C[1]) << 13) ^ (y >>> 29 | $ << 3) ^ $ >>> 6) >>> 0, l = (($ << 13 | y >>> 19) ^ (y << 3 | $ >>> 29) ^ ($ << 26 | y >>> 6)) >>> 0, p = ((($ = (U = o[Y - 15])[0]) >>> 1 | (y = U[1]) << 31) ^ ($ >>> 8 | y << 24) ^ $ >>> 7) >>> 0, g = (($ << 31 | y >>> 1) ^ ($ << 24 | y >>> 8) ^ ($ << 25 | y >>> 7)) >>> 0, A = o[Y - 7], z = o[Y - 16], y = l + A[1] + g + z[1], o[Y][0] = a + A[0] + p + z[0] + (y / 4294967296 >>> 0) >>> 0, o[Y][1] = y >>> 0;
                    for (x = i[0][0], M = i[0][1], N = i[1][0], S = i[1][1], T = i[2][0], B = i[2][1], P = i[3][0], L = i[3][1], j = i[4][0], D = i[4][1], G = i[5][0], W = i[5][1], X = i[6][0], Q = i[6][1], K = i[7][0], F = i[7][1], Y = 0; Y < 80; ++Y)
                        v = ((j >>> 14 | D << 18) ^ (j >>> 18 | D << 14) ^ (D >>> 9 | j << 23)) >>> 0, R = (X ^ j & (G ^ X)) >>> 0, b = ((x >>> 28 | M << 4) ^ (M >>> 2 | x << 30) ^ (M >>> 7 | x << 25)) >>> 0, I = ((x << 4 | M >>> 28) ^ (M << 30 | x >>> 2) ^ (M << 25 | x >>> 7)) >>> 0, _ = (x & N | T & (x ^ N)) >>> 0, k = (M & S | B & (M ^ S)) >>> 0, y = F + (((j << 18 | D >>> 14) ^ (j << 14 | D >>> 18) ^ (D << 23 | j >>> 9)) >>> 0) + ((Q ^ D & (W ^ Q)) >>> 0) + t[Y][1] + o[Y][1], a = K + v + R + t[Y][0] + o[Y][0] + (y / 4294967296 >>> 0) >>> 0, l = y >>> 0, p = b + _ + ((y = I + k) / 4294967296 >>> 0) >>> 0, g = y >>> 0, K = X, F = Q, X = G, Q = W, G = j, W = D, j = P + a + ((y = L + l) / 4294967296 >>> 0) >>> 0, D = y >>> 0, P = T, L = B, T = N, B = S, N = x, S = M, x = a + p + ((y = l + g) / 4294967296 >>> 0) >>> 0, M = y >>> 0;
                    y = i[0][1] + M, i[0][0] = i[0][0] + x + (y / 4294967296 >>> 0) >>> 0, i[0][1] = y >>> 0, y = i[1][1] + S, i[1][0] = i[1][0] + N + (y / 4294967296 >>> 0) >>> 0, i[1][1] = y >>> 0, y = i[2][1] + B, i[2][0] = i[2][0] + T + (y / 4294967296 >>> 0) >>> 0, i[2][1] = y >>> 0, y = i[3][1] + L, i[3][0] = i[3][0] + P + (y / 4294967296 >>> 0) >>> 0, i[3][1] = y >>> 0, y = i[4][1] + D, i[4][0] = i[4][0] + j + (y / 4294967296 >>> 0) >>> 0, i[4][1] = y >>> 0, y = i[5][1] + W, i[5][0] = i[5][0] + G + (y / 4294967296 >>> 0) >>> 0, i[5][1] = y >>> 0, y = i[6][1] + Q, i[6][0] = i[6][0] + X + (y / 4294967296 >>> 0) >>> 0, i[6][1] = y >>> 0, y = i[7][1] + F, i[7][0] = i[7][0] + K + (y / 4294967296 >>> 0) >>> 0, i[7][1] = y >>> 0, w -= 128;
                } }
            }, function (E, m, f) {
                "use strict";
                f(14), f(104);
                const d = f(8), r = f(6), e = f(5), c = f(31);
                m.bigIntegerToUintBase64url = (n, t) => { let s = Uint8Array.from(n.abs().toByteArray()); if (s = s[0] === 0 ? s.slice(1) : s, t != null) {
                    if (s.length > t)
                        throw new Error("byte array longer than desired length");
                    s = c([new Uint8Array(t - s.length), s]);
                } return e(s, "base64url"); }, m.base64urlToBigInteger = n => { const t = m.base64urlToBuffer(n); return new d.jsbn.BigInteger(e(t, "base16"), 16); }, m.base64urlToBuffer = (n, t) => { let s = r(n, "base64urlpad"); if (t != null) {
                    if (s.length > t)
                        throw new Error("byte array longer than desired length");
                    s = c([new Uint8Array(t - s.length), s]);
                } return s; };
            }, function (E, m, f) {
                "use strict";
                const d = f(25), r = f(231);
                E.exports = { export: async function (e, c) { const n = r.create(), t = await n.encrypt(e, c); return d.names.base64.encode(t); } };
            }, function (E, m, f) {
                "use strict";
                var d, r = m, e = f(150), c = f(235), n = f(33).assert;
                function t(u) { u.type === "short" ? this.curve = new c.short(u) : u.type === "edwards" ? this.curve = new c.edwards(u) : this.curve = new c.mont(u), this.g = this.curve.g, this.n = this.curve.n, this.hash = u.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O"); }
                function s(u, i) { Object.defineProperty(r, u, { configurable: !0, enumerable: !0, get: function () { var o = new t(i); return Object.defineProperty(r, u, { configurable: !0, enumerable: !0, value: o }), o; } }); }
                r.PresetCurve = t, s("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: e.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }), s("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: e.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }), s("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: e.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }), s("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: e.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }), s("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: e.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }), s("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: e.sha256, gRed: !1, g: ["9"] }), s("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: e.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
                try {
                    d = f(483);
                }
                catch (u) {
                    d = void 0;
                }
                s("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: e.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", d] });
            }, function (E, m, f) {
                "use strict";
                var d = m;
                d.utils = f(36), d.common = f(85), d.sha = f(477), d.ripemd = f(481), d.hmac = f(482), d.sha1 = d.sha.sha1, d.sha256 = d.sha.sha256, d.sha224 = d.sha.sha224, d.sha384 = d.sha.sha384, d.sha512 = d.sha.sha512, d.ripemd160 = d.ripemd.ripemd160;
            }, function (E, m, f) {
                "use strict";
                const d = f(520), r = f(521), e = f(245);
                m.utf8Encoder = new r("utf8"), m.utf8Decoder = new e("utf8"), m.filter = (c, n) => async function* () { for await (const t of c)
                    await n(t) && (yield t); }(), m.sortAll = (c, n) => async function* () { let t = []; for await (const s of c)
                    t.push(s); t = await n(t); for (const s of t)
                    yield s; }(), m.take = (c, n) => async function* () { if (n <= 0)
                    return; let t = 0; for await (const s of c)
                    if (yield s, t++, t >= n)
                        return; }(), m.map = (c, n) => async function* () { for await (const t of c)
                    yield n(t); }(), m.replaceStartWith = function (c, n) { const t = new RegExp("^" + n); return c.replace(t, ""); }, m.tmpdir = d;
            }, function (E, m, f) {
                "use strict";
                var d = f(523);
                function r(e, c, n) { var t = this; this._started = d(), this._rescheduled = 0, this._scheduled = c, this._args = n, this._timer = setTimeout(function s() { t._rescheduled > 0 ? (t._scheduled = t._rescheduled - (d() - t._started), t._timer = setTimeout(s, t._scheduled), t._rescheduled = 0) : e.apply(null, t._args); }, c); }
                r.prototype.reschedule = function (e) { var c = d(); return !(c + e - (this._started + this._scheduled) < 0) && (this._started = c, this._rescheduled = e, !0); }, r.prototype.clear = function () { clearTimeout(this._timer); }, E.exports = function () { if (typeof arguments[0] != "function")
                    throw new Error("callback needed"); if (typeof arguments[1] != "number")
                    throw new Error("timeout needed"); var e; if (arguments.length > 0) {
                    e = new Array(arguments.length - 2);
                    for (var c = 0; c < e.length; c++)
                        e[c] = arguments[c + 2];
                } return new r(arguments[0], arguments[1], e); };
            }, function (E, m, f) {
                "use strict";
                f.r(m), f.d(m, "default", function () { return r; });
                let d = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([a-z]*)/gi;
                function r(e = "", c = "ms") { var n = null; return (e = e.replace(/(\d),(\d)/g, "$1$2")).replace(d, function (t, s, u) { (u = r[u] || r[u.toLowerCase().replace(/s$/, "")]) && (n = (n || 0) + parseFloat(s, 10) * u); }), n && n / r[c]; }
                r.nanosecond = r.ns = 1e-6, r.\u00B5s = r.\u03BCs = r.us = r.microsecond = .001, r.millisecond = r.ms = 1, r.second = r.sec = r.s = 1e3 * r.ms, r.minute = r.min = r.m = 60 * r.s, r.hour = r.hr = r.h = 60 * r.m, r.day = r.d = 24 * r.h, r.week = r.wk = r.w = 7 * r.d, r.month = r.b = 30.4375 * r.d, r.year = r.yr = r.y = 365.25 * r.d;
            }, function (E, m, f) {
                "use strict";
                const { NotStartedError: d, AlreadyStartingError: r, AlreadyStartedError: e } = f(111), { withTimeout: c } = f(23);
                class n {
                    static create({ start: s, stop: u }) { return new n(s, u); }
                    static async start(s, u) { const { state: i, activate: o } = s; switch (i.status) {
                        case "stopped": try {
                            const h = o(u);
                            s.state = { status: "starting", ready: h };
                            const a = await h;
                            return s.state = { status: "started", value: a }, a;
                        }
                        catch (h) {
                            throw s.state = { status: "stopped" }, h;
                        }
                        case "starting": throw new r;
                        case "started": throw new e;
                        case "stopping": return await i.ready, await n.start(s, u);
                        default: return n.panic(s);
                    } }
                    static async stop(s) { const { state: u, deactivate: i } = s; switch (u.status) {
                        case "stopped": break;
                        case "starting":
                            try {
                                await u.ready;
                            }
                            catch (o) { }
                            return await n.stop(s);
                        case "stopping": return await u.ready;
                        case "started":
                            i && await i(u.value), s.state = { status: "stopped" };
                            break;
                        default: n.panic(u);
                    } }
                    static try({ state: s }) { switch (s.status) {
                        case "started": return s.value;
                        default: return null;
                    } }
                    static async use({ state: s }, u) { switch (s.status) {
                        case "started": return s.value;
                        case "starting": return await c(s.ready, u);
                        default: throw new d;
                    } }
                    static panic({ state: s }) { const u = JSON.stringify({ status: s.status }); throw RangeError(`Service in invalid state ${u}, should never happen if you see this please report a bug`); }
                    constructor(s, u) { this.activate = s, this.deactivate = u, this.state = { status: "stopped" }; }
                    async use(s) { return await n.use(this, s); }
                    try() { return n.try(this); }
                }
                E.exports = n;
            }, function (E, m, f) {
                "use strict";
                m.util = f(260), m.resolver = f(557), m.codec = m.util.codec, m.defaultHashAlg = m.util.defaultHashAlg;
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(30).BigNumber, e = f(113), c = e.SHIFT32, n = e.SHIFT16;
                m.parseHalf = function (t) { var s, u, i; return i = 128 & t[0] ? -1 : 1, s = (124 & t[0]) >> 2, u = (3 & t[0]) << 8 | t[1], s ? s === 31 ? i * (u ? NaN : Infinity) : i * Math.pow(2, s - 25) * (1024 + u) : 5960464477539063e-23 * i * u; }, m.arrayBufferToBignumber = function (t) { const s = t.byteLength; let u = ""; for (let o = 0; o < s; o++)
                    u += (i = t[o]) < 16 ? "0" + i.toString(16) : i.toString(16); var i; return new r(u, 16); }, m.buildMap = t => { const s = new Map, u = Object.keys(t), i = u.length; for (let o = 0; o < i; o++)
                    s.set(u[o], t[u[o]]); return s; }, m.buildInt32 = (t, s) => t * n + s, m.buildInt64 = (t, s, u, i) => { const o = m.buildInt32(t, s), h = m.buildInt32(u, i); return o > 2097151 ? new r(o).times(c).plus(h) : o * c + h; }, m.writeHalf = function (t, s) { const u = d.allocUnsafe(4); u.writeFloatBE(s, 0); const i = u.readUInt32BE(0); if ((8191 & i) != 0)
                    return !1; var o = i >> 16 & 32768; const h = i >> 23 & 255, a = 8388607 & i; if (h >= 113 && h <= 142)
                    o += (h - 112 << 10) + (a >> 13);
                else {
                    if (!(h >= 103 && h < 113))
                        return !1;
                    if (a & (1 << 126 - h) - 1)
                        return !1;
                    o += a + 8388608 >> 126 - h;
                } return t.writeUInt16BE(o, 0), !0; }, m.keySorter = function (t, s) { var u = t[0].byteLength, i = s[0].byteLength; return u > i ? 1 : i > u ? -1 : t[0].compare(s[0]); }, m.isNegativeZero = t => t === 0 && 1 / t < 0, m.nextPowerOf2 = t => { let s = 0; if (t && !(t & t - 1))
                    return t; for (; t !== 0;)
                    t >>= 1, s += 1; return 1 << s; };
            }, function (E, m, f) {
                "use strict";
                (m = E.exports = f(268)).Stream = m, m.Readable = m, m.Writable = f(158), m.Duplex = f(53), m.Transform = f(272), m.PassThrough = f(562);
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e = f(114); function c(M) { var N = this; this.next = null, this.entry = null, this.finish = function () { !function (S, T, B) { var P = S.entry; for (S.entry = null; P;) {
                    var L = P.callback;
                    T.pendingcb--, L(B), P = P.next;
                } T.corkedRequestsFree ? T.corkedRequestsFree.next = S : T.corkedRequestsFree = S; }(N, M); }; } E.exports = b; var n, t = !d.browser && ["v0.10", "v0.9."].indexOf(d.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick; b.WritableState = g; var s = Object.create(f(89)); s.inherits = f(15); var u = { deprecate: f(159) }, i = f(269), o = f(115).Buffer, h = r.Uint8Array || function () { }, a, l = f(270); function p() { } function g(M, N) { n = n || f(53), M = M || {}; var S = N instanceof n; this.objectMode = !!M.objectMode, S && (this.objectMode = this.objectMode || !!M.writableObjectMode); var T = M.highWaterMark, B = M.writableHighWaterMark, P = this.objectMode ? 16 : 16384; this.highWaterMark = T || T === 0 ? T : S && (B || B === 0) ? B : P, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var L = M.decodeStrings === !1; this.decodeStrings = !L, this.defaultEncoding = M.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (j) { !function (D, G) { var W = D._writableState, X = W.sync, Q = W.writecb; if (function (F) { F.writing = !1, F.writecb = null, F.length -= F.writelen, F.writelen = 0; }(W), G)
                    !function (F, Y, $, y, C) { --Y.pendingcb, $ ? (e.nextTick(C, y), e.nextTick(x, F, Y), F._writableState.errorEmitted = !0, F.emit("error", y)) : (C(y), F._writableState.errorEmitted = !0, F.emit("error", y), x(F, Y)); }(D, W, X, G, Q);
                else {
                    var K = _(W);
                    K || W.corked || W.bufferProcessing || !W.bufferedRequest || R(D, W), X ? t(v, D, W, K, Q) : v(D, W, K, Q);
                } }(N, j); }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new c(this); } function b(M) { if (n = n || f(53), !(a.call(b, this) || this instanceof n))
                    return new b(M); this._writableState = new g(M, this), this.writable = !0, M && (typeof M.write == "function" && (this._write = M.write), typeof M.writev == "function" && (this._writev = M.writev), typeof M.destroy == "function" && (this._destroy = M.destroy), typeof M.final == "function" && (this._final = M.final)), i.call(this); } function I(M, N, S, T, B, P, L) { N.writelen = T, N.writecb = L, N.writing = !0, N.sync = !0, S ? M._writev(B, N.onwrite) : M._write(B, P, N.onwrite), N.sync = !1; } function v(M, N, S, T) { S || function (B, P) { P.length === 0 && P.needDrain && (P.needDrain = !1, B.emit("drain")); }(M, N), N.pendingcb--, T(), x(M, N); } function R(M, N) { N.bufferProcessing = !0; var S = N.bufferedRequest; if (M._writev && S && S.next) {
                    var T = N.bufferedRequestCount, B = new Array(T), P = N.corkedRequestsFree;
                    P.entry = S;
                    for (var L = 0, j = !0; S;)
                        B[L] = S, S.isBuf || (j = !1), S = S.next, L += 1;
                    B.allBuffers = j, I(M, N, !0, N.length, B, "", P.finish), N.pendingcb++, N.lastBufferedRequest = null, P.next ? (N.corkedRequestsFree = P.next, P.next = null) : N.corkedRequestsFree = new c(N), N.bufferedRequestCount = 0;
                }
                else {
                    for (; S;) {
                        var D = S.chunk, G = S.encoding, W = S.callback;
                        if (I(M, N, !1, N.objectMode ? 1 : D.length, D, G, W), S = S.next, N.bufferedRequestCount--, N.writing)
                            break;
                    }
                    S === null && (N.lastBufferedRequest = null);
                } N.bufferedRequest = S, N.bufferProcessing = !1; } function _(M) { return M.ending && M.length === 0 && M.bufferedRequest === null && !M.finished && !M.writing; } function k(M, N) { M._final(function (S) { N.pendingcb--, S && M.emit("error", S), N.prefinished = !0, M.emit("prefinish"), x(M, N); }); } function x(M, N) { var S = _(N); return S && (!function (T, B) { B.prefinished || B.finalCalled || (typeof T._final == "function" ? (B.pendingcb++, B.finalCalled = !0, e.nextTick(k, T, B)) : (B.prefinished = !0, T.emit("prefinish"))); }(M, N), N.pendingcb === 0 && (N.finished = !0, M.emit("finish"))), S; } s.inherits(b, i), g.prototype.getBuffer = function () { for (var M = this.bufferedRequest, N = []; M;)
                    N.push(M), M = M.next; return N; }, function () { try {
                    Object.defineProperty(g.prototype, "buffer", { get: u.deprecate(function () { return this.getBuffer(); }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
                }
                catch (M) { } }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (a = Function.prototype[Symbol.hasInstance], Object.defineProperty(b, Symbol.hasInstance, { value: function (M) { return !!a.call(this, M) || this === b && M && M._writableState instanceof g; } })) : a = function (M) { return M instanceof this; }, b.prototype.pipe = function () { this.emit("error", new Error("Cannot pipe, not readable")); }, b.prototype.write = function (M, N, S) { var T, B = this._writableState, P = !1, L = !B.objectMode && (T = M, o.isBuffer(T) || T instanceof h); return L && !o.isBuffer(M) && (M = function (j) { return o.from(j); }(M)), typeof N == "function" && (S = N, N = null), L ? N = "buffer" : N || (N = B.defaultEncoding), typeof S != "function" && (S = p), B.ended ? function (j, D) { var G = new Error("write after end"); j.emit("error", G), e.nextTick(D, G); }(this, S) : (L || function (j, D, G, W) { var X = !0, Q = !1; return G === null ? Q = new TypeError("May not write null values to stream") : typeof G == "string" || G === void 0 || D.objectMode || (Q = new TypeError("Invalid non-string/buffer chunk")), Q && (j.emit("error", Q), e.nextTick(W, Q), X = !1), X; }(this, B, M, S)) && (B.pendingcb++, P = function (j, D, G, W, X, Q) { if (!G) {
                    var K = function (y, C, A) { return y.objectMode || y.decodeStrings === !1 || typeof C != "string" || (C = o.from(C, A)), C; }(D, W, X);
                    W !== K && (G = !0, X = "buffer", W = K);
                } var F = D.objectMode ? 1 : W.length; D.length += F; var Y = D.length < D.highWaterMark; if (Y || (D.needDrain = !0), D.writing || D.corked) {
                    var $ = D.lastBufferedRequest;
                    D.lastBufferedRequest = { chunk: W, encoding: X, isBuf: G, callback: Q, next: null }, $ ? $.next = D.lastBufferedRequest : D.bufferedRequest = D.lastBufferedRequest, D.bufferedRequestCount += 1;
                }
                else
                    I(j, D, !1, F, W, X, Q); return Y; }(this, B, L, M, N, S)), P; }, b.prototype.cork = function () { this._writableState.corked++; }, b.prototype.uncork = function () { var M = this._writableState; M.corked && (M.corked--, M.writing || M.corked || M.finished || M.bufferProcessing || !M.bufferedRequest || R(this, M)); }, b.prototype.setDefaultEncoding = function (M) { if (typeof M == "string" && (M = M.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((M + "").toLowerCase()) > -1))
                    throw new TypeError("Unknown encoding: " + M); return this._writableState.defaultEncoding = M, this; }, Object.defineProperty(b.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), b.prototype._write = function (M, N, S) { S(new Error("_write() is not implemented")); }, b.prototype._writev = null, b.prototype.end = function (M, N, S) { var T = this._writableState; typeof M == "function" ? (S = M, M = null, N = null) : typeof N == "function" && (S = N, N = null), M != null && this.write(M, N), T.corked && (T.corked = 1, this.uncork()), T.ending || T.finished || function (B, P, L) { P.ending = !0, x(B, P), L && (P.finished ? e.nextTick(L) : B.once("finish", L)), P.ended = !0, B.writable = !1; }(this, T, S); }, Object.defineProperty(b.prototype, "destroyed", { get: function () { return this._writableState !== void 0 && this._writableState.destroyed; }, set: function (M) { this._writableState && (this._writableState.destroyed = M); } }), b.prototype.destroy = l.destroy, b.prototype._undestroy = l.undestroy, b.prototype._destroy = function (M, N) { this.end(), N(M); }; }).call(this, f(9), f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(e) { try {
                    if (!d.localStorage)
                        return !1;
                }
                catch (n) {
                    return !1;
                } var c = d.localStorage[e]; return c != null && String(c).toLowerCase() === "true"; } E.exports = function (e, c) { if (r("noDeprecation"))
                    return e; var n = !1; return function () { if (!n) {
                    if (r("throwDeprecation"))
                        throw new Error(c);
                    r("traceDeprecation") ? console.trace(c) : console.warn(c), n = !0;
                } return e.apply(this, arguments); }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = f(30).BigNumber, r = f(65), e = f(161), c = new d(-1), n = new d(10), t = new d(2);
                class s {
                    constructor(i, o, h) { if (this.tag = i, this.value = o, this.err = h, typeof this.tag != "number")
                        throw new Error("Invalid tag type (" + typeof this.tag + ")"); if (this.tag < 0 || (0 | this.tag) !== this.tag)
                        throw new Error("Tag must be a positive integer: " + this.tag); }
                    toString() { return `${this.tag}(${JSON.stringify(this.value)})`; }
                    encodeCBOR(i) { return i._pushTag(this.tag), i.pushAny(this.value); }
                    convert(i) { let o = i != null ? i[this.tag] : void 0; if (typeof o != "function" && (o = s["_tag_" + this.tag], typeof o != "function"))
                        return this; try {
                        return o.call(s, this.value);
                    }
                    catch (h) {
                        return this.err = h, this;
                    } }
                    static _tag_0(i) { return new Date(i); }
                    static _tag_1(i) { return new Date(1e3 * i); }
                    static _tag_2(i) { return r.bufferToBignumber(i); }
                    static _tag_3(i) { return c.minus(r.bufferToBignumber(i)); }
                    static _tag_4(i) { return n.pow(i[0]).times(i[1]); }
                    static _tag_5(i) { return t.pow(i[0]).times(i[1]); }
                    static _tag_32(i) { return e.parse(i); }
                    static _tag_35(i) { return new RegExp(i); }
                }
                E.exports = s;
            }, function (E, m, f) {
                "use strict";
                var d = f(570), r = f(571);
                function e() { this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null; }
                m.parse = I, m.resolve = function (v, R) { return I(v, !1, !0).resolve(R); }, m.resolveObject = function (v, R) { return v ? I(v, !1, !0).resolveObject(R) : R; }, m.format = function (v) { return r.isString(v) && (v = I(v)), v instanceof e ? v.format() : e.prototype.format.call(v); }, m.Url = e;
                var c = /^([a-z0-9.+-]+:)/i, n = /:[0-9]*$/, t = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, s = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), u = ["'"].concat(s), i = ["%", "/", "?", ";", "#"].concat(u), o = ["/", "?", "#"], h = /^[+a-z0-9A-Z_-]{0,63}$/, a = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, l = { javascript: !0, "javascript:": !0 }, p = { javascript: !0, "javascript:": !0 }, g = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, b = f(572);
                function I(v, R, _) { if (v && r.isObject(v) && v instanceof e)
                    return v; var k = new e; return k.parse(v, R, _), k; }
                e.prototype.parse = function (v, R, _) { if (!r.isString(v))
                    throw new TypeError("Parameter 'url' must be a string, not " + typeof v); var k = v.indexOf("?"), x = k !== -1 && k < v.indexOf("#") ? "?" : "#", M = v.split(x); M[0] = M[0].replace(/\\/g, "/"); var N = v = M.join(x); if (N = N.trim(), !_ && v.split("#").length === 1) {
                    var S = t.exec(N);
                    if (S)
                        return this.path = N, this.href = N, this.pathname = S[1], S[2] ? (this.search = S[2], this.query = R ? b.parse(this.search.substr(1)) : this.search.substr(1)) : R && (this.search = "", this.query = {}), this;
                } var T = c.exec(N); if (T) {
                    var B = (T = T[0]).toLowerCase();
                    this.protocol = B, N = N.substr(T.length);
                } if (_ || T || N.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var P = N.substr(0, 2) === "//";
                    !P || T && p[T] || (N = N.substr(2), this.slashes = !0);
                } if (!p[T] && (P || T && !g[T])) {
                    for (var L, j, D = -1, G = 0; G < o.length; G++)
                        (W = N.indexOf(o[G])) !== -1 && (D === -1 || W < D) && (D = W);
                    for ((j = D === -1 ? N.lastIndexOf("@") : N.lastIndexOf("@", D)) !== -1 && (L = N.slice(0, j), N = N.slice(j + 1), this.auth = decodeURIComponent(L)), D = -1, G = 0; G < i.length; G++) {
                        var W;
                        (W = N.indexOf(i[G])) !== -1 && (D === -1 || W < D) && (D = W);
                    }
                    D === -1 && (D = N.length), this.host = N.slice(0, D), N = N.slice(D), this.parseHost(), this.hostname = this.hostname || "";
                    var X = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                    if (!X)
                        for (var Q = this.hostname.split(/\./), K = (G = 0, Q.length); G < K; G++) {
                            var F = Q[G];
                            if (F && !F.match(h)) {
                                for (var Y = "", $ = 0, y = F.length; $ < y; $++)
                                    F.charCodeAt($) > 127 ? Y += "x" : Y += F[$];
                                if (!Y.match(h)) {
                                    var C = Q.slice(0, G), A = Q.slice(G + 1), U = F.match(a);
                                    U && (C.push(U[1]), A.unshift(U[2])), A.length && (N = "/" + A.join(".") + N), this.hostname = C.join(".");
                                    break;
                                }
                            }
                        }
                    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), X || (this.hostname = d.toASCII(this.hostname));
                    var z = this.port ? ":" + this.port : "", w = this.hostname || "";
                    this.host = w + z, this.href += this.host, X && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), N[0] !== "/" && (N = "/" + N));
                } if (!l[B])
                    for (G = 0, K = u.length; G < K; G++) {
                        var O = u[G];
                        if (N.indexOf(O) !== -1) {
                            var q = encodeURIComponent(O);
                            q === O && (q = escape(O)), N = N.split(O).join(q);
                        }
                    } var H = N.indexOf("#"); H !== -1 && (this.hash = N.substr(H), N = N.slice(0, H)); var V = N.indexOf("?"); if (V !== -1 ? (this.search = N.substr(V), this.query = N.substr(V + 1), R && (this.query = b.parse(this.query)), N = N.slice(0, V)) : R && (this.search = "", this.query = {}), N && (this.pathname = N), g[B] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                    z = this.pathname || "";
                    var J = this.search || "";
                    this.path = z + J;
                } return this.href = this.format(), this; }, e.prototype.format = function () { var v = this.auth || ""; v && (v = (v = encodeURIComponent(v)).replace(/%3A/i, ":"), v += "@"); var R = this.protocol || "", _ = this.pathname || "", k = this.hash || "", x = !1, M = ""; this.host ? x = v + this.host : this.hostname && (x = v + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (x += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (M = b.stringify(this.query)); var N = this.search || M && "?" + M || ""; return R && R.substr(-1) !== ":" && (R += ":"), this.slashes || (!R || g[R]) && x !== !1 ? (x = "//" + (x || ""), _ && _.charAt(0) !== "/" && (_ = "/" + _)) : x || (x = ""), k && k.charAt(0) !== "#" && (k = "#" + k), N && N.charAt(0) !== "?" && (N = "?" + N), R + x + (_ = _.replace(/[?#]/g, function (S) { return encodeURIComponent(S); })) + (N = N.replace("#", "%23")) + k; }, e.prototype.resolve = function (v) { return this.resolveObject(I(v, !1, !0)).format(); }, e.prototype.resolveObject = function (v) { if (r.isString(v)) {
                    var R = new e;
                    R.parse(v, !1, !0), v = R;
                } for (var _ = new e, k = Object.keys(this), x = 0; x < k.length; x++) {
                    var M = k[x];
                    _[M] = this[M];
                } if (_.hash = v.hash, v.href === "")
                    return _.href = _.format(), _; if (v.slashes && !v.protocol) {
                    for (var N = Object.keys(v), S = 0; S < N.length; S++) {
                        var T = N[S];
                        T !== "protocol" && (_[T] = v[T]);
                    }
                    return g[_.protocol] && _.hostname && !_.pathname && (_.path = _.pathname = "/"), _.href = _.format(), _;
                } if (v.protocol && v.protocol !== _.protocol) {
                    if (!g[v.protocol]) {
                        for (var B = Object.keys(v), P = 0; P < B.length; P++) {
                            var L = B[P];
                            _[L] = v[L];
                        }
                        return _.href = _.format(), _;
                    }
                    if (_.protocol = v.protocol, v.host || p[v.protocol])
                        _.pathname = v.pathname;
                    else {
                        for (var j = (v.pathname || "").split("/"); j.length && !(v.host = j.shift());)
                            ;
                        v.host || (v.host = ""), v.hostname || (v.hostname = ""), j[0] !== "" && j.unshift(""), j.length < 2 && j.unshift(""), _.pathname = j.join("/");
                    }
                    if (_.search = v.search, _.query = v.query, _.host = v.host || "", _.auth = v.auth, _.hostname = v.hostname || v.host, _.port = v.port, _.pathname || _.search) {
                        var D = _.pathname || "", G = _.search || "";
                        _.path = D + G;
                    }
                    return _.slashes = _.slashes || v.slashes, _.href = _.format(), _;
                } var W = _.pathname && _.pathname.charAt(0) === "/", X = v.host || v.pathname && v.pathname.charAt(0) === "/", Q = X || W || _.host && v.pathname, K = Q, F = _.pathname && _.pathname.split("/") || [], Y = (j = v.pathname && v.pathname.split("/") || [], _.protocol && !g[_.protocol]); if (Y && (_.hostname = "", _.port = null, _.host && (F[0] === "" ? F[0] = _.host : F.unshift(_.host)), _.host = "", v.protocol && (v.hostname = null, v.port = null, v.host && (j[0] === "" ? j[0] = v.host : j.unshift(v.host)), v.host = null), Q = Q && (j[0] === "" || F[0] === "")), X)
                    _.host = v.host || v.host === "" ? v.host : _.host, _.hostname = v.hostname || v.hostname === "" ? v.hostname : _.hostname, _.search = v.search, _.query = v.query, F = j;
                else if (j.length)
                    F || (F = []), F.pop(), F = F.concat(j), _.search = v.search, _.query = v.query;
                else if (!r.isNullOrUndefined(v.search))
                    return Y && (_.hostname = _.host = F.shift(), (U = !!(_.host && _.host.indexOf("@") > 0) && _.host.split("@")) && (_.auth = U.shift(), _.host = _.hostname = U.shift())), _.search = v.search, _.query = v.query, r.isNull(_.pathname) && r.isNull(_.search) || (_.path = (_.pathname ? _.pathname : "") + (_.search ? _.search : "")), _.href = _.format(), _; if (!F.length)
                    return _.pathname = null, _.search ? _.path = "/" + _.search : _.path = null, _.href = _.format(), _; for (var $ = F.slice(-1)[0], y = (_.host || v.host || F.length > 1) && ($ === "." || $ === "..") || $ === "", C = 0, A = F.length; A >= 0; A--)
                    ($ = F[A]) === "." ? F.splice(A, 1) : $ === ".." ? (F.splice(A, 1), C++) : C && (F.splice(A, 1), C--); if (!Q && !K)
                    for (; C--; C)
                        F.unshift(".."); !Q || F[0] === "" || F[0] && F[0].charAt(0) === "/" || F.unshift(""), y && F.join("/").substr(-1) !== "/" && F.push(""); var U, z = F[0] === "" || F[0] && F[0].charAt(0) === "/"; return Y && (_.hostname = _.host = z ? "" : F.length ? F.shift() : "", (U = !!(_.host && _.host.indexOf("@") > 0) && _.host.split("@")) && (_.auth = U.shift(), _.host = _.hostname = U.shift())), (Q = Q || _.host && F.length) && !z && F.unshift(""), F.length ? _.pathname = F.join("/") : (_.pathname = null, _.path = null), r.isNull(_.pathname) && r.isNull(_.search) || (_.path = (_.pathname ? _.pathname : "") + (_.search ? _.search : "")), _.auth = v.auth || _.auth, _.slashes = _.slashes || v.slashes, _.href = _.format(), _; }, e.prototype.parseHost = function () { var v = this.host, R = n.exec(v); R && ((R = R[0]) !== ":" && (this.port = R.substr(1)), v = v.substr(0, v.length - R.length)), v && (this.hostname = v); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(4);
                function e(c) { const n = { path: c.path == null ? c.cid : "" + c.path, recursive: c.recursive !== !1 }; return c.metadata != null && (n.metadata = c.metadata), n; }
                E.exports = async function* (c) { if (c == null)
                    throw d(new Error("Unexpected input: " + c), "ERR_UNEXPECTED_INPUT"); if (r.isCID(c))
                    yield e({ cid: c });
                else {
                    if (!(c instanceof String || typeof c == "string")) {
                        if (c.cid != null || c.path != null)
                            return yield e(c);
                        if (c[Symbol.iterator]) {
                            const n = c[Symbol.iterator](), t = n.next();
                            if (t.done)
                                return n;
                            if (r.isCID(t.value) || t.value instanceof String || typeof t.value == "string") {
                                yield e({ cid: t.value });
                                for (const s of n)
                                    yield e({ cid: s });
                                return;
                            }
                            if (t.value.cid != null || t.value.path != null) {
                                yield e(t.value);
                                for (const s of n)
                                    yield e(s);
                                return;
                            }
                            throw d(new Error("Unexpected input: " + typeof c), "ERR_UNEXPECTED_INPUT");
                        }
                        if (c[Symbol.asyncIterator]) {
                            const n = c[Symbol.asyncIterator](), t = await n.next();
                            if (t.done)
                                return n;
                            if (r.isCID(t.value) || t.value instanceof String || typeof t.value == "string") {
                                yield e({ cid: t.value });
                                for await (const s of n)
                                    yield e({ cid: s });
                                return;
                            }
                            if (t.value.cid != null || t.value.path != null) {
                                yield e(t.value);
                                for await (const s of n)
                                    yield e(s);
                                return;
                            }
                            throw d(new Error("Unexpected input: " + typeof c), "ERR_UNEXPECTED_INPUT");
                        }
                        throw d(new Error("Unexpected input: " + typeof c), "ERR_UNEXPECTED_INPUT");
                    }
                    yield e({ path: c });
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(117), r = f(593), e = f(597), c = f(598), n = f(599), t = f(274);
                m.KeytransformDatastore = d, m.ShardingDatastore = r, m.MountDatastore = e, m.TieredDatastore = c, m.NamespaceDatastore = n, m.shard = t;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e, c, n) { for (r = r.split ? r.split(".") : r, c = 0; c < r.length; c++)
                    d = d ? d[r[c]] : n; return d === n ? e : d; };
            }, function (E, m, f) {
                "use strict";
                const d = f(277), r = f(0);
                m.getPubsubRouting = (e, c) => { if (!e || !c || !c.ipnsPubsub)
                    throw r(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED"); if (d.isIpnsPubsubDatastore(e.routing))
                    return e.routing; const n = (e.routing.stores || []).find(t => d.isIpnsPubsubDatastore(t)); if (!n)
                    throw r(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND"); return n; };
            }, function (E, m, f) {
                "use strict";
                E.exports = () => ({ Addresses: { Swarm: [], Announce: [], API: "", Gateway: "", RPC: "", Delegates: ["/dns4/node0.delegate.ipfs.io/tcp/443/https", "/dns4/node1.delegate.ipfs.io/tcp/443/https", "/dns4/node2.delegate.ipfs.io/tcp/443/https", "/dns4/node3.delegate.ipfs.io/tcp/443/https"] }, Discovery: { MDNS: { Enabled: !1, Interval: 10 }, webRTCStar: { Enabled: !0 } }, Bootstrap: ["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN", "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb", "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp", "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa", "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt", "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic", "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6", "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS", "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"], Pubsub: { Enabled: !0 }, Swarm: { ConnMgr: { LowWater: 200, HighWater: 500 } }, Routing: { Type: "none" } });
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0);
                m.cleanCid = e => { if (d.isCID(e))
                    return e; try {
                    return new d(e);
                }
                catch (c) {
                    throw r(c, "ERR_INVALID_CID");
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(282), r = f(283).bind({ ignoreUndefined: !0 }), e = { chunker: "fixed", strategy: "balanced", rawLeaves: !1, onlyHash: !1, reduceSingleLeafToSelf: !0, codec: "dag-pb", hashAlg: "sha2-256", leafType: "file", cidVersion: 0, progress: () => () => { }, shardSplitThreshold: 1e3, fileImportConcurrency: 50, blockWriteConcurrency: 10, minChunkSize: 262144, maxChunkSize: 262144, avgChunkSize: 262144, window: 16, polynomial: 17437180132763652, maxChildrenPerNode: 174, layerRepeat: 4, wrapWithDirectory: !1, pin: !1, recursive: !1, hidden: !1, preload: !1, chunkValidator: null, importBuffer: null };
                E.exports = async function* (c, n, t = {}) { const s = r(e, t); let u, i; u = typeof t.dagBuilder == "function" ? t.dagBuilder : f(641), i = typeof t.treeBuilder == "function" ? t.treeBuilder : f(655); for await (const o of i(d(u(c, n, s), s.fileImportConcurrency), n, s))
                    yield { cid: o.cid, path: o.path, unixfs: o.unixfs, size: o.size }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = async function* (d, r) { r = parseInt(r), (isNaN(r) || r < 1) && (r = 1); let e = []; for await (const c of d)
                    for (e.push(c); e.length >= r;)
                        yield e.slice(0, r), e = e.slice(r); for (; e.length;)
                    yield e.slice(0, r), e = e.slice(r); };
            }, function (E, m, f) {
                "use strict";
                E.exports = class {
                    constructor(d, r) { this.options = r || {}, Object.assign(this, d); }
                };
            }, function (E, m, f) {
                "use strict";
                const { DAGLink: d, DAGNode: r } = f(17), e = f(29), c = f(16), n = f(170), t = f(67), s = f(658), u = f(283).bind({ ignoreUndefined: !0 }), i = f(6), o = async function (a) { const l = i(a), p = (await c(l, "murmur3-128")).slice(2, 10), g = p.length, b = new Uint8Array(g); for (let I = 0; I < g; I++)
                    b[g - I - 1] = p[I]; return b; };
                o.code = 34;
                const h = { hamtHashFn: o, hamtBucketBits: 8 };
                E.exports = class extends n {
                    constructor(a, l) { super(a, l = u(h, l)), this._bucket = s({ hashFn: l.hamtHashFn, bits: l.hamtBucketBits }); }
                    async put(a, l) { await this._bucket.put(a, l); }
                    get(a) { return this._bucket.get(a); }
                    childCount() { return this._bucket.leafCount(); }
                    directChildrenCount() { return this._bucket.childrenCount(); }
                    onlyChild() { return this._bucket.onlyChild(); }
                    async *eachChildSeries() { for await (const { key: a, value: l } of this._bucket.eachLeafSeries())
                        yield { key: a, child: l }; }
                    async *flush(a, l) { for await (const p of async function* g(b, I, v, R, _) { const k = I._children, x = []; let M = 0; for (let L = 0; L < k.length; L++) {
                        const j = k.get(L);
                        if (!j)
                            continue;
                        const D = L.toString(16).toUpperCase().padStart(2, "0");
                        if (s.isBucket(j)) {
                            let G;
                            for await (const W of await g("", j, v, null, _))
                                G = W;
                            x.push(new d(D, G.size, G.cid)), M += G.size;
                        }
                        else if (typeof j.value.flush == "function") {
                            const G = j.value;
                            let W;
                            for await (const Q of G.flush(G.path, v))
                                W = Q, yield W;
                            const X = D + j.key;
                            x.push(new d(X, W.size, W.cid)), M += W.size;
                        }
                        else {
                            const G = j.value;
                            if (!G.cid)
                                continue;
                            const W = D + j.key, X = G.size;
                            x.push(new d(W, X, G.cid)), M += X;
                        }
                    } const N = Uint8Array.from(k.bitField().reverse()), S = new e({ type: "hamt-sharded-directory", data: N, fanout: I.tableSize(), hashType: _.hamtHashFn.code, mtime: R && R.mtime, mode: R && R.mode }), T = new r(S.marshal(), x).serialize(), B = await t(T, v, _), P = T.length + M; yield { cid: B, unixfs: S, path: b, size: P }; }(a, this._bucket, l, this, this.options))
                        yield p; }
                }, E.exports.hashFn = o;
            }, function (E, m, f) {
                "use strict";
                const d = f(659), r = f(660), e = { bits: 8 };
                class c {
                    constructor(i, o, h) { if (this._options = Object.assign({}, e, i), this._popCount = 0, this._parent = o, this._posAtParent = h, !this._options.hashFn)
                        throw new Error("please define an options.hashFn"); this._options.hash || (this._options.hash = r(this._options.hashFn)), this._children = new d; }
                    static isBucket(i) { return i instanceof c; }
                    async put(i, o) { const h = await this._findNewBucketAndPos(i); await h.bucket._putAt(h, i, o); }
                    async get(i) { const o = await this._findChild(i); if (o)
                        return o.value; }
                    async del(i) { const o = await this._findPlace(i), h = o.bucket._at(o.pos); h && h.key === i && o.bucket._delAt(o.pos); }
                    leafCount() { return this._children.compactArray().reduce((i, o) => o instanceof c ? i + o.leafCount() : i + 1, 0); }
                    childrenCount() { return this._children.length; }
                    onlyChild() { return this._children.get(0); }
                    *eachLeafSeries() { const i = this._children.compactArray(); for (const o of i)
                        if (o instanceof c)
                            for (const h of o.eachLeafSeries())
                                yield h;
                        else
                            yield o; }
                    serialize(i, o) { return o(this._children.reduce((h, a, l) => (a && (a instanceof c ? h.push(a.serialize(i, o)) : h.push(i(a, l))), h), [])); }
                    asyncTransform(i, o) { return async function h(a, l, p) { const g = []; for (const b of a._children.compactArray()) {
                        if (b instanceof c)
                            await h(b, l, p);
                        else {
                            const I = await l(b);
                            g.push({ bitField: a._children.bitField(), children: I });
                        }
                        return p(g);
                    } }(this, i, o); }
                    toJSON() { return this.serialize(t, s); }
                    prettyPrint() { return JSON.stringify(this.toJSON(), null, "  "); }
                    tableSize() { return Math.pow(2, this._options.bits); }
                    async _findChild(i) { const o = await this._findPlace(i), h = o.bucket._at(o.pos); if (h && h.key === i)
                        return h; }
                    async _findPlace(i) { const o = this._options.hash(i), h = await o.take(this._options.bits), a = this._children.get(h); return a instanceof c ? a._findPlace(o) : { bucket: this, pos: h, hash: o }; }
                    async _findNewBucketAndPos(i) { const o = await this._findPlace(i), h = o.bucket._at(o.pos); if (h && h.key !== i) {
                        const a = new c(this._options, o.bucket, o.pos);
                        o.bucket._putObjectAt(o.pos, a);
                        const l = await a._findPlace(h.hash);
                        return l.bucket._putAt(l, h.key, h.value), a._findNewBucketAndPos(o.hash);
                    } return o; }
                    _putAt(i, o, h) { this._putObjectAt(i.pos, { key: o, value: h, hash: i.hash }); }
                    _putObjectAt(i, o) { this._children.get(i) || this._popCount++, this._children.set(i, o); }
                    _delAt(i) { this._children.get(i) && this._popCount--, this._children.unset(i), this._level(); }
                    _level() { if (this._parent && this._popCount <= 1)
                        if (this._popCount === 1) {
                            const i = this._children.find(n);
                            if (!(i instanceof c)) {
                                const o = i.hash;
                                o.untake(this._options.bits);
                                const h = { pos: this._posAtParent, hash: o };
                                this._parent._putAt(h, i.key, i.value);
                            }
                        }
                        else
                            this._parent._delAt(this._posAtParent); }
                    _at(i) { return this._children.get(i); }
                }
                function n(u) { return Boolean(u); }
                function t(u, i) { return u.key; }
                function s(u) { return u; }
                E.exports = c;
            }, function (E, m, f) {
                "use strict";
                E.exports = async function* (d, r = {}) { const e = d.getReader(); try {
                    for (;;) {
                        const c = await e.read();
                        if (c.done)
                            return;
                        yield c.value;
                    }
                }
                finally {
                    r.preventCancel !== !0 && e.cancel(), e.releaseLock();
                } };
            }, function (E, m, f) {
                "use strict";
                E.exports = async function* (d, r) { for await (const e of d)
                    yield r(e); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e, c) { const n = r + d.length; return e >= n || c < r ? new Uint8Array(0) : (c >= r && c < n && (d = d.slice(0, c - r)), e >= r && e < n && (d = d.slice(e - r)), d); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0);
                E.exports = (r, e, c) => { if (e || (e = 0), e < 0)
                    throw d(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS"); if (e > r)
                    throw d(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS"); if (c || c === 0 || (c = r - e), c < 0)
                    throw d(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS"); return e + c > r && (c = r - e), { offset: e, length: c }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = (d = "") => (d.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
            }, function (E, m, f) {
                "use strict";
                const d = f(179), r = f(119), e = f(1)("ipfs:mfs:cp"), c = f(0), n = f(69), t = f(70), s = f(68), u = f(41), i = f(705), o = f(94), h = f(2), a = { parents: !1, flush: !0, hashAlg: "sha2-256", cidVersion: 0, shardSplitThreshold: 1e3, signal: void 0 };
                E.exports = function (I) { return h(async function (...v) { let { sources: R, destination: _, options: k } = await i(I, v, a); if (!R.length)
                    throw c(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS"); k.parents = k.p || k.parents; const x = R.find(T => !T.exists); if (x)
                    throw c(new Error(x.path + " does not exist"), "ERR_INVALID_PARAMS"); const M = l(_); if (_.exists) {
                    if (e("Destination exists"), R.length === 1 && !M)
                        throw c(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
                }
                else if (e("Destination does not exist"), R.length > 1) {
                    if (!k.parents)
                        throw c(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
                    await d(I)(_.path, k), _ = await u(I, _.path, k);
                }
                else if (_.parts.length > 1) {
                    const T = "/" + _.parts.slice(0, -1).join("/");
                    try {
                        await r(I)(T, k);
                    }
                    catch (B) {
                        if (B.code !== "ERR_NOT_FOUND")
                            throw B;
                        if (!k.parents)
                            throw c(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
                        await d(I)(T, k), _ = await u(I, _.path, k);
                    }
                } const N = l(_) ? _.mfsPath : _.mfsDirectory, S = await o(I, N); if (R.length === 1) {
                    const T = R.pop(), B = M ? T.name : _.name;
                    return e(`Only one source, copying to destination ${M ? "directory" : "file"} ${B}`), p(I, T, B, S, k);
                } return e("Multiple sources, wrapping in a directory"), g(I, R, _, S, k); }); };
                const l = I => I.unixfs && I.unixfs.type && I.unixfs.type.includes("directory"), p = async (I, v, R, _, k) => { let x = _.pop(); x = await b(I, v, R, x, k), _.push(x); const M = await n(I, _, k); await t(I, M, k); }, g = async (I, v, R, _, k) => { for (let M = 0; M < v.length; M++) {
                    const N = v[M];
                    R = await b(I, N, N.name, R, k);
                } _[_.length - 1] = R; const x = await n(I, _, k); await t(I, x, k); }, b = async (I, v, R, _, k) => { const x = await I.repo.blocks.get(v.cid), { node: M, cid: N } = await s(I, { parentCid: _.cid, size: x.data.length, cid: v.cid, name: R, hashAlg: k.hashAlg, cidVersion: k.cidVersion, flush: k.flush }); return _.node = M, _.cid = N, _.size = M.size, _; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1)("ipfs:mfs:mkdir"), e = f(37), c = f(704), n = f(177), t = f(70), s = f(69), u = f(68), i = f(295), o = f(24).bind({ ignoreUndefined: !0 }), h = f(2), a = { parents: !1, hashAlg: "sha2-256", cidVersion: 0, shardSplitThreshold: 1e3, flush: !0, mode: null, mtime: null, signal: void 0 };
                E.exports = p => h(async function (g, b = {}) { const I = o(a, b); if (!g)
                    throw new Error("no path given to Mkdir"); if ((g = g.trim()) === "/") {
                    if (I.parents)
                        return;
                    throw d(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
                } if (g.substring(0, 1) !== "/")
                    throw d(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH"); r("Creating " + g); const v = n(g); if (v[0] === "ipfs")
                    throw d(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH"); const R = await i(p, I); let _; const k = [], x = await c(p, "directory", I); for (let N = 0; N <= v.length; N++) {
                    const S = v.slice(0, N), T = `/ipfs/${R}/${S.join("/")}`;
                    try {
                        if (_ = await e(T, p.ipld), r(T + " existed"), r(`${T} had children ${_.node.Links.map(B => B.Name)}`), N === v.length) {
                            if (I.parents)
                                return;
                            throw d(new Error("file already exists"), "ERR_ALREADY_EXISTS");
                        }
                        k.push({ name: _.name, cid: _.cid });
                    }
                    catch (B) {
                        if (B.code !== "ERR_NOT_FOUND")
                            throw B;
                        if (N < v.length && !I.parents)
                            throw d(new Error(`Intermediate directory path ${T} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
                        await l(p, S[S.length - 1], x, k[k.length - 1], k, I);
                    }
                } const M = await s(p, k, I); await t(p, M, I); });
                const l = async (p, g, b, I, v, R) => { r(`Adding empty dir called ${g} to ${I.cid}`); const _ = await u(p, { parent: I.node, parentCid: I.cid, size: b.node.size, cid: b.cid, name: g, hashAlg: R.hashAlg, cidVersion: R.cidVersion, flush: R.flush }); v[v.length - 1].cid = _.cid, v.push({ name: g, cid: b.cid }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(41), r = f(24).bind({ ignoreUndefined: !0 });
                E.exports = async function (e, c, n) { const t = []; let s; for (let u = 0; u < c.length; u++)
                    typeof c[u] == "string" || c[u] instanceof String ? t.push(c[u].trim()) : u === c.length - 1 && (s = c[u]); return s = r(n, s), { sources: await d(e, t, s), options: s }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(69), e = f(70), c = f(180), n = f(706), t = f(41), s = f(94), u = f(2), i = { recursive: !1, cidVersion: 0, hashAlg: "sha2-256", flush: !0, signal: void 0 };
                E.exports = h => u(async function (...a) { const { sources: l, options: p } = await c(h, a, i); if (!l.length)
                    throw d(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS"); l.forEach(g => { if (g.path === "/")
                    throw d(new Error("Cannot delete root"), "ERR_INVALID_PARAMS"); }); for (const g of l)
                    await o(h, g.path, p); });
                const o = async (h, a, l) => { const p = await t(h, a, l), g = await s(h, p.mfsPath), b = g[g.length - 1]; g.pop(); const I = g[g.length - 1]; if (!I)
                    throw d(new Error(a + " does not exist"), "ERR_NOT_FOUND"); if (b.type === "directory" && !l.recursive)
                    throw d(new Error(a + " is a directory, use -r to remove directories"), "ERR_WAS_DIR"); const { cid: v } = await n(h, { parentCid: I.cid, name: b.name, hashAlg: l.hashAlg, cidVersion: l.cidVersion, flush: l.flush }); I.cid = v; const R = await r(h, g, l); await e(h, R, l); };
            }, function (E, m, f) {
                "use strict";
                const d = f(298), r = f(1), e = f(30), c = f(0), n = f(735), t = f(745), s = f(746), u = f(747), i = f(748), o = f(749), h = f(750), a = f(752), l = f(754), p = f(755), g = f(757), b = f(806), I = f(184), v = r("ipfs:repo"), R = Number.MAX_SAFE_INTEGER, _ = { memory: f(322), fs: f(322) };
                async function k(x) { const M = new e(0); for await (const N of x.query({}))
                    M.plus(N.value.byteLength).plus(N.key.uint8Array().byteLength); return M; }
                E.exports = class {
                    constructor(x, M) { if (typeof x != "string")
                        throw new Error("missing repoPath"); this.options = function (N) { const S = Object.assign({}, g, N); return S.storageBackends = Object.assign({}, g.storageBackends, S.storageBackends), S.storageBackendOptions = Object.assign({}, g.storageBackendOptions, S.storageBackendOptions), S; }(M), this.closed = !0, this.path = x, this._locker = this._getLocker(), this.root = i.create("root", this.path, this.options), this.version = o(this.root), this.config = h(this.root), this.spec = a(this.root), this.apiAddr = l(this.root); }
                    async init(x) { var M; v("initializing at: %s", this.path), await this._openRoot(), await this.config.set((M = x, M.datastore = Object.assign({}, b, d(M, "datastore", {})), M)), await this.spec.set(function (N) { const S = Object.assign({}, b.Spec, d(N, "datastore.Spec", {})); return { type: S.type, mounts: S.mounts.map(T => ({ mountpoint: T.mountpoint, type: T.child.type, path: T.child.path, shardFunc: T.child.shardFunc })) }; }(x)), await this.version.set(u.repoVersion); }
                    async isInitialized() { if (!this.closed)
                        return !0; try {
                        return await this._openRoot(), await this._checkInitialized(), await this.root.close(), !0;
                    }
                    catch (x) {
                        return !1;
                    } }
                    async open() { if (!this.closed)
                        throw c(new Error("repo is already open"), I.ERR_REPO_ALREADY_OPEN); v("opening at: %s", this.path); try {
                        if (await this._openRoot(), await this._checkInitialized(), this.lockfile = await this._openLock(this.path), v("acquired repo.lock"), !await this.version.check(u.repoVersion)) {
                            if (!await this._isAutoMigrationEnabled())
                                throw new I.InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
                            await this._migrate(u.repoVersion);
                        }
                        v("creating datastore"), this.datastore = i.create("datastore", s(this.path, "datastore"), this.options), await this.datastore.open(), v("creating blocks");
                        const x = i.create("blocks", s(this.path, "blocks"), this.options);
                        await x.open(), this.blocks = await p(x, this.options.storageBackendOptions.blocks), v("creating keystore"), this.keys = i.create("keys", s(this.path, "keys"), this.options), await this.keys.open(), v("creating pins"), this.pins = i.create("pins", s(this.path, "pins"), this.options), await this.pins.open(), this.closed = !1, v("all opened");
                    }
                    catch (x) {
                        if (this.lockfile)
                            try {
                                await this._closeLock(), this.lockfile = null;
                            }
                            catch (M) {
                                v("error removing lock", M);
                            }
                        throw x;
                    } }
                    _getLocker() { if (typeof this.options.lock == "string") {
                        if (!_[this.options.lock])
                            throw new Error("Unknown lock type: " + this.options.lock);
                        return _[this.options.lock];
                    } if (!this.options.lock)
                        throw new Error("No lock provided"); return this.options.lock; }
                    async _openRoot() { try {
                        await this.root.open();
                    }
                    catch (x) {
                        if (x.message !== "Already open")
                            throw x;
                    } }
                    async _openLock(x) { const M = await this._locker.lock(x); if (typeof M.close != "function")
                        throw c(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION"); return M; }
                    _closeLock() { return this.lockfile.close(); }
                    async _checkInitialized() { let x; v("init check"); try {
                        [x] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);
                    }
                    catch (M) {
                        throw M.code === "ERR_NOT_FOUND" ? c(new Error("repo is not initialized yet"), I.ERR_REPO_NOT_INITIALIZED, { path: this.path }) : M;
                    } if (!x)
                        throw c(new Error("repo is not initialized yet"), I.ERR_REPO_NOT_INITIALIZED, { path: this.path }); }
                    async close() { if (this.closed)
                        throw c(new Error("repo is already closed"), I.ERR_REPO_ALREADY_CLOSED); v("closing at: %s", this.path); try {
                        await this.apiAddr.delete();
                    }
                    catch (x) {
                        if (x.code !== I.ERR_REPO_NOT_INITIALIZED && !x.message.startsWith("ENOENT"))
                            throw x;
                    } await Promise.all([this.root, this.blocks, this.keys, this.datastore, this.pins].map(x => x.close())), v("unlocking"), this.closed = !0, await this._closeLock(), this.lockfile = null; }
                    async exists() { return this.version.exists(); }
                    async stat() { const [x, M, N, S, T] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), k(this.datastore), k(this.keys)]), B = M.size.plus(S).plus(T); return { repoPath: this.path, storageMax: x, version: N, numObjects: M.count, repoSize: B }; }
                    async _isAutoMigrationEnabled() { if (this.options.autoMigrate !== void 0)
                        return this.options.autoMigrate; let x; try {
                        x = await this.config.get("repoAutoMigrate");
                    }
                    catch (M) {
                        if (M.code !== I.NotFoundError.code)
                            throw M;
                        x = !0;
                    } return x; }
                    async _migrate(x) { return await this.version.get() > x ? (v("reverting to version " + x), n.revert(this.path, this.options, x, { ignoreLock: !0, onProgress: this.options.onMigrationProgress })) : (v("migrating to version " + x), n.migrate(this.path, this.options, x, { ignoreLock: !0, onProgress: this.options.onMigrationProgress })); }
                    async _storageMaxStat() { try {
                        const x = await this.config.get("Datastore.StorageMax");
                        return new e(t(x));
                    }
                    catch (x) {
                        return new e(R);
                    } }
                    async _blockStat() { let x = new e(0), M = new e(0); for await (const N of this.blocks.query({}))
                        x = x.plus(1), M = M.plus(N.data.byteLength).plus(N.cid.bytes.byteLength); return { count: x, size: M }; }
                }, E.exports.utils = { blockstore: f(301) }, E.exports.repoVersion = u.repoVersion, E.exports.errors = I;
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(s) { super(s), this.name = "NonReversibleMigrationError", this.code = "ERR_NON_REVERSIBLE_MIGRATION", this.message = s; }
                }
                d.code = "ERR_NON_REVERSIBLE_MIGRATION", m.NonReversibleMigrationError = d;
                class r extends Error {
                    constructor(s) { super(s), this.name = "NotInitializedRepoError", this.code = "ERR_NOT_INITIALIZED_REPO", this.message = s; }
                }
                r.code = "ERR_NOT_INITIALIZED_REPO", m.NotInitializedRepoError = r;
                class e extends Error {
                    constructor(s) { super(s), this.name = "RequiredParameterError", this.code = "ERR_REQUIRED_PARAMETER", this.message = s; }
                }
                e.code = "ERR_REQUIRED_PARAMETER", m.RequiredParameterError = e;
                class c extends Error {
                    constructor(s) { super(s), this.name = "InvalidValueError", this.code = "ERR_INVALID_VALUE", this.message = s; }
                }
                c.code = "ERR_INVALID_VALUE", m.InvalidValueError = c;
                class n extends Error {
                    constructor(s) { super(s), this.name = "MissingRepoOptionsError", this.code = "ERR_MISSING_REPO_OPTIONS", this.message = s; }
                }
                n.code = "ERR_MISSING_REPO_OPTIONS", m.MissingRepoOptionsError = n;
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(n) { super(n), this.name = "LockExistsError", this.code = d.code; }
                }
                d.code = "ERR_LOCK_EXISTS", m.LockExistsError = d;
                class r extends Error {
                    constructor(n) { super(n), this.name = "NotFoundError", this.code = r.code; }
                }
                r.code = "ERR_NOT_FOUND", m.NotFoundError = r;
                class e extends Error {
                    constructor(n) { super(n), this.name = "InvalidRepoVersionError", this.code = e.code; }
                }
                e.code = "ERR_INVALID_REPO_VERSION", m.InvalidRepoVersionError = e, m.ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED", m.ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN", m.ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
            }, function (E, m, f) {
                "use strict";
                var d = f(71), r = f(763);
                E.exports = function () { var e = d.apply(null, arguments); return r(e, { bufferKeys: e.bufferKeys || !1, snapshots: e.snapshots || !1, permanence: e.permanence || !1, seek: e.seek || !1, clear: e.clear || !1, status: e.status || !1, createIfMissing: e.createIfMissing || !1, errorIfExists: e.errorIfExists || !1, deferredOpen: e.deferredOpen || !1, openCallback: e.openCallback || !1, promises: e.promises || !1, streams: e.streams || !1, encodings: e.encodings || !1, additionalMethods: d(e.additionalMethods) }); };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(305);
            }, function (E, m, f) {
                "use strict";
                var d = f(72).codes.ERR_STREAM_PREMATURE_CLOSE;
                function r() { }
                E.exports = function e(c, n, t) { if (typeof n == "function")
                    return e(c, null, n); n || (n = {}), t = function (I) { var v = !1; return function () { if (!v) {
                    v = !0;
                    for (var R = arguments.length, _ = new Array(R), k = 0; k < R; k++)
                        _[k] = arguments[k];
                    I.apply(this, _);
                } }; }(t || r); var s = n.readable || n.readable !== !1 && c.readable, u = n.writable || n.writable !== !1 && c.writable, i = function () { c.writable || h(); }, o = c._writableState && c._writableState.finished, h = function () { u = !1, o = !0, s || t.call(c); }, a = c._readableState && c._readableState.endEmitted, l = function () { s = !1, a = !0, u || t.call(c); }, p = function (I) { t.call(c, I); }, g = function () { var I; return s && !a ? (c._readableState && c._readableState.ended || (I = new d), t.call(c, I)) : u && !o ? (c._writableState && c._writableState.ended || (I = new d), t.call(c, I)) : void 0; }, b = function () { c.req.on("finish", h); }; return function (I) { return I.setHeader && typeof I.abort == "function"; }(c) ? (c.on("complete", h), c.on("abort", g), c.req ? b() : c.on("request", b)) : u && !c._writableState && (c.on("end", i), c.on("close", i)), c.on("end", l), c.on("finish", h), n.error !== !1 && c.on("error", p), c.on("close", g), function () { c.removeListener("complete", h), c.removeListener("abort", g), c.removeListener("request", b), c.req && c.req.removeListener("finish", h), c.removeListener("end", i), c.removeListener("close", i), c.removeListener("finish", h), c.removeListener("end", l), c.removeListener("error", p), c.removeListener("close", g); }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(781).create, r = d("LevelUPError"), e = d("NotFoundError", r);
                e.prototype.notFound = !0, e.prototype.status = 404, E.exports = { LevelUPError: r, InitializationError: d("InitializationError", r), OpenError: d("OpenError", r), ReadError: d("ReadError", r), WriteError: d("WriteError", r), NotFoundError: e, EncodingError: d("EncodingError", r) };
            }, function (E, m, f) {
                "use strict";
                m.AbstractLevelDOWN = f(790), m.AbstractIterator = f(315), m.AbstractChainedBatch = f(316);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(305);
            }, function (E, m, f) {
                "use strict";
                m.codes = { ERR_MISSING_SIGNATURE: "ERR_MISSING_SIGNATURE", ERR_INVALID_SIGNATURE: "ERR_INVALID_SIGNATURE" };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { if (d) {
                    if (typeof d[Symbol.iterator] == "function")
                        return d[Symbol.iterator]();
                    if (typeof d[Symbol.asyncIterator] == "function")
                        return d[Symbol.asyncIterator]();
                    if (typeof d.next == "function")
                        return d;
                } throw new Error("argument is not an iterator or iterable"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1);
                d("libp2p:envelope").error = d("libp2p:envelope:error");
                const r = f(0), e = f(31), c = f(6), n = f(140), t = f(7), s = f(19), u = f(20), { codes: i } = f(28), o = f(849);
                class h {
                    constructor({ peerId: p, payloadType: g, payload: b, signature: I }) { this.peerId = p, this.payloadType = g, this.payload = b, this.signature = I, this._marshal = void 0; }
                    marshal() { if (this._marshal)
                        return this._marshal; const p = n.marshalPublicKey(this.peerId.pubKey); return this._marshal = o.encode({ public_key: p, payload_type: this.payloadType, payload: this.payload, signature: this.signature }), this._marshal; }
                    equals(p) { return u(this.peerId.pubKey.bytes, p.peerId.pubKey.bytes) && u(this.payloadType, p.payloadType) && u(this.payload, p.payload) && u(this.signature, p.signature); }
                    validate(p) { const g = a(p, this.payloadType, this.payload); return this.peerId.pubKey.verify(g, this.signature); }
                }
                const a = (l, p, g) => { l = c(l); const b = s.encode(l.byteLength), I = s.encode(p.length), v = s.encode(g.length); return e([new Uint8Array(b), l, new Uint8Array(I), p, new Uint8Array(v), g]); };
                h.createFromProtobuf = async (l) => { const p = o.decode(l), g = await t.createFromPubKey(p.public_key); return new h({ peerId: g, payloadType: p.payload_type, payload: p.payload, signature: p.signature }); }, h.seal = async (l, p) => { const g = l.domain, b = l.codec, I = l.marshal(), v = a(g, b, I), R = await p.privKey.sign(v); return new h({ peerId: p, payloadType: b, payload: I, signature: R }); }, h.openAndCertify = async (l, p) => { const g = await h.createFromProtobuf(l); if (!await g.validate(p))
                    throw r(new Error("envelope signature is not valid for the given domain"), i.ERR_SIGNATURE_NOT_VALID); return g; }, E.exports = h;
            }, function (E, m, f) {
                "use strict";
                typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this; }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__), E.exports = globalThis;
            }, function (E, m, f) {
                "use strict";
                const d = f(852), r = f(333);
                E.exports = (e, c) => { const n = d(e, { ...c, count: 1 }); return r.fn(async (t) => { t(() => { n.cancel(); }); const [s] = await n; return s; })(); }, E.exports.AggregateError = d.AggregateError;
            }, function (E, m, f) {
                "use strict";
                E.exports = { DIAL_TIMEOUT: 3e4, MAX_PARALLEL_DIALS: 100, MAX_PER_PEER_DIALS: 4, METRICS: { computeThrottleMaxQueueSize: 1e3, computeThrottleTimeout: 2e3, movingAverageIntervals: [6e4, 3e5, 9e5], maxOldPeersRetention: 50 } };
            }, function (E, m, f) {
                "use strict";
                E.exports = { relay: "/libp2p/circuit/relay/0.1.0" };
            }, function (E, m, f) {
                "use strict";
                const d = f(35), r = f(99), { CircuitRelay: e } = f(98), c = f(1), n = c("libp2p:circuit:stream-handler");
                n.error = c("libp2p:circuit:stream-handler:error"), E.exports = class {
                    constructor({ stream: t, maxLength: s = 4096 }) { this.stream = t, this.shake = r(this.stream), this.decoder = d.decode.fromReader(this.shake.reader, { maxDataLength: s }); }
                    async read() { const t = await this.decoder.next(); if (t.value) {
                        const s = e.decode(t.value.slice());
                        return n("read message type", s.type), s;
                    } n("read received no value, closing stream"), this.close(); }
                    write(t) { n("write message type %s", t.type), this.shake.write(d.encode.single(e.encode(t))); }
                    rest() { return this.shake.rest(), this.shake.stream; }
                    end(t) { this.write(t), this.close(); }
                    close() { n("closing the stream"), this.rest().sink([]); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = () => { const d = {}; return d.promise = new Promise((r, e) => { d.resolve = r, d.reject = e; }), d; };
            }, function (E, m, f) {
                "use strict";
                const d = f(34), r = f(35), e = f(27), c = f(0), n = f(6)(`
`);
                async function t(s) { for await (const u of s)
                    return u; }
                m.encode = s => r.encode.single(new d([s, n])), m.write = (s, u) => s.push(m.encode(u)), m.writeAll = (s, u) => { s.push(u.reduce((i, o) => i.append(m.encode(o)), new d)); }, m.read = async (s) => { let u = 1; const i = { [Symbol.asyncIterator]() { return this; }, next: () => s.next(u) }, o = await e(i, r.decode({ onLength: h => { u = h; } }), t); if (o.get(o.length - 1) !== n[0])
                    throw c(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE"); return o.shallowSlice(0, -1); };
            }, function (E, m, f) {
                "use strict";
                m.BITS = 32, m.GROUPS = 4, m.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g, m.RE_SUBNET_STRING = /\/\d{1,2}$/;
            }, function (E, m, f) {
                "use strict";
                m.BITS = 128, m.GROUPS = 8, m.SCOPES = { 0: "Reserved", 1: "Interface local", 2: "Link local", 4: "Admin local", 5: "Site local", 8: "Organization local", 14: "Global", 15: "Reserved" }, m.TYPES = { "ff01::1/128": "Multicast (All nodes on this interface)", "ff01::2/128": "Multicast (All routers on this interface)", "ff02::1/128": "Multicast (All nodes on this link)", "ff02::2/128": "Multicast (All routers on this link)", "ff05::2/128": "Multicast (All routers in this site)", "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)", "ff02::6/128": "Multicast (OSPFv3 AllDR routers)", "ff02::9/128": "Multicast (RIP routers)", "ff02::a/128": "Multicast (EIGRP routers)", "ff02::d/128": "Multicast (PIM routers)", "ff02::16/128": "Multicast (MLDv2 reports)", "ff01::fb/128": "Multicast (mDNSv6)", "ff02::fb/128": "Multicast (mDNSv6)", "ff05::fb/128": "Multicast (mDNSv6)", "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)", "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)", "ff02::1:3/128": "Multicast (All DHCP servers on this link)", "ff05::1:3/128": "Multicast (All DHCP servers in this site)", "::/128": "Unspecified", "::1/128": "Loopback", "ff00::/8": "Multicast", "fe80::/10": "Link-local unicast" }, m.RE_BAD_CHARACTERS = /([^0-9a-f:\/%])/gi, m.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi, m.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/, m.RE_ZONE_STRING = /%.*$/, m.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/), m.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
            }, function (E, m, f) {
                "use strict";
                var d = f(76).codes.ERR_STREAM_PREMATURE_CLOSE;
                function r() { }
                E.exports = function e(c, n, t) { if (typeof n == "function")
                    return e(c, null, n); n || (n = {}), t = function (I) { var v = !1; return function () { if (!v) {
                    v = !0;
                    for (var R = arguments.length, _ = new Array(R), k = 0; k < R; k++)
                        _[k] = arguments[k];
                    I.apply(this, _);
                } }; }(t || r); var s = n.readable || n.readable !== !1 && c.readable, u = n.writable || n.writable !== !1 && c.writable, i = function () { c.writable || h(); }, o = c._writableState && c._writableState.finished, h = function () { u = !1, o = !0, s || t.call(c); }, a = c._readableState && c._readableState.endEmitted, l = function () { s = !1, a = !0, u || t.call(c); }, p = function (I) { t.call(c, I); }, g = function () { var I; return s && !a ? (c._readableState && c._readableState.ended || (I = new d), t.call(c, I)) : u && !o ? (c._writableState && c._writableState.ended || (I = new d), t.call(c, I)) : void 0; }, b = function () { c.req.on("finish", h); }; return function (I) { return I.setHeader && typeof I.abort == "function"; }(c) ? (c.on("complete", h), c.on("abort", g), c.req ? b() : c.on("request", b)) : u && !c._writableState && (c.on("end", i), c.on("close", i)), c.on("end", l), c.on("finish", h), n.error !== !1 && c.on("error", p), c.on("close", g), function () { c.removeListener("complete", h), c.removeListener("abort", g), c.removeListener("request", b), c.req && c.req.removeListener("finish", h), c.removeListener("end", i), c.removeListener("close", i), c.removeListener("finish", h), c.removeListener("end", l), c.removeListener("error", p), c.removeListener("close", g); }; };
            }, function (E, m, f) {
                "use strict";
                m.CODE_P2P = 421, m.CODE_CIRCUIT = 290, m.CLOSE_TIMEOUT = 2e3;
            }, function (E, m, f) {
                "use strict";
                var d = f(966)("socket.io-parser"), r = f(78), e = f(969), c = f(364), n = f(365);
                function t() { }
                m.protocol = 4, m.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], m.CONNECT = 0, m.DISCONNECT = 1, m.EVENT = 2, m.ACK = 3, m.ERROR = 4, m.BINARY_EVENT = 5, m.BINARY_ACK = 6, m.Encoder = t, m.Decoder = i;
                var s = m.ERROR + '"encode error"';
                function u(a) { var l = "" + a.type; if (m.BINARY_EVENT !== a.type && m.BINARY_ACK !== a.type || (l += a.attachments + "-"), a.nsp && a.nsp !== "/" && (l += a.nsp + ","), a.id != null && (l += a.id), a.data != null) {
                    var p = function (g) { try {
                        return JSON.stringify(g);
                    }
                    catch (b) {
                        return !1;
                    } }(a.data);
                    if (p === !1)
                        return s;
                    l += p;
                } return d("encoded %j as %s", a, l), l; }
                function i() { this.reconstructor = null; }
                function o(a) { this.reconPack = a, this.buffers = []; }
                function h(a) { return { type: m.ERROR, data: "parser error: " + a }; }
                t.prototype.encode = function (a, l) { (d("encoding packet %j", a), m.BINARY_EVENT === a.type || m.BINARY_ACK === a.type) ? function (p, g) { e.removeBlobs(p, function (b) { var I = e.deconstructPacket(b), v = u(I.packet), R = I.buffers; R.unshift(v), g(R); }); }(a, l) : l([u(a)]); }, r(i.prototype), i.prototype.add = function (a) { var l; if (typeof a == "string")
                    l = function (p) { var g = 0, b = { type: Number(p.charAt(0)) }; if (m.types[b.type] == null)
                        return h("unknown packet type " + b.type); if (m.BINARY_EVENT === b.type || m.BINARY_ACK === b.type) {
                        for (var I = ""; p.charAt(++g) !== "-" && (I += p.charAt(g), g != p.length);)
                            ;
                        if (I != Number(I) || p.charAt(g) !== "-")
                            throw new Error("Illegal attachments");
                        b.attachments = Number(I);
                    } if (p.charAt(g + 1) === "/") {
                        for (b.nsp = ""; ++g && !((R = p.charAt(g)) === ",");)
                            if (b.nsp += R, g === p.length)
                                break;
                    }
                    else
                        b.nsp = "/"; var v = p.charAt(g + 1); if (v !== "" && Number(v) == v) {
                        for (b.id = ""; ++g;) {
                            var R;
                            if ((R = p.charAt(g)) == null || Number(R) != R) {
                                --g;
                                break;
                            }
                            if (b.id += p.charAt(g), g === p.length)
                                break;
                        }
                        b.id = Number(b.id);
                    } if (p.charAt(++g)) {
                        var _ = function (k) { try {
                            return JSON.parse(k);
                        }
                        catch (x) {
                            return !1;
                        } }(p.substr(g));
                        if (!(_ !== !1 && (b.type === m.ERROR || c(_))))
                            return h("invalid payload");
                        b.data = _;
                    } return d("decoded %s as %j", p, b), b; }(a), m.BINARY_EVENT === l.type || m.BINARY_ACK === l.type ? (this.reconstructor = new o(l), this.reconstructor.reconPack.attachments === 0 && this.emit("decoded", l)) : this.emit("decoded", l);
                else {
                    if (!n(a) && !a.base64)
                        throw new Error("Unknown type: " + a);
                    if (!this.reconstructor)
                        throw new Error("got binary data when not reconstructing a packet");
                    (l = this.reconstructor.takeBinaryData(a)) && (this.reconstructor = null, this.emit("decoded", l));
                } }, i.prototype.destroy = function () { this.reconstructor && this.reconstructor.finishedReconstruction(); }, o.prototype.takeBinaryData = function (a) { if (this.buffers.push(a), this.buffers.length === this.reconPack.attachments) {
                    var l = e.reconstructPacket(this.reconPack, this.buffers);
                    return this.finishedReconstruction(), l;
                } return null; }, o.prototype.finishedReconstruction = function () { this.reconPack = null, this.buffers = []; };
            }, function (E, m, f) {
                "use strict";
                var d = f(972), r = f(207);
                E.exports = function (e) { var c = e.xdomain, n = e.xscheme, t = e.enablesXDR; try {
                    if (typeof XMLHttpRequest != "undefined" && (!c || d))
                        return new XMLHttpRequest;
                }
                catch (s) { } try {
                    if (typeof XDomainRequest != "undefined" && !n && t)
                        return new XDomainRequest;
                }
                catch (s) { } if (!c)
                    try {
                        return new r[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
                    }
                    catch (s) { } };
            }, function (E, m, f) {
                "use strict";
                E.exports = typeof self != "undefined" ? self : typeof window != "undefined" ? window : Function("return this")();
            }, function (E, m, f) {
                "use strict";
                var d = f(79), r = f(78);
                function e(c) { this.path = c.path, this.hostname = c.hostname, this.port = c.port, this.secure = c.secure, this.query = c.query, this.timestampParam = c.timestampParam, this.timestampRequests = c.timestampRequests, this.readyState = "", this.agent = c.agent || !1, this.socket = c.socket, this.enablesXDR = c.enablesXDR, this.withCredentials = c.withCredentials, this.pfx = c.pfx, this.key = c.key, this.passphrase = c.passphrase, this.cert = c.cert, this.ca = c.ca, this.ciphers = c.ciphers, this.rejectUnauthorized = c.rejectUnauthorized, this.forceNode = c.forceNode, this.isReactNative = c.isReactNative, this.extraHeaders = c.extraHeaders, this.localAddress = c.localAddress; }
                E.exports = e, r(e.prototype), e.prototype.onError = function (c, n) { var t = new Error(c); return t.type = "TransportError", t.description = n, this.emit("error", t), this; }, e.prototype.open = function () { return this.readyState !== "closed" && this.readyState !== "" || (this.readyState = "opening", this.doOpen()), this; }, e.prototype.close = function () { return this.readyState !== "opening" && this.readyState !== "open" || (this.doClose(), this.onClose()), this; }, e.prototype.send = function (c) { if (this.readyState !== "open")
                    throw new Error("Transport not open"); this.write(c); }, e.prototype.onOpen = function () { this.readyState = "open", this.writable = !0, this.emit("open"); }, e.prototype.onData = function (c) { var n = d.decodePacket(c, this.socket.binaryType); this.onPacket(n); }, e.prototype.onPacket = function (c) { this.emit("packet", c); }, e.prototype.onClose = function () { this.readyState = "closed", this.emit("close"); };
            }, function (E, m, f) {
                "use strict";
                E.exports = d => { if (d[Symbol.asyncIterator])
                    return d; if (d.getReader)
                    return async function* () { const r = d.getReader(); try {
                        for (;;) {
                            const { done: e, value: c } = await r.read();
                            if (e)
                                return;
                            yield c;
                        }
                    }
                    finally {
                        r.releaseLock();
                    } }(); throw new Error("unknown stream"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(997), r = f(1004);
                E.exports = new d("X25519", "ED25519", r);
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.DUMP_SESSION_KEYS = m.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = m.NOISE_MSG_MAX_LENGTH_BYTES = void 0, m.NOISE_MSG_MAX_LENGTH_BYTES = 65535, m.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = m.NOISE_MSG_MAX_LENGTH_BYTES - 16, m.DUMP_SESSION_KEYS = { NODE_ENV: "production" }.DUMP_SESSION_KEYS;
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(e, c) { if (e.length !== c.length)
                    throw new Error("Inputs should have the same length"); for (var n = d.allocUnsafe(e.length), t = 0; t < e.length; t++)
                    n[t] = e[t] ^ c[t]; return n; } E.exports = r, r.compare = function (e, c) { if (e.length !== c.length)
                    throw new Error("Inputs should have the same length"); for (var n = 0; n < e.length; n++)
                    if (e[n] !== c[n])
                        return e[n] < c[n] ? -1 : 1; return 0; }, r.gt = function (e, c) { return r.compare(e, c) === 1; }, r.lt = function (e, c) { return r.compare(e, c) === -1; }, r.eq = function (e, c) { return r.compare(e, c) === 0; }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(332);
                E.exports = async (r, e, { concurrency: c = 1 / 0, stopOnError: n = !0 } = {}) => new Promise((t, s) => { if (typeof e != "function")
                    throw new TypeError("Mapper function is required"); if (!Number.isSafeInteger(c) && c !== 1 / 0 || !(c >= 1))
                    throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${c}\` (${typeof c})`); const u = [], i = [], o = r[Symbol.iterator](); let h = !1, a = !1, l = 0, p = 0; const g = () => { if (h)
                    return; const b = o.next(), I = p; if (p++, b.done)
                    return a = !0, void (l === 0 && (n || i.length === 0 ? t(u) : s(new d(i)))); l++, (async () => { try {
                    const v = await b.value;
                    u[I] = await e(v, I), l--, g();
                }
                catch (v) {
                    n ? (h = !0, s(v)) : (i.push(v), l--, g());
                } })(); }; for (let b = 0; b < c && (g(), !a); b++)
                    ; });
            }, function (E, m, f) {
                "use strict";
                const d = f(16).multihash, r = f(22), e = f(1055);
                E.exports = class {
                    constructor(c, n, t) { this.dht = c, this.key = n, this.makePath = t, this._log = r.logger(this.dht.peerId, "query:" + d.toB58String(n)), this.running = !1, this._onStart = this._onStart.bind(this), this._onComplete = this._onComplete.bind(this); }
                    async run(c) { return this.dht._queryManager.running ? c.length === 0 ? (this._log.error("Running query with no peers"), { finalSet: new Set, paths: [] }) : (this._run = new e(this), this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths, c.length)}`), this._run.once("start", this._onStart), this._run.once("complete", this._onComplete), this._run.execute(c)) : (this._log.error("Attempt to run query after shutdown"), { finalSet: new Set, paths: [] }); }
                    _onStart() { this.running = !0, this._startTime = Date.now(), this._log("query:start"), this.dht._queryManager.queryStarted(this); }
                    _onComplete() { this.stop(); }
                    stop() { this._log(`query:done in ${Date.now() - this._startTime}ms`), this._run && this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length / this._run.peersSeen.size * 100}% fail rate)`), this.running && (this._run.removeListener("start", this._onStart), this._run.removeListener("complete", this._onComplete), this.running = !1, this._run && this._run.stop(), this.dht._queryManager.queryCompleted(this)); }
                };
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(n = "Request timed out") { super(n), this.name = "TimeoutError"; }
                }
                m.TimeoutError = d;
                class r extends Error {
                    constructor(n = "The operation was aborted.") { super(n), this.name = "AbortError"; }
                }
                m.AbortError = r;
                class e extends Error {
                    constructor(n) { super(n.statusText), this.name = "HTTPError", this.response = n; }
                }
                m.HTTPError = e;
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(397), e = typeof window == "object" && typeof document == "object" && document.nodeType === 9, c = r(), n = e && !c, t = c && !e, s = c && e, u = d !== void 0 && d.release !== void 0 && d.release.name === "node" && !c, i = typeof importScripts == "function" && typeof self != "undefined" && typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope, o = d !== void 0 && { NODE_ENV: "production" } !== void 0 && !1; E.exports = { isTest: o, isElectron: c, isElectronMain: t, isElectronRenderer: s, isNode: u, isBrowser: n, isWebWorker: i, isEnvWithDom: e }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                const d = f(133)();
                d.fetch && d.Headers && d.Request && d.Response ? (E.exports = function (...r) { return d.fetch(...r); }, E.exports.Headers = d.Headers, E.exports.Request = d.Request, E.exports.Response = d.Response, E.exports.default = E.exports) : E.exports = f(402);
            }, function (E, m, f) {
                "use strict";
                var d = f(399), r = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", e = Object.prototype.toString, c = Array.prototype.concat, n = Object.defineProperty, t = n && function () { var i = {}; try {
                    for (var o in n(i, "x", { enumerable: !1, value: i }), i)
                        return !1;
                    return i.x === i;
                }
                catch (h) {
                    return !1;
                } }(), s = function (i, o, h, a) { var l; (!(o in i) || typeof (l = a) == "function" && e.call(l) === "[object Function]" && a()) && (t ? n(i, o, { configurable: !0, enumerable: !1, value: h, writable: !0 }) : i[o] = h); }, u = function (i, o) { var h = arguments.length > 2 ? arguments[2] : {}, a = d(o); r && (a = c.call(a, Object.getOwnPropertySymbols(o))); for (var l = 0; l < a.length; l += 1)
                    s(i, a[l], o[a[l]], h[a[l]]); };
                u.supportsDescriptors = !!t, E.exports = u;
            }, function (E, m, f) {
                "use strict";
                var d = Object.prototype.toString;
                E.exports = function (r) { var e = d.call(r), c = e === "[object Arguments]"; return c || (c = e !== "[object Array]" && r !== null && typeof r == "object" && typeof r.length == "number" && r.length >= 0 && d.call(r.callee) === "[object Function]"), c; };
            }, function (E, m, f) {
                "use strict";
                typeof self != "undefined" ? E.exports = self : typeof window != "undefined" ? E.exports = window : E.exports = Function("return this")();
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(220); E.exports = function () { return typeof d == "object" && d && d.Math === Math && d.Array === Array ? d : r; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = self.location && self.location.protocol + "//" + self.location.host, r = self.URL;
                E.exports = { URLWithLegacySupport: class {
                        constructor(e = "", c = d) { this.super = new r(e, c), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null; }
                        get hash() { return this.super.hash; }
                        get host() { return this.super.host; }
                        get hostname() { return this.super.hostname; }
                        get href() { return this.super.href; }
                        get origin() { return this.super.origin; }
                        get password() { return this.super.password; }
                        get pathname() { return this.super.pathname; }
                        get port() { return this.super.port; }
                        get protocol() { return this.super.protocol; }
                        get search() { return this.super.search; }
                        get searchParams() { return this.super.searchParams; }
                        get username() { return this.super.username; }
                        set hash(e) { this.super.hash = e; }
                        set host(e) { this.super.host = e; }
                        set hostname(e) { this.super.hostname = e; }
                        set href(e) { this.super.href = e; }
                        set origin(e) { this.super.origin = e; }
                        set password(e) { this.super.password = e; }
                        set pathname(e) { this.super.pathname = e; }
                        set port(e) { this.super.port = e; }
                        set protocol(e) { this.super.protocol = e; }
                        set search(e) { this.super.search = e; }
                        set searchParams(e) { this.super.searchParams = e; }
                        set username(e) { this.super.username = e; }
                        createObjectURL(e) { return this.super.createObjectURL(e); }
                        revokeObjectURL(e) { this.super.revokeObjectURL(e); }
                        toJSON() { return this.super.toJSON(); }
                        toString() { return this.super.toString(); }
                        format() { return this.toString(); }
                    }, URLSearchParams: self.URLSearchParams, defaultBase: d, format: function (e) { if (typeof e == "string")
                        return new r(e).toString(); if (!(e instanceof r)) {
                        const c = e.username && e.password ? `${e.username}:${e.password}@` : "", n = e.auth ? e.auth + "@" : "", t = e.port ? ":" + e.port : "", s = e.protocol ? e.protocol + "//" : "", u = e.host || "", i = e.hostname || "", o = e.search || (e.query ? "?" + e.query : ""), h = e.hash || "", a = e.pathname || "";
                        return `${s}${c || n}${u || i + t}${e.path || a + o}${h}`;
                    } } };
            }, function (E, m, f) {
                "use strict";
                E.exports = { encode: f(414), decode: f(415), encodingLength: f(416) };
            }, function (E, m, f) {
                "use strict";
                const d = f(223), r = f(5), e = f(6);
                function c(n) { return parseInt(r(n, "base16"), 16); }
                E.exports = { numberToUint8Array: function (n) { let t = n.toString(16); return t.length % 2 == 1 && (t = "0" + t), e(t, "base16"); }, uint8ArrayToNumber: c, varintUint8ArrayEncode: function (n) { return Uint8Array.from(d.encode(c(n))); }, varintEncode: function (n) { return Uint8Array.from(d.encode(n)); } };
            }, function (E, m, f) {
                "use strict";
                m.read = function (d, r, e, c, n) { var t, s, u = 8 * n - c - 1, i = (1 << u) - 1, o = i >> 1, h = -7, a = e ? n - 1 : 0, l = e ? -1 : 1, p = d[r + a]; for (a += l, t = p & (1 << -h) - 1, p >>= -h, h += u; h > 0; t = 256 * t + d[r + a], a += l, h -= 8)
                    ; for (s = t & (1 << -h) - 1, t >>= -h, h += c; h > 0; s = 256 * s + d[r + a], a += l, h -= 8)
                    ; if (t === 0)
                    t = 1 - o;
                else {
                    if (t === i)
                        return s ? NaN : 1 / 0 * (p ? -1 : 1);
                    s += Math.pow(2, c), t -= o;
                } return (p ? -1 : 1) * s * Math.pow(2, t - c); }, m.write = function (d, r, e, c, n, t) { var s, u, i, o = 8 * t - n - 1, h = (1 << o) - 1, a = h >> 1, l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = c ? 0 : t - 1, g = c ? 1 : -1, b = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0; for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, s = h) : (s = Math.floor(Math.log(r) / Math.LN2), r * (i = Math.pow(2, -s)) < 1 && (s--, i *= 2), (r += s + a >= 1 ? l / i : l * Math.pow(2, 1 - a)) * i >= 2 && (s++, i /= 2), s + a >= h ? (u = 0, s = h) : s + a >= 1 ? (u = (r * i - 1) * Math.pow(2, n), s += a) : (u = r * Math.pow(2, a - 1) * Math.pow(2, n), s = 0)); n >= 8; d[e + p] = 255 & u, p += g, u /= 256, n -= 8)
                    ; for (s = s << n | u, o += n; o > 0; d[e + p] = 255 & s, p += g, s /= 256, o -= 8)
                    ; d[e + p - g] |= 128 * b; };
            }, function (E, m, f) {
                "use strict";
                var d = {}.toString;
                E.exports = Array.isArray || function (r) { return d.call(r) == "[object Array]"; };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                if (f(83), f(44), f(143), f(49), f(82), f(230), f(145), f(50), f(452), f(103), f(14), r === void 0)
                    var r = d.jsbn.BigInteger;
                var e = d.asn1, c = d.pki = d.pki || {};
                E.exports = c.pbe = d.pbe = d.pbe || {};
                var n = c.oids, t = { name: "EncryptedPrivateKeyInfo", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "EncryptedPrivateKeyInfo.encryptionAlgorithm", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: e.Class.UNIVERSAL, type: e.Type.OID, constructed: !1, capture: "encryptionOid" }, { name: "AlgorithmIdentifier.parameters", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, captureAsn1: "encryptionParams" }] }, { name: "EncryptedPrivateKeyInfo.encryptedData", tagClass: e.Class.UNIVERSAL, type: e.Type.OCTETSTRING, constructed: !1, capture: "encryptedData" }] }, s = { name: "PBES2Algorithms", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "PBES2Algorithms.keyDerivationFunc", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "PBES2Algorithms.keyDerivationFunc.oid", tagClass: e.Class.UNIVERSAL, type: e.Type.OID, constructed: !1, capture: "kdfOid" }, { name: "PBES2Algorithms.params", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "PBES2Algorithms.params.salt", tagClass: e.Class.UNIVERSAL, type: e.Type.OCTETSTRING, constructed: !1, capture: "kdfSalt" }, { name: "PBES2Algorithms.params.iterationCount", tagClass: e.Class.UNIVERSAL, type: e.Type.INTEGER, constructed: !1, capture: "kdfIterationCount" }, { name: "PBES2Algorithms.params.keyLength", tagClass: e.Class.UNIVERSAL, type: e.Type.INTEGER, constructed: !1, optional: !0, capture: "keyLength" }, { name: "PBES2Algorithms.params.prf", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, optional: !0, value: [{ name: "PBES2Algorithms.params.prf.algorithm", tagClass: e.Class.UNIVERSAL, type: e.Type.OID, constructed: !1, capture: "prfOid" }] }] }] }, { name: "PBES2Algorithms.encryptionScheme", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "PBES2Algorithms.encryptionScheme.oid", tagClass: e.Class.UNIVERSAL, type: e.Type.OID, constructed: !1, capture: "encOid" }, { name: "PBES2Algorithms.encryptionScheme.iv", tagClass: e.Class.UNIVERSAL, type: e.Type.OCTETSTRING, constructed: !1, capture: "encIv" }] }] }, u = { name: "pkcs-12PbeParams", tagClass: e.Class.UNIVERSAL, type: e.Type.SEQUENCE, constructed: !0, value: [{ name: "pkcs-12PbeParams.salt", tagClass: e.Class.UNIVERSAL, type: e.Type.OCTETSTRING, constructed: !1, capture: "salt" }, { name: "pkcs-12PbeParams.iterations", tagClass: e.Class.UNIVERSAL, type: e.Type.INTEGER, constructed: !1, capture: "iterations" }] };
                function i(a, l) { return a.start().update(l).digest().getBytes(); }
                function o(a) { var l; if (a) {
                    if (!(l = c.oids[e.derToOid(a)])) {
                        var p = new Error("Unsupported PRF OID.");
                        throw p.oid = a, p.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], p;
                    }
                }
                else
                    l = "hmacWithSHA1"; return h(l); }
                function h(a) { var l = d.md; switch (a) {
                    case "hmacWithSHA224": l = d.md.sha512;
                    case "hmacWithSHA1":
                    case "hmacWithSHA256":
                    case "hmacWithSHA384":
                    case "hmacWithSHA512":
                        a = a.substr(8).toLowerCase();
                        break;
                    default:
                        var p = new Error("Unsupported PRF algorithm.");
                        throw p.algorithm = a, p.supported = ["hmacWithSHA1", "hmacWithSHA224", "hmacWithSHA256", "hmacWithSHA384", "hmacWithSHA512"], p;
                } if (!l || !(a in l))
                    throw new Error("Unknown hash algorithm: " + a); return l[a].create(); }
                c.encryptPrivateKeyInfo = function (a, l, p) { (p = p || {}).saltSize = p.saltSize || 8, p.count = p.count || 2048, p.algorithm = p.algorithm || "aes128", p.prfAlgorithm = p.prfAlgorithm || "sha1"; var g, b, I, v = d.random.getBytesSync(p.saltSize), R = p.count, _ = e.integerToDer(R); if (p.algorithm.indexOf("aes") === 0 || p.algorithm === "des") {
                    var k, x, M;
                    switch (p.algorithm) {
                        case "aes128":
                            g = 16, k = 16, x = n["aes128-CBC"], M = d.aes.createEncryptionCipher;
                            break;
                        case "aes192":
                            g = 24, k = 16, x = n["aes192-CBC"], M = d.aes.createEncryptionCipher;
                            break;
                        case "aes256":
                            g = 32, k = 16, x = n["aes256-CBC"], M = d.aes.createEncryptionCipher;
                            break;
                        case "des":
                            g = 8, k = 8, x = n.desCBC, M = d.des.createEncryptionCipher;
                            break;
                        default: throw (L = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = p.algorithm, L;
                    }
                    var N = "hmacWith" + p.prfAlgorithm.toUpperCase(), S = h(N), T = d.pkcs5.pbkdf2(l, v, R, g, S), B = d.random.getBytesSync(k);
                    (j = M(T)).start(B), j.update(e.toDer(a)), j.finish(), I = j.output.getBytes();
                    var P = function (G, W, X, Q) { var K = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, !1, G), e.create(e.Class.UNIVERSAL, e.Type.INTEGER, !1, W.getBytes())]); return Q !== "hmacWithSHA1" && K.value.push(e.create(e.Class.UNIVERSAL, e.Type.INTEGER, !1, d.util.hexToBytes(X.toString(16))), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OID, !1, e.oidToDer(c.oids[Q]).getBytes()), e.create(e.Class.UNIVERSAL, e.Type.NULL, !1, "")])), K; }(v, _, g, N);
                    b = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OID, !1, e.oidToDer(n.pkcs5PBES2).getBytes()), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OID, !1, e.oidToDer(n.pkcs5PBKDF2).getBytes()), P]), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OID, !1, e.oidToDer(x).getBytes()), e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, !1, B)])])]);
                }
                else {
                    var L;
                    if (p.algorithm !== "3des")
                        throw (L = new Error("Cannot encrypt private key. Unknown encryption algorithm.")).algorithm = p.algorithm, L;
                    g = 24;
                    var j, D = new d.util.ByteBuffer(v);
                    T = c.pbe.generatePkcs12Key(l, D, 1, R, g), B = c.pbe.generatePkcs12Key(l, D, 2, R, g), (j = d.des.createEncryptionCipher(T)).start(B), j.update(e.toDer(a)), j.finish(), I = j.output.getBytes(), b = e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OID, !1, e.oidToDer(n["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()), e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, !1, v), e.create(e.Class.UNIVERSAL, e.Type.INTEGER, !1, _.getBytes())])]);
                } return e.create(e.Class.UNIVERSAL, e.Type.SEQUENCE, !0, [b, e.create(e.Class.UNIVERSAL, e.Type.OCTETSTRING, !1, I)]); }, c.decryptPrivateKeyInfo = function (a, l) { var p = null, g = {}, b = []; if (!e.validate(a, t, g, b)) {
                    var I = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
                    throw I.errors = b, I;
                } var v = e.derToOid(g.encryptionOid), R = c.pbe.getCipher(v, g.encryptionParams, l), _ = d.util.createBuffer(g.encryptedData); return R.update(_), R.finish() && (p = e.fromDer(R.output)), p; }, c.encryptedPrivateKeyToPem = function (a, l) { var p = { type: "ENCRYPTED PRIVATE KEY", body: e.toDer(a).getBytes() }; return d.pem.encode(p, { maxline: l }); }, c.encryptedPrivateKeyFromPem = function (a) { var l = d.pem.decode(a)[0]; if (l.type !== "ENCRYPTED PRIVATE KEY") {
                    var p = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
                    throw p.headerType = l.type, p;
                } if (l.procType && l.procType.type === "ENCRYPTED")
                    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted."); return e.fromDer(l.body); }, c.encryptRsaPrivateKey = function (a, l, p) { if (!(p = p || {}).legacy) {
                    var g = c.wrapRsaPrivateKey(c.privateKeyToAsn1(a));
                    return g = c.encryptPrivateKeyInfo(g, l, p), c.encryptedPrivateKeyToPem(g);
                } var b, I, v, R; switch (p.algorithm) {
                    case "aes128":
                        b = "AES-128-CBC", v = 16, I = d.random.getBytesSync(16), R = d.aes.createEncryptionCipher;
                        break;
                    case "aes192":
                        b = "AES-192-CBC", v = 24, I = d.random.getBytesSync(16), R = d.aes.createEncryptionCipher;
                        break;
                    case "aes256":
                        b = "AES-256-CBC", v = 32, I = d.random.getBytesSync(16), R = d.aes.createEncryptionCipher;
                        break;
                    case "3des":
                        b = "DES-EDE3-CBC", v = 24, I = d.random.getBytesSync(8), R = d.des.createEncryptionCipher;
                        break;
                    case "des":
                        b = "DES-CBC", v = 8, I = d.random.getBytesSync(8), R = d.des.createEncryptionCipher;
                        break;
                    default:
                        var _ = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + p.algorithm + '".');
                        throw _.algorithm = p.algorithm, _;
                } var k = R(d.pbe.opensslDeriveBytes(l, I.substr(0, 8), v)); k.start(I), k.update(e.toDer(c.privateKeyToAsn1(a))), k.finish(); var x = { type: "RSA PRIVATE KEY", procType: { version: "4", type: "ENCRYPTED" }, dekInfo: { algorithm: b, parameters: d.util.bytesToHex(I).toUpperCase() }, body: k.output.getBytes() }; return d.pem.encode(x); }, c.decryptRsaPrivateKey = function (a, l) { var p = null, g = d.pem.decode(a)[0]; if (g.type !== "ENCRYPTED PRIVATE KEY" && g.type !== "PRIVATE KEY" && g.type !== "RSA PRIVATE KEY")
                    throw (v = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".')).headerType = v, v; if (g.procType && g.procType.type === "ENCRYPTED") {
                    var b, I;
                    switch (g.dekInfo.algorithm) {
                        case "DES-CBC":
                            b = 8, I = d.des.createDecryptionCipher;
                            break;
                        case "DES-EDE3-CBC":
                            b = 24, I = d.des.createDecryptionCipher;
                            break;
                        case "AES-128-CBC":
                            b = 16, I = d.aes.createDecryptionCipher;
                            break;
                        case "AES-192-CBC":
                            b = 24, I = d.aes.createDecryptionCipher;
                            break;
                        case "AES-256-CBC":
                            b = 32, I = d.aes.createDecryptionCipher;
                            break;
                        case "RC2-40-CBC":
                            b = 5, I = function (k) { return d.rc2.createDecryptionCipher(k, 40); };
                            break;
                        case "RC2-64-CBC":
                            b = 8, I = function (k) { return d.rc2.createDecryptionCipher(k, 64); };
                            break;
                        case "RC2-128-CBC":
                            b = 16, I = function (k) { return d.rc2.createDecryptionCipher(k, 128); };
                            break;
                        default:
                            var v;
                            throw (v = new Error('Could not decrypt private key; unsupported encryption algorithm "' + g.dekInfo.algorithm + '".')).algorithm = g.dekInfo.algorithm, v;
                    }
                    var R = d.util.hexToBytes(g.dekInfo.parameters), _ = I(d.pbe.opensslDeriveBytes(l, R.substr(0, 8), b));
                    if (_.start(R), _.update(d.util.createBuffer(g.body)), !_.finish())
                        return p;
                    p = _.output.getBytes();
                }
                else
                    p = g.body; return (p = g.type === "ENCRYPTED PRIVATE KEY" ? c.decryptPrivateKeyInfo(e.fromDer(p), l) : e.fromDer(p)) !== null && (p = c.privateKeyFromAsn1(p)), p; }, c.pbe.generatePkcs12Key = function (a, l, p, g, b, I) { var v, R; if (I == null) {
                    if (!("sha1" in d.md))
                        throw new Error('"sha1" hash algorithm unavailable.');
                    I = d.md.sha1.create();
                } var _ = I.digestLength, k = I.blockLength, x = new d.util.ByteBuffer, M = new d.util.ByteBuffer; if (a != null) {
                    for (R = 0; R < a.length; R++)
                        M.putInt16(a.charCodeAt(R));
                    M.putInt16(0);
                } var N = M.length(), S = l.length(), T = new d.util.ByteBuffer; T.fillWithByte(p, k); var B = k * Math.ceil(S / k), P = new d.util.ByteBuffer; for (R = 0; R < B; R++)
                    P.putByte(l.at(R % S)); var L = k * Math.ceil(N / k), j = new d.util.ByteBuffer; for (R = 0; R < L; R++)
                    j.putByte(M.at(R % N)); var D = P; D.putBuffer(j); for (var G = Math.ceil(b / _), W = 1; W <= G; W++) {
                    var X = new d.util.ByteBuffer;
                    X.putBytes(T.bytes()), X.putBytes(D.bytes());
                    for (var Q = 0; Q < g; Q++)
                        I.start(), I.update(X.getBytes()), X = I.digest();
                    var K = new d.util.ByteBuffer;
                    for (R = 0; R < k; R++)
                        K.putByte(X.at(R % _));
                    var F = Math.ceil(S / k) + Math.ceil(N / k), Y = new d.util.ByteBuffer;
                    for (v = 0; v < F; v++) {
                        var $ = new d.util.ByteBuffer(D.getBytes(k)), y = 511;
                        for (R = K.length() - 1; R >= 0; R--)
                            y >>= 8, y += K.at(R) + $.at(R), $.setAt(R, 255 & y);
                        Y.putBuffer($);
                    }
                    D = Y, x.putBuffer(X);
                } return x.truncate(x.length() - b), x; }, c.pbe.getCipher = function (a, l, p) { switch (a) {
                    case c.oids.pkcs5PBES2: return c.pbe.getCipherForPBES2(a, l, p);
                    case c.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                    case c.oids["pbewithSHAAnd40BitRC2-CBC"]: return c.pbe.getCipherForPKCS12PBE(a, l, p);
                    default:
                        var g = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
                        throw g.oid = a, g.supportedOids = ["pkcs5PBES2", "pbeWithSHAAnd3-KeyTripleDES-CBC", "pbewithSHAAnd40BitRC2-CBC"], g;
                } }, c.pbe.getCipherForPBES2 = function (a, l, p) { var g, b = {}, I = []; if (!e.validate(l, s, b, I))
                    throw (g = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = I, g; if ((a = e.derToOid(b.kdfOid)) !== c.oids.pkcs5PBKDF2)
                    throw (g = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.")).oid = a, g.supportedOids = ["pkcs5PBKDF2"], g; if ((a = e.derToOid(b.encOid)) !== c.oids["aes128-CBC"] && a !== c.oids["aes192-CBC"] && a !== c.oids["aes256-CBC"] && a !== c.oids["des-EDE3-CBC"] && a !== c.oids.desCBC)
                    throw (g = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.")).oid = a, g.supportedOids = ["aes128-CBC", "aes192-CBC", "aes256-CBC", "des-EDE3-CBC", "desCBC"], g; var v, R, _ = b.kdfSalt, k = d.util.createBuffer(b.kdfIterationCount); switch (k = k.getInt(k.length() << 3), c.oids[a]) {
                    case "aes128-CBC":
                        v = 16, R = d.aes.createDecryptionCipher;
                        break;
                    case "aes192-CBC":
                        v = 24, R = d.aes.createDecryptionCipher;
                        break;
                    case "aes256-CBC":
                        v = 32, R = d.aes.createDecryptionCipher;
                        break;
                    case "des-EDE3-CBC":
                        v = 24, R = d.des.createDecryptionCipher;
                        break;
                    case "desCBC": v = 8, R = d.des.createDecryptionCipher;
                } var x = o(b.prfOid), M = d.pkcs5.pbkdf2(p, _, k, v, x), N = b.encIv, S = R(M); return S.start(N), S; }, c.pbe.getCipherForPKCS12PBE = function (a, l, p) { var g = {}, b = []; if (!e.validate(l, u, g, b))
                    throw (x = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.")).errors = b, x; var I, v, R, _ = d.util.createBuffer(g.salt), k = d.util.createBuffer(g.iterations); switch (k = k.getInt(k.length() << 3), a) {
                    case c.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
                        I = 24, v = 8, R = d.des.startDecrypting;
                        break;
                    case c.oids["pbewithSHAAnd40BitRC2-CBC"]:
                        I = 5, v = 8, R = function (S, T) { var B = d.rc2.createDecryptionCipher(S, 40); return B.start(T, null), B; };
                        break;
                    default:
                        var x;
                        throw (x = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.")).oid = a, x;
                } var M = o(g.prfOid), N = c.pbe.generatePkcs12Key(p, _, 1, k, I, M); return M.start(), R(N, c.pbe.generatePkcs12Key(p, _, 2, k, v, M)); }, c.pbe.opensslDeriveBytes = function (a, l, p, g) { if (g == null) {
                    if (!("md5" in d.md))
                        throw new Error('"md5" hash algorithm unavailable.');
                    g = d.md.md5.create();
                } l === null && (l = ""); for (var b = [i(g, a + l)], I = 16, v = 1; I < p; ++v, I += 16)
                    b.push(i(g, b[v - 1] + a + l)); return b.join("").substr(0, p); };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), E.exports = d.cipher = d.cipher || {}, d.cipher.algorithms = d.cipher.algorithms || {}, d.cipher.createCipher = function (e, c) { var n = e; if (typeof n == "string" && (n = d.cipher.getAlgorithm(n)) && (n = n()), !n)
                    throw new Error("Unsupported algorithm: " + e); return new d.cipher.BlockCipher({ algorithm: n, key: c, decrypt: !1 }); }, d.cipher.createDecipher = function (e, c) { var n = e; if (typeof n == "string" && (n = d.cipher.getAlgorithm(n)) && (n = n()), !n)
                    throw new Error("Unsupported algorithm: " + e); return new d.cipher.BlockCipher({ algorithm: n, key: c, decrypt: !0 }); }, d.cipher.registerAlgorithm = function (e, c) { e = e.toUpperCase(), d.cipher.algorithms[e] = c; }, d.cipher.getAlgorithm = function (e) { return (e = e.toUpperCase()) in d.cipher.algorithms ? d.cipher.algorithms[e] : null; };
                var r = d.cipher.BlockCipher = function (e) { this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e); };
                r.prototype.start = function (e) { e = e || {}; var c = {}; for (var n in e)
                    c[n] = e[n]; c.decrypt = this._decrypt, this._finish = !1, this._input = d.util.createBuffer(), this.output = e.output || d.util.createBuffer(), this.mode.start(c); }, r.prototype.update = function (e) { for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;)
                    ; this._input.compact(); }, r.prototype.finish = function (e) { !e || this.mode.name !== "ECB" && this.mode.name !== "CBC" || (this.mode.pad = function (n) { return e(this.blockSize, n, !1); }, this.mode.unpad = function (n) { return e(this.blockSize, n, !0); }); var c = {}; return c.decrypt = this._decrypt, c.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, c)) && (this._finish = !0, this.update(), !(this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, c)) && !(this.mode.afterFinish && !this.mode.afterFinish(this.output, c))); };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), d.cipher = d.cipher || {};
                var r = E.exports = d.cipher.modes = d.cipher.modes || {};
                function e(t, s) { if (typeof t == "string" && (t = d.util.createBuffer(t)), d.util.isArray(t) && t.length > 4) {
                    var u = t;
                    t = d.util.createBuffer();
                    for (var i = 0; i < u.length; ++i)
                        t.putByte(u[i]);
                } if (t.length() < s)
                    throw new Error("Invalid IV length; got " + t.length() + " bytes and expected " + s + " bytes."); if (!d.util.isArray(t)) {
                    var o = [], h = s / 4;
                    for (i = 0; i < h; ++i)
                        o.push(t.getInt32());
                    t = o;
                } return t; }
                function c(t) { t[t.length - 1] = t[t.length - 1] + 1 & 4294967295; }
                function n(t) { return [t / 4294967296 | 0, 4294967295 & t]; }
                r.ecb = function (t) { t = t || {}, this.name = "ECB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints); }, r.ecb.prototype.start = function (t) { }, r.ecb.prototype.encrypt = function (t, s, u) { if (t.length() < this.blockSize && !(u && t.length() > 0))
                    return !0; for (var i = 0; i < this._ints; ++i)
                    this._inBlock[i] = t.getInt32(); for (this.cipher.encrypt(this._inBlock, this._outBlock), i = 0; i < this._ints; ++i)
                    s.putInt32(this._outBlock[i]); }, r.ecb.prototype.decrypt = function (t, s, u) { if (t.length() < this.blockSize && !(u && t.length() > 0))
                    return !0; for (var i = 0; i < this._ints; ++i)
                    this._inBlock[i] = t.getInt32(); for (this.cipher.decrypt(this._inBlock, this._outBlock), i = 0; i < this._ints; ++i)
                    s.putInt32(this._outBlock[i]); }, r.ecb.prototype.pad = function (t, s) { var u = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length(); return t.fillWithByte(u, u), !0; }, r.ecb.prototype.unpad = function (t, s) { if (s.overflow > 0)
                    return !1; var u = t.length(), i = t.at(u - 1); return !(i > this.blockSize << 2) && (t.truncate(i), !0); }, r.cbc = function (t) { t = t || {}, this.name = "CBC", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints); }, r.cbc.prototype.start = function (t) { if (t.iv === null) {
                    if (!this._prev)
                        throw new Error("Invalid IV parameter.");
                    this._iv = this._prev.slice(0);
                }
                else {
                    if (!("iv" in t))
                        throw new Error("Invalid IV parameter.");
                    this._iv = e(t.iv, this.blockSize), this._prev = this._iv.slice(0);
                } }, r.cbc.prototype.encrypt = function (t, s, u) { if (t.length() < this.blockSize && !(u && t.length() > 0))
                    return !0; for (var i = 0; i < this._ints; ++i)
                    this._inBlock[i] = this._prev[i] ^ t.getInt32(); for (this.cipher.encrypt(this._inBlock, this._outBlock), i = 0; i < this._ints; ++i)
                    s.putInt32(this._outBlock[i]); this._prev = this._outBlock; }, r.cbc.prototype.decrypt = function (t, s, u) { if (t.length() < this.blockSize && !(u && t.length() > 0))
                    return !0; for (var i = 0; i < this._ints; ++i)
                    this._inBlock[i] = t.getInt32(); for (this.cipher.decrypt(this._inBlock, this._outBlock), i = 0; i < this._ints; ++i)
                    s.putInt32(this._prev[i] ^ this._outBlock[i]); this._prev = this._inBlock.slice(0); }, r.cbc.prototype.pad = function (t, s) { var u = t.length() === this.blockSize ? this.blockSize : this.blockSize - t.length(); return t.fillWithByte(u, u), !0; }, r.cbc.prototype.unpad = function (t, s) { if (s.overflow > 0)
                    return !1; var u = t.length(), i = t.at(u - 1); return !(i > this.blockSize << 2) && (t.truncate(i), !0); }, r.cfb = function (t) { t = t || {}, this.name = "CFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0; }, r.cfb.prototype.start = function (t) { if (!("iv" in t))
                    throw new Error("Invalid IV parameter."); this._iv = e(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0; }, r.cfb.prototype.encrypt = function (t, s, u) { var i = t.length(); if (i === 0)
                    return !0; if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize)
                    for (var o = 0; o < this._ints; ++o)
                        this._inBlock[o] = t.getInt32() ^ this._outBlock[o], s.putInt32(this._inBlock[o]);
                else {
                    var h = (this.blockSize - i) % this.blockSize;
                    for (h > 0 && (h = this.blockSize - h), this._partialOutput.clear(), o = 0; o < this._ints; ++o)
                        this._partialBlock[o] = t.getInt32() ^ this._outBlock[o], this._partialOutput.putInt32(this._partialBlock[o]);
                    if (h > 0)
                        t.read -= this.blockSize;
                    else
                        for (o = 0; o < this._ints; ++o)
                            this._inBlock[o] = this._partialBlock[o];
                    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), h > 0 && !u)
                        return s.putBytes(this._partialOutput.getBytes(h - this._partialBytes)), this._partialBytes = h, !0;
                    s.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0;
                } }, r.cfb.prototype.decrypt = function (t, s, u) { var i = t.length(); if (i === 0)
                    return !0; if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize)
                    for (var o = 0; o < this._ints; ++o)
                        this._inBlock[o] = t.getInt32(), s.putInt32(this._inBlock[o] ^ this._outBlock[o]);
                else {
                    var h = (this.blockSize - i) % this.blockSize;
                    for (h > 0 && (h = this.blockSize - h), this._partialOutput.clear(), o = 0; o < this._ints; ++o)
                        this._partialBlock[o] = t.getInt32(), this._partialOutput.putInt32(this._partialBlock[o] ^ this._outBlock[o]);
                    if (h > 0)
                        t.read -= this.blockSize;
                    else
                        for (o = 0; o < this._ints; ++o)
                            this._inBlock[o] = this._partialBlock[o];
                    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), h > 0 && !u)
                        return s.putBytes(this._partialOutput.getBytes(h - this._partialBytes)), this._partialBytes = h, !0;
                    s.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0;
                } }, r.ofb = function (t) { t = t || {}, this.name = "OFB", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0; }, r.ofb.prototype.start = function (t) { if (!("iv" in t))
                    throw new Error("Invalid IV parameter."); this._iv = e(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0; }, r.ofb.prototype.encrypt = function (t, s, u) { var i = t.length(); if (t.length() === 0)
                    return !0; if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize)
                    for (var o = 0; o < this._ints; ++o)
                        s.putInt32(t.getInt32() ^ this._outBlock[o]), this._inBlock[o] = this._outBlock[o];
                else {
                    var h = (this.blockSize - i) % this.blockSize;
                    for (h > 0 && (h = this.blockSize - h), this._partialOutput.clear(), o = 0; o < this._ints; ++o)
                        this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[o]);
                    if (h > 0)
                        t.read -= this.blockSize;
                    else
                        for (o = 0; o < this._ints; ++o)
                            this._inBlock[o] = this._outBlock[o];
                    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), h > 0 && !u)
                        return s.putBytes(this._partialOutput.getBytes(h - this._partialBytes)), this._partialBytes = h, !0;
                    s.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0;
                } }, r.ofb.prototype.decrypt = r.ofb.prototype.encrypt, r.ctr = function (t) { t = t || {}, this.name = "CTR", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0; }, r.ctr.prototype.start = function (t) { if (!("iv" in t))
                    throw new Error("Invalid IV parameter."); this._iv = e(t.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0; }, r.ctr.prototype.encrypt = function (t, s, u) { var i = t.length(); if (i === 0)
                    return !0; if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize)
                    for (var o = 0; o < this._ints; ++o)
                        s.putInt32(t.getInt32() ^ this._outBlock[o]);
                else {
                    var h = (this.blockSize - i) % this.blockSize;
                    for (h > 0 && (h = this.blockSize - h), this._partialOutput.clear(), o = 0; o < this._ints; ++o)
                        this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[o]);
                    if (h > 0 && (t.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), h > 0 && !u)
                        return s.putBytes(this._partialOutput.getBytes(h - this._partialBytes)), this._partialBytes = h, !0;
                    s.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0;
                } c(this._inBlock); }, r.ctr.prototype.decrypt = r.ctr.prototype.encrypt, r.gcm = function (t) { t = t || {}, this.name = "GCM", this.cipher = t.cipher, this.blockSize = t.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = d.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600; }, r.gcm.prototype.start = function (t) { if (!("iv" in t))
                    throw new Error("Invalid IV parameter."); var s, u = d.util.createBuffer(t.iv); if (this._cipherLength = 0, s = "additionalData" in t ? d.util.createBuffer(t.additionalData) : d.util.createBuffer(), this._tagLength = "tagLength" in t ? t.tagLength : 128, this._tag = null, t.decrypt && (this._tag = d.util.createBuffer(t.tag).getBytes(), this._tag.length !== this._tagLength / 8))
                    throw new Error("Authentication tag does not match tag length."); this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits); var i = u.length(); if (i === 12)
                    this._j0 = [u.getInt32(), u.getInt32(), u.getInt32(), 1];
                else {
                    for (this._j0 = [0, 0, 0, 0]; u.length() > 0;)
                        this._j0 = this.ghash(this._hashSubkey, this._j0, [u.getInt32(), u.getInt32(), u.getInt32(), u.getInt32()]);
                    this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(n(8 * i)));
                } this._inBlock = this._j0.slice(0), c(this._inBlock), this._partialBytes = 0, s = d.util.createBuffer(s), this._aDataLength = n(8 * s.length()); var o = s.length() % this.blockSize; for (o && s.fillWithByte(0, this.blockSize - o), this._s = [0, 0, 0, 0]; s.length() > 0;)
                    this._s = this.ghash(this._hashSubkey, this._s, [s.getInt32(), s.getInt32(), s.getInt32(), s.getInt32()]); }, r.gcm.prototype.encrypt = function (t, s, u) { var i = t.length(); if (i === 0)
                    return !0; if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && i >= this.blockSize) {
                    for (var o = 0; o < this._ints; ++o)
                        s.putInt32(this._outBlock[o] ^= t.getInt32());
                    this._cipherLength += this.blockSize;
                }
                else {
                    var h = (this.blockSize - i) % this.blockSize;
                    for (h > 0 && (h = this.blockSize - h), this._partialOutput.clear(), o = 0; o < this._ints; ++o)
                        this._partialOutput.putInt32(t.getInt32() ^ this._outBlock[o]);
                    if (h <= 0 || u) {
                        if (u) {
                            var a = i % this.blockSize;
                            this._cipherLength += a, this._partialOutput.truncate(this.blockSize - a);
                        }
                        else
                            this._cipherLength += this.blockSize;
                        for (o = 0; o < this._ints; ++o)
                            this._outBlock[o] = this._partialOutput.getInt32();
                        this._partialOutput.read -= this.blockSize;
                    }
                    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), h > 0 && !u)
                        return t.read -= this.blockSize, s.putBytes(this._partialOutput.getBytes(h - this._partialBytes)), this._partialBytes = h, !0;
                    s.putBytes(this._partialOutput.getBytes(i - this._partialBytes)), this._partialBytes = 0;
                } this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), c(this._inBlock); }, r.gcm.prototype.decrypt = function (t, s, u) { var i = t.length(); if (i < this.blockSize && !(u && i > 0))
                    return !0; this.cipher.encrypt(this._inBlock, this._outBlock), c(this._inBlock), this._hashBlock[0] = t.getInt32(), this._hashBlock[1] = t.getInt32(), this._hashBlock[2] = t.getInt32(), this._hashBlock[3] = t.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock); for (var o = 0; o < this._ints; ++o)
                    s.putInt32(this._outBlock[o] ^ this._hashBlock[o]); i < this.blockSize ? this._cipherLength += i % this.blockSize : this._cipherLength += this.blockSize; }, r.gcm.prototype.afterFinish = function (t, s) { var u = !0; s.decrypt && s.overflow && t.truncate(this.blockSize - s.overflow), this.tag = d.util.createBuffer(); var i = this._aDataLength.concat(n(8 * this._cipherLength)); this._s = this.ghash(this._hashSubkey, this._s, i); var o = []; this.cipher.encrypt(this._j0, o); for (var h = 0; h < this._ints; ++h)
                    this.tag.putInt32(this._s[h] ^ o[h]); return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), s.decrypt && this.tag.bytes() !== this._tag && (u = !1), u; }, r.gcm.prototype.multiply = function (t, s) { for (var u = [0, 0, 0, 0], i = s.slice(0), o = 0; o < 128; ++o)
                    t[o / 32 | 0] & 1 << 31 - o % 32 && (u[0] ^= i[0], u[1] ^= i[1], u[2] ^= i[2], u[3] ^= i[3]), this.pow(i, i); return u; }, r.gcm.prototype.pow = function (t, s) { for (var u = 1 & t[3], i = 3; i > 0; --i)
                    s[i] = t[i] >>> 1 | (1 & t[i - 1]) << 31; s[0] = t[0] >>> 1, u && (s[0] ^= this._R); }, r.gcm.prototype.tableMultiply = function (t) { for (var s = [0, 0, 0, 0], u = 0; u < 32; ++u) {
                    var i = t[u / 8 | 0] >>> 4 * (7 - u % 8) & 15, o = this._m[u][i];
                    s[0] ^= o[0], s[1] ^= o[1], s[2] ^= o[2], s[3] ^= o[3];
                } return s; }, r.gcm.prototype.ghash = function (t, s, u) { return s[0] ^= u[0], s[1] ^= u[1], s[2] ^= u[2], s[3] ^= u[3], this.tableMultiply(s); }, r.gcm.prototype.generateHashTable = function (t, s) { for (var u = 8 / s, i = 4 * u, o = 16 * u, h = new Array(o), a = 0; a < o; ++a) {
                    var l = [0, 0, 0, 0], p = (i - 1 - a % i) * s;
                    l[a / i | 0] = 1 << s - 1 << p, h[a] = this.generateSubHashTable(this.multiply(l, t), s);
                } return h; }, r.gcm.prototype.generateSubHashTable = function (t, s) { var u = 1 << s, i = u >>> 1, o = new Array(u); o[i] = t.slice(0); for (var h = i >>> 1; h > 0;)
                    this.pow(o[2 * h], o[h] = []), h >>= 1; for (h = 2; h < i;) {
                    for (var a = 1; a < h; ++a) {
                        var l = o[h], p = o[a];
                        o[h + a] = [l[0] ^ p[0], l[1] ^ p[1], l[2] ^ p[2], l[3] ^ p[3]];
                    }
                    h *= 2;
                } for (o[0] = [0, 0, 0, 0], h = i + 1; h < u; ++h) {
                    var g = o[h ^ i];
                    o[h] = [t[0] ^ g[0], t[1] ^ g[1], t[2] ^ g[2], t[3] ^ g[3]];
                } return o; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(8); f(449), f(49), f(14); var e, c = r.pkcs5 = r.pkcs5 || {}; r.util.isNodejs && !r.options.usePureJavaScript && (e = f(144)), E.exports = r.pbkdf2 = c.pbkdf2 = function (n, t, s, u, i, o) { if (typeof i == "function" && (o = i, i = null), r.util.isNodejs && !r.options.usePureJavaScript && e.pbkdf2 && (i === null || typeof i != "object") && (e.pbkdf2Sync.length > 4 || !i || i === "sha1"))
                    return typeof i != "string" && (i = "sha1"), n = d.from(n, "binary"), t = d.from(t, "binary"), o ? e.pbkdf2Sync.length === 4 ? e.pbkdf2(n, t, s, u, function (N, S) { if (N)
                        return o(N); o(null, S.toString("binary")); }) : e.pbkdf2(n, t, s, u, i, function (N, S) { if (N)
                        return o(N); o(null, S.toString("binary")); }) : e.pbkdf2Sync.length === 4 ? e.pbkdf2Sync(n, t, s, u).toString("binary") : e.pbkdf2Sync(n, t, s, u, i).toString("binary"); if (i == null && (i = "sha1"), typeof i == "string") {
                    if (!(i in r.md.algorithms))
                        throw new Error("Unknown hash algorithm: " + i);
                    i = r.md[i].create();
                } var h = i.digestLength; if (u > 4294967295 * h) {
                    var a = new Error("Derived key is too long.");
                    if (o)
                        return o(a);
                    throw a;
                } var l = Math.ceil(u / h), p = u - (l - 1) * h, g = r.hmac.create(); g.start(i, n); var b, I, v, R = ""; if (!o) {
                    for (var _ = 1; _ <= l; ++_) {
                        g.start(null, null), g.update(t), g.update(r.util.int32ToBytes(_)), b = v = g.digest().getBytes();
                        for (var k = 2; k <= s; ++k)
                            g.start(null, null), g.update(v), I = g.digest().getBytes(), b = r.util.xorBytes(b, I, h), v = I;
                        R += _ < l ? b : b.substr(0, p);
                    }
                    return R;
                } _ = 1; function x() { if (_ > l)
                    return o(null, R); g.start(null, null), g.update(t), g.update(r.util.int32ToBytes(_)), b = v = g.digest().getBytes(), k = 2, M(); } function M() { if (k <= s)
                    return g.start(null, null), g.update(v), I = g.digest().getBytes(), b = r.util.xorBytes(b, I, h), v = I, ++k, r.util.setImmediate(M); R += _ < l ? b : b.substr(0, p), ++_, x(); } x(); }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(31), r = f(6), e = f(105);
                E.exports = { create: function ({ algorithm: c = "AES-GCM", nonceLength: n = 12, keyLength: t = 16, digest: s = "SHA-256", saltLength: u = 16, iterations: i = 32767 } = {}) { const o = e.get(); return t *= 8, { encrypt: async function (h, a) { const l = o.getRandomValues(new Uint8Array(u)), p = o.getRandomValues(new Uint8Array(n)), g = { name: c, iv: p }, b = { name: "PBKDF2", salt: l, iterations: i, hash: { name: s } }, I = await o.subtle.importKey("raw", r(a), { name: "PBKDF2" }, !1, ["deriveKey", "deriveBits"]), v = await o.subtle.deriveKey(b, I, { name: c, length: t }, !0, ["encrypt"]), R = await o.subtle.encrypt(g, v, h); return d([l, g.iv, new Uint8Array(R)]); }, decrypt: async function (h, a) { const l = h.slice(0, u), p = h.slice(u, u + n), g = h.slice(u + n), b = { name: c, iv: p }, I = { name: "PBKDF2", salt: l, iterations: i, hash: { name: s } }, v = await o.subtle.importKey("raw", r(a), { name: "PBKDF2" }, !1, ["deriveKey", "deriveBits"]), R = await o.subtle.deriveKey(I, v, { name: c, length: t }, !0, ["decrypt"]), _ = await o.subtle.decrypt(b, R, g); return new Uint8Array(_); } }; } };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(8); f(104), f(50), f(146), f(14); var e = f(458), c = e.publicKeyValidator, n = e.privateKeyValidator; if (t === void 0)
                    var t = r.jsbn.BigInteger; var s = r.util.ByteBuffer, u = d === void 0 ? Uint8Array : d; r.pki = r.pki || {}, E.exports = r.pki.ed25519 = r.ed25519 = r.ed25519 || {}; var i = r.ed25519; function o($) { var y = $.message; if (y instanceof Uint8Array || y instanceof u)
                    return y; var C = $.encoding; if (y === void 0) {
                    if (!$.md)
                        throw new TypeError('"options.message" or "options.md" not specified.');
                    y = $.md.digest().getBytes(), C = "binary";
                } if (typeof y == "string" && !C)
                    throw new TypeError('"options.encoding" must be "binary" or "utf8".'); if (typeof y == "string") {
                    if (d !== void 0)
                        return d.from(y, C);
                    y = new s(y, C);
                }
                else if (!(y instanceof s))
                    throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'); for (var A = new u(y.length()), U = 0; U < A.length; ++U)
                    A[U] = y.at(U); return A; } i.constants = {}, i.constants.PUBLIC_KEY_BYTE_LENGTH = 32, i.constants.PRIVATE_KEY_BYTE_LENGTH = 64, i.constants.SEED_BYTE_LENGTH = 32, i.constants.SIGN_BYTE_LENGTH = 64, i.constants.HASH_BYTE_LENGTH = 64, i.generateKeyPair = function ($) { var y = ($ = $ || {}).seed; if (y === void 0)
                    y = r.random.getBytesSync(i.constants.SEED_BYTE_LENGTH);
                else if (typeof y == "string") {
                    if (y.length !== i.constants.SEED_BYTE_LENGTH)
                        throw new TypeError('"seed" must be ' + i.constants.SEED_BYTE_LENGTH + " bytes in length.");
                }
                else if (!(y instanceof Uint8Array))
                    throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.'); y = o({ message: y, encoding: "binary" }); for (var C = new u(i.constants.PUBLIC_KEY_BYTE_LENGTH), A = new u(i.constants.PRIVATE_KEY_BYTE_LENGTH), U = 0; U < 32; ++U)
                    A[U] = y[U]; return function (z, w) { var O, q = [X(), X(), X(), X()], H = R(w, 32); for (H[0] &= 248, H[31] &= 127, H[31] |= 64, j(q, H), N(z, q), O = 0; O < 32; ++O)
                    w[O + 32] = z[O]; }(C, A), { publicKey: C, privateKey: A }; }, i.privateKeyFromAsn1 = function ($) { var y = {}, C = []; if (!r.asn1.validate($, n, y, C)) {
                    var A = new Error("Invalid Key.");
                    throw A.errors = C, A;
                } var U = r.asn1.derToOid(y.privateKeyOid), z = r.oids.EdDSA25519; if (U !== z)
                    throw new Error('Invalid OID "' + U + '"; OID must be "' + z + '".'); var w = y.privateKey; return { privateKeyBytes: o({ message: r.asn1.fromDer(w).value, encoding: "binary" }) }; }, i.publicKeyFromAsn1 = function ($) { var y = {}, C = []; if (!r.asn1.validate($, c, y, C)) {
                    var A = new Error("Invalid Key.");
                    throw A.errors = C, A;
                } var U = r.asn1.derToOid(y.publicKeyOid), z = r.oids.EdDSA25519; if (U !== z)
                    throw new Error('Invalid OID "' + U + '"; OID must be "' + z + '".'); var w = y.ed25519PublicKey; if (w.length !== i.constants.PUBLIC_KEY_BYTE_LENGTH)
                    throw new Error("Key length is invalid."); return o({ message: w, encoding: "binary" }); }, i.publicKeyFromPrivateKey = function ($) { var y = o({ message: ($ = $ || {}).privateKey, encoding: "binary" }); if (y.length !== i.constants.PRIVATE_KEY_BYTE_LENGTH)
                    throw new TypeError('"options.privateKey" must have a byte length of ' + i.constants.PRIVATE_KEY_BYTE_LENGTH); for (var C = new u(i.constants.PUBLIC_KEY_BYTE_LENGTH), A = 0; A < C.length; ++A)
                    C[A] = y[32 + A]; return C; }, i.sign = function ($) { var y = o($ = $ || {}), C = o({ message: $.privateKey, encoding: "binary" }); if (C.length === i.constants.SEED_BYTE_LENGTH)
                    C = i.generateKeyPair({ seed: C }).privateKey;
                else if (C.length !== i.constants.PRIVATE_KEY_BYTE_LENGTH)
                    throw new TypeError('"options.privateKey" must have a byte length of ' + i.constants.SEED_BYTE_LENGTH + " or " + i.constants.PRIVATE_KEY_BYTE_LENGTH); var A = new u(i.constants.SIGN_BYTE_LENGTH + y.length); !function (w, O, q, H) { var V, J, Z = new Float64Array(64), tt = [X(), X(), X(), X()], nt = R(H, 32); nt[0] &= 248, nt[31] &= 127, nt[31] |= 64; var rt = q + 64; for (V = 0; V < q; ++V)
                    w[64 + V] = O[V]; for (V = 0; V < 32; ++V)
                    w[32 + V] = nt[32 + V]; var it = R(w.subarray(32), q + 32); for (k(it), j(tt, it), N(w, tt), V = 32; V < 64; ++V)
                    w[V] = H[V]; var st = R(w, q + 64); for (k(st), V = 32; V < 64; ++V)
                    Z[V] = 0; for (V = 0; V < 32; ++V)
                    Z[V] = it[V]; for (V = 0; V < 32; ++V)
                    for (J = 0; J < 32; J++)
                        Z[V + J] += st[V] * nt[J]; _(w.subarray(32), Z); }(A, y, y.length, C); for (var U = new u(i.constants.SIGN_BYTE_LENGTH), z = 0; z < U.length; ++z)
                    U[z] = A[z]; return U; }, i.verify = function ($) { var y = o($ = $ || {}); if ($.signature === void 0)
                    throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'); var C = o({ message: $.signature, encoding: "binary" }); if (C.length !== i.constants.SIGN_BYTE_LENGTH)
                    throw new TypeError('"options.signature" must have a byte length of ' + i.constants.SIGN_BYTE_LENGTH); var A = o({ message: $.publicKey, encoding: "binary" }); if (A.length !== i.constants.PUBLIC_KEY_BYTE_LENGTH)
                    throw new TypeError('"options.publicKey" must have a byte length of ' + i.constants.PUBLIC_KEY_BYTE_LENGTH); var U, z = new u(i.constants.SIGN_BYTE_LENGTH + y.length), w = new u(i.constants.SIGN_BYTE_LENGTH + y.length); for (U = 0; U < i.constants.SIGN_BYTE_LENGTH; ++U)
                    z[U] = C[U]; for (U = 0; U < y.length; ++U)
                    z[U + i.constants.SIGN_BYTE_LENGTH] = y[U]; return function (O, q, H, V) { var J, Z = new u(32), tt = [X(), X(), X(), X()], nt = [X(), X(), X(), X()]; if (H < 64)
                    return -1; if (function (it, st) { var at = X(), ct = X(), lt = X(), pt = X(), mt = X(), Tt = X(), vt = X(); return D(it[2], a), function (Rt, Bt) { var wt; for (wt = 0; wt < 16; ++wt)
                    Rt[wt] = Bt[2 * wt] + (Bt[2 * wt + 1] << 8); Rt[15] &= 32767; }(it[1], st), F(lt, it[1]), Y(pt, lt, l), K(lt, lt, it[2]), Q(pt, it[2], pt), F(mt, pt), F(Tt, mt), Y(vt, Tt, mt), Y(at, vt, lt), Y(at, at, pt), function (Rt, Bt) { var wt, kt = X(); for (wt = 0; wt < 16; ++wt)
                    kt[wt] = Bt[wt]; for (wt = 250; wt >= 0; --wt)
                    F(kt, kt), wt !== 1 && Y(kt, kt, Bt); for (wt = 0; wt < 16; ++wt)
                    Rt[wt] = kt[wt]; }(at, at), Y(at, at, lt), Y(at, at, pt), Y(at, at, pt), Y(it[0], at, pt), F(ct, it[0]), Y(ct, ct, pt), T(ct, lt) && Y(it[0], it[0], v), (F(ct, it[0]), Y(ct, ct, pt), T(ct, lt)) ? -1 : (P(it[0]) === st[31] >> 7 && K(it[0], h, it[0]), Y(it[3], it[0], it[1]), 0); }(nt, V))
                    return -1; for (J = 0; J < H; ++J)
                    O[J] = q[J]; for (J = 0; J < 32; ++J)
                    O[J + 32] = V[J]; var rt = R(O, H); if (k(rt), L(tt, nt, rt), j(nt, q.subarray(32)), x(tt, nt), N(Z, tt), H -= 64, B(q, 0, Z, 0)) {
                    for (J = 0; J < H; ++J)
                        O[J] = 0;
                    return -1;
                } for (J = 0; J < H; ++J)
                    O[J] = q[J + 64]; return H; }(w, z, z.length, A) >= 0; }; var h = X(), a = X([1]), l = X([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), p = X([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), g = X([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), b = X([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]), v = X([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]); function R($, y) { var C = r.md.sha512.create(), A = new s($); C.update(A.getBytes(y), "binary"); var U = C.digest().getBytes(); if (d !== void 0)
                    return d.from(U, "binary"); for (var z = new u(i.constants.HASH_BYTE_LENGTH), w = 0; w < 64; ++w)
                    z[w] = U.charCodeAt(w); return z; } function _($, y) { var C, A, U, z; for (A = 63; A >= 32; --A) {
                    for (C = 0, U = A - 32, z = A - 12; U < z; ++U)
                        y[U] += C - 16 * y[A] * I[U - (A - 32)], C = y[U] + 128 >> 8, y[U] -= 256 * C;
                    y[U] += C, y[A] = 0;
                } for (C = 0, U = 0; U < 32; ++U)
                    y[U] += C - (y[31] >> 4) * I[U], C = y[U] >> 8, y[U] &= 255; for (U = 0; U < 32; ++U)
                    y[U] -= C * I[U]; for (A = 0; A < 32; ++A)
                    y[A + 1] += y[A] >> 8, $[A] = 255 & y[A]; } function k($) { for (var y = new Float64Array(64), C = 0; C < 64; ++C)
                    y[C] = $[C], $[C] = 0; _($, y); } function x($, y) { var C = X(), A = X(), U = X(), z = X(), w = X(), O = X(), q = X(), H = X(), V = X(); K(C, $[1], $[0]), K(V, y[1], y[0]), Y(C, C, V), Q(A, $[0], $[1]), Q(V, y[0], y[1]), Y(A, A, V), Y(U, $[3], y[3]), Y(U, U, p), Y(z, $[2], y[2]), Q(z, z, z), K(w, A, C), K(O, z, U), Q(q, z, U), Q(H, A, C), Y($[0], w, O), Y($[1], H, q), Y($[2], q, O), Y($[3], w, H); } function M($, y, C) { for (var A = 0; A < 4; ++A)
                    W($[A], y[A], C); } function N($, y) { var C = X(), A = X(), U = X(); !function (z, w) { var O, q = X(); for (O = 0; O < 16; ++O)
                    q[O] = w[O]; for (O = 253; O >= 0; --O)
                    F(q, q), O !== 2 && O !== 4 && Y(q, q, w); for (O = 0; O < 16; ++O)
                    z[O] = q[O]; }(U, y[2]), Y(C, y[0], U), Y(A, y[1], U), S($, A), $[31] ^= P(C) << 7; } function S($, y) { var C, A, U, z = X(), w = X(); for (C = 0; C < 16; ++C)
                    w[C] = y[C]; for (G(w), G(w), G(w), A = 0; A < 2; ++A) {
                    for (z[0] = w[0] - 65517, C = 1; C < 15; ++C)
                        z[C] = w[C] - 65535 - (z[C - 1] >> 16 & 1), z[C - 1] &= 65535;
                    z[15] = w[15] - 32767 - (z[14] >> 16 & 1), U = z[15] >> 16 & 1, z[14] &= 65535, W(w, z, 1 - U);
                } for (C = 0; C < 16; C++)
                    $[2 * C] = 255 & w[C], $[2 * C + 1] = w[C] >> 8; } function T($, y) { var C = new u(32), A = new u(32); return S(C, $), S(A, y), B(C, 0, A, 0); } function B($, y, C, A) { return function (U, z, w, O, q) { var H, V = 0; for (H = 0; H < q; ++H)
                    V |= U[z + H] ^ w[O + H]; return (1 & V - 1 >>> 8) - 1; }($, y, C, A, 32); } function P($) { var y = new u(32); return S(y, $), 1 & y[0]; } function L($, y, C) { var A, U; for (D($[0], h), D($[1], a), D($[2], a), D($[3], h), U = 255; U >= 0; --U)
                    M($, y, A = C[U / 8 | 0] >> (7 & U) & 1), x(y, $), x($, $), M($, y, A); } function j($, y) { var C = [X(), X(), X(), X()]; D(C[0], g), D(C[1], b), D(C[2], a), Y(C[3], g, b), L($, C, y); } function D($, y) { var C; for (C = 0; C < 16; C++)
                    $[C] = 0 | y[C]; } function G($) { var y, C, A = 1; for (y = 0; y < 16; ++y)
                    C = $[y] + A + 65535, A = Math.floor(C / 65536), $[y] = C - 65536 * A; $[0] += A - 1 + 37 * (A - 1); } function W($, y, C) { for (var A, U = ~(C - 1), z = 0; z < 16; ++z)
                    A = U & ($[z] ^ y[z]), $[z] ^= A, y[z] ^= A; } function X($) { var y, C = new Float64Array(16); if ($)
                    for (y = 0; y < $.length; ++y)
                        C[y] = $[y]; return C; } function Q($, y, C) { for (var A = 0; A < 16; ++A)
                    $[A] = y[A] + C[A]; } function K($, y, C) { for (var A = 0; A < 16; ++A)
                    $[A] = y[A] - C[A]; } function F($, y) { Y($, y, y); } function Y($, y, C) { var A, U, z = 0, w = 0, O = 0, q = 0, H = 0, V = 0, J = 0, Z = 0, tt = 0, nt = 0, rt = 0, it = 0, st = 0, at = 0, ct = 0, lt = 0, pt = 0, mt = 0, Tt = 0, vt = 0, Rt = 0, Bt = 0, wt = 0, kt = 0, Wt = 0, Ct = 0, Ft = 0, te = 0, jt = 0, Kt = 0, re = 0, St = C[0], Nt = C[1], ne = C[2], Vt = C[3], qt = C[4], ee = C[5], Ot = C[6], ft = C[7], gt = C[8], bt = C[9], _t = C[10], Lt = C[11], Pt = C[12], Mt = C[13], Yt = C[14], Dt = C[15]; z += (A = y[0]) * St, w += A * Nt, O += A * ne, q += A * Vt, H += A * qt, V += A * ee, J += A * Ot, Z += A * ft, tt += A * gt, nt += A * bt, rt += A * _t, it += A * Lt, st += A * Pt, at += A * Mt, ct += A * Yt, lt += A * Dt, w += (A = y[1]) * St, O += A * Nt, q += A * ne, H += A * Vt, V += A * qt, J += A * ee, Z += A * Ot, tt += A * ft, nt += A * gt, rt += A * bt, it += A * _t, st += A * Lt, at += A * Pt, ct += A * Mt, lt += A * Yt, pt += A * Dt, O += (A = y[2]) * St, q += A * Nt, H += A * ne, V += A * Vt, J += A * qt, Z += A * ee, tt += A * Ot, nt += A * ft, rt += A * gt, it += A * bt, st += A * _t, at += A * Lt, ct += A * Pt, lt += A * Mt, pt += A * Yt, mt += A * Dt, q += (A = y[3]) * St, H += A * Nt, V += A * ne, J += A * Vt, Z += A * qt, tt += A * ee, nt += A * Ot, rt += A * ft, it += A * gt, st += A * bt, at += A * _t, ct += A * Lt, lt += A * Pt, pt += A * Mt, mt += A * Yt, Tt += A * Dt, H += (A = y[4]) * St, V += A * Nt, J += A * ne, Z += A * Vt, tt += A * qt, nt += A * ee, rt += A * Ot, it += A * ft, st += A * gt, at += A * bt, ct += A * _t, lt += A * Lt, pt += A * Pt, mt += A * Mt, Tt += A * Yt, vt += A * Dt, V += (A = y[5]) * St, J += A * Nt, Z += A * ne, tt += A * Vt, nt += A * qt, rt += A * ee, it += A * Ot, st += A * ft, at += A * gt, ct += A * bt, lt += A * _t, pt += A * Lt, mt += A * Pt, Tt += A * Mt, vt += A * Yt, Rt += A * Dt, J += (A = y[6]) * St, Z += A * Nt, tt += A * ne, nt += A * Vt, rt += A * qt, it += A * ee, st += A * Ot, at += A * ft, ct += A * gt, lt += A * bt, pt += A * _t, mt += A * Lt, Tt += A * Pt, vt += A * Mt, Rt += A * Yt, Bt += A * Dt, Z += (A = y[7]) * St, tt += A * Nt, nt += A * ne, rt += A * Vt, it += A * qt, st += A * ee, at += A * Ot, ct += A * ft, lt += A * gt, pt += A * bt, mt += A * _t, Tt += A * Lt, vt += A * Pt, Rt += A * Mt, Bt += A * Yt, wt += A * Dt, tt += (A = y[8]) * St, nt += A * Nt, rt += A * ne, it += A * Vt, st += A * qt, at += A * ee, ct += A * Ot, lt += A * ft, pt += A * gt, mt += A * bt, Tt += A * _t, vt += A * Lt, Rt += A * Pt, Bt += A * Mt, wt += A * Yt, kt += A * Dt, nt += (A = y[9]) * St, rt += A * Nt, it += A * ne, st += A * Vt, at += A * qt, ct += A * ee, lt += A * Ot, pt += A * ft, mt += A * gt, Tt += A * bt, vt += A * _t, Rt += A * Lt, Bt += A * Pt, wt += A * Mt, kt += A * Yt, Wt += A * Dt, rt += (A = y[10]) * St, it += A * Nt, st += A * ne, at += A * Vt, ct += A * qt, lt += A * ee, pt += A * Ot, mt += A * ft, Tt += A * gt, vt += A * bt, Rt += A * _t, Bt += A * Lt, wt += A * Pt, kt += A * Mt, Wt += A * Yt, Ct += A * Dt, it += (A = y[11]) * St, st += A * Nt, at += A * ne, ct += A * Vt, lt += A * qt, pt += A * ee, mt += A * Ot, Tt += A * ft, vt += A * gt, Rt += A * bt, Bt += A * _t, wt += A * Lt, kt += A * Pt, Wt += A * Mt, Ct += A * Yt, Ft += A * Dt, st += (A = y[12]) * St, at += A * Nt, ct += A * ne, lt += A * Vt, pt += A * qt, mt += A * ee, Tt += A * Ot, vt += A * ft, Rt += A * gt, Bt += A * bt, wt += A * _t, kt += A * Lt, Wt += A * Pt, Ct += A * Mt, Ft += A * Yt, te += A * Dt, at += (A = y[13]) * St, ct += A * Nt, lt += A * ne, pt += A * Vt, mt += A * qt, Tt += A * ee, vt += A * Ot, Rt += A * ft, Bt += A * gt, wt += A * bt, kt += A * _t, Wt += A * Lt, Ct += A * Pt, Ft += A * Mt, te += A * Yt, jt += A * Dt, ct += (A = y[14]) * St, lt += A * Nt, pt += A * ne, mt += A * Vt, Tt += A * qt, vt += A * ee, Rt += A * Ot, Bt += A * ft, wt += A * gt, kt += A * bt, Wt += A * _t, Ct += A * Lt, Ft += A * Pt, te += A * Mt, jt += A * Yt, Kt += A * Dt, lt += (A = y[15]) * St, w += 38 * (mt += A * ne), O += 38 * (Tt += A * Vt), q += 38 * (vt += A * qt), H += 38 * (Rt += A * ee), V += 38 * (Bt += A * Ot), J += 38 * (wt += A * ft), Z += 38 * (kt += A * gt), tt += 38 * (Wt += A * bt), nt += 38 * (Ct += A * _t), rt += 38 * (Ft += A * Lt), it += 38 * (te += A * Pt), st += 38 * (jt += A * Mt), at += 38 * (Kt += A * Yt), ct += 38 * (re += A * Dt), z = (A = (z += 38 * (pt += A * Nt)) + (U = 1) + 65535) - 65536 * (U = Math.floor(A / 65536)), w = (A = w + U + 65535) - 65536 * (U = Math.floor(A / 65536)), O = (A = O + U + 65535) - 65536 * (U = Math.floor(A / 65536)), q = (A = q + U + 65535) - 65536 * (U = Math.floor(A / 65536)), H = (A = H + U + 65535) - 65536 * (U = Math.floor(A / 65536)), V = (A = V + U + 65535) - 65536 * (U = Math.floor(A / 65536)), J = (A = J + U + 65535) - 65536 * (U = Math.floor(A / 65536)), Z = (A = Z + U + 65535) - 65536 * (U = Math.floor(A / 65536)), tt = (A = tt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), nt = (A = nt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), rt = (A = rt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), it = (A = it + U + 65535) - 65536 * (U = Math.floor(A / 65536)), st = (A = st + U + 65535) - 65536 * (U = Math.floor(A / 65536)), at = (A = at + U + 65535) - 65536 * (U = Math.floor(A / 65536)), ct = (A = ct + U + 65535) - 65536 * (U = Math.floor(A / 65536)), lt = (A = lt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), z = (A = (z += U - 1 + 37 * (U - 1)) + (U = 1) + 65535) - 65536 * (U = Math.floor(A / 65536)), w = (A = w + U + 65535) - 65536 * (U = Math.floor(A / 65536)), O = (A = O + U + 65535) - 65536 * (U = Math.floor(A / 65536)), q = (A = q + U + 65535) - 65536 * (U = Math.floor(A / 65536)), H = (A = H + U + 65535) - 65536 * (U = Math.floor(A / 65536)), V = (A = V + U + 65535) - 65536 * (U = Math.floor(A / 65536)), J = (A = J + U + 65535) - 65536 * (U = Math.floor(A / 65536)), Z = (A = Z + U + 65535) - 65536 * (U = Math.floor(A / 65536)), tt = (A = tt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), nt = (A = nt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), rt = (A = rt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), it = (A = it + U + 65535) - 65536 * (U = Math.floor(A / 65536)), st = (A = st + U + 65535) - 65536 * (U = Math.floor(A / 65536)), at = (A = at + U + 65535) - 65536 * (U = Math.floor(A / 65536)), ct = (A = ct + U + 65535) - 65536 * (U = Math.floor(A / 65536)), lt = (A = lt + U + 65535) - 65536 * (U = Math.floor(A / 65536)), z += U - 1 + 37 * (U - 1), $[0] = z, $[1] = w, $[2] = O, $[3] = q, $[4] = H, $[5] = V, $[6] = J, $[7] = Z, $[8] = tt, $[9] = nt, $[10] = rt, $[11] = it, $[12] = st, $[13] = at, $[14] = ct, $[15] = lt; } }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d = m;
                function r(c) { return c.length === 1 ? "0" + c : c; }
                function e(c) { for (var n = "", t = 0; t < c.length; t++)
                    n += r(c[t].toString(16)); return n; }
                d.toArray = function (c, n) { if (Array.isArray(c))
                    return c.slice(); if (!c)
                    return []; var t = []; if (typeof c != "string") {
                    for (var s = 0; s < c.length; s++)
                        t[s] = 0 | c[s];
                    return t;
                } if (n === "hex")
                    for ((c = c.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (c = "0" + c), s = 0; s < c.length; s += 2)
                        t.push(parseInt(c[s] + c[s + 1], 16));
                else
                    for (s = 0; s < c.length; s++) {
                        var u = c.charCodeAt(s), i = u >> 8, o = 255 & u;
                        i ? t.push(i, o) : t.push(o);
                    } return t; }, d.zero2 = r, d.toHex = e, d.encode = function (c, n) { return n === "hex" ? e(c) : c; };
            }, function (E, m, f) {
                "use strict";
                var d;
                function r(c) { this.rand = c; }
                if (E.exports = function (c) { return d || (d = new r(null)), d.generate(c); }, E.exports.Rand = r, r.prototype.generate = function (c) { return this._rand(c); }, r.prototype._rand = function (c) { if (this.rand.getBytes)
                    return this.rand.getBytes(c); for (var n = new Uint8Array(c), t = 0; t < n.length; t++)
                    n[t] = this.rand.getByte(); return n; }, typeof self == "object")
                    self.crypto && self.crypto.getRandomValues ? r.prototype._rand = function (c) { var n = new Uint8Array(c); return self.crypto.getRandomValues(n), n; } : self.msCrypto && self.msCrypto.getRandomValues ? r.prototype._rand = function (c) { var n = new Uint8Array(c); return self.msCrypto.getRandomValues(n), n; } : typeof window == "object" && (r.prototype._rand = function () { throw new Error("Not implemented yet"); });
                else
                    try {
                        var e = f(473);
                        if (typeof e.randomBytes != "function")
                            throw new Error("Not supported");
                        r.prototype._rand = function (c) { return e.randomBytes(c); };
                    }
                    catch (c) { }
            }, function (E, m, f) {
                "use strict";
                var d = m;
                d.base = f(108), d.short = f(474), d.mont = f(475), d.edwards = f(476);
            }, function (E, m, f) {
                "use strict";
                var d = f(36).rotr32;
                function r(n, t, s) { return n & t ^ ~n & s; }
                function e(n, t, s) { return n & t ^ n & s ^ t & s; }
                function c(n, t, s) { return n ^ t ^ s; }
                m.ft_1 = function (n, t, s, u) { return n === 0 ? r(t, s, u) : n === 1 || n === 3 ? c(t, s, u) : n === 2 ? e(t, s, u) : void 0; }, m.ch32 = r, m.maj32 = e, m.p32 = c, m.s0_256 = function (n) { return d(n, 2) ^ d(n, 13) ^ d(n, 22); }, m.s1_256 = function (n) { return d(n, 6) ^ d(n, 11) ^ d(n, 25); }, m.g0_256 = function (n) { return d(n, 7) ^ d(n, 18) ^ n >>> 3; }, m.g1_256 = function (n) { return d(n, 17) ^ d(n, 19) ^ n >>> 10; };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(85), e = f(236), c = f(51), n = d.sum32, t = d.sum32_4, s = d.sum32_5, u = e.ch32, i = e.maj32, o = e.s0_256, h = e.s1_256, a = e.g0_256, l = e.g1_256, p = r.BlockHash, g = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
                function b() { if (!(this instanceof b))
                    return new b; p.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = g, this.W = new Array(64); }
                d.inherits(b, p), E.exports = b, b.blockSize = 512, b.outSize = 256, b.hmacStrength = 192, b.padLength = 64, b.prototype._update = function (I, v) { for (var R = this.W, _ = 0; _ < 16; _++)
                    R[_] = I[v + _]; for (; _ < R.length; _++)
                    R[_] = t(l(R[_ - 2]), R[_ - 7], a(R[_ - 15]), R[_ - 16]); var k = this.h[0], x = this.h[1], M = this.h[2], N = this.h[3], S = this.h[4], T = this.h[5], B = this.h[6], P = this.h[7]; for (c(this.k.length === R.length), _ = 0; _ < R.length; _++) {
                    var L = s(P, h(S), u(S, T, B), this.k[_], R[_]), j = n(o(k), i(k, x, M));
                    P = B, B = T, T = S, S = n(N, L), N = M, M = x, x = k, k = n(L, j);
                } this.h[0] = n(this.h[0], k), this.h[1] = n(this.h[1], x), this.h[2] = n(this.h[2], M), this.h[3] = n(this.h[3], N), this.h[4] = n(this.h[4], S), this.h[5] = n(this.h[5], T), this.h[6] = n(this.h[6], B), this.h[7] = n(this.h[7], P); }, b.prototype._digest = function (I) { return I === "hex" ? d.toHex32(this.h, "big") : d.split32(this.h, "big"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(85), e = f(51), c = d.rotr64_hi, n = d.rotr64_lo, t = d.shr64_hi, s = d.shr64_lo, u = d.sum64, i = d.sum64_hi, o = d.sum64_lo, h = d.sum64_4_hi, a = d.sum64_4_lo, l = d.sum64_5_hi, p = d.sum64_5_lo, g = r.BlockHash, b = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
                function I() { if (!(this instanceof I))
                    return new I; g.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = b, this.W = new Array(160); }
                function v(j, D, G, W, X) { var Q = j & G ^ ~j & X; return Q < 0 && (Q += 4294967296), Q; }
                function R(j, D, G, W, X, Q) { var K = D & W ^ ~D & Q; return K < 0 && (K += 4294967296), K; }
                function _(j, D, G, W, X) { var Q = j & G ^ j & X ^ G & X; return Q < 0 && (Q += 4294967296), Q; }
                function k(j, D, G, W, X, Q) { var K = D & W ^ D & Q ^ W & Q; return K < 0 && (K += 4294967296), K; }
                function x(j, D) { var G = c(j, D, 28) ^ c(D, j, 2) ^ c(D, j, 7); return G < 0 && (G += 4294967296), G; }
                function M(j, D) { var G = n(j, D, 28) ^ n(D, j, 2) ^ n(D, j, 7); return G < 0 && (G += 4294967296), G; }
                function N(j, D) { var G = c(j, D, 14) ^ c(j, D, 18) ^ c(D, j, 9); return G < 0 && (G += 4294967296), G; }
                function S(j, D) { var G = n(j, D, 14) ^ n(j, D, 18) ^ n(D, j, 9); return G < 0 && (G += 4294967296), G; }
                function T(j, D) { var G = c(j, D, 1) ^ c(j, D, 8) ^ t(j, D, 7); return G < 0 && (G += 4294967296), G; }
                function B(j, D) { var G = n(j, D, 1) ^ n(j, D, 8) ^ s(j, D, 7); return G < 0 && (G += 4294967296), G; }
                function P(j, D) { var G = c(j, D, 19) ^ c(D, j, 29) ^ t(j, D, 6); return G < 0 && (G += 4294967296), G; }
                function L(j, D) { var G = n(j, D, 19) ^ n(D, j, 29) ^ s(j, D, 6); return G < 0 && (G += 4294967296), G; }
                d.inherits(I, g), E.exports = I, I.blockSize = 1024, I.outSize = 512, I.hmacStrength = 192, I.padLength = 128, I.prototype._prepareBlock = function (j, D) { for (var G = this.W, W = 0; W < 32; W++)
                    G[W] = j[D + W]; for (; W < G.length; W += 2) {
                    var X = P(G[W - 4], G[W - 3]), Q = L(G[W - 4], G[W - 3]), K = G[W - 14], F = G[W - 13], Y = T(G[W - 30], G[W - 29]), $ = B(G[W - 30], G[W - 29]), y = G[W - 32], C = G[W - 31];
                    G[W] = h(X, Q, K, F, Y, $, y, C), G[W + 1] = a(X, Q, K, F, Y, $, y, C);
                } }, I.prototype._update = function (j, D) { this._prepareBlock(j, D); var G = this.W, W = this.h[0], X = this.h[1], Q = this.h[2], K = this.h[3], F = this.h[4], Y = this.h[5], $ = this.h[6], y = this.h[7], C = this.h[8], A = this.h[9], U = this.h[10], z = this.h[11], w = this.h[12], O = this.h[13], q = this.h[14], H = this.h[15]; e(this.k.length === G.length); for (var V = 0; V < G.length; V += 2) {
                    var J = q, Z = H, tt = N(C, A), nt = S(C, A), rt = v(C, A, U, z, w), it = R(C, A, U, z, w, O), st = this.k[V], at = this.k[V + 1], ct = G[V], lt = G[V + 1], pt = l(J, Z, tt, nt, rt, it, st, at, ct, lt), mt = p(J, Z, tt, nt, rt, it, st, at, ct, lt);
                    J = x(W, X), Z = M(W, X), tt = _(W, X, Q, K, F), nt = k(W, X, Q, K, F, Y);
                    var Tt = i(J, Z, tt, nt), vt = o(J, Z, tt, nt);
                    q = w, H = O, w = U, O = z, U = C, z = A, C = i($, y, pt, mt), A = o(y, y, pt, mt), $ = F, y = Y, F = Q, Y = K, Q = W, K = X, W = i(pt, mt, Tt, vt), X = o(pt, mt, Tt, vt);
                } u(this.h, 0, W, X), u(this.h, 2, Q, K), u(this.h, 4, F, Y), u(this.h, 6, $, y), u(this.h, 8, C, A), u(this.h, 10, U, z), u(this.h, 12, w, O), u(this.h, 14, q, H); }, I.prototype._digest = function (j) { return j === "hex" ? d.toHex32(this.h, "big") : d.split32(this.h, "big"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(105), r = f(492), e = { SHA1: "SHA-1", SHA256: "SHA-256", SHA512: "SHA-512" };
                m.create = async function (c, n) { const t = e[c], s = await d.get().subtle.importKey("raw", n, { name: "HMAC", hash: { name: t } }, !1, ["sign"]); return { digest: async (u) => (async (i, o) => { const h = await d.get().subtle.sign({ name: "HMAC" }, i, o); return new Uint8Array(h, h.byteOffset, h.byteLength); })(s, u), length: r[c] }; };
            }, function (E, m, f) {
                "use strict";
                const d = self.location ? self.location.protocol + "//" + self.location.host : "", r = self.URL;
                E.exports = { URLWithLegacySupport: class {
                        constructor(e = "", c = d) { this.super = new r(e, c), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null; }
                        get hash() { return this.super.hash; }
                        get host() { return this.super.host; }
                        get hostname() { return this.super.hostname; }
                        get href() { return this.super.href; }
                        get origin() { return this.super.origin; }
                        get password() { return this.super.password; }
                        get pathname() { return this.super.pathname; }
                        get port() { return this.super.port; }
                        get protocol() { return this.super.protocol; }
                        get search() { return this.super.search; }
                        get searchParams() { return this.super.searchParams; }
                        get username() { return this.super.username; }
                        set hash(e) { this.super.hash = e; }
                        set host(e) { this.super.host = e; }
                        set hostname(e) { this.super.hostname = e; }
                        set href(e) { this.super.href = e; }
                        set origin(e) { this.super.origin = e; }
                        set password(e) { this.super.password = e; }
                        set pathname(e) { this.super.pathname = e; }
                        set port(e) { this.super.port = e; }
                        set protocol(e) { this.super.protocol = e; }
                        set search(e) { this.super.search = e; }
                        set searchParams(e) { this.super.searchParams = e; }
                        set username(e) { this.super.username = e; }
                        createObjectURL(e) { return this.super.createObjectURL(e); }
                        revokeObjectURL(e) { this.super.revokeObjectURL(e); }
                        toJSON() { return this.super.toJSON(); }
                        toString() { return this.super.toString(); }
                        format() { return this.toString(); }
                    }, URLSearchParams: self.URLSearchParams, defaultBase: d, format: function (e) { if (typeof e == "string")
                        return new r(e).toString(); if (!(e instanceof r)) {
                        const c = e.username && e.password ? `${e.username}:${e.password}@` : "", n = e.auth ? e.auth + "@" : "", t = e.port ? ":" + e.port : "", s = e.protocol ? e.protocol + "//" : "", u = e.host || "", i = e.hostname || "", o = e.search || (e.query ? "?" + e.query : ""), h = e.hash || "", a = e.pathname || "";
                        return `${s}${c || n}${u || i + t}${e.path || a + o}${h}`;
                    } } };
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    function r(e) { return (4294967296 + e).toString(16).substring(1); }
                    E.exports = { normalizeInput: function (e) { var c; if (e instanceof Uint8Array)
                            c = e;
                        else if (e instanceof d)
                            c = new Uint8Array(e);
                        else {
                            if (typeof e != "string")
                                throw new Error("Input must be an string, Buffer or Uint8Array");
                            c = new Uint8Array(d.from(e, "utf8"));
                        } return c; }, toHex: function (e) { return Array.prototype.map.call(e, function (c) { return (c < 16 ? "0" : "") + c.toString(16); }).join(""); }, debugPrint: function (e, c, n) {
                            for (var t = `
` + e + " = ", s = 0; s < c.length; s += 2) {
                                if (n === 32)
                                    t += r(c[s]).toUpperCase(), t += " ", t += r(c[s + 1]).toUpperCase();
                                else {
                                    if (n !== 64)
                                        throw new Error("Invalid size " + n);
                                    t += r(c[s + 1]).toUpperCase(), t += r(c[s]).toUpperCase();
                                }
                                s % 6 == 4 ? t += `
` + new Array(e.length + 4).join(" ") : s < c.length - 2 && (t += " ");
                            }
                            console.log(t);
                        }, testSpeed: function (e, c, n) { for (var t = new Date().getTime(), s = new Uint8Array(c), u = 0; u < c; u++)
                            s[u] = u % 256; var i = new Date().getTime(); for (console.log("Generated random input in " + (i - t) + "ms"), t = i, u = 0; u < n; u++) {
                            var o = e(s), h = new Date().getTime(), a = h - t;
                            t = h, console.log("Hashed in " + a + "ms: " + o.substring(0, 20) + "..."), console.log(Math.round(c / (1 << 20) / (a / 1e3) * 100) / 100 + " MB PER SECOND");
                        } } };
                }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const { nanoid: d } = f(243), r = f(26), { utf8Encoder: e, utf8Decoder: c } = f(151), n = f(245), t = e.encode("/"), s = t[0];
                class u {
                    constructor(h, a) { if (typeof h == "string")
                        this._buf = e.encode(h);
                    else {
                        if (!(h instanceof Uint8Array))
                            throw new Error("Invalid key, should be String of Uint8Array");
                        this._buf = h;
                    } if (a == null && (a = !0), a && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== s)
                        throw new Error("Invalid key"); }
                    toString(h = "utf8") { return h === "utf8" || h === "utf-8" ? c.decode(this._buf) : new n(h).decode(this._buf); }
                    uint8Array() { return this._buf; }
                    get [Symbol.toStringTag]() { return `Key(${this.toString()})`; }
                    static withNamespaces(h) { return new i(h.join("/")); }
                    static random() { return new i(d().replace(/-/g, "")); }
                    clean() { if (this._buf && this._buf.byteLength !== 0 || (this._buf = t), this._buf[0] !== s) {
                        const h = new Uint8Array(this._buf.byteLength + 1);
                        h.fill(s, 0, 1), h.set(this._buf, 1), this._buf = h;
                    } for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === s;)
                        this._buf = this._buf.subarray(0, -1); }
                    less(h) { const a = this.list(), l = h.list(); for (let p = 0; p < a.length; p++) {
                        if (l.length < p + 1)
                            return !1;
                        const g = a[p], b = l[p];
                        if (g < b)
                            return !0;
                        if (g > b)
                            return !1;
                    } return a.length < l.length; }
                    reverse() { return u.withNamespaces(this.list().slice().reverse()); }
                    namespaces() { return this.list(); }
                    baseNamespace() { const h = this.namespaces(); return h[h.length - 1]; }
                    list() { return this.toString().split("/").slice(1); }
                    type() { return function (h) { const a = h.split(":"); return a.length < 2 ? "" : a.slice(0, -1).join(":"); }(this.baseNamespace()); }
                    name() { return function (h) { const a = h.split(":"); return a[a.length - 1]; }(this.baseNamespace()); }
                    instance(h) { return new i(this.toString() + ":" + h); }
                    path() { let h = this.parent().toString(); return h.endsWith("/") || (h += "/"), h += this.type(), new i(h); }
                    parent() { const h = this.list(); return h.length === 1 ? new i("/") : new i(h.slice(0, -1).join("/")); }
                    child(h) { return this.toString() === "/" ? h : h.toString() === "/" ? this : new i(this.toString() + h.toString(), !1); }
                    isAncestorOf(h) { return h.toString() !== this.toString() && h.toString().startsWith(this.toString()); }
                    isDecendantOf(h) { return h.toString() !== this.toString() && this.toString().startsWith(h.toString()); }
                    isTopLevel() { return this.list().length === 1; }
                    concat(...h) { return u.withNamespaces([...this.namespaces(), ...(a = h.map(l => l.namespaces()), [].concat(...a))]); var a; }
                }
                const i = r(u, { className: "Key", symbolName: "@ipfs/interface-datastore/key" });
                E.exports = i;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), Object.defineProperty(m, "urlAlphabet", { enumerable: !0, get: function () { return d.urlAlphabet; } }), m.random = m.customRandom = m.customAlphabet = m.nanoid = void 0;
                var d = f(519);
                let r = c => crypto.getRandomValues(new Uint8Array(c));
                m.random = r;
                let e = (c, n, t) => { let s = (2 << Math.log(c.length - 1) / Math.LN2) - 1, u = -~(1.6 * s * n / c.length); return () => { let i = ""; for (;;) {
                    let o = t(u), h = u;
                    for (; h--;)
                        if (i += c[o[h] & s] || "", i.length === n)
                            return i;
                } }; };
                m.customRandom = e, m.customAlphabet = (c, n) => e(c, n, r), m.nanoid = (c = 21) => { let n = "", t = crypto.getRandomValues(new Uint8Array(c)); for (; c--;) {
                    let s = 63 & t[c];
                    n += s < 36 ? s.toString(36) : s < 62 ? (s - 26).toString(36).toUpperCase() : s < 63 ? "_" : "-";
                } return n; };
            }, function (E, m, f) {
                "use strict";
                typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this; }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__), E.exports = globalThis;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(244).TextDecoder;
            }, function (E, m, f) {
                "use strict";
                const { filter: d, sortAll: r, take: e, map: c } = f(151), n = f(247);
                E.exports = class {
                    async open() { }
                    async close() { }
                    async put(t, s, u = {}) { }
                    async *putMany(t, s = {}) { for await (const { key: u, value: i } of t)
                        await this.put(u, i, s), yield { key: u, value: i }; }
                    async get(t, s = {}) { }
                    async *getMany(t, s = {}) { for await (const u of t)
                        yield this.get(u, s); }
                    async has(t) { }
                    async delete(t, s = {}) { }
                    async *deleteMany(t, s = {}) { for await (const u of t)
                        await this.delete(u, s), yield u; }
                    batch() { let t = [], s = []; return { put(u, i) { t.push({ key: u, value: i }); }, delete(u) { s.push(u); }, commit: async (u) => { await n(this.putMany(t, u)), t = [], await n(this.deleteMany(s, u)), s = []; } }; }
                    async *_all(t, s) { }
                    async *query(t, s) { let u = this._all(t, s); if (t.prefix != null && (u = d(u, i => i.key.toString().startsWith(t.prefix))), Array.isArray(t.filters) && (u = t.filters.reduce((i, o) => d(i, o), u)), Array.isArray(t.orders) && (u = t.orders.reduce((i, o) => r(i, o), u)), t.offset != null) {
                        let i = 0;
                        u = d(u, () => i++ >= t.offset);
                    } t.limit != null && (u = e(u, t.limit)), t.keysOnly === !0 && (u = c(u, i => ({ key: i.key }))), yield* u; }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { for await (const r of d)
                    ; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0);
                E.exports.dbOpenFailedError = r => (r = r || new Error("Cannot open database"), d(r, "ERR_DB_OPEN_FAILED")), E.exports.dbDeleteFailedError = r => (r = r || new Error("Delete failed"), d(r, "ERR_DB_DELETE_FAILED")), E.exports.dbWriteFailedError = r => (r = r || new Error("Write failed"), d(r, "ERR_DB_WRITE_FAILED")), E.exports.notFoundError = r => (r = r || new Error("Not Found"), d(r, "ERR_NOT_FOUND")), E.exports.abortedError = r => (r = r || new Error("Aborted"), d(r, "ERR_ABORTED"));
            }, function (E, m, f) {
                "use strict";
                const { AbortController: d } = typeof self != "undefined" ? self : typeof window != "undefined" ? window : f(47), r = f(152);
                class e extends d {
                    constructor(n) { super(), this._ms = n, this._timer = r(() => this.abort(), n), Object.setPrototypeOf(this, e.prototype); }
                    abort() { return this._timer.clear(), super.abort(); }
                    clear() { this._timer.clear(); }
                    reset() { this._timer.clear(), this._timer = r(() => this.abort(), this._ms); }
                }
                E.exports = e, E.exports.TimeoutController = e;
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = f(251), e = f(61), { serializeDAGNode: c } = f(253), n = f(529), t = f(530), s = f(532), u = f(6), i = f(5);
                E.exports = d(class {
                    constructor(o, h = [], a = null) { if (o || (o = new Uint8Array(0)), typeof o == "string" && (o = u(o)), !(o instanceof Uint8Array))
                        throw new Error("Passed 'data' is not a Uint8Array or a String!"); if (a !== null && typeof a != "number")
                        throw new Error("Passed 'serializedSize' must be a number!"); h = h.map(l => e.isDAGLink(l) ? l : e.util.createDagLinkFromB58EncodedHash(l)), r(h), Object.defineProperties(this, { Data: { value: o, writable: !1, enumerable: !0 }, Links: { value: h, writable: !1, enumerable: !0 }, _serializedSize: { value: a, writable: !0, enumerable: !1 }, _size: { value: null, writable: !0, enumerable: !1 } }); }
                    toJSON() { return this._json || (this._json = Object.freeze({ data: this.Data, links: this.Links.map(o => o.toJSON()), size: this.size })), Object.assign({}, this._json); }
                    toString() { return `DAGNode <data: "${i(this.Data, "base64urlpad")}", links: ${this.Links.length}, size: ${this.size}>`; }
                    _invalidateCached() { this._serializedSize = null, this._size = null; }
                    addLink(o) { return this._invalidateCached(), t(this, o); }
                    rmLink(o) { return this._invalidateCached(), s(this, o); }
                    toDAGLink(o) { return n(this, o); }
                    serialize() { return c(this); }
                    get size() { return this._size === null && (this._serializedSize === null && (this._serializedSize = this.serialize().length), this._size = this.Links.reduce((o, h) => o + h.Tsize, this._serializedSize)), this._size; }
                    set size(o) { throw new Error("Can't set property: 'size' is immutable"); }
                }, { className: "DAGNode", symbolName: "@ipld/js-ipld-dag-pb/dagnode" });
            }, function (E, m, f) {
                "use strict";
                const d = f(528), r = f(252), e = (c, n) => { const t = c.nameAsBuffer, s = n.nameAsBuffer; return r(t, s); };
                E.exports = c => { d.inplace(c, e); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { for (let e = 0; e < d.byteLength; e++) {
                    if (d[e] < r[e])
                        return -1;
                    if (d[e] > r[e])
                        return 1;
                } return d.byteLength > r.byteLength ? 1 : d.byteLength < r.byteLength ? -1 : 0; };
            }, function (E, m, f) {
                "use strict";
                const d = f(21)(f(254)), r = f(61);
                m = E.exports;
                const e = c => { const n = c.Data, t = c.Links || []; return d.PBNode.encode((s => { const u = {}; return s.Data && s.Data.byteLength > 0 ? u.Data = s.Data : u.Data = null, s.Links && s.Links.length > 0 ? u.Links = s.Links.map(i => ({ Hash: i.Hash.bytes, Name: i.Name, Tsize: i.Tsize })) : u.Links = null, u; })({ Data: n, Links: t })); };
                m.serializeDAGNode = e, m.serializeDAGNodeLike = (c, n = []) => { const t = { Data: c }; return t.Links = n.map(s => r.isDAGLink(s) ? s : r.util.createDagLinkFromB58EncodedHash(s)), e(t); };
            }, function (E, m, f) {
                "use strict";
                E.exports = `// An IPFS MerkleDAG Link
message PBLink {

  // multihash of the target object
  optional bytes Hash = 1;

  // utf string name. should be unique per object
  optional string Name = 2;

  // cumulative size of target object
  optional uint64 Tsize = 3;
}

// An IPFS MerkleDAG Node
message PBNode {

  // refs to other objects
  repeated PBLink Links = 2;

  // opaque user data
  optional bytes Data = 1;
}`;
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(18), e = f(16);
                (m = E.exports).codec = r.DAG_PB, m.defaultHashAlg = r.SHA2_256, m.cid = async (c, n) => { const t = { cidVersion: 1, hashAlg: m.defaultHashAlg }, s = Object.assign(t, n), u = await e(c, s.hashAlg), i = r.print[m.codec]; return new d(s.cidVersion, i, u); };
            }, function (E, m, f) {
                "use strict";
                (E.exports = f(61)).util = f(531);
            }, function (E, m, f) {
                "use strict";
                const d = f(21)(f(254)), r = f(61), e = f(250), { serializeDAGNodeLike: c } = f(253), n = f(255);
                (m = E.exports).codec = n.codec, m.defaultHashAlg = n.defaultHashAlg, m.serialize = t => e.isDAGNode(t) ? t.serialize() : c(t.Data, t.Links), m.deserialize = t => { const s = d.PBNode.decode(t), u = s.Links.map(o => new r(o.Name, o.Tsize, o.Hash)), i = s.Data == null ? new Uint8Array(0) : s.Data; return new e(i, u, t.byteLength); }, m.cid = (t, s) => n.cid(t, s);
            }, function (E, m, f) {
                "use strict";
                const d = f(112);
                E.exports = class {
                    constructor(r) { this.lru = d(r); }
                    get(r) { const e = this.lru.get(r); if (e)
                        return e.expire && e.expire < Date.now() ? void this.lru.remove(r) : e.value; }
                    set(r, e, c) { this.lru.set(r, { value: e, expire: Date.now() + c }); }
                    has(r) { return !!this.get(r); }
                    remove(r) { this.lru.remove(r); }
                    clear() { this.lru.clear(); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(4);
                m.cidToString = (r, e = {}) => { const c = e.upgrade !== !1; let n = d.isCID(r) ? r : new d(r); if (n.version === 0 && e.base && e.base !== "base58btc") {
                    if (!c)
                        return n.toString();
                    n = n.toV1();
                } return n.toBaseEncodedString(e.base); };
            }, function (E, m, f) {
                "use strict";
                const d = f(550), r = f(18), e = f(16), c = f(4), n = f(555), t = f(31), s = f(6);
                function u(l) { let p; try {
                    p = n(l);
                }
                catch (g) {
                    p = !1;
                } if (p)
                    throw new Error("The object passed has circular references"); return function g(b) { if (!b || b instanceof Uint8Array || typeof b == "string")
                    return b; if (Array.isArray(b))
                    return b.map(g); if (c.isCID(b))
                    return typeof (I = b) == "string" ? I = new c(I).bytes : c.isCID(I) && (I = I.bytes), new d.Tagged(42, t([s("00", "base16"), I], 1 + I.length)); var I; const v = Object.keys(b); if (v.length > 0) {
                    const R = {};
                    return v.forEach(_ => { typeof b[_] == "object" ? R[_] = g(b[_]) : R[_] = b[_]; }), R;
                } return b; }(l); }
                (m = E.exports).codec = r.DAG_CBOR, m.defaultHashAlg = r.SHA2_256;
                const i = { 42: l => (l = l.slice(1), new c(l)) };
                let o = 65536, h = 67108864, a = null;
                m.configureDecoder = l => { let p = i; l ? (typeof l.size == "number" && (o = l.size), typeof l.maxSize == "number" && (h = l.maxSize), l.tags && (p = Object.assign({}, i, l && l.tags))) : (o = 65536, h = 67108864); const g = { tags: p, size: o }; a = new d.Decoder(g), o = g.size; }, m.configureDecoder(), m.serialize = l => { const p = u(l); return d.encode(p); }, m.deserialize = l => { if (l.length > o && l.length <= h && m.configureDecoder({ size: l.length }), l.length > o)
                    throw new Error("Data is too large to deserialize with current decoder"); const p = a.decodeAll(l); if (p.length !== 1)
                    throw new Error("Extraneous CBOR data found beyond initial top-level object"); return p[0]; }, m.cid = async (l, p) => { const g = { cidVersion: 1, hashAlg: m.defaultHashAlg }, b = Object.assign(g, p), I = await e(l, b.hashAlg), v = r.print[m.codec]; return new c(b.cidVersion, v, I); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const { Buffer: r } = f(3), e = f(225), c = f(30).BigNumber, n = f(552), t = f(156), s = f(113), u = f(262), i = f(263), { URL: o } = f(264); class h {
                    constructor(l) { !(l = l || {}).size || l.size < 65536 ? l.size = 65536 : l.size = t.nextPowerOf2(l.size), this._heap = new ArrayBuffer(l.size), this._heap8 = new Uint8Array(this._heap), this._buffer = r.from(this._heap), this._reset(), this._knownTags = Object.assign({ 0: p => new Date(p), 1: p => new Date(1e3 * p), 2: p => t.arrayBufferToBignumber(p), 3: p => s.NEG_ONE.minus(t.arrayBufferToBignumber(p)), 4: p => s.TEN.pow(p[0]).times(p[1]), 5: p => s.TWO.pow(p[0]).times(p[1]), 32: p => new o(p), 35: p => new RegExp(p) }, l.tags), this.parser = n(d, { log: console.log.bind(console), pushInt: this.pushInt.bind(this), pushInt32: this.pushInt32.bind(this), pushInt32Neg: this.pushInt32Neg.bind(this), pushInt64: this.pushInt64.bind(this), pushInt64Neg: this.pushInt64Neg.bind(this), pushFloat: this.pushFloat.bind(this), pushFloatSingle: this.pushFloatSingle.bind(this), pushFloatDouble: this.pushFloatDouble.bind(this), pushTrue: this.pushTrue.bind(this), pushFalse: this.pushFalse.bind(this), pushUndefined: this.pushUndefined.bind(this), pushNull: this.pushNull.bind(this), pushInfinity: this.pushInfinity.bind(this), pushInfinityNeg: this.pushInfinityNeg.bind(this), pushNaN: this.pushNaN.bind(this), pushNaNNeg: this.pushNaNNeg.bind(this), pushArrayStart: this.pushArrayStart.bind(this), pushArrayStartFixed: this.pushArrayStartFixed.bind(this), pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this), pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this), pushObjectStart: this.pushObjectStart.bind(this), pushObjectStartFixed: this.pushObjectStartFixed.bind(this), pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this), pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this), pushByteString: this.pushByteString.bind(this), pushByteStringStart: this.pushByteStringStart.bind(this), pushUtf8String: this.pushUtf8String.bind(this), pushUtf8StringStart: this.pushUtf8StringStart.bind(this), pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this), pushTagUnassigned: this.pushTagUnassigned.bind(this), pushTagStart: this.pushTagStart.bind(this), pushTagStart4: this.pushTagStart4.bind(this), pushTagStart8: this.pushTagStart8.bind(this), pushBreak: this.pushBreak.bind(this) }, this._heap); }
                    get _depth() { return this._parents.length; }
                    get _currentParent() { return this._parents[this._depth - 1]; }
                    get _ref() { return this._currentParent.ref; }
                    _closeParent() { var l = this._parents.pop(); if (l.length > 0)
                        throw new Error(`Missing ${l.length} elements`); switch (l.type) {
                        case s.PARENT.TAG:
                            this._push(this.createTag(l.ref[0], l.ref[1]));
                            break;
                        case s.PARENT.BYTE_STRING:
                            this._push(this.createByteString(l.ref, l.length));
                            break;
                        case s.PARENT.UTF8_STRING:
                            this._push(this.createUtf8String(l.ref, l.length));
                            break;
                        case s.PARENT.MAP:
                            if (l.values % 2 > 0)
                                throw new Error("Odd number of elements in the map");
                            this._push(this.createMap(l.ref, l.length));
                            break;
                        case s.PARENT.OBJECT:
                            if (l.values % 2 > 0)
                                throw new Error("Odd number of elements in the map");
                            this._push(this.createObject(l.ref, l.length));
                            break;
                        case s.PARENT.ARRAY: this._push(this.createArray(l.ref, l.length));
                    } this._currentParent && this._currentParent.type === s.PARENT.TAG && this._dec(); }
                    _dec() { const l = this._currentParent; l.length < 0 || (l.length--, l.length === 0 && this._closeParent()); }
                    _push(l, p) { const g = this._currentParent; switch (g.values++, g.type) {
                        case s.PARENT.ARRAY:
                        case s.PARENT.BYTE_STRING:
                        case s.PARENT.UTF8_STRING:
                            g.length > -1 ? this._ref[this._ref.length - g.length] = l : this._ref.push(l), this._dec();
                            break;
                        case s.PARENT.OBJECT:
                            g.tmpKey != null ? (this._ref[g.tmpKey] = l, g.tmpKey = null, this._dec()) : (g.tmpKey = l, typeof g.tmpKey != "string" && (g.type = s.PARENT.MAP, g.ref = t.buildMap(g.ref)));
                            break;
                        case s.PARENT.MAP:
                            g.tmpKey != null ? (this._ref.set(g.tmpKey, l), g.tmpKey = null, this._dec()) : g.tmpKey = l;
                            break;
                        case s.PARENT.TAG:
                            this._ref.push(l), p || this._dec();
                            break;
                        default: throw new Error("Unknown parent type");
                    } }
                    _createParent(l, p, g) { this._parents[this._depth] = { type: p, length: g, ref: l, values: 0, tmpKey: null }; }
                    _reset() { this._res = [], this._parents = [{ type: s.PARENT.ARRAY, length: -1, ref: this._res, values: 0, tmpKey: null }]; }
                    createTag(l, p) { const g = this._knownTags[l]; return g ? g(p) : new i(l, p); }
                    createMap(l, p) { return l; }
                    createObject(l, p) { return l; }
                    createArray(l, p) { return l; }
                    createByteString(l, p) { return r.concat(l); }
                    createByteStringFromHeap(l, p) { return l === p ? r.alloc(0) : r.from(this._heap.slice(l, p)); }
                    createInt(l) { return l; }
                    createInt32(l, p) { return t.buildInt32(l, p); }
                    createInt64(l, p, g, b) { return t.buildInt64(l, p, g, b); }
                    createFloat(l) { return l; }
                    createFloatSingle(l, p, g, b) { return e.read([l, p, g, b], 0, !1, 23, 4); }
                    createFloatDouble(l, p, g, b, I, v, R, _) { return e.read([l, p, g, b, I, v, R, _], 0, !1, 52, 8); }
                    createInt32Neg(l, p) { return -1 - t.buildInt32(l, p); }
                    createInt64Neg(l, p, g, b) { const I = t.buildInt32(l, p), v = t.buildInt32(g, b); return I > s.MAX_SAFE_HIGH ? s.NEG_ONE.minus(new c(I).times(s.SHIFT32).plus(v)) : -1 - (I * s.SHIFT32 + v); }
                    createTrue() { return !0; }
                    createFalse() { return !1; }
                    createNull() { return null; }
                    createUndefined() { }
                    createInfinity() { return 1 / 0; }
                    createInfinityNeg() { return -1 / 0; }
                    createNaN() { return NaN; }
                    createNaNNeg() { return NaN; }
                    createUtf8String(l, p) { return l.join(""); }
                    createUtf8StringFromHeap(l, p) { return l === p ? "" : this._buffer.toString("utf8", l, p); }
                    createSimpleUnassigned(l) { return new u(l); }
                    pushInt(l) { this._push(this.createInt(l)); }
                    pushInt32(l, p) { this._push(this.createInt32(l, p)); }
                    pushInt64(l, p, g, b) { this._push(this.createInt64(l, p, g, b)); }
                    pushFloat(l) { this._push(this.createFloat(l)); }
                    pushFloatSingle(l, p, g, b) { this._push(this.createFloatSingle(l, p, g, b)); }
                    pushFloatDouble(l, p, g, b, I, v, R, _) { this._push(this.createFloatDouble(l, p, g, b, I, v, R, _)); }
                    pushInt32Neg(l, p) { this._push(this.createInt32Neg(l, p)); }
                    pushInt64Neg(l, p, g, b) { this._push(this.createInt64Neg(l, p, g, b)); }
                    pushTrue() { this._push(this.createTrue()); }
                    pushFalse() { this._push(this.createFalse()); }
                    pushNull() { this._push(this.createNull()); }
                    pushUndefined() { this._push(this.createUndefined()); }
                    pushInfinity() { this._push(this.createInfinity()); }
                    pushInfinityNeg() { this._push(this.createInfinityNeg()); }
                    pushNaN() { this._push(this.createNaN()); }
                    pushNaNNeg() { this._push(this.createNaNNeg()); }
                    pushArrayStart() { this._createParent([], s.PARENT.ARRAY, -1); }
                    pushArrayStartFixed(l) { this._createArrayStartFixed(l); }
                    pushArrayStartFixed32(l, p) { const g = t.buildInt32(l, p); this._createArrayStartFixed(g); }
                    pushArrayStartFixed64(l, p, g, b) { const I = t.buildInt64(l, p, g, b); this._createArrayStartFixed(I); }
                    pushObjectStart() { this._createObjectStartFixed(-1); }
                    pushObjectStartFixed(l) { this._createObjectStartFixed(l); }
                    pushObjectStartFixed32(l, p) { const g = t.buildInt32(l, p); this._createObjectStartFixed(g); }
                    pushObjectStartFixed64(l, p, g, b) { const I = t.buildInt64(l, p, g, b); this._createObjectStartFixed(I); }
                    pushByteStringStart() { this._parents[this._depth] = { type: s.PARENT.BYTE_STRING, length: -1, ref: [], values: 0, tmpKey: null }; }
                    pushByteString(l, p) { this._push(this.createByteStringFromHeap(l, p)); }
                    pushUtf8StringStart() { this._parents[this._depth] = { type: s.PARENT.UTF8_STRING, length: -1, ref: [], values: 0, tmpKey: null }; }
                    pushUtf8String(l, p) { this._push(this.createUtf8StringFromHeap(l, p)); }
                    pushSimpleUnassigned(l) { this._push(this.createSimpleUnassigned(l)); }
                    pushTagStart(l) { this._parents[this._depth] = { type: s.PARENT.TAG, length: 1, ref: [l] }; }
                    pushTagStart4(l, p) { this.pushTagStart(t.buildInt32(l, p)); }
                    pushTagStart8(l, p, g, b) { this.pushTagStart(t.buildInt64(l, p, g, b)); }
                    pushTagUnassigned(l) { this._push(this.createTag(l)); }
                    pushBreak() { if (this._currentParent.length > -1)
                        throw new Error("Unexpected break"); this._closeParent(); }
                    _createObjectStartFixed(l) { l !== 0 ? this._createParent({}, s.PARENT.OBJECT, l) : this._push(this.createObject({})); }
                    _createArrayStartFixed(l) { l !== 0 ? this._createParent(new Array(l), s.PARENT.ARRAY, l) : this._push(this.createArray([])); }
                    _decode(l) { if (l.byteLength === 0)
                        throw new Error("Input too short"); this._reset(), this._heap8.set(l); const p = this.parser.parse(l.byteLength); if (this._depth > 1) {
                        for (; this._currentParent.length === 0;)
                            this._closeParent();
                        if (this._depth > 1)
                            throw new Error("Undeterminated nesting");
                    } if (p > 0)
                        throw new Error("Failed to parse"); if (this._res.length === 0)
                        throw new Error("No valid result"); }
                    decodeFirst(l) { return this._decode(l), this._res[0]; }
                    decodeAll(l) { return this._decode(l), this._res; }
                    static decode(l, p) { return typeof l == "string" && (l = r.from(l, p || "hex")), new h({ size: l.length }).decodeFirst(l); }
                    static decodeAll(l, p) { return typeof l == "string" && (l = r.from(l, p || "hex")), new h({ size: l.length }).decodeAll(l); }
                } h.decodeFirst = h.decode, E.exports = h; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = f(113), r = d.MT, e = d.SIMPLE, c = d.SYMS;
                class n {
                    constructor(s) { if (typeof s != "number")
                        throw new Error("Invalid Simple type: " + typeof s); if (s < 0 || s > 255 || (0 | s) !== s)
                        throw new Error("value must be a small positive integer: " + s); this.value = s; }
                    toString() { return "simple(" + this.value + ")"; }
                    inspect() { return "simple(" + this.value + ")"; }
                    encodeCBOR(s) { return s._pushInt(this.value, r.SIMPLE_FLOAT); }
                    static isSimple(s) { return s instanceof n; }
                    static decode(s, u) { switch (u == null && (u = !0), s) {
                        case e.FALSE: return !1;
                        case e.TRUE: return !0;
                        case e.NULL: return u ? null : c.NULL;
                        case e.UNDEFINED: return u ? void 0 : c.UNDEFINED;
                        case -1:
                            if (!u)
                                throw new Error("Invalid BREAK");
                            return c.BREAK;
                        default: return new n(s);
                    } }
                }
                E.exports = n;
            }, function (E, m, f) {
                "use strict";
                class d {
                    constructor(e, c, n) { if (this.tag = e, this.value = c, this.err = n, typeof this.tag != "number")
                        throw new Error("Invalid tag type (" + typeof this.tag + ")"); if (this.tag < 0 || (0 | this.tag) !== this.tag)
                        throw new Error("Tag must be a positive integer: " + this.tag); }
                    toString() { return `${this.tag}(${JSON.stringify(this.value)})`; }
                    encodeCBOR(e) { return e._pushTag(this.tag), e.pushAny(this.value); }
                    convert(e) { var c, n; if (typeof (n = e != null ? e[this.tag] : void 0) != "function" && typeof (n = d["_tag" + this.tag]) != "function")
                        return this; try {
                        return n.call(d, this.value);
                    }
                    catch (t) {
                        return c = t, this.err = c, this;
                    } }
                }
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r, URLSearchParams: e, defaultBase: c } = f(265), n = f(553);
                E.exports = { URL: d, URLSearchParams: e, format: r, relative: n, defaultBase: c };
            }, function (E, m, f) {
                "use strict";
                const d = self.location ? self.location.protocol + "//" + self.location.host : "", r = self.URL;
                E.exports = { URLWithLegacySupport: class {
                        constructor(e = "", c = d) { this.super = new r(e, c), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null; }
                        get hash() { return this.super.hash; }
                        get host() { return this.super.host; }
                        get hostname() { return this.super.hostname; }
                        get href() { return this.super.href; }
                        get origin() { return this.super.origin; }
                        get password() { return this.super.password; }
                        get pathname() { return this.super.pathname; }
                        get port() { return this.super.port; }
                        get protocol() { return this.super.protocol; }
                        get search() { return this.super.search; }
                        get searchParams() { return this.super.searchParams; }
                        get username() { return this.super.username; }
                        set hash(e) { this.super.hash = e; }
                        set host(e) { this.super.host = e; }
                        set hostname(e) { this.super.hostname = e; }
                        set href(e) { this.super.href = e; }
                        set origin(e) { this.super.origin = e; }
                        set password(e) { this.super.password = e; }
                        set pathname(e) { this.super.pathname = e; }
                        set port(e) { this.super.port = e; }
                        set protocol(e) { this.super.protocol = e; }
                        set search(e) { this.super.search = e; }
                        set searchParams(e) { this.super.searchParams = e; }
                        set username(e) { this.super.username = e; }
                        createObjectURL(e) { return this.super.createObjectURL(e); }
                        revokeObjectURL(e) { this.super.revokeObjectURL(e); }
                        toJSON() { return this.super.toJSON(); }
                        toString() { return this.super.toString(); }
                        format() { return this.toString(); }
                    }, URLSearchParams: self.URLSearchParams, defaultBase: d, format: function (e) { if (typeof e == "string")
                        return new r(e).toString(); if (!(e instanceof r)) {
                        const c = e.username && e.password ? `${e.username}:${e.password}@` : "", n = e.auth ? e.auth + "@" : "", t = e.port ? ":" + e.port : "", s = e.protocol ? e.protocol + "//" : "", u = e.host || "", i = e.hostname || "", o = e.search || (e.query ? "?" + e.query : ""), h = e.hash || "", a = e.pathname || "";
                        return `${s}${c || n}${u || i + t}${e.path || a + o}${h}`;
                    } } };
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { for await (const r of d)
                    return r; };
            }, function (E, m, f) {
                "use strict";
                m.Commented = f(558), m.Diagnose = f(575), m.Decoder = f(116), m.Encoder = f(273), m.Simple = f(90), m.Tagged = f(160), m.Map = f(576), m.comment = m.Commented.comment, m.decodeAll = m.Decoder.decodeAll, m.decodeFirst = m.Decoder.decodeFirst, m.decodeAllSync = m.Decoder.decodeAllSync, m.decodeFirstSync = m.Decoder.decodeFirstSync, m.diagnose = m.Diagnose.diagnose, m.encode = m.Encoder.encode, m.encodeCanonical = m.Encoder.encodeCanonical, m.encodeOne = m.Encoder.encodeOne, m.encodeAsync = m.Encoder.encodeAsync, m.decode = m.Decoder.decodeFirstSync, m.leveldb = { decode: m.Decoder.decodeAllSync, encode: m.Encoder.encode, buffer: !0, name: "cbor" }, m.hasBigInt = f(65).hasBigInt;
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e = f(114); E.exports = v; var c, n = f(226); v.ReadableState = I, f(12).EventEmitter; var t = function (W, X) { return W.listeners(X).length; }, s = f(269), u = f(115).Buffer, i = d.Uint8Array || function () { }, o = Object.create(f(89)); o.inherits = f(15); var h = f(559), a = void 0; a = h && h.debuglog ? h.debuglog("stream") : function () { }; var l, p = f(560), g = f(270); o.inherits(v, s); var b = ["error", "close", "destroy", "pause", "resume"]; function I(W, X) { W = W || {}; var Q = X instanceof (c = c || f(53)); this.objectMode = !!W.objectMode, Q && (this.objectMode = this.objectMode || !!W.readableObjectMode); var K = W.highWaterMark, F = W.readableHighWaterMark, Y = this.objectMode ? 16 : 16384; this.highWaterMark = K || K === 0 ? K : Q && (F || F === 0) ? F : Y, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = W.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, W.encoding && (l || (l = f(271).StringDecoder), this.decoder = new l(W.encoding), this.encoding = W.encoding); } function v(W) { if (c = c || f(53), !(this instanceof v))
                    return new v(W); this._readableState = new I(W, this), this.readable = !0, W && (typeof W.read == "function" && (this._read = W.read), typeof W.destroy == "function" && (this._destroy = W.destroy)), s.call(this); } function R(W, X, Q, K, F) { var Y, $ = W._readableState; return X === null ? ($.reading = !1, function (y, C) { if (C.ended)
                    return; if (C.decoder) {
                    var A = C.decoder.end();
                    A && A.length && (C.buffer.push(A), C.length += C.objectMode ? 1 : A.length);
                } C.ended = !0, x(y); }(W, $)) : (F || (Y = function (y, C) { var A; U = C, u.isBuffer(U) || U instanceof i || typeof C == "string" || C === void 0 || y.objectMode || (A = new TypeError("Invalid non-string/buffer chunk")); var U; return A; }($, X)), Y ? W.emit("error", Y) : $.objectMode || X && X.length > 0 ? (typeof X == "string" || $.objectMode || Object.getPrototypeOf(X) === u.prototype || (X = function (y) { return u.from(y); }(X)), K ? $.endEmitted ? W.emit("error", new Error("stream.unshift() after end event")) : _(W, $, X, !0) : $.ended ? W.emit("error", new Error("stream.push() after EOF")) : ($.reading = !1, $.decoder && !Q ? (X = $.decoder.write(X), $.objectMode || X.length !== 0 ? _(W, $, X, !1) : N(W, $)) : _(W, $, X, !1))) : K || ($.reading = !1)), function (y) { return !y.ended && (y.needReadable || y.length < y.highWaterMark || y.length === 0); }($); } function _(W, X, Q, K) { X.flowing && X.length === 0 && !X.sync ? (W.emit("data", Q), W.read(0)) : (X.length += X.objectMode ? 1 : Q.length, K ? X.buffer.unshift(Q) : X.buffer.push(Q), X.needReadable && x(W)), N(W, X); } Object.defineProperty(v.prototype, "destroyed", { get: function () { return this._readableState !== void 0 && this._readableState.destroyed; }, set: function (W) { this._readableState && (this._readableState.destroyed = W); } }), v.prototype.destroy = g.destroy, v.prototype._undestroy = g.undestroy, v.prototype._destroy = function (W, X) { this.push(null), X(W); }, v.prototype.push = function (W, X) { var Q, K = this._readableState; return K.objectMode ? Q = !0 : typeof W == "string" && ((X = X || K.defaultEncoding) !== K.encoding && (W = u.from(W, X), X = ""), Q = !0), R(this, W, X, !1, Q); }, v.prototype.unshift = function (W) { return R(this, W, null, !0, !1); }, v.prototype.isPaused = function () { return this._readableState.flowing === !1; }, v.prototype.setEncoding = function (W) { return l || (l = f(271).StringDecoder), this._readableState.decoder = new l(W), this._readableState.encoding = W, this; }; function k(W, X) { return W <= 0 || X.length === 0 && X.ended ? 0 : X.objectMode ? 1 : W != W ? X.flowing && X.length ? X.buffer.head.data.length : X.length : (W > X.highWaterMark && (X.highWaterMark = function (Q) { return Q >= 8388608 ? Q = 8388608 : (Q--, Q |= Q >>> 1, Q |= Q >>> 2, Q |= Q >>> 4, Q |= Q >>> 8, Q |= Q >>> 16, Q++), Q; }(W)), W <= X.length ? W : X.ended ? X.length : (X.needReadable = !0, 0)); } function x(W) { var X = W._readableState; X.needReadable = !1, X.emittedReadable || (a("emitReadable", X.flowing), X.emittedReadable = !0, X.sync ? e.nextTick(M, W) : M(W)); } function M(W) { a("emit readable"), W.emit("readable"), P(W); } function N(W, X) { X.readingMore || (X.readingMore = !0, e.nextTick(S, W, X)); } function S(W, X) { for (var Q = X.length; !X.reading && !X.flowing && !X.ended && X.length < X.highWaterMark && (a("maybeReadMore read 0"), W.read(0), Q !== X.length);)
                    Q = X.length; X.readingMore = !1; } function T(W) { a("readable nexttick read 0"), W.read(0); } function B(W, X) { X.reading || (a("resume read 0"), W.read(0)), X.resumeScheduled = !1, X.awaitDrain = 0, W.emit("resume"), P(W), X.flowing && !X.reading && W.read(0); } function P(W) { var X = W._readableState; for (a("flow", X.flowing); X.flowing && W.read() !== null;)
                    ; } function L(W, X) { return X.length === 0 ? null : (X.objectMode ? Q = X.buffer.shift() : !W || W >= X.length ? (Q = X.decoder ? X.buffer.join("") : X.buffer.length === 1 ? X.buffer.head.data : X.buffer.concat(X.length), X.buffer.clear()) : Q = function (K, F, Y) { var $; return K < F.head.data.length ? ($ = F.head.data.slice(0, K), F.head.data = F.head.data.slice(K)) : $ = K === F.head.data.length ? F.shift() : Y ? function (y, C) { var A = C.head, U = 1, z = A.data; for (y -= z.length; A = A.next;) {
                    var w = A.data, O = y > w.length ? w.length : y;
                    if (O === w.length ? z += w : z += w.slice(0, y), (y -= O) === 0) {
                        O === w.length ? (++U, A.next ? C.head = A.next : C.head = C.tail = null) : (C.head = A, A.data = w.slice(O));
                        break;
                    }
                    ++U;
                } return C.length -= U, z; }(K, F) : function (y, C) { var A = u.allocUnsafe(y), U = C.head, z = 1; for (U.data.copy(A), y -= U.data.length; U = U.next;) {
                    var w = U.data, O = y > w.length ? w.length : y;
                    if (w.copy(A, A.length - y, 0, O), (y -= O) === 0) {
                        O === w.length ? (++z, U.next ? C.head = U.next : C.head = C.tail = null) : (C.head = U, U.data = w.slice(O));
                        break;
                    }
                    ++z;
                } return C.length -= z, A; }(K, F), $; }(W, X.buffer, X.decoder), Q); var Q; } function j(W) { var X = W._readableState; if (X.length > 0)
                    throw new Error('"endReadable()" called on non-empty stream'); X.endEmitted || (X.ended = !0, e.nextTick(D, X, W)); } function D(W, X) { W.endEmitted || W.length !== 0 || (W.endEmitted = !0, X.readable = !1, X.emit("end")); } function G(W, X) { for (var Q = 0, K = W.length; Q < K; Q++)
                    if (W[Q] === X)
                        return Q; return -1; } v.prototype.read = function (W) { a("read", W), W = parseInt(W, 10); var X = this._readableState, Q = W; if (W !== 0 && (X.emittedReadable = !1), W === 0 && X.needReadable && (X.length >= X.highWaterMark || X.ended))
                    return a("read: emitReadable", X.length, X.ended), X.length === 0 && X.ended ? j(this) : x(this), null; if ((W = k(W, X)) === 0 && X.ended)
                    return X.length === 0 && j(this), null; var K, F = X.needReadable; return a("need readable", F), (X.length === 0 || X.length - W < X.highWaterMark) && a("length less than watermark", F = !0), X.ended || X.reading ? a("reading or ended", F = !1) : F && (a("do read"), X.reading = !0, X.sync = !0, X.length === 0 && (X.needReadable = !0), this._read(X.highWaterMark), X.sync = !1, X.reading || (W = k(Q, X))), (K = W > 0 ? L(W, X) : null) === null ? (X.needReadable = !0, W = 0) : X.length -= W, X.length === 0 && (X.ended || (X.needReadable = !0), Q !== W && X.ended && j(this)), K !== null && this.emit("data", K), K; }, v.prototype._read = function (W) { this.emit("error", new Error("_read() is not implemented")); }, v.prototype.pipe = function (W, X) { var Q = this, K = this._readableState; switch (K.pipesCount) {
                    case 0:
                        K.pipes = W;
                        break;
                    case 1:
                        K.pipes = [K.pipes, W];
                        break;
                    default: K.pipes.push(W);
                } K.pipesCount += 1, a("pipe count=%d opts=%j", K.pipesCount, X); var F = (!X || X.end !== !1) && W !== r.stdout && W !== r.stderr ? $ : q; function Y(H, V) { a("onunpipe"), H === Q && V && V.hasUnpiped === !1 && (V.hasUnpiped = !0, a("cleanup"), W.removeListener("close", w), W.removeListener("finish", O), W.removeListener("drain", y), W.removeListener("error", z), W.removeListener("unpipe", Y), Q.removeListener("end", $), Q.removeListener("end", q), Q.removeListener("data", U), C = !0, !K.awaitDrain || W._writableState && !W._writableState.needDrain || y()); } function $() { a("onend"), W.end(); } K.endEmitted ? e.nextTick(F) : Q.once("end", F), W.on("unpipe", Y); var y = function (H) { return function () { var V = H._readableState; a("pipeOnDrain", V.awaitDrain), V.awaitDrain && V.awaitDrain--, V.awaitDrain === 0 && t(H, "data") && (V.flowing = !0, P(H)); }; }(Q); W.on("drain", y); var C = !1, A = !1; function U(H) { a("ondata"), A = !1, W.write(H) !== !1 || A || ((K.pipesCount === 1 && K.pipes === W || K.pipesCount > 1 && G(K.pipes, W) !== -1) && !C && (a("false write response, pause", Q._readableState.awaitDrain), Q._readableState.awaitDrain++, A = !0), Q.pause()); } function z(H) { a("onerror", H), q(), W.removeListener("error", z), t(W, "error") === 0 && W.emit("error", H); } function w() { W.removeListener("finish", O), q(); } function O() { a("onfinish"), W.removeListener("close", w), q(); } function q() { a("unpipe"), Q.unpipe(W); } return Q.on("data", U), function (H, V, J) { if (typeof H.prependListener == "function")
                    return H.prependListener(V, J); H._events && H._events[V] ? n(H._events[V]) ? H._events[V].unshift(J) : H._events[V] = [J, H._events[V]] : H.on(V, J); }(W, "error", z), W.once("close", w), W.once("finish", O), W.emit("pipe", Q), K.flowing || (a("pipe resume"), Q.resume()), W; }, v.prototype.unpipe = function (W) { var X = this._readableState, Q = { hasUnpiped: !1 }; if (X.pipesCount === 0)
                    return this; if (X.pipesCount === 1)
                    return W && W !== X.pipes || (W || (W = X.pipes), X.pipes = null, X.pipesCount = 0, X.flowing = !1, W && W.emit("unpipe", this, Q)), this; if (!W) {
                    var K = X.pipes, F = X.pipesCount;
                    X.pipes = null, X.pipesCount = 0, X.flowing = !1;
                    for (var Y = 0; Y < F; Y++)
                        K[Y].emit("unpipe", this, Q);
                    return this;
                } var $ = G(X.pipes, W); return $ === -1 || (X.pipes.splice($, 1), X.pipesCount -= 1, X.pipesCount === 1 && (X.pipes = X.pipes[0]), W.emit("unpipe", this, Q)), this; }, v.prototype.on = function (W, X) { var Q = s.prototype.on.call(this, W, X); if (W === "data")
                    this._readableState.flowing !== !1 && this.resume();
                else if (W === "readable") {
                    var K = this._readableState;
                    K.endEmitted || K.readableListening || (K.readableListening = K.needReadable = !0, K.emittedReadable = !1, K.reading ? K.length && x(this) : e.nextTick(T, this));
                } return Q; }, v.prototype.addListener = v.prototype.on, v.prototype.resume = function () { var W = this._readableState; return W.flowing || (a("resume"), W.flowing = !0, function (X, Q) { Q.resumeScheduled || (Q.resumeScheduled = !0, e.nextTick(B, X, Q)); }(this, W)), this; }, v.prototype.pause = function () { return a("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (a("pause"), this._readableState.flowing = !1, this.emit("pause")), this; }, v.prototype.wrap = function (W) { var X = this, Q = this._readableState, K = !1; for (var F in W.on("end", function () { if (a("wrapped end"), Q.decoder && !Q.ended) {
                    var $ = Q.decoder.end();
                    $ && $.length && X.push($);
                } X.push(null); }), W.on("data", function ($) { (a("wrapped data"), Q.decoder && ($ = Q.decoder.write($)), Q.objectMode && $ == null) || (Q.objectMode || $ && $.length) && (X.push($) || (K = !0, W.pause())); }), W)
                    this[F] === void 0 && typeof W[F] == "function" && (this[F] = function ($) { return function () { return W[$].apply(W, arguments); }; }(F)); for (var Y = 0; Y < b.length; Y++)
                    W.on(b[Y], this.emit.bind(this, b[Y])); return this._read = function ($) { a("wrapped _read", $), K && (K = !1, W.resume()); }, this; }, Object.defineProperty(v.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark; } }), v._fromList = L; }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = f(12).EventEmitter;
            }, function (E, m, f) {
                "use strict";
                var d = f(114);
                function r(e, c) { e.emit("error", c); }
                E.exports = { destroy: function (e, c) { var n = this, t = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed; return t || s ? (c ? c(e) : !e || this._writableState && this._writableState.errorEmitted || d.nextTick(r, this, e), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function (u) { !c && u ? (d.nextTick(r, n, u), n._writableState && (n._writableState.errorEmitted = !0)) : c && c(u); }), this); }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1); } };
            }, function (E, m, f) {
                "use strict";
                var d = f(115).Buffer, r = d.isEncoding || function (a) { switch ((a = "" + a) && a.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw": return !0;
                    default: return !1;
                } };
                function e(a) { var l; switch (this.encoding = function (p) { var g = function (b) { if (!b)
                    return "utf8"; for (var I;;)
                    switch (b) {
                        case "utf8":
                        case "utf-8": return "utf8";
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le": return "utf16le";
                        case "latin1":
                        case "binary": return "latin1";
                        case "base64":
                        case "ascii":
                        case "hex": return b;
                        default:
                            if (I)
                                return;
                            b = ("" + b).toLowerCase(), I = !0;
                    } }(p); if (typeof g != "string" && (d.isEncoding === r || !r(p)))
                    throw new Error("Unknown encoding: " + p); return g || p; }(a), this.encoding) {
                    case "utf16le":
                        this.text = t, this.end = s, l = 4;
                        break;
                    case "utf8":
                        this.fillLast = n, l = 4;
                        break;
                    case "base64":
                        this.text = u, this.end = i, l = 3;
                        break;
                    default: return this.write = o, void (this.end = h);
                } this.lastNeed = 0, this.lastTotal = 0, this.lastChar = d.allocUnsafe(l); }
                function c(a) { return a <= 127 ? 0 : a >> 5 == 6 ? 2 : a >> 4 == 14 ? 3 : a >> 3 == 30 ? 4 : a >> 6 == 2 ? -1 : -2; }
                function n(a) { var l = this.lastTotal - this.lastNeed, p = function (g, b, I) { if ((192 & b[0]) != 128)
                    return g.lastNeed = 0, "\uFFFD"; if (g.lastNeed > 1 && b.length > 1) {
                    if ((192 & b[1]) != 128)
                        return g.lastNeed = 1, "\uFFFD";
                    if (g.lastNeed > 2 && b.length > 2 && (192 & b[2]) != 128)
                        return g.lastNeed = 2, "\uFFFD";
                } }(this, a); return p !== void 0 ? p : this.lastNeed <= a.length ? (a.copy(this.lastChar, l, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (a.copy(this.lastChar, l, 0, a.length), void (this.lastNeed -= a.length)); }
                function t(a, l) { if ((a.length - l) % 2 == 0) {
                    var p = a.toString("utf16le", l);
                    if (p) {
                        var g = p.charCodeAt(p.length - 1);
                        if (g >= 55296 && g <= 56319)
                            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], p.slice(0, -1);
                    }
                    return p;
                } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", l, a.length - 1); }
                function s(a) { var l = a && a.length ? this.write(a) : ""; if (this.lastNeed) {
                    var p = this.lastTotal - this.lastNeed;
                    return l + this.lastChar.toString("utf16le", 0, p);
                } return l; }
                function u(a, l) { var p = (a.length - l) % 3; return p === 0 ? a.toString("base64", l) : (this.lastNeed = 3 - p, this.lastTotal = 3, p === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", l, a.length - p)); }
                function i(a) { var l = a && a.length ? this.write(a) : ""; return this.lastNeed ? l + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : l; }
                function o(a) { return a.toString(this.encoding); }
                function h(a) { return a && a.length ? this.write(a) : ""; }
                m.StringDecoder = e, e.prototype.write = function (a) { if (a.length === 0)
                    return ""; var l, p; if (this.lastNeed) {
                    if ((l = this.fillLast(a)) === void 0)
                        return "";
                    p = this.lastNeed, this.lastNeed = 0;
                }
                else
                    p = 0; return p < a.length ? l ? l + this.text(a, p) : this.text(a, p) : l || ""; }, e.prototype.end = function (a) { var l = a && a.length ? this.write(a) : ""; return this.lastNeed ? l + "\uFFFD" : l; }, e.prototype.text = function (a, l) { var p = function (b, I, v) { var R = I.length - 1; if (R < v)
                    return 0; var _ = c(I[R]); return _ >= 0 ? (_ > 0 && (b.lastNeed = _ - 1), _) : --R < v || _ === -2 ? 0 : (_ = c(I[R])) >= 0 ? (_ > 0 && (b.lastNeed = _ - 2), _) : --R < v || _ === -2 ? 0 : (_ = c(I[R])) >= 0 ? (_ > 0 && (_ === 2 ? _ = 0 : b.lastNeed = _ - 3), _) : 0; }(this, a, l); if (!this.lastNeed)
                    return a.toString("utf8", l); this.lastTotal = p; var g = a.length - (p - this.lastNeed); return a.copy(this.lastChar, 0, g), a.toString("utf8", l, g); }, e.prototype.fillLast = function (a) { if (this.lastNeed <= a.length)
                    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length; };
            }, function (E, m, f) {
                "use strict";
                E.exports = c;
                var d = f(53), r = Object.create(f(89));
                function e(s, u) { var i = this._transformState; i.transforming = !1; var o = i.writecb; if (!o)
                    return this.emit("error", new Error("write callback called multiple times")); i.writechunk = null, i.writecb = null, u != null && this.push(u), o(s); var h = this._readableState; h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark); }
                function c(s) { if (!(this instanceof c))
                    return new c(s); d.call(this, s), this._transformState = { afterTransform: e.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, s && (typeof s.transform == "function" && (this._transform = s.transform), typeof s.flush == "function" && (this._flush = s.flush)), this.on("prefinish", n); }
                function n() { var s = this; typeof this._flush == "function" ? this._flush(function (u, i) { t(s, u, i); }) : t(this, null, null); }
                function t(s, u, i) { if (u)
                    return s.emit("error", u); if (i != null && s.push(i), s._writableState.length)
                    throw new Error("Calling transform done when ws.length != 0"); if (s._transformState.transforming)
                    throw new Error("Calling transform done when still transforming"); return s.push(null); }
                r.inherits = f(15), r.inherits(c, d), c.prototype.push = function (s, u) { return this._transformState.needTransform = !1, d.prototype.push.call(this, s, u); }, c.prototype._transform = function (s, u, i) { throw new Error("_transform() is not implemented"); }, c.prototype._write = function (s, u, i) { var o = this._transformState; if (o.writecb = i, o.writechunk = s, o.writeencoding = u, !o.transforming) {
                    var h = this._readableState;
                    (o.needTransform || h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
                } }, c.prototype._read = function (s) { var u = this._transformState; u.writechunk !== null && u.writecb && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0; }, c.prototype._destroy = function (s, u) { var i = this; d.prototype._destroy.call(this, s, function (o) { u(o), i.emit("close"); }); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(63), e = f(161), c = f(30).BigNumber, n = f(91), t = (f(160), f(90), f(65)), s = f(54), u = s.MT, i = s.NUMBYTES, o = s.SHIFT32, h = s.SYMS, a = s.TAG, l = s.MT.SIMPLE_FLOAT << 5 | s.NUMBYTES.TWO, p = s.MT.SIMPLE_FLOAT << 5 | s.NUMBYTES.FOUR, g = s.MT.SIMPLE_FLOAT << 5 | s.NUMBYTES.EIGHT, b = s.MT.SIMPLE_FLOAT << 5 | s.SIMPLE.TRUE, I = s.MT.SIMPLE_FLOAT << 5 | s.SIMPLE.FALSE, v = s.MT.SIMPLE_FLOAT << 5 | s.SIMPLE.UNDEFINED, R = s.MT.SIMPLE_FLOAT << 5 | s.SIMPLE.NULL, _ = t.bigIntize(s.BI), k = s.BN, x = d.from("f97e00", "hex"), M = d.from("f9fc00", "hex"), N = d.from("f97c00", "hex"), S = d.from("f98000", "hex"), T = Symbol("CBOR_LOOP_DETECT"); class B extends r.Transform {
                    constructor(L) { const j = Object.assign({}, L, { readableObjectMode: !1, writableObjectMode: !0 }); super(j), this.canonical = j.canonical, this.encodeUndefined = j.encodeUndefined, this.disallowUndefinedKeys = !!j.disallowUndefinedKeys, this.dateType = j.dateType != null ? j.dateType.toLowerCase() : "number", this.collapseBigIntegers = !!j.collapseBigIntegers, typeof j.detectLoops == "symbol" ? this.detectLoops = j.detectLoops : this.detectLoops = j.detectLoops ? Symbol("CBOR_DETECT") : null, this.semanticTypes = [Array, this._pushArray, Date, this._pushDate, d, this._pushBuffer, Map, this._pushMap, n, this._pushNoFilter, RegExp, this._pushRegexp, Set, this._pushSet, c, this._pushBigNumber, ArrayBuffer, this._pushUint8Array, Uint8ClampedArray, this._pushUint8Array, Uint8Array, this._pushUint8Array, Uint16Array, this._pushArray, Uint32Array, this._pushArray, Int8Array, this._pushArray, Int16Array, this._pushArray, Int32Array, this._pushArray, Float32Array, this._pushFloat32Array, Float64Array, this._pushFloat64Array], e.Url && this.semanticTypes.push(e.Url, this._pushUrl), e.URL && this.semanticTypes.push(e.URL, this._pushURL); const D = j.genTypes || []; for (let G = 0, W = D.length; G < W; G += 2)
                        this.addSemanticType(D[G], D[G + 1]); }
                    _transform(L, j, D) { return D(this.pushAny(L) === !1 ? new Error("Push Error") : void 0); }
                    _flush(L) { return L(); }
                    addSemanticType(L, j) { for (let D = 0, G = this.semanticTypes.length; D < G; D += 2)
                        if (this.semanticTypes[D] === L) {
                            const W = this.semanticTypes[D + 1];
                            return this.semanticTypes[D + 1] = j, W;
                        } return this.semanticTypes.push(L, j), null; }
                    _pushUInt8(L) { const j = d.allocUnsafe(1); return j.writeUInt8(L, 0), this.push(j); }
                    _pushUInt16BE(L) { const j = d.allocUnsafe(2); return j.writeUInt16BE(L, 0), this.push(j); }
                    _pushUInt32BE(L) { const j = d.allocUnsafe(4); return j.writeUInt32BE(L, 0), this.push(j); }
                    _pushFloatBE(L) { const j = d.allocUnsafe(4); return j.writeFloatBE(L, 0), this.push(j); }
                    _pushDoubleBE(L) { const j = d.allocUnsafe(8); return j.writeDoubleBE(L, 0), this.push(j); }
                    _pushNaN() { return this.push(x); }
                    _pushInfinity(L) { const j = L < 0 ? M : N; return this.push(j); }
                    _pushFloat(L) { if (this.canonical) {
                        const j = d.allocUnsafe(2);
                        if (t.writeHalf(j, L) && t.parseHalf(j) === L)
                            return this._pushUInt8(l) && this.push(j);
                    } return Math.fround(L) === L ? this._pushUInt8(p) && this._pushFloatBE(L) : this._pushUInt8(g) && this._pushDoubleBE(L); }
                    _pushInt(L, j, D) { const G = j << 5; switch (!1) {
                        case !(L < 24): return this._pushUInt8(G | L);
                        case !(L <= 255): return this._pushUInt8(G | i.ONE) && this._pushUInt8(L);
                        case !(L <= 65535): return this._pushUInt8(G | i.TWO) && this._pushUInt16BE(L);
                        case !(L <= 4294967295): return this._pushUInt8(G | i.FOUR) && this._pushUInt32BE(L);
                        case !(L <= Number.MAX_SAFE_INTEGER): return this._pushUInt8(G | i.EIGHT) && this._pushUInt32BE(Math.floor(L / o)) && this._pushUInt32BE(L % o);
                        default: return j === u.NEG_INT ? this._pushFloat(D) : this._pushFloat(L);
                    } }
                    _pushIntNum(L) { return Object.is(L, -0) ? this.push(S) : L < 0 ? this._pushInt(-L - 1, u.NEG_INT, L) : this._pushInt(L, u.POS_INT); }
                    _pushNumber(L) { switch (!1) {
                        case !isNaN(L): return this._pushNaN();
                        case isFinite(L): return this._pushInfinity(L);
                        case Math.round(L) !== L: return this._pushIntNum(L);
                        default: return this._pushFloat(L);
                    } }
                    _pushString(L) { const j = d.byteLength(L, "utf8"); return this._pushInt(j, u.UTF8_STRING) && this.push(L, "utf8"); }
                    _pushBoolean(L) { return this._pushUInt8(L ? b : I); }
                    _pushUndefined(L) { switch (typeof this.encodeUndefined) {
                        case "undefined": return this._pushUInt8(v);
                        case "function": return this.pushAny(this.encodeUndefined.call(this, L));
                        case "object": if (d.isBuffer(this.encodeUndefined))
                            return this.push(this.encodeUndefined);
                    } return this.pushAny(this.encodeUndefined); }
                    _pushNull(L) { return this._pushUInt8(R); }
                    _pushArray(L, j) { const D = j.length; if (!L._pushInt(D, u.ARRAY))
                        return !1; for (let G = 0; G < D; G++)
                        if (!L.pushAny(j[G]))
                            return !1; return !0; }
                    _pushTag(L) { return this._pushInt(L, u.TAG); }
                    _pushDate(L, j) { switch (L.dateType) {
                        case "string": return L._pushTag(a.DATE_STRING) && L._pushString(j.toISOString());
                        case "int":
                        case "integer": return L._pushTag(a.DATE_EPOCH) && L._pushIntNum(Math.round(j / 1e3));
                        case "float": return L._pushTag(a.DATE_EPOCH) && L._pushFloat(j / 1e3);
                        case "number":
                        default: return L._pushTag(a.DATE_EPOCH) && L.pushAny(j / 1e3);
                    } }
                    _pushBuffer(L, j) { return L._pushInt(j.length, u.BYTE_STRING) && L.push(j); }
                    _pushNoFilter(L, j) { return L._pushBuffer(L, j.slice()); }
                    _pushRegexp(L, j) { return L._pushTag(a.REGEXP) && L.pushAny(j.source); }
                    _pushSet(L, j) { if (!L._pushInt(j.size, u.ARRAY))
                        return !1; for (const D of j)
                        if (!L.pushAny(D))
                            return !1; return !0; }
                    _pushUrl(L, j) { return L._pushTag(a.URI) && L.pushAny(j.format()); }
                    _pushURL(L, j) { return L._pushTag(a.URI) && L.pushAny(j.toString()); }
                    _pushBigint(L) { let j = u.POS_INT, D = a.POS_BIGINT; if (L.isNegative() && (L = L.negated().minus(1), j = u.NEG_INT, D = a.NEG_BIGINT), this.collapseBigIntegers && L.lte(k.MAXINT64))
                        return L.lte(k.MAXINT32) ? this._pushInt(L.toNumber(), j) : this._pushUInt8(j << 5 | i.EIGHT) && this._pushUInt32BE(L.dividedToIntegerBy(k.SHIFT32).toNumber()) && this._pushUInt32BE(L.mod(k.SHIFT32).toNumber()); let G = L.toString(16); G.length % 2 && (G = "0" + G); const W = d.from(G, "hex"); return this._pushTag(D) && this._pushBuffer(this, W); }
                    _pushJSBigint(L) { let j = u.POS_INT, D = a.POS_BIGINT; if (L < 0 && (L = -L + _.MINUS_ONE, j = u.NEG_INT, D = a.NEG_BIGINT), this.collapseBigIntegers && L <= _.MAXINT64)
                        return L <= 4294967295 ? this._pushInt(Number(L), j) : this._pushUInt8(j << 5 | i.EIGHT) && this._pushUInt32BE(Number(L / _.SHIFT32)) && this._pushUInt32BE(Number(L % _.SHIFT32)); let G = L.toString(16); G.length % 2 && (G = "0" + G); const W = d.from(G, "hex"); return this._pushTag(D) && this._pushBuffer(this, W); }
                    _pushBigNumber(L, j) { if (j.isNaN())
                        return L._pushNaN(); if (!j.isFinite())
                        return L._pushInfinity(j.isNegative() ? -1 / 0 : 1 / 0); if (j.isInteger())
                        return L._pushBigint(j); if (!L._pushTag(a.DECIMAL_FRAC) || !L._pushInt(2, u.ARRAY))
                        return !1; const D = j.decimalPlaces(), G = j.times(new c(10).pow(D)); return !!L._pushIntNum(-D) && (G.abs().isLessThan(k.MAXINT) ? L._pushIntNum(G.toNumber()) : L._pushBigint(G)); }
                    _pushMap(L, j) { if (!L._pushInt(j.size, u.MAP))
                        return !1; if (L.canonical) {
                        const D = [...j.entries()], G = new B(this), W = new n({ highWaterMark: this.readableHighWaterMark });
                        G.pipe(W), D.sort(([X], [Q]) => { G.pushAny(X); const K = W.read(); G.pushAny(Q); const F = W.read(); return K.compare(F); });
                        for (const [X, Q] of D) {
                            if (L.disallowUndefinedKeys && X === void 0)
                                throw new Error("Invalid Map key: undefined");
                            if (!L.pushAny(X) || !L.pushAny(Q))
                                return !1;
                        }
                    }
                    else
                        for (const [D, G] of j) {
                            if (L.disallowUndefinedKeys && D === void 0)
                                throw new Error("Invalid Map key: undefined");
                            if (!L.pushAny(D) || !L.pushAny(G))
                                return !1;
                        } return !0; }
                    _pushUint8Array(L, j) { return L._pushBuffer(L, d.from(j)); }
                    _pushFloat32Array(L, j) { const D = j.length; if (!L._pushInt(D, u.ARRAY))
                        return !1; for (let G = 0; G < D; G++)
                        if (!L._pushUInt8(p) || !L._pushFloatBE(j[G]))
                            return !1; return !0; }
                    _pushFloat64Array(L, j) { const D = j.length; if (!L._pushInt(D, u.ARRAY))
                        return !1; for (let G = 0; G < D; G++)
                        if (!L._pushUInt8(g) || !L._pushDoubleBE(j[G]))
                            return !1; return !0; }
                    removeLoopDetectors(L) { if (!this.detectLoops || typeof L != "object" || !L)
                        return !1; const j = L[T]; if (!j || j !== this.detectLoops)
                        return !1; if (delete L[T], Array.isArray(L))
                        for (const D of L)
                            this.removeLoopDetectors(D);
                    else
                        for (const D in L)
                            this.removeLoopDetectors(L[D]); return !0; }
                    _pushObject(L) { if (!L)
                        return this._pushNull(L); if (this.detectLoops) {
                        if (L[T] === this.detectLoops)
                            throw new Error("Loop detected while CBOR encoding");
                        L[T] = this.detectLoops;
                    } const j = L.encodeCBOR; if (typeof j == "function")
                        return j.call(L, this); for (let X = 0, Q = this.semanticTypes.length; X < Q; X += 2)
                        if (L instanceof this.semanticTypes[X])
                            return this.semanticTypes[X + 1].call(L, this, L); const D = Object.keys(L), G = {}; if (this.canonical && D.sort((X, Q) => { const K = G[X] || (G[X] = B.encode(X)), F = G[Q] || (G[Q] = B.encode(Q)); return K.compare(F); }), !this._pushInt(D.length, u.MAP))
                        return !1; let W; for (let X = 0, Q = D.length; X < Q; X++) {
                        const K = D[X];
                        if (this.canonical && (W = G[K])) {
                            if (!this.push(W))
                                return !1;
                        }
                        else if (!this._pushString(K))
                            return !1;
                        if (!this.pushAny(L[K]))
                            return !1;
                    } return !0; }
                    pushAny(L) { switch (typeof L) {
                        case "number": return this._pushNumber(L);
                        case "bigint": return this._pushJSBigint(L);
                        case "string": return this._pushString(L);
                        case "boolean": return this._pushBoolean(L);
                        case "undefined": return this._pushUndefined(L);
                        case "object": return this._pushObject(L);
                        case "symbol": switch (L) {
                            case h.NULL: return this._pushNull(null);
                            case h.UNDEFINED: return this._pushUndefined(void 0);
                            default: throw new Error("Unknown symbol: " + L.toString());
                        }
                        default: throw new Error("Unknown type: " + typeof L + ", " + (L ? L.toString() : ""));
                    } }
                    _pushAny(L) { return this.pushAny(L); }
                    _encodeAll(L) { const j = new n({ highWaterMark: this.readableHighWaterMark }); this.pipe(j); for (const D of L)
                        this.pushAny(D); return this.end(), j.read(); }
                    static encode(...L) { return new B()._encodeAll(L); }
                    static encodeCanonical(...L) { return new B({ canonical: !0 })._encodeAll(L); }
                    static encodeOne(L, j) { return new B(j)._encodeAll([L]); }
                    static encodeAsync(L, j) { return new Promise((D, G) => { const W = [], X = new B(j); X.on("data", Q => W.push(Q)), X.on("error", G), X.on("finish", () => D(d.concat(W))), X.pushAny(L), X.end(); }); }
                } E.exports = B; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, { utf8Decoder: r } = f(275), e = f(596), c = m.PREFIX = "/repo/flatfs/shard/", n = m.SHARDING_FN = "SHARDING";
                m.README_FN = "_README";
                class t {
                    constructor(a) { this.param = a; }
                    fun(a) { throw new Error("implement me"); }
                    toString() { return `${c}v1/${this.name}/${this.param}`; }
                }
                class s extends t {
                    constructor(a) { super(a), this._padding = "".padStart(a, "_"), this.name = "prefix"; }
                    fun(a) { return (a + this._padding).slice(0, this.param); }
                }
                class u extends t {
                    constructor(a) { super(a), this._padding = "".padStart(a, "_"), this.name = "suffix"; }
                    fun(a) { const l = this._padding + a; return l.slice(l.length - this.param); }
                }
                class i extends t {
                    constructor(a) { super(a), this._padding = "".padStart(a + 1, "_"), this.name = "next-to-last"; }
                    fun(a) { const l = this._padding + a, p = l.length - this.param - 1; return l.slice(p, p + this.param); }
                }
                function o(h) { if ((h = h.trim()).length === 0)
                    throw new Error("empty shard string"); if (!h.startsWith(c))
                    throw new Error("invalid or no path prefix: " + h); const a = h.slice(c.length).split("/"), l = a[0]; if (l !== "v1")
                    throw new Error(`expect 'v1' version, got '${l}'`); const p = a[1]; if (!a[2])
                    throw new Error("missing param"); const g = parseInt(a[2], 10); switch (p) {
                    case "prefix": return new s(g);
                    case "suffix": return new u(g);
                    case "next-to-last": return new i(g);
                    default: throw new Error("unkown sharding function: " + p);
                } }
                m.readShardFun = async (h, a) => { const l = new d(h).child(new d(n)), p = typeof a.getRaw == "function" ? a.getRaw.bind(a) : a.get.bind(a), g = await p(l); return o(r.decode(g || "").trim()); }, m.readme = e, m.parseShardFun = o, m.Prefix = s, m.Suffix = u, m.NextToLast = i;
            }, function (E, m, f) {
                "use strict";
                const d = f(594), r = f(595);
                E.exports.utf8Encoder = new d("utf8"), E.exports.utf8Decoder = new r("utf8");
            }, function (E, m, f) {
                "use strict";
                typeof globalThis != "object" && (Object.defineProperty(Object.prototype, "__magic__", { get: function () { return this; }, configurable: !0 }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__), E.exports = globalThis;
            }, function (E, m, f) {
                "use strict";
                const d = f(92), { toB58String: r } = f(16).multihash, e = f(600), c = f(5), n = f(6), t = f(26), s = f(0), u = f(1), i = Object.assign(u("ipfs:ipns:pubsub"), { error: u("ipfs:ipns:pubsub:error") });
                E.exports = t(class {
                    constructor(o, h, a) { this._pubsub = o, this._subscriptions = {}, this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this), this._pubsubDs = new e(o, h, a, d.validator, this._handleSubscriptionKey); }
                    async put(o, h) { return this._pubsubDs.put(o, h); }
                    async get(o) { let h, a; try {
                        h = await this._pubsubDs.get(o);
                    }
                    catch (p) {
                        a = p;
                    } const l = o.slice(0, d.namespaceLength); if (c(l) === d.namespace) {
                        const p = r(o), g = r(o.slice(d.namespaceLength));
                        this._subscriptions[p] = g, i(`subscribed to pubsub topic ${p}, id ${g}`);
                    } if (a)
                        throw a; return h; }
                    _handleSubscriptionKey(o) { o instanceof Uint8Array && (o = c(o, "base58btc")); const h = this._subscriptions[o]; if (!h)
                        throw s(new Error(`key ${o} does not correspond to a subscription`), "ERR_INVALID_KEY"); let a; try {
                        a = d.getIdKeys(n(h, "base58btc"));
                    }
                    catch (l) {
                        throw i.error(l), l;
                    } return a.routingKey.uint8Array(); }
                    getSubscriptions() { return Object.values(this._subscriptions).filter(Boolean).map(o => `${d.namespace}${o}`); }
                    async cancel(o) { if (typeof o != "string")
                        throw s(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME"); o.startsWith(d.namespace) && (o = o.substring(d.namespaceLength)); const h = Object.keys(this._subscriptions).find(l => this._subscriptions[l] === o); if (!h)
                        return { canceled: !1 }; const a = n(h); return this._pubsubDs.unsubscribe(a), this._subscriptions[h] = void 0, i(`unsubscribed pubsub ${h}: ${o}`), { canceled: !0 }; }
                }, { className: "IpnsPubsubDatastore", symbolName: "@js-ipfs/ipns/IpnsPubsubDatastore" });
            }, function (E, m, f) {
                "use strict";
                const { Key: d } = f(11), { Record: r } = f(66), { encodeBase32: e } = f(279), c = f(0), n = f(1), t = Object.assign(n("ipfs:ipns:offline-datastore"), { error: n("ipfs:ipns:offline-datastore:error") });
                E.exports = class {
                    constructor(s) { this._repo = s; }
                    async put(s, u) { if (!(s instanceof Uint8Array))
                        throw c(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY"); if (!(u instanceof Uint8Array))
                        throw c(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE"); let i; try {
                        i = this._routingKey(s);
                    }
                    catch (h) {
                        throw t.error(h), c(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
                    } const o = new r(s, u); return this._repo.datastore.put(i, o.serialize()); }
                    async get(s) { if (!(s instanceof Uint8Array))
                        throw c(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY"); let u; try {
                        u = this._routingKey(s);
                    }
                    catch (h) {
                        throw t.error(h), c(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
                    } const i = await this._repo.datastore.get(u); let o; try {
                        o = r.deserialize(i);
                    }
                    catch (h) {
                        throw t.error(h), h;
                    } return o.value; }
                    _routingKey(s) { return new d("/" + e(s), !1); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(92), r = f(5);
                E.exports = { encodeBase32: e => r(e, "base32upper"), validator: { func: (e, c, n) => d.validator.validate(c, e, n) }, selector: (e, c) => d.validator.select(c[0], c[1]) };
            }, function (E, m, f) {
                "use strict";
                const d = f(30).default, r = f(4), e = f(2);
                E.exports = ({ network: c }) => e(async function (n) { const { bitswap: t } = await c.use(n), s = t.stat().snapshot; return { provideBufLen: parseInt(s.providesBufferLength.toString()), blocksReceived: new d(s.blocksReceived), wantlist: Array.from(t.getWantlist()).map(u => u[1].cid), peers: t.peers().map(u => new r(u.toB58String())), dupBlksReceived: new d(s.dupBlksReceived), dupDataReceived: new d(s.dupDataReceived), dataReceived: new d(s.dataReceived), blocksSent: new d(s.blocksSent), dataSent: new d(s.dataSent) }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(60).IPFS.matches;
                m.isValidMultiaddr = r => { try {
                    return d(r);
                }
                catch (e) {
                    return !1;
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(169);
                E.exports = async function* (r, e) { e = parseInt(e), (isNaN(e) || e < 1) && (e = 1); for await (const c of d(r, e)) {
                    const n = c.map(t => t().then(s => ({ ok: !0, value: s }), s => ({ ok: !1, err: s })));
                    for (let t = 0; t < n.length; t++) {
                        const s = await n[t];
                        if (!s.ok)
                            throw s.err;
                        yield s.value;
                    }
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(134), { hasOwnProperty: r } = Object.prototype, { propertyIsEnumerable: e } = Object, c = (o, h, a) => Object.defineProperty(o, h, { value: a, writable: !0, enumerable: !0, configurable: !0 }), n = { concatArrays: !1, ignoreUndefined: !1 }, t = o => { const h = []; for (const a in o)
                    r.call(o, a) && h.push(a); if (Object.getOwnPropertySymbols) {
                    const a = Object.getOwnPropertySymbols(o);
                    for (const l of a)
                        e.call(o, l) && h.push(l);
                } return h; };
                function s(o) { return Array.isArray(o) ? function (h) { const a = h.slice(0, 0); return t(h).forEach(l => { c(a, l, s(h[l])); }), a; }(o) : d(o) ? function (h) { const a = Object.getPrototypeOf(h) === null ? Object.create(null) : {}; return t(h).forEach(l => { c(a, l, s(h[l])); }), a; }(o) : o; }
                const u = (o, h, a, l) => (a.forEach(p => { h[p] === void 0 && l.ignoreUndefined || (p in o && o[p] !== Object.getPrototypeOf(o) ? c(o, p, i(o[p], h[p], l)) : c(o, p, s(h[p]))); }), o);
                function i(o, h, a) { return a.concatArrays && Array.isArray(o) && Array.isArray(h) ? ((l, p, g) => { let b = l.slice(0, 0), I = 0; return [l, p].forEach(v => { const R = []; for (let _ = 0; _ < v.length; _++)
                    r.call(v, _) && (R.push(String(_)), c(b, I++, v === l ? v[_] : s(v[_]))); b = u(b, v, t(v).filter(_ => !R.includes(_)), g); }), b; })(o, h, a) : d(h) && d(o) ? u(o, h, t(h), a) : s(h); }
                E.exports = function (...o) { const h = i(s(n), this !== void 0 && this || {}, n); let a = { _: {} }; for (const l of o)
                    if (l !== void 0) {
                        if (!d(l))
                            throw new TypeError("`" + l + "` is not an Option Object");
                        a = i(a, { _: l }, h);
                    } return a._; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { const [r, e] = d[Symbol.asyncIterator] ? [d[Symbol.asyncIterator](), Symbol.asyncIterator] : [d[Symbol.iterator](), Symbol.iterator], c = []; return { peek: () => r.next(), push: n => { c.push(n); }, next: () => c.length ? { done: !1, value: c.shift() } : r.next(), [e]() { return this; } }; };
            }, function (E, m, f) {
                "use strict";
                const { Blob: d } = f(135);
                E.exports = { isBytes: function (r) { return ArrayBuffer.isView(r) || r instanceof ArrayBuffer; }, isBlob: function (r) { return d !== void 0 && r instanceof d; }, isFileObject: function (r) { return typeof r == "object" && (r.path || r.content); }, isReadableStream: r => r && typeof r.getReader == "function", mtimeToObject: function (r) { if (r != null) {
                        if (r instanceof Date) {
                            const e = r.getTime(), c = Math.floor(e / 1e3);
                            return { secs: c, nsecs: 1e3 * (e - 1e3 * c) };
                        }
                        return Object.prototype.hasOwnProperty.call(r, "secs") ? { secs: r.secs, nsecs: r.nsecs } : Object.prototype.hasOwnProperty.call(r, "Seconds") ? { secs: r.Seconds, nsecs: r.FractionalNanoseconds } : Array.isArray(r) ? { secs: r[0], nsecs: r[1] } : void 0;
                    } }, modeToNumber: function (r) { if (r != null)
                        return typeof r == "number" ? r : (r = r.toString()).substring(0, 1) === "0" ? parseInt(r, 8) : parseInt(r, 10); } };
            }, function (E, m, f) {
                "use strict";
                const d = f(175), r = f(176), e = f(29), c = f(0);
                E.exports = (n, t, s, u, i, o, h) => (a = {}) => { const l = s.fileSize(), { offset: p, length: g } = r(l, a.offset, a.length); return async function* b(I, v, R, _, k = 0, x) { if (v instanceof Uint8Array) {
                    const S = d(v, k, R, _);
                    return S.length && (yield S), k += S.length;
                } let M; try {
                    M = e.unmarshal(v.Data);
                }
                catch (S) {
                    throw c(S, "ERR_NOT_UNIXFS");
                } if (Boolean(M.data && M.data.length)) {
                    const S = d(M.data, k, R, _);
                    S.length && (yield S), k += M.data.length;
                } let N = k; for (let S = 0; S < v.Links.length; S++) {
                    const T = v.Links[S], B = k + M.blockSizes[S];
                    if (R >= N && R < B || _ > N && _ <= B || R < N && _ > B) {
                        const P = await I.get(T.Hash, x);
                        for await (const L of b(I, P, R, _, k, x))
                            k += L.length, yield L;
                    }
                    k = B, N = B + 1;
                } }(h, t, p, p + g, 0, a); };
            }, function (E) { E.exports = JSON.parse('{"name":"ipfs-core","version":"0.3.1","description":"JavaScript implementation of the IPFS specification","keywords":["IPFS"],"homepage":"https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-core#readme","bugs":"https://github.com/ipfs/js-ipfs/issues","license":"(Apache-2.0 OR MIT)","leadMaintainer":"Alex Potsides <alex@achingbrain.net>","main":"src/index.js","files":["src","dist"],"browser":{"./src/runtime/init-assets-nodejs.js":"./src/runtime/init-assets-browser.js","./src/runtime/config-nodejs.js":"./src/runtime/config-browser.js","./src/runtime/dns-nodejs.js":"./src/runtime/dns-browser.js","./src/runtime/libp2p-nodejs.js":"./src/runtime/libp2p-browser.js","./src/runtime/libp2p-pubsub-routers-nodejs.js":"./src/runtime/libp2p-pubsub-routers-browser.js","./src/runtime/preload-nodejs.js":"./src/runtime/preload-browser.js","./src/runtime/repo-nodejs.js":"./src/runtime/repo-browser.js","./test/utils/create-repo-nodejs.js":"./test/utils/create-repo-browser.js","ipfs-utils/src/files/glob-source":false},"typesVersions":{"*":{"*":["dist/*","dist/*/index"]}},"repository":{"type":"git","url":"git+https://github.com/ipfs/js-ipfs.git"},"scripts":{"lint":"aegir lint","build":"npm run build:js && npm run build:types","build:js":"aegir build","build:types":"tsc --build","test":"aegir test","test:node":"aegir test -t node","test:browser":"aegir test -t browser","test:webworker":"aegir test -t webworker -- --timeout 10000","test:electron-main":"aegir test -t electron-main","test:electron-renderer":"aegir test -t electron-renderer","test:bootstrapers":"IPFS_TEST=bootstrapers aegir test -t browser -f test/bootstrapers.js","coverage":"nyc --reporter=text --reporter=lcov npm run test:node","clean":"rimraf ./dist","dep-check":"aegir dep-check -i typescript -i interface-ipfs-core -i ipfs-core-types"},"dependencies":{"array-shuffle":"^1.0.1","bignumber.js":"^9.0.0","cbor":"^5.1.0","cids":"^1.0.0","class-is":"^1.1.0","dag-cbor-links":"^2.0.0","datastore-core":"^2.0.0","datastore-pubsub":"^0.4.1","debug":"^4.1.1","dlv":"^1.1.3","err-code":"^2.0.3","hamt-sharding":"^1.0.0","hashlru":"^2.3.0","interface-datastore":"^2.0.0","ipfs-bitswap":"^4.0.0","ipfs-block-service":"^0.18.0","ipfs-core-utils":"^0.5.4","ipfs-core-types":"^0.1.0","ipfs-repo":"^7.0.0","ipfs-unixfs":"^2.0.3","ipfs-unixfs-exporter":"^3.0.4","ipfs-unixfs-importer":"^5.0.0","ipfs-utils":"^5.0.0","ipld":"^0.28.0","ipld-block":"^0.11.0","ipld-dag-cbor":"^0.17.0","ipld-dag-pb":"^0.20.0","ipld-raw":"^6.0.0","ipns":"^0.8.0","is-domain-name":"^1.0.1","is-ipfs":"^2.0.0","it-all":"^1.0.4","it-first":"^1.0.4","it-last":"^1.0.4","it-pipe":"^1.1.0","libp2p":"^0.29.3","libp2p-bootstrap":"^0.12.1","libp2p-crypto":"^0.18.0","libp2p-floodsub":"^0.23.1","libp2p-gossipsub":"^0.6.1","libp2p-kad-dht":"^0.20.1","libp2p-mdns":"^0.15.0","libp2p-mplex":"^0.10.0","libp2p-noise":"^2.0.1","libp2p-record":"^0.9.0","libp2p-tcp":"^0.15.1","libp2p-webrtc-star":"^0.20.1","libp2p-websockets":"^0.14.0","mafmt":"^8.0.0","merge-options":"^2.0.0","mortice":"^2.0.0","multiaddr":"^8.0.0","multiaddr-to-uri":"^6.0.0","multibase":"^3.0.0","multicodec":"^2.0.1","multihashing-async":"^2.0.1","native-abort-controller":"~0.0.3","p-queue":"^6.6.1","parse-duration":"^0.4.4","peer-id":"^0.14.1","streaming-iterables":"^5.0.2","uint8arrays":"^1.1.0"},"devDependencies":{"aegir":"^29.2.2","delay":"^4.4.0","go-ipfs":"^0.7.0","interface-ipfs-core":"^0.142.3","ipfsd-ctl":"^7.2.0","ipld-git":"^0.6.1","iso-url":"^1.0.0","nanoid":"^3.1.12","rimraf":"^3.0.2","sinon":"^9.0.3","typescript":"4.0.x"}}'); }, function (E, m, f) {
                "use strict";
                const d = f(166), r = f(2), e = f(1)("ipfs:core:config");
                async function c(t) { return Object.keys(n).map(s => ({ name: s, description: n[s].description })); }
                E.exports = ({ repo: t }) => ({ getAll: r(async function (s = {}) { return t.config.getAll(s); }), get: r(async function (s, u) { return s ? t.config.get(s, u) : Promise.reject(new Error("key argument is required")); }), set: r(async function (s, u, i) { return t.config.set(s, u, i); }), replace: r(async function (s, u) { return t.config.replace(s, u); }), profiles: { apply: r(async function (s, u = {}) { const { dryRun: i } = u, o = n[s]; if (!o)
                            throw new Error(`No profile with name '${s}' exists`); try {
                            const h = await t.config.getAll(u);
                            let a = JSON.parse(JSON.stringify(h));
                            return a = o.transform(a), i || await t.config.replace(a, u), delete h.Identity.PrivKey, delete a.Identity.PrivKey, { original: h, updated: a };
                        }
                        catch (h) {
                            throw e(h), new Error(`Could not apply profile '${s}' to config: ${h.message}`);
                        } }), list: r(c) } });
                const n = { server: { description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery in local networks.", transform: t => (t.Discovery.MDNS.Enabled = !1, t.Discovery.webRTCStar.Enabled = !1, t) }, "local-discovery": { description: "Sets default values to fields affected by `server` profile, enables discovery in local networks.", transform: t => (t.Discovery.MDNS.Enabled = !0, t.Discovery.webRTCStar.Enabled = !0, t) }, test: { description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.", transform: t => { const s = d(); return t.Addresses.API = s.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "", t.Addresses.Gateway = s.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "", t.Addresses.Swarm = s.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : [], t.Addresses.Delegates = [], t.Bootstrap = [], t.Discovery.MDNS.Enabled = !1, t.Discovery.webRTCStar.Enabled = !1, t; } }, "default-networking": { description: "Restores default network settings. Inverse profile of the `test` profile.", transform: t => { const s = d(); return t.Addresses.API = s.Addresses.API, t.Addresses.Gateway = s.Addresses.Gateway, t.Addresses.Swarm = s.Addresses.Swarm, t.Addresses.Delegates = s.Addresses.Delegates, t.Bootstrap = s.Bootstrap, t.Discovery.MDNS.Enabled = s.Discovery.MDNS.Enabled, t.Discovery.webRTCStar.Enabled = s.Discovery.webRTCStar.Enabled, t; } }, lowpower: { description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.", transform: t => { const s = t.Swarm || {}, u = s.ConnMgr || {}; return u.LowWater = 20, u.HighWater = 40, s.ConnMgr = u, t.Swarm = s, t; } }, "default-power": { description: 'Inverse of "lowpower" profile.', transform: t => { const s = d(); return t.Swarm = s.Swarm, t; } } };
                E.exports.profiles = n;
            }, function (E, m, f) {
                "use strict";
                const d = f(13), r = (c, n) => n, e = { ip4: r, ip6: (c, n, t, s) => s.length === 1 && s[0].protocol === "ip6" ? n : `[${n}]`, tcp: (c, n, t, s, u) => s.some(i => ["http", "https", "ws", "wss"].includes(i.protocol)) ? `${c}:${n}` : ((i, o, h, a) => { if (a && a.assumeHttp === !1)
                        return `tcp://${i}:${o}`; let l = "tcp", p = ":" + o; return h[h.length - 1].protocol === "tcp" && (l = o === "443" ? "https" : "http", p = o === "443" || o === "80" ? "" : p), `${l}://${i}${p}`; })(c, n, s, u), udp: (c, n) => `udp://${c}:${n}`, dnsaddr: r, dns4: r, dns6: r, ipfs: (c, n) => `${c}/ipfs/${n}`, p2p: (c, n) => `${c}/p2p/${n}`, http: c => "http://" + c, https: c => "https://" + c, ws: c => "ws://" + c, wss: c => "wss://" + c, "p2p-websocket-star": c => c + "/p2p-websocket-star", "p2p-webrtc-star": c => c + "/p2p-webrtc-star", "p2p-webrtc-direct": c => c + "/p2p-webrtc-direct" };
                E.exports = (c, n) => { const t = d(c), s = c.toString().split("/").slice(1); return t.tuples().map(u => ({ protocol: s.shift(), content: u[1] ? s.shift() : null })).reduce((u, i, o, h) => { const a = e[i.protocol]; if (!a)
                    throw new Error("Unsupported protocol " + i.protocol); return a(u, i.content, o, h, n); }, ""); };
            }, function (E, m, f) {
                "use strict";
                const d = f(291);
                let r;
                E.exports = e => { if (r)
                    return r; const c = d({ singleProcess: e }); return r = { readLock: n => async (...t) => { const s = await c.readLock(); try {
                        return await n.apply(null, t);
                    }
                    finally {
                        s();
                    } }, writeLock: n => async (...t) => { const s = await c.writeLock(); try {
                        return await n.apply(null, t);
                    }
                    finally {
                        s();
                    } } }, r; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(691), e = f(701), { default: c } = f(86), { timeout: n } = f(702), t = f(294), s = {}; let u; function i(h, a) { let l; const p = new Promise(g => { l = g; }); return h.add(() => n(new Promise(g => { l(() => { g(); }); }), a.timeout)), p; } const o = { concurrency: 1 / 0, timeout: 846e5, global: d, singleProcess: !1 }; E.exports = (h, a) => (a || (a = {}), typeof h == "object" && (a = h, h = "lock"), h || (h = "lock"), a = Object.assign({}, o, a), u || (u = r(a) || e(a), u.isWorker || (u.on("requestReadLock", (l, p) => { s[l] && s[l].readLock().then(g => p().finally(() => g())); }), u.on("requestWriteLock", async (l, p) => { s[l] && s[l].writeLock().then(g => p().finally(() => g())); }))), s[h] || (s[h] = ((l, p) => { if (u.isWorker)
                    return { readLock: u.readLock(l, p), writeLock: u.writeLock(l, p) }; const g = new c({ concurrency: 1 }); let b = null; return { readLock: () => { if (b)
                        return i(b, p); b = new c({ concurrency: p.concurrency, autoStart: !1 }); const I = b, v = i(b, p); return g.add(() => (I.start(), I.onIdle().then(() => { b === I && (b = null); }))), v; }, writeLock: () => (b = null, i(g, p)) }; })(h, a)), s[h]), E.exports.Worker = function (h, a) { let l; a = a || d.Worker; try {
                    l = new a(h);
                }
                catch (p) {
                    p.message.includes("not a constructor") && (l = a(h));
                } if (!l)
                    throw new Error("Could not create Worker from", a); return t(l), l; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                E.exports = f(692);
            }, function (E, m, f) {
                "use strict";
                E.exports = { WORKER_REQUEST_READ_LOCK: "lock:worker:request-read", WORKER_RELEASE_READ_LOCK: "lock:worker:release-read", MASTER_GRANT_READ_LOCK: "lock:master:grant-read", WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write", WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write", MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write" };
            }, function (E, m, f) {
                "use strict";
                const d = {}, r = e => { e.addEventListener("message", c => { r.dispatchEvent("message", e, c); }), e.port && e.port.addEventListener("message", c => { r.dispatchEvent("message", e, c); }); };
                r.addEventListener = (e, c) => { d[e] || (d[e] = []), d[e].push(c); }, r.removeEventListener = (e, c) => { d[e] && (d[e] = d[e].filter(n => n === c)); }, r.dispatchEvent = function () { const e = Array.prototype.slice.call(arguments), c = e.shift(); d[c] && d[c].forEach(n => n.apply(null, e)); }, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(29), { DAGNode: e } = f(17), c = f(1)("ipfs:mfs:utils:with-mfs-root"), n = f(18), t = f(16).multihash, s = f(0), { MFS_ROOT_KEY: u } = f(23);
                E.exports = async (i, o) => { if (o && o.signal && o.signal.aborted)
                    throw s(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" }); let h; await i.repo.datastore.open(); try {
                    const a = await i.repo.datastore.get(u);
                    h = new d(a);
                }
                catch (a) {
                    if (a.code !== "ERR_NOT_FOUND")
                        throw a;
                    c("Creating new MFS root");
                    const l = new e(new r({ type: "directory" }).marshal());
                    if (h = await i.ipld.put(l, n.DAG_PB, { cidVersion: 0, hashAlg: t.names["sha2-256"] }), o && o.signal && o.signal.aborted)
                        throw s(new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
                    await i.repo.datastore.put(u, h.bytes);
                } return c("Loaded MFS root /ipfs/" + h), h; };
            }, function (E, m, f) {
                "use strict";
                const { DAGNode: d } = f(17), r = f(172), e = f(171), c = f(1)("ipfs:mfs:core:utils:hamt-utils"), n = f(29), t = f(18), s = f(16).multihash, u = f(40), i = async (a, l, p, g) => { const b = new r({ hashFn: e.hashFn, hash: p ? p._options.hash : void 0 }, p, g); return p && p._putObjectAt(g, b), await o(a, b, l), b; }, o = async (a, l, p) => { await Promise.all(a.map(g => { if (g.Name.length === 2) {
                    const b = parseInt(g.Name, 16);
                    return l._putObjectAt(b, new r({ hashFn: e.hashFn }, l, b)), Promise.resolve();
                } return (p || l).put(g.Name.substring(2), { size: g.Tsize, cid: g.Hash }); })); }, h = a => a.toString("16").toUpperCase().padStart(2, "0").substring(0, 2);
                E.exports = { generatePath: async (a, l, p) => { const g = await i(p.Links, null, null, null), b = await g._findNewBucketAndPos(l), I = [{ bucket: b.bucket, prefix: h(b.pos) }]; let v = b.bucket; for (; v !== g;)
                        I.push({ bucket: v, prefix: h(v._posAtParent) }), v = v._parent; I.reverse(), I[0].node = p; for (let R = 0; R < I.length; R++) {
                        const _ = I[R], k = _.node.Links.filter(N => N.Name.substring(0, 2) === _.prefix).pop();
                        if (!k) {
                            c(`Link ${_.prefix}${l} will be added`);
                            continue;
                        }
                        if (k.Name === `${_.prefix}${l}`) {
                            c(`Link ${_.prefix}${l} will be replaced`);
                            continue;
                        }
                        c("Found subshard " + _.prefix);
                        const x = await a.ipld.get(k.Hash);
                        if (!I[R + 1]) {
                            c("Loaded new subshard " + _.prefix), await i(x.Links, g, _.bucket, parseInt(_.prefix, 16));
                            const N = await g._findNewBucketAndPos(l);
                            I.push({ bucket: N.bucket, prefix: h(N.pos), node: x });
                            continue;
                        }
                        const M = I[R + 1];
                        await o(x.Links, M.bucket, g), M.node = x;
                    } return await g.put(l, !0), I.reverse(), { rootBucket: g, path: I }; }, updateHamtDirectory: async (a, l, p, g) => { const b = Uint8Array.from(p._children.bitField().reverse()), I = n.unmarshal(g.parent.Data), v = new n({ type: "hamt-sharded-directory", data: b, fanout: p.tableSize(), hashType: e.hashFn.code, mode: I.mode, mtime: I.mtime }), R = s.names[g.hashAlg], _ = new d(v.marshal(), l); return { node: _, cid: await a.ipld.put(_, t.DAG_PB, { cidVersion: g.cidVersion, hashAlg: R, onlyHash: !g.flush }), size: _.size }; }, recreateHamtLevel: i, addLinksToHamtBucket: o, toPrefix: h, createShard: async (a, l, p) => { const g = new e({ root: !0, dir: !0, parent: null, parentKey: null, path: "", dirty: !0, flat: !1, mtime: p.mtime, mode: p.mode }, { ...p, codec: "dag-pb" }); for (let b = 0; b < l.length; b++)
                        await g._bucket.put(l[b].name, { size: l[b].size, cid: l[b].cid }); return u(g.flush("", a.block, null)); } };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ repo: r }) => d(async function (e) { const c = await r.stat(e); return { numObjects: c.numObjects, repoSize: c.repoSize, repoPath: c.repoPath, version: c.version.toString(), storageMax: c.storageMax }; });
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { if (!d)
                    return e; var c, n; if (Array.isArray(r) && (c = r.slice(0)), typeof r == "string" && (c = r.split(".")), typeof r == "symbol" && (c = [r]), !Array.isArray(c))
                    throw new Error("props arg must be an array, a string or a symbol"); for (; c.length;) {
                    if (n = c.shift(), !d)
                        return e;
                    if ((d = d[n]) === void 0)
                        return e;
                } return d; };
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { let r = 0; for await (const e of d)
                    r++; return r; };
            }, function (E, m, f) {
                "use strict";
                const d = f(25), { Key: r } = f(11), e = f(16).multihash, c = new r("/local/pins"), n = e.fromB58String("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
                E.exports = { PIN_DS_KEY: c, DEFAULT_FANOUT: 256, MAX_ITEMS: 8192, EMPTY_KEY: n, PinTypes: { direct: "direct", recursive: "recursive" }, cidToKey: function (t) { return new r("/" + d.encoding("base32upper").encode(t.multihash)); } };
            }, function (E, m, f) {
                "use strict";
                const { Key: d } = f(11), r = f(4), e = f(25), c = f(0), n = f(5);
                m.cidToKey = t => { if (!r.isCID(t))
                    throw c(new Error("Not a valid cid"), "ERR_INVALID_CID"); return new d("/" + n(e.encode("base32", t.multihash)).slice(1).toUpperCase(), !1); }, m.keyToCid = t => new r(1, "raw", e.decode("b" + t.toString().slice(1).toLowerCase()));
            }, function (E, m, f) {
                "use strict";
                const d = f(756);
                E.exports = class {
                    constructor(r) { this.hwm = r || 16, this.head = new d(this.hwm), this.tail = this.head; }
                    push(r) { if (!this.head.push(r)) {
                        const e = this.head;
                        this.head = e.next = new d(2 * this.head.buffer.length), this.head.push(r);
                    } }
                    shift() { const r = this.tail.shift(); if (r === void 0 && this.tail.next) {
                        const e = this.tail.next;
                        return this.tail.next = null, this.tail = e, this.tail.shift();
                    } return r; }
                    isEmpty() { return this.head.isEmpty(); }
                };
            }, function (E, m, f) {
                "use strict";
                m.AbstractLevelDOWN = f(762), m.AbstractIterator = f(304), m.AbstractChainedBatch = f(306);
            }, function (E, m, f) {
                "use strict";
                var d = f(186);
                function r(e) { if (typeof e != "object" || e === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = e, this._ended = !1, this._nexting = !1; }
                r.prototype.next = function (e) { var c = this; if (typeof e != "function")
                    throw new Error("next() requires a callback argument"); return c._ended ? (d(e, new Error("cannot call next() after end()")), c) : c._nexting ? (d(e, new Error("cannot call next() before previous next() has completed")), c) : (c._nexting = !0, c._next(function () { c._nexting = !1, e.apply(null, arguments); }), c); }, r.prototype._next = function (e) { d(e); }, r.prototype.seek = function (e) { if (this._ended)
                    throw new Error("cannot call seek() after end()"); if (this._nexting)
                    throw new Error("cannot call seek() before next() has completed"); e = this.db._serializeKey(e), this._seek(e); }, r.prototype._seek = function (e) { }, r.prototype.end = function (e) { if (typeof e != "function")
                    throw new Error("end() requires a callback argument"); if (this._ended)
                    return d(e, new Error("end() already called on iterator")); this._ended = !0, this._end(e); }, r.prototype._end = function (e) { d(e); }, r.prototype._nextTick = d, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                var d, r, e, c = [f(764), f(765), f(766), f(767), f(768), f(769)], n = -1, t = [], s = !1;
                function u() { d && r && (d = !1, r.length ? t = r.concat(t) : n = -1, t.length && i()); }
                function i() { if (!d) {
                    s = !1, d = !0;
                    for (var l = t.length, p = setTimeout(u); l;) {
                        for (r = t, t = []; r && ++n < l;)
                            r[n].run();
                        n = -1, l = t.length;
                    }
                    r = null, n = -1, d = !1, clearTimeout(p);
                } }
                for (var o = -1, h = c.length; ++o < h;)
                    if (c[o] && c[o].test && c[o].test()) {
                        e = c[o].install(i);
                        break;
                    }
                function a(l, p) { this.fun = l, this.array = p; }
                a.prototype.run = function () { var l = this.fun, p = this.array; switch (p.length) {
                    case 0: return l();
                    case 1: return l(p[0]);
                    case 2: return l(p[0], p[1]);
                    case 3: return l(p[0], p[1], p[2]);
                    default: return l.apply(null, p);
                } }, E.exports = function (l) { var p = new Array(arguments.length - 1); if (arguments.length > 1)
                    for (var g = 1; g < arguments.length; g++)
                        p[g - 1] = arguments[g]; t.push(new a(l, p)), s || d || (s = !0, e()); };
            }, function (E, m, f) {
                "use strict";
                var d = f(186);
                function r(e) { if (typeof e != "object" || e === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = e, this._operations = [], this._written = !1; }
                r.prototype._checkWritten = function () { if (this._written)
                    throw new Error("write() already called on this batch"); }, r.prototype.put = function (e, c) { this._checkWritten(); var n = this.db._checkKey(e) || this.db._checkValue(c); if (n)
                    throw n; return e = this.db._serializeKey(e), c = this.db._serializeValue(c), this._put(e, c), this; }, r.prototype._put = function (e, c) { this._operations.push({ type: "put", key: e, value: c }); }, r.prototype.del = function (e) { this._checkWritten(); var c = this.db._checkKey(e); if (c)
                    throw c; return e = this.db._serializeKey(e), this._del(e), this; }, r.prototype._del = function (e) { this._operations.push({ type: "del", key: e }); }, r.prototype.clear = function () { return this._checkWritten(), this._clear(), this; }, r.prototype._clear = function () { this._operations = []; }, r.prototype.write = function (e, c) { if (this._checkWritten(), typeof e == "function" && (c = e), typeof c != "function")
                    throw new Error("write() requires a callback argument"); typeof e == "object" && e !== null || (e = {}), this._written = !0, this._write(e, c); }, r.prototype._write = function (e, c) { this.db._batch(this._operations, e, c); }, r.prototype._nextTick = d, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e; E.exports = N, N.ReadableState = M, f(12).EventEmitter; var c = function (y, C) { return y.listeners(C).length; }, n = f(308), t = f(3).Buffer, s = d.Uint8Array || function () { }, u, i = f(773); u = i && i.debuglog ? i.debuglog("stream") : function () { }; var o, h, a, l = f(774), p = f(309), g = f(310).getHighWaterMark, b = f(72).codes, I = b.ERR_INVALID_ARG_TYPE, v = b.ERR_STREAM_PUSH_AFTER_EOF, R = b.ERR_METHOD_NOT_IMPLEMENTED, _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; f(15)(N, n); var k = p.errorOrDestroy, x = ["error", "close", "destroy", "pause", "resume"]; function M(y, C, A) { e = e || f(73), y = y || {}, typeof A != "boolean" && (A = C instanceof e), this.objectMode = !!y.objectMode, A && (this.objectMode = this.objectMode || !!y.readableObjectMode), this.highWaterMark = g(this, y, "readableHighWaterMark", A), this.buffer = new l, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = y.emitClose !== !1, this.autoDestroy = !!y.autoDestroy, this.destroyed = !1, this.defaultEncoding = y.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, y.encoding && (o || (o = f(121).StringDecoder), this.decoder = new o(y.encoding), this.encoding = y.encoding); } function N(y) { if (e = e || f(73), !(this instanceof N))
                    return new N(y); var C = this instanceof e; this._readableState = new M(y, this, C), this.readable = !0, y && (typeof y.read == "function" && (this._read = y.read), typeof y.destroy == "function" && (this._destroy = y.destroy)), n.call(this); } function S(y, C, A, U, z) { u("readableAddChunk", C); var w, O = y._readableState; if (C === null)
                    O.reading = !1, function (q, H) { if (u("onEofChunk"), H.ended)
                        return; if (H.decoder) {
                        var V = H.decoder.end();
                        V && V.length && (H.buffer.push(V), H.length += H.objectMode ? 1 : V.length);
                    } H.ended = !0, H.sync ? P(q) : (H.needReadable = !1, H.emittedReadable || (H.emittedReadable = !0, L(q))); }(y, O);
                else if (z || (w = function (q, H) { var V; J = H, t.isBuffer(J) || J instanceof s || typeof H == "string" || H === void 0 || q.objectMode || (V = new I("chunk", ["string", "Buffer", "Uint8Array"], H)); var J; return V; }(O, C)), w)
                    k(y, w);
                else if (O.objectMode || C && C.length > 0)
                    if (typeof C == "string" || O.objectMode || Object.getPrototypeOf(C) === t.prototype || (C = function (q) { return t.from(q); }(C)), U)
                        O.endEmitted ? k(y, new _) : T(y, O, C, !0);
                    else if (O.ended)
                        k(y, new v);
                    else {
                        if (O.destroyed)
                            return !1;
                        O.reading = !1, O.decoder && !A ? (C = O.decoder.write(C), O.objectMode || C.length !== 0 ? T(y, O, C, !1) : j(y, O)) : T(y, O, C, !1);
                    }
                else
                    U || (O.reading = !1, j(y, O)); return !O.ended && (O.length < O.highWaterMark || O.length === 0); } function T(y, C, A, U) { C.flowing && C.length === 0 && !C.sync ? (C.awaitDrain = 0, y.emit("data", A)) : (C.length += C.objectMode ? 1 : A.length, U ? C.buffer.unshift(A) : C.buffer.push(A), C.needReadable && P(y)), j(y, C); } Object.defineProperty(N.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState !== void 0 && this._readableState.destroyed; }, set: function (y) { this._readableState && (this._readableState.destroyed = y); } }), N.prototype.destroy = p.destroy, N.prototype._undestroy = p.undestroy, N.prototype._destroy = function (y, C) { C(y); }, N.prototype.push = function (y, C) { var A, U = this._readableState; return U.objectMode ? A = !0 : typeof y == "string" && ((C = C || U.defaultEncoding) !== U.encoding && (y = t.from(y, C), C = ""), A = !0), S(this, y, C, !1, A); }, N.prototype.unshift = function (y) { return S(this, y, null, !0, !1); }, N.prototype.isPaused = function () { return this._readableState.flowing === !1; }, N.prototype.setEncoding = function (y) { o || (o = f(121).StringDecoder); var C = new o(y); this._readableState.decoder = C, this._readableState.encoding = this._readableState.decoder.encoding; for (var A = this._readableState.buffer.head, U = ""; A !== null;)
                    U += C.write(A.data), A = A.next; return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this; }; function B(y, C) { return y <= 0 || C.length === 0 && C.ended ? 0 : C.objectMode ? 1 : y != y ? C.flowing && C.length ? C.buffer.head.data.length : C.length : (y > C.highWaterMark && (C.highWaterMark = function (A) { return A >= 1073741824 ? A = 1073741824 : (A--, A |= A >>> 1, A |= A >>> 2, A |= A >>> 4, A |= A >>> 8, A |= A >>> 16, A++), A; }(y)), y <= C.length ? y : C.ended ? C.length : (C.needReadable = !0, 0)); } function P(y) { var C = y._readableState; u("emitReadable", C.needReadable, C.emittedReadable), C.needReadable = !1, C.emittedReadable || (u("emitReadable", C.flowing), C.emittedReadable = !0, r.nextTick(L, y)); } function L(y) { var C = y._readableState; u("emitReadable_", C.destroyed, C.length, C.ended), C.destroyed || !C.length && !C.ended || (y.emit("readable"), C.emittedReadable = !1), C.needReadable = !C.flowing && !C.ended && C.length <= C.highWaterMark, Q(y); } function j(y, C) { C.readingMore || (C.readingMore = !0, r.nextTick(D, y, C)); } function D(y, C) { for (; !C.reading && !C.ended && (C.length < C.highWaterMark || C.flowing && C.length === 0);) {
                    var A = C.length;
                    if (u("maybeReadMore read 0"), y.read(0), A === C.length)
                        break;
                } C.readingMore = !1; } function G(y) { var C = y._readableState; C.readableListening = y.listenerCount("readable") > 0, C.resumeScheduled && !C.paused ? C.flowing = !0 : y.listenerCount("data") > 0 && y.resume(); } function W(y) { u("readable nexttick read 0"), y.read(0); } function X(y, C) { u("resume", C.reading), C.reading || y.read(0), C.resumeScheduled = !1, y.emit("resume"), Q(y), C.flowing && !C.reading && y.read(0); } function Q(y) { var C = y._readableState; for (u("flow", C.flowing); C.flowing && y.read() !== null;)
                    ; } function K(y, C) { return C.length === 0 ? null : (C.objectMode ? A = C.buffer.shift() : !y || y >= C.length ? (A = C.decoder ? C.buffer.join("") : C.buffer.length === 1 ? C.buffer.first() : C.buffer.concat(C.length), C.buffer.clear()) : A = C.buffer.consume(y, C.decoder), A); var A; } function F(y) { var C = y._readableState; u("endReadable", C.endEmitted), C.endEmitted || (C.ended = !0, r.nextTick(Y, C, y)); } function Y(y, C) { if (u("endReadableNT", y.endEmitted, y.length), !y.endEmitted && y.length === 0 && (y.endEmitted = !0, C.readable = !1, C.emit("end"), y.autoDestroy)) {
                    var A = C._writableState;
                    (!A || A.autoDestroy && A.finished) && C.destroy();
                } } function $(y, C) { for (var A = 0, U = y.length; A < U; A++)
                    if (y[A] === C)
                        return A; return -1; } N.prototype.read = function (y) { u("read", y), y = parseInt(y, 10); var C = this._readableState, A = y; if (y !== 0 && (C.emittedReadable = !1), y === 0 && C.needReadable && ((C.highWaterMark !== 0 ? C.length >= C.highWaterMark : C.length > 0) || C.ended))
                    return u("read: emitReadable", C.length, C.ended), C.length === 0 && C.ended ? F(this) : P(this), null; if ((y = B(y, C)) === 0 && C.ended)
                    return C.length === 0 && F(this), null; var U, z = C.needReadable; return u("need readable", z), (C.length === 0 || C.length - y < C.highWaterMark) && u("length less than watermark", z = !0), C.ended || C.reading ? u("reading or ended", z = !1) : z && (u("do read"), C.reading = !0, C.sync = !0, C.length === 0 && (C.needReadable = !0), this._read(C.highWaterMark), C.sync = !1, C.reading || (y = B(A, C))), (U = y > 0 ? K(y, C) : null) === null ? (C.needReadable = C.length <= C.highWaterMark, y = 0) : (C.length -= y, C.awaitDrain = 0), C.length === 0 && (C.ended || (C.needReadable = !0), A !== y && C.ended && F(this)), U !== null && this.emit("data", U), U; }, N.prototype._read = function (y) { k(this, new R("_read()")); }, N.prototype.pipe = function (y, C) { var A = this, U = this._readableState; switch (U.pipesCount) {
                    case 0:
                        U.pipes = y;
                        break;
                    case 1:
                        U.pipes = [U.pipes, y];
                        break;
                    default: U.pipes.push(y);
                } U.pipesCount += 1, u("pipe count=%d opts=%j", U.pipesCount, C); var z = (!C || C.end !== !1) && y !== r.stdout && y !== r.stderr ? O : nt; function w(rt, it) { u("onunpipe"), rt === A && it && it.hasUnpiped === !1 && (it.hasUnpiped = !0, u("cleanup"), y.removeListener("close", Z), y.removeListener("finish", tt), y.removeListener("drain", q), y.removeListener("error", J), y.removeListener("unpipe", w), A.removeListener("end", O), A.removeListener("end", nt), A.removeListener("data", V), H = !0, !U.awaitDrain || y._writableState && !y._writableState.needDrain || q()); } function O() { u("onend"), y.end(); } U.endEmitted ? r.nextTick(z) : A.once("end", z), y.on("unpipe", w); var q = function (rt) { return function () { var it = rt._readableState; u("pipeOnDrain", it.awaitDrain), it.awaitDrain && it.awaitDrain--, it.awaitDrain === 0 && c(rt, "data") && (it.flowing = !0, Q(rt)); }; }(A); y.on("drain", q); var H = !1; function V(rt) { u("ondata"); var it = y.write(rt); u("dest.write", it), it === !1 && ((U.pipesCount === 1 && U.pipes === y || U.pipesCount > 1 && $(U.pipes, y) !== -1) && !H && (u("false write response, pause", U.awaitDrain), U.awaitDrain++), A.pause()); } function J(rt) { u("onerror", rt), nt(), y.removeListener("error", J), c(y, "error") === 0 && k(y, rt); } function Z() { y.removeListener("finish", tt), nt(); } function tt() { u("onfinish"), y.removeListener("close", Z), nt(); } function nt() { u("unpipe"), A.unpipe(y); } return A.on("data", V), function (rt, it, st) { if (typeof rt.prependListener == "function")
                    return rt.prependListener(it, st); rt._events && rt._events[it] ? Array.isArray(rt._events[it]) ? rt._events[it].unshift(st) : rt._events[it] = [st, rt._events[it]] : rt.on(it, st); }(y, "error", J), y.once("close", Z), y.once("finish", tt), y.emit("pipe", A), U.flowing || (u("pipe resume"), A.resume()), y; }, N.prototype.unpipe = function (y) { var C = this._readableState, A = { hasUnpiped: !1 }; if (C.pipesCount === 0)
                    return this; if (C.pipesCount === 1)
                    return y && y !== C.pipes || (y || (y = C.pipes), C.pipes = null, C.pipesCount = 0, C.flowing = !1, y && y.emit("unpipe", this, A)), this; if (!y) {
                    var U = C.pipes, z = C.pipesCount;
                    C.pipes = null, C.pipesCount = 0, C.flowing = !1;
                    for (var w = 0; w < z; w++)
                        U[w].emit("unpipe", this, { hasUnpiped: !1 });
                    return this;
                } var O = $(C.pipes, y); return O === -1 || (C.pipes.splice(O, 1), C.pipesCount -= 1, C.pipesCount === 1 && (C.pipes = C.pipes[0]), y.emit("unpipe", this, A)), this; }, N.prototype.on = function (y, C) { var A = n.prototype.on.call(this, y, C), U = this._readableState; return y === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== !1 && this.resume()) : y === "readable" && (U.endEmitted || U.readableListening || (U.readableListening = U.needReadable = !0, U.flowing = !1, U.emittedReadable = !1, u("on readable", U.length, U.reading), U.length ? P(this) : U.reading || r.nextTick(W, this))), A; }, N.prototype.addListener = N.prototype.on, N.prototype.removeListener = function (y, C) { var A = n.prototype.removeListener.call(this, y, C); return y === "readable" && r.nextTick(G, this), A; }, N.prototype.removeAllListeners = function (y) { var C = n.prototype.removeAllListeners.apply(this, arguments); return y !== "readable" && y !== void 0 || r.nextTick(G, this), C; }, N.prototype.resume = function () { var y = this._readableState; return y.flowing || (u("resume"), y.flowing = !y.readableListening, function (C, A) { A.resumeScheduled || (A.resumeScheduled = !0, r.nextTick(X, C, A)); }(this, y)), y.paused = !1, this; }, N.prototype.pause = function () { return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this; }, N.prototype.wrap = function (y) { var C = this, A = this._readableState, U = !1; for (var z in y.on("end", function () { if (u("wrapped end"), A.decoder && !A.ended) {
                    var O = A.decoder.end();
                    O && O.length && C.push(O);
                } C.push(null); }), y.on("data", function (O) { (u("wrapped data"), A.decoder && (O = A.decoder.write(O)), A.objectMode && O == null) || (A.objectMode || O && O.length) && (C.push(O) || (U = !0, y.pause())); }), y)
                    this[z] === void 0 && typeof y[z] == "function" && (this[z] = function (O) { return function () { return y[O].apply(y, arguments); }; }(z)); for (var w = 0; w < x.length; w++)
                    y.on(x[w], this.emit.bind(this, x[w])); return this._read = function (O) { u("wrapped _read", O), U && (U = !1, y.resume()); }, this; }, typeof Symbol == "function" && (N.prototype[Symbol.asyncIterator] = function () { return h === void 0 && (h = f(776)), h(this); }), Object.defineProperty(N.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark; } }), Object.defineProperty(N.prototype, "readableBuffer", { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer; } }), Object.defineProperty(N.prototype, "readableFlowing", { enumerable: !1, get: function () { return this._readableState.flowing; }, set: function (y) { this._readableState && (this._readableState.flowing = y); } }), N._fromList = K, Object.defineProperty(N.prototype, "readableLength", { enumerable: !1, get: function () { return this._readableState.length; } }), typeof Symbol == "function" && (N.from = function (y, C) { return a === void 0 && (a = f(777)), a(N, y, C); }); }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = f(12).EventEmitter;
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(n, t) { c(n, t), e(n); } function e(n) { n._writableState && !n._writableState.emitClose || n._readableState && !n._readableState.emitClose || n.emit("close"); } function c(n, t) { n.emit("error", t); } E.exports = { destroy: function (n, t) { var s = this, u = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed; return u || i ? (t ? t(n) : n && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, d.nextTick(c, this, n)) : d.nextTick(c, this, n)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(n || null, function (o) { !t && o ? s._writableState ? s._writableState.errorEmitted ? d.nextTick(e, s) : (s._writableState.errorEmitted = !0, d.nextTick(r, s, o)) : d.nextTick(r, s, o) : t ? (d.nextTick(e, s), t(o)) : d.nextTick(e, s); }), this); }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1); }, errorOrDestroy: function (n, t) { var s = n._readableState, u = n._writableState; s && s.autoDestroy || u && u.autoDestroy ? n.destroy(t) : n.emit("error", t); } }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(72).codes.ERR_INVALID_OPT_VALUE;
                E.exports = { getHighWaterMark: function (r, e, c, n) { var t = function (s, u, i) { return s.highWaterMark != null ? s.highWaterMark : u ? s[i] : null; }(e, n, c); if (t != null) {
                        if (!isFinite(t) || Math.floor(t) !== t || t < 0)
                            throw new d(n ? c : "highWaterMark", t);
                        return Math.floor(t);
                    } return r.objectMode ? 16 : 16384; } };
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { function e(D) { var G = this; this.next = null, this.entry = null, this.finish = function () { !function (W, X, Q) { var K = W.entry; for (W.entry = null; K;) {
                    var F = K.callback;
                    X.pendingcb--, F(Q), K = K.next;
                } X.corkedRequestsFree.next = W; }(G, D); }; } var c; E.exports = N, N.WritableState = M; var n = { deprecate: f(159) }, t = f(308), s = f(3).Buffer, u = d.Uint8Array || function () { }, i, o = f(309), h = f(310).getHighWaterMark, a = f(72).codes, l = a.ERR_INVALID_ARG_TYPE, p = a.ERR_METHOD_NOT_IMPLEMENTED, g = a.ERR_MULTIPLE_CALLBACK, b = a.ERR_STREAM_CANNOT_PIPE, I = a.ERR_STREAM_DESTROYED, v = a.ERR_STREAM_NULL_VALUES, R = a.ERR_STREAM_WRITE_AFTER_END, _ = a.ERR_UNKNOWN_ENCODING, k = o.errorOrDestroy; function x() { } function M(D, G, W) { c = c || f(73), D = D || {}, typeof W != "boolean" && (W = G instanceof c), this.objectMode = !!D.objectMode, W && (this.objectMode = this.objectMode || !!D.writableObjectMode), this.highWaterMark = h(this, D, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var X = D.decodeStrings === !1; this.decodeStrings = !X, this.defaultEncoding = D.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (Q) { !function (K, F) { var Y = K._writableState, $ = Y.sync, y = Y.writecb; if (typeof y != "function")
                    throw new g; if (function (A) { A.writing = !1, A.writecb = null, A.length -= A.writelen, A.writelen = 0; }(Y), F)
                    !function (A, U, z, w, O) { --U.pendingcb, z ? (r.nextTick(O, w), r.nextTick(j, A, U), A._writableState.errorEmitted = !0, k(A, w)) : (O(w), A._writableState.errorEmitted = !0, k(A, w), j(A, U)); }(K, Y, $, F, y);
                else {
                    var C = P(Y) || K.destroyed;
                    C || Y.corked || Y.bufferProcessing || !Y.bufferedRequest || B(K, Y), $ ? r.nextTick(T, K, Y, C, y) : T(K, Y, C, y);
                } }(G, Q); }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = D.emitClose !== !1, this.autoDestroy = !!D.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this); } function N(D) { var G = this instanceof (c = c || f(73)); if (!G && !i.call(N, this))
                    return new N(D); this._writableState = new M(D, this, G), this.writable = !0, D && (typeof D.write == "function" && (this._write = D.write), typeof D.writev == "function" && (this._writev = D.writev), typeof D.destroy == "function" && (this._destroy = D.destroy), typeof D.final == "function" && (this._final = D.final)), t.call(this); } function S(D, G, W, X, Q, K, F) { G.writelen = X, G.writecb = F, G.writing = !0, G.sync = !0, G.destroyed ? G.onwrite(new I("write")) : W ? D._writev(Q, G.onwrite) : D._write(Q, K, G.onwrite), G.sync = !1; } function T(D, G, W, X) { W || function (Q, K) { K.length === 0 && K.needDrain && (K.needDrain = !1, Q.emit("drain")); }(D, G), G.pendingcb--, X(), j(D, G); } function B(D, G) { G.bufferProcessing = !0; var W = G.bufferedRequest; if (D._writev && W && W.next) {
                    var X = G.bufferedRequestCount, Q = new Array(X), K = G.corkedRequestsFree;
                    K.entry = W;
                    for (var F = 0, Y = !0; W;)
                        Q[F] = W, W.isBuf || (Y = !1), W = W.next, F += 1;
                    Q.allBuffers = Y, S(D, G, !0, G.length, Q, "", K.finish), G.pendingcb++, G.lastBufferedRequest = null, K.next ? (G.corkedRequestsFree = K.next, K.next = null) : G.corkedRequestsFree = new e(G), G.bufferedRequestCount = 0;
                }
                else {
                    for (; W;) {
                        var $ = W.chunk, y = W.encoding, C = W.callback;
                        if (S(D, G, !1, G.objectMode ? 1 : $.length, $, y, C), W = W.next, G.bufferedRequestCount--, G.writing)
                            break;
                    }
                    W === null && (G.lastBufferedRequest = null);
                } G.bufferedRequest = W, G.bufferProcessing = !1; } function P(D) { return D.ending && D.length === 0 && D.bufferedRequest === null && !D.finished && !D.writing; } function L(D, G) { D._final(function (W) { G.pendingcb--, W && k(D, W), G.prefinished = !0, D.emit("prefinish"), j(D, G); }); } function j(D, G) { var W = P(G); if (W && (function (Q, K) { K.prefinished || K.finalCalled || (typeof Q._final != "function" || K.destroyed ? (K.prefinished = !0, Q.emit("prefinish")) : (K.pendingcb++, K.finalCalled = !0, r.nextTick(L, Q, K))); }(D, G), G.pendingcb === 0 && (G.finished = !0, D.emit("finish"), G.autoDestroy))) {
                    var X = D._readableState;
                    (!X || X.autoDestroy && X.endEmitted) && D.destroy();
                } return W; } f(15)(N, t), M.prototype.getBuffer = function () { for (var D = this.bufferedRequest, G = []; D;)
                    G.push(D), D = D.next; return G; }, function () { try {
                    Object.defineProperty(M.prototype, "buffer", { get: n.deprecate(function () { return this.getBuffer(); }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
                }
                catch (D) { } }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (i = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, { value: function (D) { return !!i.call(this, D) || this === N && D && D._writableState instanceof M; } })) : i = function (D) { return D instanceof this; }, N.prototype.pipe = function () { k(this, new b); }, N.prototype.write = function (D, G, W) { var X, Q = this._writableState, K = !1, F = !Q.objectMode && (X = D, s.isBuffer(X) || X instanceof u); return F && !s.isBuffer(D) && (D = function (Y) { return s.from(Y); }(D)), typeof G == "function" && (W = G, G = null), F ? G = "buffer" : G || (G = Q.defaultEncoding), typeof W != "function" && (W = x), Q.ending ? function (Y, $) { var y = new R; k(Y, y), r.nextTick($, y); }(this, W) : (F || function (Y, $, y, C) { var A; return y === null ? A = new v : typeof y == "string" || $.objectMode || (A = new l("chunk", ["string", "Buffer"], y)), !A || (k(Y, A), r.nextTick(C, A), !1); }(this, Q, D, W)) && (Q.pendingcb++, K = function (Y, $, y, C, A, U) { if (!y) {
                    var z = function (H, V, J) { return H.objectMode || H.decodeStrings === !1 || typeof V != "string" || (V = s.from(V, J)), V; }($, C, A);
                    C !== z && (y = !0, A = "buffer", C = z);
                } var w = $.objectMode ? 1 : C.length; $.length += w; var O = $.length < $.highWaterMark; if (O || ($.needDrain = !0), $.writing || $.corked) {
                    var q = $.lastBufferedRequest;
                    $.lastBufferedRequest = { chunk: C, encoding: A, isBuf: y, callback: U, next: null }, q ? q.next = $.lastBufferedRequest : $.bufferedRequest = $.lastBufferedRequest, $.bufferedRequestCount += 1;
                }
                else
                    S(Y, $, !1, w, C, A, U); return O; }(this, Q, F, D, G, W)), K; }, N.prototype.cork = function () { this._writableState.corked++; }, N.prototype.uncork = function () { var D = this._writableState; D.corked && (D.corked--, D.writing || D.corked || D.bufferProcessing || !D.bufferedRequest || B(this, D)); }, N.prototype.setDefaultEncoding = function (D) { if (typeof D == "string" && (D = D.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((D + "").toLowerCase()) > -1))
                    throw new _(D); return this._writableState.defaultEncoding = D, this; }, Object.defineProperty(N.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer(); } }), Object.defineProperty(N.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), N.prototype._write = function (D, G, W) { W(new p("_write()")); }, N.prototype._writev = null, N.prototype.end = function (D, G, W) { var X = this._writableState; return typeof D == "function" ? (W = D, D = null, G = null) : typeof G == "function" && (W = G, G = null), D != null && this.write(D, G), X.corked && (X.corked = 1, this.uncork()), X.ending || function (Q, K, F) { K.ending = !0, j(Q, K), F && (K.finished ? r.nextTick(F) : Q.once("finish", F)), K.ended = !0, Q.writable = !1; }(this, X, W), this; }, Object.defineProperty(N.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length; } }), Object.defineProperty(N.prototype, "destroyed", { enumerable: !1, get: function () { return this._writableState !== void 0 && this._writableState.destroyed; }, set: function (D) { this._writableState && (this._writableState.destroyed = D); } }), N.prototype.destroy = o.destroy, N.prototype._undestroy = o.undestroy, N.prototype._destroy = function (D, G) { G(D); }; }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(3), r = d.Buffer;
                function e(n, t) { for (var s in n)
                    t[s] = n[s]; }
                function c(n, t, s) { return r(n, t, s); }
                r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? E.exports = d : (e(d, m), m.Buffer = c), c.prototype = Object.create(r.prototype), e(r, c), c.from = function (n, t, s) { if (typeof n == "number")
                    throw new TypeError("Argument must not be a number"); return r(n, t, s); }, c.alloc = function (n, t, s) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); var u = r(n); return t !== void 0 ? typeof s == "string" ? u.fill(t, s) : u.fill(t) : u.fill(0), u; }, c.allocUnsafe = function (n) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); return r(n); }, c.allocUnsafeSlow = function (n) { if (typeof n != "number")
                    throw new TypeError("Argument must be a number"); return d.SlowBuffer(n); };
            }, function (E, m, f) {
                "use strict";
                E.exports = u;
                var d = f(72).codes, r = d.ERR_METHOD_NOT_IMPLEMENTED, e = d.ERR_MULTIPLE_CALLBACK, c = d.ERR_TRANSFORM_ALREADY_TRANSFORMING, n = d.ERR_TRANSFORM_WITH_LENGTH_0, t = f(73);
                function s(h, a) { var l = this._transformState; l.transforming = !1; var p = l.writecb; if (p === null)
                    return this.emit("error", new e); l.writechunk = null, l.writecb = null, a != null && this.push(a), p(h); var g = this._readableState; g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark); }
                function u(h) { if (!(this instanceof u))
                    return new u(h); t.call(this, h), this._transformState = { afterTransform: s.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", i); }
                function i() { var h = this; typeof this._flush != "function" || this._readableState.destroyed ? o(this, null, null) : this._flush(function (a, l) { o(h, a, l); }); }
                function o(h, a, l) { if (a)
                    return h.emit("error", a); if (l != null && h.push(l), h._writableState.length)
                    throw new n; if (h._transformState.transforming)
                    throw new c; return h.push(null); }
                f(15)(u, t), u.prototype.push = function (h, a) { return this._transformState.needTransform = !1, t.prototype.push.call(this, h, a); }, u.prototype._transform = function (h, a, l) { l(new r("_transform()")); }, u.prototype._write = function (h, a, l) { var p = this._transformState; if (p.writecb = l, p.writechunk = h, p.writeencoding = a, !p.transforming) {
                    var g = this._readableState;
                    (p.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
                } }, u.prototype._read = function (h) { var a = this._transformState; a.writechunk === null || a.transforming ? a.needTransform = !0 : (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)); }, u.prototype._destroy = function (h, a) { t.prototype._destroy.call(this, h, function (l) { a(l); }); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { var d, r = new Promise(function (e, c) { d = function (n, t) { n ? c(n) : e(t); }; }); return d.promise = r, d; };
            }, function (E, m, f) {
                "use strict";
                var d = f(190);
                function r(e) { if (typeof e != "object" || e === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = e, this._ended = !1, this._nexting = !1; }
                r.prototype.next = function (e) { var c = this; if (typeof e != "function")
                    throw new Error("next() requires a callback argument"); return c._ended ? (d(e, new Error("cannot call next() after end()")), c) : c._nexting ? (d(e, new Error("cannot call next() before previous next() has completed")), c) : (c._nexting = !0, c._next(function () { c._nexting = !1, e.apply(null, arguments); }), c); }, r.prototype._next = function (e) { d(e); }, r.prototype.seek = function (e) { if (this._ended)
                    throw new Error("cannot call seek() after end()"); if (this._nexting)
                    throw new Error("cannot call seek() before next() has completed"); e = this.db._serializeKey(e), this._seek(e); }, r.prototype._seek = function (e) { }, r.prototype.end = function (e) { if (typeof e != "function")
                    throw new Error("end() requires a callback argument"); if (this._ended)
                    return d(e, new Error("end() already called on iterator")); this._ended = !0, this._end(e); }, r.prototype._end = function (e) { d(e); }, r.prototype._nextTick = d, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                var d = f(190);
                function r(e) { if (typeof e != "object" || e === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = e, this._operations = [], this._written = !1; }
                r.prototype._checkWritten = function () { if (this._written)
                    throw new Error("write() already called on this batch"); }, r.prototype.put = function (e, c) { this._checkWritten(); var n = this.db._checkKey(e) || this.db._checkValue(c); if (n)
                    throw n; return e = this.db._serializeKey(e), c = this.db._serializeValue(c), this._put(e, c), this; }, r.prototype._put = function (e, c) { this._operations.push({ type: "put", key: e, value: c }); }, r.prototype.del = function (e) { this._checkWritten(); var c = this.db._checkKey(e); if (c)
                    throw c; return e = this.db._serializeKey(e), this._del(e), this; }, r.prototype._del = function (e) { this._operations.push({ type: "del", key: e }); }, r.prototype.clear = function () { return this._checkWritten(), this._clear(), this; }, r.prototype._clear = function () { this._operations = []; }, r.prototype.write = function (e, c) { if (this._checkWritten(), typeof e == "function" && (c = e), typeof c != "function")
                    throw new Error("write() requires a callback argument"); typeof e == "object" && e !== null || (e = {}), this._written = !0, this._write(e, c); }, r.prototype._write = function (e, c) { this.db._batch(this._operations, e, c); }, r.prototype._nextTick = d, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                m.AbstractLevelDOWN = f(794), m.AbstractIterator = f(318), m.AbstractChainedBatch = f(319);
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(e) { if (typeof e != "object" || e === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = e, this._ended = !1, this._nexting = !1; } r.prototype.next = function (e) { var c = this; if (typeof e != "function")
                    throw new Error("next() requires a callback argument"); return c._ended ? (d.nextTick(e, new Error("cannot call next() after end()")), c) : c._nexting ? (d.nextTick(e, new Error("cannot call next() before previous next() has completed")), c) : (c._nexting = !0, c._next(function () { c._nexting = !1, e.apply(null, arguments); }), c); }, r.prototype._next = function (e) { d.nextTick(e); }, r.prototype.seek = function (e) { if (this._ended)
                    throw new Error("cannot call seek() after end()"); if (this._nexting)
                    throw new Error("cannot call seek() before next() has completed"); e = this.db._serializeKey(e), this._seek(e); }, r.prototype._seek = function (e) { }, r.prototype.end = function (e) { if (typeof e != "function")
                    throw new Error("end() requires a callback argument"); if (this._ended)
                    return d.nextTick(e, new Error("end() already called on iterator")); this._ended = !0, this._end(e); }, r.prototype._end = function (e) { d.nextTick(e); }, E.exports = r; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                function d(r) { if (typeof r != "object" || r === null)
                    throw new TypeError("First argument must be an abstract-leveldown compliant store"); this.db = r, this._operations = [], this._written = !1; }
                d.prototype._checkWritten = function () { if (this._written)
                    throw new Error("write() already called on this batch"); }, d.prototype.put = function (r, e) { this._checkWritten(); var c = this.db._checkKey(r) || this.db._checkValue(e); if (c)
                    throw c; return r = this.db._serializeKey(r), e = this.db._serializeValue(e), this._put(r, e), this; }, d.prototype._put = function (r, e) { this._operations.push({ type: "put", key: r, value: e }); }, d.prototype.del = function (r) { this._checkWritten(); var e = this.db._checkKey(r); if (e)
                    throw e; return r = this.db._serializeKey(r), this._del(r), this; }, d.prototype._del = function (r) { this._operations.push({ type: "del", key: r }); }, d.prototype.clear = function () { return this._checkWritten(), this._clear(), this; }, d.prototype._clear = function () { this._operations = []; }, d.prototype.write = function (r, e) { if (this._checkWritten(), typeof r == "function" && (e = r), typeof e != "function")
                    throw new Error("write() requires a callback argument"); typeof r == "object" && r !== null || (r = {}), this._written = !0, this._write(r, e); }, d.prototype._write = function (r, e) { this.db._batch(this._operations, r, e); }, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(797); E.exports = function (e) { return e instanceof Uint8Array ? r(e) : e instanceof ArrayBuffer ? d.from(e) : d.from(String(e)); }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(799);
            }, function (E, m, f) {
                "use strict";
                const d = f(184), r = f(1)("ipfs:repo:lock"), e = {};
                m.lock = async (c) => { const n = c + "/repo.lock"; if (r("locking %s", n), e[n] === !0)
                    throw new d.LockExistsError("Lock already being held for file: " + n); return e[n] = !0, { async close() { e[n] && delete e[n]; } }; }, m.locked = async (c) => { const n = c + "/repo.lock"; return r("checking lock: " + n), Boolean(e[n]); };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(16), e = f(18);
                E.exports = { codec: e.RAW, defaultHashAlg: e.SHA2_256, resolver: { resolve: (c, n) => { if (n !== "/")
                            throw new Error("Only the root path / may be resolved"); return { value: c, remainderPath: "" }; }, tree: c => ({ done: !0 }) }, util: { deserialize: c => c, serialize: c => c, cid: async (c, n) => { const t = { cidVersion: 1, hashAlg: E.exports.defaultHashAlg }, s = Object.assign(t, n), u = await r(c, s.hashAlg), i = e.print[E.exports.codec]; return new d(s.cidVersion, i, u); } } };
            }, function (E, m, f) {
                "use strict";
                const d = f(164), r = f(24), e = f(0), c = f(817);
                E.exports = ({ options: n = {}, peerId: t, multiaddrs: s = [], repo: u, keychainConfig: i = {}, config: o = {} }) => { const { datastore: h, keys: a } = u, l = function ({ options: p, config: g, datastore: b, keys: I, keychainConfig: v, peerId: R, multiaddrs: _ }) { const k = { datastore: b, peerId: R, modules: {} }, x = { modules: { pubsub: (() => { const T = d(g, "Pubsub.Router") || "gossipsub"; if (!c[T])
                            throw e(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${T} router.`), "ERR_NOT_SUPPORTED"); return c[T]; })() }, config: { peerDiscovery: { mdns: { enabled: d(p, "config.Discovery.MDNS.Enabled", d(g, "Discovery.MDNS.Enabled", !0)) }, webRTCStar: { enabled: d(p, "config.Discovery.webRTCStar.Enabled", d(g, "Discovery.webRTCStar.Enabled", !0)) }, bootstrap: { list: d(p, "config.Bootstrap", d(g, "Bootstrap", [])) } }, relay: { enabled: d(p, "relay.enabled", d(g, "relay.enabled", !0)), hop: { enabled: d(p, "relay.hop.enabled", d(g, "relay.hop.enabled", !1)), active: d(p, "relay.hop.active", d(g, "relay.hop.active", !1)) } }, dht: { enabled: d(g, "Routing.Type", "none") !== "none", clientMode: d(g, "Routing.Type", "dht") !== "dhtserver", kBucketSize: d(p, "dht.kBucketSize", 20) }, pubsub: { enabled: d(p, "config.Pubsub.Enabled", d(g, "Pubsub.Enabled", !0)) } }, addresses: { listen: _, announce: d(p, "addresses.announce", d(g, "Addresses.Announce", [])) }, connectionManager: d(p, "connectionManager", { maxConnections: d(p, "config.Swarm.ConnMgr.HighWater", d(g, "Swarm.ConnMgr.HighWater")), minConnections: d(p, "config.Swarm.ConnMgr.LowWater", d(g, "Swarm.ConnMgr.LowWater")) }), keychain: { datastore: I, ...v } }, M = f(926); let N = d(p, "libp2p", {}); typeof N == "function" && (N = {}); const S = r(k, M(), x, N); return d(S, "config.peerDiscovery.bootstrap.list", []).length > 0 && S.modules.peerDiscovery.push(f(1086)), S; }({ options: n, config: o, datastore: h, keys: a, keychainConfig: i, peerId: t, multiaddrs: s }); return typeof n.libp2p == "function" ? n.libp2p({ libp2pOptions: l, options: n, config: o, datastore: h, peerId: t }) : new (f(850))(l); };
            }, function (E, m, f) {
                "use strict";
                var d = Object.create ? function (v, R, _, k) { k === void 0 && (k = _), Object.defineProperty(v, k, { enumerable: !0, get: function () { return R[_]; } }); } : function (v, R, _, k) { k === void 0 && (k = _), v[k] = R[_]; }, r = Object.create ? function (v, R) { Object.defineProperty(v, "default", { enumerable: !0, value: R }); } : function (v, R) { v.default = R; }, e = function (v) { if (v && v.__esModule)
                    return v; var R = {}; if (v != null)
                    for (var _ in v)
                        _ !== "default" && Object.hasOwnProperty.call(v, _) && d(R, v, _); return r(R, v), R; }, c = function (v, R, _, k) { return new (_ || (_ = Promise))(function (x, M) { function N(B) { try {
                    T(k.next(B));
                }
                catch (P) {
                    M(P);
                } } function S(B) { try {
                    T(k.throw(B));
                }
                catch (P) {
                    M(P);
                } } function T(B) { var P; B.done ? x(B.value) : (P = B.value, P instanceof _ ? P : new _(function (L) { L(P); })).then(N, S); } T((k = k.apply(v, R || [])).next()); }); };
                const n = e(f(818)), t = f(831), s = f(836), u = e(f(75)), i = f(838), o = f(329), h = f(74), a = f(839), l = f(846), p = f(847), g = f(7), b = f(193);
                class I extends n.default {
                    constructor(R, _ = {}) { const k = [u.GossipsubIDv11, u.GossipsubIDv10], x = Object.assign(Object.assign({ gossipIncoming: !0, fallbackToFloodsub: !0, floodPublish: !0, doPX: !1, directPeers: [], D: u.GossipsubD, Dlo: u.GossipsubDlo, Dhi: u.GossipsubDhi, Dscore: u.GossipsubDscore, Dout: u.GossipsubDout, Dlazy: u.GossipsubDlazy }, _), { scoreParams: a.createPeerScoreParams(_.scoreParams), scoreThresholds: a.createPeerScoreThresholds(_.scoreThresholds) }); x.fallbackToFloodsub && k.push(u.FloodsubID), super(Object.assign({ debugName: "libp2p:gossipsub", multicodecs: k, libp2p: R }, x)), this._options = x, this.direct = new Set(x.directPeers.map(M => M.id.toB58String())), x.directPeers.forEach(M => { R.peerStore.addressBook.add(M.id, M.addrs); }), this.seenCache = new p, this.mesh = new Map, this.fanout = new Map, this.lastpub = new Map, this.gossip = new Map, this.control = new Map, this.peerhave = new Map, this.iasked = new Map, this.backoff = new Map, this.outbound = new Map, this.messageCache = _.messageCache || new t.MessageCache(u.GossipsubHistoryGossip, u.GossipsubHistoryLength, this.getMsgId.bind(this)), this.heartbeat = new i.Heartbeat(this), this.heartbeatTicks = 0, this.gossipTracer = new l.IWantTracer(this.getMsgId.bind(this)), this._libp2p = R, this.score = new a.PeerScore(this._options.scoreParams, R.connectionManager, this.getMsgId.bind(this)); }
                    _decodeRpc(R) { return s.RPCCodec.decode(R); }
                    _encodeRpc(R) { return s.RPCCodec.encode(R); }
                    _addPeer(R, _) { const k = super._addPeer(R, _); this.score.addPeer(R.toB58String()); let x = !1; for (const M of this._libp2p.connectionManager.getAll(R))
                        if (M.stat.direction === "outbound" && Array.from(M.registry.values()).some(N => _ === N.protocol)) {
                            x = !0;
                            break;
                        } return this.outbound.set(k.id.toB58String(), x), k; }
                    _removePeer(R) { const _ = super._removePeer(R), k = R.toB58String(); for (const x of this.mesh.values())
                        x.delete(k); for (const x of this.fanout.values())
                        x.delete(k); return this.gossip.delete(k), this.control.delete(k), this.outbound.delete(k), this.score.removePeer(k), _; }
                    _processRpc(R, _, k) { return !!super._processRpc(R, _, k) && (k.control && this._processRpcControlMessage(R, k.control), !0); }
                    _processRpcControlMessage(R, _) { if (!_)
                        return; const k = this._handleIHave(R, _.ihave), x = this._handleIWant(R, _.iwant), M = this._handleGraft(R, _.graft); if (this._handlePrune(R, _.prune), !k.length && !x.length && !M.length)
                        return; const N = h.createGossipRpc(x, { iwant: k, prune: M }); this._sendRpc(R, N); }
                    _processRpcMessage(R) { const _ = Object.create(null, { _processRpcMessage: { get: () => super._processRpcMessage } }); return c(this, void 0, void 0, function* () { const k = this.getMsgId(R), x = h.messageIdToString(k); this.seenCache.has(x) ? this.score.duplicateMessage(R) : (this.seenCache.put(x), this.score.validateMessage(R), yield _._processRpcMessage.call(this, R)); }); }
                    _acceptFrom(R) { return this.direct.has(R) || this.score.score(R) >= this._options.scoreThresholds.graylistThreshold; }
                    validate(R) { const _ = Object.create(null, { validate: { get: () => super.validate } }); return c(this, void 0, void 0, function* () { try {
                        yield _.validate.call(this, R);
                    }
                    catch (k) {
                        throw this.score.rejectMessage(R, k.code), this.gossipTracer.rejectMessage(R, k.code), k;
                    } }); }
                    _handleIHave(R, _) { if (!_.length)
                        return []; const k = this.score.score(R); if (k < this._options.scoreThresholds.gossipThreshold)
                        return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", R, k), []; const x = (this.peerhave.get(R) || 0) + 1; if (this.peerhave.set(R, x), x > u.GossipsubMaxIHaveMessages)
                        return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", R, x), []; const M = this.iasked.get(R) || 0; if (M >= u.GossipsubMaxIHaveLength)
                        return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", R, M), []; const N = new Map; if (_.forEach(({ topicID: B, messageIDs: P }) => { B && this.mesh.has(B) && P.forEach(L => { const j = h.messageIdToString(L); this.seenCache.has(j) || N.set(j, L); }); }), !N.size)
                        return []; let S = N.size; S + M > u.GossipsubMaxIHaveLength && (S = u.GossipsubMaxIHaveLength - M), this.log("IHAVE: Asking for %d out of %d messages from %s", S, N.size, R); let T = Array.from(N.values()); return h.shuffle(T), T = T.slice(0, S), this.iasked.set(R, M + S), this.gossipTracer.addPromise(R, T), [{ messageIDs: T }]; }
                    _handleIWant(R, _) { if (!_.length)
                        return []; const k = this.score.score(R); if (k < this._options.scoreThresholds.gossipThreshold)
                        return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", R, k), []; const x = new Map; return _.forEach(({ messageIDs: M }) => { M.forEach(N => { const [S, T] = this.messageCache.getForPeer(N, R); S && (T > u.GossipsubGossipRetransmission ? this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", R, N) : x.set(h.messageIdToString(N), S)); }); }), x.size ? (this.log("IWANT: Sending %d messages to %s", x.size, R), Array.from(x.values()).map(n.utils.normalizeOutRpcMessage)) : []; }
                    _handleGraft(R, _) { const k = [], x = this.score.score(R), M = this._now(); let N = this._options.doPX; return _.forEach(({ topicID: S }) => { var T; if (!S)
                        return; const B = this.mesh.get(S); if (!B)
                        return void (N = !1); if (B.has(R))
                        return; if (this.direct.has(R))
                        return this.log("GRAFT: ignoring request from direct peer %s", R), k.push(S), void (N = !1); const P = (T = this.backoff.get(S)) === null || T === void 0 ? void 0 : T.get(R); if (typeof P == "number" && M < P) {
                        this.log("GRAFT: ignoring backed off peer %s", R), this.score.addPenalty(R, 1), N = !1;
                        const L = P + u.GossipsubGraftFloodThreshold - u.GossipsubPruneBackoff;
                        return M < L && this.score.addPenalty(R, 1), this._addBackoff(R, S), void k.push(S);
                    } return x < 0 ? (this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", R, x, S), k.push(S), N = !1, void this._addBackoff(R, S)) : B.size >= this._options.Dhi && !this.outbound.get(R) ? (k.push(S), void this._addBackoff(R, S)) : (this.log("GRAFT: Add mesh link from %s in %s", R, S), this.score.graft(R, S), void B.add(R)); }), k.length ? k.map(S => this._makePrune(R, S, N)) : []; }
                    _handlePrune(R, _) { const k = this.score.score(R); _.forEach(({ topicID: x, backoff: M, peers: N }) => { if (!x)
                        return; const S = this.mesh.get(x); if (S && (this.log("PRUNE: Remove mesh link to %s in %s", R, x), this.score.prune(R, x), S.delete(R), typeof M == "number" && M > 0 ? this._doAddBackoff(R, x, 1e3 * M) : this._addBackoff(R, x), N && N.length)) {
                        if (k < this._options.scoreThresholds.acceptPXThreshold)
                            return void this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", R, k, x);
                        this._pxConnect(N);
                    } }); }
                    _addBackoff(R, _) { this._doAddBackoff(R, _, u.GossipsubPruneBackoff); }
                    _doAddBackoff(R, _, k) { let x = this.backoff.get(_); x || (x = new Map, this.backoff.set(_, x)); const M = this._now() + k; (x.get(R) || 0) < M && x.set(R, M); }
                    _applyIwantPenalties() { this.gossipTracer.getBrokenPromises().forEach((R, _) => { this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", _, R), this.score.addPenalty(_, R); }); }
                    _clearBackoff() { if (this.heartbeatTicks % u.GossipsubPruneBackoffTicks != 0)
                        return; const R = this._now(); this.backoff.forEach((_, k) => { _.forEach((x, M) => { x < R && _.delete(M); }), _.size === 0 && this.backoff.delete(k); }); }
                    _directConnect() { if (this.heartbeatTicks % u.GossipsubDirectConnectTicks != 0)
                        return; const R = []; this.direct.forEach(_ => { const k = this.peers.get(_); k && k.isWritable || R.push(_); }), R.length && R.forEach(_ => { this._connect(_); }); }
                    _pxConnect(R) { return c(this, void 0, void 0, function* () { R.length > u.GossipsubPrunePeers && (h.shuffle(R), R = R.slice(0, u.GossipsubPrunePeers)); const _ = []; yield Promise.all(R.map(k => c(this, void 0, void 0, function* () { if (!k.peerID)
                        return; const x = g.createFromBytes(k.peerID).toB58String(); if (!this.peers.has(x))
                        if (k.signedPeerRecord)
                            try {
                                const M = yield b.openAndCertify(k.signedPeerRecord, "libp2p-peer-record"), N = M.peerId.toB58String();
                                if (x !== N)
                                    return void this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s", N, x);
                                if (!this._libp2p.peerStore.addressBook.consumePeerRecord(M))
                                    return void this.log("bogus peer record obtained through px: could not add peer record to address book");
                                _.push(x);
                            }
                            catch (M) {
                                this.log("bogus peer record obtained through px: invalid signature or not a peer record");
                            }
                        else
                            _.push(x); }))), _.length && _.forEach(k => this._connect(k)); }); }
                    start() { super.start(), this.heartbeat.start(), this.score.start(), this._directPeerInitial = setTimeout(() => { this.direct.forEach(R => { this._connect(R); }); }, u.GossipsubDirectConnectInitialDelay); }
                    stop() { super.stop(), this.heartbeat.stop(), this.score.stop(), this.mesh = new Map, this.fanout = new Map, this.lastpub = new Map, this.gossip = new Map, this.control = new Map, this.peerhave = new Map, this.iasked = new Map, this.backoff = new Map, this.outbound = new Map, this.gossipTracer.clear(), clearTimeout(this._directPeerInitial); }
                    _connect(R) { this.log("Initiating connection with %s", R), this._libp2p.dialProtocol(g.createFromB58String(R), this.multicodecs); }
                    subscribe(R) { super.subscribe(R), this.join(R); }
                    unsubscribe(R) { super.unsubscribe(R), this.leave(R); }
                    join(R) { if (!this.started)
                        throw new Error("Gossipsub has not started"); this.log("JOIN %s", R); const _ = this.fanout.get(R); if (_)
                        _.forEach(k => { this.score.score(k) < 0 && _.delete(k); }), _.size < this._options.D && o.getGossipPeers(this, R, this._options.D - _.size, k => !_.has(k) && !this.direct.has(k) && this.score.score(k) >= 0).forEach(k => _.add(k)), this.mesh.set(R, _), this.fanout.delete(R), this.lastpub.delete(R);
                    else {
                        const k = o.getGossipPeers(this, R, this._options.D, x => !this.direct.has(x) && this.score.score(x) >= 0);
                        this.mesh.set(R, k);
                    } this.mesh.get(R).forEach(k => { this.log("JOIN: Add mesh link to %s in %s", k, R), this._sendGraft(k, R); }); }
                    leave(R) { if (!this.started)
                        throw new Error("Gossipsub has not started"); this.log("LEAVE %s", R); const _ = this.mesh.get(R); _ && (_.forEach(k => { this.log("LEAVE: Remove mesh link to %s in %s", k, R), this._sendPrune(k, R); }), this.mesh.delete(R)); }
                    _publish(R) { return c(this, void 0, void 0, function* () { R.receivedFrom !== this.peerId.toB58String() && (this.score.deliverMessage(R), this.gossipTracer.deliverMessage(R)); const _ = this.getMsgId(R), k = h.messageIdToString(_); this.seenCache.put(k), this.messageCache.put(R); const x = new Set; R.topicIDs.forEach(N => { const S = this.topics.get(N); if (S)
                        if (this._options.floodPublish && R.from === this.peerId.toB58String())
                            S.forEach(T => { (this.direct.has(T) || this.score.score(T) >= this._options.scoreThresholds.publishThreshold) && x.add(T); });
                        else {
                            this.direct.forEach(B => { x.add(B); }), S.forEach(B => { const P = this.score.score(B), L = this.peers.get(B); L && L.protocol === u.FloodsubID && P >= this._options.scoreThresholds.publishThreshold && x.add(B); });
                            let T = this.mesh.get(N);
                            if (!T || !T.size) {
                                if (T = this.fanout.get(N), !T) {
                                    const B = o.getGossipPeers(this, N, this._options.D, P => this.score.score(P) >= this._options.scoreThresholds.publishThreshold);
                                    B.size > 0 ? (T = B, this.fanout.set(N, B)) : T = new Set;
                                }
                                this.lastpub.set(N, this._now());
                            }
                            T.forEach(B => { x.add(B); });
                        } }); const M = h.createGossipRpc([n.utils.normalizeOutRpcMessage(R)]); x.forEach(N => { N !== R.from && this._sendRpc(N, M); }); }); }
                    _sendGraft(R, _) { const k = [{ topicID: _ }], x = h.createGossipRpc([], { graft: k }); this._sendRpc(R, x); }
                    _sendPrune(R, _) { const k = [this._makePrune(R, _, this._options.doPX)], x = h.createGossipRpc([], { prune: k }); this._sendRpc(R, x); }
                    _sendRpc(R, _) { const k = this.peers.get(R); if (!k || !k.isWritable)
                        return; const x = this.control.get(R); x && (this._piggybackControl(R, _, x), this.control.delete(R)); const M = this.gossip.get(R); M && (this._piggybackGossip(R, _, M), this.gossip.delete(R)), k.write(s.RPCCodec.encode(_)); }
                    _piggybackControl(R, _, k) { const x = (k.graft || []).filter(({ topicID: N }) => (N && this.mesh.get(N) || new Set).has(R)), M = (k.prune || []).filter(({ topicID: N }) => !(N && this.mesh.get(N) || new Set).has(R)); (x.length || M.length) && (_.control ? (_.control.graft = _.control.graft.concat(x), _.control.prune = _.control.prune.concat(M)) : _.control = { ihave: [], iwant: [], graft: x, prune: M }); }
                    _piggybackGossip(R, _, k) { _.control || (_.control = { ihave: [], iwant: [], graft: [], prune: [] }), _.control.ihave = k; }
                    _sendGraftPrune(R, _, k) { const x = this._options.doPX; for (const [M, N] of R) {
                        const S = N.map(L => ({ topicID: L }));
                        let T = [];
                        const B = _.get(M);
                        B && (T = B.map(L => this._makePrune(M, L, x && !k.get(M))), _.delete(M));
                        const P = h.createGossipRpc([], { graft: S, prune: T });
                        this._sendRpc(M, P);
                    } for (const [M, N] of _) {
                        const S = N.map(B => this._makePrune(M, B, x && !k.get(M))), T = h.createGossipRpc([], { prune: S });
                        this._sendRpc(M, T);
                    } }
                    _emitGossip(R, _) { const k = this.messageCache.getGossipIDs(R); if (!k.length)
                        return; h.shuffle(k), k.length > u.GossipsubMaxIHaveLength && this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", k.length); const x = [], M = this.topics.get(R); if (!M)
                        return; M.forEach(T => { const B = this.peers.get(T); B && !_.has(T) && !this.direct.has(T) && h.hasGossipProtocol(B.protocol) && this.score.score(T) >= this._options.scoreThresholds.gossipThreshold && x.push(T); }); let N = this._options.Dlazy; const S = u.GossipsubGossipFactor * x.length; S > N && (N = S), N > x.length ? N = x.length : h.shuffle(x), x.slice(0, N).forEach(T => { let B = k; k.length > u.GossipsubMaxIHaveLength && (B = h.shuffle(B.slice()).slice(0, u.GossipsubMaxIHaveLength)), this._pushGossip(T, { topicID: R, messageIDs: B }); }); }
                    _flush() { for (const [R, _] of this.gossip.entries()) {
                        this.gossip.delete(R);
                        const k = h.createGossipRpc([], { ihave: _ });
                        this._sendRpc(R, k);
                    } for (const [R, _] of this.control.entries()) {
                        this.control.delete(R);
                        const k = h.createGossipRpc([], { graft: _.graft, prune: _.prune });
                        this._sendRpc(R, k);
                    } }
                    _pushGossip(R, _) { this.log("Add gossip to %s", R); const k = this.gossip.get(R) || []; this.gossip.set(R, k.concat(_)); }
                    _now() { return Date.now(); }
                    _makePrune(R, _, k) { if (this.peers.get(R).protocol === u.GossipsubIDv10)
                        return { topicID: _, peers: [] }; const x = u.GossipsubPruneBackoff / 1e3, M = []; return k && o.getGossipPeers(this, _, u.GossipsubPrunePeers, N => N !== R && this.score.score(N) >= 0).forEach(N => { const S = g.createFromB58String(N); M.push({ peerID: S.toBytes(), signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(S) }); }), { topicID: _, peers: M, backoff: x }; }
                }
                I.multicodec = u.GossipsubIDv11, E.exports = I;
            }, function (E, m, f) {
                "use strict";
                const d = f(21), r = d(f(821)), e = r.RPC, c = d(f(822));
                (m = E.exports).rpc = r, m.td = c, m.RPC = e, m.Message = e.Message, m.SubOpts = e.SubOpts;
            }, function (E, m, f) {
                "use strict";
                const d = f(19), { Buffer: r } = f(3), e = (c, n, t) => { const s = d.encode(c, n, t); return e.bytes = d.encode.bytes, n || r.from(s); };
                E.exports = e;
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(19), e = c => { const n = r.decode(d.isBuffer(c) ? c : (t = c, new Proxy({}, { get: (s, u) => u[0] === "l" ? t[u] : t.get(parseInt(u)) }))); var t; return e.bytes = r.decode.bytes, n; };
                E.exports = e;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.getGossipPeers = void 0;
                const d = f(74);
                m.getGossipPeers = function (r, e, c, n = () => !0) { const t = r.topics.get(e); if (!t)
                    return new Set; let s = []; return t.forEach(u => { const i = r.peers.get(u); i && d.hasGossipProtocol(i.protocol) && n(u) && s.push(u); }), s = d.shuffle(s), c > 0 && s.length > c && (s = s.slice(0, c)), new Set(s); };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.validateTopicScoreParams = m.validatePeerScoreParams = m.createTopicScoreParams = m.createPeerScoreParams = m.defaultTopicScoreParams = m.defaultPeerScoreParams = void 0;
                const d = f(331), r = f(0);
                function e(n = {}) { return Object.assign(Object.assign({}, m.defaultTopicScoreParams), n); }
                function c(n) { if (n.topicWeight < 0)
                    throw r(new Error("invalid topic weight; must be >= 0"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.timeInMeshQuantum === 0)
                    throw r(new Error("invalid TimeInMeshQuantum; must be non zero"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.timeInMeshWeight < 0)
                    throw r(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.timeInMeshWeight !== 0 && n.timeInMeshQuantum <= 0)
                    throw r(new Error("invalid TimeInMeshQuantum; must be positive"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.timeInMeshWeight !== 0 && n.timeInMeshCap <= 0)
                    throw r(new Error("invalid TimeInMeshCap; must be positive"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.firstMessageDeliveriesWeight < 0)
                    throw r(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.firstMessageDeliveriesWeight !== 0 && (n.firstMessageDeliveriesDecay <= 0 || n.firstMessageDeliveriesDecay >= 1))
                    throw r(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.firstMessageDeliveriesWeight !== 0 && n.firstMessageDeliveriesCap <= 0)
                    throw r(new Error("invalid FirstMessageDeliveriesCap; must be positive"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWeight > 0)
                    throw r(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWeight !== 0 && (n.meshMessageDeliveriesDecay <= 0 || n.meshMessageDeliveriesDecay >= 1))
                    throw r(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesCap <= 0)
                    throw r(new Error("invalid MeshMessageDeliveriesCap; must be positive"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesThreshold <= 0)
                    throw r(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWindow < 0)
                    throw r(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshMessageDeliveriesWeight !== 0 && n.meshMessageDeliveriesActivation < 1e3)
                    throw r(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshFailurePenaltyWeight > 0)
                    throw r(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.meshFailurePenaltyWeight !== 0 && (n.meshFailurePenaltyDecay <= 0 || n.meshFailurePenaltyDecay >= 1))
                    throw r(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.invalidMessageDeliveriesWeight > 0)
                    throw r(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.invalidMessageDeliveriesDecay <= 0 || n.invalidMessageDeliveriesDecay >= 1)
                    throw r(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); }
                m.defaultPeerScoreParams = { topics: {}, topicScoreCap: 10, appSpecificScore: () => 0, appSpecificWeight: 10, IPColocationFactorWeight: -5, IPColocationFactorThreshold: 10, IPColocationFactorWhitelist: new Set, behaviourPenaltyWeight: -10, behaviourPenaltyDecay: .2, decayInterval: 1e3, decayToZero: .1, retainScore: 36e5 }, m.defaultTopicScoreParams = { topicWeight: .5, timeInMeshWeight: 1, timeInMeshQuantum: 1, timeInMeshCap: 3600, firstMessageDeliveriesWeight: 1, firstMessageDeliveriesDecay: .5, firstMessageDeliveriesCap: 2e3, meshMessageDeliveriesWeight: -1, meshMessageDeliveriesDecay: .5, meshMessageDeliveriesCap: 100, meshMessageDeliveriesThreshold: 20, meshMessageDeliveriesWindow: 10, meshMessageDeliveriesActivation: 5e3, meshFailurePenaltyWeight: -1, meshFailurePenaltyDecay: .5, invalidMessageDeliveriesWeight: -1, invalidMessageDeliveriesDecay: .3 }, m.createPeerScoreParams = function (n = {}) { return Object.assign(Object.assign(Object.assign({}, m.defaultPeerScoreParams), n), { topics: n.topics ? Object.entries(n.topics).reduce((t, [s, u]) => (t[s] = e(u), t), {}) : {} }); }, m.createTopicScoreParams = e, m.validatePeerScoreParams = function (n) { for (const [t, s] of Object.entries(n.topics))
                    try {
                        c(s);
                    }
                    catch (u) {
                        throw r(new Error(`invalid score parameters for topic ${t}: ${u.message}`), d.ERR_INVALID_PEER_SCORE_PARAMS);
                    } if (n.topicScoreCap < 0)
                    throw r(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.appSpecificScore === null || n.appSpecificScore === void 0)
                    throw r(new Error("missing application specific score function"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.IPColocationFactorWeight > 0)
                    throw r(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.IPColocationFactorWeight !== 0 && n.IPColocationFactorThreshold < 1)
                    throw r(new Error("invalid IPColocationFactorThreshold; must be at least 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.behaviourPenaltyWeight > 0)
                    throw r(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.behaviourPenaltyWeight !== 0 && (n.behaviourPenaltyDecay <= 0 || n.behaviourPenaltyDecay >= 1))
                    throw r(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.decayInterval < 1e3)
                    throw r(new Error("invalid DecayInterval; must be at least 1s"), d.ERR_INVALID_PEER_SCORE_PARAMS); if (n.decayToZero <= 0 || n.decayToZero >= 1)
                    throw r(new Error("invalid DecayToZero; must be between 0 and 1"), d.ERR_INVALID_PEER_SCORE_PARAMS); }, m.validateTopicScoreParams = c;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.ERR_INVALID_PEER_SCORE_THRESHOLDS = m.ERR_INVALID_PEER_SCORE_PARAMS = void 0, m.ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS", m.ERR_INVALID_PEER_SCORE_THRESHOLDS = "ERR_INVALID_PEER_SCORE_THRESHOLDS";
            }, function (E, m, f) {
                "use strict";
                const d = f(853), r = f(854);
                class e extends Error {
                    constructor(n) {
                        if (!Array.isArray(n))
                            throw new TypeError("Expected input to be an Array, got " + typeof n);
                        let t = (n = [...n].map(s => s instanceof Error ? s : s !== null && typeof s == "object" ? Object.assign(new Error(s.message), s) : new Error(s))).map(s => typeof s.stack == "string" ? r(s.stack).replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "") : String(s)).join(`
`);
                        t = `
` + d(t, 4), super(t), this.name = "AggregateError", Object.defineProperty(this, "_errors", { value: n });
                    }
                    *[Symbol.iterator]() { for (const n of this._errors)
                        yield n; }
                }
                E.exports = e;
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(c) { super(c || "Promise was canceled"), this.name = "CancelError"; }
                    get isCanceled() { return !0; }
                }
                class r {
                    static fn(c) { return (...n) => new r((t, s, u) => { n.push(u), c(...n).then(t, s); }); }
                    constructor(c) { this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((n, t) => { this._reject = t; const s = u => { if (!this._isPending)
                        throw new Error("The `onCancel` handler was attached after the promise settled."); this._cancelHandlers.push(u); }; return Object.defineProperties(s, { shouldReject: { get: () => this._rejectOnCancel, set: u => { this._rejectOnCancel = u; } } }), c(u => { this._isPending = !1, n(u); }, u => { this._isPending = !1, t(u); }, s); }); }
                    then(c, n) { return this._promise.then(c, n); }
                    catch(c) { return this._promise.catch(c); }
                    finally(c) { return this._promise.finally(c); }
                    cancel(c) { if (this._isPending && !this._isCanceled) {
                        if (this._cancelHandlers.length > 0)
                            try {
                                for (const n of this._cancelHandlers)
                                    n();
                            }
                            catch (n) {
                                this._reject(n);
                            }
                        this._isCanceled = !0, this._rejectOnCancel && this._reject(new d(c));
                    } }
                    get isCanceled() { return this._isCanceled; }
                }
                Object.setPrototypeOf(r.prototype, Promise.prototype), E.exports = r, E.exports.CancelError = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(13), e = f(0), { codes: c } = f(28);
                E.exports = function (n) { let t; if (typeof n == "string" && (n = r(n)), r.isMultiaddr(n)) {
                    t = n;
                    try {
                        n = d.createFromB58String(n.getPeerId());
                    }
                    catch (s) {
                        throw e(new Error(n + " is not a valid peer type"), c.ERR_INVALID_MULTIADDR);
                    }
                } return { id: n, multiaddrs: t ? [t] : void 0 }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(865).version;
                E.exports.PROTOCOL_VERSION = "ipfs/0.1.0", E.exports.AGENT_VERSION = "js-libp2p/" + d, E.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0", E.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
            }, function (E, m, f) {
                "use strict";
                const d = f(866), { codes: r } = f(28), e = f(0), c = f(1), n = c("libp2p:transports");
                n.error = c("libp2p:transports:error");
                class t {
                    constructor({ libp2p: i, upgrader: o, faultTolerance: h = s.FATAL_ALL }) { this.libp2p = i, this.upgrader = o, this._transports = new Map, this._listeners = new Map, this._listenerOptions = new Map, this.faultTolerance = h; }
                    add(i, o, h = {}) { if (n("adding %s", i), !i)
                        throw e(new Error(`Transport must have a valid key, was given '${i}'`), r.ERR_INVALID_KEY); if (this._transports.has(i))
                        throw e(new Error("There is already a transport with this key"), r.ERR_DUPLICATE_TRANSPORT); const a = new o({ ...h, libp2p: this.libp2p, upgrader: this.upgrader }); this._transports.set(i, a), this._listenerOptions.set(i, h.listenerOptions || {}), this._listeners.has(i) || this._listeners.set(i, []); }
                    async close() { const i = []; for (const [o, h] of this._listeners)
                        for (n("closing listeners for %s", o); h.length;) {
                            const a = h.pop();
                            i.push(a.close());
                        } await Promise.all(i), n("all listeners closed"); for (const o of this._listeners.keys())
                        this._listeners.set(o, []); }
                    async dial(i, o) { const h = this.transportForMultiaddr(i); if (!h)
                        throw e(new Error("No transport available for address " + String(i)), r.ERR_TRANSPORT_UNAVAILABLE); try {
                        return await h.dial(i, o);
                    }
                    catch (a) {
                        throw a.code || (a.code = r.ERR_TRANSPORT_DIAL_FAILED), a;
                    } }
                    getAddrs() { let i = []; for (const o of this._listeners.values())
                        for (const h of o)
                            i = [...i, ...h.getAddrs()]; return i; }
                    getTransports() { return this._transports.values(); }
                    transportForMultiaddr(i) { for (const o of this._transports.values())
                        if (o.filter([i]).length)
                            return o; return null; }
                    async listen() { const i = this.libp2p.addressManager.getListenAddrs(); if (i.length === 0)
                        return void n("no addresses were provided for listening, this node is dial only"); const o = []; for (const [h, a] of this._transports.entries()) {
                        const l = a.filter(i), p = [];
                        for (const g of l) {
                            n("creating listener for %s on %s", h, g);
                            const b = a.createListener(this._listenerOptions.get(h), this.onConnection);
                            this._listeners.get(h).push(b), p.push(b.listen(g));
                        }
                        if (p.length === 0) {
                            o.push(h);
                            continue;
                        }
                        if (!(await d(p)).find(g => g.isFulfilled === !0))
                            throw e(new Error(`Transport (${h}) could not listen on any available address`), r.ERR_NO_VALID_ADDRESSES);
                    } if (o.length === this._transports.size) {
                        const h = `no valid addresses were provided for transports [${o}]`;
                        if (this.faultTolerance === s.FATAL_ALL)
                            throw e(new Error(h), r.ERR_NO_VALID_ADDRESSES);
                        n("libp2p in dial mode only: " + h);
                    } }
                    async remove(i) { if (n("removing %s", i), this._listeners.has(i))
                        for (const o of this._listeners.get(i))
                            await o.close(); this._transports.delete(i), this._listeners.delete(i); }
                    async removeAll() { const i = []; for (const o of this._transports.keys())
                        i.push(this.remove(o)); await Promise.all(i); }
                }
                const s = { FATAL_ALL: 0, NO_FATAL: 1 };
                t.FaultTolerance = s, E.exports = t;
            }, function (E, m, f) {
                "use strict";
                const d = f(13), { CircuitRelay: r } = f(98);
                function e(c, n) { c.write({ type: r.Type.STATUS, code: n }); }
                E.exports = { validateAddrs: function (c, n) { try {
                        c.dstPeer.addrs.forEach(t => d(t));
                    }
                    catch (t) {
                        throw e(n, c.type === r.Type.HOP ? r.Status.HOP_DST_MULTIADDR_INVALID : r.Status.STOP_DST_MULTIADDR_INVALID), t;
                    } try {
                        c.srcPeer.addrs.forEach(t => d(t));
                    }
                    catch (t) {
                        throw e(n, c.type === r.Type.HOP ? r.Status.HOP_SRC_MULTIADDR_INVALID : r.Status.STOP_SRC_MULTIADDR_INVALID), t;
                    } } };
            }, function (E, m, f) {
                "use strict";
                const d = f(34);
                E.exports = r => { const e = async function* () { let c = yield, n = new d; for await (const t of r)
                    if (c)
                        for (n.append(t); n.length >= c;) {
                            const s = n.shallowSlice(0, c);
                            if (n.consume(c), c = yield s, !c) {
                                n.length && (c = yield n, n = new d);
                                break;
                            }
                        }
                    else
                        c = yield n.append(t), n = new d; if (c)
                    throw Object.assign(new Error(`stream ended before ${c} bytes became available`), { code: "ERR_UNDER_READ", buffer: n }); }(); return e.next(), e; };
            }, function (E, m, f) {
                "use strict";
                const { CircuitRelay: d } = f(98), r = f(197), e = f(198), { validateAddrs: c } = f(337), n = f(1), t = n("libp2p:circuit:stop");
                t.error = n("libp2p:circuit:stop:error"), E.exports.handleStop = function ({ connection: s, request: u, streamHandler: i }) { try {
                    c(u, i);
                }
                catch (o) {
                    return t.error("invalid stop request via peer %s", s.remotePeer.toB58String(), o);
                } return t("stop request is valid"), i.write({ type: d.Type.STATUS, code: d.Status.SUCCESS }), i.rest(); }, E.exports.stop = async function ({ connection: s, request: u }) { const { stream: i } = await s.newStream([r.relay]); t("starting stop request to %s", s.remotePeer.toB58String()); const o = new e({ stream: i }); o.write(u); const h = await o.read(); if (h.code === d.Status.SUCCESS)
                    return t("stop request to %s was successful", s.remotePeer.toB58String()), o.rest(); t("stop request failed with code %d", h.code), o.close(); };
            }, function (E, m, f) {
                "use strict";
                const d = f(879);
                function r(e) { const c = new d; function n() { c.abort(); for (const t of e)
                    t && t.removeEventListener && t.removeEventListener("abort", n); } for (const t of e)
                    if (t && t.addEventListener) {
                        if (t.aborted) {
                            n();
                            break;
                        }
                        t.addEventListener("abort", n);
                    } return c.signal; }
                E.exports = r, E.exports.anySignal = r;
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(83), f(44), f(143), f(49), f(890), f(82), f(145), f(892), f(103), f(14);
                var r = d.asn1, e = E.exports = d.pki = d.pki || {}, c = e.oids, n = {};
                n.CN = c.commonName, n.commonName = "CN", n.C = c.countryName, n.countryName = "C", n.L = c.localityName, n.localityName = "L", n.ST = c.stateOrProvinceName, n.stateOrProvinceName = "ST", n.O = c.organizationName, n.organizationName = "O", n.OU = c.organizationalUnitName, n.organizationalUnitName = "OU", n.E = c.emailAddress, n.emailAddress = "E";
                var t = d.pki.rsa.publicKeyValidator, s = { name: "Certificate", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "Certificate.TBSCertificate", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "tbsCertificate", value: [{ name: "Certificate.TBSCertificate.version", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, constructed: !0, optional: !0, value: [{ name: "Certificate.TBSCertificate.version.integer", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "certVersion" }] }, { name: "Certificate.TBSCertificate.serialNumber", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "certSerialNumber" }, { name: "Certificate.TBSCertificate.signature", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "Certificate.TBSCertificate.signature.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "certinfoSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: r.Class.UNIVERSAL, optional: !0, captureAsn1: "certinfoSignatureParams" }] }, { name: "Certificate.TBSCertificate.issuer", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "certIssuer" }, { name: "Certificate.TBSCertificate.validity", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "Certificate.TBSCertificate.validity.notBefore (utc)", tagClass: r.Class.UNIVERSAL, type: r.Type.UTCTIME, constructed: !1, optional: !0, capture: "certValidity1UTCTime" }, { name: "Certificate.TBSCertificate.validity.notBefore (generalized)", tagClass: r.Class.UNIVERSAL, type: r.Type.GENERALIZEDTIME, constructed: !1, optional: !0, capture: "certValidity2GeneralizedTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (utc)", tagClass: r.Class.UNIVERSAL, type: r.Type.UTCTIME, constructed: !1, optional: !0, capture: "certValidity3UTCTime" }, { name: "Certificate.TBSCertificate.validity.notAfter (generalized)", tagClass: r.Class.UNIVERSAL, type: r.Type.GENERALIZEDTIME, constructed: !1, optional: !0, capture: "certValidity4GeneralizedTime" }] }, { name: "Certificate.TBSCertificate.subject", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "certSubject" }, t, { name: "Certificate.TBSCertificate.issuerUniqueID", tagClass: r.Class.CONTEXT_SPECIFIC, type: 1, constructed: !0, optional: !0, value: [{ name: "Certificate.TBSCertificate.issuerUniqueID.id", tagClass: r.Class.UNIVERSAL, type: r.Type.BITSTRING, constructed: !1, captureBitStringValue: "certIssuerUniqueId" }] }, { name: "Certificate.TBSCertificate.subjectUniqueID", tagClass: r.Class.CONTEXT_SPECIFIC, type: 2, constructed: !0, optional: !0, value: [{ name: "Certificate.TBSCertificate.subjectUniqueID.id", tagClass: r.Class.UNIVERSAL, type: r.Type.BITSTRING, constructed: !1, captureBitStringValue: "certSubjectUniqueId" }] }, { name: "Certificate.TBSCertificate.extensions", tagClass: r.Class.CONTEXT_SPECIFIC, type: 3, constructed: !0, captureAsn1: "certExtensions", optional: !0 }] }, { name: "Certificate.signatureAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "Certificate.signatureAlgorithm.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "certSignatureOid" }, { name: "Certificate.TBSCertificate.signature.parameters", tagClass: r.Class.UNIVERSAL, optional: !0, captureAsn1: "certSignatureParams" }] }, { name: "Certificate.signatureValue", tagClass: r.Class.UNIVERSAL, type: r.Type.BITSTRING, constructed: !1, captureBitStringValue: "certSignature" }] }, u = { name: "rsapss", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "rsapss.hashAlgorithm", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, constructed: !0, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier", tagClass: r.Class.UNIVERSAL, type: r.Class.SEQUENCE, constructed: !0, optional: !0, value: [{ name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "hashOid" }] }] }, { name: "rsapss.maskGenAlgorithm", tagClass: r.Class.CONTEXT_SPECIFIC, type: 1, constructed: !0, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier", tagClass: r.Class.UNIVERSAL, type: r.Class.SEQUENCE, constructed: !0, optional: !0, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "maskGenOid" }, { name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "maskGenHashOid" }] }] }] }, { name: "rsapss.saltLength", tagClass: r.Class.CONTEXT_SPECIFIC, type: 2, optional: !0, value: [{ name: "rsapss.saltLength.saltLength", tagClass: r.Class.UNIVERSAL, type: r.Class.INTEGER, constructed: !1, capture: "saltLength" }] }, { name: "rsapss.trailerField", tagClass: r.Class.CONTEXT_SPECIFIC, type: 3, optional: !0, value: [{ name: "rsapss.trailer.trailer", tagClass: r.Class.UNIVERSAL, type: r.Class.INTEGER, constructed: !1, capture: "trailer" }] }] }, i = { name: "CertificationRequestInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "certificationRequestInfo", value: [{ name: "CertificationRequestInfo.integer", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "certificationRequestInfoVersion" }, { name: "CertificationRequestInfo.subject", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "certificationRequestInfoSubject" }, t, { name: "CertificationRequestInfo.attributes", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, constructed: !0, optional: !0, capture: "certificationRequestInfoAttributes", value: [{ name: "CertificationRequestInfo.attributes", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "CertificationRequestInfo.attributes.type", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1 }, { name: "CertificationRequestInfo.attributes.value", tagClass: r.Class.UNIVERSAL, type: r.Type.SET, constructed: !0 }] }] }] }, o = { name: "CertificationRequest", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "csr", value: [i, { name: "CertificationRequest.signatureAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "CertificationRequest.signatureAlgorithm.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "csrSignatureOid" }, { name: "CertificationRequest.signatureAlgorithm.parameters", tagClass: r.Class.UNIVERSAL, optional: !0, captureAsn1: "csrSignatureParams" }] }, { name: "CertificationRequest.signature", tagClass: r.Class.UNIVERSAL, type: r.Type.BITSTRING, constructed: !1, captureBitStringValue: "csrSignature" }] };
                function h(k, x) { typeof x == "string" && (x = { shortName: x }); for (var M, N = null, S = 0; N === null && S < k.attributes.length; ++S)
                    M = k.attributes[S], (x.type && x.type === M.type || x.name && x.name === M.name || x.shortName && x.shortName === M.shortName) && (N = M); return N; }
                e.RDNAttributesAsArray = function (k, x) { for (var M, N, S, T = [], B = 0; B < k.value.length; ++B) {
                    M = k.value[B];
                    for (var P = 0; P < M.value.length; ++P)
                        S = {}, N = M.value[P], S.type = r.derToOid(N.value[0].value), S.value = N.value[1].value, S.valueTagClass = N.value[1].type, S.type in c && (S.name = c[S.type], S.name in n && (S.shortName = n[S.name])), x && (x.update(S.type), x.update(S.value)), T.push(S);
                } return T; }, e.CRIAttributesAsArray = function (k) { for (var x = [], M = 0; M < k.length; ++M)
                    for (var N = k[M], S = r.derToOid(N.value[0].value), T = N.value[1].value, B = 0; B < T.length; ++B) {
                        var P = {};
                        if (P.type = S, P.value = T[B].value, P.valueTagClass = T[B].type, P.type in c && (P.name = c[P.type], P.name in n && (P.shortName = n[P.name])), P.type === c.extensionRequest) {
                            P.extensions = [];
                            for (var L = 0; L < P.value.length; ++L)
                                P.extensions.push(e.certificateExtensionFromAsn1(P.value[L]));
                        }
                        x.push(P);
                    } return x; };
                var a = function (k, x, M) { var N = {}; if (k !== c["RSASSA-PSS"])
                    return N; M && (N = { hash: { algorithmOid: c.sha1 }, mgf: { algorithmOid: c.mgf1, hash: { algorithmOid: c.sha1 } }, saltLength: 20 }); var S = {}, T = []; if (!r.validate(x, u, S, T)) {
                    var B = new Error("Cannot read RSASSA-PSS parameter block.");
                    throw B.errors = T, B;
                } return S.hashOid !== void 0 && (N.hash = N.hash || {}, N.hash.algorithmOid = r.derToOid(S.hashOid)), S.maskGenOid !== void 0 && (N.mgf = N.mgf || {}, N.mgf.algorithmOid = r.derToOid(S.maskGenOid), N.mgf.hash = N.mgf.hash || {}, N.mgf.hash.algorithmOid = r.derToOid(S.maskGenHashOid)), S.saltLength !== void 0 && (N.saltLength = S.saltLength.charCodeAt(0)), N; };
                function l(k) { for (var x, M, N = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []), S = k.attributes, T = 0; T < S.length; ++T) {
                    var B = (x = S[T]).value, P = r.Type.PRINTABLESTRING;
                    "valueTagClass" in x && (P = x.valueTagClass) === r.Type.UTF8 && (B = d.util.encodeUtf8(B)), M = r.create(r.Class.UNIVERSAL, r.Type.SET, !0, [r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(x.type).getBytes()), r.create(r.Class.UNIVERSAL, P, !1, B)])]), N.value.push(M);
                } return N; }
                function p(k) { for (var x, M = 0; M < k.length; ++M) {
                    if ((x = k[M]).name === void 0 && (x.type && x.type in e.oids ? x.name = e.oids[x.type] : x.shortName && x.shortName in n && (x.name = e.oids[n[x.shortName]])), x.type === void 0) {
                        if (!x.name || !(x.name in e.oids))
                            throw (S = new Error("Attribute type not specified.")).attribute = x, S;
                        x.type = e.oids[x.name];
                    }
                    if (x.shortName === void 0 && x.name && x.name in n && (x.shortName = n[x.name]), x.type === c.extensionRequest && (x.valueConstructed = !0, x.valueTagClass = r.Type.SEQUENCE, !x.value && x.extensions)) {
                        x.value = [];
                        for (var N = 0; N < x.extensions.length; ++N)
                            x.value.push(e.certificateExtensionToAsn1(g(x.extensions[N])));
                    }
                    var S;
                    if (x.value === void 0)
                        throw (S = new Error("Attribute value not specified.")).attribute = x, S;
                } }
                function g(k, x) { if (x = x || {}, k.name === void 0 && k.id && k.id in e.oids && (k.name = e.oids[k.id]), k.id === void 0) {
                    if (!k.name || !(k.name in e.oids))
                        throw (F = new Error("Extension ID not specified.")).extension = k, F;
                    k.id = e.oids[k.name];
                } if (k.value !== void 0)
                    return k; if (k.name === "keyUsage") {
                    var M = 0, N = 0, S = 0;
                    k.digitalSignature && (N |= 128, M = 7), k.nonRepudiation && (N |= 64, M = 6), k.keyEncipherment && (N |= 32, M = 5), k.dataEncipherment && (N |= 16, M = 4), k.keyAgreement && (N |= 8, M = 3), k.keyCertSign && (N |= 4, M = 2), k.cRLSign && (N |= 2, M = 1), k.encipherOnly && (N |= 1, M = 0), k.decipherOnly && (S |= 128, M = 7);
                    var T = String.fromCharCode(M);
                    S !== 0 ? T += String.fromCharCode(N) + String.fromCharCode(S) : N !== 0 && (T += String.fromCharCode(N)), k.value = r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, T);
                }
                else if (k.name === "basicConstraints")
                    k.value = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []), k.cA && k.value.value.push(r.create(r.Class.UNIVERSAL, r.Type.BOOLEAN, !1, String.fromCharCode(255))), "pathLenConstraint" in k && k.value.value.push(r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(k.pathLenConstraint).getBytes()));
                else if (k.name === "extKeyUsage") {
                    k.value = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []);
                    var B = k.value.value;
                    for (var P in k)
                        k[P] === !0 && (P in c ? B.push(r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(c[P]).getBytes())) : P.indexOf(".") !== -1 && B.push(r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(P).getBytes())));
                }
                else if (k.name === "nsCertType")
                    M = 0, N = 0, k.client && (N |= 128, M = 7), k.server && (N |= 64, M = 6), k.email && (N |= 32, M = 5), k.objsign && (N |= 16, M = 4), k.reserved && (N |= 8, M = 3), k.sslCA && (N |= 4, M = 2), k.emailCA && (N |= 2, M = 1), k.objCA && (N |= 1, M = 0), T = String.fromCharCode(M), N !== 0 && (T += String.fromCharCode(N)), k.value = r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, T);
                else if (k.name === "subjectAltName" || k.name === "issuerAltName") {
                    k.value = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []);
                    for (var L = 0; L < k.altNames.length; ++L) {
                        if (T = (X = k.altNames[L]).value, X.type === 7 && X.ip) {
                            if ((T = d.util.bytesFromIP(X.ip)) === null)
                                throw (F = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = k, F;
                        }
                        else
                            X.type === 8 && (T = X.oid ? r.oidToDer(r.oidToDer(X.oid)) : r.oidToDer(T));
                        k.value.value.push(r.create(r.Class.CONTEXT_SPECIFIC, X.type, !1, T));
                    }
                }
                else if (k.name === "nsComment" && x.cert) {
                    if (!/^[\x00-\x7F]*$/.test(k.comment) || k.comment.length < 1 || k.comment.length > 128)
                        throw new Error('Invalid "nsComment" content.');
                    k.value = r.create(r.Class.UNIVERSAL, r.Type.IA5STRING, !1, k.comment);
                }
                else if (k.name === "subjectKeyIdentifier" && x.cert) {
                    var j = x.cert.generateSubjectKeyIdentifier();
                    k.subjectKeyIdentifier = j.toHex(), k.value = r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, j.getBytes());
                }
                else if (k.name === "authorityKeyIdentifier" && x.cert) {
                    if (k.value = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []), B = k.value.value, k.keyIdentifier) {
                        var D = k.keyIdentifier === !0 ? x.cert.generateSubjectKeyIdentifier().getBytes() : k.keyIdentifier;
                        B.push(r.create(r.Class.CONTEXT_SPECIFIC, 0, !1, D));
                    }
                    if (k.authorityCertIssuer) {
                        var G = [r.create(r.Class.CONTEXT_SPECIFIC, 4, !0, [l(k.authorityCertIssuer === !0 ? x.cert.issuer : k.authorityCertIssuer)])];
                        B.push(r.create(r.Class.CONTEXT_SPECIFIC, 1, !0, G));
                    }
                    if (k.serialNumber) {
                        var W = d.util.hexToBytes(k.serialNumber === !0 ? x.cert.serialNumber : k.serialNumber);
                        B.push(r.create(r.Class.CONTEXT_SPECIFIC, 2, !1, W));
                    }
                }
                else if (k.name === "cRLDistributionPoints") {
                    k.value = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []), B = k.value.value;
                    var X, Q = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []), K = r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, []);
                    for (L = 0; L < k.altNames.length; ++L) {
                        if (T = (X = k.altNames[L]).value, X.type === 7 && X.ip) {
                            if ((T = d.util.bytesFromIP(X.ip)) === null)
                                throw (F = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')).extension = k, F;
                        }
                        else
                            X.type === 8 && (T = X.oid ? r.oidToDer(r.oidToDer(X.oid)) : r.oidToDer(T));
                        K.value.push(r.create(r.Class.CONTEXT_SPECIFIC, X.type, !1, T));
                    }
                    Q.value.push(r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [K])), B.push(Q);
                } var F; if (k.value === void 0)
                    throw (F = new Error("Extension value not specified.")).extension = k, F; return k; }
                function b(k, x) { switch (k) {
                    case c["RSASSA-PSS"]:
                        var M = [];
                        return x.hash.algorithmOid !== void 0 && M.push(r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(x.hash.algorithmOid).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")])])), x.mgf.algorithmOid !== void 0 && M.push(r.create(r.Class.CONTEXT_SPECIFIC, 1, !0, [r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(x.mgf.algorithmOid).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(x.mgf.hash.algorithmOid).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")])])])), x.saltLength !== void 0 && M.push(r.create(r.Class.CONTEXT_SPECIFIC, 2, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(x.saltLength).getBytes())])), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, M);
                    default: return r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "");
                } }
                function I(k) { var x = r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, []); if (k.attributes.length === 0)
                    return x; for (var M = k.attributes, N = 0; N < M.length; ++N) {
                    var S = M[N], T = S.value, B = r.Type.UTF8;
                    "valueTagClass" in S && (B = S.valueTagClass), B === r.Type.UTF8 && (T = d.util.encodeUtf8(T));
                    var P = !1;
                    "valueConstructed" in S && (P = S.valueConstructed);
                    var L = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(S.type).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SET, !0, [r.create(r.Class.UNIVERSAL, B, P, T)])]);
                    x.value.push(L);
                } return x; }
                e.certificateFromPem = function (k, x, M) { var N = d.pem.decode(k)[0]; if (N.type !== "CERTIFICATE" && N.type !== "X509 CERTIFICATE" && N.type !== "TRUSTED CERTIFICATE") {
                    var S = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                    throw S.headerType = N.type, S;
                } if (N.procType && N.procType.type === "ENCRYPTED")
                    throw new Error("Could not convert certificate from PEM; PEM is encrypted."); var T = r.fromDer(N.body, M); return e.certificateFromAsn1(T, x); }, e.certificateToPem = function (k, x) { var M = { type: "CERTIFICATE", body: r.toDer(e.certificateToAsn1(k)).getBytes() }; return d.pem.encode(M, { maxline: x }); }, e.publicKeyFromPem = function (k) { var x = d.pem.decode(k)[0]; if (x.type !== "PUBLIC KEY" && x.type !== "RSA PUBLIC KEY") {
                    var M = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
                    throw M.headerType = x.type, M;
                } if (x.procType && x.procType.type === "ENCRYPTED")
                    throw new Error("Could not convert public key from PEM; PEM is encrypted."); var N = r.fromDer(x.body); return e.publicKeyFromAsn1(N); }, e.publicKeyToPem = function (k, x) { var M = { type: "PUBLIC KEY", body: r.toDer(e.publicKeyToAsn1(k)).getBytes() }; return d.pem.encode(M, { maxline: x }); }, e.publicKeyToRSAPublicKeyPem = function (k, x) { var M = { type: "RSA PUBLIC KEY", body: r.toDer(e.publicKeyToRSAPublicKey(k)).getBytes() }; return d.pem.encode(M, { maxline: x }); }, e.getPublicKeyFingerprint = function (k, x) { var M, N = (x = x || {}).md || d.md.sha1.create(); switch (x.type || "RSAPublicKey") {
                    case "RSAPublicKey":
                        M = r.toDer(e.publicKeyToRSAPublicKey(k)).getBytes();
                        break;
                    case "SubjectPublicKeyInfo":
                        M = r.toDer(e.publicKeyToAsn1(k)).getBytes();
                        break;
                    default: throw new Error('Unknown fingerprint type "' + x.type + '".');
                } N.start(), N.update(M); var S = N.digest(); if (x.encoding === "hex") {
                    var T = S.toHex();
                    return x.delimiter ? T.match(/.{2}/g).join(x.delimiter) : T;
                } if (x.encoding === "binary")
                    return S.getBytes(); if (x.encoding)
                    throw new Error('Unknown encoding "' + x.encoding + '".'); return S; }, e.certificationRequestFromPem = function (k, x, M) { var N = d.pem.decode(k)[0]; if (N.type !== "CERTIFICATE REQUEST") {
                    var S = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
                    throw S.headerType = N.type, S;
                } if (N.procType && N.procType.type === "ENCRYPTED")
                    throw new Error("Could not convert certification request from PEM; PEM is encrypted."); var T = r.fromDer(N.body, M); return e.certificationRequestFromAsn1(T, x); }, e.certificationRequestToPem = function (k, x) { var M = { type: "CERTIFICATE REQUEST", body: r.toDer(e.certificationRequestToAsn1(k)).getBytes() }; return d.pem.encode(M, { maxline: x }); }, e.createCertificate = function () { var k = { version: 2, serialNumber: "00", signatureOid: null, signature: null, siginfo: {} }; return k.siginfo.algorithmOid = null, k.validity = {}, k.validity.notBefore = new Date, k.validity.notAfter = new Date, k.issuer = {}, k.issuer.getField = function (x) { return h(k.issuer, x); }, k.issuer.addField = function (x) { p([x]), k.issuer.attributes.push(x); }, k.issuer.attributes = [], k.issuer.hash = null, k.subject = {}, k.subject.getField = function (x) { return h(k.subject, x); }, k.subject.addField = function (x) { p([x]), k.subject.attributes.push(x); }, k.subject.attributes = [], k.subject.hash = null, k.extensions = [], k.publicKey = null, k.md = null, k.setSubject = function (x, M) { p(x), k.subject.attributes = x, delete k.subject.uniqueId, M && (k.subject.uniqueId = M), k.subject.hash = null; }, k.setIssuer = function (x, M) { p(x), k.issuer.attributes = x, delete k.issuer.uniqueId, M && (k.issuer.uniqueId = M), k.issuer.hash = null; }, k.setExtensions = function (x) { for (var M = 0; M < x.length; ++M)
                    g(x[M], { cert: k }); k.extensions = x; }, k.getExtension = function (x) { typeof x == "string" && (x = { name: x }); for (var M, N = null, S = 0; N === null && S < k.extensions.length; ++S)
                    M = k.extensions[S], (x.id && M.id === x.id || x.name && M.name === x.name) && (N = M); return N; }, k.sign = function (x, M) { k.md = M || d.md.sha1.create(); var N = c[k.md.algorithm + "WithRSAEncryption"]; if (!N) {
                    var S = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
                    throw S.algorithm = k.md.algorithm, S;
                } k.signatureOid = k.siginfo.algorithmOid = N, k.tbsCertificate = e.getTBSCertificate(k); var T = r.toDer(k.tbsCertificate); k.md.update(T.getBytes()), k.signature = x.sign(k.md); }, k.verify = function (x) { var M = !1; if (!k.issued(x)) {
                    var N = x.issuer, S = k.subject;
                    throw (G = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.")).expectedIssuer = N.attributes, G.actualIssuer = S.attributes, G;
                } var T = x.md; if (T === null) {
                    if (x.signatureOid in c)
                        switch (c[x.signatureOid]) {
                            case "sha1WithRSAEncryption":
                                T = d.md.sha1.create();
                                break;
                            case "md5WithRSAEncryption":
                                T = d.md.md5.create();
                                break;
                            case "sha256WithRSAEncryption":
                                T = d.md.sha256.create();
                                break;
                            case "sha384WithRSAEncryption":
                                T = d.md.sha384.create();
                                break;
                            case "sha512WithRSAEncryption":
                                T = d.md.sha512.create();
                                break;
                            case "RSASSA-PSS": T = d.md.sha256.create();
                        }
                    if (T === null)
                        throw (G = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = x.signatureOid, G;
                    var B = x.tbsCertificate || e.getTBSCertificate(x), P = r.toDer(B);
                    T.update(P.getBytes());
                } if (T !== null) {
                    var L;
                    switch (x.signatureOid) {
                        case c.sha1WithRSAEncryption:
                            L = void 0;
                            break;
                        case c["RSASSA-PSS"]:
                            var j, D, G;
                            if ((j = c[x.signatureParameters.mgf.hash.algorithmOid]) === void 0 || d.md[j] === void 0)
                                throw (G = new Error("Unsupported MGF hash function.")).oid = x.signatureParameters.mgf.hash.algorithmOid, G.name = j, G;
                            if ((D = c[x.signatureParameters.mgf.algorithmOid]) === void 0 || d.mgf[D] === void 0)
                                throw (G = new Error("Unsupported MGF function.")).oid = x.signatureParameters.mgf.algorithmOid, G.name = D, G;
                            if (D = d.mgf[D].create(d.md[j].create()), (j = c[x.signatureParameters.hash.algorithmOid]) === void 0 || d.md[j] === void 0)
                                throw { message: "Unsupported RSASSA-PSS hash function.", oid: x.signatureParameters.hash.algorithmOid, name: j };
                            L = d.pss.create(d.md[j].create(), D, x.signatureParameters.saltLength);
                    }
                    M = k.publicKey.verify(T.digest().getBytes(), x.signature, L);
                } return M; }, k.isIssuer = function (x) { var M = !1, N = k.issuer, S = x.subject; if (N.hash && S.hash)
                    M = N.hash === S.hash;
                else if (N.attributes.length === S.attributes.length) {
                    var T, B;
                    M = !0;
                    for (var P = 0; M && P < N.attributes.length; ++P)
                        T = N.attributes[P], B = S.attributes[P], T.type === B.type && T.value === B.value || (M = !1);
                } return M; }, k.issued = function (x) { return x.isIssuer(k); }, k.generateSubjectKeyIdentifier = function () { return e.getPublicKeyFingerprint(k.publicKey, { type: "RSAPublicKey" }); }, k.verifySubjectKeyIdentifier = function () { for (var x = c.subjectKeyIdentifier, M = 0; M < k.extensions.length; ++M) {
                    var N = k.extensions[M];
                    if (N.id === x) {
                        var S = k.generateSubjectKeyIdentifier().getBytes();
                        return d.util.hexToBytes(N.subjectKeyIdentifier) === S;
                    }
                } return !1; }, k; }, e.certificateFromAsn1 = function (k, x) { var M = {}, N = []; if (!r.validate(k, s, M, N))
                    throw (P = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.")).errors = N, P; if (r.derToOid(M.publicKeyOid) !== e.oids.rsaEncryption)
                    throw new Error("Cannot read public key. OID is not RSA."); var S = e.createCertificate(); S.version = M.certVersion ? M.certVersion.charCodeAt(0) : 0; var T = d.util.createBuffer(M.certSerialNumber); S.serialNumber = T.toHex(), S.signatureOid = d.asn1.derToOid(M.certSignatureOid), S.signatureParameters = a(S.signatureOid, M.certSignatureParams, !0), S.siginfo.algorithmOid = d.asn1.derToOid(M.certinfoSignatureOid), S.siginfo.parameters = a(S.siginfo.algorithmOid, M.certinfoSignatureParams, !1), S.signature = M.certSignature; var B = []; if (M.certValidity1UTCTime !== void 0 && B.push(r.utcTimeToDate(M.certValidity1UTCTime)), M.certValidity2GeneralizedTime !== void 0 && B.push(r.generalizedTimeToDate(M.certValidity2GeneralizedTime)), M.certValidity3UTCTime !== void 0 && B.push(r.utcTimeToDate(M.certValidity3UTCTime)), M.certValidity4GeneralizedTime !== void 0 && B.push(r.generalizedTimeToDate(M.certValidity4GeneralizedTime)), B.length > 2)
                    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate."); if (B.length < 2)
                    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime."); if (S.validity.notBefore = B[0], S.validity.notAfter = B[1], S.tbsCertificate = M.tbsCertificate, x) {
                    var P;
                    if (S.md = null, S.signatureOid in c)
                        switch (c[S.signatureOid]) {
                            case "sha1WithRSAEncryption":
                                S.md = d.md.sha1.create();
                                break;
                            case "md5WithRSAEncryption":
                                S.md = d.md.md5.create();
                                break;
                            case "sha256WithRSAEncryption":
                                S.md = d.md.sha256.create();
                                break;
                            case "sha384WithRSAEncryption":
                                S.md = d.md.sha384.create();
                                break;
                            case "sha512WithRSAEncryption":
                                S.md = d.md.sha512.create();
                                break;
                            case "RSASSA-PSS": S.md = d.md.sha256.create();
                        }
                    if (S.md === null)
                        throw (P = new Error("Could not compute certificate digest. Unknown signature OID.")).signatureOid = S.signatureOid, P;
                    var L = r.toDer(S.tbsCertificate);
                    S.md.update(L.getBytes());
                } var j = d.md.sha1.create(); S.issuer.getField = function (G) { return h(S.issuer, G); }, S.issuer.addField = function (G) { p([G]), S.issuer.attributes.push(G); }, S.issuer.attributes = e.RDNAttributesAsArray(M.certIssuer, j), M.certIssuerUniqueId && (S.issuer.uniqueId = M.certIssuerUniqueId), S.issuer.hash = j.digest().toHex(); var D = d.md.sha1.create(); return S.subject.getField = function (G) { return h(S.subject, G); }, S.subject.addField = function (G) { p([G]), S.subject.attributes.push(G); }, S.subject.attributes = e.RDNAttributesAsArray(M.certSubject, D), M.certSubjectUniqueId && (S.subject.uniqueId = M.certSubjectUniqueId), S.subject.hash = D.digest().toHex(), M.certExtensions ? S.extensions = e.certificateExtensionsFromAsn1(M.certExtensions) : S.extensions = [], S.publicKey = e.publicKeyFromAsn1(M.subjectPublicKeyInfo), S; }, e.certificateExtensionsFromAsn1 = function (k) { for (var x = [], M = 0; M < k.value.length; ++M)
                    for (var N = k.value[M], S = 0; S < N.value.length; ++S)
                        x.push(e.certificateExtensionFromAsn1(N.value[S])); return x; }, e.certificateExtensionFromAsn1 = function (k) { var x = {}; if (x.id = r.derToOid(k.value[0].value), x.critical = !1, k.value[1].type === r.Type.BOOLEAN ? (x.critical = k.value[1].value.charCodeAt(0) !== 0, x.value = k.value[2].value) : x.value = k.value[1].value, x.id in c)
                    if (x.name = c[x.id], x.name === "keyUsage") {
                        var M = 0, N = 0;
                        (T = r.fromDer(x.value)).value.length > 1 && (M = T.value.charCodeAt(1), N = T.value.length > 2 ? T.value.charCodeAt(2) : 0), x.digitalSignature = (128 & M) == 128, x.nonRepudiation = (64 & M) == 64, x.keyEncipherment = (32 & M) == 32, x.dataEncipherment = (16 & M) == 16, x.keyAgreement = (8 & M) == 8, x.keyCertSign = (4 & M) == 4, x.cRLSign = (2 & M) == 2, x.encipherOnly = (1 & M) == 1, x.decipherOnly = (128 & N) == 128;
                    }
                    else if (x.name === "basicConstraints") {
                        (T = r.fromDer(x.value)).value.length > 0 && T.value[0].type === r.Type.BOOLEAN ? x.cA = T.value[0].value.charCodeAt(0) !== 0 : x.cA = !1;
                        var S = null;
                        T.value.length > 0 && T.value[0].type === r.Type.INTEGER ? S = T.value[0].value : T.value.length > 1 && (S = T.value[1].value), S !== null && (x.pathLenConstraint = r.derToInteger(S));
                    }
                    else if (x.name === "extKeyUsage")
                        for (var T = r.fromDer(x.value), B = 0; B < T.value.length; ++B) {
                            var P = r.derToOid(T.value[B].value);
                            P in c ? x[c[P]] = !0 : x[P] = !0;
                        }
                    else if (x.name === "nsCertType")
                        M = 0, (T = r.fromDer(x.value)).value.length > 1 && (M = T.value.charCodeAt(1)), x.client = (128 & M) == 128, x.server = (64 & M) == 64, x.email = (32 & M) == 32, x.objsign = (16 & M) == 16, x.reserved = (8 & M) == 8, x.sslCA = (4 & M) == 4, x.emailCA = (2 & M) == 2, x.objCA = (1 & M) == 1;
                    else if (x.name === "subjectAltName" || x.name === "issuerAltName") {
                        var L;
                        x.altNames = [], T = r.fromDer(x.value);
                        for (var j = 0; j < T.value.length; ++j) {
                            var D = { type: (L = T.value[j]).type, value: L.value };
                            switch (x.altNames.push(D), L.type) {
                                case 1:
                                case 2:
                                case 6: break;
                                case 7:
                                    D.ip = d.util.bytesToIP(L.value);
                                    break;
                                case 8: D.oid = r.derToOid(L.value);
                            }
                        }
                    }
                    else
                        x.name === "subjectKeyIdentifier" && (T = r.fromDer(x.value), x.subjectKeyIdentifier = d.util.bytesToHex(T.value)); return x; }, e.certificationRequestFromAsn1 = function (k, x) { var M = {}, N = []; if (!r.validate(k, o, M, N))
                    throw (T = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.")).errors = N, T; if (r.derToOid(M.publicKeyOid) !== e.oids.rsaEncryption)
                    throw new Error("Cannot read public key. OID is not RSA."); var S = e.createCertificationRequest(); if (S.version = M.csrVersion ? M.csrVersion.charCodeAt(0) : 0, S.signatureOid = d.asn1.derToOid(M.csrSignatureOid), S.signatureParameters = a(S.signatureOid, M.csrSignatureParams, !0), S.siginfo.algorithmOid = d.asn1.derToOid(M.csrSignatureOid), S.siginfo.parameters = a(S.siginfo.algorithmOid, M.csrSignatureParams, !1), S.signature = M.csrSignature, S.certificationRequestInfo = M.certificationRequestInfo, x) {
                    var T;
                    if (S.md = null, S.signatureOid in c)
                        switch (c[S.signatureOid]) {
                            case "sha1WithRSAEncryption":
                                S.md = d.md.sha1.create();
                                break;
                            case "md5WithRSAEncryption":
                                S.md = d.md.md5.create();
                                break;
                            case "sha256WithRSAEncryption":
                                S.md = d.md.sha256.create();
                                break;
                            case "sha384WithRSAEncryption":
                                S.md = d.md.sha384.create();
                                break;
                            case "sha512WithRSAEncryption":
                                S.md = d.md.sha512.create();
                                break;
                            case "RSASSA-PSS": S.md = d.md.sha256.create();
                        }
                    if (S.md === null)
                        throw (T = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = S.signatureOid, T;
                    var B = r.toDer(S.certificationRequestInfo);
                    S.md.update(B.getBytes());
                } var P = d.md.sha1.create(); return S.subject.getField = function (L) { return h(S.subject, L); }, S.subject.addField = function (L) { p([L]), S.subject.attributes.push(L); }, S.subject.attributes = e.RDNAttributesAsArray(M.certificationRequestInfoSubject, P), S.subject.hash = P.digest().toHex(), S.publicKey = e.publicKeyFromAsn1(M.subjectPublicKeyInfo), S.getAttribute = function (L) { return h(S, L); }, S.addAttribute = function (L) { p([L]), S.attributes.push(L); }, S.attributes = e.CRIAttributesAsArray(M.certificationRequestInfoAttributes || []), S; }, e.createCertificationRequest = function () { var k = { version: 0, signatureOid: null, signature: null, siginfo: {} }; return k.siginfo.algorithmOid = null, k.subject = {}, k.subject.getField = function (x) { return h(k.subject, x); }, k.subject.addField = function (x) { p([x]), k.subject.attributes.push(x); }, k.subject.attributes = [], k.subject.hash = null, k.publicKey = null, k.attributes = [], k.getAttribute = function (x) { return h(k, x); }, k.addAttribute = function (x) { p([x]), k.attributes.push(x); }, k.md = null, k.setSubject = function (x) { p(x), k.subject.attributes = x, k.subject.hash = null; }, k.setAttributes = function (x) { p(x), k.attributes = x; }, k.sign = function (x, M) { k.md = M || d.md.sha1.create(); var N = c[k.md.algorithm + "WithRSAEncryption"]; if (!N) {
                    var S = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
                    throw S.algorithm = k.md.algorithm, S;
                } k.signatureOid = k.siginfo.algorithmOid = N, k.certificationRequestInfo = e.getCertificationRequestInfo(k); var T = r.toDer(k.certificationRequestInfo); k.md.update(T.getBytes()), k.signature = x.sign(k.md); }, k.verify = function () { var x = !1, M = k.md; if (M === null) {
                    if (k.signatureOid in c)
                        switch (c[k.signatureOid]) {
                            case "sha1WithRSAEncryption":
                                M = d.md.sha1.create();
                                break;
                            case "md5WithRSAEncryption":
                                M = d.md.md5.create();
                                break;
                            case "sha256WithRSAEncryption":
                                M = d.md.sha256.create();
                                break;
                            case "sha384WithRSAEncryption":
                                M = d.md.sha384.create();
                                break;
                            case "sha512WithRSAEncryption":
                                M = d.md.sha512.create();
                                break;
                            case "RSASSA-PSS": M = d.md.sha256.create();
                        }
                    if (M === null)
                        throw (L = new Error("Could not compute certification request digest. Unknown signature OID.")).signatureOid = k.signatureOid, L;
                    var N = k.certificationRequestInfo || e.getCertificationRequestInfo(k), S = r.toDer(N);
                    M.update(S.getBytes());
                } if (M !== null) {
                    var T;
                    switch (k.signatureOid) {
                        case c.sha1WithRSAEncryption: break;
                        case c["RSASSA-PSS"]:
                            var B, P, L;
                            if ((B = c[k.signatureParameters.mgf.hash.algorithmOid]) === void 0 || d.md[B] === void 0)
                                throw (L = new Error("Unsupported MGF hash function.")).oid = k.signatureParameters.mgf.hash.algorithmOid, L.name = B, L;
                            if ((P = c[k.signatureParameters.mgf.algorithmOid]) === void 0 || d.mgf[P] === void 0)
                                throw (L = new Error("Unsupported MGF function.")).oid = k.signatureParameters.mgf.algorithmOid, L.name = P, L;
                            if (P = d.mgf[P].create(d.md[B].create()), (B = c[k.signatureParameters.hash.algorithmOid]) === void 0 || d.md[B] === void 0)
                                throw (L = new Error("Unsupported RSASSA-PSS hash function.")).oid = k.signatureParameters.hash.algorithmOid, L.name = B, L;
                            T = d.pss.create(d.md[B].create(), P, k.signatureParameters.saltLength);
                    }
                    x = k.publicKey.verify(M.digest().getBytes(), k.signature, T);
                } return x; }, k; };
                var v = new Date("1950-01-01T00:00:00Z"), R = new Date("2050-01-01T00:00:00Z");
                function _(k) { return k >= v && k < R ? r.create(r.Class.UNIVERSAL, r.Type.UTCTIME, !1, r.dateToUtcTime(k)) : r.create(r.Class.UNIVERSAL, r.Type.GENERALIZEDTIME, !1, r.dateToGeneralizedTime(k)); }
                e.getTBSCertificate = function (k) { var x = _(k.validity.notBefore), M = _(k.validity.notAfter), N = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(k.version).getBytes())]), r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, d.util.hexToBytes(k.serialNumber)), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(k.siginfo.algorithmOid).getBytes()), b(k.siginfo.algorithmOid, k.siginfo.parameters)]), l(k.issuer), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [x, M]), l(k.subject), e.publicKeyToAsn1(k.publicKey)]); return k.issuer.uniqueId && N.value.push(r.create(r.Class.CONTEXT_SPECIFIC, 1, !0, [r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, String.fromCharCode(0) + k.issuer.uniqueId)])), k.subject.uniqueId && N.value.push(r.create(r.Class.CONTEXT_SPECIFIC, 2, !0, [r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, String.fromCharCode(0) + k.subject.uniqueId)])), k.extensions.length > 0 && N.value.push(e.certificateExtensionsToAsn1(k.extensions)), N; }, e.getCertificationRequestInfo = function (k) { return r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(k.version).getBytes()), l(k.subject), e.publicKeyToAsn1(k.publicKey), I(k)]); }, e.distinguishedNameToAsn1 = function (k) { return l(k); }, e.certificateToAsn1 = function (k) { var x = k.tbsCertificate || e.getTBSCertificate(k); return r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [x, r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(k.signatureOid).getBytes()), b(k.signatureOid, k.signatureParameters)]), r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, String.fromCharCode(0) + k.signature)]); }, e.certificateExtensionsToAsn1 = function (k) { var x = r.create(r.Class.CONTEXT_SPECIFIC, 3, !0, []), M = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []); x.value.push(M); for (var N = 0; N < k.length; ++N)
                    M.value.push(e.certificateExtensionToAsn1(k[N])); return x; }, e.certificateExtensionToAsn1 = function (k) { var x = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, []); x.value.push(r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(k.id).getBytes())), k.critical && x.value.push(r.create(r.Class.UNIVERSAL, r.Type.BOOLEAN, !1, String.fromCharCode(255))); var M = k.value; return typeof k.value != "string" && (M = r.toDer(M).getBytes()), x.value.push(r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, M)), x; }, e.certificationRequestToAsn1 = function (k) { var x = k.certificationRequestInfo || e.getCertificationRequestInfo(k); return r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [x, r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(k.signatureOid).getBytes()), b(k.signatureOid, k.signatureParameters)]), r.create(r.Class.UNIVERSAL, r.Type.BITSTRING, !1, String.fromCharCode(0) + k.signature)]); }, e.createCaStore = function (k) { var x = { certs: {} }; function M(B) { return N(B), x.certs[B.hash] || null; } function N(B) { if (!B.hash) {
                    var P = d.md.sha1.create();
                    B.attributes = e.RDNAttributesAsArray(l(B), P), B.hash = P.digest().toHex();
                } } if (x.getIssuer = function (B) { return M(B.issuer); }, x.addCertificate = function (B) { if (typeof B == "string" && (B = d.pki.certificateFromPem(B)), N(B.subject), !x.hasCertificate(B))
                    if (B.subject.hash in x.certs) {
                        var P = x.certs[B.subject.hash];
                        d.util.isArray(P) || (P = [P]), P.push(B), x.certs[B.subject.hash] = P;
                    }
                    else
                        x.certs[B.subject.hash] = B; }, x.hasCertificate = function (B) { typeof B == "string" && (B = d.pki.certificateFromPem(B)); var P = M(B.subject); if (!P)
                    return !1; d.util.isArray(P) || (P = [P]); for (var L = r.toDer(e.certificateToAsn1(B)).getBytes(), j = 0; j < P.length; ++j)
                    if (L === r.toDer(e.certificateToAsn1(P[j])).getBytes())
                        return !0; return !1; }, x.listAllCertificates = function () { var B = []; for (var P in x.certs)
                    if (x.certs.hasOwnProperty(P)) {
                        var L = x.certs[P];
                        if (d.util.isArray(L))
                            for (var j = 0; j < L.length; ++j)
                                B.push(L[j]);
                        else
                            B.push(L);
                    } return B; }, x.removeCertificate = function (B) { var P; if (typeof B == "string" && (B = d.pki.certificateFromPem(B)), N(B.subject), !x.hasCertificate(B))
                    return null; var L = M(B.subject); if (!d.util.isArray(L))
                    return P = x.certs[B.subject.hash], delete x.certs[B.subject.hash], P; for (var j = r.toDer(e.certificateToAsn1(B)).getBytes(), D = 0; D < L.length; ++D)
                    j === r.toDer(e.certificateToAsn1(L[D])).getBytes() && (P = L[D], L.splice(D, 1)); return L.length === 0 && delete x.certs[B.subject.hash], P; }, k)
                    for (var S = 0; S < k.length; ++S) {
                        var T = k[S];
                        x.addCertificate(T);
                    } return x; }, e.certificateError = { bad_certificate: "forge.pki.BadCertificate", unsupported_certificate: "forge.pki.UnsupportedCertificate", certificate_revoked: "forge.pki.CertificateRevoked", certificate_expired: "forge.pki.CertificateExpired", certificate_unknown: "forge.pki.CertificateUnknown", unknown_ca: "forge.pki.UnknownCertificateAuthority" }, e.verifyCertificateChain = function (k, x, M) { typeof M == "function" && (M = { verify: M }), M = M || {}; var N = (x = x.slice(0)).slice(0), S = M.validityCheckDate; S === void 0 && (S = new Date); var T = !0, B = null, P = 0; do {
                    var L = x.shift(), j = null, D = !1;
                    if (S && (S < L.validity.notBefore || S > L.validity.notAfter) && (B = { message: "Certificate is not valid yet or has expired.", error: e.certificateError.certificate_expired, notBefore: L.validity.notBefore, notAfter: L.validity.notAfter, now: S }), B === null) {
                        if ((j = x[0] || k.getIssuer(L)) === null && L.isIssuer(L) && (D = !0, j = L), j) {
                            var G = j;
                            d.util.isArray(G) || (G = [G]);
                            for (var W = !1; !W && G.length > 0;) {
                                j = G.shift();
                                try {
                                    W = j.verify(L);
                                }
                                catch (C) { }
                            }
                            W || (B = { message: "Certificate signature is invalid.", error: e.certificateError.bad_certificate });
                        }
                        B !== null || j && !D || k.hasCertificate(L) || (B = { message: "Certificate is not trusted.", error: e.certificateError.unknown_ca });
                    }
                    if (B === null && j && !L.isIssuer(j) && (B = { message: "Certificate issuer is invalid.", error: e.certificateError.bad_certificate }), B === null)
                        for (var X = { keyUsage: !0, basicConstraints: !0 }, Q = 0; B === null && Q < L.extensions.length; ++Q) {
                            var K = L.extensions[Q];
                            K.critical && !(K.name in X) && (B = { message: "Certificate has an unsupported critical extension.", error: e.certificateError.unsupported_certificate });
                        }
                    if (B === null && (!T || x.length === 0 && (!j || D))) {
                        var F = L.getExtension("basicConstraints"), Y = L.getExtension("keyUsage");
                        (Y !== null && (Y.keyCertSign && F !== null || (B = { message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.", error: e.certificateError.bad_certificate })), B !== null || F === null || F.cA || (B = { message: "Certificate basicConstraints indicates the certificate is not a CA.", error: e.certificateError.bad_certificate }), B === null && Y !== null && "pathLenConstraint" in F) && (P - 1 > F.pathLenConstraint && (B = { message: "Certificate basicConstraints pathLenConstraint violated.", error: e.certificateError.bad_certificate }));
                    }
                    var $ = B === null || B.error, y = M.verify ? M.verify($, P, N) : $;
                    if (y !== !0)
                        throw $ === !0 && (B = { message: "The application rejected the certificate.", error: e.certificateError.bad_certificate }), (y || y === 0) && (typeof y != "object" || d.util.isArray(y) ? typeof y == "string" && (B.error = y) : (y.message && (B.message = y.message), y.error && (B.error = y.error))), B;
                    B = null, T = !1, ++P;
                } while (x.length > 0); return !0; };
            }, function (E, m, f) {
                "use strict";
                const d = Math.exp;
                E.exports = function (r) { if (typeof r != "number")
                    throw new Error("must provide a timespan to the moving average constructor"); if (r <= 0)
                    throw new Error("must provide a timespan > 0 to the moving average constructor"); let e, c, n = 0, t = 0, s = 0, u = {}; return u.push = function (i, o) { if (c) {
                    const h = 1 - d(-(i - c) / r), a = o - e;
                    e = h * o + (1 - h) * e, n = (1 - h) * (n + a * (h * a)), t = Math.sqrt(n), s = e + h * a;
                }
                else
                    e = o; c = i; }, u.movingAverage = function () { return e; }, u.variance = function () { return n; }, u.deviation = function () { return t; }, u.forecast = function () { return s; }, u; };
            }, function (E, m, f) {
                "use strict";
                m.PROTOCOL_ID = "/multistream/1.0.0";
            }, function (E, m, f) {
                "use strict";
                E.exports = { OPEN: "open", CLOSING: "closing", CLOSED: "closed" };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1);
                r("libp2p:peer-store").error = r("libp2p:peer-store:error");
                const { EventEmitter: e } = f(12), c = f(7), n = f(905), t = f(910), s = f(911), u = f(912), { ERR_INVALID_PARAMETERS: i } = f(28);
                E.exports = class extends e {
                    constructor({ peerId: o }) { super(), this._peerId = o, this.addressBook = new n(this), this.keyBook = new t(this), this.metadataBook = new s(this), this.protoBook = new u(this); }
                    start() { }
                    stop() { }
                    get peers() { const o = new Set([...this.addressBook.data.keys(), ...this.keyBook.data.keys(), ...this.protoBook.data.keys(), ...this.metadataBook.data.keys()]); this._peerId && o.delete(this._peerId.toB58String()); const h = new Map; return o.forEach(a => { h.set(a, this.get(c.createFromCID(a))); }), h; }
                    delete(o) { const h = this.addressBook.delete(o), a = this.keyBook.delete(o), l = this.protoBook.delete(o), p = this.metadataBook.delete(o); return h || a || l || p; }
                    get(o) { if (!c.isPeerId(o))
                        throw d(new Error("peerId must be an instance of peer-id"), i); const h = this.keyBook.data.get(o.toB58String()), a = this.addressBook.get(o), l = this.metadataBook.get(o), p = this.protoBook.get(o); if (h || a || l || p)
                        return { id: h || o, addresses: a || [], protocols: p || [], metadata: l }; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(13), r = f(7), e = f(906), c = f(907), n = f(908), { ENVELOPE_DOMAIN_PEER_RECORD: t, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: s } = f(909);
                class u extends e {
                    constructor({ peerId: o, multiaddrs: h = [], seqNumber: a = Date.now() }) { super(t, s), this.peerId = o, this.multiaddrs = h, this.seqNumber = a, this._marshal = void 0; }
                    marshal() { return this._marshal || (this._marshal = n.encode({ peer_id: this.peerId.toBytes(), seq: this.seqNumber, addresses: this.multiaddrs.map(o => ({ multiaddr: o.bytes })) })), this._marshal; }
                    equals(o) { return !!this.peerId.equals(o.peerId) && this.seqNumber === o.seqNumber && !!c(this.multiaddrs, o.multiaddrs); }
                }
                u.createFromProtobuf = i => { const o = n.decode(i), h = r.createFromBytes(o.peer_id), a = (o.addresses || []).map(p => d(p.multiaddr)), l = o.seq; return new u({ peerId: h, multiaddrs: a, seqNumber: l }); }, u.DOMAIN = t, E.exports = u;
            }, function (E, m, f) {
                "use strict";
                m.CODE_P2P = 421, m.CODE_CIRCUIT = 290, m.CLOSE_TIMEOUT = 2e3;
            }, function (E, m, f) {
                "use strict";
                const d = f(13), r = f(0), { Address4: e, Address6: c } = f(941), n = { ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER", ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER", ERR_INVALID_IP: "ERR_INVALID_IP" };
                E.exports = function (t, s) { if (typeof t != "string")
                    throw r(new Error("invalid ip provided: " + t), n.ERR_INVALID_IP_PARAMETER); if (s = parseInt(s), isNaN(s))
                    throw r(new Error("invalid port provided: " + s), n.ERR_INVALID_PORT_PARAMETER); if (new e(t).isValid())
                    return d(`/ip4/${t}/tcp/${s}`); const u = new c(t); if (u.isValid())
                    return u.is4() ? d(`/ip4/${u.to4().correctForm()}/tcp/${s}`) : d(`/ip6/${t}/tcp/${s}`); throw r(new Error(`invalid ip:port for creating a multiaddr: ${t}:${s}`), n.ERR_INVALID_IP); }, E.exports.Errors = n;
            }, function (E, m, f) {
                "use strict";
                var d = f(350).BigInteger, r = f(351), e = f(100).sprintf, c = f(352), n = f(353), t = f(201);
                function s(u) { this.valid = !1, this.address = u, this.groups = t.GROUPS, this.v4 = !0, this.subnet = "/32", this.subnetMask = 32; var i = t.RE_SUBNET_STRING.exec(u); if (i) {
                    if (this.parsedSubnet = i[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = "/" + this.subnetMask, this.subnetMask < 0 || this.subnetMask > t.BITS)
                        return this.valid = !1, void (this.error = "Invalid subnet mask.");
                    u = u.replace(t.RE_SUBNET_STRING, "");
                } this.addressMinusSuffix = u, this.parsedAddress = this.parse(u); }
                s.prototype.parse = function (u) { var i = u.split("."); return u.match(t.RE_ADDRESS) ? this.valid = !0 : this.error = "Invalid IPv4 address.", i; }, s.prototype.isValid = function () { return this.valid; }, s.prototype.correctForm = function () { return this.parsedAddress.map(function (u) { return parseInt(u, 10); }).join("."); }, s.prototype.isCorrect = r.isCorrect(t.BITS), s.fromHex = function (u) { var i, o = c(u.replace(/:/g, ""), 8, "0"), h = []; for (i = 0; i < 8; i += 2) {
                    var a = o.slice(i, i + 2);
                    h.push(parseInt(a, 16));
                } return new s(h.join(".")); }, s.fromInteger = function (u) { return s.fromHex(u.toString(16)); }, s.prototype.toHex = function () { return this.parsedAddress.map(function (u) { return e("%02x", parseInt(u, 10)); }).join(":"); }, s.prototype.toArray = function () { return this.parsedAddress.map(function (u) { return parseInt(u, 10); }); }, s.prototype.toGroup6 = function () { var u, i = []; for (u = 0; u < t.GROUPS; u += 2) {
                    var o = e("%02x%02x", parseInt(this.parsedAddress[u], 10), parseInt(this.parsedAddress[u + 1], 10));
                    i.push(e("%x", parseInt(o, 16)));
                } return i.join(":"); }, s.prototype.bigInteger = function () { return this.valid ? new d(this.parsedAddress.map(function (u) { return e("%02x", parseInt(u, 10)); }).join(""), 16) : null; }, s.prototype._startAddress = function () { return new d(this.mask() + n("0", t.BITS - this.subnetMask), 2); }, s.prototype.startAddress = function () { return s.fromBigInteger(this._startAddress()); }, s.prototype.startAddressExclusive = function () { var u = new d("1"); return s.fromBigInteger(this._startAddress().add(u)); }, s.prototype._endAddress = function () { return new d(this.mask() + n("1", t.BITS - this.subnetMask), 2); }, s.prototype.endAddress = function () { return s.fromBigInteger(this._endAddress()); }, s.prototype.endAddressExclusive = function () { var u = new d("1"); return s.fromBigInteger(this._endAddress().subtract(u)); }, s.fromBigInteger = function (u) { return s.fromInteger(parseInt(u.toString(), 10)); }, s.prototype.mask = function (u) { return u === void 0 && (u = this.subnetMask), this.getBitsBase2(0, u); }, s.prototype.getBitsBase2 = function (u, i) { return this.binaryZeroPad().slice(u, i); }, s.prototype.isInSubnet = r.isInSubnet, s.prototype.isMulticast = function () { return this.isInSubnet(new s("224.0.0.0/4")); }, s.prototype.binaryZeroPad = function () { return c(this.bigInteger().toString(2), t.BITS, "0"); }, E.exports = s;
            }, function (E, m, f) {
                "use strict";
                (function () { var d; function r(K, F, Y) { K != null && (typeof K == "number" ? this.fromNumber(K, F, Y) : F == null && typeof K != "string" ? this.fromString(K, 256) : this.fromString(K, F)); } function e() { return new r(null); } var c = typeof navigator != "undefined"; c && navigator.appName == "Microsoft Internet Explorer" ? (r.prototype.am = function (K, F, Y, $, y, C) { for (var A = 32767 & F, U = F >> 15; --C >= 0;) {
                    var z = 32767 & this[K], w = this[K++] >> 15, O = U * z + w * A;
                    y = ((z = A * z + ((32767 & O) << 15) + Y[$] + (1073741823 & y)) >>> 30) + (O >>> 15) + U * w + (y >>> 30), Y[$++] = 1073741823 & z;
                } return y; }, d = 30) : c && navigator.appName != "Netscape" ? (r.prototype.am = function (K, F, Y, $, y, C) { for (; --C >= 0;) {
                    var A = F * this[K++] + Y[$] + y;
                    y = Math.floor(A / 67108864), Y[$++] = 67108863 & A;
                } return y; }, d = 26) : (r.prototype.am = function (K, F, Y, $, y, C) { for (var A = 16383 & F, U = F >> 14; --C >= 0;) {
                    var z = 16383 & this[K], w = this[K++] >> 14, O = U * z + w * A;
                    y = ((z = A * z + ((16383 & O) << 14) + Y[$] + y) >> 28) + (O >> 14) + U * w, Y[$++] = 268435455 & z;
                } return y; }, d = 28), r.prototype.DB = d, r.prototype.DM = (1 << d) - 1, r.prototype.DV = 1 << d, r.prototype.FV = Math.pow(2, 52), r.prototype.F1 = 52 - d, r.prototype.F2 = 2 * d - 52; var n, t, s = new Array; for (n = "0".charCodeAt(0), t = 0; t <= 9; ++t)
                    s[n++] = t; for (n = "a".charCodeAt(0), t = 10; t < 36; ++t)
                    s[n++] = t; for (n = "A".charCodeAt(0), t = 10; t < 36; ++t)
                    s[n++] = t; function u(K) { return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(K); } function i(K, F) { var Y = s[K.charCodeAt(F)]; return Y !== null && Y !== void 0 ? Y : -1; } function o(K) { var F = e(); return F.fromInt(K), F; } function h(K) { var F, Y = 1; return (F = K >>> 16) != 0 && (K = F, Y += 16), (F = K >> 8) != 0 && (K = F, Y += 8), (F = K >> 4) != 0 && (K = F, Y += 4), (F = K >> 2) != 0 && (K = F, Y += 2), (F = K >> 1) != 0 && (K = F, Y += 1), Y; } function a(K) { this.m = K; } function l(K) { this.m = K, this.mp = K.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << K.DB - 15) - 1, this.mt2 = 2 * K.t; } function p(K, F) { return K & F; } function g(K, F) { return K | F; } function b(K, F) { return K ^ F; } function I(K, F) { return K & ~F; } function v(K) { if (K == 0)
                    return -1; var F = 0; return (65535 & K) == 0 && (K >>= 16, F += 16), (255 & K) == 0 && (K >>= 8, F += 8), (15 & K) == 0 && (K >>= 4, F += 4), (3 & K) == 0 && (K >>= 2, F += 2), (1 & K) == 0 && ++F, F; } function R(K) { for (var F = 0; K != 0;)
                    K &= K - 1, ++F; return F; } function _() { } function k(K) { return K; } function x(K) { this.r2 = e(), this.q3 = e(), r.ONE.dlShiftTo(2 * K.t, this.r2), this.mu = this.r2.divide(K), this.m = K; } a.prototype.convert = function (K) { return K.s < 0 || K.compareTo(this.m) >= 0 ? K.mod(this.m) : K; }, a.prototype.revert = function (K) { return K; }, a.prototype.reduce = function (K) { K.divRemTo(this.m, null, K); }, a.prototype.mulTo = function (K, F, Y) { K.multiplyTo(F, Y), this.reduce(Y); }, a.prototype.sqrTo = function (K, F) { K.squareTo(F), this.reduce(F); }, l.prototype.convert = function (K) { var F = e(); return K.abs().dlShiftTo(this.m.t, F), F.divRemTo(this.m, null, F), K.s < 0 && F.compareTo(r.ZERO) > 0 && this.m.subTo(F, F), F; }, l.prototype.revert = function (K) { var F = e(); return K.copyTo(F), this.reduce(F), F; }, l.prototype.reduce = function (K) { for (; K.t <= this.mt2;)
                    K[K.t++] = 0; for (var F = 0; F < this.m.t; ++F) {
                    var Y = 32767 & K[F], $ = Y * this.mpl + ((Y * this.mph + (K[F] >> 15) * this.mpl & this.um) << 15) & K.DM;
                    for (K[Y = F + this.m.t] += this.m.am(0, $, K, F, 0, this.m.t); K[Y] >= K.DV;)
                        K[Y] -= K.DV, K[++Y]++;
                } K.clamp(), K.drShiftTo(this.m.t, K), K.compareTo(this.m) >= 0 && K.subTo(this.m, K); }, l.prototype.mulTo = function (K, F, Y) { K.multiplyTo(F, Y), this.reduce(Y); }, l.prototype.sqrTo = function (K, F) { K.squareTo(F), this.reduce(F); }, r.prototype.copyTo = function (K) { for (var F = this.t - 1; F >= 0; --F)
                    K[F] = this[F]; K.t = this.t, K.s = this.s; }, r.prototype.fromInt = function (K) { this.t = 1, this.s = K < 0 ? -1 : 0, K > 0 ? this[0] = K : K < -1 ? this[0] = K + this.DV : this.t = 0; }, r.prototype.fromString = function (K, F) { var Y; if (F == 16)
                    Y = 4;
                else if (F == 8)
                    Y = 3;
                else if (F == 256)
                    Y = 8;
                else if (F == 2)
                    Y = 1;
                else if (F == 32)
                    Y = 5;
                else {
                    if (F != 4)
                        return void this.fromRadix(K, F);
                    Y = 2;
                } this.t = 0, this.s = 0; for (var $ = K.length, y = !1, C = 0; --$ >= 0;) {
                    var A = Y == 8 ? 255 & K[$] : i(K, $);
                    A < 0 ? K.charAt($) == "-" && (y = !0) : (y = !1, C == 0 ? this[this.t++] = A : C + Y > this.DB ? (this[this.t - 1] |= (A & (1 << this.DB - C) - 1) << C, this[this.t++] = A >> this.DB - C) : this[this.t - 1] |= A << C, (C += Y) >= this.DB && (C -= this.DB));
                } Y == 8 && (128 & K[0]) != 0 && (this.s = -1, C > 0 && (this[this.t - 1] |= (1 << this.DB - C) - 1 << C)), this.clamp(), y && r.ZERO.subTo(this, this); }, r.prototype.clamp = function () { for (var K = this.s & this.DM; this.t > 0 && this[this.t - 1] == K;)
                    --this.t; }, r.prototype.dlShiftTo = function (K, F) { var Y; for (Y = this.t - 1; Y >= 0; --Y)
                    F[Y + K] = this[Y]; for (Y = K - 1; Y >= 0; --Y)
                    F[Y] = 0; F.t = this.t + K, F.s = this.s; }, r.prototype.drShiftTo = function (K, F) { for (var Y = K; Y < this.t; ++Y)
                    F[Y - K] = this[Y]; F.t = Math.max(this.t - K, 0), F.s = this.s; }, r.prototype.lShiftTo = function (K, F) { var Y, $ = K % this.DB, y = this.DB - $, C = (1 << y) - 1, A = Math.floor(K / this.DB), U = this.s << $ & this.DM; for (Y = this.t - 1; Y >= 0; --Y)
                    F[Y + A + 1] = this[Y] >> y | U, U = (this[Y] & C) << $; for (Y = A - 1; Y >= 0; --Y)
                    F[Y] = 0; F[A] = U, F.t = this.t + A + 1, F.s = this.s, F.clamp(); }, r.prototype.rShiftTo = function (K, F) { F.s = this.s; var Y = Math.floor(K / this.DB); if (Y >= this.t)
                    F.t = 0;
                else {
                    var $ = K % this.DB, y = this.DB - $, C = (1 << $) - 1;
                    F[0] = this[Y] >> $;
                    for (var A = Y + 1; A < this.t; ++A)
                        F[A - Y - 1] |= (this[A] & C) << y, F[A - Y] = this[A] >> $;
                    $ > 0 && (F[this.t - Y - 1] |= (this.s & C) << y), F.t = this.t - Y, F.clamp();
                } }, r.prototype.subTo = function (K, F) { for (var Y = 0, $ = 0, y = Math.min(K.t, this.t); Y < y;)
                    $ += this[Y] - K[Y], F[Y++] = $ & this.DM, $ >>= this.DB; if (K.t < this.t) {
                    for ($ -= K.s; Y < this.t;)
                        $ += this[Y], F[Y++] = $ & this.DM, $ >>= this.DB;
                    $ += this.s;
                }
                else {
                    for ($ += this.s; Y < K.t;)
                        $ -= K[Y], F[Y++] = $ & this.DM, $ >>= this.DB;
                    $ -= K.s;
                } F.s = $ < 0 ? -1 : 0, $ < -1 ? F[Y++] = this.DV + $ : $ > 0 && (F[Y++] = $), F.t = Y, F.clamp(); }, r.prototype.multiplyTo = function (K, F) { var Y = this.abs(), $ = K.abs(), y = Y.t; for (F.t = y + $.t; --y >= 0;)
                    F[y] = 0; for (y = 0; y < $.t; ++y)
                    F[y + Y.t] = Y.am(0, $[y], F, y, 0, Y.t); F.s = 0, F.clamp(), this.s != K.s && r.ZERO.subTo(F, F); }, r.prototype.squareTo = function (K) { for (var F = this.abs(), Y = K.t = 2 * F.t; --Y >= 0;)
                    K[Y] = 0; for (Y = 0; Y < F.t - 1; ++Y) {
                    var $ = F.am(Y, F[Y], K, 2 * Y, 0, 1);
                    (K[Y + F.t] += F.am(Y + 1, 2 * F[Y], K, 2 * Y + 1, $, F.t - Y - 1)) >= F.DV && (K[Y + F.t] -= F.DV, K[Y + F.t + 1] = 1);
                } K.t > 0 && (K[K.t - 1] += F.am(Y, F[Y], K, 2 * Y, 0, 1)), K.s = 0, K.clamp(); }, r.prototype.divRemTo = function (K, F, Y) { var $ = K.abs(); if (!($.t <= 0)) {
                    var y = this.abs();
                    if (y.t < $.t)
                        return F != null && F.fromInt(0), void (Y != null && this.copyTo(Y));
                    Y == null && (Y = e());
                    var C = e(), A = this.s, U = K.s, z = this.DB - h($[$.t - 1]);
                    z > 0 ? ($.lShiftTo(z, C), y.lShiftTo(z, Y)) : ($.copyTo(C), y.copyTo(Y));
                    var w = C.t, O = C[w - 1];
                    if (O != 0) {
                        var q = O * (1 << this.F1) + (w > 1 ? C[w - 2] >> this.F2 : 0), H = this.FV / q, V = (1 << this.F1) / q, J = 1 << this.F2, Z = Y.t, tt = Z - w, nt = F !== null && F !== void 0 ? F : e();
                        for (C.dlShiftTo(tt, nt), Y.compareTo(nt) >= 0 && (Y[Y.t++] = 1, Y.subTo(nt, Y)), r.ONE.dlShiftTo(w, nt), nt.subTo(C, C); C.t < w;)
                            C[C.t++] = 0;
                        for (; --tt >= 0;) {
                            var rt = Y[--Z] == O ? this.DM : Math.floor(Y[Z] * H + (Y[Z - 1] + J) * V);
                            if ((Y[Z] += C.am(0, rt, Y, tt, 0, w)) < rt)
                                for (C.dlShiftTo(tt, nt), Y.subTo(nt, Y); Y[Z] < --rt;)
                                    Y.subTo(nt, Y);
                        }
                        F != null && (Y.drShiftTo(w, F), A != U && r.ZERO.subTo(F, F)), Y.t = w, Y.clamp(), z > 0 && Y.rShiftTo(z, Y), A < 0 && r.ZERO.subTo(Y, Y);
                    }
                } }, r.prototype.invDigit = function () { if (this.t < 1)
                    return 0; var K = this[0]; if ((1 & K) == 0)
                    return 0; var F = 3 & K; return (F = (F = (F = (F = F * (2 - (15 & K) * F) & 15) * (2 - (255 & K) * F) & 255) * (2 - ((65535 & K) * F & 65535)) & 65535) * (2 - K * F % this.DV) % this.DV) > 0 ? this.DV - F : -F; }, r.prototype.isEven = function () { return (this.t > 0 ? 1 & this[0] : this.s) == 0; }, r.prototype.exp = function (K, F) { if (K > 4294967295 || K < 1)
                    return r.ONE; var Y = e(), $ = e(), y = F.convert(this), C = h(K) - 1; for (y.copyTo(Y); --C >= 0;)
                    if (F.sqrTo(Y, $), (K & 1 << C) > 0)
                        F.mulTo($, y, Y);
                    else {
                        var A = Y;
                        Y = $, $ = A;
                    } return F.revert(Y); }, r.prototype.toString = function (K) { if (this.s < 0)
                    return "-" + this.negate().toString(K); var F; if (K == 16)
                    F = 4;
                else if (K == 8)
                    F = 3;
                else if (K == 2)
                    F = 1;
                else if (K == 32)
                    F = 5;
                else {
                    if (K != 4)
                        return this.toRadix(K);
                    F = 2;
                } var Y, $ = (1 << F) - 1, y = !1, C = "", A = this.t, U = this.DB - A * this.DB % F; if (A-- > 0)
                    for (U < this.DB && (Y = this[A] >> U) > 0 && (y = !0, C = u(Y)); A >= 0;)
                        U < F ? (Y = (this[A] & (1 << U) - 1) << F - U, Y |= this[--A] >> (U += this.DB - F)) : (Y = this[A] >> (U -= F) & $, U <= 0 && (U += this.DB, --A)), Y > 0 && (y = !0), y && (C += u(Y)); return y ? C : "0"; }, r.prototype.negate = function () { var K = e(); return r.ZERO.subTo(this, K), K; }, r.prototype.abs = function () { return this.s < 0 ? this.negate() : this; }, r.prototype.compareTo = function (K) { var F = this.s - K.s; if (F != 0)
                    return F; var Y = this.t; if ((F = Y - K.t) != 0)
                    return this.s < 0 ? -F : F; for (; --Y >= 0;)
                    if ((F = this[Y] - K[Y]) != 0)
                        return F; return 0; }, r.prototype.bitLength = function () { return this.t <= 0 ? 0 : this.DB * (this.t - 1) + h(this[this.t - 1] ^ this.s & this.DM); }, r.prototype.mod = function (K) { var F = e(); return this.abs().divRemTo(K, null, F), this.s < 0 && F.compareTo(r.ZERO) > 0 && K.subTo(F, F), F; }, r.prototype.modPowInt = function (K, F) { var Y; return Y = K < 256 || F.isEven() ? new a(F) : new l(F), this.exp(K, Y); }, r.ZERO = o(0), r.ONE = o(1), _.prototype.convert = k, _.prototype.revert = k, _.prototype.mulTo = function (K, F, Y) { K.multiplyTo(F, Y); }, _.prototype.sqrTo = function (K, F) { K.squareTo(F); }, x.prototype.convert = function (K) { if (K.s < 0 || K.t > 2 * this.m.t)
                    return K.mod(this.m); if (K.compareTo(this.m) < 0)
                    return K; var F = e(); return K.copyTo(F), this.reduce(F), F; }, x.prototype.revert = function (K) { return K; }, x.prototype.reduce = function (K) { for (K.drShiftTo(this.m.t - 1, this.r2), K.t > this.m.t + 1 && (K.t = this.m.t + 1, K.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); K.compareTo(this.r2) < 0;)
                    K.dAddOffset(1, this.m.t + 1); for (K.subTo(this.r2, K); K.compareTo(this.m) >= 0;)
                    K.subTo(this.m, K); }, x.prototype.mulTo = function (K, F, Y) { K.multiplyTo(F, Y), this.reduce(Y); }, x.prototype.sqrTo = function (K, F) { K.squareTo(F), this.reduce(F); }; var M, N, S, T = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], B = (1 << 26) / T[T.length - 1]; function P() { var K; K = new Date().getTime(), N[S++] ^= 255 & K, N[S++] ^= K >> 8 & 255, N[S++] ^= K >> 16 & 255, N[S++] ^= K >> 24 & 255, S >= Q && (S -= Q); } if (r.prototype.chunkSize = function (K) { return Math.floor(Math.LN2 * this.DB / Math.log(K)); }, r.prototype.toRadix = function (K) { if (K == null && (K = 10), this.signum() == 0 || K < 2 || K > 36)
                    return "0"; var F = this.chunkSize(K), Y = Math.pow(K, F), $ = o(Y), y = e(), C = e(), A = ""; for (this.divRemTo($, y, C); y.signum() > 0;)
                    A = (Y + C.intValue()).toString(K).substr(1) + A, y.divRemTo($, y, C); return C.intValue().toString(K) + A; }, r.prototype.fromRadix = function (K, F) { this.fromInt(0), F == null && (F = 10); for (var Y = this.chunkSize(F), $ = Math.pow(F, Y), y = !1, C = 0, A = 0, U = 0; U < K.length; ++U) {
                    var z = i(K, U);
                    z < 0 ? K.charAt(U) == "-" && this.signum() == 0 && (y = !0) : (A = F * A + z, ++C >= Y && (this.dMultiply($), this.dAddOffset(A, 0), C = 0, A = 0));
                } C > 0 && (this.dMultiply(Math.pow(F, C)), this.dAddOffset(A, 0)), y && r.ZERO.subTo(this, this); }, r.prototype.fromNumber = function (K, F, Y) { if (typeof F == "number")
                    if (K < 2)
                        this.fromInt(1);
                    else
                        for (this.fromNumber(K, Y), this.testBit(K - 1) || this.bitwiseTo(r.ONE.shiftLeft(K - 1), g, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(F);)
                            this.dAddOffset(2, 0), this.bitLength() > K && this.subTo(r.ONE.shiftLeft(K - 1), this);
                else {
                    var $ = new Array, y = 7 & K;
                    $.length = 1 + (K >> 3), F.nextBytes($), y > 0 ? $[0] &= (1 << y) - 1 : $[0] = 0, this.fromString($, 256);
                } }, r.prototype.bitwiseTo = function (K, F, Y) { var $, y, C = Math.min(K.t, this.t); for ($ = 0; $ < C; ++$)
                    Y[$] = F(this[$], K[$]); if (K.t < this.t) {
                    for (y = K.s & this.DM, $ = C; $ < this.t; ++$)
                        Y[$] = F(this[$], y);
                    Y.t = this.t;
                }
                else {
                    for (y = this.s & this.DM, $ = C; $ < K.t; ++$)
                        Y[$] = F(y, K[$]);
                    Y.t = K.t;
                } Y.s = F(this.s, K.s), Y.clamp(); }, r.prototype.changeBit = function (K, F) { var Y = r.ONE.shiftLeft(K); return this.bitwiseTo(Y, F, Y), Y; }, r.prototype.addTo = function (K, F) { for (var Y = 0, $ = 0, y = Math.min(K.t, this.t); Y < y;)
                    $ += this[Y] + K[Y], F[Y++] = $ & this.DM, $ >>= this.DB; if (K.t < this.t) {
                    for ($ += K.s; Y < this.t;)
                        $ += this[Y], F[Y++] = $ & this.DM, $ >>= this.DB;
                    $ += this.s;
                }
                else {
                    for ($ += this.s; Y < K.t;)
                        $ += K[Y], F[Y++] = $ & this.DM, $ >>= this.DB;
                    $ += K.s;
                } F.s = $ < 0 ? -1 : 0, $ > 0 ? F[Y++] = $ : $ < -1 && (F[Y++] = this.DV + $), F.t = Y, F.clamp(); }, r.prototype.dMultiply = function (K) { this[this.t] = this.am(0, K - 1, this, 0, 0, this.t), ++this.t, this.clamp(); }, r.prototype.dAddOffset = function (K, F) { if (K != 0) {
                    for (; this.t <= F;)
                        this[this.t++] = 0;
                    for (this[F] += K; this[F] >= this.DV;)
                        this[F] -= this.DV, ++F >= this.t && (this[this.t++] = 0), ++this[F];
                } }, r.prototype.multiplyLowerTo = function (K, F, Y) { var $, y = Math.min(this.t + K.t, F); for (Y.s = 0, Y.t = y; y > 0;)
                    Y[--y] = 0; for ($ = Y.t - this.t; y < $; ++y)
                    Y[y + this.t] = this.am(0, K[y], Y, y, 0, this.t); for ($ = Math.min(K.t, F); y < $; ++y)
                    this.am(0, K[y], Y, y, 0, F - y); Y.clamp(); }, r.prototype.multiplyUpperTo = function (K, F, Y) { --F; var $ = Y.t = this.t + K.t - F; for (Y.s = 0; --$ >= 0;)
                    Y[$] = 0; for ($ = Math.max(F - this.t, 0); $ < K.t; ++$)
                    Y[this.t + $ - F] = this.am(F - $, K[$], Y, 0, 0, this.t + $ - F); Y.clamp(), Y.drShiftTo(1, Y); }, r.prototype.modInt = function (K) { if (K <= 0)
                    return 0; var F = this.DV % K, Y = this.s < 0 ? K - 1 : 0; if (this.t > 0)
                    if (F == 0)
                        Y = this[0] % K;
                    else
                        for (var $ = this.t - 1; $ >= 0; --$)
                            Y = (F * Y + this[$]) % K; return Y; }, r.prototype.millerRabin = function (K) { var F = this.subtract(r.ONE), Y = F.getLowestSetBit(); if (Y <= 0)
                    return !1; var $ = F.shiftRight(Y); (K = K + 1 >> 1) > T.length && (K = T.length); for (var y = e(), C = 0; C < K; ++C) {
                    y.fromInt(T[Math.floor(Math.random() * T.length)]);
                    var A = y.modPow($, this);
                    if (A.compareTo(r.ONE) != 0 && A.compareTo(F) != 0) {
                        for (var U = 1; U++ < Y && A.compareTo(F) != 0;)
                            if ((A = A.modPowInt(2, this)).compareTo(r.ONE) == 0)
                                return !1;
                        if (A.compareTo(F) != 0)
                            return !1;
                    }
                } return !0; }, r.prototype.clone = function () { var K = e(); return this.copyTo(K), K; }, r.prototype.intValue = function () { if (this.s < 0) {
                    if (this.t == 1)
                        return this[0] - this.DV;
                    if (this.t == 0)
                        return -1;
                }
                else {
                    if (this.t == 1)
                        return this[0];
                    if (this.t == 0)
                        return 0;
                } return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0]; }, r.prototype.byteValue = function () { return this.t == 0 ? this.s : this[0] << 24 >> 24; }, r.prototype.shortValue = function () { return this.t == 0 ? this.s : this[0] << 16 >> 16; }, r.prototype.signum = function () { return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1; }, r.prototype.toByteArray = function () { var K = this.t, F = new Array; F[0] = this.s; var Y, $ = this.DB - K * this.DB % 8, y = 0; if (K-- > 0)
                    for ($ < this.DB && (Y = this[K] >> $) != (this.s & this.DM) >> $ && (F[y++] = Y | this.s << this.DB - $); K >= 0;)
                        $ < 8 ? (Y = (this[K] & (1 << $) - 1) << 8 - $, Y |= this[--K] >> ($ += this.DB - 8)) : (Y = this[K] >> ($ -= 8) & 255, $ <= 0 && ($ += this.DB, --K)), (128 & Y) != 0 && (Y |= -256), y == 0 && (128 & this.s) != (128 & Y) && ++y, (y > 0 || Y != this.s) && (F[y++] = Y); return F; }, r.prototype.equals = function (K) { return this.compareTo(K) == 0; }, r.prototype.min = function (K) { return this.compareTo(K) < 0 ? this : K; }, r.prototype.max = function (K) { return this.compareTo(K) > 0 ? this : K; }, r.prototype.and = function (K) { var F = e(); return this.bitwiseTo(K, p, F), F; }, r.prototype.or = function (K) { var F = e(); return this.bitwiseTo(K, g, F), F; }, r.prototype.xor = function (K) { var F = e(); return this.bitwiseTo(K, b, F), F; }, r.prototype.andNot = function (K) { var F = e(); return this.bitwiseTo(K, I, F), F; }, r.prototype.not = function () { for (var K = e(), F = 0; F < this.t; ++F)
                    K[F] = this.DM & ~this[F]; return K.t = this.t, K.s = ~this.s, K; }, r.prototype.shiftLeft = function (K) { var F = e(); return K < 0 ? this.rShiftTo(-K, F) : this.lShiftTo(K, F), F; }, r.prototype.shiftRight = function (K) { var F = e(); return K < 0 ? this.lShiftTo(-K, F) : this.rShiftTo(K, F), F; }, r.prototype.getLowestSetBit = function () { for (var K = 0; K < this.t; ++K)
                    if (this[K] != 0)
                        return K * this.DB + v(this[K]); return this.s < 0 ? this.t * this.DB : -1; }, r.prototype.bitCount = function () { for (var K = 0, F = this.s & this.DM, Y = 0; Y < this.t; ++Y)
                    K += R(this[Y] ^ F); return K; }, r.prototype.testBit = function (K) { var F = Math.floor(K / this.DB); return F >= this.t ? this.s != 0 : (this[F] & 1 << K % this.DB) != 0; }, r.prototype.setBit = function (K) { return this.changeBit(K, g); }, r.prototype.clearBit = function (K) { return this.changeBit(K, I); }, r.prototype.flipBit = function (K) { return this.changeBit(K, b); }, r.prototype.add = function (K) { var F = e(); return this.addTo(K, F), F; }, r.prototype.subtract = function (K) { var F = e(); return this.subTo(K, F), F; }, r.prototype.multiply = function (K) { var F = e(); return this.multiplyTo(K, F), F; }, r.prototype.divide = function (K) { var F = e(); return this.divRemTo(K, F, null), F; }, r.prototype.remainder = function (K) { var F = e(); return this.divRemTo(K, null, F), F; }, r.prototype.divideAndRemainder = function (K) { var F = e(), Y = e(); return this.divRemTo(K, F, Y), new Array(F, Y); }, r.prototype.modPow = function (K, F) { var Y, $, y = K.bitLength(), C = o(1); if (y <= 0)
                    return C; Y = y < 18 ? 1 : y < 48 ? 3 : y < 144 ? 4 : y < 768 ? 5 : 6, $ = y < 8 ? new a(F) : F.isEven() ? new x(F) : new l(F); var A = new Array, U = 3, z = Y - 1, w = (1 << Y) - 1; if (A[1] = $.convert(this), Y > 1) {
                    var O = e();
                    for ($.sqrTo(A[1], O); U <= w;)
                        A[U] = e(), $.mulTo(O, A[U - 2], A[U]), U += 2;
                } var q, H, V = K.t - 1, J = !0, Z = e(); for (y = h(K[V]) - 1; V >= 0;) {
                    for (y >= z ? q = K[V] >> y - z & w : (q = (K[V] & (1 << y + 1) - 1) << z - y, V > 0 && (q |= K[V - 1] >> this.DB + y - z)), U = Y; (1 & q) == 0;)
                        q >>= 1, --U;
                    if ((y -= U) < 0 && (y += this.DB, --V), J)
                        A[q].copyTo(C), J = !1;
                    else {
                        for (; U > 1;)
                            $.sqrTo(C, Z), $.sqrTo(Z, C), U -= 2;
                        U > 0 ? $.sqrTo(C, Z) : (H = C, C = Z, Z = H), $.mulTo(Z, A[q], C);
                    }
                    for (; V >= 0 && (K[V] & 1 << y) == 0;)
                        $.sqrTo(C, Z), H = C, C = Z, Z = H, --y < 0 && (y = this.DB - 1, --V);
                } return $.revert(C); }, r.prototype.modInverse = function (K) { var F = K.isEven(); if (this.isEven() && F || K.signum() == 0)
                    return r.ZERO; for (var Y = K.clone(), $ = this.clone(), y = o(1), C = o(0), A = o(0), U = o(1); Y.signum() != 0;) {
                    for (; Y.isEven();)
                        Y.rShiftTo(1, Y), F ? (y.isEven() && C.isEven() || (y.addTo(this, y), C.subTo(K, C)), y.rShiftTo(1, y)) : C.isEven() || C.subTo(K, C), C.rShiftTo(1, C);
                    for (; $.isEven();)
                        $.rShiftTo(1, $), F ? (A.isEven() && U.isEven() || (A.addTo(this, A), U.subTo(K, U)), A.rShiftTo(1, A)) : U.isEven() || U.subTo(K, U), U.rShiftTo(1, U);
                    Y.compareTo($) >= 0 ? (Y.subTo($, Y), F && y.subTo(A, y), C.subTo(U, C)) : ($.subTo(Y, $), F && A.subTo(y, A), U.subTo(C, U));
                } return $.compareTo(r.ONE) != 0 ? r.ZERO : U.compareTo(K) >= 0 ? U.subtract(K) : U.signum() < 0 ? (U.addTo(K, U), U.signum() < 0 ? U.add(K) : U) : U; }, r.prototype.pow = function (K) { return this.exp(K, new _); }, r.prototype.gcd = function (K) { var F = this.s < 0 ? this.negate() : this.clone(), Y = K.s < 0 ? K.negate() : K.clone(); if (F.compareTo(Y) < 0) {
                    var $ = F;
                    F = Y, Y = $;
                } var y = F.getLowestSetBit(), C = Y.getLowestSetBit(); if (C < 0)
                    return F; for (y < C && (C = y), C > 0 && (F.rShiftTo(C, F), Y.rShiftTo(C, Y)); F.signum() > 0;)
                    (y = F.getLowestSetBit()) > 0 && F.rShiftTo(y, F), (y = Y.getLowestSetBit()) > 0 && Y.rShiftTo(y, Y), F.compareTo(Y) >= 0 ? (F.subTo(Y, F), F.rShiftTo(1, F)) : (Y.subTo(F, Y), Y.rShiftTo(1, Y)); return C > 0 && Y.lShiftTo(C, Y), Y; }, r.prototype.isProbablePrime = function (K) { var F, Y = this.abs(); if (Y.t == 1 && Y[0] <= T[T.length - 1]) {
                    for (F = 0; F < T.length; ++F)
                        if (Y[0] == T[F])
                            return !0;
                    return !1;
                } if (Y.isEven())
                    return !1; for (F = 1; F < T.length;) {
                    for (var $ = T[F], y = F + 1; y < T.length && $ < B;)
                        $ *= T[y++];
                    for ($ = Y.modInt($); F < y;)
                        if ($ % T[F++] == 0)
                            return !1;
                } return Y.millerRabin(K); }, r.prototype.square = function () { var K = e(); return this.squareTo(K), K; }, r.prototype.Barrett = x, N == null) {
                    var L;
                    if (N = new Array, S = 0, typeof window != "undefined" && window.crypto) {
                        if (window.crypto.getRandomValues) {
                            var j = new Uint8Array(32);
                            for (window.crypto.getRandomValues(j), L = 0; L < 32; ++L)
                                N[S++] = j[L];
                        }
                        else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
                            var D = window.crypto.random(32);
                            for (L = 0; L < D.length; ++L)
                                N[S++] = 255 & D.charCodeAt(L);
                        }
                    }
                    for (; S < Q;)
                        L = Math.floor(65536 * Math.random()), N[S++] = L >>> 8, N[S++] = 255 & L;
                    S = 0, P();
                } function G() { if (M == null) {
                    for (P(), (M = new X).init(N), S = 0; S < N.length; ++S)
                        N[S] = 0;
                    S = 0;
                } return M.next(); } function W() { } function X() { this.i = 0, this.j = 0, this.S = new Array; } W.prototype.nextBytes = function (K) { var F; for (F = 0; F < K.length; ++F)
                    K[F] = G(); }, X.prototype.init = function (K) { var F, Y, $; for (F = 0; F < 256; ++F)
                    this.S[F] = F; for (Y = 0, F = 0; F < 256; ++F)
                    Y = Y + this.S[F] + K[F % K.length] & 255, $ = this.S[F], this.S[F] = this.S[Y], this.S[Y] = $; this.i = 0, this.j = 0; }, X.prototype.next = function () { var K; return this.i = this.i + 1 & 255, this.j = this.j + this.S[this.i] & 255, K = this.S[this.i], this.S[this.i] = this.S[this.j], this.S[this.j] = K, this.S[K + this.S[this.i] & 255]; }; var Q = 256; E.exports = { default: r, BigInteger: r, SecureRandom: W }; }).call(void 0);
            }, function (E, m, f) {
                "use strict";
                var d = m.falseIfInvalid = function (r) { return function () { return !!this.valid && r.apply(this, arguments); }; };
                m.isInSubnet = d(function (r) { return !(this.subnetMask < r.subnetMask) && this.mask(r.subnetMask) === r.mask(); }), m.isCorrect = function (r) { return d(function () { return this.addressMinusSuffix === this.correctForm() && (this.subnetMask === r && !this.parsedSubnet || this.parsedSubnet === String(this.subnetMask)); }); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r, e = /^\s+|\s+$/g, c = /^[-+]0x[0-9a-f]+$/i, n = /^0b[01]+$/i, t = /^0o[0-7]+$/i, s = "[\\ud800-\\udfff]", u = "[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", i = "\\ud83c[\\udffb-\\udfff]", o = "[^\\ud800-\\udfff]", h = "(?:\\ud83c[\\udde6-\\uddff]){2}", a = "[\\ud800-\\udbff][\\udc00-\\udfff]", l = "(?:" + u + "|" + i + ")?", p = "[\\ufe0e\\ufe0f]?" + l + ("(?:\\u200d(?:" + [o, h, a].join("|") + ")[\\ufe0e\\ufe0f]?" + l + ")*"), g = "(?:" + [o + u + "?", u, h, a, s].join("|") + ")", b = RegExp(i + "(?=" + i + ")|" + g + p, "g"), I = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"), v = parseInt, R = typeof d == "object" && d && d.Object === Object && d, _ = typeof self == "object" && self && self.Object === Object && self, k = R || _ || Function("return this")(), x = (r = "length", function (Y) { return Y == null ? void 0 : Y[r]; }); function M(Y) { return I.test(Y); } function N(Y) { return M(Y) ? function ($) { for (var y = b.lastIndex = 0; b.test($);)
                    y++; return y; }(Y) : x(Y); } function S(Y) { return M(Y) ? function ($) { return $.match(b) || []; }(Y) : function ($) { return $.split(""); }(Y); } var T = Object.prototype.toString, B = k.Symbol, P = Math.ceil, L = Math.floor, j = B ? B.prototype : void 0, D = j ? j.toString : void 0; function G(Y, $) { var y = ""; if (!Y || $ < 1 || $ > 9007199254740991)
                    return y; do
                    $ % 2 && (y += Y), ($ = L($ / 2)) && (Y += Y);
                while ($); return y; } function W(Y) { if (typeof Y == "string")
                    return Y; if (K(Y))
                    return D ? D.call(Y) : ""; var $ = Y + ""; return $ == "0" && 1 / Y == -1 / 0 ? "-0" : $; } function X(Y, $, y) { var C = Y.length; return y = y === void 0 ? C : y, !$ && y >= C ? Y : function (A, U, z) { var w = -1, O = A.length; U < 0 && (U = -U > O ? 0 : O + U), (z = z > O ? O : z) < 0 && (z += O), O = U > z ? 0 : z - U >>> 0, U >>>= 0; for (var q = Array(O); ++w < O;)
                    q[w] = A[w + U]; return q; }(Y, $, y); } function Q(Y) { var $ = typeof Y; return !!Y && ($ == "object" || $ == "function"); } function K(Y) { return typeof Y == "symbol" || function ($) { return !!$ && typeof $ == "object"; }(Y) && T.call(Y) == "[object Symbol]"; } function F(Y) { return Y ? (Y = function ($) { if (typeof $ == "number")
                    return $; if (K($))
                    return NaN; if (Q($)) {
                    var y = typeof $.valueOf == "function" ? $.valueOf() : $;
                    $ = Q(y) ? y + "" : y;
                } if (typeof $ != "string")
                    return $ === 0 ? $ : +$; $ = $.replace(e, ""); var C = n.test($); return C || t.test($) ? v($.slice(2), C ? 2 : 8) : c.test($) ? NaN : +$; }(Y)) === 1 / 0 || Y === -1 / 0 ? 17976931348623157e292 * (Y < 0 ? -1 : 1) : Y == Y ? Y : 0 : Y === 0 ? Y : 0; } E.exports = function (Y, $, y) { var C; Y = (C = Y) == null ? "" : W(C); var A = ($ = function (U) { var z = F(U), w = z % 1; return z == z ? w ? z - w : z : 0; }($)) ? N(Y) : 0; return $ && A < $ ? function (U, z) { var w = (z = z === void 0 ? " " : W(z)).length; if (w < 2)
                    return w ? G(z, U) : z; var O = G(z, P(U / N(z))); return M(z) ? X(S(O), 0, U).join("") : O.slice(0, U); }($ - A, y) + Y : Y; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = /^\s+|\s+$/g, e = /^[-+]0x[0-9a-f]+$/i, c = /^0b[01]+$/i, n = /^0o[0-7]+$/i, t = /^(?:0|[1-9]\d*)$/, s = parseInt, u = typeof d == "object" && d && d.Object === Object && d, i = typeof self == "object" && self && self.Object === Object && self, o = u || i || Function("return this")(), h = Object.prototype.toString, a = o.Symbol, l = Math.floor, p = a ? a.prototype : void 0, g = p ? p.toString : void 0; function b(k, x, M) { if (!I(M))
                    return !1; var N = typeof x; return !!(N == "number" ? function (S) { return S != null && function (T) { return typeof T == "number" && T > -1 && T % 1 == 0 && T <= 9007199254740991; }(S.length) && !function (T) { var B = I(T) ? h.call(T) : ""; return B == "[object Function]" || B == "[object GeneratorFunction]"; }(S); }(M) && function (S, T) { return !!(T = T !== null && T !== void 0 ? T : 9007199254740991) && (typeof S == "number" || t.test(S)) && S > -1 && S % 1 == 0 && S < T; }(x, M.length) : N == "string" && x in M) && function (S, T) { return S === T || S != S && T != T; }(M[x], k); } function I(k) { var x = typeof k; return !!k && (x == "object" || x == "function"); } function v(k) { return typeof k == "symbol" || function (x) { return !!x && typeof x == "object"; }(k) && h.call(k) == "[object Symbol]"; } function R(k) { return k ? (k = function (x) { if (typeof x == "number")
                    return x; if (v(x))
                    return NaN; if (I(x)) {
                    var M = typeof x.valueOf == "function" ? x.valueOf() : x;
                    x = I(M) ? M + "" : M;
                } if (typeof x != "string")
                    return x === 0 ? x : +x; x = x.replace(r, ""); var N = c.test(x); return N || n.test(x) ? s(x.slice(2), N ? 2 : 8) : e.test(x) ? NaN : +x; }(k)) === 1 / 0 || k === -1 / 0 ? 17976931348623157e292 * (k < 0 ? -1 : 1) : k == k ? k : 0 : k === 0 ? k : 0; } function _(k) { return k == null ? "" : function (x) { if (typeof x == "string")
                    return x; if (v(x))
                    return g ? g.call(x) : ""; var M = x + ""; return M == "0" && 1 / x == -1 / 0 ? "-0" : M; }(k); } E.exports = function (k, x, M) { var N, S; return (M ? b(k, x, M) : x === void 0) ? x = 1 : (N = R(x), S = N % 1, x = N == N ? S ? N - S : N : 0), function (T, B) { var P = ""; if (!T || B < 1 || B > 9007199254740991)
                    return P; do
                    B % 2 && (P += T), (B = l(B / 2)) && (T += T);
                while (B); return P; }(_(k), x); }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                var d = f(100).sprintf, r = m.spanAllZeroes = function (c) { return c.replace(/(0+)/g, '<span class="zero">$1</span>'); };
                function e(c) { return c.replace(/^(0+)/, '<span class="zero">$1</span>'); }
                m.spanAll = function (c, n) { return n === void 0 && (n = 0), c.split("").map(function (t, s) { return d('<span class="digit value-%s position-%d">%s</span>', t, s + n, r(t)); }).join(""); }, m.spanLeadingZeroes = function (c) { return c.split(":").map(function (n) { return e(n); }).join(":"); }, m.simpleGroup = function (c, n) { var t = c.split(":"); return n || (n = 0), t.map(function (s, u) { return /group-v4/.test(s) ? s : d('<span class="hover-group group-%d">%s</span>', u + n, e(s)); }).join(":"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(1)("simple-peer"), r = f(950), e = f(356), c = f(951), n = f(959), t = f(0);
                function s(i) { return i.replace(/a=ice-options:trickle\s\n/g, ""); }
                class u extends c.Duplex {
                    constructor(o) { if (super(o = Object.assign({ allowHalfOpen: !1 }, o)), this._id = e(4).toString("hex").slice(0, 7), this._debug("new peer %o", o), this.channelName = o.initiator ? o.channelName || e(20).toString("hex") : null, this.initiator = o.initiator || !1, this.channelConfig = o.channelConfig || u.channelConfig, this.negotiated = this.channelConfig.negotiated, this.config = Object.assign({}, u.config, o.config), this.offerOptions = o.offerOptions || {}, this.answerOptions = o.answerOptions || {}, this.sdpTransform = o.sdpTransform || (h => h), this.streams = o.streams || (o.stream ? [o.stream] : []), this.trickle = o.trickle === void 0 || o.trickle, this.allowHalfTrickle = o.allowHalfTrickle !== void 0 && o.allowHalfTrickle, this.iceCompleteTimeout = o.iceCompleteTimeout || 5e3, this._connected = !1, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = o.wrtc && typeof o.wrtc == "object" ? o.wrtc : r(), !this._wrtc)
                        throw typeof window == "undefined" ? t(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT") : t(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT"); this._pcReady = !1, this._channelReady = !1, this._iceComplete = !1, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = !this.negotiated && !this.initiator, this._batchedNegotiation = !1, this._queuedNegotiation = !1, this._sendersAwaitingStable = [], this._senderMap = new Map, this._firstStable = !0, this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null; try {
                        this._pc = new this._wrtc.RTCPeerConnection(this.config);
                    }
                    catch (h) {
                        return void n(() => this.destroy(t(h, "ERR_PC_CONSTRUCTOR")));
                    } this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == "number", this._pc.oniceconnectionstatechange = () => { this._onIceStateChange(); }, this._pc.onicegatheringstatechange = () => { this._onIceStateChange(); }, this._pc.onconnectionstatechange = () => { this._onConnectionStateChange(); }, this._pc.onsignalingstatechange = () => { this._onSignalingStateChange(); }, this._pc.onicecandidate = h => { this._onIceCandidate(h); }, this.initiator || this.negotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = h => { this._setupData(h); }, this.streams && this.streams.forEach(h => { this.addStream(h); }), this._pc.ontrack = h => { this._onTrack(h); }, this.initiator && this._needsNegotiation(), this._onFinishBound = () => { this._onFinish(); }, this.once("finish", this._onFinishBound); }
                    get bufferSize() { return this._channel && this._channel.bufferedAmount || 0; }
                    get connected() { return this._connected && this._channel.readyState === "open"; }
                    address() { return { port: this.localPort, family: this.localFamily, address: this.localAddress }; }
                    signal(o) { if (this.destroyed)
                        throw t(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING"); if (typeof o == "string")
                        try {
                            o = JSON.parse(o);
                        }
                        catch (h) {
                            o = {};
                        } this._debug("signal()"), o.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), o.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(o.transceiverRequest.kind, o.transceiverRequest.init)), o.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(o.candidate) : this._pendingCandidates.push(o.candidate)), o.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(o)).then(() => { this.destroyed || (this._pendingCandidates.forEach(h => { this._addIceCandidate(h); }), this._pendingCandidates = [], this._pc.remoteDescription.type === "offer" && this._createAnswer()); }).catch(h => { this.destroy(t(h, "ERR_SET_REMOTE_DESCRIPTION")); }), o.sdp || o.candidate || o.renegotiate || o.transceiverRequest || this.destroy(t(new Error("signal() called with invalid signal data"), "ERR_SIGNALING")); }
                    _addIceCandidate(o) { var h = new this._wrtc.RTCIceCandidate(o); this._pc.addIceCandidate(h).catch(a => { var l; !h.address || h.address.endsWith(".local") ? (l = "Ignoring unsupported ICE candidate.", console.warn(l)) : this.destroy(t(a, "ERR_ADD_ICE_CANDIDATE")); }); }
                    send(o) { this._channel.send(o); }
                    addTransceiver(o, h) { if (this._debug("addTransceiver()"), this.initiator)
                        try {
                            this._pc.addTransceiver(o, h), this._needsNegotiation();
                        }
                        catch (a) {
                            this.destroy(t(a, "ERR_ADD_TRANSCEIVER"));
                        }
                    else
                        this.emit("signal", { transceiverRequest: { kind: o, init: h } }); }
                    addStream(o) { this._debug("addStream()"), o.getTracks().forEach(h => { this.addTrack(h, o); }); }
                    addTrack(o, h) { this._debug("addTrack()"); var a = this._senderMap.get(o) || new Map, l = a.get(h); if (l)
                        throw l.removed ? t(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED") : t(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED"); l = this._pc.addTrack(o, h), a.set(h, l), this._senderMap.set(o, a), this._needsNegotiation(); }
                    replaceTrack(o, h, a) { this._debug("replaceTrack()"); var l = this._senderMap.get(o), p = l ? l.get(a) : null; if (!p)
                        throw t(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED"); h && this._senderMap.set(h, l), p.replaceTrack != null ? p.replaceTrack(h) : this.destroy(t(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")); }
                    removeTrack(o, h) { this._debug("removeSender()"); var a = this._senderMap.get(o), l = a ? a.get(h) : null; if (!l)
                        throw t(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED"); try {
                        l.removed = !0, this._pc.removeTrack(l);
                    }
                    catch (p) {
                        p.name === "NS_ERROR_UNEXPECTED" ? this._sendersAwaitingStable.push(l) : this.destroy(t(p, "ERR_REMOVE_TRACK"));
                    } this._needsNegotiation(); }
                    removeStream(o) { this._debug("removeSenders()"), o.getTracks().forEach(h => { this.removeTrack(h, o); }); }
                    _needsNegotiation() { this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = !0, n(() => { this._batchedNegotiation = !1, this._debug("starting batched negotiation"), this.negotiate(); })); }
                    negotiate() { this.initiator ? this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => { this._createOffer(); }, 0)) : this._isNegotiating ? (this._queuedNegotiation = !0, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { renegotiate: !0 })), this._isNegotiating = !0; }
                    _destroy(o, h) { if (this._debug("destroy (error: %s)", o && (o.message || o)), this.readable = this.writable = !1, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = !1, this._pcReady = !1, this._channelReady = !1, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                        try {
                            this._channel.close();
                        }
                        catch (a) { }
                        this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
                    } if (this._pc) {
                        try {
                            this._pc.close();
                        }
                        catch (a) { }
                        this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
                    } this._pc = null, this._channel = null, h(o); }
                    _setupData(o) { if (!o.channel)
                        return this.destroy(t(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL")); this._channel = o.channel, this._channel.binaryType = "arraybuffer", typeof this._channel.bufferedAmountLowThreshold == "number" && (this._channel.bufferedAmountLowThreshold = 65536), this.channelName = this._channel.label, this._channel.onmessage = a => { this._onChannelMessage(a); }, this._channel.onbufferedamountlow = () => { this._onChannelBufferedAmountLow(); }, this._channel.onopen = () => { this._onChannelOpen(); }, this._channel.onclose = () => { this._onChannelClose(); }, this._channel.onerror = a => { this.destroy(t(a, "ERR_DATA_CHANNEL")); }; var h = !1; this._closingInterval = setInterval(() => { this._channel && this._channel.readyState === "closing" ? (h && this._onChannelClose(), h = !0) : h = !1; }, 5e3); }
                    _read() { }
                    _write(o, h, a) { if (this.destroyed)
                        return a(t(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL")); if (this._connected) {
                        try {
                            this.send(o);
                        }
                        catch (l) {
                            return this.destroy(t(l, "ERR_DATA_CHANNEL"));
                        }
                        this._channel.bufferedAmount > 65536 ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = a) : a(null);
                    }
                    else
                        this._debug("write before connect"), this._chunk = o, this._cb = a; }
                    _onFinish() { if (this.destroyed)
                        return; const o = () => { setTimeout(() => this.destroy(), 1e3); }; this._connected ? o() : this.once("connect", o); }
                    _startIceCompleteTimeout() { this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => { this._iceComplete || (this._iceComplete = !0, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete")); }, this.iceCompleteTimeout)); }
                    _createOffer() { this.destroyed || this._pc.createOffer(this.offerOptions).then(o => { if (this.destroyed)
                        return; this.trickle || this.allowHalfTrickle || (o.sdp = s(o.sdp)), o.sdp = this.sdpTransform(o.sdp); const h = () => { if (!this.destroyed) {
                        var a = this._pc.localDescription || o;
                        this._debug("signal"), this.emit("signal", { type: a.type, sdp: a.sdp });
                    } }; this._pc.setLocalDescription(o).then(() => { this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? h() : this.once("_iceComplete", h)); }).catch(a => { this.destroy(t(a, "ERR_SET_LOCAL_DESCRIPTION")); }); }).catch(o => { this.destroy(t(o, "ERR_CREATE_OFFER")); }); }
                    _requestMissingTransceivers() { this._pc.getTransceivers && this._pc.getTransceivers().forEach(o => { o.mid || !o.sender.track || o.requested || (o.requested = !0, this.addTransceiver(o.sender.track.kind)); }); }
                    _createAnswer() { this.destroyed || this._pc.createAnswer(this.answerOptions).then(o => { if (this.destroyed)
                        return; this.trickle || this.allowHalfTrickle || (o.sdp = s(o.sdp)), o.sdp = this.sdpTransform(o.sdp); const h = () => { if (!this.destroyed) {
                        var a = this._pc.localDescription || o;
                        this._debug("signal"), this.emit("signal", { type: a.type, sdp: a.sdp }), this.initiator || this._requestMissingTransceivers();
                    } }; this._pc.setLocalDescription(o).then(() => { this.destroyed || (this.trickle || this._iceComplete ? h() : this.once("_iceComplete", h)); }).catch(a => { this.destroy(t(a, "ERR_SET_LOCAL_DESCRIPTION")); }); }).catch(o => { this.destroy(t(o, "ERR_CREATE_ANSWER")); }); }
                    _onConnectionStateChange() { this.destroyed || this._pc.connectionState === "failed" && this.destroy(t(new Error("Connection failed."), "ERR_CONNECTION_FAILURE")); }
                    _onIceStateChange() { if (!this.destroyed) {
                        var o = this._pc.iceConnectionState, h = this._pc.iceGatheringState;
                        this._debug("iceStateChange (connection: %s) (gathering: %s)", o, h), this.emit("iceStateChange", o, h), o !== "connected" && o !== "completed" || (this._pcReady = !0, this._maybeReady()), o === "failed" && this.destroy(t(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), o === "closed" && this.destroy(t(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
                    } }
                    getStats(o) { const h = a => (Object.prototype.toString.call(a.values) === "[object Array]" && a.values.forEach(l => { Object.assign(a, l); }), a); this._pc.getStats.length === 0 || this._isReactNativeWebrtc ? this._pc.getStats().then(a => { var l = []; a.forEach(p => { l.push(h(p)); }), o(null, l); }, a => o(a)) : this._pc.getStats.length > 0 ? this._pc.getStats(a => { if (!this.destroyed) {
                        var l = [];
                        a.result().forEach(p => { var g = {}; p.names().forEach(b => { g[b] = p.stat(b); }), g.id = p.id, g.type = p.type, g.timestamp = p.timestamp, l.push(h(g)); }), o(null, l);
                    } }, a => o(a)) : o(null, []); }
                    _maybeReady() { if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
                        return; this._connecting = !0; const o = () => { this.destroyed || this.getStats((h, a) => { if (this.destroyed)
                        return; h && (a = []); var l = {}, p = {}, g = {}, b = !1; a.forEach(R => { R.type !== "remotecandidate" && R.type !== "remote-candidate" || (l[R.id] = R), R.type !== "localcandidate" && R.type !== "local-candidate" || (p[R.id] = R), R.type !== "candidatepair" && R.type !== "candidate-pair" || (g[R.id] = R); }); const I = R => { b = !0; var _ = p[R.localCandidateId]; _ && (_.ip || _.address) ? (this.localAddress = _.ip || _.address, this.localPort = Number(_.port)) : _ && _.ipAddress ? (this.localAddress = _.ipAddress, this.localPort = Number(_.portNumber)) : typeof R.googLocalAddress == "string" && (_ = R.googLocalAddress.split(":"), this.localAddress = _[0], this.localPort = Number(_[1])), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4"); var k = l[R.remoteCandidateId]; k && (k.ip || k.address) ? (this.remoteAddress = k.ip || k.address, this.remotePort = Number(k.port)) : k && k.ipAddress ? (this.remoteAddress = k.ipAddress, this.remotePort = Number(k.portNumber)) : typeof R.googRemoteAddress == "string" && (k = R.googRemoteAddress.split(":"), this.remoteAddress = k[0], this.remotePort = Number(k[1])), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort); }; if (a.forEach(R => { R.type === "transport" && R.selectedCandidatePairId && I(g[R.selectedCandidatePairId]), (R.type === "googCandidatePair" && R.googActiveConnection === "true" || (R.type === "candidatepair" || R.type === "candidate-pair") && R.selected) && I(R); }), b || Object.keys(g).length && !Object.keys(p).length) {
                        if (this._connecting = !1, this._connected = !0, this._chunk) {
                            try {
                                this.send(this._chunk);
                            }
                            catch (R) {
                                return this.destroy(t(R, "ERR_DATA_CHANNEL"));
                            }
                            this._chunk = null, this._debug('sent chunk from "write before connect"');
                            var v = this._cb;
                            this._cb = null, v(null);
                        }
                        typeof this._channel.bufferedAmountLowThreshold != "number" && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
                    }
                    else
                        setTimeout(o, 100); }); }; o(); }
                    _onInterval() { !this._cb || !this._channel || this._channel.bufferedAmount > 65536 || this._onChannelBufferedAmountLow(); }
                    _onSignalingStateChange() { this.destroyed || (this._pc.signalingState !== "stable" || this._firstStable || (this._isNegotiating = !1, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach(o => { this._pc.removeTrack(o), this._queuedNegotiation = !0; }), this._sendersAwaitingStable = [], this._queuedNegotiation && (this._debug("flushing negotiation queue"), this._queuedNegotiation = !1, this._needsNegotiation()), this._debug("negotiate"), this.emit("negotiate")), this._firstStable = !1, this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState)); }
                    _onIceCandidate(o) { this.destroyed || (o.candidate && this.trickle ? this.emit("signal", { candidate: { candidate: o.candidate.candidate, sdpMLineIndex: o.candidate.sdpMLineIndex, sdpMid: o.candidate.sdpMid } }) : o.candidate || this._iceComplete || (this._iceComplete = !0, this.emit("_iceComplete")), o.candidate && this._startIceCompleteTimeout()); }
                    _onChannelMessage(o) { if (!this.destroyed) {
                        var h = o.data;
                        h instanceof ArrayBuffer && (h = new Uint8Array(h)), this.push(h);
                    } }
                    _onChannelBufferedAmountLow() { if (!this.destroyed && this._cb) {
                        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
                        var o = this._cb;
                        this._cb = null, o(null);
                    } }
                    _onChannelOpen() { this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = !0, this._maybeReady()); }
                    _onChannelClose() { this.destroyed || (this._debug("on channel close"), this.destroy()); }
                    _onTrack(o) { this.destroyed || o.streams.forEach(h => { this._debug("on track"), this.emit("track", o.track, h), this._remoteTracks.push({ track: o.track, stream: h }), this._remoteStreams.some(a => a.id === h.id) || (this._remoteStreams.push(h), n(() => { this.emit("stream", h); })); }); }
                    _debug() { var o = [].slice.call(arguments); o[0] = "[" + this._id + "] " + o[0], d.apply(null, o); }
                }
                u.WEBRTC_SUPPORT = !!r(), u.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, u.channelConfig = {}, E.exports = u;
            }, function (E, m, f) {
                "use strict";
                (function (d, r) {
                    var e = f(312).Buffer, c = d.crypto || d.msCrypto;
                    c && c.getRandomValues ? E.exports = function (n, t) { if (n > 4294967295)
                        throw new RangeError("requested too many random bytes"); var s = e.allocUnsafe(n); if (n > 0)
                        if (n > 65536)
                            for (var u = 0; u < n; u += 65536)
                                c.getRandomValues(s.slice(u, u + 65536));
                        else
                            c.getRandomValues(s); return typeof t == "function" ? r.nextTick(function () { t(null, s); }) : s; } : E.exports = function () {
                        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
                    };
                }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e; E.exports = N, N.ReadableState = M, f(12).EventEmitter; var c = function (y, C) { return y.listeners(C).length; }, n = f(358), t = f(3).Buffer, s = d.Uint8Array || function () { }, u, i = f(952); u = i && i.debuglog ? i.debuglog("stream") : function () { }; var o, h, a, l = f(953), p = f(359), g = f(360).getHighWaterMark, b = f(76).codes, I = b.ERR_INVALID_ARG_TYPE, v = b.ERR_STREAM_PUSH_AFTER_EOF, R = b.ERR_METHOD_NOT_IMPLEMENTED, _ = b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; f(15)(N, n); var k = p.errorOrDestroy, x = ["error", "close", "destroy", "pause", "resume"]; function M(y, C, A) { e = e || f(77), y = y || {}, typeof A != "boolean" && (A = C instanceof e), this.objectMode = !!y.objectMode, A && (this.objectMode = this.objectMode || !!y.readableObjectMode), this.highWaterMark = g(this, y, "readableHighWaterMark", A), this.buffer = new l, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = y.emitClose !== !1, this.autoDestroy = !!y.autoDestroy, this.destroyed = !1, this.defaultEncoding = y.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, y.encoding && (o || (o = f(121).StringDecoder), this.decoder = new o(y.encoding), this.encoding = y.encoding); } function N(y) { if (e = e || f(77), !(this instanceof N))
                    return new N(y); var C = this instanceof e; this._readableState = new M(y, this, C), this.readable = !0, y && (typeof y.read == "function" && (this._read = y.read), typeof y.destroy == "function" && (this._destroy = y.destroy)), n.call(this); } function S(y, C, A, U, z) { u("readableAddChunk", C); var w, O = y._readableState; if (C === null)
                    O.reading = !1, function (q, H) { if (u("onEofChunk"), H.ended)
                        return; if (H.decoder) {
                        var V = H.decoder.end();
                        V && V.length && (H.buffer.push(V), H.length += H.objectMode ? 1 : V.length);
                    } H.ended = !0, H.sync ? P(q) : (H.needReadable = !1, H.emittedReadable || (H.emittedReadable = !0, L(q))); }(y, O);
                else if (z || (w = function (q, H) { var V; J = H, t.isBuffer(J) || J instanceof s || typeof H == "string" || H === void 0 || q.objectMode || (V = new I("chunk", ["string", "Buffer", "Uint8Array"], H)); var J; return V; }(O, C)), w)
                    k(y, w);
                else if (O.objectMode || C && C.length > 0)
                    if (typeof C == "string" || O.objectMode || Object.getPrototypeOf(C) === t.prototype || (C = function (q) { return t.from(q); }(C)), U)
                        O.endEmitted ? k(y, new _) : T(y, O, C, !0);
                    else if (O.ended)
                        k(y, new v);
                    else {
                        if (O.destroyed)
                            return !1;
                        O.reading = !1, O.decoder && !A ? (C = O.decoder.write(C), O.objectMode || C.length !== 0 ? T(y, O, C, !1) : j(y, O)) : T(y, O, C, !1);
                    }
                else
                    U || (O.reading = !1, j(y, O)); return !O.ended && (O.length < O.highWaterMark || O.length === 0); } function T(y, C, A, U) { C.flowing && C.length === 0 && !C.sync ? (C.awaitDrain = 0, y.emit("data", A)) : (C.length += C.objectMode ? 1 : A.length, U ? C.buffer.unshift(A) : C.buffer.push(A), C.needReadable && P(y)), j(y, C); } Object.defineProperty(N.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState !== void 0 && this._readableState.destroyed; }, set: function (y) { this._readableState && (this._readableState.destroyed = y); } }), N.prototype.destroy = p.destroy, N.prototype._undestroy = p.undestroy, N.prototype._destroy = function (y, C) { C(y); }, N.prototype.push = function (y, C) { var A, U = this._readableState; return U.objectMode ? A = !0 : typeof y == "string" && ((C = C || U.defaultEncoding) !== U.encoding && (y = t.from(y, C), C = ""), A = !0), S(this, y, C, !1, A); }, N.prototype.unshift = function (y) { return S(this, y, null, !0, !1); }, N.prototype.isPaused = function () { return this._readableState.flowing === !1; }, N.prototype.setEncoding = function (y) { o || (o = f(121).StringDecoder); var C = new o(y); this._readableState.decoder = C, this._readableState.encoding = this._readableState.decoder.encoding; for (var A = this._readableState.buffer.head, U = ""; A !== null;)
                    U += C.write(A.data), A = A.next; return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this; }; function B(y, C) { return y <= 0 || C.length === 0 && C.ended ? 0 : C.objectMode ? 1 : y != y ? C.flowing && C.length ? C.buffer.head.data.length : C.length : (y > C.highWaterMark && (C.highWaterMark = function (A) { return A >= 1073741824 ? A = 1073741824 : (A--, A |= A >>> 1, A |= A >>> 2, A |= A >>> 4, A |= A >>> 8, A |= A >>> 16, A++), A; }(y)), y <= C.length ? y : C.ended ? C.length : (C.needReadable = !0, 0)); } function P(y) { var C = y._readableState; u("emitReadable", C.needReadable, C.emittedReadable), C.needReadable = !1, C.emittedReadable || (u("emitReadable", C.flowing), C.emittedReadable = !0, r.nextTick(L, y)); } function L(y) { var C = y._readableState; u("emitReadable_", C.destroyed, C.length, C.ended), C.destroyed || !C.length && !C.ended || (y.emit("readable"), C.emittedReadable = !1), C.needReadable = !C.flowing && !C.ended && C.length <= C.highWaterMark, Q(y); } function j(y, C) { C.readingMore || (C.readingMore = !0, r.nextTick(D, y, C)); } function D(y, C) { for (; !C.reading && !C.ended && (C.length < C.highWaterMark || C.flowing && C.length === 0);) {
                    var A = C.length;
                    if (u("maybeReadMore read 0"), y.read(0), A === C.length)
                        break;
                } C.readingMore = !1; } function G(y) { var C = y._readableState; C.readableListening = y.listenerCount("readable") > 0, C.resumeScheduled && !C.paused ? C.flowing = !0 : y.listenerCount("data") > 0 && y.resume(); } function W(y) { u("readable nexttick read 0"), y.read(0); } function X(y, C) { u("resume", C.reading), C.reading || y.read(0), C.resumeScheduled = !1, y.emit("resume"), Q(y), C.flowing && !C.reading && y.read(0); } function Q(y) { var C = y._readableState; for (u("flow", C.flowing); C.flowing && y.read() !== null;)
                    ; } function K(y, C) { return C.length === 0 ? null : (C.objectMode ? A = C.buffer.shift() : !y || y >= C.length ? (A = C.decoder ? C.buffer.join("") : C.buffer.length === 1 ? C.buffer.first() : C.buffer.concat(C.length), C.buffer.clear()) : A = C.buffer.consume(y, C.decoder), A); var A; } function F(y) { var C = y._readableState; u("endReadable", C.endEmitted), C.endEmitted || (C.ended = !0, r.nextTick(Y, C, y)); } function Y(y, C) { if (u("endReadableNT", y.endEmitted, y.length), !y.endEmitted && y.length === 0 && (y.endEmitted = !0, C.readable = !1, C.emit("end"), y.autoDestroy)) {
                    var A = C._writableState;
                    (!A || A.autoDestroy && A.finished) && C.destroy();
                } } function $(y, C) { for (var A = 0, U = y.length; A < U; A++)
                    if (y[A] === C)
                        return A; return -1; } N.prototype.read = function (y) { u("read", y), y = parseInt(y, 10); var C = this._readableState, A = y; if (y !== 0 && (C.emittedReadable = !1), y === 0 && C.needReadable && ((C.highWaterMark !== 0 ? C.length >= C.highWaterMark : C.length > 0) || C.ended))
                    return u("read: emitReadable", C.length, C.ended), C.length === 0 && C.ended ? F(this) : P(this), null; if ((y = B(y, C)) === 0 && C.ended)
                    return C.length === 0 && F(this), null; var U, z = C.needReadable; return u("need readable", z), (C.length === 0 || C.length - y < C.highWaterMark) && u("length less than watermark", z = !0), C.ended || C.reading ? u("reading or ended", z = !1) : z && (u("do read"), C.reading = !0, C.sync = !0, C.length === 0 && (C.needReadable = !0), this._read(C.highWaterMark), C.sync = !1, C.reading || (y = B(A, C))), (U = y > 0 ? K(y, C) : null) === null ? (C.needReadable = C.length <= C.highWaterMark, y = 0) : (C.length -= y, C.awaitDrain = 0), C.length === 0 && (C.ended || (C.needReadable = !0), A !== y && C.ended && F(this)), U !== null && this.emit("data", U), U; }, N.prototype._read = function (y) { k(this, new R("_read()")); }, N.prototype.pipe = function (y, C) { var A = this, U = this._readableState; switch (U.pipesCount) {
                    case 0:
                        U.pipes = y;
                        break;
                    case 1:
                        U.pipes = [U.pipes, y];
                        break;
                    default: U.pipes.push(y);
                } U.pipesCount += 1, u("pipe count=%d opts=%j", U.pipesCount, C); var z = (!C || C.end !== !1) && y !== r.stdout && y !== r.stderr ? O : nt; function w(rt, it) { u("onunpipe"), rt === A && it && it.hasUnpiped === !1 && (it.hasUnpiped = !0, u("cleanup"), y.removeListener("close", Z), y.removeListener("finish", tt), y.removeListener("drain", q), y.removeListener("error", J), y.removeListener("unpipe", w), A.removeListener("end", O), A.removeListener("end", nt), A.removeListener("data", V), H = !0, !U.awaitDrain || y._writableState && !y._writableState.needDrain || q()); } function O() { u("onend"), y.end(); } U.endEmitted ? r.nextTick(z) : A.once("end", z), y.on("unpipe", w); var q = function (rt) { return function () { var it = rt._readableState; u("pipeOnDrain", it.awaitDrain), it.awaitDrain && it.awaitDrain--, it.awaitDrain === 0 && c(rt, "data") && (it.flowing = !0, Q(rt)); }; }(A); y.on("drain", q); var H = !1; function V(rt) { u("ondata"); var it = y.write(rt); u("dest.write", it), it === !1 && ((U.pipesCount === 1 && U.pipes === y || U.pipesCount > 1 && $(U.pipes, y) !== -1) && !H && (u("false write response, pause", U.awaitDrain), U.awaitDrain++), A.pause()); } function J(rt) { u("onerror", rt), nt(), y.removeListener("error", J), c(y, "error") === 0 && k(y, rt); } function Z() { y.removeListener("finish", tt), nt(); } function tt() { u("onfinish"), y.removeListener("close", Z), nt(); } function nt() { u("unpipe"), A.unpipe(y); } return A.on("data", V), function (rt, it, st) { if (typeof rt.prependListener == "function")
                    return rt.prependListener(it, st); rt._events && rt._events[it] ? Array.isArray(rt._events[it]) ? rt._events[it].unshift(st) : rt._events[it] = [st, rt._events[it]] : rt.on(it, st); }(y, "error", J), y.once("close", Z), y.once("finish", tt), y.emit("pipe", A), U.flowing || (u("pipe resume"), A.resume()), y; }, N.prototype.unpipe = function (y) { var C = this._readableState, A = { hasUnpiped: !1 }; if (C.pipesCount === 0)
                    return this; if (C.pipesCount === 1)
                    return y && y !== C.pipes || (y || (y = C.pipes), C.pipes = null, C.pipesCount = 0, C.flowing = !1, y && y.emit("unpipe", this, A)), this; if (!y) {
                    var U = C.pipes, z = C.pipesCount;
                    C.pipes = null, C.pipesCount = 0, C.flowing = !1;
                    for (var w = 0; w < z; w++)
                        U[w].emit("unpipe", this, { hasUnpiped: !1 });
                    return this;
                } var O = $(C.pipes, y); return O === -1 || (C.pipes.splice(O, 1), C.pipesCount -= 1, C.pipesCount === 1 && (C.pipes = C.pipes[0]), y.emit("unpipe", this, A)), this; }, N.prototype.on = function (y, C) { var A = n.prototype.on.call(this, y, C), U = this._readableState; return y === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== !1 && this.resume()) : y === "readable" && (U.endEmitted || U.readableListening || (U.readableListening = U.needReadable = !0, U.flowing = !1, U.emittedReadable = !1, u("on readable", U.length, U.reading), U.length ? P(this) : U.reading || r.nextTick(W, this))), A; }, N.prototype.addListener = N.prototype.on, N.prototype.removeListener = function (y, C) { var A = n.prototype.removeListener.call(this, y, C); return y === "readable" && r.nextTick(G, this), A; }, N.prototype.removeAllListeners = function (y) { var C = n.prototype.removeAllListeners.apply(this, arguments); return y !== "readable" && y !== void 0 || r.nextTick(G, this), C; }, N.prototype.resume = function () { var y = this._readableState; return y.flowing || (u("resume"), y.flowing = !y.readableListening, function (C, A) { A.resumeScheduled || (A.resumeScheduled = !0, r.nextTick(X, C, A)); }(this, y)), y.paused = !1, this; }, N.prototype.pause = function () { return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this; }, N.prototype.wrap = function (y) { var C = this, A = this._readableState, U = !1; for (var z in y.on("end", function () { if (u("wrapped end"), A.decoder && !A.ended) {
                    var O = A.decoder.end();
                    O && O.length && C.push(O);
                } C.push(null); }), y.on("data", function (O) { (u("wrapped data"), A.decoder && (O = A.decoder.write(O)), A.objectMode && O == null) || (A.objectMode || O && O.length) && (C.push(O) || (U = !0, y.pause())); }), y)
                    this[z] === void 0 && typeof y[z] == "function" && (this[z] = function (O) { return function () { return y[O].apply(y, arguments); }; }(z)); for (var w = 0; w < x.length; w++)
                    y.on(x[w], this.emit.bind(this, x[w])); return this._read = function (O) { u("wrapped _read", O), U && (U = !1, y.resume()); }, this; }, typeof Symbol == "function" && (N.prototype[Symbol.asyncIterator] = function () { return h === void 0 && (h = f(955)), h(this); }), Object.defineProperty(N.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark; } }), Object.defineProperty(N.prototype, "readableBuffer", { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer; } }), Object.defineProperty(N.prototype, "readableFlowing", { enumerable: !1, get: function () { return this._readableState.flowing; }, set: function (y) { this._readableState && (this._readableState.flowing = y); } }), N._fromList = K, Object.defineProperty(N.prototype, "readableLength", { enumerable: !1, get: function () { return this._readableState.length; } }), typeof Symbol == "function" && (N.from = function (y, C) { return a === void 0 && (a = f(956)), a(N, y, C); }); }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = f(12).EventEmitter;
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(n, t) { c(n, t), e(n); } function e(n) { n._writableState && !n._writableState.emitClose || n._readableState && !n._readableState.emitClose || n.emit("close"); } function c(n, t) { n.emit("error", t); } E.exports = { destroy: function (n, t) { var s = this, u = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed; return u || i ? (t ? t(n) : n && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, d.nextTick(c, this, n)) : d.nextTick(c, this, n)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(n || null, function (o) { !t && o ? s._writableState ? s._writableState.errorEmitted ? d.nextTick(e, s) : (s._writableState.errorEmitted = !0, d.nextTick(r, s, o)) : d.nextTick(r, s, o) : t ? (d.nextTick(e, s), t(o)) : d.nextTick(e, s); }), this); }, undestroy: function () { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1); }, errorOrDestroy: function (n, t) { var s = n._readableState, u = n._writableState; s && s.autoDestroy || u && u.autoDestroy ? n.destroy(t) : n.emit("error", t); } }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(76).codes.ERR_INVALID_OPT_VALUE;
                E.exports = { getHighWaterMark: function (r, e, c, n) { var t = function (s, u, i) { return s.highWaterMark != null ? s.highWaterMark : u ? s[i] : null; }(e, n, c); if (t != null) {
                        if (!isFinite(t) || Math.floor(t) !== t || t < 0)
                            throw new d(n ? c : "highWaterMark", t);
                        return Math.floor(t);
                    } return r.objectMode ? 16 : 16384; } };
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { function e(D) { var G = this; this.next = null, this.entry = null, this.finish = function () { !function (W, X, Q) { var K = W.entry; for (W.entry = null; K;) {
                    var F = K.callback;
                    X.pendingcb--, F(Q), K = K.next;
                } X.corkedRequestsFree.next = W; }(G, D); }; } var c; E.exports = N, N.WritableState = M; var n = { deprecate: f(159) }, t = f(358), s = f(3).Buffer, u = d.Uint8Array || function () { }, i, o = f(359), h = f(360).getHighWaterMark, a = f(76).codes, l = a.ERR_INVALID_ARG_TYPE, p = a.ERR_METHOD_NOT_IMPLEMENTED, g = a.ERR_MULTIPLE_CALLBACK, b = a.ERR_STREAM_CANNOT_PIPE, I = a.ERR_STREAM_DESTROYED, v = a.ERR_STREAM_NULL_VALUES, R = a.ERR_STREAM_WRITE_AFTER_END, _ = a.ERR_UNKNOWN_ENCODING, k = o.errorOrDestroy; function x() { } function M(D, G, W) { c = c || f(77), D = D || {}, typeof W != "boolean" && (W = G instanceof c), this.objectMode = !!D.objectMode, W && (this.objectMode = this.objectMode || !!D.writableObjectMode), this.highWaterMark = h(this, D, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var X = D.decodeStrings === !1; this.decodeStrings = !X, this.defaultEncoding = D.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (Q) { !function (K, F) { var Y = K._writableState, $ = Y.sync, y = Y.writecb; if (typeof y != "function")
                    throw new g; if (function (A) { A.writing = !1, A.writecb = null, A.length -= A.writelen, A.writelen = 0; }(Y), F)
                    !function (A, U, z, w, O) { --U.pendingcb, z ? (r.nextTick(O, w), r.nextTick(j, A, U), A._writableState.errorEmitted = !0, k(A, w)) : (O(w), A._writableState.errorEmitted = !0, k(A, w), j(A, U)); }(K, Y, $, F, y);
                else {
                    var C = P(Y) || K.destroyed;
                    C || Y.corked || Y.bufferProcessing || !Y.bufferedRequest || B(K, Y), $ ? r.nextTick(T, K, Y, C, y) : T(K, Y, C, y);
                } }(G, Q); }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = D.emitClose !== !1, this.autoDestroy = !!D.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this); } function N(D) { var G = this instanceof (c = c || f(77)); if (!G && !i.call(N, this))
                    return new N(D); this._writableState = new M(D, this, G), this.writable = !0, D && (typeof D.write == "function" && (this._write = D.write), typeof D.writev == "function" && (this._writev = D.writev), typeof D.destroy == "function" && (this._destroy = D.destroy), typeof D.final == "function" && (this._final = D.final)), t.call(this); } function S(D, G, W, X, Q, K, F) { G.writelen = X, G.writecb = F, G.writing = !0, G.sync = !0, G.destroyed ? G.onwrite(new I("write")) : W ? D._writev(Q, G.onwrite) : D._write(Q, K, G.onwrite), G.sync = !1; } function T(D, G, W, X) { W || function (Q, K) { K.length === 0 && K.needDrain && (K.needDrain = !1, Q.emit("drain")); }(D, G), G.pendingcb--, X(), j(D, G); } function B(D, G) { G.bufferProcessing = !0; var W = G.bufferedRequest; if (D._writev && W && W.next) {
                    var X = G.bufferedRequestCount, Q = new Array(X), K = G.corkedRequestsFree;
                    K.entry = W;
                    for (var F = 0, Y = !0; W;)
                        Q[F] = W, W.isBuf || (Y = !1), W = W.next, F += 1;
                    Q.allBuffers = Y, S(D, G, !0, G.length, Q, "", K.finish), G.pendingcb++, G.lastBufferedRequest = null, K.next ? (G.corkedRequestsFree = K.next, K.next = null) : G.corkedRequestsFree = new e(G), G.bufferedRequestCount = 0;
                }
                else {
                    for (; W;) {
                        var $ = W.chunk, y = W.encoding, C = W.callback;
                        if (S(D, G, !1, G.objectMode ? 1 : $.length, $, y, C), W = W.next, G.bufferedRequestCount--, G.writing)
                            break;
                    }
                    W === null && (G.lastBufferedRequest = null);
                } G.bufferedRequest = W, G.bufferProcessing = !1; } function P(D) { return D.ending && D.length === 0 && D.bufferedRequest === null && !D.finished && !D.writing; } function L(D, G) { D._final(function (W) { G.pendingcb--, W && k(D, W), G.prefinished = !0, D.emit("prefinish"), j(D, G); }); } function j(D, G) { var W = P(G); if (W && (function (Q, K) { K.prefinished || K.finalCalled || (typeof Q._final != "function" || K.destroyed ? (K.prefinished = !0, Q.emit("prefinish")) : (K.pendingcb++, K.finalCalled = !0, r.nextTick(L, Q, K))); }(D, G), G.pendingcb === 0 && (G.finished = !0, D.emit("finish"), G.autoDestroy))) {
                    var X = D._readableState;
                    (!X || X.autoDestroy && X.endEmitted) && D.destroy();
                } return W; } f(15)(N, t), M.prototype.getBuffer = function () { for (var D = this.bufferedRequest, G = []; D;)
                    G.push(D), D = D.next; return G; }, function () { try {
                    Object.defineProperty(M.prototype, "buffer", { get: n.deprecate(function () { return this.getBuffer(); }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
                }
                catch (D) { } }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (i = Function.prototype[Symbol.hasInstance], Object.defineProperty(N, Symbol.hasInstance, { value: function (D) { return !!i.call(this, D) || this === N && D && D._writableState instanceof M; } })) : i = function (D) { return D instanceof this; }, N.prototype.pipe = function () { k(this, new b); }, N.prototype.write = function (D, G, W) { var X, Q = this._writableState, K = !1, F = !Q.objectMode && (X = D, s.isBuffer(X) || X instanceof u); return F && !s.isBuffer(D) && (D = function (Y) { return s.from(Y); }(D)), typeof G == "function" && (W = G, G = null), F ? G = "buffer" : G || (G = Q.defaultEncoding), typeof W != "function" && (W = x), Q.ending ? function (Y, $) { var y = new R; k(Y, y), r.nextTick($, y); }(this, W) : (F || function (Y, $, y, C) { var A; return y === null ? A = new v : typeof y == "string" || $.objectMode || (A = new l("chunk", ["string", "Buffer"], y)), !A || (k(Y, A), r.nextTick(C, A), !1); }(this, Q, D, W)) && (Q.pendingcb++, K = function (Y, $, y, C, A, U) { if (!y) {
                    var z = function (H, V, J) { return H.objectMode || H.decodeStrings === !1 || typeof V != "string" || (V = s.from(V, J)), V; }($, C, A);
                    C !== z && (y = !0, A = "buffer", C = z);
                } var w = $.objectMode ? 1 : C.length; $.length += w; var O = $.length < $.highWaterMark; if (O || ($.needDrain = !0), $.writing || $.corked) {
                    var q = $.lastBufferedRequest;
                    $.lastBufferedRequest = { chunk: C, encoding: A, isBuf: y, callback: U, next: null }, q ? q.next = $.lastBufferedRequest : $.bufferedRequest = $.lastBufferedRequest, $.bufferedRequestCount += 1;
                }
                else
                    S(Y, $, !1, w, C, A, U); return O; }(this, Q, F, D, G, W)), K; }, N.prototype.cork = function () { this._writableState.corked++; }, N.prototype.uncork = function () { var D = this._writableState; D.corked && (D.corked--, D.writing || D.corked || D.bufferProcessing || !D.bufferedRequest || B(this, D)); }, N.prototype.setDefaultEncoding = function (D) { if (typeof D == "string" && (D = D.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((D + "").toLowerCase()) > -1))
                    throw new _(D); return this._writableState.defaultEncoding = D, this; }, Object.defineProperty(N.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer(); } }), Object.defineProperty(N.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark; } }), N.prototype._write = function (D, G, W) { W(new p("_write()")); }, N.prototype._writev = null, N.prototype.end = function (D, G, W) { var X = this._writableState; return typeof D == "function" ? (W = D, D = null, G = null) : typeof G == "function" && (W = G, G = null), D != null && this.write(D, G), X.corked && (X.corked = 1, this.uncork()), X.ending || function (Q, K, F) { K.ending = !0, j(Q, K), F && (K.finished ? r.nextTick(F) : Q.once("finish", F)), K.ended = !0, Q.writable = !1; }(this, X, W), this; }, Object.defineProperty(N.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length; } }), Object.defineProperty(N.prototype, "destroyed", { enumerable: !1, get: function () { return this._writableState !== void 0 && this._writableState.destroyed; }, set: function (D) { this._writableState && (this._writableState.destroyed = D); } }), N.prototype.destroy = o.destroy, N.prototype._undestroy = o.undestroy, N.prototype._destroy = function (D, G) { G(D); }; }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = u;
                var d = f(76).codes, r = d.ERR_METHOD_NOT_IMPLEMENTED, e = d.ERR_MULTIPLE_CALLBACK, c = d.ERR_TRANSFORM_ALREADY_TRANSFORMING, n = d.ERR_TRANSFORM_WITH_LENGTH_0, t = f(77);
                function s(h, a) { var l = this._transformState; l.transforming = !1; var p = l.writecb; if (p === null)
                    return this.emit("error", new e); l.writechunk = null, l.writecb = null, a != null && this.push(a), p(h); var g = this._readableState; g.reading = !1, (g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark); }
                function u(h) { if (!(this instanceof u))
                    return new u(h); t.call(this, h), this._transformState = { afterTransform: s.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", i); }
                function i() { var h = this; typeof this._flush != "function" || this._readableState.destroyed ? o(this, null, null) : this._flush(function (a, l) { o(h, a, l); }); }
                function o(h, a, l) { if (a)
                    return h.emit("error", a); if (l != null && h.push(l), h._writableState.length)
                    throw new n; if (h._transformState.transforming)
                    throw new c; return h.push(null); }
                f(15)(u, t), u.prototype.push = function (h, a) { return this._transformState.needTransform = !1, t.prototype.push.call(this, h, a); }, u.prototype._transform = function (h, a, l) { l(new r("_transform()")); }, u.prototype._write = function (h, a, l) { var p = this._transformState; if (p.writecb = l, p.writechunk = h, p.writeencoding = a, !p.transforming) {
                    var g = this._readableState;
                    (p.needTransform || g.needReadable || g.length < g.highWaterMark) && this._read(g.highWaterMark);
                } }, u.prototype._read = function (h) { var a = this._transformState; a.writechunk === null || a.transforming ? a.needTransform = !0 : (a.transforming = !0, this._transform(a.writechunk, a.writeencoding, a.afterTransform)); }, u.prototype._destroy = function (h, a) { t.prototype._destroy.call(this, h, function (l) { a(l); }); };
            }, function (E, m, f) {
                "use strict";
                var d = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, r = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
                E.exports = function (e) { var c = e, n = e.indexOf("["), t = e.indexOf("]"); n != -1 && t != -1 && (e = e.substring(0, n) + e.substring(n, t).replace(/:/g, ";") + e.substring(t, e.length)); for (var s, u, i = d.exec(e || ""), o = {}, h = 14; h--;)
                    o[r[h]] = i[h] || ""; return n != -1 && t != -1 && (o.source = c, o.host = o.host.substring(1, o.host.length - 1).replace(/;/g, ":"), o.authority = o.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), o.ipv6uri = !0), o.pathNames = function (a, l) { var p = l.replace(/\/{2,9}/g, "/").split("/"); return l.substr(0, 1) != "/" && l.length !== 0 || p.splice(0, 1), l.substr(l.length - 1, 1) == "/" && p.splice(p.length - 1, 1), p; }(0, o.path), o.queryKey = (s = o.query, u = {}, s.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (a, l, p) { l && (u[l] = p); }), u), o; };
            }, function (E, m, f) {
                "use strict";
                var d = {}.toString;
                E.exports = Array.isArray || function (r) { return d.call(r) == "[object Array]"; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { E.exports = function (c) { return r && d.isBuffer(c) || e && (c instanceof ArrayBuffer || function (n) { return typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer; }(c)); }; var r = typeof d == "function" && typeof d.isBuffer == "function", e = typeof ArrayBuffer == "function"; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d = f(970), r = f(372), e = f(78), c = f(205), n = f(373), t = f(374), s = f(125)("socket.io-client:manager"), u = f(371), i = f(987), o = Object.prototype.hasOwnProperty;
                function h(a, l) { if (!(this instanceof h))
                    return new h(a, l); a && typeof a == "object" && (l = a, a = void 0), (l = l || {}).path = l.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = l, this.reconnection(l.reconnection !== !1), this.reconnectionAttempts(l.reconnectionAttempts || 1 / 0), this.reconnectionDelay(l.reconnectionDelay || 1e3), this.reconnectionDelayMax(l.reconnectionDelayMax || 5e3), this.randomizationFactor(l.randomizationFactor || .5), this.backoff = new i({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(l.timeout == null ? 2e4 : l.timeout), this.readyState = "closed", this.uri = a, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = []; var p = l.parser || c; this.encoder = new p.Encoder, this.decoder = new p.Decoder, this.autoConnect = l.autoConnect !== !1, this.autoConnect && this.open(); }
                E.exports = h, h.prototype.emitAll = function () { for (var a in this.emit.apply(this, arguments), this.nsps)
                    o.call(this.nsps, a) && this.nsps[a].emit.apply(this.nsps[a], arguments); }, h.prototype.updateSocketIds = function () { for (var a in this.nsps)
                    o.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a)); }, h.prototype.generateId = function (a) { return (a === "/" ? "" : a + "#") + this.engine.id; }, e(h.prototype), h.prototype.reconnection = function (a) { return arguments.length ? (this._reconnection = !!a, this) : this._reconnection; }, h.prototype.reconnectionAttempts = function (a) { return arguments.length ? (this._reconnectionAttempts = a, this) : this._reconnectionAttempts; }, h.prototype.reconnectionDelay = function (a) { return arguments.length ? (this._reconnectionDelay = a, this.backoff && this.backoff.setMin(a), this) : this._reconnectionDelay; }, h.prototype.randomizationFactor = function (a) { return arguments.length ? (this._randomizationFactor = a, this.backoff && this.backoff.setJitter(a), this) : this._randomizationFactor; }, h.prototype.reconnectionDelayMax = function (a) { return arguments.length ? (this._reconnectionDelayMax = a, this.backoff && this.backoff.setMax(a), this) : this._reconnectionDelayMax; }, h.prototype.timeout = function (a) { return arguments.length ? (this._timeout = a, this) : this._timeout; }, h.prototype.maybeReconnectOnOpen = function () { !this.reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect(); }, h.prototype.open = h.prototype.connect = function (a, l) { if (s("readyState %s", this.readyState), ~this.readyState.indexOf("open"))
                    return this; s("opening %s", this.uri), this.engine = d(this.uri, this.opts); var p = this.engine, g = this; this.readyState = "opening", this.skipReconnect = !1; var b = n(p, "open", function () { g.onopen(), a && a(); }), I = n(p, "error", function (_) { if (s("connect_error"), g.cleanup(), g.readyState = "closed", g.emitAll("connect_error", _), a) {
                    var k = new Error("Connection error");
                    k.data = _, a(k);
                }
                else
                    g.maybeReconnectOnOpen(); }); if (this._timeout !== !1) {
                    var v = this._timeout;
                    s("connect attempt will timeout after %d", v), v === 0 && b.destroy();
                    var R = setTimeout(function () { s("connect attempt timed out after %d", v), b.destroy(), p.close(), p.emit("error", "timeout"), g.emitAll("connect_timeout", v); }, v);
                    this.subs.push({ destroy: function () { clearTimeout(R); } });
                } return this.subs.push(b), this.subs.push(I), this; }, h.prototype.onopen = function () { s("open"), this.cleanup(), this.readyState = "open", this.emit("open"); var a = this.engine; this.subs.push(n(a, "data", t(this, "ondata"))), this.subs.push(n(a, "ping", t(this, "onping"))), this.subs.push(n(a, "pong", t(this, "onpong"))), this.subs.push(n(a, "error", t(this, "onerror"))), this.subs.push(n(a, "close", t(this, "onclose"))), this.subs.push(n(this.decoder, "decoded", t(this, "ondecoded"))); }, h.prototype.onping = function () { this.lastPing = new Date, this.emitAll("ping"); }, h.prototype.onpong = function () { this.emitAll("pong", new Date - this.lastPing); }, h.prototype.ondata = function (a) { this.decoder.add(a); }, h.prototype.ondecoded = function (a) { this.emit("packet", a); }, h.prototype.onerror = function (a) { s("error", a), this.emitAll("error", a); }, h.prototype.socket = function (a, l) { var p = this.nsps[a]; if (!p) {
                    p = new r(this, a, l), this.nsps[a] = p;
                    var g = this;
                    p.on("connecting", b), p.on("connect", function () { p.id = g.generateId(a); }), this.autoConnect && b();
                } function b() { ~u(g.connecting, p) || g.connecting.push(p); } return p; }, h.prototype.destroy = function (a) { var l = u(this.connecting, a); ~l && this.connecting.splice(l, 1), this.connecting.length || this.close(); }, h.prototype.packet = function (a) { s("writing packet %j", a); var l = this; a.query && a.type === 0 && (a.nsp += "?" + a.query), l.encoding ? l.packetBuffer.push(a) : (l.encoding = !0, this.encoder.encode(a, function (p) { for (var g = 0; g < p.length; g++)
                    l.engine.write(p[g], a.options); l.encoding = !1, l.processPacketQueue(); })); }, h.prototype.processPacketQueue = function () { if (this.packetBuffer.length > 0 && !this.encoding) {
                    var a = this.packetBuffer.shift();
                    this.packet(a);
                } }, h.prototype.cleanup = function () { s("cleanup"); for (var a = this.subs.length, l = 0; l < a; l++)
                    this.subs.shift().destroy(); this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy(); }, h.prototype.close = h.prototype.disconnect = function () { s("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, this.readyState === "opening" && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close(); }, h.prototype.onclose = function (a) { s("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", a), this._reconnection && !this.skipReconnect && this.reconnect(); }, h.prototype.reconnect = function () { if (this.reconnecting || this.skipReconnect)
                    return this; var a = this; if (this.backoff.attempts >= this._reconnectionAttempts)
                    s("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;
                else {
                    var l = this.backoff.duration();
                    s("will wait %dms before reconnect attempt", l), this.reconnecting = !0;
                    var p = setTimeout(function () { a.skipReconnect || (s("attempting reconnect"), a.emitAll("reconnect_attempt", a.backoff.attempts), a.emitAll("reconnecting", a.backoff.attempts), a.skipReconnect || a.open(function (g) { g ? (s("reconnect attempt error"), a.reconnecting = !1, a.reconnect(), a.emitAll("reconnect_error", g.data)) : (s("reconnect success"), a.onreconnect()); })); }, l);
                    this.subs.push({ destroy: function () { clearTimeout(p); } });
                } }, h.prototype.onreconnect = function () { var a = this.backoff.attempts; this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", a); };
            }, function (E, m, f) {
                "use strict";
                var d = f(206), r = f(973), e = f(983), c = f(984);
                m.polling = function (n) { var t = !1, s = !1, u = n.jsonp !== !1; if (typeof location != "undefined") {
                    var i = location.protocol === "https:", o = location.port;
                    o || (o = i ? 443 : 80), t = n.hostname !== location.hostname || o !== n.port, s = n.secure !== i;
                } if (n.xdomain = t, n.xscheme = s, "open" in new d(n) && !n.forceJSONP)
                    return new r(n); if (!u)
                    throw new Error("JSONP disabled"); return new e(n); }, m.websocket = c;
            }, function (E, m, f) {
                "use strict";
                var d = f(208), r = f(126), e = f(79), c = f(127), n = f(370), t = f(128)("engine.io-client:polling");
                E.exports = u;
                var s = new (f(206))({ xdomain: !1 }).responseType != null;
                function u(i) { var o = i && i.forceBase64; s && !o || (this.supportsBinary = !1), d.call(this, i); }
                c(u, d), u.prototype.name = "polling", u.prototype.doOpen = function () { this.poll(); }, u.prototype.pause = function (i) { var o = this; function h() { t("paused"), o.readyState = "paused", i(); } if (this.readyState = "pausing", this.polling || !this.writable) {
                    var a = 0;
                    this.polling && (t("we are currently polling - waiting to pause"), a++, this.once("pollComplete", function () { t("pre-pause polling complete"), --a || h(); })), this.writable || (t("we are currently writing - waiting to pause"), a++, this.once("drain", function () { t("pre-pause writing complete"), --a || h(); }));
                }
                else
                    h(); }, u.prototype.poll = function () { t("polling"), this.polling = !0, this.doPoll(), this.emit("poll"); }, u.prototype.onData = function (i) { var o = this; t("polling got data %s", i), e.decodePayload(i, this.socket.binaryType, function (h, a, l) { if (o.readyState === "opening" && o.onOpen(), h.type === "close")
                    return o.onClose(), !1; o.onPacket(h); }), this.readyState !== "closed" && (this.polling = !1, this.emit("pollComplete"), this.readyState === "open" ? this.poll() : t('ignoring poll - transport state "%s"', this.readyState)); }, u.prototype.doClose = function () { var i = this; function o() { t("writing close packet"), i.write([{ type: "close" }]); } this.readyState === "open" ? (t("transport open - closing"), o()) : (t("transport not open - deferring close"), this.once("open", o)); }, u.prototype.write = function (i) { var o = this; this.writable = !1; var h = function () { o.writable = !0, o.emit("drain"); }; e.encodePayload(i, this.supportsBinary, function (a) { o.doWrite(a, h); }); }, u.prototype.uri = function () { var i = this.query || {}, o = this.secure ? "https" : "http", h = ""; return this.timestampRequests !== !1 && (i[this.timestampParam] = n()), this.supportsBinary || i.sid || (i.b64 = 1), i = r.encode(i), this.port && (o === "https" && Number(this.port) !== 443 || o === "http" && Number(this.port) !== 80) && (h = ":" + this.port), i.length && (i = "?" + i), o + "://" + (this.hostname.indexOf(":") !== -1 ? "[" + this.hostname + "]" : this.hostname) + h + this.path + i; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(975), e = Object.prototype.toString, c = typeof Blob == "function" || typeof Blob != "undefined" && e.call(Blob) === "[object BlobConstructor]", n = typeof File == "function" || typeof File != "undefined" && e.call(File) === "[object FileConstructor]"; E.exports = function t(s) { if (!s || typeof s != "object")
                    return !1; if (r(s)) {
                    for (var u = 0, i = s.length; u < i; u++)
                        if (t(s[u]))
                            return !0;
                    return !1;
                } if (typeof d == "function" && d.isBuffer && d.isBuffer(s) || typeof ArrayBuffer == "function" && s instanceof ArrayBuffer || c && s instanceof Blob || n && s instanceof File)
                    return !0; if (s.toJSON && typeof s.toJSON == "function" && arguments.length === 1)
                    return t(s.toJSON(), !0); for (var o in s)
                    if (Object.prototype.hasOwnProperty.call(s, o) && t(s[o]))
                        return !0; return !1; }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d, r = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), e = {}, c = 0, n = 0;
                function t(u) { var i = ""; do
                    i = r[u % 64] + i, u = Math.floor(u / 64);
                while (u > 0); return i; }
                function s() { var u = t(+new Date); return u !== d ? (c = 0, d = u) : u + "." + t(c++); }
                for (; n < 64; n++)
                    e[r[n]] = n;
                s.encode = t, s.decode = function (u) { var i = 0; for (n = 0; n < u.length; n++)
                    i = 64 * i + e[u.charAt(n)]; return i; }, E.exports = s;
            }, function (E, m, f) {
                "use strict";
                var d = [].indexOf;
                E.exports = function (r, e) { if (d)
                    return r.indexOf(e); for (var c = 0; c < r.length; ++c)
                    if (r[c] === e)
                        return c; return -1; };
            }, function (E, m, f) {
                "use strict";
                var d = f(205), r = f(78), e = f(986), c = f(373), n = f(374), t = f(125)("socket.io-client:socket"), s = f(126), u = f(369);
                E.exports = h;
                var i = { connect: 1, connect_error: 1, connect_timeout: 1, connecting: 1, disconnect: 1, error: 1, reconnect: 1, reconnect_attempt: 1, reconnect_failed: 1, reconnect_error: 1, reconnecting: 1, ping: 1, pong: 1 }, o = r.prototype.emit;
                function h(a, l, p) { this.io = a, this.nsp = l, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, p && p.query && (this.query = p.query), this.io.autoConnect && this.open(); }
                r(h.prototype), h.prototype.subEvents = function () { if (!this.subs) {
                    var a = this.io;
                    this.subs = [c(a, "open", n(this, "onopen")), c(a, "packet", n(this, "onpacket")), c(a, "close", n(this, "onclose"))];
                } }, h.prototype.open = h.prototype.connect = function () { return this.connected || (this.subEvents(), this.io.reconnecting || this.io.open(), this.io.readyState === "open" && this.onopen(), this.emit("connecting")), this; }, h.prototype.send = function () { var a = e(arguments); return a.unshift("message"), this.emit.apply(this, a), this; }, h.prototype.emit = function (a) { if (i.hasOwnProperty(a))
                    return o.apply(this, arguments), this; var l = e(arguments), p = { type: (this.flags.binary !== void 0 ? this.flags.binary : u(l)) ? d.BINARY_EVENT : d.EVENT, data: l, options: {} }; return p.options.compress = !this.flags || this.flags.compress !== !1, typeof l[l.length - 1] == "function" && (t("emitting packet with ack id %d", this.ids), this.acks[this.ids] = l.pop(), p.id = this.ids++), this.connected ? this.packet(p) : this.sendBuffer.push(p), this.flags = {}, this; }, h.prototype.packet = function (a) { a.nsp = this.nsp, this.io.packet(a); }, h.prototype.onopen = function () { if (t("transport is open - connecting"), this.nsp !== "/")
                    if (this.query) {
                        var a = typeof this.query == "object" ? s.encode(this.query) : this.query;
                        t("sending connect packet with query %s", a), this.packet({ type: d.CONNECT, query: a });
                    }
                    else
                        this.packet({ type: d.CONNECT }); }, h.prototype.onclose = function (a) { t("close (%s)", a), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", a); }, h.prototype.onpacket = function (a) { var l = a.nsp === this.nsp, p = a.type === d.ERROR && a.nsp === "/"; if (l || p)
                    switch (a.type) {
                        case d.CONNECT:
                            this.onconnect();
                            break;
                        case d.EVENT:
                        case d.BINARY_EVENT:
                            this.onevent(a);
                            break;
                        case d.ACK:
                        case d.BINARY_ACK:
                            this.onack(a);
                            break;
                        case d.DISCONNECT:
                            this.ondisconnect();
                            break;
                        case d.ERROR: this.emit("error", a.data);
                    } }, h.prototype.onevent = function (a) { var l = a.data || []; t("emitting event %j", l), a.id != null && (t("attaching ack callback to event"), l.push(this.ack(a.id))), this.connected ? o.apply(this, l) : this.receiveBuffer.push(l); }, h.prototype.ack = function (a) { var l = this, p = !1; return function () { if (!p) {
                    p = !0;
                    var g = e(arguments);
                    t("sending ack %j", g), l.packet({ type: u(g) ? d.BINARY_ACK : d.ACK, id: a, data: g });
                } }; }, h.prototype.onack = function (a) { var l = this.acks[a.id]; typeof l == "function" ? (t("calling ack %s with %j", a.id, a.data), l.apply(this, a.data), delete this.acks[a.id]) : t("bad ack %s", a.id); }, h.prototype.onconnect = function () { this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered(); }, h.prototype.emitBuffered = function () { var a; for (a = 0; a < this.receiveBuffer.length; a++)
                    o.apply(this, this.receiveBuffer[a]); for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++)
                    this.packet(this.sendBuffer[a]); this.sendBuffer = []; }, h.prototype.ondisconnect = function () { t("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect"); }, h.prototype.destroy = function () { if (this.subs) {
                    for (var a = 0; a < this.subs.length; a++)
                        this.subs[a].destroy();
                    this.subs = null;
                } this.io.destroy(this); }, h.prototype.close = h.prototype.disconnect = function () { return this.connected && (t("performing disconnect (%s)", this.nsp), this.packet({ type: d.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this; }, h.prototype.compress = function (a) { return this.flags.compress = a, this; }, h.prototype.binary = function (a) { return this.flags.binary = a, this; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { return d.on(r, e), { destroy: function () { d.removeListener(r, e); } }; };
            }, function (E, m, f) {
                "use strict";
                var d = [].slice;
                E.exports = function (r, e) { if (typeof e == "string" && (e = r[e]), typeof e != "function")
                    throw new Error("bind() requires a function"); var c = d.call(arguments, 2); return function () { return e.apply(r, c.concat(d.call(arguments))); }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(45), r = f(988), { CLOSE_TIMEOUT: e } = f(204), c = f(348), n = f(1), t = n("libp2p:webrtc-star:socket");
                t.error = n("libp2p:webrtc-star:socket:error");
                const s = (u, i) => { if (u && i)
                    try {
                        return c(u, i);
                    }
                    catch (o) {
                        return t.error(o), c("0.0.0.0", i);
                    } };
                E.exports = (u, i = {}) => { const { sink: o, source: h } = r.duplex(u), a = i.remoteAddr || s(u.remoteAddress, u.remotePort), l = s(u.localAddress, u.localPort), p = { async sink(g) { i.signal && (g = d(g, i.signal)); try {
                        await o(async function* () { for await (const b of g)
                            yield b instanceof Uint8Array ? b : b.slice(); }());
                    }
                    catch (b) {
                        b.type !== "aborted" && t.error(b);
                    } }, source: i.signal ? d(h, i.signal) : h, conn: u, localAddr: l, remoteAddr: a, timeline: { open: Date.now() }, close() { if (!u.destroyed)
                        return new Promise((g, b) => { const I = Date.now(), v = setTimeout(() => { if (p.remoteAddr) {
                            const { host: R, port: _ } = p.remoteAddr.toOptions();
                            t("timeout closing socket to %s:%s after %dms, destroying it manually", R, _, Date.now() - I);
                        } u.destroyed || u.destroy(); }, e); u.once("close", () => { g(); }), u.end(R => { if (clearTimeout(v), p.timeline.close = Date.now(), R)
                            return b(R); }); }); } }; return u.once("close", () => { p.timeline.close || (p.timeline.close = Date.now()); }), p; };
            }, function (E, m, f) {
                "use strict";
                const d = f(192);
                E.exports = r => async (e) => { e = d(e); const c = b => { typeof b.return == "function" && b.return(); }; let n = null, t = null; const s = b => { n = b, t && t(b), c(e); }; let u = null, i = !1; const o = () => { i = !0, u && u(); }; let h = null, a = !1; const l = () => { a = !0, h && h(); }; let p = null; const g = () => { p && p(); }; r.once("error", s), r.once("close", o), r.once("finish", l); try {
                    for await (const b of e) {
                        if (!r.writable || r.destroyed || n)
                            break;
                        r.write(b) === !1 && await new Promise((I, v) => { u = p = I, t = v, r.once("drain", g); });
                    }
                }
                catch (b) {
                    n || r.destroy(), n = b;
                } try {
                    if (r.writable && r.end(), await (c(e), new Promise((b, I) => { if (i || a || n)
                        return b(); h = u = b, t = I; })), n)
                        throw n;
                }
                finally {
                    r.removeListener("error", s), r.removeListener("close", o), r.removeListener("finish", l), r.removeListener("drain", g);
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(376), r = f(209);
                E.exports = e => ({ sink: d(e), source: r(e) });
            }, function (E, m, f) {
                "use strict";
                const d = f(13);
                (m = E.exports).cleanUrlSIO = function (r) { const e = r.toString().split("/"), c = r.protos()[1].name, n = r.protos()[2].name, t = r.stringTuples()[1][1]; if (c !== "tcp" || n !== "ws" && n !== "wss")
                    throw new Error("invalid multiaddr: " + r.toString()); return d.isName(r) ? n === "ws" ? "http://" + e[2] + (t === 80 ? "" : ":" + t) : n === "wss" ? "https://" + e[2] + (t === 443 ? "" : ":" + t) : void 0 : "http://" + e[2] + ":" + e[4]; }, m.cleanMultiaddr = function (r) { const e = "/libp2p-webrtc-star"; if (r.indexOf(e) !== -1) {
                    r = r.substring(e.length, r.length);
                    let c = d(r);
                    const n = c.stringTuples().filter(t => t[0] === 421)[0];
                    c = c.decapsulate("p2p"), c = c.encapsulate("/p2p-webrtc-star"), c = c.encapsulate("/p2p/" + n[1]), r = c.toString();
                } return r; };
            }, function (E, m, f) {
                "use strict";
                E.exports = d => { d = d || 1 << 20; const r = e => { if (e.data && e.data.length > d)
                    throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" }); }; return e => async function* () { for await (const c of e)
                    Array.isArray(c) ? c.forEach(r) : r(c), yield c; }(); }, E.exports.MAX_MSG_SIZE = 1 << 20;
            }, function (E, m, f) {
                "use strict";
                const d = Object.freeze({ NEW_STREAM: 0, MESSAGE_RECEIVER: 1, MESSAGE_INITIATOR: 2, CLOSE_RECEIVER: 3, CLOSE_INITIATOR: 4, RESET_RECEIVER: 5, RESET_INITIATOR: 6 });
                m.MessageTypes = d, m.InitiatorMessageTypes = Object.freeze({ NEW_STREAM: d.NEW_STREAM, MESSAGE: d.MESSAGE_INITIATOR, CLOSE: d.CLOSE_INITIATOR, RESET: d.RESET_INITIATOR }), m.ReceiverMessageTypes = Object.freeze({ MESSAGE: d.MESSAGE_RECEIVER, CLOSE: d.CLOSE_RECEIVER, RESET: d.RESET_RECEIVER }), m.MessageTypeNames = Object.freeze(Object.entries(d).reduce((r, e) => (r[e[1]] = e[0], r), {}));
            }, function (E, m, f) {
                "use strict";
                var d = function (v) { return v && v.__esModule ? v : { default: v }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.Noise = void 0;
                const r = d(f(210)), e = f(3), c = d(f(1005)), n = d(f(1007)), t = d(f(124)), s = d(f(27)), u = f(35), i = f(383), o = f(1032), h = f(1035), a = f(57), l = f(129), p = f(1036), g = f(1037), b = f(101), I = f(211);
                m.Noise = class {
                    constructor(v, R) { if (this.protocol = "/noise", this.prologue = e.Buffer.alloc(0), this.earlyData = R || e.Buffer.alloc(0), this.useNoisePipes = !1, v) {
                        const _ = r.default.publicKeyCreate(v);
                        this.staticKeys = { privateKey: v, publicKey: _ };
                    }
                    else
                        this.staticKeys = a.generateKeypair(); }
                    async secureOutbound(v, R, _) { const k = c.default(R, { lengthEncoder: l.uint16BEEncode, lengthDecoder: l.uint16BEDecode, maxDataLength: I.NOISE_MSG_MAX_LENGTH_BYTES }), x = await this.performHandshake({ connection: k, isInitiator: !0, localPeer: v, remotePeer: _ }); return { conn: await this.createSecureConnection(k, x), remoteEarlyData: x.remoteEarlyData, remotePeer: x.remotePeer }; }
                    async secureInbound(v, R, _) { const k = c.default(R, { lengthEncoder: l.uint16BEEncode, lengthDecoder: l.uint16BEDecode, maxDataLength: I.NOISE_MSG_MAX_LENGTH_BYTES }), x = await this.performHandshake({ connection: k, isInitiator: !1, localPeer: v, remotePeer: _ }); return { conn: await this.createSecureConnection(k, x), remoteEarlyData: x.remoteEarlyData, remotePeer: x.remotePeer }; }
                    async performHandshake(v) { const R = await a.getPayload(v.localPeer, this.staticKeys.publicKey, this.earlyData); let _ = this.useNoisePipes; if (v.isInitiator && g.KeyCache.load(v.remotePeer) === null && (_ = !1), !_)
                        return await this.performXXHandshake(v, R); {
                        const { remotePeer: k, connection: x, isInitiator: M } = v, N = new o.IKHandshake(M, R, this.prologue, this.staticKeys, x, g.KeyCache.load(v.remotePeer) || e.Buffer.alloc(32), k);
                        try {
                            return await this.performIKHandshake(N);
                        }
                        catch (S) {
                            let T;
                            return v.isInitiator && (T = N.getLocalEphemeralKeys()), await this.performXXFallbackHandshake(v, R, S.initialMsg, T);
                        }
                    } }
                    async performXXFallbackHandshake(v, R, _, k) { const { isInitiator: x, remotePeer: M, connection: N } = v, S = new h.XXFallbackHandshake(x, R, this.prologue, this.staticKeys, N, _, M, k); try {
                        await S.propose(), await S.exchange(), await S.finish();
                    }
                    catch (T) {
                        throw b.logger(T), new Error("Error occurred during XX Fallback handshake: " + T.message);
                    } return S; }
                    async performXXHandshake(v, R) { const { isInitiator: _, remotePeer: k, connection: x } = v, M = new i.XXHandshake(_, R, this.prologue, this.staticKeys, x, k); try {
                        await M.propose(), await M.exchange(), await M.finish(), this.useNoisePipes && M.remotePeer && g.KeyCache.store(M.remotePeer, M.getRemoteStaticKey());
                    }
                    catch (N) {
                        throw new Error("Error occurred during XX handshake: " + N.message);
                    } return M; }
                    async performIKHandshake(v) { return await v.stage0(), await v.stage1(), v; }
                    async createSecureConnection(v, R) { const [_, k] = n.default(), x = v.unwrap(); return await s.default(_, t.default, p.encryptStream(R), u.encode({ lengthEncoder: l.uint16BEEncode }), x, u.decode({ lengthDecoder: l.uint16BEDecode }), t.default, p.decryptStream(R), _), k; }
                };
            }, function (E, m, f) {
                "use strict";
                m.custom = "inspect";
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.XXHandshake = void 0;
                const d = f(3), r = f(1009), e = f(57), c = f(101), n = f(129);
                m.XXHandshake = class {
                    constructor(t, s, u, i, o, h, a) { this.isInitiator = t, this.payload = s, this.prologue = u, this.staticKeypair = i, this.connection = o, h && (this.remotePeer = h), this.xx = a || new r.XX, this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair), this.remoteEarlyData = d.Buffer.alloc(0); }
                    async propose() { if (c.logLocalStaticKeys(this.session.hs.s), this.isInitiator) {
                        c.logger("Stage 0 - Initiator starting to send first message.");
                        const t = this.xx.sendMessage(this.session, d.Buffer.alloc(0));
                        this.connection.writeLP(n.encode0(t)), c.logger("Stage 0 - Initiator finished sending first message."), c.logLocalEphemeralKeys(this.session.hs.e);
                    }
                    else {
                        c.logger("Stage 0 - Responder waiting to receive first message...");
                        const t = n.decode0((await this.connection.readLP()).slice()), { valid: s } = this.xx.recvMessage(this.session, t);
                        if (!s)
                            throw new Error("xx handshake stage 0 validation fail");
                        c.logger("Stage 0 - Responder received first message."), c.logRemoteEphemeralKey(this.session.hs.re);
                    } }
                    async exchange() { if (this.isInitiator) {
                        c.logger("Stage 1 - Initiator waiting to receive first message from responder...");
                        const t = n.decode1((await this.connection.readLP()).slice()), { plaintext: s, valid: u } = this.xx.recvMessage(this.session, t);
                        if (!u)
                            throw new Error("xx handshake stage 1 validation fail");
                        c.logger("Stage 1 - Initiator received the message."), c.logRemoteEphemeralKey(this.session.hs.re), c.logRemoteStaticKey(this.session.hs.rs), c.logger("Initiator going to check remote's signature...");
                        try {
                            const i = await e.decodePayload(s);
                            this.remotePeer = this.remotePeer || await e.getPeerIdFromPayload(i), this.remotePeer = await e.verifySignedPayload(t.ns, i, this.remotePeer), this.setRemoteEarlyData(i.data);
                        }
                        catch (i) {
                            throw new Error("Error occurred while verifying signed payload: " + i.message);
                        }
                        c.logger("All good with the signature!");
                    }
                    else {
                        c.logger("Stage 1 - Responder sending out first message with signed payload and static key.");
                        const t = this.xx.sendMessage(this.session, this.payload);
                        this.connection.writeLP(n.encode1(t)), c.logger("Stage 1 - Responder sent the second handshake message with signed payload."), c.logLocalEphemeralKeys(this.session.hs.e);
                    } }
                    async finish() { if (this.isInitiator) {
                        c.logger("Stage 2 - Initiator sending third handshake message.");
                        const t = this.xx.sendMessage(this.session, this.payload);
                        this.connection.writeLP(n.encode2(t)), c.logger("Stage 2 - Initiator sent message with signed payload.");
                    }
                    else {
                        c.logger("Stage 2 - Responder waiting for third handshake message...");
                        const t = n.decode2((await this.connection.readLP()).slice()), { plaintext: s, valid: u } = this.xx.recvMessage(this.session, t);
                        if (!u)
                            throw new Error("xx handshake stage 2 validation fail");
                        c.logger("Stage 2 - Responder received the message, finished handshake.");
                        try {
                            const i = await e.decodePayload(s);
                            this.remotePeer = this.remotePeer || await e.getPeerIdFromPayload(i), await e.verifySignedPayload(this.session.hs.rs, i, this.remotePeer), this.setRemoteEarlyData(i.data);
                        }
                        catch (i) {
                            throw new Error("Error occurred while verifying signed payload: " + i.message);
                        }
                    } c.logCipherState(this.session); }
                    encrypt(t, s) { const u = this.getCS(s); return this.xx.encryptWithAd(u, d.Buffer.alloc(0), t); }
                    decrypt(t, s) { const u = this.getCS(s, !1); return this.xx.decryptWithAd(u, d.Buffer.alloc(0), t); }
                    getRemoteStaticKey() { return this.session.hs.rs; }
                    getCS(t, s = !0) { if (!t.cs1 || !t.cs2)
                        throw new Error("Handshake not completed properly, cipher state does not exist."); return this.isInitiator ? s ? t.cs1 : t.cs2 : s ? t.cs2 : t.cs1; }
                    setRemoteEarlyData(t) { t && (this.remoteEarlyData = d.Buffer.from(t.buffer, t.byteOffset, t.length)); }
                };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42), e = f(1012), c = d.alloc(8, 0), n = d.alloc(64, 0); n[0] = 128; const t = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]); class s {
                    constructor() { this.state = new Uint32Array(8), this.msg = new Uint32Array(64), this.block = d.alloc(64), this.size = -1; }
                    init() { return this.state[0] = 1779033703, this.state[1] = 3144134277, this.state[2] = 1013904242, this.state[3] = 2773480762, this.state[4] = 1359893119, this.state[5] = 2600822924, this.state[6] = 528734635, this.state[7] = 1541459225, this.size = 0, this; }
                    update(g) { return r(d.isBuffer(g)), this._update(g, g.length), this; }
                    final() { return this._final(d.alloc(32)); }
                    _update(g, b) { r(this.size !== -1, "Context is not initialized."); let I = 63 & this.size, v = 0; if (this.size += b, I > 0) {
                        let R = 64 - I;
                        if (R > b && (R = b), g.copy(this.block, I, v, v + R), I += R, b -= R, v += R, I < 64)
                            return;
                        this._transform(this.block, 0);
                    } for (; b >= 64;)
                        this._transform(g, v), v += 64, b -= 64; b > 0 && g.copy(this.block, 0, v, v + b); }
                    _final(g) { r(this.size !== -1, "Context is not initialized."); const b = 63 & this.size, I = 8 * this.size; l(c, I * (1 / 4294967296) >>> 0, 0), l(c, I >>> 0, 4), this._update(n, 1 + (119 - b & 63)), this._update(c, 8); for (let v = 0; v < 8; v++)
                        l(g, this.state[v], 4 * v), this.state[v] = 0; for (let v = 0; v < 64; v++)
                        this.msg[v] = 0; for (let v = 0; v < 64; v++)
                        this.block[v] = 0; return this.size = -1, g; }
                    _transform(g, b) { const I = this.msg; let v = this.state[0], R = this.state[1], _ = this.state[2], k = this.state[3], x = this.state[4], M = this.state[5], N = this.state[6], S = this.state[7], T = 0; for (; T < 16; T++)
                        I[T] = (P = b + 4 * T, 16777216 * (B = g)[P++] + 65536 * B[P++] + 256 * B[P++] + B[P]); for (var B, P, L; T < 64; T++)
                        I[T] = (((L = I[T - 2]) >>> 17 | L << 15) ^ (L >>> 19 | L << 13) ^ L >>> 10) + I[T - 7] + o(I[T - 15]) + I[T - 16]; for (T = 0; T < 64; T++) {
                        const j = S + i(x) + h(x, M, N) + t[T] + I[T], D = u(v) + a(v, R, _);
                        S = N, N = M, M = x, x = k + j >>> 0, k = _, _ = R, R = v, v = j + D >>> 0;
                    } this.state[0] += v, this.state[1] += R, this.state[2] += _, this.state[3] += k, this.state[4] += x, this.state[5] += M, this.state[6] += N, this.state[7] += S; }
                    static hash() { return new s; }
                    static hmac() { return new e(s, 64); }
                    static digest(g) { return s.ctx.init().update(g).final(); }
                    static root(g, b) { return r(d.isBuffer(g) && g.length === 32), r(d.isBuffer(b) && b.length === 32), s.ctx.init().update(g).update(b).final(); }
                    static multi(g, b, I) { const { ctx: v } = s; return v.init(), v.update(g), v.update(b), I && v.update(I), v.final(); }
                    static mac(g, b) { return s.hmac().init(b).update(g).final(); }
                } function u(p) { return (p >>> 2 | p << 30) ^ (p >>> 13 | p << 19) ^ (p >>> 22 | p << 10); } function i(p) { return (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7); } function o(p) { return (p >>> 7 | p << 25) ^ (p >>> 18 | p << 14) ^ p >>> 3; } function h(p, g, b) { return b ^ p & (g ^ b); } function a(p, g, b) { return p & g | b & (p | g); } function l(p, g, b) { return p[b++] = g >>> 24, p[b++] = g >>> 16, p[b++] = g >>> 8, p[b++] = g, b; } s.native = 0, s.id = "SHA256", s.size = 32, s.bits = 256, s.blockSize = 64, s.zero = d.alloc(32, 0), s.ctx = new s, E.exports = s; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = i;
                var d, r = f(58), e = r.LongBits, c = r.base64, n = r.utf8;
                function t(b, I, v) { this.fn = b, this.len = I, this.next = void 0, this.val = v; }
                function s() { }
                function u(b) { this.head = b.head, this.tail = b.tail, this.len = b.len, this.next = b.states; }
                function i() { this.len = 0, this.head = new t(s, 0, 0), this.tail = this.head, this.states = null; }
                var o = function () { return r.Buffer ? function () { return (i.create = function () { return new d; })(); } : function () { return new i; }; };
                function h(b, I, v) { I[v] = 255 & b; }
                function a(b, I) { this.len = b, this.next = void 0, this.val = I; }
                function l(b, I, v) { for (; b.hi;)
                    I[v++] = 127 & b.lo | 128, b.lo = (b.lo >>> 7 | b.hi << 25) >>> 0, b.hi >>>= 7; for (; b.lo > 127;)
                    I[v++] = 127 & b.lo | 128, b.lo = b.lo >>> 7; I[v++] = b.lo; }
                function p(b, I, v) { I[v] = 255 & b, I[v + 1] = b >>> 8 & 255, I[v + 2] = b >>> 16 & 255, I[v + 3] = b >>> 24; }
                i.create = o(), i.alloc = function (b) { return new r.Array(b); }, r.Array !== Array && (i.alloc = r.pool(i.alloc, r.Array.prototype.subarray)), i.prototype._push = function (b, I, v) { return this.tail = this.tail.next = new t(b, I, v), this.len += I, this; }, a.prototype = Object.create(t.prototype), a.prototype.fn = function (b, I, v) { for (; b > 127;)
                    I[v++] = 127 & b | 128, b >>>= 7; I[v] = b; }, i.prototype.uint32 = function (b) { return this.len += (this.tail = this.tail.next = new a((b >>>= 0) < 128 ? 1 : b < 16384 ? 2 : b < 2097152 ? 3 : b < 268435456 ? 4 : 5, b)).len, this; }, i.prototype.int32 = function (b) { return b < 0 ? this._push(l, 10, e.fromNumber(b)) : this.uint32(b); }, i.prototype.sint32 = function (b) { return this.uint32((b << 1 ^ b >> 31) >>> 0); }, i.prototype.uint64 = function (b) { var I = e.from(b); return this._push(l, I.length(), I); }, i.prototype.int64 = i.prototype.uint64, i.prototype.sint64 = function (b) { var I = e.from(b).zzEncode(); return this._push(l, I.length(), I); }, i.prototype.bool = function (b) { return this._push(h, 1, b ? 1 : 0); }, i.prototype.fixed32 = function (b) { return this._push(p, 4, b >>> 0); }, i.prototype.sfixed32 = i.prototype.fixed32, i.prototype.fixed64 = function (b) { var I = e.from(b); return this._push(p, 4, I.lo)._push(p, 4, I.hi); }, i.prototype.sfixed64 = i.prototype.fixed64, i.prototype.float = function (b) { return this._push(r.float.writeFloatLE, 4, b); }, i.prototype.double = function (b) { return this._push(r.float.writeDoubleLE, 8, b); };
                var g = r.Array.prototype.set ? function (b, I, v) { I.set(b, v); } : function (b, I, v) { for (var R = 0; R < b.length; ++R)
                    I[v + R] = b[R]; };
                i.prototype.bytes = function (b) { var I = b.length >>> 0; if (!I)
                    return this._push(h, 1, 0); if (r.isString(b)) {
                    var v = i.alloc(I = c.length(b));
                    c.decode(b, v, 0), b = v;
                } return this.uint32(I)._push(g, I, b); }, i.prototype.string = function (b) { var I = n.length(b); return I ? this.uint32(I)._push(n.write, I, b) : this._push(h, 1, 0); }, i.prototype.fork = function () { return this.states = new u(this), this.head = this.tail = new t(s, 0, 0), this.len = 0, this; }, i.prototype.reset = function () { return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new t(s, 0, 0), this.len = 0), this; }, i.prototype.ldelim = function () { var b = this.head, I = this.tail, v = this.len; return this.reset().uint32(v), v && (this.tail.next = b.next, this.tail = I, this.len += v), this; }, i.prototype.finish = function () { for (var b = this.head.next, I = this.constructor.alloc(this.len), v = 0; b;)
                    b.fn(b.val, I, v), v += b.len, b = b.next; return I; }, i._configure = function (b) { d = b, i.create = o(), d._configure(); };
            }, function (E, m, f) {
                "use strict";
                E.exports = t;
                var d, r = f(58), e = r.LongBits, c = r.utf8;
                function n(l, p) { return RangeError("index out of range: " + l.pos + " + " + (p || 1) + " > " + l.len); }
                function t(l) { this.buf = l, this.pos = 0, this.len = l.length; }
                var s, u = typeof Uint8Array != "undefined" ? function (l) { if (l instanceof Uint8Array || Array.isArray(l))
                    return new t(l); throw Error("illegal buffer"); } : function (l) { if (Array.isArray(l))
                    return new t(l); throw Error("illegal buffer"); }, i = function () { return r.Buffer ? function (l) { return (t.create = function (p) { return r.Buffer.isBuffer(p) ? new d(p) : u(p); })(l); } : u; };
                function o() { var l = new e(0, 0), p = 0; if (!(this.len - this.pos > 4)) {
                    for (; p < 3; ++p) {
                        if (this.pos >= this.len)
                            throw n(this);
                        if (l.lo = (l.lo | (127 & this.buf[this.pos]) << 7 * p) >>> 0, this.buf[this.pos++] < 128)
                            return l;
                    }
                    return l.lo = (l.lo | (127 & this.buf[this.pos++]) << 7 * p) >>> 0, l;
                } for (; p < 4; ++p)
                    if (l.lo = (l.lo | (127 & this.buf[this.pos]) << 7 * p) >>> 0, this.buf[this.pos++] < 128)
                        return l; if (l.lo = (l.lo | (127 & this.buf[this.pos]) << 28) >>> 0, l.hi = (l.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128)
                    return l; if (p = 0, this.len - this.pos > 4) {
                    for (; p < 5; ++p)
                        if (l.hi = (l.hi | (127 & this.buf[this.pos]) << 7 * p + 3) >>> 0, this.buf[this.pos++] < 128)
                            return l;
                }
                else
                    for (; p < 5; ++p) {
                        if (this.pos >= this.len)
                            throw n(this);
                        if (l.hi = (l.hi | (127 & this.buf[this.pos]) << 7 * p + 3) >>> 0, this.buf[this.pos++] < 128)
                            return l;
                    } throw Error("invalid varint encoding"); }
                function h(l, p) { return (l[p - 4] | l[p - 3] << 8 | l[p - 2] << 16 | l[p - 1] << 24) >>> 0; }
                function a() { if (this.pos + 8 > this.len)
                    throw n(this, 8); return new e(h(this.buf, this.pos += 4), h(this.buf, this.pos += 4)); }
                t.create = i(), t.prototype._slice = r.Array.prototype.subarray || r.Array.prototype.slice, t.prototype.uint32 = (s = 4294967295, function () { if (s = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128)
                    return s; if (s = (s | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128)
                    return s; if (s = (s | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128)
                    return s; if (s = (s | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128)
                    return s; if (s = (s | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128)
                    return s; if ((this.pos += 5) > this.len)
                    throw this.pos = this.len, n(this, 10); return s; }), t.prototype.int32 = function () { return 0 | this.uint32(); }, t.prototype.sint32 = function () { var l = this.uint32(); return l >>> 1 ^ -(1 & l) | 0; }, t.prototype.bool = function () { return this.uint32() !== 0; }, t.prototype.fixed32 = function () { if (this.pos + 4 > this.len)
                    throw n(this, 4); return h(this.buf, this.pos += 4); }, t.prototype.sfixed32 = function () { if (this.pos + 4 > this.len)
                    throw n(this, 4); return 0 | h(this.buf, this.pos += 4); }, t.prototype.float = function () { if (this.pos + 4 > this.len)
                    throw n(this, 4); var l = r.float.readFloatLE(this.buf, this.pos); return this.pos += 4, l; }, t.prototype.double = function () { if (this.pos + 8 > this.len)
                    throw n(this, 4); var l = r.float.readDoubleLE(this.buf, this.pos); return this.pos += 8, l; }, t.prototype.bytes = function () { var l = this.uint32(), p = this.pos, g = this.pos + l; if (g > this.len)
                    throw n(this, l); return this.pos += l, Array.isArray(this.buf) ? this.buf.slice(p, g) : p === g ? new this.buf.constructor(0) : this._slice.call(this.buf, p, g); }, t.prototype.string = function () { var l = this.bytes(); return c.read(l, 0, l.length); }, t.prototype.skip = function (l) { if (typeof l == "number") {
                    if (this.pos + l > this.len)
                        throw n(this, l);
                    this.pos += l;
                }
                else
                    do
                        if (this.pos >= this.len)
                            throw n(this);
                    while (128 & this.buf[this.pos++]); return this; }, t.prototype.skipType = function (l) { switch (l) {
                    case 0:
                        this.skip();
                        break;
                    case 1:
                        this.skip(8);
                        break;
                    case 2:
                        this.skip(this.uint32());
                        break;
                    case 3:
                        for (; (l = 7 & this.uint32()) != 4;)
                            this.skipType(l);
                        break;
                    case 5:
                        this.skip(4);
                        break;
                    default: throw Error("invalid wire type " + l + " at offset " + this.pos);
                } return this; }, t._configure = function (l) { d = l, t.create = i(), d._configure(); var p = r.Long ? "toLong" : "toNumber"; r.merge(t.prototype, { int64: function () { return o.call(this)[p](!1); }, uint64: function () { return o.call(this)[p](!0); }, sint64: function () { return o.call(this).zzDecode()[p](!1); }, fixed64: function () { return a.call(this)[p](!0); }, sfixed64: function () { return a.call(this)[p](!1); } }); };
            }, function (E, m, f) {
                "use strict";
                var d = function (u) { return u && u.__esModule ? u : { default: u }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.AbstractHandshake = m.MIN_NONCE = void 0;
                const r = f(3), e = d(f(1029)), c = d(f(210)), n = d(f(384)), t = f(57), s = f(101);
                m.MIN_NONCE = 0, m.AbstractHandshake = class {
                    encryptWithAd(u, i, o) { const h = this.encrypt(u.k, u.n, i, o); return this.setNonce(u, this.incrementNonce(u.n)), h; }
                    decryptWithAd(u, i, o) { const { plaintext: h, valid: a } = this.decrypt(u.k, u.n, i, o); return this.setNonce(u, this.incrementNonce(u.n)), { plaintext: h, valid: a }; }
                    hasKey(u) { return !this.isEmptyKey(u.k); }
                    setNonce(u, i) { u.n = i; }
                    createEmptyKey() { return r.Buffer.alloc(32); }
                    isEmptyKey(u) { return this.createEmptyKey().equals(u); }
                    incrementNonce(u) { return u + 1; }
                    nonceToBytes(u) { const i = r.Buffer.alloc(12); return i.writeUInt32LE(u, 4), i; }
                    encrypt(u, i, o, h) { const a = this.nonceToBytes(i), l = new e.default; return h = r.Buffer.from(h), l.init(u, a), l.aad(o), l.encrypt(h), r.Buffer.concat([h, l.final()]); }
                    encryptAndHash(u, i) { let o; return o = this.hasKey(u.cs) ? this.encryptWithAd(u.cs, u.h, i) : i, this.mixHash(u, o), o; }
                    decrypt(u, i, o, h) { const a = this.nonceToBytes(i), l = new e.default, p = (h = r.Buffer.from(h)).slice(h.length - 16); return h = h.slice(0, h.length - 16), l.init(u, a), l.aad(o), l.decrypt(h), { plaintext: h, valid: l.verify(p) }; }
                    decryptAndHash(u, i) { let o, h = !0; return this.hasKey(u.cs) ? { plaintext: o, valid: h } = this.decryptWithAd(u.cs, u.h, i) : o = i, this.mixHash(u, i), { plaintext: o, valid: h }; }
                    dh(u, i) { try {
                        const o = c.default.derive(i, u), h = r.Buffer.alloc(32);
                        return o.copy(h), h;
                    }
                    catch (o) {
                        return s.logger(o.message), r.Buffer.alloc(32);
                    } }
                    mixHash(u, i) { u.h = this.getHash(u.h, i); }
                    getHash(u, i) { return n.default.digest(r.Buffer.from([...u, ...i])); }
                    mixKey(u, i) { const [o, h] = t.getHkdf(u.ck, i); u.cs = this.initializeKey(h), u.ck = o; }
                    initializeKey(u) { return { k: u, n: m.MIN_NONCE }; }
                    initializeSymmetric(u) { const i = r.Buffer.from(u, "utf-8"), o = this.hashProtocolName(i), h = o, a = this.createEmptyKey(); return { cs: this.initializeKey(a), ck: h, h: o }; }
                    hashProtocolName(u) { if (u.length <= 32) {
                        const i = r.Buffer.alloc(32);
                        return u.copy(i), i;
                    } return this.getHash(u, r.Buffer.alloc(0)); }
                    split(u) { const [i, o] = t.getHkdf(u.ck, r.Buffer.alloc(0)); return { cs1: this.initializeKey(i), cs2: this.initializeKey(o) }; }
                    writeMessageRegular(u, i) { const o = this.encryptWithAd(u, r.Buffer.alloc(0), i); return { ne: this.createEmptyKey(), ns: r.Buffer.alloc(0), ciphertext: o }; }
                    readMessageRegular(u, i) { return this.decryptWithAd(u, r.Buffer.alloc(0), i.ciphertext); }
                };
            }, function (E, m, f) {
                "use strict";
                (function (d) { Object.defineProperty(m, "__esModule", { value: !0 }), m.hasNextTick = m.hasSetImmediate = void 0, m.fallback = u, m.wrap = i; var r, e = f(389), c = (r = e) && r.__esModule ? r : { default: r }, n, t = m.hasSetImmediate = typeof setImmediate == "function" && setImmediate, s = m.hasNextTick = typeof d == "object" && typeof d.nextTick == "function"; function u(o) { setTimeout(o, 0); } function i(o) { return function (h) { var a = (0, c.default)(arguments, 1); o(function () { h.apply(null, a); }); }; } n = t ? setImmediate : s ? d.nextTick : u, m.default = i(n); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (d, r) { r |= 0; for (var e = Math.max(d.length - r, 0), c = Array(e), n = 0; n < e; n++)
                    c[n] = d[r + n]; return c; }, E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.isAsync = void 0;
                var d, r = f(1072), e = (d = r) && d.__esModule ? d : { default: d }, c = typeof Symbol == "function";
                function n(t) { return c && t[Symbol.toStringTag] === "AsyncFunction"; }
                m.default = function (t) { return n(t) ? (0, e.default)(t) : t; }, m.isAsync = n;
            }, function (E, m, f) { E.exports = f(392); }, function (E, m, f) {
                "use strict";
                const d = f(393), r = f(394), e = f(7), c = f(39), n = f(52), t = f(13), s = f(25), u = f(18), i = f(16), o = i.multihash, h = f(4), { create: a } = f(518);
                E.exports = { create: a, crypto: c, isIPFS: n, CID: h, multiaddr: t, multibase: s, multihash: o, multihashing: i, multicodec: u, PeerId: e, globSource: d, urlSource: r };
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                const d = f(132);
                E.exports = async function* (r, e) { const c = new d, n = await c.get(r, e); yield { path: decodeURIComponent(new URL(r).pathname.split("/").pop() || ""), content: n.iterator() }; };
            }, function (E, m, f) {
                "use strict";
                const { TimeoutError: d, AbortError: r } = f(215), { Request: e, Response: c, Headers: n } = f(396), t = fetch;
                m.fetch = (i, o = {}) => o.onUploadProgress != null ? ((h, a = {}) => { const l = new XMLHttpRequest; l.open(a.method || "GET", h.toString(), !0); const { timeout: p } = a; if (p > 0 && p < 1 / 0 && (l.timeout = a.timeout), a.overrideMimeType != null && l.overrideMimeType(a.overrideMimeType), a.headers)
                    for (const [g, b] of a.headers.entries())
                        l.setRequestHeader(g, b); return a.signal && (a.signal.onabort = () => l.abort()), a.onUploadProgress && (l.upload.onprogress = a.onUploadProgress), l.responseType = "arraybuffer", new Promise((g, b) => { const I = v => { switch (v.type) {
                    case "error":
                        g(c.error());
                        break;
                    case "load":
                        g(new u(l.responseURL, l.response, { status: l.status, statusText: l.statusText, headers: s(l.getAllResponseHeaders()) }));
                        break;
                    case "timeout":
                        b(new d);
                        break;
                    case "abort": b(new r);
                } }; l.onerror = I, l.onload = I, l.ontimeout = I, l.onabort = I, l.send(a.body); }); })(i, o) : t(i, o), m.Request = e, m.Headers = n;
                const s = i => { const o = new n; for (const h of i.trim().split(/[\r\n]+/)) {
                    const a = h.indexOf(": ");
                    a > 0 && o.set(h.slice(0, a), h.slice(a + 1));
                } return o; };
                class u extends c {
                    constructor(o, h, a) { super(h, a), Object.defineProperty(this, "url", { value: o }); }
                }
            }, function (E, m, f) {
                "use strict";
                const { isElectronMain: d } = f(216);
                E.exports = f(d ? 398 : 217);
            }, function (E, m, f) {
                "use strict";
                (function (d) { E.exports = function () { return typeof window != "undefined" && typeof window.process == "object" && window.process.type === "renderer" || !(d === void 0 || typeof d.versions != "object" || !d.versions.electron) || typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Electron") >= 0; }; }).call(this, f(9));
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                var d = Array.prototype.slice, r = f(219), e = Object.keys, c = e ? function (t) { return e(t); } : f(400), n = Object.keys;
                c.shim = function () { return Object.keys ? function () { var t = Object.keys(arguments); return t && t.length === arguments.length; }(1, 2) || (Object.keys = function (t) { return r(t) ? n(d.call(t)) : n(t); }) : Object.keys = c, Object.keys || c; }, E.exports = c;
            }, function (E, m, f) {
                "use strict";
                var d;
                if (!Object.keys) {
                    var r = Object.prototype.hasOwnProperty, e = Object.prototype.toString, c = f(219), n = Object.prototype.propertyIsEnumerable, t = !n.call({ toString: null }, "toString"), s = n.call(function () { }, "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], i = function (a) { var l = a.constructor; return l && l.prototype === a; }, o = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }, h = function () { if (typeof window == "undefined")
                        return !1; for (var a in window)
                        try {
                            if (!o["$" + a] && r.call(window, a) && window[a] !== null && typeof window[a] == "object")
                                try {
                                    i(window[a]);
                                }
                                catch (l) {
                                    return !0;
                                }
                        }
                        catch (l) {
                            return !0;
                        } return !1; }();
                    d = function (a) { var l = a !== null && typeof a == "object", p = e.call(a) === "[object Function]", g = c(a), b = l && e.call(a) === "[object String]", I = []; if (!l && !p && !g)
                        throw new TypeError("Object.keys called on a non-object"); var v = s && p; if (b && a.length > 0 && !r.call(a, 0))
                        for (var R = 0; R < a.length; ++R)
                            I.push(String(R)); if (g && a.length > 0)
                        for (var _ = 0; _ < a.length; ++_)
                            I.push(String(_));
                    else
                        for (var k in a)
                            v && k === "prototype" || !r.call(a, k) || I.push(String(k)); if (t)
                        for (var x = function (N) { if (typeof window == "undefined" || !h)
                            return i(N); try {
                            return i(N);
                        }
                        catch (S) {
                            return !1;
                        } }(a), M = 0; M < u.length; ++M)
                            x && u[M] === "constructor" || !r.call(a, u[M]) || I.push(u[M]); return I; };
                }
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                var d = f(218), r = f(221);
                E.exports = function () { var e = r(); if (d.supportsDescriptors) {
                    var c = Object.getOwnPropertyDescriptor(e, "globalThis");
                    (!c || c.configurable && (c.enumerable || c.writable || globalThis !== e)) && Object.defineProperty(e, "globalThis", { configurable: !0, enumerable: !1, value: e, writable: !1 });
                }
                else
                    typeof globalThis == "object" && globalThis === e || (e.globalThis = e); return e; };
            }, function (E, m, f) {
                "use strict";
                var d = function () { if (typeof self != "undefined")
                    return self; if (typeof window != "undefined")
                    return window; if (d !== void 0)
                    return d; throw new Error("unable to locate global object"); }();
                E.exports = m = d.fetch, d.fetch && (m.default = d.fetch.bind(d)), m.Headers = d.Headers, m.Request = d.Request, m.Response = d.Response;
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r, URLSearchParams: e, defaultBase: c } = f(222), n = f(404);
                E.exports = { URL: d, URLSearchParams: e, format: r, relative: n, defaultBase: c };
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r } = f(222);
                E.exports = (e, c = {}, n = {}, t) => { let s, u = c.protocol ? c.protocol.replace(":", "") : "http"; u = (n[u] || t || u) + ":"; try {
                    s = new d(e);
                }
                catch (o) {
                    s = {};
                } const i = Object.assign({}, c, { protocol: u || s.protocol, host: c.host || s.host }); return new d(e, r(i)).toString(); };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(135).TextDecoder;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { if (d.length >= 255)
                    throw new TypeError("Alphabet too long"); for (var r = new Uint8Array(256), e = 0; e < r.length; e++)
                    r[e] = 255; for (var c = 0; c < d.length; c++) {
                    var n = d.charAt(c), t = n.charCodeAt(0);
                    if (r[t] !== 255)
                        throw new TypeError(n + " is ambiguous");
                    r[t] = c;
                } var s = d.length, u = d.charAt(0), i = Math.log(s) / Math.log(256), o = Math.log(256) / Math.log(s); function h(a) { if (typeof a != "string")
                    throw new TypeError("Expected String"); if (a.length === 0)
                    return new Uint8Array; var l = 0; if (a[l] !== " ") {
                    for (var p = 0, g = 0; a[l] === u;)
                        p++, l++;
                    for (var b = (a.length - l) * i + 1 >>> 0, I = new Uint8Array(b); a[l];) {
                        var v = r[a.charCodeAt(l)];
                        if (v === 255)
                            return;
                        for (var R = 0, _ = b - 1; (v !== 0 || R < g) && _ !== -1; _--, R++)
                            v += s * I[_] >>> 0, I[_] = v % 256 >>> 0, v = v / 256 >>> 0;
                        if (v !== 0)
                            throw new Error("Non-zero carry");
                        g = R, l++;
                    }
                    if (a[l] !== " ") {
                        for (var k = b - g; k !== b && I[k] === 0;)
                            k++;
                        for (var x = new Uint8Array(p + (b - k)), M = p; k !== b;)
                            x[M++] = I[k++];
                        return x;
                    }
                } } return { encode: function (a) { if (a instanceof Uint8Array || (ArrayBuffer.isView(a) ? a = new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : Array.isArray(a) && (a = Uint8Array.from(a))), !(a instanceof Uint8Array))
                        throw new TypeError("Expected Uint8Array"); if (a.length === 0)
                        return ""; for (var l = 0, p = 0, g = 0, b = a.length; g !== b && a[g] === 0;)
                        g++, l++; for (var I = (b - g) * o + 1 >>> 0, v = new Uint8Array(I); g !== b;) {
                        for (var R = a[g], _ = 0, k = I - 1; (R !== 0 || _ < p) && k !== -1; k--, _++)
                            R += 256 * v[k] >>> 0, v[k] = R % s >>> 0, R = R / s >>> 0;
                        if (R !== 0)
                            throw new Error("Non-zero carry");
                        p = _, g++;
                    } for (var x = I - p; x !== I && v[x] === 0;)
                        x++; for (var M = u.repeat(l); x < I; ++x)
                        M += d.charAt(v[x]); return M; }, decodeUnsafe: h, decode: function (a) { var l = h(a); if (l)
                        return l; throw new Error("Non-base" + s + " character"); } }; };
            }, function (E, m, f) {
                "use strict";
                const { encodeText: d } = f(139);
                E.exports = class {
                    constructor(r, e, c, n) { this.name = r, this.code = e, this.codeBuf = d(this.code), this.alphabet = n, this.codec = c(n); }
                    encode(r) { return this.codec.encode(r); }
                    decode(r) { for (const e of r)
                        if (this.alphabet && this.alphabet.indexOf(e) < 0)
                            throw new Error(`invalid character '${e}' in '${r}'`); return this.codec.decode(r); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = { rfc4648: d => r => ({ encode: e => ((c, n, t) => { const s = n[n.length - 1] === "=", u = (1 << t) - 1; let i = "", o = 0, h = 0; for (let a = 0; a < c.length; ++a)
                            for (h = h << 8 | c[a], o += 8; o > t;)
                                o -= t, i += n[u & h >> o]; if (o && (i += n[u & h << t - o]), s)
                            for (; i.length * t & 7;)
                                i += "="; return i; })(e, r, d), decode: e => ((c, n, t) => { const s = {}; for (let l = 0; l < n.length; ++l)
                            s[n[l]] = l; let u = c.length; for (; c[u - 1] === "=";)
                            --u; const i = new Uint8Array(u * t / 8 | 0); let o = 0, h = 0, a = 0; for (let l = 0; l < u; ++l) {
                            const p = s[c[l]];
                            if (p === void 0)
                                throw new SyntaxError("Invalid character " + c[l]);
                            h = h << t | p, o += t, o >= 8 && (o -= 8, i[a++] = 255 & h >> o);
                        } if (o >= t || 255 & h << 8 - o)
                            throw new SyntaxError("Unexpected end of data"); return i; })(e, r, d) }) };
            }, function (E, m, f) {
                "use strict";
                E.exports = { encode: f(410), decode: f(411), encodingLength: f(412) };
            }, function (E, m, f) {
                "use strict";
                E.exports = function r(e, c, n) { if (Number.MAX_SAFE_INTEGER && e > Number.MAX_SAFE_INTEGER)
                    throw r.bytes = 0, new RangeError("Could not encode varint"); c = c || []; for (var t = n = n || 0; e >= d;)
                    c[n++] = 255 & e | 128, e /= 128; for (; -128 & e;)
                    c[n++] = 255 & e | 128, e >>>= 7; return c[n] = 0 | e, r.bytes = n - t + 1, c; };
                var d = Math.pow(2, 31);
            }, function (E, m, f) {
                "use strict";
                E.exports = function d(r, e) { var c, n = 0, t = 0, s = e = e || 0, u = r.length; do {
                    if (s >= u || t > 49)
                        throw d.bytes = 0, new RangeError("Could not decode varint");
                    c = r[s++], n += t < 28 ? (127 & c) << t : (127 & c) * Math.pow(2, t), t += 7;
                } while (c >= 128); return d.bytes = s - e, n; };
            }, function (E, m, f) {
                "use strict";
                var d = Math.pow(2, 7), r = Math.pow(2, 14), e = Math.pow(2, 21), c = Math.pow(2, 28), n = Math.pow(2, 35), t = Math.pow(2, 42), s = Math.pow(2, 49), u = Math.pow(2, 56), i = Math.pow(2, 63);
                E.exports = function (o) { return o < d ? 1 : o < r ? 2 : o < e ? 3 : o < c ? 4 : o < n ? 5 : o < t ? 6 : o < s ? 7 : o < u ? 8 : o < i ? 9 : 10; };
            }, function (E, m, f) {
                "use strict";
                const d = Object.freeze({ identity: 0, sha1: 17, "sha2-256": 18, "sha2-512": 19, "sha3-512": 20, "sha3-384": 21, "sha3-256": 22, "sha3-224": 23, "shake-128": 24, "shake-256": 25, "keccak-224": 26, "keccak-256": 27, "keccak-384": 28, "keccak-512": 29, blake3: 30, "murmur3-128": 34, "murmur3-32": 35, "dbl-sha2-256": 86, md4: 212, md5: 213, bmt: 214, "sha2-256-trunc254-padded": 4114, "ripemd-128": 4178, "ripemd-160": 4179, "ripemd-256": 4180, "ripemd-320": 4181, x11: 4352, kangarootwelve: 7425, "sm3-256": 21325, "blake2b-8": 45569, "blake2b-16": 45570, "blake2b-24": 45571, "blake2b-32": 45572, "blake2b-40": 45573, "blake2b-48": 45574, "blake2b-56": 45575, "blake2b-64": 45576, "blake2b-72": 45577, "blake2b-80": 45578, "blake2b-88": 45579, "blake2b-96": 45580, "blake2b-104": 45581, "blake2b-112": 45582, "blake2b-120": 45583, "blake2b-128": 45584, "blake2b-136": 45585, "blake2b-144": 45586, "blake2b-152": 45587, "blake2b-160": 45588, "blake2b-168": 45589, "blake2b-176": 45590, "blake2b-184": 45591, "blake2b-192": 45592, "blake2b-200": 45593, "blake2b-208": 45594, "blake2b-216": 45595, "blake2b-224": 45596, "blake2b-232": 45597, "blake2b-240": 45598, "blake2b-248": 45599, "blake2b-256": 45600, "blake2b-264": 45601, "blake2b-272": 45602, "blake2b-280": 45603, "blake2b-288": 45604, "blake2b-296": 45605, "blake2b-304": 45606, "blake2b-312": 45607, "blake2b-320": 45608, "blake2b-328": 45609, "blake2b-336": 45610, "blake2b-344": 45611, "blake2b-352": 45612, "blake2b-360": 45613, "blake2b-368": 45614, "blake2b-376": 45615, "blake2b-384": 45616, "blake2b-392": 45617, "blake2b-400": 45618, "blake2b-408": 45619, "blake2b-416": 45620, "blake2b-424": 45621, "blake2b-432": 45622, "blake2b-440": 45623, "blake2b-448": 45624, "blake2b-456": 45625, "blake2b-464": 45626, "blake2b-472": 45627, "blake2b-480": 45628, "blake2b-488": 45629, "blake2b-496": 45630, "blake2b-504": 45631, "blake2b-512": 45632, "blake2s-8": 45633, "blake2s-16": 45634, "blake2s-24": 45635, "blake2s-32": 45636, "blake2s-40": 45637, "blake2s-48": 45638, "blake2s-56": 45639, "blake2s-64": 45640, "blake2s-72": 45641, "blake2s-80": 45642, "blake2s-88": 45643, "blake2s-96": 45644, "blake2s-104": 45645, "blake2s-112": 45646, "blake2s-120": 45647, "blake2s-128": 45648, "blake2s-136": 45649, "blake2s-144": 45650, "blake2s-152": 45651, "blake2s-160": 45652, "blake2s-168": 45653, "blake2s-176": 45654, "blake2s-184": 45655, "blake2s-192": 45656, "blake2s-200": 45657, "blake2s-208": 45658, "blake2s-216": 45659, "blake2s-224": 45660, "blake2s-232": 45661, "blake2s-240": 45662, "blake2s-248": 45663, "blake2s-256": 45664, "skein256-8": 45825, "skein256-16": 45826, "skein256-24": 45827, "skein256-32": 45828, "skein256-40": 45829, "skein256-48": 45830, "skein256-56": 45831, "skein256-64": 45832, "skein256-72": 45833, "skein256-80": 45834, "skein256-88": 45835, "skein256-96": 45836, "skein256-104": 45837, "skein256-112": 45838, "skein256-120": 45839, "skein256-128": 45840, "skein256-136": 45841, "skein256-144": 45842, "skein256-152": 45843, "skein256-160": 45844, "skein256-168": 45845, "skein256-176": 45846, "skein256-184": 45847, "skein256-192": 45848, "skein256-200": 45849, "skein256-208": 45850, "skein256-216": 45851, "skein256-224": 45852, "skein256-232": 45853, "skein256-240": 45854, "skein256-248": 45855, "skein256-256": 45856, "skein512-8": 45857, "skein512-16": 45858, "skein512-24": 45859, "skein512-32": 45860, "skein512-40": 45861, "skein512-48": 45862, "skein512-56": 45863, "skein512-64": 45864, "skein512-72": 45865, "skein512-80": 45866, "skein512-88": 45867, "skein512-96": 45868, "skein512-104": 45869, "skein512-112": 45870, "skein512-120": 45871, "skein512-128": 45872, "skein512-136": 45873, "skein512-144": 45874, "skein512-152": 45875, "skein512-160": 45876, "skein512-168": 45877, "skein512-176": 45878, "skein512-184": 45879, "skein512-192": 45880, "skein512-200": 45881, "skein512-208": 45882, "skein512-216": 45883, "skein512-224": 45884, "skein512-232": 45885, "skein512-240": 45886, "skein512-248": 45887, "skein512-256": 45888, "skein512-264": 45889, "skein512-272": 45890, "skein512-280": 45891, "skein512-288": 45892, "skein512-296": 45893, "skein512-304": 45894, "skein512-312": 45895, "skein512-320": 45896, "skein512-328": 45897, "skein512-336": 45898, "skein512-344": 45899, "skein512-352": 45900, "skein512-360": 45901, "skein512-368": 45902, "skein512-376": 45903, "skein512-384": 45904, "skein512-392": 45905, "skein512-400": 45906, "skein512-408": 45907, "skein512-416": 45908, "skein512-424": 45909, "skein512-432": 45910, "skein512-440": 45911, "skein512-448": 45912, "skein512-456": 45913, "skein512-464": 45914, "skein512-472": 45915, "skein512-480": 45916, "skein512-488": 45917, "skein512-496": 45918, "skein512-504": 45919, "skein512-512": 45920, "skein1024-8": 45921, "skein1024-16": 45922, "skein1024-24": 45923, "skein1024-32": 45924, "skein1024-40": 45925, "skein1024-48": 45926, "skein1024-56": 45927, "skein1024-64": 45928, "skein1024-72": 45929, "skein1024-80": 45930, "skein1024-88": 45931, "skein1024-96": 45932, "skein1024-104": 45933, "skein1024-112": 45934, "skein1024-120": 45935, "skein1024-128": 45936, "skein1024-136": 45937, "skein1024-144": 45938, "skein1024-152": 45939, "skein1024-160": 45940, "skein1024-168": 45941, "skein1024-176": 45942, "skein1024-184": 45943, "skein1024-192": 45944, "skein1024-200": 45945, "skein1024-208": 45946, "skein1024-216": 45947, "skein1024-224": 45948, "skein1024-232": 45949, "skein1024-240": 45950, "skein1024-248": 45951, "skein1024-256": 45952, "skein1024-264": 45953, "skein1024-272": 45954, "skein1024-280": 45955, "skein1024-288": 45956, "skein1024-296": 45957, "skein1024-304": 45958, "skein1024-312": 45959, "skein1024-320": 45960, "skein1024-328": 45961, "skein1024-336": 45962, "skein1024-344": 45963, "skein1024-352": 45964, "skein1024-360": 45965, "skein1024-368": 45966, "skein1024-376": 45967, "skein1024-384": 45968, "skein1024-392": 45969, "skein1024-400": 45970, "skein1024-408": 45971, "skein1024-416": 45972, "skein1024-424": 45973, "skein1024-432": 45974, "skein1024-440": 45975, "skein1024-448": 45976, "skein1024-456": 45977, "skein1024-464": 45978, "skein1024-472": 45979, "skein1024-480": 45980, "skein1024-488": 45981, "skein1024-496": 45982, "skein1024-504": 45983, "skein1024-512": 45984, "skein1024-520": 45985, "skein1024-528": 45986, "skein1024-536": 45987, "skein1024-544": 45988, "skein1024-552": 45989, "skein1024-560": 45990, "skein1024-568": 45991, "skein1024-576": 45992, "skein1024-584": 45993, "skein1024-592": 45994, "skein1024-600": 45995, "skein1024-608": 45996, "skein1024-616": 45997, "skein1024-624": 45998, "skein1024-632": 45999, "skein1024-640": 46e3, "skein1024-648": 46001, "skein1024-656": 46002, "skein1024-664": 46003, "skein1024-672": 46004, "skein1024-680": 46005, "skein1024-688": 46006, "skein1024-696": 46007, "skein1024-704": 46008, "skein1024-712": 46009, "skein1024-720": 46010, "skein1024-728": 46011, "skein1024-736": 46012, "skein1024-744": 46013, "skein1024-752": 46014, "skein1024-760": 46015, "skein1024-768": 46016, "skein1024-776": 46017, "skein1024-784": 46018, "skein1024-792": 46019, "skein1024-800": 46020, "skein1024-808": 46021, "skein1024-816": 46022, "skein1024-824": 46023, "skein1024-832": 46024, "skein1024-840": 46025, "skein1024-848": 46026, "skein1024-856": 46027, "skein1024-864": 46028, "skein1024-872": 46029, "skein1024-880": 46030, "skein1024-888": 46031, "skein1024-896": 46032, "skein1024-904": 46033, "skein1024-912": 46034, "skein1024-920": 46035, "skein1024-928": 46036, "skein1024-936": 46037, "skein1024-944": 46038, "skein1024-952": 46039, "skein1024-960": 46040, "skein1024-968": 46041, "skein1024-976": 46042, "skein1024-984": 46043, "skein1024-992": 46044, "skein1024-1000": 46045, "skein1024-1008": 46046, "skein1024-1016": 46047, "skein1024-1024": 46048, "poseidon-bls12_381-a2-fc1": 46081, "poseidon-bls12_381-a2-fc1-sc": 46082 });
                E.exports = { names: d };
            }, function (E, m, f) {
                "use strict";
                E.exports = function r(e, c, n) { if (Number.MAX_SAFE_INTEGER && e > Number.MAX_SAFE_INTEGER)
                    throw r.bytes = 0, new RangeError("Could not encode varint"); c = c || []; for (var t = n = n || 0; e >= d;)
                    c[n++] = 255 & e | 128, e /= 128; for (; -128 & e;)
                    c[n++] = 255 & e | 128, e >>>= 7; return c[n] = 0 | e, r.bytes = n - t + 1, c; };
                var d = Math.pow(2, 31);
            }, function (E, m, f) {
                "use strict";
                E.exports = function d(r, e) { var c, n = 0, t = 0, s = e = e || 0, u = r.length; do {
                    if (s >= u || t > 49)
                        throw d.bytes = 0, new RangeError("Could not decode varint");
                    c = r[s++], n += t < 28 ? (127 & c) << t : (127 & c) * Math.pow(2, t), t += 7;
                } while (c >= 128); return d.bytes = s - e, n; };
            }, function (E, m, f) {
                "use strict";
                var d = Math.pow(2, 7), r = Math.pow(2, 14), e = Math.pow(2, 21), c = Math.pow(2, 28), n = Math.pow(2, 35), t = Math.pow(2, 42), s = Math.pow(2, 49), u = Math.pow(2, 56), i = Math.pow(2, 63);
                E.exports = function (o) { return o < d ? 1 : o < r ? 2 : o < e ? 3 : o < c ? 4 : o < n ? 5 : o < t ? 6 : o < s ? 7 : o < u ? 8 : o < i ? 9 : 10; };
            }, function (E, m, f) {
                "use strict";
                const { baseTable: d } = f(81), r = new Map;
                for (const e in d) {
                    const c = d[e];
                    r.set(c, e);
                }
                E.exports = Object.freeze(r);
            }, function (E, m, f) {
                "use strict";
                const { baseTable: d } = f(81), r = f(224).varintEncode, e = {};
                for (const c in d) {
                    const n = d[c];
                    e[c] = r(n);
                }
                E.exports = Object.freeze(e);
            }, function (E, m, f) {
                "use strict";
                const { baseTable: d } = f(81), r = {};
                for (const [e, c] of Object.entries(d))
                    r[e.toUpperCase().replace(/-/g, "_")] = c;
                E.exports = Object.freeze(r);
            }, function (E, m, f) {
                "use strict";
                const { baseTable: d } = f(81), r = {};
                for (const [e, c] of Object.entries(d))
                    r[c] === void 0 && (r[c] = e);
                E.exports = Object.freeze(r);
            }, function (E, m, f) {
                "use strict";
                const d = f(48), r = { checkCIDComponents: function (e) { if (e == null)
                        return "null values are not valid CIDs"; if (e.version !== 0 && e.version !== 1)
                        return "Invalid version, must be a number equal to 1 or 0"; if (typeof e.codec != "string")
                        return "codec must be string"; if (e.version === 0) {
                        if (e.codec !== "dag-pb")
                            return "codec must be 'dag-pb' for CIDv0";
                        if (e.multibaseName !== "base58btc")
                            return "multibaseName must be 'base58btc' for CIDv0";
                    } if (!(e.multihash instanceof Uint8Array))
                        return "multihash must be a Uint8Array"; try {
                        d.validate(e.multihash);
                    }
                    catch (c) {
                        let n = c.message;
                        return n || (n = "Multihash validation failed"), n;
                    } } };
                E.exports = r;
            }, function (E, m, f) {
                "use strict";
                var d = f(423), r = f(425);
                E.exports = d, E.exports.parse = d, E.exports.stringify = r;
            }, function (E, m, f) {
                "use strict";
                var d = f(424), r = ["int32", "int64", "uint32", "uint64", "sint32", "sint64", "bool", "fixed64", "sfixed64", "double", "fixed32", "sfixed32", "float"], e = function (v) { for (var R = {}; v.length;)
                    switch (v[0]) {
                        case "[":
                        case ",":
                            v.shift();
                            var _ = v.shift();
                            if (_ === "(" && (_ = v.shift(), v.shift()), v[0] !== "=")
                                throw new Error("Unexpected token in field options: " + v[0]);
                            if (v.shift(), v[0] === "]")
                                throw new Error("Unexpected ] in field option");
                            R[_] = v.shift();
                            break;
                        case "]": return v.shift(), R;
                        default: throw new Error("Unexpected token in field options: " + v[0]);
                    } throw new Error("No closing tag for field options"); }, c = function (v) { for (var R = { name: null, type: null, tag: -1, map: null, oneof: null, required: !1, repeated: !1, options: {} }; v.length;)
                    switch (v[0]) {
                        case "=":
                            v.shift(), R.tag = Number(v.shift());
                            break;
                        case "map":
                            if (R.type = "map", R.map = { from: null, to: null }, v.shift(), v[0] !== "<")
                                throw new Error("Unexpected token in map type: " + v[0]);
                            if (v.shift(), R.map.from = v.shift(), v[0] !== ",")
                                throw new Error("Unexpected token in map type: " + v[0]);
                            if (v.shift(), R.map.to = v.shift(), v[0] !== ">")
                                throw new Error("Unexpected token in map type: " + v[0]);
                            v.shift(), R.name = v.shift();
                            break;
                        case "repeated":
                        case "required":
                        case "optional":
                            var _ = v.shift();
                            R.required = _ === "required", R.repeated = _ === "repeated", R.type = v.shift(), R.name = v.shift();
                            break;
                        case "[":
                            R.options = e(v);
                            break;
                        case ";":
                            if (R.name === null)
                                throw new Error("Missing field name");
                            if (R.type === null)
                                throw new Error("Missing type in message field: " + R.name);
                            if (R.tag === -1)
                                throw new Error("Missing tag number in message field: " + R.name);
                            return v.shift(), R;
                        default: throw new Error("Unexpected token in message field: " + v[0]);
                    } throw new Error("No ; found for message field"); }, n = function (v) { for (var R = { enums: [], options: {}, messages: [], fields: [], extends: [], extensions: null }; v.length;)
                    switch (v[0]) {
                        case "map":
                        case "repeated":
                        case "optional":
                        case "required":
                            R.fields.push(c(v));
                            break;
                        case "enum":
                            R.enums.push(a(v));
                            break;
                        case "message":
                            R.messages.push(u(v));
                            break;
                        case "extensions":
                            R.extensions = s(v);
                            break;
                        case "oneof":
                            v.shift();
                            var _ = v.shift();
                            if (v[0] !== "{")
                                throw new Error("Unexpected token in oneof: " + v[0]);
                            for (v.shift(); v[0] !== "}";) {
                                v.unshift("optional");
                                var k = c(v);
                                k.oneof = _, R.fields.push(k);
                            }
                            v.shift();
                            break;
                        case "extend":
                            R.extends.push(t(v));
                            break;
                        case ";":
                            v.shift();
                            break;
                        case "reserved":
                            for (v.shift(); v[0] !== ";";)
                                v.shift();
                            break;
                        case "option":
                            var x = l(v);
                            if (R.options[x.name] !== void 0)
                                throw new Error("Duplicate option " + x.name);
                            R.options[x.name] = x.value;
                            break;
                        default: v.unshift("optional"), R.fields.push(c(v));
                    } return R; }, t = function (v) { return { name: v[1], message: u(v) }; }, s = function (v) { v.shift(); var R = Number(v.shift()); if (isNaN(R))
                    throw new Error("Invalid from in extensions definition"); if (v.shift() !== "to")
                    throw new Error("Expected keyword 'to' in extensions definition"); var _ = v.shift(); if (_ === "max" && (_ = 536870911), _ = Number(_), isNaN(_))
                    throw new Error("Invalid to in extensions definition"); if (v.shift() !== ";")
                    throw new Error("Missing ; in extensions definition"); return { from: R, to: _ }; }, u = function (v) { v.shift(); var R = 1, _ = [], k = { name: v.shift(), options: {}, enums: [], extends: [], messages: [], fields: [] }; if (v[0] !== "{")
                    throw new Error("Expected { but found " + v[0]); for (v.shift(); v.length;) {
                    if (v[0] === "{" ? R++ : v[0] === "}" && R--, !R)
                        return v.shift(), _ = n(_), k.enums = _.enums, k.messages = _.messages, k.fields = _.fields, k.extends = _.extends, k.extensions = _.extensions, k.options = _.options, k;
                    _.push(v.shift());
                } if (R)
                    throw new Error("No closing tag for message"); }, i = function (v) { v.shift(); var R = v.shift(); if (v[0] !== ";")
                    throw new Error("Expected ; but found " + v[0]); return v.shift(), R; }, o = function (v) { if (v.shift(), v[0] !== "=")
                    throw new Error("Expected = but found " + v[0]); v.shift(); var R = v.shift(); switch (R) {
                    case '"proto2"':
                        R = 2;
                        break;
                    case '"proto3"':
                        R = 3;
                        break;
                    default: throw new Error("Expected protobuf syntax version but found " + R);
                } if (v[0] !== ";")
                    throw new Error("Expected ; but found " + v[0]); return v.shift(), R; }, h = function (v) { if (v.length < 4)
                    throw new Error("Invalid enum value: " + v.slice(0, 3).join(" ")); if (v[1] !== "=")
                    throw new Error("Expected = but found " + v[1]); if (v[3] !== ";" && v[3] !== "[")
                    throw new Error("Expected ; or [ but found " + v[1]); var R = v.shift(); v.shift(); var _ = { value: null, options: {} }; return _.value = Number(v.shift()), v[0] === "[" && (_.options = e(v)), v.shift(), { name: R, val: _ }; }, a = function (v) { v.shift(); var R = {}, _ = { name: v.shift(), values: {}, options: {} }; if (v[0] !== "{")
                    throw new Error("Expected { but found " + v[0]); for (v.shift(); v.length;) {
                    if (v[0] === "}")
                        return v.shift(), v[0] === ";" && v.shift(), _;
                    if (v[0] !== "option") {
                        var k = h(v);
                        _.values[k.name] = k.val;
                    }
                    else
                        R = l(v), _.options[R.name] = R.value;
                } throw new Error("No closing tag for enum"); }, l = function (v) { for (var R = null, _ = null, k = function (M) { return M === "true" || M !== "false" && M.replace(/^"+|"+$/gm, ""); }; v.length;) {
                    if (v[0] === ";")
                        return v.shift(), { name: R, value: _ };
                    switch (v[0]) {
                        case "option":
                            v.shift();
                            var x = v[0] === "(";
                            if (x && v.shift(), R = v.shift(), x) {
                                if (v[0] !== ")")
                                    throw new Error("Expected ) but found " + v[0]);
                                v.shift();
                            }
                            v[0][0] === "." && (R += v.shift());
                            break;
                        case "=":
                            if (v.shift(), R === null)
                                throw new Error("Expected key for option with value: " + v[0]);
                            if (_ = k(v.shift()), R === "optimize_for" && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(_))
                                throw new Error("Unexpected value for option optimize_for: " + _);
                            _ === "{" && (_ = p(v));
                            break;
                        default: throw new Error("Unexpected token in option: " + v[0]);
                    }
                } }, p = function (v) { for (var R = function (N) { return N === "true" || N !== "false" && N.replace(/^"+|"+$/gm, ""); }, _ = {}; v.length;) {
                    if (v[0] === "}")
                        return v.shift(), _;
                    var k = v[0] === "(";
                    k && v.shift();
                    var x = v.shift();
                    if (k) {
                        if (v[0] !== ")")
                            throw new Error("Expected ) but found " + v[0]);
                        v.shift();
                    }
                    var M = null;
                    switch (v[0]) {
                        case ":":
                            if (_[x] !== void 0)
                                throw new Error("Duplicate option map key " + x);
                            v.shift(), (M = R(v.shift())) === "{" && (M = p(v)), _[x] = M, v[0] === ";" && v.shift();
                            break;
                        case "{":
                            if (v.shift(), M = p(v), _[x] === void 0 && (_[x] = []), !Array.isArray(_[x]))
                                throw new Error("Duplicate option map key " + x);
                            _[x].push(M);
                            break;
                        default: throw new Error("Unexpected token in option map: " + v[0]);
                    }
                } throw new Error("No closing tag for option map"); }, g = function (v) { v.shift(); var R = v.shift().replace(/^"+|"+$/gm, ""); if (v[0] !== ";")
                    throw new Error("Unexpected token: " + v[0] + '. Expected ";"'); return v.shift(), R; }, b = function (v) { v.shift(); var R = { name: v.shift(), methods: [], options: {} }; if (v[0] !== "{")
                    throw new Error("Expected { but found " + v[0]); for (v.shift(); v.length;) {
                    if (v[0] === "}")
                        return v.shift(), v[0] === ";" && v.shift(), R;
                    switch (v[0]) {
                        case "option":
                            var _ = l(v);
                            if (R.options[_.name] !== void 0)
                                throw new Error("Duplicate option " + _.name);
                            R.options[_.name] = _.value;
                            break;
                        case "rpc":
                            R.methods.push(I(v));
                            break;
                        default: throw new Error("Unexpected token in service: " + v[0]);
                    }
                } throw new Error("No closing tag for service"); }, I = function (v) { v.shift(); var R = { name: v.shift(), input_type: null, output_type: null, client_streaming: !1, server_streaming: !1, options: {} }; if (v[0] !== "(")
                    throw new Error("Expected ( but found " + v[0]); if (v.shift(), v[0] === "stream" && (v.shift(), R.client_streaming = !0), R.input_type = v.shift(), v[0] !== ")")
                    throw new Error("Expected ) but found " + v[0]); if (v.shift(), v[0] !== "returns")
                    throw new Error("Expected returns but found " + v[0]); if (v.shift(), v[0] !== "(")
                    throw new Error("Expected ( but found " + v[0]); if (v.shift(), v[0] === "stream" && (v.shift(), R.server_streaming = !0), R.output_type = v.shift(), v[0] !== ")")
                    throw new Error("Expected ) but found " + v[0]); if (v.shift(), v[0] === ";")
                    return v.shift(), R; if (v[0] !== "{")
                    throw new Error("Expected { but found " + v[0]); for (v.shift(); v.length;) {
                    if (v[0] === "}")
                        return v.shift(), v[0] === ";" && v.shift(), R;
                    if (v[0] !== "option")
                        throw new Error("Unexpected token in rpc options: " + v[0]);
                    var _ = l(v);
                    if (R.options[_.name] !== void 0)
                        throw new Error("Duplicate option " + _.name);
                    R.options[_.name] = _.value;
                } throw new Error("No closing tag for rpc"); };
                E.exports = function (v) { for (var R = d(v.toString()), _ = 0; _ < R.length; _++) {
                    var k;
                    if (/^("|')([^'"]*)$/.test(R[_])) {
                        for (k = R[_].length === 1 ? _ + 1 : _; k < R.length; k++)
                            if (/^[^'"\\]*(?:\\.[^'"\\]*)*("|')$/.test(R[k])) {
                                R = R.slice(0, _).concat(R.slice(_, k + 1).join("")).concat(R.slice(k + 1));
                                break;
                            }
                    }
                } for (var x = { syntax: 3, package: null, imports: [], enums: [], messages: [], options: {}, extends: [] }, M = !0; R.length;) {
                    switch (R[0]) {
                        case "package":
                            x.package = i(R);
                            break;
                        case "syntax":
                            if (!M)
                                throw new Error("Protobuf syntax version should be first thing in file");
                            x.syntax = o(R);
                            break;
                        case "message":
                            x.messages.push(u(R));
                            break;
                        case "enum":
                            x.enums.push(a(R));
                            break;
                        case "option":
                            var N = l(R);
                            if (x.options[N.name])
                                throw new Error("Duplicate option " + N.name);
                            x.options[N.name] = N.value;
                            break;
                        case "import":
                            x.imports.push(g(R));
                            break;
                        case "extend":
                            x.extends.push(t(R));
                            break;
                        case "service":
                            x.services || (x.services = []), x.services.push(b(R));
                            break;
                        default: throw new Error("Unexpected token: " + R[0]);
                    }
                    M = !1;
                } return x.extends.forEach(function (S) { x.messages.forEach(function (T) { T.name === S.name && S.message.fields.forEach(function (B) { if (!T.extensions || B.tag < T.extensions.from || B.tag > T.extensions.to)
                    throw new Error(T.name + " does not declare " + B.tag + " as an extension number"); T.fields.push(B); }); }); }), x.messages.forEach(function (S) { S.fields.forEach(function (T) { var B, P, L, j; if (T.options && T.options.packed === "true" && r.indexOf(T.type) === -1) {
                    if (T.type.indexOf(".") === -1) {
                        if (S.enums && S.enums.some(function (D) { return D.name === T.type; }))
                            return;
                    }
                    else {
                        if ((B = T.type.split(".")).length > 2)
                            throw new Error("what is this?");
                        if (P = B[0], L = B[1], x.messages.some(function (D) { if (D.name === P)
                            return j = D, D; }), j && j.enums && j.enums.some(function (D) { return D.name === L; }))
                            return;
                    }
                    throw new Error("Fields of type " + T.type + ' cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared "packed". See https://developers.google.com/protocol-buffers/docs/encoding#optional');
                } }); }), x; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) {
                    var r, e = function (c) { return c.trim(); };
                    return d.replace(/([;,{}()=:[\]<>]|\/\*|\*\/)/g, " $1 ").split(/\n/).map(e).filter(Boolean).map(function (c) { var n = c.indexOf("//"); return n > -1 ? c.slice(0, n) : c; }).map(e).filter(Boolean).join(`
`).split(/\s+|\n+/gm).filter((r = !1, function (c) { return c === "/*" ? (r = !0, !1) : c === "*/" ? (r = !1, !1) : !r; }));
                };
            }, function (E, m, f) {
                "use strict";
                var d = function (i, o) { var h = i.repeated ? "repeated" : i.required ? "required" : "optional"; i.type === "map" && (h = "map<" + i.map.from + "," + i.map.to + ">"), i.oneof && (h = ""); var a = Object.keys(i.options || {}).map(function (l) { return l + " = " + i.options[l]; }).join(","); return a && (a = " [" + a + "]"), o.push((h ? h + " " : "") + (i.map === "map" ? "" : i.type + " ") + i.name + " = " + i.tag + a + ";"), o; }, r = function (i, o) { o.push("message " + i.name + " {"), i.options || (i.options = {}), n(i.options, o), i.enums || (i.enums = []), i.enums.forEach(function (a) { o.push(e(a, [])); }), i.messages || (i.messages = []), i.messages.forEach(function (a) { o.push(r(a, [])); }); var h = {}; return i.fields || (i.fields = []), i.fields.forEach(function (a) { a.oneof ? (h[a.oneof] || (h[a.oneof] = []), h[a.oneof].push(d(a, []))) : o.push(d(a, [])); }), Object.keys(h).forEach(function (a) { h[a].unshift("oneof " + a + " {"), h[a].push("}"), o.push(h[a]); }), o.push("}", ""), o; }, e = function (i, o) { o.push("enum " + i.name + " {"), i.options || (i.options = {}); var h = n(i.options, []); return h.length > 1 && o.push(h.slice(0, -1)), Object.keys(i.values).map(function (a) { var l = c(i.values[a]); o.push([a + " = " + l + ";"]); }), o.push("}", ""), o; }, c = function (i, o) { var h = Object.keys(i.options || {}).map(function (a) { return a + " = " + i.options[a]; }).join(","); return h && (h = " [" + h + "]"), i.value + h; }, n = function (i, o) { var h = Object.keys(i); return h.forEach(function (a) { var l = i[a]; ~a.indexOf(".") && (a = "(" + a + ")"); var p = typeof l; p === "object" ? (l = t(l, [])).length && o.push("option " + a + " = {", l, "};") : (p === "string" && a !== "optimize_for" && (l = '"' + l + '"'), o.push("option " + a + " = " + l + ";")); }), h.length > 0 && o.push(""), o; }, t = function (i, o) { return Object.keys(i).forEach(function (h) { var a = i[h], l = typeof a; l === "object" ? Array.isArray(a) ? a.forEach(function (p) { (p = t(p, [])).length && o.push(h + " {", p, "}"); }) : (a = t(a, [])).length && o.push(h + " {", a, "}") : (l === "string" && (a = '"' + a + '"'), o.push(h + ": " + a)); }), o; }, s = function (i, o) { var h = "rpc " + i.name + "("; i.client_streaming && (h += "stream "), h += i.input_type + ") returns (", i.server_streaming && (h += "stream "), h += i.output_type + ")", i.options || (i.options = {}); var a = n(i.options, []); return a.length > 1 ? o.push(h + " {", a.slice(0, -1), "}") : o.push(h + ";"), o; }, u = function (i) {
                    return function (o) {
                        return Array.isArray(o) ? o.map(u(i + "  ")).join(`
`) : i + o;
                    };
                };
                E.exports = function (i) {
                    var o = [];
                    return o.push('syntax = "proto' + i.syntax + '";', ""), i.package && o.push("package " + i.package + ";", ""), i.options || (i.options = {}), n(i.options, o), i.enums || (i.enums = []), i.enums.forEach(function (h) { e(h, o); }), i.messages || (i.messages = []), i.messages.forEach(function (h) { r(h, o); }), i.services && i.services.forEach(function (h) { !function (a, l) { l.push("service " + a.name + " {"), a.options || (a.options = {}), n(a.options, l), a.methods || (a.methods = []), a.methods.forEach(function (p) { l.push(s(p, [])); }), l.push("}", ""); }(h, o); }), o.map(u("")).join(`
`);
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(427), r = f(444), e = f(445), c = f(446), n = f(19);
                E.exports = function (t, s) { const u = {}, i = {}, o = {}, h = function (p, g) { p.enums && p.enums.forEach(function (b) { b.id = g + (g ? "." : "") + b.name, i[b.id] = b, h(b, b.id); }), p.messages && p.messages.forEach(function (b) { b.id = g + (g ? "." : "") + b.name, u[b.id] = b, b.fields.forEach(function (I) { if (!I.map)
                    return; const v = "Map_" + I.map.from + "_" + I.map.to, R = { name: v, enums: [], messages: [], fields: [{ name: "key", type: I.map.from, tag: 1, repeated: !1, required: !0 }, { name: "value", type: I.map.to, tag: 2, repeated: !1, required: !1 }], extensions: null, id: g + (g ? "." : "") + v }; u[R.id] || (u[R.id] = R, p.messages.push(R)), I.type = v, I.repeated = !0; }), h(b, b.id); }); }; h(t, ""); const a = function (p, g) { p.messages.forEach(function (k) { g[k.name] = l(k.name, p.id); }), p.enums.forEach(function (k) { g[k.name] = function (x) { if (!x)
                    return null; const M = {}; return Object.keys(x).forEach(function (N) { M[N] = x[N].value; }), M; }(k.values); }), g.type = 2, g.message = !0, g.name = p.name; const b = {}; p.fields.forEach(function (k) { k.oneof && (b[k.oneof] || (b[k.oneof] = []), b[k.oneof].push(k.name)); }); const I = p.fields.map(function (k) { return l(k.type, p.id); }), v = c(p, I, b), R = e(p, l, I, b, v), _ = r(p, l, I); return R.bytes = _.bytes = 0, g.buffer = !0, g.encode = R, g.decode = _, g.encodingLength = v, g; }, l = function (p, g, b) { if (s && s[p])
                    return s[p]; if (d[p])
                    return d[p]; const I = (g ? g + "." + p : p).split(".").map(function (v, R, _) { return _.slice(0, R).concat(p).join("."); }).reverse().reduce(function (v, R) { return v || u[R] || i[R]; }, null); if (b === !1)
                    return I; if (!I)
                    throw new Error("Could not resolve " + p); return I.values ? function (v) { const R = Object.keys(v.values || []).map(function (_) { return parseInt(v.values[_].value, 10); }); return d.make(0, function _(k, x, M, N) { if (!R.length || R.indexOf(k) === -1)
                    throw new Error("Invalid enum value: " + k); return n.encode(k, x, N), _.bytes = n.encode.bytes, x; }, function _(k, x, M) { var N = n.decode(k, M); if (!R.length || R.indexOf(N) === -1)
                    throw new Error("Invalid enum value: " + N); return _.bytes = n.decode.bytes, N; }, n.encodingLength); }(I) : o[I.id] || a(I, o[I.id] = {}); }; return (t.enums || []).concat((t.messages || []).map(function (p) { return l(p.id); })); };
            }, function (E, m, f) {
                "use strict";
                m.make = f(32), m.bytes = f(428), m.string = f(432), m.bool = f(433), m.int32 = f(434), m.int64 = f(435), m.sint32 = m.sint64 = f(436), m.uint32 = m.uint64 = m.enum = m.varint = f(438), m.fixed64 = m.sfixed64 = f(439), m.double = f(440), m.fixed32 = f(441), m.sfixed32 = f(442), m.float = f(443);
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(32);
                function e(c) { return c.byteLength; }
                E.exports = r(2, function c(n, t, s, u) { const i = u, o = e(n); d.encode(o, t, u), u += d.encode.bytes, t.set(n, u), c.bytes = (u += o) - i; }, function c(n, t, s) { const u = s, i = d.decode(n, s); s += d.decode.bytes; const o = n.slice(s, s + i); return s += o.length, c.bytes = s - u, o; }, function (c) { const n = e(c); return d.encodingLength(n) + n; });
            }, function (E, m, f) {
                "use strict";
                E.exports = function r(e, c, n) { c = c || []; for (var t = n = n || 0; e >= d;)
                    c[n++] = 255 & e | 128, e /= 128; for (; -128 & e;)
                    c[n++] = 255 & e | 128, e >>>= 7; return c[n] = 0 | e, r.bytes = n - t + 1, c; };
                var d = Math.pow(2, 31);
            }, function (E, m, f) {
                "use strict";
                E.exports = function d(r, e) { var c, n = 0, t = 0, s = e = e || 0, u = r.length; do {
                    if (s >= u)
                        throw d.bytes = 0, new RangeError("Could not decode varint");
                    c = r[s++], n += t < 28 ? (127 & c) << t : (127 & c) * Math.pow(2, t), t += 7;
                } while (c >= 128); return d.bytes = s - e, n; };
            }, function (E, m, f) {
                "use strict";
                var d = Math.pow(2, 7), r = Math.pow(2, 14), e = Math.pow(2, 21), c = Math.pow(2, 28), n = Math.pow(2, 35), t = Math.pow(2, 42), s = Math.pow(2, 49), u = Math.pow(2, 56), i = Math.pow(2, 63);
                E.exports = function (o) { return o < d ? 1 : o < r ? 2 : o < e ? 3 : o < c ? 4 : o < n ? 5 : o < t ? 6 : o < s ? 7 : o < u ? 8 : o < i ? 9 : 10; };
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(6), e = f(5), c = f(32);
                E.exports = c(2, function n(t, s, u, i) { const o = i, h = r(t).byteLength; d.encode(h, s, i, "utf-8"), i += d.encode.bytes; const a = r(t); s.set(a, i), i += a.length, n.bytes = i - o; }, function n(t, s, u) { const i = u, o = d.decode(t, u); u += d.decode.bytes; const h = e(t.subarray(u, u + o)); return n.bytes = (u += o) - i, h; }, function (n) { const t = r(n).byteLength; return d.encodingLength(t) + t; });
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(0, function r(e, c, n, t) { c[t] = e ? 1 : 0, r.bytes = 1; }, function r(e, c, n) { const t = e[n] > 0; return r.bytes = 1, t; }, function () { return 1; });
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(32);
                E.exports = r(0, function e(c, n, t, s) { d.encode(c < 0 ? c + 4294967296 : c, n, s), e.bytes = d.encode.bytes; }, function e(c, n, t) { const s = d.decode(c, t); return e.bytes = d.decode.bytes, s > 2147483647 ? s - 4294967296 : s; }, function (e) { return d.encodingLength(e < 0 ? e + 4294967296 : e); });
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(32);
                E.exports = r(0, function e(c, n, t, s) { if (c < 0) {
                    const u = s + 9;
                    for (d.encode(-1 * c, n, s), n[s += d.encode.bytes - 1] = 128 | n[s]; s < u - 1;)
                        n[++s] = 255;
                    n[u] = 1, e.bytes = 10;
                }
                else
                    d.encode(c, n, s), e.bytes = d.encode.bytes; }, function e(c, n, t) { let s = d.decode(c, t); if (s >= Math.pow(2, 63)) {
                    let u = 9;
                    for (; c[t + u - 1] === 255;)
                        u--;
                    u = u || 9;
                    const i = c.subarray(t, t + u);
                    i[u - 1] = 127 & i[u - 1], s = -1 * d.decode(i, 0), e.bytes = 10;
                }
                else
                    e.bytes = d.decode.bytes; return s; }, function (e) { return e < 0 ? 10 : d.encodingLength(e); });
            }, function (E, m, f) {
                "use strict";
                const d = f(437), r = f(32);
                E.exports = r(0, function e(c, n, t, s) { d.encode(c, n, s), e.bytes = d.encode.bytes; }, function e(c, n, t) { const s = d.decode(c, t); return e.bytes = d.decode.bytes, s; }, d.encodingLength);
            }, function (E, m, f) {
                "use strict";
                var d = f(19);
                m.encode = function r(e, c, n) { e = e >= 0 ? 2 * e : -2 * e - 1; var t = d.encode(e, c, n); return r.bytes = d.encode.bytes, t; }, m.decode = function r(e, c) { var n = d.decode(e, c); return r.bytes = d.decode.bytes, 1 & n ? (n + 1) / -2 : n / 2; }, m.encodingLength = function (r) { return d.encodingLength(r >= 0 ? 2 * r : -2 * r - 1); };
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(32);
                E.exports = r(0, function e(c, n, t, s) { d.encode(c, n, s), e.bytes = d.encode.bytes; }, function e(c, n, t) { const s = d.decode(c, t); return e.bytes = d.decode.bytes, s; }, d.encodingLength);
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(1, function r(e, c, n, t) { for (const s of e)
                    c[t] = s, t++; r.bytes = 8; }, function r(e, c, n) { const t = e.slice(n, n + 8); return r.bytes = 8, t; }, function () { return 8; });
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(1, function r(e, c, n, t) { n.setFloat64(t, e, !0), r.bytes = 8; }, function r(e, c, n) { const t = c.getFloat64(n, !0); return r.bytes = 8, t; }, function () { return 8; });
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(5, function r(e, c, n, t) { n.setUint32(t, e, !0), r.bytes = 4; }, function r(e, c, n) { const t = c.getUint32(n, !0); return r.bytes = 4, t; }, function (r) { return 4; });
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(5, function r(e, c, n, t) { n.setInt32(t, e, !0), r.bytes = 4; }, function r(e, c, n) { const t = c.getInt32(n, !0); return r.bytes = 4, t; }, function (r) { return 4; });
            }, function (E, m, f) {
                "use strict";
                const d = f(32);
                E.exports = d(5, function r(e, c, n, t) { n.setFloat32(t, e, !0), r.bytes = 4; }, function r(e, c, n) { const t = c.getFloat32(n, !0); return r.bytes = 4, t; }, function () { return 4; });
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(141).defined;
                function e(u) { return `${u.substring(0, 1).toUpperCase()}${u.substring(1)}`; }
                function c(u, i, o, h) { if (Object.prototype.hasOwnProperty.call(u, i))
                    return; const a = e(i); Object.defineProperties(u, { [i]: { enumerable: !0, configurable: !0, set: l => { o = l; }, get: () => o === void 0 ? h : o }, ["has" + a]: { configurable: !0, value: () => o !== void 0 }, ["set" + a]: { configurable: !0, value: l => { o = l; } }, ["get" + a]: { configurable: !0, value: () => o }, ["clear" + a]: { configurable: !0, value: () => { o = void 0, u[i] = void 0; } } }); }
                var n = function (u, i, o, h) { switch (u) {
                    case 0: return d.decode(i, h), h + d.decode.bytes;
                    case 1: return h + 8;
                    case 2:
                        var a = d.decode(i, h);
                        return h + d.decode.bytes + a;
                    case 3:
                    case 4: throw new Error("Groups are not supported");
                    case 5: return h + 4;
                    default: throw new Error("Unknown wire type: " + u);
                } }, t = function (u) { if (u.map)
                    return {}; if (u.repeated)
                    return []; switch (u.type) {
                    case "string": return "";
                    case "bool": return !1;
                    case "float":
                    case "double":
                    case "sfixed32":
                    case "fixed32":
                    case "varint":
                    case "enum":
                    case "uint64":
                    case "uint32":
                    case "int64":
                    case "int32":
                    case "sint64":
                    case "sint32": return 0;
                    default: return null;
                } }, s = function (u, i) { if (i === void 0)
                    return i; switch (u.type) {
                    case "bool": return i === "true";
                    case "float":
                    case "double":
                    case "sfixed32":
                    case "fixed32":
                    case "varint":
                    case "enum":
                    case "uint64":
                    case "uint32":
                    case "int64":
                    case "int32":
                    case "sint64":
                    case "sint32": return parseInt(i, 10);
                    default: return i;
                } };
                E.exports = function (u, i, o) { const h = [], a = {}, l = [], p = []; for (var g = 0; g < o.length; g++) {
                    const I = u.fields[g];
                    a[I.tag] = g;
                    const v = I.options && I.options.default, R = i(I.type, u.id, !1);
                    p[g] = [v, R && R.values], u.fields[g].packed = I.repeated && I.options && I.options.packed && I.options.packed !== "false", I.required && h.push(I.name), I.oneof && l.push(I.name);
                } function b(I, v, R, _, k, x, M) { const N = v.name; if (v.oneof) {
                    const B = Object.keys(R);
                    for (var S = 0; S < B.length; S++)
                        if (l.indexOf(B[S]) > -1) {
                            const P = e(B[S]);
                            delete R["has" + P], delete R["get" + P], delete R["set" + P], delete R["clear" + P], delete R[B[S]];
                        }
                } let T; if (I.message) {
                    const B = d.decode(_, x);
                    x += d.decode.bytes;
                    const P = I.decode(_, k, x, x + B);
                    v.map ? (T = R[N] || {}, T[P.key] = P.value) : v.repeated ? (T = R[N] || [], T.push(P)) : T = P;
                }
                else
                    v.repeated ? (T = R[N] || [], T.push(I.decode(_, k, x))) : T = I.decode(_, k, x); return c(R, N, T), x += I.decode.bytes; } return function I(v, R, _, k) { if (_ == null && (_ = 0), k == null && (k = v.length), !(k <= v.length && _ <= v.length))
                    throw new Error("Decoded message is not valid"); R || (R = new DataView(v.buffer, v.byteOffset, v.byteLength)); for (var x, M = _, N = {};;) {
                    if (k <= _) {
                        var S, T, B = "", P = 0;
                        for (P = 0; P < h.length; P++)
                            if (B = h[P], !r(N[B]))
                                throw new Error("Decoded message is not valid, missing required field: " + B);
                        for (P = 0; P < o.length; P++) {
                            let K;
                            if (x = u.fields[P], T = p[P][0], S = p[P][1], B = x.name, !Object.prototype.hasOwnProperty.call(N, B)) {
                                var L = !1;
                                if (x.oneof) {
                                    for (var j = Object.keys(N), D = 0; D < j.length; D++)
                                        if (l.indexOf(j[D]) > -1) {
                                            L = !0;
                                            break;
                                        }
                                }
                                L || (S ? x.repeated ? T = [] : (T = T && S[T] ? S[T].value : S[Object.keys(S)[0]].value, T = parseInt(T || 0, 10)) : (K = t(x), T = s(x, T)), c(N, B, T, K));
                            }
                        }
                        return I.bytes = _ - M, N;
                    }
                    var G = d.decode(v, _);
                    _ += d.decode.bytes;
                    var W = a[G >> 3];
                    if (W != null) {
                        var X = o[W];
                        if ((x = u.fields[W]).packed) {
                            var Q = d.decode(v, _);
                            for (Q += _ += d.decode.bytes; _ < Q;)
                                _ = b(X, x, N, v, R, _);
                        }
                        else
                            _ = b(X, x, N, v, R, _);
                    }
                    else
                        _ = n(7 & G, v, R, _);
                } }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(141).defined, r = f(19);
                E.exports = function (e, c, n, t, s) { const u = Object.keys(t), i = n.length, o = {}; for (let a = 0; a < i; a++) {
                    o[a] = { p: r.encode(e.fields[a].tag << 3 | 2), h: r.encode(e.fields[a].tag << 3 | n[a].type) };
                    const l = e.fields[a];
                    e.fields[a].packed = l.repeated && l.options && l.options.packed && l.options.packed !== "false";
                } function h(a, l, p, g, b, I, v) { let R = 0; if (!I)
                    for (R = 0; R < g.length; R++)
                        a[p++] = g[R]; return b.message && (r.encode(b.encodingLength(v), a, p), p += r.encode.bytes), b.encode(v, a, l, p), p + b.encode.bytes; } return function a(l, p, g, b = 0) { p == null && (p = new Uint8Array(s(l))), g == null && (g = new DataView(p.buffer, p.byteOffset, p.byteLength)); const I = b, v = Object.keys(l); let R = 0, _ = !1; for (R = 0; R < u.length; R++) {
                    const k = u[R], x = t[R];
                    if (v.indexOf(x) > -1) {
                        if (_)
                            throw new Error("only one of the properties defined in oneof " + k + " can be set");
                        _ = !0;
                    }
                } for (R = 0; R < i; R++) {
                    const k = n[R], x = e.fields[R];
                    let M = l[x.name], N = 0;
                    if (!d(M)) {
                        if (x.required)
                            throw new Error(x.name + " is required");
                        continue;
                    }
                    const S = o[R].p, T = o[R].h, B = x.packed;
                    if (x.map) {
                        const P = Object.keys(M);
                        for (N = 0; N < P.length; N++)
                            P[N] = { key: P[N], value: M[P[N]] };
                        M = P;
                    }
                    if (B) {
                        let P = 0;
                        for (N = 0; N < M.length; N++)
                            Object.prototype.hasOwnProperty.call(M, N) && (P += k.encodingLength(M[N]));
                        if (P) {
                            for (N = 0; N < T.length; N++)
                                p[b++] = S[N];
                            r.encode(P, p, b), b += r.encode.bytes;
                        }
                    }
                    if (x.repeated) {
                        let P;
                        for (N = 0; N < M.length; N++)
                            P = M[N], d(P) && (b = h(p, g, b, T, k, B, P));
                    }
                    else
                        b = h(p, g, b, T, k, B, M);
                } return a.bytes = b - I, p; }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(141).defined, r = f(19);
                E.exports = function (e, c, n) { const t = Object.keys(n), s = c.length, u = new Array(s); for (let i = 0; i < e.fields.length; i++) {
                    u[i] = r.encodingLength(e.fields[i].tag << 3 | c[i].type);
                    const o = e.fields[i];
                    e.fields[i].packed = o.repeated && o.options && o.options.packed && o.options.packed !== "false";
                } return function (i) { let o = 0, h = 0, a = 0; for (h = 0; h < t.length; h++) {
                    const l = t[h], p = n[l];
                    let g = !1;
                    for (a = 0; a < p.length; a++)
                        if (d(i[p[a]])) {
                            if (g)
                                throw new Error("only one of the properties defined in oneof " + l + " can be set");
                            g = !0;
                        }
                } for (h = 0; h < s; h++) {
                    const l = c[h], p = e.fields[h];
                    let g = i[p.name];
                    const b = u[h];
                    let I;
                    if (d(g)) {
                        if (p.map) {
                            const v = Object.keys(g);
                            for (a = 0; a < v.length; a++)
                                v[a] = { key: v[a], value: g[v[a]] };
                            g = v;
                        }
                        if (p.packed) {
                            let v = 0;
                            for (a = 0; a < g.length; a++)
                                d(g[a]) && (I = l.encodingLength(g[a]), v += I, l.message && (v += r.encodingLength(I)));
                            v && (o += b + v + r.encodingLength(v));
                        }
                        else if (p.repeated)
                            for (a = 0; a < g.length; a++)
                                d(g[a]) && (I = l.encodingLength(g[a]), o += b + I + (l.message ? r.encodingLength(I) : 0));
                        else
                            I = l.encodingLength(g), o += b + I + (l.message ? r.encodingLength(I) : 0);
                    }
                    else if (p.required)
                        throw new Error(p.name + " is required");
                } return o; }; };
            }, function (E, m, f) {
                "use strict";
                m.byteLength = function (i) { var o = s(i), h = o[0], a = o[1]; return 3 * (h + a) / 4 - a; }, m.toByteArray = function (i) { var o, h, a = s(i), l = a[0], p = a[1], g = new e(function (v, R, _) { return 3 * (R + _) / 4 - _; }(0, l, p)), b = 0, I = p > 0 ? l - 4 : l; for (h = 0; h < I; h += 4)
                    o = r[i.charCodeAt(h)] << 18 | r[i.charCodeAt(h + 1)] << 12 | r[i.charCodeAt(h + 2)] << 6 | r[i.charCodeAt(h + 3)], g[b++] = o >> 16 & 255, g[b++] = o >> 8 & 255, g[b++] = 255 & o; return p === 2 && (o = r[i.charCodeAt(h)] << 2 | r[i.charCodeAt(h + 1)] >> 4, g[b++] = 255 & o), p === 1 && (o = r[i.charCodeAt(h)] << 10 | r[i.charCodeAt(h + 1)] << 4 | r[i.charCodeAt(h + 2)] >> 2, g[b++] = o >> 8 & 255, g[b++] = 255 & o), g; }, m.fromByteArray = function (i) { for (var o, h = i.length, a = h % 3, l = [], p = 0, g = h - a; p < g; p += 16383)
                    l.push(u(i, p, p + 16383 > g ? g : p + 16383)); return a === 1 ? (o = i[h - 1], l.push(d[o >> 2] + d[o << 4 & 63] + "==")) : a === 2 && (o = (i[h - 2] << 8) + i[h - 1], l.push(d[o >> 10] + d[o >> 4 & 63] + d[o << 2 & 63] + "=")), l.join(""); };
                for (var d = [], r = [], e = typeof Uint8Array != "undefined" ? Uint8Array : Array, c = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, t = c.length; n < t; ++n)
                    d[n] = c[n], r[c.charCodeAt(n)] = n;
                function s(i) { var o = i.length; if (o % 4 > 0)
                    throw new Error("Invalid string. Length must be a multiple of 4"); var h = i.indexOf("="); return h === -1 && (h = o), [h, h === o ? 0 : 4 - h % 4]; }
                function u(i, o, h) { for (var a, l, p = [], g = o; g < h; g += 3)
                    a = (i[g] << 16 & 16711680) + (i[g + 1] << 8 & 65280) + (255 & i[g + 2]), p.push(d[(l = a) >> 18 & 63] + d[l >> 12 & 63] + d[l >> 6 & 63] + d[63 & l]); return p.join(""); }
                r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63;
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    var r = {};
                    E.exports = r;
                    var e = {};
                    r.encode = function (c, n, t) {
                        if (typeof n != "string")
                            throw new TypeError('"alphabet" must be a string.');
                        if (t !== void 0 && typeof t != "number")
                            throw new TypeError('"maxline" must be a number.');
                        var s = "";
                        if (c instanceof Uint8Array) {
                            var u = 0, i = n.length, o = n.charAt(0), h = [0];
                            for (u = 0; u < c.length; ++u) {
                                for (var a = 0, l = c[u]; a < h.length; ++a)
                                    l += h[a] << 8, h[a] = l % i, l = l / i | 0;
                                for (; l > 0;)
                                    h.push(l % i), l = l / i | 0;
                            }
                            for (u = 0; c[u] === 0 && u < c.length - 1; ++u)
                                s += o;
                            for (u = h.length - 1; u >= 0; --u)
                                s += n[h[u]];
                        }
                        else
                            s = function (g, b) { var I = 0, v = b.length, R = b.charAt(0), _ = [0]; for (I = 0; I < g.length(); ++I) {
                                for (var k = 0, x = g.at(I); k < _.length; ++k)
                                    x += _[k] << 8, _[k] = x % v, x = x / v | 0;
                                for (; x > 0;)
                                    _.push(x % v), x = x / v | 0;
                            } var M = ""; for (I = 0; g.at(I) === 0 && I < g.length() - 1; ++I)
                                M += R; for (I = _.length - 1; I >= 0; --I)
                                M += b[_[I]]; return M; }(c, n);
                        if (t) {
                            var p = new RegExp(".{1," + t + "}", "g");
                            s = s.match(p).join(`\r
`);
                        }
                        return s;
                    }, r.decode = function (c, n) { if (typeof c != "string")
                        throw new TypeError('"input" must be a string.'); if (typeof n != "string")
                        throw new TypeError('"alphabet" must be a string.'); var t = e[n]; if (!t) {
                        t = e[n] = [];
                        for (var s = 0; s < n.length; ++s)
                            t[n.charCodeAt(s)] = s;
                    } c = c.replace(/\s/g, ""); var u = n.length, i = n.charAt(0), o = [0]; for (s = 0; s < c.length; s++) {
                        var h = t[c.charCodeAt(s)];
                        if (h === void 0)
                            return;
                        for (var a = 0, l = h; a < o.length; ++a)
                            l += o[a] * u, o[a] = 255 & l, l >>= 8;
                        for (; l > 0;)
                            o.push(255 & l), l >>= 8;
                    } for (var p = 0; c[p] === i && p < c.length - 1; ++p)
                        o.push(0); return d !== void 0 ? d.from(o.reverse()) : new Uint8Array(o.reverse()); };
                }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(49), f(14), (E.exports = d.hmac = d.hmac || {}).create = function () { var r = null, e = null, c = null, n = null, t = { start: function (s, u) { if (s !== null)
                        if (typeof s == "string") {
                            if (!((s = s.toLowerCase()) in d.md.algorithms))
                                throw new Error('Unknown hash algorithm "' + s + '"');
                            e = d.md.algorithms[s].create();
                        }
                        else
                            e = s; if (u === null)
                        u = r;
                    else {
                        if (typeof u == "string")
                            u = d.util.createBuffer(u);
                        else if (d.util.isArray(u)) {
                            var i = u;
                            u = d.util.createBuffer();
                            for (var o = 0; o < i.length; ++o)
                                u.putByte(i[o]);
                        }
                        var h = u.length();
                        for (h > e.blockLength && (e.start(), e.update(u.bytes()), u = e.digest()), c = d.util.createBuffer(), n = d.util.createBuffer(), h = u.length(), o = 0; o < h; ++o)
                            i = u.at(o), c.putByte(54 ^ i), n.putByte(92 ^ i);
                        if (h < e.blockLength)
                            for (i = e.blockLength - h, o = 0; o < i; ++o)
                                c.putByte(54), n.putByte(92);
                        r = u, c = c.bytes(), n = n.bytes();
                    } e.start(), e.update(c); }, update: function (s) { e.update(s); }, getMac: function () { var s = e.digest().bytes(); return e.start(), e.update(n), e.update(s), e.digest(); } }; return t.digest = t.getMac, t; };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(49), f(14);
                var r = E.exports = d.sha256 = d.sha256 || {};
                d.md.sha256 = d.md.algorithms.sha256 = r, r.create = function () { c || (e = String.fromCharCode(128), e += d.util.fillString(String.fromCharCode(0), 64), n = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], c = !0); var s = null, u = d.util.createBuffer(), i = new Array(64), o = { algorithm: "sha256", blockLength: 64, digestLength: 32, messageLength: 0, fullMessageLength: null, messageLengthSize: 8, start: function () { o.messageLength = 0, o.fullMessageLength = o.messageLength64 = []; for (var h = o.messageLengthSize / 4, a = 0; a < h; ++a)
                        o.fullMessageLength.push(0); return u = d.util.createBuffer(), s = { h0: 1779033703, h1: 3144134277, h2: 1013904242, h3: 2773480762, h4: 1359893119, h5: 2600822924, h6: 528734635, h7: 1541459225 }, o; } }; return o.start(), o.update = function (h, a) { a === "utf8" && (h = d.util.encodeUtf8(h)); var l = h.length; o.messageLength += l, l = [l / 4294967296 >>> 0, l >>> 0]; for (var p = o.fullMessageLength.length - 1; p >= 0; --p)
                    o.fullMessageLength[p] += l[1], l[1] = l[0] + (o.fullMessageLength[p] / 4294967296 >>> 0), o.fullMessageLength[p] = o.fullMessageLength[p] >>> 0, l[0] = l[1] / 4294967296 >>> 0; return u.putBytes(h), t(s, i, u), (u.read > 2048 || u.length() === 0) && u.compact(), o; }, o.digest = function () { var h = d.util.createBuffer(); h.putBytes(u.bytes()); var a, l = o.fullMessageLength[o.fullMessageLength.length - 1] + o.messageLengthSize & o.blockLength - 1; h.putBytes(e.substr(0, o.blockLength - l)); for (var p = 8 * o.fullMessageLength[0], g = 0; g < o.fullMessageLength.length - 1; ++g)
                    p += (a = 8 * o.fullMessageLength[g + 1]) / 4294967296 >>> 0, h.putInt32(p >>> 0), p = a >>> 0; h.putInt32(p); var b = { h0: s.h0, h1: s.h1, h2: s.h2, h3: s.h3, h4: s.h4, h5: s.h5, h6: s.h6, h7: s.h7 }; t(b, i, h); var I = d.util.createBuffer(); return I.putInt32(b.h0), I.putInt32(b.h1), I.putInt32(b.h2), I.putInt32(b.h3), I.putInt32(b.h4), I.putInt32(b.h5), I.putInt32(b.h6), I.putInt32(b.h7), I; }, o; };
                var e = null, c = !1, n = null;
                function t(s, u, i) { for (var o, h, a, l, p, g, b, I, v, R, _, k, x, M = i.length(); M >= 64;) {
                    for (p = 0; p < 16; ++p)
                        u[p] = i.getInt32();
                    for (; p < 64; ++p)
                        o = ((o = u[p - 2]) >>> 17 | o << 15) ^ (o >>> 19 | o << 13) ^ o >>> 10, h = ((h = u[p - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, u[p] = o + u[p - 7] + h + u[p - 16] | 0;
                    for (g = s.h0, b = s.h1, I = s.h2, v = s.h3, R = s.h4, _ = s.h5, k = s.h6, x = s.h7, p = 0; p < 64; ++p)
                        a = (g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10), l = g & b | I & (g ^ b), o = x + ((R >>> 6 | R << 26) ^ (R >>> 11 | R << 21) ^ (R >>> 25 | R << 7)) + (k ^ R & (_ ^ k)) + n[p] + u[p], x = k, k = _, _ = R, R = v + o >>> 0, v = I, I = b, b = g, g = o + (h = a + l) >>> 0;
                    s.h0 = s.h0 + g | 0, s.h1 = s.h1 + b | 0, s.h2 = s.h2 + I | 0, s.h3 = s.h3 + v | 0, s.h4 = s.h4 + R | 0, s.h5 = s.h5 + _ | 0, s.h6 = s.h6 + k | 0, s.h7 = s.h7 + x | 0, M -= 64;
                } }
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(8); f(14); var e = null; !r.util.isNodejs || r.options.usePureJavaScript || d.versions["node-webkit"] || (e = f(144)), (E.exports = r.prng = r.prng || {}).create = function (c) { for (var n = { plugin: c, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: "" }, t = c.md, s = new Array(32), u = 0; u < 32; ++u)
                    s[u] = t.create(); function i() { if (n.pools[0].messageLength >= 32)
                    return o(); var a = 32 - n.pools[0].messageLength << 5; n.collect(n.seedFileSync(a)), o(); } function o() { n.reseeds = n.reseeds === 4294967295 ? 0 : n.reseeds + 1; var a = n.plugin.md.create(); a.update(n.keyBytes); for (var l = 1, p = 0; p < 32; ++p)
                    n.reseeds % l == 0 && (a.update(n.pools[p].digest().getBytes()), n.pools[p].start()), l <<= 1; n.keyBytes = a.digest().getBytes(), a.start(), a.update(n.keyBytes); var g = a.digest().getBytes(); n.key = n.plugin.formatKey(n.keyBytes), n.seed = n.plugin.formatSeed(g), n.generated = 0; } function h(a) { var l = null, p = r.util.globalScope, g = p.crypto || p.msCrypto; g && g.getRandomValues && (l = function (N) { return g.getRandomValues(N); }); var b = r.util.createBuffer(); if (l)
                    for (; b.length() < a;) {
                        var I = Math.max(1, Math.min(a - b.length(), 65536) / 4), v = new Uint32Array(Math.floor(I));
                        try {
                            l(v);
                            for (var R = 0; R < v.length; ++R)
                                b.putInt32(v[R]);
                        }
                        catch (N) {
                            if (!(typeof QuotaExceededError != "undefined" && N instanceof QuotaExceededError))
                                throw N;
                        }
                    } if (b.length() < a)
                    for (var _, k, x, M = Math.floor(65536 * Math.random()); b.length() < a;)
                        for (k = 16807 * (65535 & M), k += (32767 & (_ = 16807 * (M >> 16))) << 16, M = 4294967295 & (k = (2147483647 & (k += _ >> 15)) + (k >> 31)), R = 0; R < 3; ++R)
                            x = M >>> (R << 3), x ^= Math.floor(256 * Math.random()), b.putByte(String.fromCharCode(255 & x)); return b.getBytes(a); } return n.pools = s, n.pool = 0, n.generate = function (a, l) { if (!l)
                    return n.generateSync(a); var p = n.plugin.cipher, g = n.plugin.increment, b = n.plugin.formatKey, I = n.plugin.formatSeed, v = r.util.createBuffer(); n.key = null, function R(_) { if (_)
                    return l(_); if (v.length() >= a)
                    return l(null, v.getBytes(a)); if (n.generated > 1048575 && (n.key = null), n.key === null)
                    return r.util.nextTick(function () { !function (x) { if (n.pools[0].messageLength >= 32)
                        return o(), x(); var M = 32 - n.pools[0].messageLength << 5; n.seedFile(M, function (N, S) { if (N)
                        return x(N); n.collect(S), o(), x(); }); }(R); }); var k = p(n.key, n.seed); n.generated += k.length, v.putBytes(k), n.key = b(p(n.key, g(n.seed))), n.seed = I(p(n.key, n.seed)), r.util.setImmediate(R); }(); }, n.generateSync = function (a) { var l = n.plugin.cipher, p = n.plugin.increment, g = n.plugin.formatKey, b = n.plugin.formatSeed; n.key = null; for (var I = r.util.createBuffer(); I.length() < a;) {
                    n.generated > 1048575 && (n.key = null), n.key === null && i();
                    var v = l(n.key, n.seed);
                    n.generated += v.length, I.putBytes(v), n.key = g(l(n.key, p(n.seed))), n.seed = b(l(n.key, n.seed));
                } return I.getBytes(a); }, e ? (n.seedFile = function (a, l) { e.randomBytes(a, function (p, g) { if (p)
                    return l(p); l(null, g.toString()); }); }, n.seedFileSync = function (a) { return e.randomBytes(a).toString(); }) : (n.seedFile = function (a, l) { try {
                    l(null, h(a));
                }
                catch (p) {
                    l(p);
                } }, n.seedFileSync = h), n.collect = function (a) { for (var l = a.length, p = 0; p < l; ++p)
                    n.pools[n.pool].update(a.substr(p, 1)), n.pool = n.pool === 31 ? 0 : n.pool + 1; }, n.collectInt = function (a, l) { for (var p = "", g = 0; g < l; g += 8)
                    p += String.fromCharCode(a >> g & 255); n.collect(p); }, n.registerWorker = function (a) { a === self ? n.seedFile = function (l, p) { self.addEventListener("message", function g(b) { var I = b.data; I.forge && I.forge.prng && (self.removeEventListener("message", g), p(I.forge.prng.err, I.forge.prng.bytes)); }), self.postMessage({ forge: { prng: { needed: l } } }); } : a.addEventListener("message", function (l) { var p = l.data; p.forge && p.forge.prng && n.seedFile(p.forge.prng.needed, function (g, b) { a.postMessage({ forge: { prng: { err: g, bytes: b } } }); }); }); }, n; }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14);
                var r = [217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83, 142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125, 50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178, 28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182, 38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62, 231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106, 42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203, 204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151, 49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168, 44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46, 197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173], e = [1, 2, 3, 5], c = function (s, u) { return s << u & 65535 | (65535 & s) >> 16 - u; }, n = function (s, u) { return (65535 & s) >> u | s << 16 - u & 65535; };
                E.exports = d.rc2 = d.rc2 || {}, d.rc2.expandKey = function (s, u) { typeof s == "string" && (s = d.util.createBuffer(s)), u = u || 128; var i, o = s, h = s.length(), a = u, l = Math.ceil(a / 8), p = 255 >> (7 & a); for (i = h; i < 128; i++)
                    o.putByte(r[o.at(i - 1) + o.at(i - h) & 255]); for (o.setAt(128 - l, r[o.at(128 - l) & p]), i = 127 - l; i >= 0; i--)
                    o.setAt(i, r[o.at(i + 1) ^ o.at(i + l)]); return o; };
                var t = function (s, u, i) { var o, h, a, l, p = !1, g = null, b = null, I = null, v = []; for (s = d.rc2.expandKey(s, u), a = 0; a < 64; a++)
                    v.push(s.getInt16Le()); i ? (o = function (k) { for (a = 0; a < 4; a++)
                    k[a] += v[l] + (k[(a + 3) % 4] & k[(a + 2) % 4]) + (~k[(a + 3) % 4] & k[(a + 1) % 4]), k[a] = c(k[a], e[a]), l++; }, h = function (k) { for (a = 0; a < 4; a++)
                    k[a] += v[63 & k[(a + 3) % 4]]; }) : (o = function (k) { for (a = 3; a >= 0; a--)
                    k[a] = n(k[a], e[a]), k[a] -= v[l] + (k[(a + 3) % 4] & k[(a + 2) % 4]) + (~k[(a + 3) % 4] & k[(a + 1) % 4]), l--; }, h = function (k) { for (a = 3; a >= 0; a--)
                    k[a] -= v[63 & k[(a + 3) % 4]]; }); var R = function (k) { var x = []; for (a = 0; a < 4; a++) {
                    var M = g.getInt16Le();
                    I !== null && (i ? M ^= I.getInt16Le() : I.putInt16Le(M)), x.push(65535 & M);
                } l = i ? 0 : 63; for (var N = 0; N < k.length; N++)
                    for (var S = 0; S < k[N][0]; S++)
                        k[N][1](x); for (a = 0; a < 4; a++)
                    I !== null && (i ? I.putInt16Le(x[a]) : x[a] ^= I.getInt16Le()), b.putInt16Le(x[a]); }, _ = null; return _ = { start: function (k, x) { k && typeof k == "string" && (k = d.util.createBuffer(k)), p = !1, g = d.util.createBuffer(), b = x || new d.util.createBuffer, I = k, _.output = b; }, update: function (k) { for (p || g.putBuffer(k); g.length() >= 8;)
                        R([[5, o], [1, h], [6, o], [1, h], [5, o]]); }, finish: function (k) { var x = !0; if (i)
                        if (k)
                            x = k(8, g, !i);
                        else {
                            var M = g.length() === 8 ? 8 : 8 - g.length();
                            g.fillWithByte(M, M);
                        } if (x && (p = !0, _.update()), !i && (x = g.length() === 0))
                        if (k)
                            x = k(8, b, !i);
                        else {
                            var N = b.length(), S = b.at(N - 1);
                            S > N ? x = !1 : b.truncate(S);
                        } return x; } }; };
                d.rc2.startEncrypting = function (s, u, i) { var o = d.rc2.createEncryptionCipher(s, 128); return o.start(u, i), o; }, d.rc2.createEncryptionCipher = function (s, u) { return t(s, u, !0); }, d.rc2.startDecrypting = function (s, u, i) { var o = d.rc2.createDecryptionCipher(s, 128); return o.start(u, i), o; }, d.rc2.createDecryptionCipher = function (s, u) { return t(s, u, !1); };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), f(50), f(454);
                var r = E.exports = d.pkcs1 = d.pkcs1 || {};
                function e(c, n, t) { t || (t = d.md.sha1.create()); for (var s = "", u = Math.ceil(n / t.digestLength), i = 0; i < u; ++i) {
                    var o = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i);
                    t.start(), t.update(c + o), s += t.digest().getBytes();
                } return s.substring(0, n); }
                r.encode_rsa_oaep = function (c, n, t) { var s, u, i, o; typeof t == "string" ? (s = t, u = arguments[3] || void 0, i = arguments[4] || void 0) : t && (s = t.label || void 0, u = t.seed || void 0, i = t.md || void 0, t.mgf1 && t.mgf1.md && (o = t.mgf1.md)), i ? i.start() : i = d.md.sha1.create(), o || (o = i); var h = Math.ceil(c.n.bitLength() / 8), a = h - 2 * i.digestLength - 2; if (n.length > a)
                    throw (v = new Error("RSAES-OAEP input message length is too long.")).length = n.length, v.maxLength = a, v; s || (s = ""), i.update(s, "raw"); for (var l = i.digest(), p = "", g = a - n.length, b = 0; b < g; b++)
                    p += "\0"; var I = l.getBytes() + p + "" + n; if (u) {
                    if (u.length !== i.digestLength) {
                        var v;
                        throw (v = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.")).seedLength = u.length, v.digestLength = i.digestLength, v;
                    }
                }
                else
                    u = d.random.getBytes(i.digestLength); var R = e(u, h - i.digestLength - 1, o), _ = d.util.xorBytes(I, R, I.length), k = e(_, i.digestLength, o), x = d.util.xorBytes(u, k, u.length); return "\0" + x + _; }, r.decode_rsa_oaep = function (c, n, t) { var s, u, i; typeof t == "string" ? (s = t, u = arguments[3] || void 0) : t && (s = t.label || void 0, u = t.md || void 0, t.mgf1 && t.mgf1.md && (i = t.mgf1.md)); var o = Math.ceil(c.n.bitLength() / 8); if (n.length !== o)
                    throw (_ = new Error("RSAES-OAEP encoded message length is invalid.")).length = n.length, _.expectedLength = o, _; if (u === void 0 ? u = d.md.sha1.create() : u.start(), i || (i = u), o < 2 * u.digestLength + 2)
                    throw new Error("RSAES-OAEP key is too short for the hash function."); s || (s = ""), u.update(s, "raw"); for (var h = u.digest().getBytes(), a = n.charAt(0), l = n.substring(1, u.digestLength + 1), p = n.substring(1 + u.digestLength), g = e(p, u.digestLength, i), b = d.util.xorBytes(l, g, l.length), I = e(b, o - u.digestLength - 1, i), v = d.util.xorBytes(p, I, p.length), R = v.substring(0, u.digestLength), _ = a !== "\0", k = 0; k < u.digestLength; ++k)
                    _ |= h.charAt(k) !== R.charAt(k); for (var x = 1, M = u.digestLength, N = u.digestLength; N < v.length; N++) {
                    var S = v.charCodeAt(N), T = 1 & S ^ 1, B = x ? 65534 : 0;
                    _ |= S & B, M += x &= T;
                } if (_ || v.charCodeAt(M) !== 1)
                    throw new Error("Invalid RSAES-OAEP padding."); return v.substring(M + 1); };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(49), f(14);
                var r = E.exports = d.sha1 = d.sha1 || {};
                d.md.sha1 = d.md.algorithms.sha1 = r, r.create = function () { c || (e = String.fromCharCode(128), e += d.util.fillString(String.fromCharCode(0), 64), c = !0); var t = null, s = d.util.createBuffer(), u = new Array(80), i = { algorithm: "sha1", blockLength: 64, digestLength: 20, messageLength: 0, fullMessageLength: null, messageLengthSize: 8, start: function () { i.messageLength = 0, i.fullMessageLength = i.messageLength64 = []; for (var o = i.messageLengthSize / 4, h = 0; h < o; ++h)
                        i.fullMessageLength.push(0); return s = d.util.createBuffer(), t = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }, i; } }; return i.start(), i.update = function (o, h) { h === "utf8" && (o = d.util.encodeUtf8(o)); var a = o.length; i.messageLength += a, a = [a / 4294967296 >>> 0, a >>> 0]; for (var l = i.fullMessageLength.length - 1; l >= 0; --l)
                    i.fullMessageLength[l] += a[1], a[1] = a[0] + (i.fullMessageLength[l] / 4294967296 >>> 0), i.fullMessageLength[l] = i.fullMessageLength[l] >>> 0, a[0] = a[1] / 4294967296 >>> 0; return s.putBytes(o), n(t, u, s), (s.read > 2048 || s.length() === 0) && s.compact(), i; }, i.digest = function () { var o = d.util.createBuffer(); o.putBytes(s.bytes()); var h, a = i.fullMessageLength[i.fullMessageLength.length - 1] + i.messageLengthSize & i.blockLength - 1; o.putBytes(e.substr(0, i.blockLength - a)); for (var l = 8 * i.fullMessageLength[0], p = 0; p < i.fullMessageLength.length - 1; ++p)
                    l += (h = 8 * i.fullMessageLength[p + 1]) / 4294967296 >>> 0, o.putInt32(l >>> 0), l = h >>> 0; o.putInt32(l); var g = { h0: t.h0, h1: t.h1, h2: t.h2, h3: t.h3, h4: t.h4 }; n(g, u, o); var b = d.util.createBuffer(); return b.putInt32(g.h0), b.putInt32(g.h1), b.putInt32(g.h2), b.putInt32(g.h3), b.putInt32(g.h4), b; }, i; };
                var e = null, c = !1;
                function n(t, s, u) { for (var i, o, h, a, l, p, g, b = u.length(); b >= 64;) {
                    for (o = t.h0, h = t.h1, a = t.h2, l = t.h3, p = t.h4, g = 0; g < 16; ++g)
                        i = u.getInt32(), s[g] = i, i = (o << 5 | o >>> 27) + (l ^ h & (a ^ l)) + p + 1518500249 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    for (; g < 20; ++g)
                        i = (i = s[g - 3] ^ s[g - 8] ^ s[g - 14] ^ s[g - 16]) << 1 | i >>> 31, s[g] = i, i = (o << 5 | o >>> 27) + (l ^ h & (a ^ l)) + p + 1518500249 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    for (; g < 32; ++g)
                        i = (i = s[g - 3] ^ s[g - 8] ^ s[g - 14] ^ s[g - 16]) << 1 | i >>> 31, s[g] = i, i = (o << 5 | o >>> 27) + (h ^ a ^ l) + p + 1859775393 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    for (; g < 40; ++g)
                        i = (i = s[g - 6] ^ s[g - 16] ^ s[g - 28] ^ s[g - 32]) << 2 | i >>> 30, s[g] = i, i = (o << 5 | o >>> 27) + (h ^ a ^ l) + p + 1859775393 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    for (; g < 60; ++g)
                        i = (i = s[g - 6] ^ s[g - 16] ^ s[g - 28] ^ s[g - 32]) << 2 | i >>> 30, s[g] = i, i = (o << 5 | o >>> 27) + (h & a | l & (h ^ a)) + p + 2400959708 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    for (; g < 80; ++g)
                        i = (i = s[g - 6] ^ s[g - 16] ^ s[g - 28] ^ s[g - 32]) << 2 | i >>> 30, s[g] = i, i = (o << 5 | o >>> 27) + (h ^ a ^ l) + p + 3395469782 + i, p = l, l = a, a = (h << 30 | h >>> 2) >>> 0, h = o, o = i;
                    t.h0 = t.h0 + o | 0, t.h1 = t.h1 + h | 0, t.h2 = t.h2 + a | 0, t.h3 = t.h3 + l | 0, t.h4 = t.h4 + p | 0, b -= 64;
                } }
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), f(104), f(50), function () { if (d.prime)
                    E.exports = d.prime;
                else {
                    var r = E.exports = d.prime = d.prime || {}, e = d.jsbn.BigInteger, c = [6, 4, 2, 4, 2, 4, 6, 2], n = new e(null);
                    n.fromInt(30);
                    var t = function (i, o) { return i | o; };
                    r.generateProbablePrime = function (i, o, h) { typeof o == "function" && (h = o, o = {}); var a = (o = o || {}).algorithm || "PRIMEINC"; typeof a == "string" && (a = { name: a }), a.options = a.options || {}; var l = o.prng || d.random, p = { nextBytes: function (g) { for (var b = l.getBytesSync(g.length), I = 0; I < g.length; ++I)
                            g[I] = b.charCodeAt(I); } }; if (a.name === "PRIMEINC")
                        return function (g, b, I, v) { return "workers" in I ? function (R, _, k, x) { if (typeof Worker == "undefined")
                            return s(R, _, k, x); var M = u(R, _), N = k.workers, S = k.workLoad || 100, T = 30 * S / 8, B = k.workerScript || "forge/prime.worker.js"; if (N === -1)
                            return d.util.estimateCores(function (L, j) { L && (j = 2), N = j - 1, P(); }); function P() { N = Math.max(1, N); for (var L = [], j = 0; j < N; ++j)
                            L[j] = new Worker(B); for (j = 0; j < N; ++j)
                            L[j].addEventListener("message", G); var D = !1; function G(W) { if (!D) {
                            var X = W.data;
                            if (X.found) {
                                for (var Q = 0; Q < L.length; ++Q)
                                    L[Q].terminate();
                                return D = !0, x(null, new e(X.prime, 16));
                            }
                            M.bitLength() > R && (M = u(R, _));
                            var K = M.toString(16);
                            W.target.postMessage({ hex: K, workLoad: S }), M.dAddOffset(T, 0);
                        } } } P(); }(g, b, I, v) : s(g, b, I, v); }(i, p, a.options, h); throw new Error("Invalid prime generation algorithm: " + a.name); };
                } function s(i, o, h, a) { var l = u(i, o), p = function (b) { return b <= 100 ? 27 : b <= 150 ? 18 : b <= 200 ? 15 : b <= 250 ? 12 : b <= 300 ? 9 : b <= 350 ? 8 : b <= 400 ? 7 : b <= 500 ? 6 : b <= 600 ? 5 : b <= 800 ? 4 : b <= 1250 ? 3 : 2; }(l.bitLength()); "millerRabinTests" in h && (p = h.millerRabinTests); var g = 10; "maxBlockTime" in h && (g = h.maxBlockTime), function b(I, v, R, _, k, x, M) { var N = +new Date; do {
                    if (I.bitLength() > v && (I = u(v, R)), I.isProbablePrime(k))
                        return M(null, I);
                    I.dAddOffset(c[_++ % 8], 0);
                } while (x < 0 || +new Date - N < x); d.util.setImmediate(function () { b(I, v, R, _, k, x, M); }); }(l, i, o, 0, p, g, a); } function u(i, o) { var h = new e(i, o), a = i - 1; return h.testBit(a) || h.bitwiseTo(e.ONE.shiftLeft(a), t, h), h.dAddOffset(31 - h.mod(n).byteValue(), 0), h; } }();
            }, function (E, m, f) {
                "use strict";
                const d = f(25), r = f(231);
                E.exports = { import: async function (e, c) { const n = d.names.base64.decode(e), t = r.create(); return await t.decrypt(n, c); } };
            }, function (E, m, f) {
                "use strict";
                const d = f(84), r = f(21), e = f(0), c = f(20), n = f(5);
                f(146), f(232);
                const t = f(8), s = f(459), u = r(f(142)), i = f(148);
                class o {
                    constructor(l) { this._key = l; }
                    async verify(l, p) { return s.hashAndVerify(this._key, p, l); }
                    marshal() { return s.utils.jwkToPkix(this._key); }
                    get bytes() { return u.PublicKey.encode({ Type: u.KeyType.RSA, Data: this.marshal() }); }
                    encrypt(l) { return s.encrypt(this._key, l); }
                    equals(l) { return c(this.bytes, l.bytes); }
                    async hash() { return d.multihashing(this.bytes, "sha2-256"); }
                }
                class h {
                    constructor(l, p) { this._key = l, this._publicKey = p; }
                    genSecret() { return s.getRandomValues(16); }
                    async sign(l) { return s.hashAndSign(this._key, l); }
                    get public() { if (!this._publicKey)
                        throw e(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED"); return new o(this._publicKey); }
                    decrypt(l) { return s.decrypt(this._key, l); }
                    marshal() { return s.utils.jwkToPkcs1(this._key); }
                    get bytes() { return u.PrivateKey.encode({ Type: u.KeyType.RSA, Data: this.marshal() }); }
                    equals(l) { return c(this.bytes, l.bytes); }
                    async hash() { return d.multihashing(this.bytes, "sha2-256"); }
                    async id() { const l = await this.public.hash(); return n(l, "base58btc"); }
                    async export(l, p = "pkcs-8") { if (p === "pkcs-8") {
                        const g = new t.util.ByteBuffer(this.marshal()), b = t.asn1.fromDer(g), I = t.pki.privateKeyFromAsn1(b), v = { algorithm: "aes256", count: 1e4, saltSize: 16, prfAlgorithm: "sha512" };
                        return t.pki.encryptRsaPrivateKey(I, l, v);
                    } if (p === "libp2p-key")
                        return i.export(this.bytes, l); throw e(new Error(`export format '${p}' is not supported`), "ERR_INVALID_EXPORT_FORMAT"); }
                }
                E.exports = { RsaPublicKey: o, RsaPrivateKey: h, unmarshalRsaPublicKey: function (a) { const l = s.utils.pkixToJwk(a); return new o(l); }, unmarshalRsaPrivateKey: async function (a) { const l = s.utils.pkcs1ToJwk(a), p = await s.unmarshalPrivateKey(l); return new h(p.privateKey, p.publicKey); }, generateKeyPair: async function (a) { const l = await s.generateKey(a); return new h(l.privateKey, l.publicKey); }, fromJwk: async function (a) { const l = await s.unmarshalPrivateKey(a); return new h(l.privateKey, l.publicKey); } };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(44);
                var r = d.asn1;
                m.privateKeyValidator = { name: "PrivateKeyInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "PrivateKeyInfo.version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "privateKeyVersion" }, { name: "PrivateKeyInfo.privateKeyAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "privateKeyOid" }] }, { name: "PrivateKeyInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.OCTETSTRING, constructed: !1, capture: "privateKey" }] }, m.publicKeyValidator = { name: "SubjectPublicKeyInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "subjectPublicKeyInfo", value: [{ name: "SubjectPublicKeyInfo.AlgorithmIdentifier", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "AlgorithmIdentifier.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "publicKeyOid" }] }, { tagClass: r.Class.UNIVERSAL, type: r.Type.BITSTRING, constructed: !1, composed: !0, captureBitStringValue: "ed25519PublicKey" }] };
            }, function (E, m, f) {
                "use strict";
                const d = f(105), r = f(106), e = f(5), c = f(6);
                function n(i) { return Promise.all([d.get().subtle.exportKey("jwk", i.privateKey), d.get().subtle.exportKey("jwk", i.publicKey)]); }
                m.utils = f(461), m.generateKey = async function (i) { const o = await d.get().subtle.generateKey({ name: "RSASSA-PKCS1-v1_5", modulusLength: i, publicExponent: new Uint8Array([1, 0, 1]), hash: { name: "SHA-256" } }, !0, ["sign", "verify"]), h = await n(o); return { privateKey: h[0], publicKey: h[1] }; }, m.unmarshalPrivateKey = async function (i) { const o = [await d.get().subtle.importKey("jwk", i, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, !0, ["sign"]), await (h = i, d.get().subtle.importKey("jwk", { kty: h.kty, n: h.n, e: h.e }, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, !0, ["verify"]))]; var h; const a = await n({ privateKey: o[0], publicKey: o[1] }); return { privateKey: a[0], publicKey: a[1] }; }, m.getRandomValues = r, m.hashAndSign = async function (i, o) { const h = await d.get().subtle.importKey("jwk", i, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, !1, ["sign"]), a = await d.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, h, Uint8Array.from(o)); return new Uint8Array(a, a.byteOffset, a.byteLength); }, m.hashAndVerify = async function (i, o, h) { const a = await d.get().subtle.importKey("jwk", i, { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } }, !1, ["verify"]); return d.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, a, o, h); };
                const { jwk2pub: t, jwk2priv: s } = f(462);
                function u(i, o, h, a) { const l = o ? t(i) : s(i), p = a(e(Uint8Array.from(h), "ascii"), l); return c(p, "ascii"); }
                m.encrypt = function (i, o) { return u(i, !0, o, (h, a) => a.encrypt(h)); }, m.decrypt = function (i, o) { return u(i, !1, o, (h, a) => a.decrypt(h)); };
            }, function (E, m, f) {
                "use strict";
                const d = self.crypto || self.msCrypto, { Buffer: r } = f(3);
                d && d.getRandomValues ? E.exports = function (e) { const c = new Uint8Array(e); let n = 0; if (e > 0)
                    if (e > 65536)
                        for (; n < e;)
                            n + 65536 > e ? (d.getRandomValues(c.subarray(n, n + (e - n))), n += e - n) : (d.getRandomValues(c.subarray(n, n + 65536)), n += 65536);
                    else
                        d.getRandomValues(c); return r.from(c); } : E.exports = function () {
                    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
                };
            }, function (E, m, f) {
                "use strict";
                f(44), f(103);
                const d = f(8), { bigIntegerToUintBase64url: r, base64urlToBigInteger: e } = f(147), c = f(6), n = f(5);
                m.pkcs1ToJwk = function (t) { const s = d.asn1.fromDer(n(t, "ascii")), u = d.pki.privateKeyFromAsn1(s); return { kty: "RSA", n: r(u.n), e: r(u.e), d: r(u.d), p: r(u.p), q: r(u.q), dp: r(u.dP), dq: r(u.dQ), qi: r(u.qInv), alg: "RS256", kid: "2011-04-29" }; }, m.jwkToPkcs1 = function (t) { const s = d.pki.privateKeyToAsn1({ n: e(t.n), e: e(t.e), d: e(t.d), p: e(t.p), q: e(t.q), dP: e(t.dp), dQ: e(t.dq), qInv: e(t.qi) }); return c(d.asn1.toDer(s).getBytes(), "ascii"); }, m.pkixToJwk = function (t) { const s = d.asn1.fromDer(n(t, "ascii")), u = d.pki.publicKeyFromAsn1(s); return { kty: "RSA", n: r(u.n), e: r(u.e), alg: "RS256", kid: "2011-04-29" }; }, m.jwkToPkix = function (t) { const s = d.pki.publicKeyToAsn1({ n: e(t.n), e: e(t.e) }); return c(d.asn1.toDer(s).getBytes(), "ascii"); };
            }, function (E, m, f) {
                "use strict";
                f(103);
                const d = f(8), { base64urlToBigInteger: r } = f(147);
                function e(c, n) { return n.map(t => r(c[t])); }
                E.exports = { jwk2pub: function (c) { return d.pki.setRsaPublicKey(...e(c, ["n", "e"])); }, jwk2priv: function (c) { return d.pki.setRsaPrivateKey(...e(c, ["n", "e", "d", "p", "q", "dp", "dq", "qi"])); } };
            }, function (E, m, f) {
                "use strict";
                const d = f(84), r = f(21), e = f(25), c = f(0), n = f(20), t = f(464), s = r(f(142)), u = f(148);
                class i {
                    constructor(l) { this._key = h(l, t.publicKeyLength); }
                    async verify(l, p) { return t.hashAndVerify(this._key, p, l); }
                    marshal() { return this._key; }
                    get bytes() { return s.PublicKey.encode({ Type: s.KeyType.Ed25519, Data: this.marshal() }); }
                    equals(l) { return n(this.bytes, l.bytes); }
                    async hash() { return d.multihashing(this.bytes, "sha2-256"); }
                }
                class o {
                    constructor(l, p) { this._key = h(l, t.privateKeyLength), this._publicKey = h(p, t.publicKeyLength); }
                    async sign(l) { return t.hashAndSign(this._key, l); }
                    get public() { return new i(this._publicKey); }
                    marshal() { return this._key; }
                    get bytes() { return s.PrivateKey.encode({ Type: s.KeyType.Ed25519, Data: this.marshal() }); }
                    equals(l) { return n(this.bytes, l.bytes); }
                    async hash() { return d.multihashing(this.bytes, "sha2-256"); }
                    async id() { const l = await this.public.hash(); return e.encode("base58btc", l).toString().slice(1); }
                    async export(l, p = "libp2p-key") { if (p === "libp2p-key")
                        return u.export(this.bytes, l); throw c(new Error(`export format '${p}' is not supported`), "ERR_INVALID_EXPORT_FORMAT"); }
                }
                function h(a, l) { if ((a = Uint8Array.from(a || [])).length !== l)
                    throw c(new Error(`Key must be a Uint8Array of length ${l}, got ${a.length}`), "ERR_INVALID_KEY_TYPE"); return a; }
                E.exports = { Ed25519PublicKey: i, Ed25519PrivateKey: o, unmarshalEd25519PrivateKey: function (a) { if (a.length > t.privateKeyLength) {
                        const g = (a = h(a, t.privateKeyLength + t.publicKeyLength)).slice(0, t.privateKeyLength), b = a.slice(t.privateKeyLength, a.length);
                        return new o(g, b);
                    } const l = (a = h(a, t.privateKeyLength)).slice(0, t.privateKeyLength), p = a.slice(t.publicKeyLength); return new o(l, p); }, unmarshalEd25519PublicKey: function (a) { return a = h(a, t.publicKeyLength), new i(a); }, generateKeyPair: async function () { const { privateKey: a, publicKey: l } = await t.generateKey(); return new o(a, l); }, generateKeyPairFromSeed: async function (a) { const { privateKey: l, publicKey: p } = await t.generateKeyFromSeed(a); return new o(l, p); } };
            }, function (E, m, f) {
                "use strict";
                f(232);
                const d = f(8);
                m.publicKeyLength = d.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH, m.privateKeyLength = d.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH, m.generateKey = async function () { return d.pki.ed25519.generateKeyPair(); }, m.generateKeyFromSeed = async function (r) { return d.pki.ed25519.generateKeyPair({ seed: r }); }, m.hashAndSign = async function (r, e) { return d.pki.ed25519.sign({ message: e, privateKey: r }); }, m.hashAndVerify = async function (r, e, c) { return d.pki.ed25519.verify({ signature: e, message: c, publicKey: r }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(84), r = f(0), e = f(20), c = f(5), n = f(148);
                E.exports = (t, s, u) => { u = u || f(466)(s); class i {
                    constructor(a) { u.validatePublicKey(a), this._key = a; }
                    verify(a, l) { return u.hashAndVerify(this._key, l, a); }
                    marshal() { return u.compressPublicKey(this._key); }
                    get bytes() { return t.PublicKey.encode({ Type: t.KeyType.Secp256k1, Data: this.marshal() }); }
                    equals(a) { return e(this.bytes, a.bytes); }
                    hash() { return d.multihashing(this.bytes, "sha2-256"); }
                } class o {
                    constructor(a, l) { this._key = a, this._publicKey = l || u.computePublicKey(a), u.validatePrivateKey(this._key), u.validatePublicKey(this._publicKey); }
                    sign(a) { return u.hashAndSign(this._key, a); }
                    get public() { return new i(this._publicKey); }
                    marshal() { return this._key; }
                    get bytes() { return t.PrivateKey.encode({ Type: t.KeyType.Secp256k1, Data: this.marshal() }); }
                    equals(a) { return e(this.bytes, a.bytes); }
                    hash() { return d.multihashing(this.bytes, "sha2-256"); }
                    async id() { const a = await this.public.hash(); return c(a, "base58btc"); }
                    async export(a, l = "libp2p-key") { if (l === "libp2p-key")
                        return n.export(this.bytes, a); throw r(new Error(`export format '${l}' is not supported`), "ERR_INVALID_EXPORT_FORMAT"); }
                } return { Secp256k1PublicKey: i, Secp256k1PrivateKey: o, unmarshalSecp256k1PrivateKey: function (h) { return new o(h); }, unmarshalSecp256k1PublicKey: function (h) { return new i(h); }, generateKeyPair: async function () { const h = await u.generateKey(); return new o(h); } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(467), r = f(84);
                E.exports = e => { function c(n) { if (!d.privateKeyVerify(n))
                    throw new Error("Invalid private key"); } return { generateKey: function () { let n; do
                        n = e(32);
                    while (!d.privateKeyVerify(n)); return n; }, privateKeyLength: 32, hashAndSign: async function (n, t) { const s = await r.digest(t, "sha2-256"), u = d.ecdsaSign(s, n); return d.signatureExport(u.signature); }, hashAndVerify: async function (n, t, s) { const u = await r.digest(s, "sha2-256"); return t = d.signatureImport(t), d.ecdsaVerify(t, u, n); }, compressPublicKey: function (n) { if (!d.publicKeyVerify(n))
                        throw new Error("Invalid public key"); return d.publicKeyConvert(n, !0); }, decompressPublicKey: function (n) { return d.publicKeyConvert(n, !1); }, validatePrivateKey: c, validatePublicKey: function (n) { if (!d.publicKeyVerify(n))
                        throw new Error("Invalid public key"); }, computePublicKey: function (n) { return c(n), d.publicKeyCreate(n); } }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(468)(f(469));
            }, function (E, m, f) {
                "use strict";
                const d = "Impossible case. Please create issue.", r = "The tweak was out of range or the resulted private key is invalid", e = "The tweak was out of range or equal to zero", c = "Unknow error on context randomization", n = "Private Key is invalid", t = "Public Key could not be parsed", s = "Public Key serialization error", u = "The sum of the public keys is not valid", i = "Signature could not be parsed", o = "The nonce generation function failed, or the private key was invalid", h = "Public key could not be recover", a = "Scalar was invalid (zero or overflow)";
                function l(v, R) { if (!v)
                    throw new Error(R); }
                function p(v, R, _) { if (l(R instanceof Uint8Array, `Expected ${v} to be an Uint8Array`), _ !== void 0)
                    if (Array.isArray(_)) {
                        const k = `Expected ${v} to be an Uint8Array with length [${_.join(", ")}]`;
                        l(_.includes(R.length), k);
                    }
                    else {
                        const k = `Expected ${v} to be an Uint8Array with length ${_}`;
                        l(R.length === _, k);
                    } }
                function g(v) { l(I(v) === "Boolean", "Expected compressed to be a Boolean"); }
                function b(v = _ => new Uint8Array(_), R) { return typeof v == "function" && (v = v(R)), p("output", v, R), v; }
                function I(v) { return Object.prototype.toString.call(v).slice(8, -1); }
                E.exports = v => ({ contextRandomize(R) { switch (l(R === null || R instanceof Uint8Array, "Expected seed to be an Uint8Array or null"), R !== null && p("seed", R, 32), v.contextRandomize(R)) {
                        case 1: throw new Error(c);
                    } }, privateKeyVerify: R => (p("private key", R, 32), v.privateKeyVerify(R) === 0), privateKeyNegate(R) { switch (p("private key", R, 32), v.privateKeyNegate(R)) {
                        case 0: return R;
                        case 1: throw new Error(d);
                    } }, privateKeyTweakAdd(R, _) { switch (p("private key", R, 32), p("tweak", _, 32), v.privateKeyTweakAdd(R, _)) {
                        case 0: return R;
                        case 1: throw new Error(r);
                    } }, privateKeyTweakMul(R, _) { switch (p("private key", R, 32), p("tweak", _, 32), v.privateKeyTweakMul(R, _)) {
                        case 0: return R;
                        case 1: throw new Error(e);
                    } }, publicKeyVerify: R => (p("public key", R, [33, 65]), v.publicKeyVerify(R) === 0), publicKeyCreate(R, _ = !0, k) { switch (p("private key", R, 32), g(_), k = b(k, _ ? 33 : 65), v.publicKeyCreate(k, R)) {
                        case 0: return k;
                        case 1: throw new Error(n);
                        case 2: throw new Error(s);
                    } }, publicKeyConvert(R, _ = !0, k) { switch (p("public key", R, [33, 65]), g(_), k = b(k, _ ? 33 : 65), v.publicKeyConvert(k, R)) {
                        case 0: return k;
                        case 1: throw new Error(t);
                        case 2: throw new Error(s);
                    } }, publicKeyNegate(R, _ = !0, k) { switch (p("public key", R, [33, 65]), g(_), k = b(k, _ ? 33 : 65), v.publicKeyNegate(k, R)) {
                        case 0: return k;
                        case 1: throw new Error(t);
                        case 2: throw new Error(d);
                        case 3: throw new Error(s);
                    } }, publicKeyCombine(R, _ = !0, k) { l(Array.isArray(R), "Expected public keys to be an Array"), l(R.length > 0, "Expected public keys array will have more than zero items"); for (const x of R)
                        p("public key", x, [33, 65]); switch (g(_), k = b(k, _ ? 33 : 65), v.publicKeyCombine(k, R)) {
                        case 0: return k;
                        case 1: throw new Error(t);
                        case 2: throw new Error(u);
                        case 3: throw new Error(s);
                    } }, publicKeyTweakAdd(R, _, k = !0, x) { switch (p("public key", R, [33, 65]), p("tweak", _, 32), g(k), x = b(x, k ? 33 : 65), v.publicKeyTweakAdd(x, R, _)) {
                        case 0: return x;
                        case 1: throw new Error(t);
                        case 2: throw new Error(r);
                    } }, publicKeyTweakMul(R, _, k = !0, x) { switch (p("public key", R, [33, 65]), p("tweak", _, 32), g(k), x = b(x, k ? 33 : 65), v.publicKeyTweakMul(x, R, _)) {
                        case 0: return x;
                        case 1: throw new Error(t);
                        case 2: throw new Error(e);
                    } }, signatureNormalize(R) { switch (p("signature", R, 64), v.signatureNormalize(R)) {
                        case 0: return R;
                        case 1: throw new Error(i);
                    } }, signatureExport(R, _) { p("signature", R, 64); const k = { output: _ = b(_, 72), outputlen: 72 }; switch (v.signatureExport(k, R)) {
                        case 0: return _.slice(0, k.outputlen);
                        case 1: throw new Error(i);
                        case 2: throw new Error(d);
                    } }, signatureImport(R, _) { switch (p("signature", R), _ = b(_, 64), v.signatureImport(_, R)) {
                        case 0: return _;
                        case 1: throw new Error(i);
                        case 2: throw new Error(d);
                    } }, ecdsaSign(R, _, k = {}, x) { p("message", R, 32), p("private key", _, 32), l(I(k) === "Object", "Expected options to be an Object"), k.data !== void 0 && p("options.data", k.data), k.noncefn !== void 0 && l(I(k.noncefn) === "Function", "Expected options.noncefn to be a Function"); const M = { signature: x = b(x, 64), recid: null }; switch (v.ecdsaSign(M, R, _, k.data, k.noncefn)) {
                        case 0: return M;
                        case 1: throw new Error(o);
                        case 2: throw new Error(d);
                    } }, ecdsaVerify(R, _, k) { switch (p("signature", R, 64), p("message", _, 32), p("public key", k, [33, 65]), v.ecdsaVerify(R, _, k)) {
                        case 0: return !0;
                        case 3: return !1;
                        case 1: throw new Error(i);
                        case 2: throw new Error(t);
                    } }, ecdsaRecover(R, _, k, x = !0, M) { switch (p("signature", R, 64), l(I(_) === "Number" && _ >= 0 && _ <= 3, "Expected recovery id to be a Number within interval [0, 3]"), p("message", k, 32), g(x), M = b(M, x ? 33 : 65), v.ecdsaRecover(M, R, _, k)) {
                        case 0: return M;
                        case 1: throw new Error(i);
                        case 2: throw new Error(h);
                        case 3: throw new Error(d);
                    } }, ecdh(R, _, k = {}, x) { switch (p("public key", R, [33, 65]), p("private key", _, 32), l(I(k) === "Object", "Expected options to be an Object"), k.data !== void 0 && p("options.data", k.data), k.hashfn !== void 0 ? (l(I(k.hashfn) === "Function", "Expected options.hashfn to be a Function"), k.xbuf !== void 0 && p("options.xbuf", k.xbuf, 32), k.ybuf !== void 0 && p("options.ybuf", k.ybuf, 32), p("output", x)) : x = b(x, 32), v.ecdh(x, R, _, k.data, k.hashfn, k.xbuf, k.ybuf)) {
                        case 0: return x;
                        case 1: throw new Error(t);
                        case 2: throw new Error(a);
                    } } });
            }, function (E, m, f) {
                "use strict";
                const d = new (f(470)).ec("secp256k1"), r = d.curve, e = r.n.constructor;
                function c(t) { const s = t[0]; switch (s) {
                    case 2:
                    case 3: return t.length !== 33 ? null : function (u, i) { let o = new e(i); if (o.cmp(r.p) >= 0)
                        return null; o = o.toRed(r.red); let h = o.redSqr().redIMul(o).redIAdd(r.b).redSqrt(); return u === 3 !== h.isOdd() && (h = h.redNeg()), d.keyPair({ pub: { x: o, y: h } }); }(s, t.subarray(1, 33));
                    case 4:
                    case 6:
                    case 7: return t.length !== 65 ? null : function (u, i, o) { let h = new e(i), a = new e(o); if (h.cmp(r.p) >= 0 || a.cmp(r.p) >= 0)
                        return null; if (h = h.toRed(r.red), a = a.toRed(r.red), (u === 6 || u === 7) && a.isOdd() !== (u === 7))
                        return null; const l = h.redSqr().redIMul(h); return a.redSqr().redISub(l.redIAdd(r.b)).isZero() ? d.keyPair({ pub: { x: h, y: a } }) : null; }(s, t.subarray(1, 33), t.subarray(33, 65));
                    default: return null;
                } }
                function n(t, s) { const u = s.encode(null, t.length === 33); for (let i = 0; i < t.length; ++i)
                    t[i] = u[i]; }
                E.exports = { contextRandomize: () => 0, privateKeyVerify(t) { const s = new e(t); return s.cmp(r.n) < 0 && !s.isZero() ? 0 : 1; }, privateKeyNegate(t) { const s = new e(t), u = r.n.sub(s).umod(r.n).toArrayLike(Uint8Array, "be", 32); return t.set(u), 0; }, privateKeyTweakAdd(t, s) { const u = new e(s); if (u.cmp(r.n) >= 0)
                        return 1; if (u.iadd(new e(t)), u.cmp(r.n) >= 0 && u.isub(r.n), u.isZero())
                        return 1; const i = u.toArrayLike(Uint8Array, "be", 32); return t.set(i), 0; }, privateKeyTweakMul(t, s) { let u = new e(s); if (u.cmp(r.n) >= 0 || u.isZero())
                        return 1; u.imul(new e(t)), u.cmp(r.n) >= 0 && (u = u.umod(r.n)); const i = u.toArrayLike(Uint8Array, "be", 32); return t.set(i), 0; }, publicKeyVerify: t => c(t) === null ? 1 : 0, publicKeyCreate(t, s) { const u = new e(s); return u.cmp(r.n) >= 0 || u.isZero() ? 1 : (n(t, d.keyFromPrivate(s).getPublic()), 0); }, publicKeyConvert(t, s) { const u = c(s); return u === null ? 1 : (n(t, u.getPublic()), 0); }, publicKeyNegate(t, s) { const u = c(s); if (u === null)
                        return 1; const i = u.getPublic(); return i.y = i.y.redNeg(), n(t, i), 0; }, publicKeyCombine(t, s) { const u = new Array(s.length); for (let o = 0; o < s.length; ++o)
                        if (u[o] = c(s[o]), u[o] === null)
                            return 1; let i = u[0].getPublic(); for (let o = 1; o < u.length; ++o)
                        i = i.add(u[o].pub); return i.isInfinity() ? 2 : (n(t, i), 0); }, publicKeyTweakAdd(t, s, u) { const i = c(s); if (i === null)
                        return 1; if ((u = new e(u)).cmp(r.n) >= 0)
                        return 2; const o = i.getPublic().add(r.g.mul(u)); return o.isInfinity() ? 2 : (n(t, o), 0); }, publicKeyTweakMul(t, s, u) { const i = c(s); return i === null ? 1 : (u = new e(u)).cmp(r.n) >= 0 || u.isZero() ? 2 : (n(t, i.getPublic().mul(u)), 0); }, signatureNormalize(t) { const s = new e(t.subarray(0, 32)), u = new e(t.subarray(32, 64)); return s.cmp(r.n) >= 0 || u.cmp(r.n) >= 0 ? 1 : (u.cmp(d.nh) === 1 && t.set(r.n.sub(u).toArrayLike(Uint8Array, "be", 32), 32), 0); }, signatureExport(t, s) { const u = s.subarray(0, 32), i = s.subarray(32, 64); if (new e(u).cmp(r.n) >= 0)
                        return 1; if (new e(i).cmp(r.n) >= 0)
                        return 1; const { output: o } = t; let h = o.subarray(4, 37); h[0] = 0, h.set(u, 1); let a = 33, l = 0; for (; a > 1 && h[l] === 0 && !(128 & h[l + 1]); --a, ++l)
                        ; if (h = h.subarray(l), 128 & h[0])
                        return 1; if (a > 1 && h[0] === 0 && !(128 & h[1]))
                        return 1; let p = o.subarray(39, 72); p[0] = 0, p.set(i, 1); let g = 33, b = 0; for (; g > 1 && p[b] === 0 && !(128 & p[b + 1]); --g, ++b)
                        ; return p = p.subarray(b), 128 & p[0] || g > 1 && p[0] === 0 && !(128 & p[1]) ? 1 : (t.outputlen = 6 + a + g, o[0] = 48, o[1] = t.outputlen - 2, o[2] = 2, o[3] = h.length, o.set(h, 4), o[4 + a] = 2, o[5 + a] = p.length, o.set(p, 6 + a), 0); }, signatureImport(t, s) { if (s.length < 8)
                        return 1; if (s.length > 72)
                        return 1; if (s[0] !== 48)
                        return 1; if (s[1] !== s.length - 2)
                        return 1; if (s[2] !== 2)
                        return 1; const u = s[3]; if (u === 0)
                        return 1; if (5 + u >= s.length)
                        return 1; if (s[4 + u] !== 2)
                        return 1; const i = s[5 + u]; if (i === 0)
                        return 1; if (6 + u + i !== s.length)
                        return 1; if (128 & s[4])
                        return 1; if (u > 1 && s[4] === 0 && !(128 & s[5]))
                        return 1; if (128 & s[u + 6])
                        return 1; if (i > 1 && s[u + 6] === 0 && !(128 & s[u + 7]))
                        return 1; let o = s.subarray(4, 4 + u); if (o.length === 33 && o[0] === 0 && (o = o.subarray(1)), o.length > 32)
                        return 1; let h = s.subarray(6 + u); if (h.length === 33 && h[0] === 0 && (h = h.slice(1)), h.length > 32)
                        throw new Error("S length is too long"); let a = new e(o); a.cmp(r.n) >= 0 && (a = new e(0)); let l = new e(s.subarray(6 + u)); return l.cmp(r.n) >= 0 && (l = new e(0)), t.set(a.toArrayLike(Uint8Array, "be", 32), 0), t.set(l.toArrayLike(Uint8Array, "be", 32), 32), 0; }, ecdsaSign(t, s, u, i, o) { if (o) {
                        const l = o;
                        o = p => { const g = l(s, u, null, i, p); if (!(g instanceof Uint8Array && g.length === 32))
                            throw new Error("This is the way"); return new e(g); };
                    } const h = new e(u); if (h.cmp(r.n) >= 0 || h.isZero())
                        return 1; let a; try {
                        a = d.sign(s, u, { canonical: !0, k: o, pers: i });
                    }
                    catch (l) {
                        return 1;
                    } return t.signature.set(a.r.toArrayLike(Uint8Array, "be", 32), 0), t.signature.set(a.s.toArrayLike(Uint8Array, "be", 32), 32), t.recid = a.recoveryParam, 0; }, ecdsaVerify(t, s, u) { const i = { r: t.subarray(0, 32), s: t.subarray(32, 64) }, o = new e(i.r), h = new e(i.s); if (o.cmp(r.n) >= 0 || h.cmp(r.n) >= 0)
                        return 1; if (h.cmp(d.nh) === 1 || o.isZero() || h.isZero())
                        return 3; const a = c(u); if (a === null)
                        return 2; const l = a.getPublic(); return d.verify(s, i, l) ? 0 : 3; }, ecdsaRecover(t, s, u, i) { const o = { r: s.slice(0, 32), s: s.slice(32, 64) }, h = new e(o.r), a = new e(o.s); if (h.cmp(r.n) >= 0 || a.cmp(r.n) >= 0)
                        return 1; if (h.isZero() || a.isZero())
                        return 2; let l; try {
                        l = d.recoverPubKey(i, o, u);
                    }
                    catch (p) {
                        return 2;
                    } return n(t, l), 0; }, ecdh(t, s, u, i, o, h, a) { const l = c(s); if (l === null)
                        return 1; const p = new e(u); if (p.cmp(r.n) >= 0 || p.isZero())
                        return 2; const g = l.getPublic().mul(p); if (o === void 0) {
                        const b = g.encode(null, !0), I = d.hash().update(b).digest();
                        for (let v = 0; v < 32; ++v)
                            t[v] = I[v];
                    }
                    else {
                        h || (h = new Uint8Array(32));
                        const b = g.getX().toArray("be", 32);
                        for (let R = 0; R < 32; ++R)
                            h[R] = b[R];
                        a || (a = new Uint8Array(32));
                        const I = g.getY().toArray("be", 32);
                        for (let R = 0; R < 32; ++R)
                            a[R] = I[R];
                        const v = o(h, a, i);
                        if (!(v instanceof Uint8Array && v.length === t.length))
                            return 2;
                        t.set(v);
                    } return 0; } };
            }, function (E, m, f) {
                "use strict";
                var d = m;
                d.version = f(471).version, d.utils = f(33), d.rand = f(234), d.curve = f(235), d.curves = f(149), d.ec = f(484), d.eddsa = f(488);
            }, function (E) { E.exports = JSON.parse('{"name":"elliptic","version":"6.5.3","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^1.4.3","coveralls":"^3.0.8","grunt":"^1.0.4","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.2","jscs":"^3.0.7","jshint":"^2.10.3","mocha":"^6.2.2"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"}}'); }, function (E, m) { }, function (E, m) { }, function (E, m, f) {
                "use strict";
                var d = f(33), r = f(38), e = f(15), c = f(108), n = d.assert;
                function t(i) { c.call(this, "short", i), this.a = new r(i.a, 16).toRed(this.red), this.b = new r(i.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(i), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4); }
                function s(i, o, h, a) { c.BasePoint.call(this, i, "affine"), o === null && h === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new r(o, 16), this.y = new r(h, 16), a && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1); }
                function u(i, o, h, a) { c.BasePoint.call(this, i, "jacobian"), o === null && h === null && a === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new r(0)) : (this.x = new r(o, 16), this.y = new r(h, 16), this.z = new r(a, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one; }
                e(t, c), E.exports = t, t.prototype._getEndomorphism = function (i) { if (this.zeroA && this.g && this.n && this.p.modn(3) === 1) {
                    var o, h;
                    if (i.beta)
                        o = new r(i.beta, 16).toRed(this.red);
                    else {
                        var a = this._getEndoRoots(this.p);
                        o = (o = a[0].cmp(a[1]) < 0 ? a[0] : a[1]).toRed(this.red);
                    }
                    if (i.lambda)
                        h = new r(i.lambda, 16);
                    else {
                        var l = this._getEndoRoots(this.n);
                        this.g.mul(l[0]).x.cmp(this.g.x.redMul(o)) === 0 ? h = l[0] : (h = l[1], n(this.g.mul(h).x.cmp(this.g.x.redMul(o)) === 0));
                    }
                    return { beta: o, lambda: h, basis: i.basis ? i.basis.map(function (p) { return { a: new r(p.a, 16), b: new r(p.b, 16) }; }) : this._getEndoBasis(h) };
                } }, t.prototype._getEndoRoots = function (i) { var o = i === this.p ? this.red : r.mont(i), h = new r(2).toRed(o).redInvm(), a = h.redNeg(), l = new r(3).toRed(o).redNeg().redSqrt().redMul(h); return [a.redAdd(l).fromRed(), a.redSub(l).fromRed()]; }, t.prototype._getEndoBasis = function (i) { for (var o, h, a, l, p, g, b, I, v, R = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), _ = i, k = this.n.clone(), x = new r(1), M = new r(0), N = new r(0), S = new r(1), T = 0; _.cmpn(0) !== 0;) {
                    var B = k.div(_);
                    I = k.sub(B.mul(_)), v = N.sub(B.mul(x));
                    var P = S.sub(B.mul(M));
                    if (!a && I.cmp(R) < 0)
                        o = b.neg(), h = x, a = I.neg(), l = v;
                    else if (a && ++T == 2)
                        break;
                    b = I, k = _, _ = I, N = x, x = v, S = M, M = P;
                } p = I.neg(), g = v; var L = a.sqr().add(l.sqr()); return p.sqr().add(g.sqr()).cmp(L) >= 0 && (p = o, g = h), a.negative && (a = a.neg(), l = l.neg()), p.negative && (p = p.neg(), g = g.neg()), [{ a, b: l }, { a: p, b: g }]; }, t.prototype._endoSplit = function (i) { var o = this.endo.basis, h = o[0], a = o[1], l = a.b.mul(i).divRound(this.n), p = h.b.neg().mul(i).divRound(this.n), g = l.mul(h.a), b = p.mul(a.a), I = l.mul(h.b), v = p.mul(a.b); return { k1: i.sub(g).sub(b), k2: I.add(v).neg() }; }, t.prototype.pointFromX = function (i, o) { (i = new r(i, 16)).red || (i = i.toRed(this.red)); var h = i.redSqr().redMul(i).redIAdd(i.redMul(this.a)).redIAdd(this.b), a = h.redSqrt(); if (a.redSqr().redSub(h).cmp(this.zero) !== 0)
                    throw new Error("invalid point"); var l = a.fromRed().isOdd(); return (o && !l || !o && l) && (a = a.redNeg()), this.point(i, a); }, t.prototype.validate = function (i) { if (i.inf)
                    return !0; var o = i.x, h = i.y, a = this.a.redMul(o), l = o.redSqr().redMul(o).redIAdd(a).redIAdd(this.b); return h.redSqr().redISub(l).cmpn(0) === 0; }, t.prototype._endoWnafMulAdd = function (i, o, h) { for (var a = this._endoWnafT1, l = this._endoWnafT2, p = 0; p < i.length; p++) {
                    var g = this._endoSplit(o[p]), b = i[p], I = b._getBeta();
                    g.k1.negative && (g.k1.ineg(), b = b.neg(!0)), g.k2.negative && (g.k2.ineg(), I = I.neg(!0)), a[2 * p] = b, a[2 * p + 1] = I, l[2 * p] = g.k1, l[2 * p + 1] = g.k2;
                } for (var v = this._wnafMulAdd(1, a, l, 2 * p, h), R = 0; R < 2 * p; R++)
                    a[R] = null, l[R] = null; return v; }, e(s, c.BasePoint), t.prototype.point = function (i, o, h) { return new s(this, i, o, h); }, t.prototype.pointFromJSON = function (i, o) { return s.fromJSON(this, i, o); }, s.prototype._getBeta = function () { if (this.curve.endo) {
                    var i = this.precomputed;
                    if (i && i.beta)
                        return i.beta;
                    var o = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
                    if (i) {
                        var h = this.curve, a = function (l) { return h.point(l.x.redMul(h.endo.beta), l.y); };
                        i.beta = o, o.precomputed = { beta: null, naf: i.naf && { wnd: i.naf.wnd, points: i.naf.points.map(a) }, doubles: i.doubles && { step: i.doubles.step, points: i.doubles.points.map(a) } };
                    }
                    return o;
                } }, s.prototype.toJSON = function () { return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y]; }, s.fromJSON = function (i, o, h) { typeof o == "string" && (o = JSON.parse(o)); var a = i.point(o[0], o[1], h); if (!o[2])
                    return a; function l(g) { return i.point(g[0], g[1], h); } var p = o[2]; return a.precomputed = { beta: null, doubles: p.doubles && { step: p.doubles.step, points: [a].concat(p.doubles.points.map(l)) }, naf: p.naf && { wnd: p.naf.wnd, points: [a].concat(p.naf.points.map(l)) } }, a; }, s.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">"; }, s.prototype.isInfinity = function () { return this.inf; }, s.prototype.add = function (i) { if (this.inf)
                    return i; if (i.inf)
                    return this; if (this.eq(i))
                    return this.dbl(); if (this.neg().eq(i))
                    return this.curve.point(null, null); if (this.x.cmp(i.x) === 0)
                    return this.curve.point(null, null); var o = this.y.redSub(i.y); o.cmpn(0) !== 0 && (o = o.redMul(this.x.redSub(i.x).redInvm())); var h = o.redSqr().redISub(this.x).redISub(i.x), a = o.redMul(this.x.redSub(h)).redISub(this.y); return this.curve.point(h, a); }, s.prototype.dbl = function () { if (this.inf)
                    return this; var i = this.y.redAdd(this.y); if (i.cmpn(0) === 0)
                    return this.curve.point(null, null); var o = this.curve.a, h = this.x.redSqr(), a = i.redInvm(), l = h.redAdd(h).redIAdd(h).redIAdd(o).redMul(a), p = l.redSqr().redISub(this.x.redAdd(this.x)), g = l.redMul(this.x.redSub(p)).redISub(this.y); return this.curve.point(p, g); }, s.prototype.getX = function () { return this.x.fromRed(); }, s.prototype.getY = function () { return this.y.fromRed(); }, s.prototype.mul = function (i) { return i = new r(i, 16), this.isInfinity() ? this : this._hasDoubles(i) ? this.curve._fixedNafMul(this, i) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [i]) : this.curve._wnafMul(this, i); }, s.prototype.mulAdd = function (i, o, h) { var a = [this, o], l = [i, h]; return this.curve.endo ? this.curve._endoWnafMulAdd(a, l) : this.curve._wnafMulAdd(1, a, l, 2); }, s.prototype.jmulAdd = function (i, o, h) { var a = [this, o], l = [i, h]; return this.curve.endo ? this.curve._endoWnafMulAdd(a, l, !0) : this.curve._wnafMulAdd(1, a, l, 2, !0); }, s.prototype.eq = function (i) { return this === i || this.inf === i.inf && (this.inf || this.x.cmp(i.x) === 0 && this.y.cmp(i.y) === 0); }, s.prototype.neg = function (i) { if (this.inf)
                    return this; var o = this.curve.point(this.x, this.y.redNeg()); if (i && this.precomputed) {
                    var h = this.precomputed, a = function (l) { return l.neg(); };
                    o.precomputed = { naf: h.naf && { wnd: h.naf.wnd, points: h.naf.points.map(a) }, doubles: h.doubles && { step: h.doubles.step, points: h.doubles.points.map(a) } };
                } return o; }, s.prototype.toJ = function () { return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one); }, e(u, c.BasePoint), t.prototype.jpoint = function (i, o, h) { return new u(this, i, o, h); }, u.prototype.toP = function () { if (this.isInfinity())
                    return this.curve.point(null, null); var i = this.z.redInvm(), o = i.redSqr(), h = this.x.redMul(o), a = this.y.redMul(o).redMul(i); return this.curve.point(h, a); }, u.prototype.neg = function () { return this.curve.jpoint(this.x, this.y.redNeg(), this.z); }, u.prototype.add = function (i) { if (this.isInfinity())
                    return i; if (i.isInfinity())
                    return this; var o = i.z.redSqr(), h = this.z.redSqr(), a = this.x.redMul(o), l = i.x.redMul(h), p = this.y.redMul(o.redMul(i.z)), g = i.y.redMul(h.redMul(this.z)), b = a.redSub(l), I = p.redSub(g); if (b.cmpn(0) === 0)
                    return I.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var v = b.redSqr(), R = v.redMul(b), _ = a.redMul(v), k = I.redSqr().redIAdd(R).redISub(_).redISub(_), x = I.redMul(_.redISub(k)).redISub(p.redMul(R)), M = this.z.redMul(i.z).redMul(b); return this.curve.jpoint(k, x, M); }, u.prototype.mixedAdd = function (i) { if (this.isInfinity())
                    return i.toJ(); if (i.isInfinity())
                    return this; var o = this.z.redSqr(), h = this.x, a = i.x.redMul(o), l = this.y, p = i.y.redMul(o).redMul(this.z), g = h.redSub(a), b = l.redSub(p); if (g.cmpn(0) === 0)
                    return b.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var I = g.redSqr(), v = I.redMul(g), R = h.redMul(I), _ = b.redSqr().redIAdd(v).redISub(R).redISub(R), k = b.redMul(R.redISub(_)).redISub(l.redMul(v)), x = this.z.redMul(g); return this.curve.jpoint(_, k, x); }, u.prototype.dblp = function (i) { if (i === 0)
                    return this; if (this.isInfinity())
                    return this; if (!i)
                    return this.dbl(); if (this.curve.zeroA || this.curve.threeA) {
                    for (var o = this, h = 0; h < i; h++)
                        o = o.dbl();
                    return o;
                } var a = this.curve.a, l = this.curve.tinv, p = this.x, g = this.y, b = this.z, I = b.redSqr().redSqr(), v = g.redAdd(g); for (h = 0; h < i; h++) {
                    var R = p.redSqr(), _ = v.redSqr(), k = _.redSqr(), x = R.redAdd(R).redIAdd(R).redIAdd(a.redMul(I)), M = p.redMul(_), N = x.redSqr().redISub(M.redAdd(M)), S = M.redISub(N), T = x.redMul(S);
                    T = T.redIAdd(T).redISub(k);
                    var B = v.redMul(b);
                    h + 1 < i && (I = I.redMul(k)), p = N, b = B, v = T;
                } return this.curve.jpoint(p, v.redMul(l), b); }, u.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl(); }, u.prototype._zeroDbl = function () { var i, o, h; if (this.zOne) {
                    var a = this.x.redSqr(), l = this.y.redSqr(), p = l.redSqr(), g = this.x.redAdd(l).redSqr().redISub(a).redISub(p);
                    g = g.redIAdd(g);
                    var b = a.redAdd(a).redIAdd(a), I = b.redSqr().redISub(g).redISub(g), v = p.redIAdd(p);
                    v = (v = v.redIAdd(v)).redIAdd(v), i = I, o = b.redMul(g.redISub(I)).redISub(v), h = this.y.redAdd(this.y);
                }
                else {
                    var R = this.x.redSqr(), _ = this.y.redSqr(), k = _.redSqr(), x = this.x.redAdd(_).redSqr().redISub(R).redISub(k);
                    x = x.redIAdd(x);
                    var M = R.redAdd(R).redIAdd(R), N = M.redSqr(), S = k.redIAdd(k);
                    S = (S = S.redIAdd(S)).redIAdd(S), i = N.redISub(x).redISub(x), o = M.redMul(x.redISub(i)).redISub(S), h = (h = this.y.redMul(this.z)).redIAdd(h);
                } return this.curve.jpoint(i, o, h); }, u.prototype._threeDbl = function () { var i, o, h; if (this.zOne) {
                    var a = this.x.redSqr(), l = this.y.redSqr(), p = l.redSqr(), g = this.x.redAdd(l).redSqr().redISub(a).redISub(p);
                    g = g.redIAdd(g);
                    var b = a.redAdd(a).redIAdd(a).redIAdd(this.curve.a), I = b.redSqr().redISub(g).redISub(g);
                    i = I;
                    var v = p.redIAdd(p);
                    v = (v = v.redIAdd(v)).redIAdd(v), o = b.redMul(g.redISub(I)).redISub(v), h = this.y.redAdd(this.y);
                }
                else {
                    var R = this.z.redSqr(), _ = this.y.redSqr(), k = this.x.redMul(_), x = this.x.redSub(R).redMul(this.x.redAdd(R));
                    x = x.redAdd(x).redIAdd(x);
                    var M = k.redIAdd(k), N = (M = M.redIAdd(M)).redAdd(M);
                    i = x.redSqr().redISub(N), h = this.y.redAdd(this.z).redSqr().redISub(_).redISub(R);
                    var S = _.redSqr();
                    S = (S = (S = S.redIAdd(S)).redIAdd(S)).redIAdd(S), o = x.redMul(M.redISub(i)).redISub(S);
                } return this.curve.jpoint(i, o, h); }, u.prototype._dbl = function () { var i = this.curve.a, o = this.x, h = this.y, a = this.z, l = a.redSqr().redSqr(), p = o.redSqr(), g = h.redSqr(), b = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), I = o.redAdd(o), v = (I = I.redIAdd(I)).redMul(g), R = b.redSqr().redISub(v.redAdd(v)), _ = v.redISub(R), k = g.redSqr(); k = (k = (k = k.redIAdd(k)).redIAdd(k)).redIAdd(k); var x = b.redMul(_).redISub(k), M = h.redAdd(h).redMul(a); return this.curve.jpoint(R, x, M); }, u.prototype.trpl = function () { if (!this.curve.zeroA)
                    return this.dbl().add(this); var i = this.x.redSqr(), o = this.y.redSqr(), h = this.z.redSqr(), a = o.redSqr(), l = i.redAdd(i).redIAdd(i), p = l.redSqr(), g = this.x.redAdd(o).redSqr().redISub(i).redISub(a), b = (g = (g = (g = g.redIAdd(g)).redAdd(g).redIAdd(g)).redISub(p)).redSqr(), I = a.redIAdd(a); I = (I = (I = I.redIAdd(I)).redIAdd(I)).redIAdd(I); var v = l.redIAdd(g).redSqr().redISub(p).redISub(b).redISub(I), R = o.redMul(v); R = (R = R.redIAdd(R)).redIAdd(R); var _ = this.x.redMul(b).redISub(R); _ = (_ = _.redIAdd(_)).redIAdd(_); var k = this.y.redMul(v.redMul(I.redISub(v)).redISub(g.redMul(b))); k = (k = (k = k.redIAdd(k)).redIAdd(k)).redIAdd(k); var x = this.z.redAdd(g).redSqr().redISub(h).redISub(b); return this.curve.jpoint(_, k, x); }, u.prototype.mul = function (i, o) { return i = new r(i, o), this.curve._wnafMul(this, i); }, u.prototype.eq = function (i) { if (i.type === "affine")
                    return this.eq(i.toJ()); if (this === i)
                    return !0; var o = this.z.redSqr(), h = i.z.redSqr(); if (this.x.redMul(h).redISub(i.x.redMul(o)).cmpn(0) !== 0)
                    return !1; var a = o.redMul(this.z), l = h.redMul(i.z); return this.y.redMul(l).redISub(i.y.redMul(a)).cmpn(0) === 0; }, u.prototype.eqXToP = function (i) { var o = this.z.redSqr(), h = i.toRed(this.curve.red).redMul(o); if (this.x.cmp(h) === 0)
                    return !0; for (var a = i.clone(), l = this.curve.redN.redMul(o);;) {
                    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
                        return !1;
                    if (h.redIAdd(l), this.x.cmp(h) === 0)
                        return !0;
                } }, u.prototype.inspect = function () { return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">"; }, u.prototype.isInfinity = function () { return this.z.cmpn(0) === 0; };
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(15), e = f(108), c = f(33);
                function n(s) { e.call(this, "mont", s), this.a = new d(s.a, 16).toRed(this.red), this.b = new d(s.b, 16).toRed(this.red), this.i4 = new d(4).toRed(this.red).redInvm(), this.two = new d(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two)); }
                function t(s, u, i) { e.BasePoint.call(this, s, "projective"), u === null && i === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new d(u, 16), this.z = new d(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red))); }
                r(n, e), E.exports = n, n.prototype.validate = function (s) { var u = s.normalize().x, i = u.redSqr(), o = i.redMul(u).redAdd(i.redMul(this.a)).redAdd(u); return o.redSqrt().redSqr().cmp(o) === 0; }, r(t, e.BasePoint), n.prototype.decodePoint = function (s, u) { return this.point(c.toArray(s, u), 1); }, n.prototype.point = function (s, u) { return new t(this, s, u); }, n.prototype.pointFromJSON = function (s) { return t.fromJSON(this, s); }, t.prototype.precompute = function () { }, t.prototype._encode = function () { return this.getX().toArray("be", this.curve.p.byteLength()); }, t.fromJSON = function (s, u) { return new t(s, u[0], u[1] || s.one); }, t.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"; }, t.prototype.isInfinity = function () { return this.z.cmpn(0) === 0; }, t.prototype.dbl = function () { var s = this.x.redAdd(this.z).redSqr(), u = this.x.redSub(this.z).redSqr(), i = s.redSub(u), o = s.redMul(u), h = i.redMul(u.redAdd(this.curve.a24.redMul(i))); return this.curve.point(o, h); }, t.prototype.add = function () { throw new Error("Not supported on Montgomery curve"); }, t.prototype.diffAdd = function (s, u) { var i = this.x.redAdd(this.z), o = this.x.redSub(this.z), h = s.x.redAdd(s.z), a = s.x.redSub(s.z).redMul(i), l = h.redMul(o), p = u.z.redMul(a.redAdd(l).redSqr()), g = u.x.redMul(a.redISub(l).redSqr()); return this.curve.point(p, g); }, t.prototype.mul = function (s) { for (var u = s.clone(), i = this, o = this.curve.point(null, null), h = []; u.cmpn(0) !== 0; u.iushrn(1))
                    h.push(u.andln(1)); for (var a = h.length - 1; a >= 0; a--)
                    h[a] === 0 ? (i = i.diffAdd(o, this), o = o.dbl()) : (o = i.diffAdd(o, this), i = i.dbl()); return o; }, t.prototype.mulAdd = function () { throw new Error("Not supported on Montgomery curve"); }, t.prototype.jumlAdd = function () { throw new Error("Not supported on Montgomery curve"); }, t.prototype.eq = function (s) { return this.getX().cmp(s.getX()) === 0; }, t.prototype.normalize = function () { return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this; }, t.prototype.getX = function () { return this.normalize(), this.x.fromRed(); };
            }, function (E, m, f) {
                "use strict";
                var d = f(33), r = f(38), e = f(15), c = f(108), n = d.assert;
                function t(u) { this.twisted = (0 | u.a) != 1, this.mOneA = this.twisted && (0 | u.a) == -1, this.extended = this.mOneA, c.call(this, "edwards", u), this.a = new r(u.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new r(u.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new r(u.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), n(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (0 | u.c) == 1; }
                function s(u, i, o, h, a) { c.BasePoint.call(this, u, "projective"), i === null && o === null && h === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new r(i, 16), this.y = new r(o, 16), this.z = h ? new r(h, 16) : this.curve.one, this.t = a && new r(a, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm())))); }
                e(t, c), E.exports = t, t.prototype._mulA = function (u) { return this.mOneA ? u.redNeg() : this.a.redMul(u); }, t.prototype._mulC = function (u) { return this.oneC ? u : this.c.redMul(u); }, t.prototype.jpoint = function (u, i, o, h) { return this.point(u, i, o, h); }, t.prototype.pointFromX = function (u, i) { (u = new r(u, 16)).red || (u = u.toRed(this.red)); var o = u.redSqr(), h = this.c2.redSub(this.a.redMul(o)), a = this.one.redSub(this.c2.redMul(this.d).redMul(o)), l = h.redMul(a.redInvm()), p = l.redSqrt(); if (p.redSqr().redSub(l).cmp(this.zero) !== 0)
                    throw new Error("invalid point"); var g = p.fromRed().isOdd(); return (i && !g || !i && g) && (p = p.redNeg()), this.point(u, p); }, t.prototype.pointFromY = function (u, i) { (u = new r(u, 16)).red || (u = u.toRed(this.red)); var o = u.redSqr(), h = o.redSub(this.c2), a = o.redMul(this.d).redMul(this.c2).redSub(this.a), l = h.redMul(a.redInvm()); if (l.cmp(this.zero) === 0) {
                    if (i)
                        throw new Error("invalid point");
                    return this.point(this.zero, u);
                } var p = l.redSqrt(); if (p.redSqr().redSub(l).cmp(this.zero) !== 0)
                    throw new Error("invalid point"); return p.fromRed().isOdd() !== i && (p = p.redNeg()), this.point(p, u); }, t.prototype.validate = function (u) { if (u.isInfinity())
                    return !0; u.normalize(); var i = u.x.redSqr(), o = u.y.redSqr(), h = i.redMul(this.a).redAdd(o), a = this.c2.redMul(this.one.redAdd(this.d.redMul(i).redMul(o))); return h.cmp(a) === 0; }, e(s, c.BasePoint), t.prototype.pointFromJSON = function (u) { return s.fromJSON(this, u); }, t.prototype.point = function (u, i, o, h) { return new s(this, u, i, o, h); }, s.fromJSON = function (u, i) { return new s(u, i[0], i[1], i[2]); }, s.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">"; }, s.prototype.isInfinity = function () { return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0); }, s.prototype._extDbl = function () { var u = this.x.redSqr(), i = this.y.redSqr(), o = this.z.redSqr(); o = o.redIAdd(o); var h = this.curve._mulA(u), a = this.x.redAdd(this.y).redSqr().redISub(u).redISub(i), l = h.redAdd(i), p = l.redSub(o), g = h.redSub(i), b = a.redMul(p), I = l.redMul(g), v = a.redMul(g), R = p.redMul(l); return this.curve.point(b, I, R, v); }, s.prototype._projDbl = function () { var u, i, o, h = this.x.redAdd(this.y).redSqr(), a = this.x.redSqr(), l = this.y.redSqr(); if (this.curve.twisted) {
                    var p = (I = this.curve._mulA(a)).redAdd(l);
                    if (this.zOne)
                        u = h.redSub(a).redSub(l).redMul(p.redSub(this.curve.two)), i = p.redMul(I.redSub(l)), o = p.redSqr().redSub(p).redSub(p);
                    else {
                        var g = this.z.redSqr(), b = p.redSub(g).redISub(g);
                        u = h.redSub(a).redISub(l).redMul(b), i = p.redMul(I.redSub(l)), o = p.redMul(b);
                    }
                }
                else {
                    var I = a.redAdd(l);
                    g = this.curve._mulC(this.z).redSqr(), b = I.redSub(g).redSub(g), u = this.curve._mulC(h.redISub(I)).redMul(b), i = this.curve._mulC(I).redMul(a.redISub(l)), o = I.redMul(b);
                } return this.curve.point(u, i, o); }, s.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl(); }, s.prototype._extAdd = function (u) { var i = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), o = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), h = this.t.redMul(this.curve.dd).redMul(u.t), a = this.z.redMul(u.z.redAdd(u.z)), l = o.redSub(i), p = a.redSub(h), g = a.redAdd(h), b = o.redAdd(i), I = l.redMul(p), v = g.redMul(b), R = l.redMul(b), _ = p.redMul(g); return this.curve.point(I, v, _, R); }, s.prototype._projAdd = function (u) { var i, o, h = this.z.redMul(u.z), a = h.redSqr(), l = this.x.redMul(u.x), p = this.y.redMul(u.y), g = this.curve.d.redMul(l).redMul(p), b = a.redSub(g), I = a.redAdd(g), v = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(l).redISub(p), R = h.redMul(b).redMul(v); return this.curve.twisted ? (i = h.redMul(I).redMul(p.redSub(this.curve._mulA(l))), o = b.redMul(I)) : (i = h.redMul(I).redMul(p.redSub(l)), o = this.curve._mulC(b).redMul(I)), this.curve.point(R, i, o); }, s.prototype.add = function (u) { return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u); }, s.prototype.mul = function (u) { return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u); }, s.prototype.mulAdd = function (u, i, o) { return this.curve._wnafMulAdd(1, [this, i], [u, o], 2, !1); }, s.prototype.jmulAdd = function (u, i, o) { return this.curve._wnafMulAdd(1, [this, i], [u, o], 2, !0); }, s.prototype.normalize = function () { if (this.zOne)
                    return this; var u = this.z.redInvm(); return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this; }, s.prototype.neg = function () { return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg()); }, s.prototype.getX = function () { return this.normalize(), this.x.fromRed(); }, s.prototype.getY = function () { return this.normalize(), this.y.fromRed(); }, s.prototype.eq = function (u) { return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0; }, s.prototype.eqXToP = function (u) { var i = u.toRed(this.curve.red).redMul(this.z); if (this.x.cmp(i) === 0)
                    return !0; for (var o = u.clone(), h = this.curve.redN.redMul(this.z);;) {
                    if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
                        return !1;
                    if (i.redIAdd(h), this.x.cmp(i) === 0)
                        return !0;
                } }, s.prototype.toP = s.prototype.normalize, s.prototype.mixedAdd = s.prototype.add;
            }, function (E, m, f) {
                "use strict";
                m.sha1 = f(478), m.sha224 = f(479), m.sha256 = f(237), m.sha384 = f(480), m.sha512 = f(238);
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(85), e = f(236), c = d.rotl32, n = d.sum32, t = d.sum32_5, s = e.ft_1, u = r.BlockHash, i = [1518500249, 1859775393, 2400959708, 3395469782];
                function o() { if (!(this instanceof o))
                    return new o; u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80); }
                d.inherits(o, u), E.exports = o, o.blockSize = 512, o.outSize = 160, o.hmacStrength = 80, o.padLength = 64, o.prototype._update = function (h, a) { for (var l = this.W, p = 0; p < 16; p++)
                    l[p] = h[a + p]; for (; p < l.length; p++)
                    l[p] = c(l[p - 3] ^ l[p - 8] ^ l[p - 14] ^ l[p - 16], 1); var g = this.h[0], b = this.h[1], I = this.h[2], v = this.h[3], R = this.h[4]; for (p = 0; p < l.length; p++) {
                    var _ = ~~(p / 20), k = t(c(g, 5), s(_, b, I, v), R, l[p], i[_]);
                    R = v, v = I, I = c(b, 30), b = g, g = k;
                } this.h[0] = n(this.h[0], g), this.h[1] = n(this.h[1], b), this.h[2] = n(this.h[2], I), this.h[3] = n(this.h[3], v), this.h[4] = n(this.h[4], R); }, o.prototype._digest = function (h) { return h === "hex" ? d.toHex32(this.h, "big") : d.split32(this.h, "big"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(237);
                function e() { if (!(this instanceof e))
                    return new e; r.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]; }
                d.inherits(e, r), E.exports = e, e.blockSize = 512, e.outSize = 224, e.hmacStrength = 192, e.padLength = 64, e.prototype._digest = function (c) { return c === "hex" ? d.toHex32(this.h.slice(0, 7), "big") : d.split32(this.h.slice(0, 7), "big"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(238);
                function e() { if (!(this instanceof e))
                    return new e; r.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]; }
                d.inherits(e, r), E.exports = e, e.blockSize = 1024, e.outSize = 384, e.hmacStrength = 192, e.padLength = 128, e.prototype._digest = function (c) { return c === "hex" ? d.toHex32(this.h.slice(0, 12), "big") : d.split32(this.h.slice(0, 12), "big"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(85), e = d.rotl32, c = d.sum32, n = d.sum32_3, t = d.sum32_4, s = r.BlockHash;
                function u() { if (!(this instanceof u))
                    return new u; s.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"; }
                function i(b, I, v, R) { return b <= 15 ? I ^ v ^ R : b <= 31 ? I & v | ~I & R : b <= 47 ? (I | ~v) ^ R : b <= 63 ? I & R | v & ~R : I ^ (v | ~R); }
                function o(b) { return b <= 15 ? 0 : b <= 31 ? 1518500249 : b <= 47 ? 1859775393 : b <= 63 ? 2400959708 : 2840853838; }
                function h(b) { return b <= 15 ? 1352829926 : b <= 31 ? 1548603684 : b <= 47 ? 1836072691 : b <= 63 ? 2053994217 : 0; }
                d.inherits(u, s), m.ripemd160 = u, u.blockSize = 512, u.outSize = 160, u.hmacStrength = 192, u.padLength = 64, u.prototype._update = function (b, I) { for (var v = this.h[0], R = this.h[1], _ = this.h[2], k = this.h[3], x = this.h[4], M = v, N = R, S = _, T = k, B = x, P = 0; P < 80; P++) {
                    var L = c(e(t(v, i(P, R, _, k), b[a[P] + I], o(P)), p[P]), x);
                    v = x, x = k, k = e(_, 10), _ = R, R = L, L = c(e(t(M, i(79 - P, N, S, T), b[l[P] + I], h(P)), g[P]), B), M = B, B = T, T = e(S, 10), S = N, N = L;
                } L = n(this.h[1], _, T), this.h[1] = n(this.h[2], k, B), this.h[2] = n(this.h[3], x, M), this.h[3] = n(this.h[4], v, N), this.h[4] = n(this.h[0], R, S), this.h[0] = L; }, u.prototype._digest = function (b) { return b === "hex" ? d.toHex32(this.h, "little") : d.split32(this.h, "little"); };
                var a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], l = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], p = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], g = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
            }, function (E, m, f) {
                "use strict";
                var d = f(36), r = f(51);
                function e(c, n, t) { if (!(this instanceof e))
                    return new e(c, n, t); this.Hash = c, this.blockSize = c.blockSize / 8, this.outSize = c.outSize / 8, this.inner = null, this.outer = null, this._init(d.toArray(n, t)); }
                E.exports = e, e.prototype._init = function (c) { c.length > this.blockSize && (c = new this.Hash().update(c).digest()), r(c.length <= this.blockSize); for (var n = c.length; n < this.blockSize; n++)
                    c.push(0); for (n = 0; n < c.length; n++)
                    c[n] ^= 54; for (this.inner = new this.Hash().update(c), n = 0; n < c.length; n++)
                    c[n] ^= 106; this.outer = new this.Hash().update(c); }, e.prototype.update = function (c, n) { return this.inner.update(c, n), this; }, e.prototype.digest = function (c) { return this.outer.update(this.inner.digest()), this.outer.digest(c); };
            }, function (E, m, f) {
                "use strict";
                E.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(485), e = f(33), c = f(149), n = f(234), t = e.assert, s = f(486), u = f(487);
                function i(o) { if (!(this instanceof i))
                    return new i(o); typeof o == "string" && (t(c.hasOwnProperty(o), "Unknown curve " + o), o = c[o]), o instanceof c.PresetCurve && (o = { curve: o }), this.curve = o.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = o.curve.g, this.g.precompute(o.curve.n.bitLength() + 1), this.hash = o.hash || o.curve.hash; }
                E.exports = i, i.prototype.keyPair = function (o) { return new s(this, o); }, i.prototype.keyFromPrivate = function (o, h) { return s.fromPrivate(this, o, h); }, i.prototype.keyFromPublic = function (o, h) { return s.fromPublic(this, o, h); }, i.prototype.genKeyPair = function (o) { o || (o = {}); for (var h = new r({ hash: this.hash, pers: o.pers, persEnc: o.persEnc || "utf8", entropy: o.entropy || n(this.hash.hmacStrength), entropyEnc: o.entropy && o.entropyEnc || "utf8", nonce: this.n.toArray() }), a = this.n.byteLength(), l = this.n.sub(new d(2));;) {
                    var p = new d(h.generate(a));
                    if (!(p.cmp(l) > 0))
                        return p.iaddn(1), this.keyFromPrivate(p);
                } }, i.prototype._truncateToN = function (o, h) { var a = 8 * o.byteLength() - this.n.bitLength(); return a > 0 && (o = o.ushrn(a)), !h && o.cmp(this.n) >= 0 ? o.sub(this.n) : o; }, i.prototype.sign = function (o, h, a, l) { typeof a == "object" && (l = a, a = null), l || (l = {}), h = this.keyFromPrivate(h, a), o = this._truncateToN(new d(o, 16)); for (var p = this.n.byteLength(), g = h.getPrivate().toArray("be", p), b = o.toArray("be", p), I = new r({ hash: this.hash, entropy: g, nonce: b, pers: l.pers, persEnc: l.persEnc || "utf8" }), v = this.n.sub(new d(1)), R = 0;; R++) {
                    var _ = l.k ? l.k(R) : new d(I.generate(this.n.byteLength()));
                    if (!((_ = this._truncateToN(_, !0)).cmpn(1) <= 0 || _.cmp(v) >= 0)) {
                        var k = this.g.mul(_);
                        if (!k.isInfinity()) {
                            var x = k.getX(), M = x.umod(this.n);
                            if (M.cmpn(0) !== 0) {
                                var N = _.invm(this.n).mul(M.mul(h.getPrivate()).iadd(o));
                                if ((N = N.umod(this.n)).cmpn(0) !== 0) {
                                    var S = (k.getY().isOdd() ? 1 : 0) | (x.cmp(M) !== 0 ? 2 : 0);
                                    return l.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), S ^= 1), new u({ r: M, s: N, recoveryParam: S });
                                }
                            }
                        }
                    }
                } }, i.prototype.verify = function (o, h, a, l) { o = this._truncateToN(new d(o, 16)), a = this.keyFromPublic(a, l); var p = (h = new u(h, "hex")).r, g = h.s; if (p.cmpn(1) < 0 || p.cmp(this.n) >= 0)
                    return !1; if (g.cmpn(1) < 0 || g.cmp(this.n) >= 0)
                    return !1; var b, I = g.invm(this.n), v = I.mul(o).umod(this.n), R = I.mul(p).umod(this.n); return this.curve._maxwellTrick ? !(b = this.g.jmulAdd(v, a.getPublic(), R)).isInfinity() && b.eqXToP(p) : !(b = this.g.mulAdd(v, a.getPublic(), R)).isInfinity() && b.getX().umod(this.n).cmp(p) === 0; }, i.prototype.recoverPubKey = function (o, h, a, l) { t((3 & a) === a, "The recovery param is more than two bits"), h = new u(h, l); var p = this.n, g = new d(o), b = h.r, I = h.s, v = 1 & a, R = a >> 1; if (b.cmp(this.curve.p.umod(this.curve.n)) >= 0 && R)
                    throw new Error("Unable to find sencond key candinate"); b = R ? this.curve.pointFromX(b.add(this.curve.n), v) : this.curve.pointFromX(b, v); var _ = h.r.invm(p), k = p.sub(g).mul(_).umod(p), x = I.mul(_).umod(p); return this.g.mulAdd(k, b, x); }, i.prototype.getKeyRecoveryParam = function (o, h, a, l) { if ((h = new u(h, l)).recoveryParam !== null)
                    return h.recoveryParam; for (var p = 0; p < 4; p++) {
                    var g;
                    try {
                        g = this.recoverPubKey(o, h, p);
                    }
                    catch (b) {
                        continue;
                    }
                    if (g.eq(a))
                        return p;
                } throw new Error("Unable to find valid recovery factor"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(150), r = f(233), e = f(51);
                function c(n) { if (!(this instanceof c))
                    return new c(n); this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null; var t = r.toArray(n.entropy, n.entropyEnc || "hex"), s = r.toArray(n.nonce, n.nonceEnc || "hex"), u = r.toArray(n.pers, n.persEnc || "hex"); e(t.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(t, s, u); }
                E.exports = c, c.prototype._init = function (n, t, s) { var u = n.concat(t).concat(s); this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8); for (var i = 0; i < this.V.length; i++)
                    this.K[i] = 0, this.V[i] = 1; this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656; }, c.prototype._hmac = function () { return new d.hmac(this.hash, this.K); }, c.prototype._update = function (n) { var t = this._hmac().update(this.V).update([0]); n && (t = t.update(n)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), n && (this.K = this._hmac().update(this.V).update([1]).update(n).digest(), this.V = this._hmac().update(this.V).digest()); }, c.prototype.reseed = function (n, t, s, u) { typeof t != "string" && (u = s, s = t, t = null), n = r.toArray(n, t), s = r.toArray(s, u), e(n.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(n.concat(s || [])), this._reseed = 1; }, c.prototype.generate = function (n, t, s, u) { if (this._reseed > this.reseedInterval)
                    throw new Error("Reseed is required"); typeof t != "string" && (u = s, s = t, t = null), s && (s = r.toArray(s, u || "hex"), this._update(s)); for (var i = []; i.length < n;)
                    this.V = this._hmac().update(this.V).digest(), i = i.concat(this.V); var o = i.slice(0, n); return this._update(s), this._reseed++, r.encode(o, t); };
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(33).assert;
                function e(c, n) { this.ec = c, this.priv = null, this.pub = null, n.priv && this._importPrivate(n.priv, n.privEnc), n.pub && this._importPublic(n.pub, n.pubEnc); }
                E.exports = e, e.fromPublic = function (c, n, t) { return n instanceof e ? n : new e(c, { pub: n, pubEnc: t }); }, e.fromPrivate = function (c, n, t) { return n instanceof e ? n : new e(c, { priv: n, privEnc: t }); }, e.prototype.validate = function () { var c = this.getPublic(); return c.isInfinity() ? { result: !1, reason: "Invalid public key" } : c.validate() ? c.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" }; }, e.prototype.getPublic = function (c, n) { return typeof c == "string" && (n = c, c = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, c) : this.pub; }, e.prototype.getPrivate = function (c) { return c === "hex" ? this.priv.toString(16, 2) : this.priv; }, e.prototype._importPrivate = function (c, n) { this.priv = new d(c, n || 16), this.priv = this.priv.umod(this.ec.curve.n); }, e.prototype._importPublic = function (c, n) { if (c.x || c.y)
                    return this.ec.curve.type === "mont" ? r(c.x, "Need x coordinate") : this.ec.curve.type !== "short" && this.ec.curve.type !== "edwards" || r(c.x && c.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(c.x, c.y)); this.pub = this.ec.curve.decodePoint(c, n); }, e.prototype.derive = function (c) { return c.mul(this.priv).getX(); }, e.prototype.sign = function (c, n, t) { return this.ec.sign(c, this, n, t); }, e.prototype.verify = function (c, n) { return this.ec.verify(c, n, this); }, e.prototype.inspect = function () { return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >"; };
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(33), e = r.assert;
                function c(i, o) { if (i instanceof c)
                    return i; this._importDER(i, o) || (e(i.r && i.s, "Signature without r or s"), this.r = new d(i.r, 16), this.s = new d(i.s, 16), i.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = i.recoveryParam); }
                function n() { this.place = 0; }
                function t(i, o) { var h = i[o.place++]; if (!(128 & h))
                    return h; var a = 15 & h; if (a === 0 || a > 4)
                    return !1; for (var l = 0, p = 0, g = o.place; p < a; p++, g++)
                    l <<= 8, l |= i[g], l >>>= 0; return !(l <= 127) && (o.place = g, l); }
                function s(i) { for (var o = 0, h = i.length - 1; !i[o] && !(128 & i[o + 1]) && o < h;)
                    o++; return o === 0 ? i : i.slice(o); }
                function u(i, o) { if (o < 128)
                    i.push(o);
                else {
                    var h = 1 + (Math.log(o) / Math.LN2 >>> 3);
                    for (i.push(128 | h); --h;)
                        i.push(o >>> (h << 3) & 255);
                    i.push(o);
                } }
                E.exports = c, c.prototype._importDER = function (i, o) { i = r.toArray(i, o); var h = new n; if (i[h.place++] !== 48)
                    return !1; var a = t(i, h); if (a === !1)
                    return !1; if (a + h.place !== i.length)
                    return !1; if (i[h.place++] !== 2)
                    return !1; var l = t(i, h); if (l === !1)
                    return !1; var p = i.slice(h.place, l + h.place); if (h.place += l, i[h.place++] !== 2)
                    return !1; var g = t(i, h); if (g === !1)
                    return !1; if (i.length !== g + h.place)
                    return !1; var b = i.slice(h.place, g + h.place); if (p[0] === 0) {
                    if (!(128 & p[1]))
                        return !1;
                    p = p.slice(1);
                } if (b[0] === 0) {
                    if (!(128 & b[1]))
                        return !1;
                    b = b.slice(1);
                } return this.r = new d(p), this.s = new d(b), this.recoveryParam = null, !0; }, c.prototype.toDER = function (i) { var o = this.r.toArray(), h = this.s.toArray(); for (128 & o[0] && (o = [0].concat(o)), 128 & h[0] && (h = [0].concat(h)), o = s(o), h = s(h); !(h[0] || 128 & h[1]);)
                    h = h.slice(1); var a = [2]; u(a, o.length), (a = a.concat(o)).push(2), u(a, h.length); var l = a.concat(h), p = [48]; return u(p, l.length), p = p.concat(l), r.encode(p, i); };
            }, function (E, m, f) {
                "use strict";
                var d = f(150), r = f(149), e = f(33), c = e.assert, n = e.parseBytes, t = f(489), s = f(490);
                function u(i) { if (c(i === "ed25519", "only tested with ed25519 so far"), !(this instanceof u))
                    return new u(i); i = r[i].curve, this.curve = i, this.g = i.g, this.g.precompute(i.n.bitLength() + 1), this.pointClass = i.point().constructor, this.encodingLength = Math.ceil(i.n.bitLength() / 8), this.hash = d.sha512; }
                E.exports = u, u.prototype.sign = function (i, o) { i = n(i); var h = this.keyFromSecret(o), a = this.hashInt(h.messagePrefix(), i), l = this.g.mul(a), p = this.encodePoint(l), g = this.hashInt(p, h.pubBytes(), i).mul(h.priv()), b = a.add(g).umod(this.curve.n); return this.makeSignature({ R: l, S: b, Rencoded: p }); }, u.prototype.verify = function (i, o, h) { i = n(i), o = this.makeSignature(o); var a = this.keyFromPublic(h), l = this.hashInt(o.Rencoded(), a.pubBytes(), i), p = this.g.mul(o.S()); return o.R().add(a.pub().mul(l)).eq(p); }, u.prototype.hashInt = function () { for (var i = this.hash(), o = 0; o < arguments.length; o++)
                    i.update(arguments[o]); return e.intFromLE(i.digest()).umod(this.curve.n); }, u.prototype.keyFromPublic = function (i) { return t.fromPublic(this, i); }, u.prototype.keyFromSecret = function (i) { return t.fromSecret(this, i); }, u.prototype.makeSignature = function (i) { return i instanceof s ? i : new s(this, i); }, u.prototype.encodePoint = function (i) { var o = i.getY().toArray("le", this.encodingLength); return o[this.encodingLength - 1] |= i.getX().isOdd() ? 128 : 0, o; }, u.prototype.decodePoint = function (i) { var o = (i = e.parseBytes(i)).length - 1, h = i.slice(0, o).concat(-129 & i[o]), a = (128 & i[o]) != 0, l = e.intFromLE(h); return this.curve.pointFromY(l, a); }, u.prototype.encodeInt = function (i) { return i.toArray("le", this.encodingLength); }, u.prototype.decodeInt = function (i) { return e.intFromLE(i); }, u.prototype.isPoint = function (i) { return i instanceof this.pointClass; };
            }, function (E, m, f) {
                "use strict";
                var d = f(33), r = d.assert, e = d.parseBytes, c = d.cachedProperty;
                function n(t, s) { this.eddsa = t, this._secret = e(s.secret), t.isPoint(s.pub) ? this._pub = s.pub : this._pubBytes = e(s.pub); }
                n.fromPublic = function (t, s) { return s instanceof n ? s : new n(t, { pub: s }); }, n.fromSecret = function (t, s) { return s instanceof n ? s : new n(t, { secret: s }); }, n.prototype.secret = function () { return this._secret; }, c(n, "pubBytes", function () { return this.eddsa.encodePoint(this.pub()); }), c(n, "pub", function () { return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv()); }), c(n, "privBytes", function () { var t = this.eddsa, s = this.hash(), u = t.encodingLength - 1, i = s.slice(0, t.encodingLength); return i[0] &= 248, i[u] &= 127, i[u] |= 64, i; }), c(n, "priv", function () { return this.eddsa.decodeInt(this.privBytes()); }), c(n, "hash", function () { return this.eddsa.hash().update(this.secret()).digest(); }), c(n, "messagePrefix", function () { return this.hash().slice(this.eddsa.encodingLength); }), n.prototype.sign = function (t) { return r(this._secret, "KeyPair can only verify"), this.eddsa.sign(t, this); }, n.prototype.verify = function (t, s) { return this.eddsa.verify(t, s, this); }, n.prototype.getSecret = function (t) { return r(this._secret, "KeyPair is public only"), d.encode(this.secret(), t); }, n.prototype.getPublic = function (t) { return d.encode(this.pubBytes(), t); }, E.exports = n;
            }, function (E, m, f) {
                "use strict";
                var d = f(38), r = f(33), e = r.assert, c = r.cachedProperty, n = r.parseBytes;
                function t(s, u) { this.eddsa = s, typeof u != "object" && (u = n(u)), Array.isArray(u) && (u = { R: u.slice(0, s.encodingLength), S: u.slice(s.encodingLength) }), e(u.R && u.S, "Signature without R or S"), s.isPoint(u.R) && (this._R = u.R), u.S instanceof d && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded; }
                c(t, "S", function () { return this.eddsa.decodeInt(this.Sencoded()); }), c(t, "R", function () { return this.eddsa.decodePoint(this.Rencoded()); }), c(t, "Rencoded", function () { return this.eddsa.encodePoint(this.R()); }), c(t, "Sencoded", function () { return this.eddsa.encodeInt(this.S()); }), t.prototype.toBytes = function () { return this.Rencoded().concat(this.Sencoded()); }, t.prototype.toHex = function () { return r.encode(this.toBytes(), "hex").toUpperCase(); }, E.exports = t;
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(31), e = f(6), c = f(239), n = { "AES-128": { ivSize: 16, keySize: 16 }, "AES-256": { ivSize: 16, keySize: 32 }, Blowfish: { ivSize: 8, cipherKeySize: 32 } };
                E.exports = async (t, s, u) => { const i = n[t]; if (!i) {
                    const M = Object.keys(n).join(" / ");
                    throw d(new Error(`unknown cipher type '${t}'. Must be ${M}`), "ERR_INVALID_CIPHER_TYPE");
                } if (!s)
                    throw d(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE"); const o = i.keySize, h = i.ivSize, a = e("key expansion"), l = 2 * (h + o + 20), p = await c.create(s, u); let g = await p.digest(a); const b = []; let I = 0; for (; I < l;) {
                    const M = await p.digest(r([g, a]));
                    let N = M.length;
                    I + N > l && (N = l - I), b.push(M), I += N, g = await p.digest(g);
                } const v = l / 2, R = r(b), _ = R.slice(0, v), k = R.slice(v, l), x = M => ({ iv: M.slice(0, h), cipherKey: M.slice(h, h + o), macKey: M.slice(h + o) }); return { k1: x(_), k2: x(k) }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = { SHA1: 20, SHA256: 32, SHA512: 64 };
            }, function (E, m, f) {
                "use strict";
                const d = f(494);
                E.exports = async (r) => d.generateEphmeralKeyPair(r);
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(105), { base64urlToBuffer: e } = f(147), c = f(495), n = f(5), t = f(31), s = f(20), u = { "P-256": 256, "P-384": 384, "P-521": 521 };
                m.generateEphmeralKeyPair = async function (l) { c(Object.keys(u), l); const p = await r.get().subtle.generateKey({ name: "ECDH", namedCurve: l }, !0, ["deriveBits"]); return { key: o(await r.get().subtle.exportKey("jwk", p.publicKey)), genSharedKey: async (g, b) => { let I; I = b ? await r.get().subtle.importKey("jwk", a(l, b), { name: "ECDH", namedCurve: l }, !1, ["deriveBits"]) : p.privateKey; const v = [await r.get().subtle.importKey("jwk", h(l, g), { name: "ECDH", namedCurve: l }, !1, []), I], R = await r.get().subtle.deriveBits({ name: "ECDH", namedCurve: l, public: v[0] }, v[1], u[l]); return new Uint8Array(R, R.byteOffset, R.byteLength); } }; };
                const i = { "P-256": 32, "P-384": 48, "P-521": 66 };
                function o(l) { const p = i[l.crv]; return t([Uint8Array.from([4]), e(l.x, p), e(l.y, p)], 1 + 2 * p); }
                function h(l, p) { const g = i[l]; if (s(!p.slice(0, 1), Uint8Array.from([4])))
                    throw d(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT"); return { kty: "EC", crv: l, x: n(p.slice(1, g + 1), "base64url"), y: n(p.slice(1 + g), "base64url"), ext: !0 }; }
                const a = (l, p) => ({ ...h(l, p.public), d: n(p.private, "base64url") });
            }, function (E, m, f) {
                "use strict";
                const d = f(0);
                E.exports = function (r, e) { if (!r.includes(e)) {
                    const c = r.join(" / ");
                    throw d(new Error(`Unknown curve: ${e}. Must be ${c}`), "ERR_INVALID_CURVE");
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`

message PeerIdProto {
  required bytes id = 1;
  bytes pubKey = 2;
  bytes privKey = 3;
}

`);
            }, function (E, m, f) {
                "use strict";
                const d = f(498), r = f(499);
                m.create = async function (e, c) { const n = r(e), t = d.createCipheriv(n, e, c), s = d.createDecipheriv(n, e, c); return { encrypt: async (u) => t.update(u), decrypt: async (u) => s.update(u) }; };
            }, function (E, m, f) {
                "use strict";
                f(83);
                const d = f(8), r = f(5), e = f(6);
                E.exports = { createCipheriv: (c, n, t) => { const s = d.cipher.createCipher("AES-CTR", r(n, "ascii")); return s.start({ iv: r(t, "ascii") }), { update: u => (s.update(d.util.createBuffer(r(u, "ascii"))), e(s.output.getBytes(), "ascii")) }; }, createDecipheriv: (c, n, t) => { const s = d.cipher.createDecipher("AES-CTR", r(n, "ascii")); return s.start({ iv: r(t, "ascii") }), { update: u => (s.update(d.util.createBuffer(r(u, "ascii"))), e(s.output.getBytes(), "ascii")) }; } };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = { 16: "aes-128-ctr", 32: "aes-256-ctr" };
                E.exports = function (e) { const c = r[e.length]; if (!c) {
                    const n = Object.entries(r).map(([t, s]) => `${t} (${s})`).join(" / ");
                    throw d(new Error(`Invalid key length ${e.length} bytes. Must be ${n}`), "ERR_INVALID_KEY_LENGTH");
                } return c; };
            }, function (E, m, f) {
                "use strict";
                const d = f(230), r = f(14), e = f(0), c = { sha1: "sha1", "sha2-256": "sha256", "sha2-512": "sha512" };
                E.exports = function (n, t, s, u, i) { const o = c[i]; if (!o) {
                    const a = Object.keys(c).join(" / ");
                    throw e(new Error(`Hash '${i}' is unknown or not supported. Must be ${a}`), "ERR_UNSUPPORTED_HASH_TYPE");
                } const h = d(n, t, s, u, o); return r.encode64(h); };
            }, function (E, m, f) {
                "use strict";
                const d = f(502), r = f(109), e = f(19), c = f(31), n = f(5);
                function t(R) { const _ = [], k = R.split("/").slice(1); if (k.length === 1 && k[0] === "")
                    return []; for (let x = 0; x < k.length; x++) {
                    const M = k[x], N = r(M);
                    if (N.size !== 0) {
                        if (x++, x >= k.length)
                            throw I("invalid address: " + R);
                        if (N.path) {
                            _.push([M, b(k.slice(x).join("/"))]);
                            break;
                        }
                        _.push([M, k[x]]);
                    }
                    else
                        _.push([M]);
                } return _; }
                function s(R) { const _ = []; return R.map(k => { const x = v(k); _.push(x.name), k.length > 1 && _.push(k[1]); }), b(_.join("/")); }
                function u(R) { return R.map(_ => { Array.isArray(_) || (_ = [_]); const k = v(_); return _.length > 1 ? [k.code, d.toBytes(k.code, _[1])] : [k.code]; }); }
                function i(R) { return R.map(_ => { const k = v(_); return _.length > 1 ? [k.code, d.toString(k.code, _[1])] : [k.code]; }); }
                function o(R) { return p(c(R.map(_ => { const k = v(_); let x = Uint8Array.from(e.encode(k.code)); return _.length > 1 && (x = c([x, _[1]])), x; }))); }
                function h(R, _) { return R.size > 0 ? R.size / 8 : R.size === 0 ? 0 : e.decode(_) + e.decode.bytes; }
                function a(R) { const _ = []; let k = 0; for (; k < R.length;) {
                    const x = e.decode(R, k), M = e.decode.bytes, N = h(r(x), R.slice(k + M));
                    if (N === 0) {
                        _.push([x]), k += M;
                        continue;
                    }
                    const S = R.slice(k + M, k + M + N);
                    if (k += N + M, k > R.length)
                        throw I("Invalid address Uint8Array: " + n(R, "base16"));
                    _.push([x, S]);
                } return _; }
                function l(R) { return o(u(t(R = b(R)))); }
                function p(R) { const _ = g(R); if (_)
                    throw _; return Uint8Array.from(R); }
                function g(R) { try {
                    a(R);
                }
                catch (_) {
                    return _;
                } }
                function b(R) { return "/" + R.trim().split("/").filter(_ => _).join("/"); }
                function I(R) { return new Error("Error parsing address: " + R); }
                function v(R) { return r(R[0]); }
                E.exports = { stringToStringTuples: t, stringTuplesToString: s, tuplesToStringTuples: i, stringTuplesToTuples: u, bytesToTuples: a, tuplesToBytes: o, bytesToString: function (R) { const _ = a(R); return s(i(_)); }, stringToBytes: l, fromString: function (R) { return l(R); }, fromBytes: p, validateBytes: g, isValidBytes: function (R) { return g(R) === void 0; }, cleanPath: b, ParseError: I, protoFromTuple: v, sizeForAddr: h };
            }, function (E, m, f) {
                "use strict";
                const d = f(503), r = f(109), e = f(4), c = f(25), n = f(19), t = f(5), s = f(6), u = f(31);
                function i(p, g) { return g instanceof Uint8Array ? i.toString(p, g) : i.toBytes(p, g); }
                function o(p) { if (!d.isIP(p))
                    throw new Error("invalid ip address"); return d.toBytes(p); }
                function h(p) { const g = new ArrayBuffer(2); return new DataView(g).setUint16(0, p), new Uint8Array(g); }
                function a(p) { return new DataView(p.buffer).getUint16(0); }
                function l(p) { const g = p.slice(0, p.length - 2), b = p.slice(p.length - 2); return t(g, "base32") + ":" + a(b); }
                E.exports = i, i.toString = function (p, g) { switch ((p = r(p)).code) {
                    case 4:
                    case 41: return function (b) { const I = d.toString(b); if (!I || !d.isIP(I))
                        throw new Error("invalid ip address"); return I; }(g);
                    case 6:
                    case 273:
                    case 33:
                    case 132: return a(g);
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 400:
                    case 777: return function (b) { const I = n.decode(b); if ((b = b.slice(n.decode.bytes)).length !== I)
                        throw new Error("inconsistent lengths"); return t(b); }(g);
                    case 421: return function (b) { const I = n.decode(b), v = b.slice(n.decode.bytes); if (v.length !== I)
                        throw new Error("inconsistent lengths"); return t(v, "base58btc"); }(g);
                    case 444:
                    case 445: return l(g);
                    default: return t(g, "base16");
                } }, i.toBytes = function (p, g) { switch ((p = r(p)).code) {
                    case 4:
                    case 41: return o(g);
                    case 6:
                    case 273:
                    case 33:
                    case 132: return h(parseInt(g, 10));
                    case 53:
                    case 54:
                    case 55:
                    case 56:
                    case 400:
                    case 777: return function (b) { const I = s(b), v = Uint8Array.from(n.encode(I.length)); return u([v, I], v.length + I.length); }(g);
                    case 421: return function (b) { const I = new e(b).multihash, v = Uint8Array.from(n.encode(I.length)); return u([v, I], v.length + I.length); }(g);
                    case 444: return function (b) { const I = b.split(":"); if (I.length !== 2)
                        throw new Error("failed to parse onion addr: " + I + " does not contain a port number"); if (I[0].length !== 16)
                        throw new Error("failed to parse onion addr: " + I[0] + " not a Tor onion address."); const v = c.decode("b" + I[0]), R = parseInt(I[1], 10); if (R < 1 || R > 65536)
                        throw new Error("Port number is not in range(1, 65536)"); const _ = h(R); return u([v, _], v.length + _.length); }(g);
                    case 445: return function (b) { const I = b.split(":"); if (I.length !== 2)
                        throw new Error("failed to parse onion addr: " + I + " does not contain a port number"); if (I[0].length !== 56)
                        throw new Error("failed to parse onion addr: " + I[0] + " not a Tor onion3 address."); const v = c.decode("b" + I[0]), R = parseInt(I[1], 10); if (R < 1 || R > 65536)
                        throw new Error("Port number is not in range(1, 65536)"); const _ = h(R); return u([v, _], v.length + _.length); }(g);
                    default: return s(g, "base16");
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(504), r = f(5), e = d, c = d.v4, n = d.v6, t = function (s, u, i) { var o; if (i = ~~i, c(s))
                    o = u || new Uint8Array(i + 4), s.split(/\./g).map(function (b) { o[i++] = 255 & parseInt(b, 10); });
                else if (n(s)) {
                    var h, a = s.split(":", 8);
                    for (h = 0; h < a.length; h++) {
                        var l;
                        c(a[h]) && (l = t(a[h]), a[h] = r(l.slice(0, 2), "base16")), l && ++h < 8 && a.splice(h, 0, r(l.slice(2, 4), "base16"));
                    }
                    if (a[0] === "")
                        for (; a.length < 8;)
                            a.unshift("0");
                    else if (a[a.length - 1] === "")
                        for (; a.length < 8;)
                            a.push("0");
                    else if (a.length < 8) {
                        for (h = 0; h < a.length && a[h] !== ""; h++)
                            ;
                        var p = [h, "1"];
                        for (h = 9 - a.length; h > 0; h--)
                            p.push("0");
                        a.splice.apply(a, p);
                    }
                    for (o = u || new Uint8Array(i + 16), h = 0; h < a.length; h++) {
                        var g = parseInt(a[h], 16);
                        o[i++] = g >> 8 & 255, o[i++] = 255 & g;
                    }
                } if (!o)
                    throw Error("Invalid ip address: " + s); return o; };
                E.exports = { isIP: e, isV4: c, isV6: n, toBytes: t, toString: function (s, u, i) { u = ~~u, i = i || s.length - u; var o, h = []; const a = new DataView(s.buffer); if (i === 4) {
                        for (let l = 0; l < i; l++)
                            h.push(s[u + l]);
                        o = h.join(".");
                    }
                    else if (i === 16) {
                        for (let l = 0; l < i; l += 2)
                            h.push(a.getUint16(u + l).toString(16));
                        o = (o = (o = h.join(":")).replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3")).replace(/:{3,4}/, "::");
                    } return o; } };
            }, function (E, m, f) {
                "use strict";
                const d = f(505), r = e => d({ exact: !0 }).test(e);
                r.v4 = e => d.v4({ exact: !0 }).test(e), r.v6 = e => d.v6({ exact: !0 }).test(e), r.version = e => r(e) ? r.v4(e) ? 4 : 6 : void 0, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                const d = i => i && i.includeBoundaries ? "(?:(?<=\\s|^)(?=[a-fA-F\\d:])|(?<=[a-fA-F\\d:])(?=\\s|$))" : "", r = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", e = "[a-fA-F\\d]{1,4}", c = `
(
(?:${e}:){7}(?:${e}|:)|                                // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${e}:){6}(?:${r}|:${e}|:)|                         // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${e}:){5}(?::${r}|(:${e}){1,2}|:)|                 // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${e}:){4}(?:(:${e}){0,1}:${r}|(:${e}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${e}:){3}(?:(:${e}){0,2}:${r}|(:${e}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${e}:){2}(?:(:${e}){0,3}:${r}|(:${e}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${e}:){1}(?:(:${e}){0,4}:${r}|(:${e}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::((?::${e}){0,5}:${r}|(?::${e}){1,7}|:))           // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(%[0-9a-zA-Z]{1,})?                                           // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), n = new RegExp(`(?:^${r}$)|(?:^${c}$)`), t = new RegExp(`^${r}$`), s = new RegExp(`^${c}$`), u = i => i && i.exact ? n : new RegExp(`(?:${d(i)}${r}${d(i)})|(?:${d(i)}${c}${d(i)})`, "g");
                u.v4 = i => i && i.exact ? t : new RegExp(`${d(i)}${r}${d(i)}`, "g"), u.v6 = i => i && i.exact ? s : new RegExp(`${d(i)}${c}${d(i)}`, "g"), E.exports = u;
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r, URLSearchParams: e, defaultBase: c } = f(240), n = f(507);
                E.exports = { URL: d, URLSearchParams: e, format: r, relative: n, defaultBase: c };
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r } = f(240);
                E.exports = (e, c = {}, n = {}, t) => { let s, u = c.protocol ? c.protocol.replace(":", "") : "http"; u = (n[u] || t || u) + ":"; try {
                    s = new d(e);
                }
                catch (o) {
                    s = {};
                } const i = Object.assign({}, c, { protocol: u || s.protocol, host: c.host || s.host }); return new d(e, r(i)).toString(); };
            }, function (E, m, f) {
                "use strict";
                const d = f(509), r = f(511), { factory: e } = f(84), { fromNumberTo32BitBuf: c } = f(513), n = f(6), t = s => async (u) => { switch (s) {
                    case "sha3-224": return new Uint8Array(d.sha3_224.arrayBuffer(u));
                    case "sha3-256": return new Uint8Array(d.sha3_256.arrayBuffer(u));
                    case "sha3-384": return new Uint8Array(d.sha3_384.arrayBuffer(u));
                    case "sha3-512": return new Uint8Array(d.sha3_512.arrayBuffer(u));
                    case "shake-128": return new Uint8Array(d.shake128.create(128).update(u).arrayBuffer());
                    case "shake-256": return new Uint8Array(d.shake256.create(256).update(u).arrayBuffer());
                    case "keccak-224": return new Uint8Array(d.keccak224.arrayBuffer(u));
                    case "keccak-256": return new Uint8Array(d.keccak256.arrayBuffer(u));
                    case "keccak-384": return new Uint8Array(d.keccak384.arrayBuffer(u));
                    case "keccak-512": return new Uint8Array(d.keccak512.arrayBuffer(u));
                    case "murmur3-128": return n(r.x64.hash128(u), "base16");
                    case "murmur3-32": return c(r.x86.hash32(u));
                    default: throw new TypeError(s + " is not a supported algorithm");
                } };
                E.exports = { identity: s => s, sha1: e("sha1"), sha2256: e("sha2-256"), sha2512: e("sha2-512"), dblSha2256: e("dbl-sha2-256"), sha3224: t("sha3-224"), sha3256: t("sha3-256"), sha3384: t("sha3-384"), sha3512: t("sha3-512"), shake128: t("shake-128"), shake256: t("shake-256"), keccak224: t("keccak-224"), keccak256: t("keccak-256"), keccak384: t("keccak-384"), keccak512: t("keccak-512"), murmur3128: t("murmur3-128"), murmur332: t("murmur3-32"), addBlake: f(514) };
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e; !function () { var c = "input is invalid type", n = typeof window == "object", t = n ? window : {}; t.JS_SHA3_NO_WINDOW && (n = !1); var s = !n && typeof self == "object"; !t.JS_SHA3_NO_NODE_JS && typeof d == "object" && d.versions && d.versions.node ? t = r : s && (t = self); var u = !t.JS_SHA3_NO_COMMON_JS && typeof E == "object" && E.exports, i = f(510), o = !t.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", h = "0123456789abcdef".split(""), a = [4, 1024, 262144, 67108864], l = [0, 8, 16, 24], p = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], g = [224, 256, 384, 512], b = [128, 256], I = ["hex", "buffer", "arrayBuffer", "array", "digest"], v = { 128: 168, 256: 136 }; !t.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function (F) { return Object.prototype.toString.call(F) === "[object Array]"; }), !o || !t.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function (F) { return typeof F == "object" && F.buffer && F.buffer.constructor === ArrayBuffer; }); for (var R = function (F, Y, $) { return function (y) { return new X(F, Y, F).update(y)[$](); }; }, _ = function (F, Y, $) { return function (y, C) { return new X(F, Y, C).update(y)[$](); }; }, k = function (F, Y, $) { return function (y, C, A, U) { return T["cshake" + F].update(y, C, A, U)[$](); }; }, x = function (F, Y, $) { return function (y, C, A, U) { return T["kmac" + F].update(y, C, A, U)[$](); }; }, M = function (F, Y, $, y) { for (var C = 0; C < I.length; ++C) {
                    var A = I[C];
                    F[A] = Y($, y, A);
                } return F; }, N = function (F, Y) { var $ = R(F, Y, "hex"); return $.create = function () { return new X(F, Y, F); }, $.update = function (y) { return $.create().update(y); }, M($, R, F, Y); }, S = [{ name: "keccak", padding: [1, 256, 65536, 16777216], bits: g, createMethod: N }, { name: "sha3", padding: [6, 1536, 393216, 100663296], bits: g, createMethod: N }, { name: "shake", padding: [31, 7936, 2031616, 520093696], bits: b, createMethod: function (F, Y) { var $ = _(F, Y, "hex"); return $.create = function (y) { return new X(F, Y, y); }, $.update = function (y, C) { return $.create(C).update(y); }, M($, _, F, Y); } }, { name: "cshake", padding: a, bits: b, createMethod: function (F, Y) { var $ = v[F], y = k(F, 0, "hex"); return y.create = function (C, A, U) { return A || U ? new X(F, Y, C).bytepad([A, U], $) : T["shake" + F].create(C); }, y.update = function (C, A, U, z) { return y.create(A, U, z).update(C); }, M(y, k, F, Y); } }, { name: "kmac", padding: a, bits: b, createMethod: function (F, Y) { var $ = v[F], y = x(F, 0, "hex"); return y.create = function (C, A, U) { return new Q(F, Y, A).bytepad(["KMAC", U], $).bytepad([C], $); }, y.update = function (C, A, U, z) { return y.create(C, U, z).update(A); }, M(y, x, F, Y); } }], T = {}, B = [], P = 0; P < S.length; ++P)
                    for (var L = S[P], j = L.bits, D = 0; D < j.length; ++D) {
                        var G = L.name + "_" + j[D];
                        if (B.push(G), T[G] = L.createMethod(j[D], L.padding), L.name !== "sha3") {
                            var W = L.name + j[D];
                            B.push(W), T[W] = T[G];
                        }
                    } function X(F, Y, $) { this.blocks = [], this.s = [], this.padding = Y, this.outputBits = $, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (F << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = $ >> 5, this.extraBytes = (31 & $) >> 3; for (var y = 0; y < 50; ++y)
                    this.s[y] = 0; } function Q(F, Y, $) { X.call(this, F, Y, $); } X.prototype.update = function (F) { if (this.finalized)
                    throw new Error("finalize already called"); var Y, $ = typeof F; if ($ !== "string") {
                    if ($ !== "object")
                        throw new Error(c);
                    if (F === null)
                        throw new Error(c);
                    if (o && F.constructor === ArrayBuffer)
                        F = new Uint8Array(F);
                    else if (!(Array.isArray(F) || o && ArrayBuffer.isView(F)))
                        throw new Error(c);
                    Y = !0;
                } for (var y, C, A = this.blocks, U = this.byteCount, z = F.length, w = this.blockCount, O = 0, q = this.s; O < z;) {
                    if (this.reset)
                        for (this.reset = !1, A[0] = this.block, y = 1; y < w + 1; ++y)
                            A[y] = 0;
                    if (Y)
                        for (y = this.start; O < z && y < U; ++O)
                            A[y >> 2] |= F[O] << l[3 & y++];
                    else
                        for (y = this.start; O < z && y < U; ++O)
                            (C = F.charCodeAt(O)) < 128 ? A[y >> 2] |= C << l[3 & y++] : C < 2048 ? (A[y >> 2] |= (192 | C >> 6) << l[3 & y++], A[y >> 2] |= (128 | 63 & C) << l[3 & y++]) : C < 55296 || C >= 57344 ? (A[y >> 2] |= (224 | C >> 12) << l[3 & y++], A[y >> 2] |= (128 | C >> 6 & 63) << l[3 & y++], A[y >> 2] |= (128 | 63 & C) << l[3 & y++]) : (C = 65536 + ((1023 & C) << 10 | 1023 & F.charCodeAt(++O)), A[y >> 2] |= (240 | C >> 18) << l[3 & y++], A[y >> 2] |= (128 | C >> 12 & 63) << l[3 & y++], A[y >> 2] |= (128 | C >> 6 & 63) << l[3 & y++], A[y >> 2] |= (128 | 63 & C) << l[3 & y++]);
                    if (this.lastByteIndex = y, y >= U) {
                        for (this.start = y - U, this.block = A[w], y = 0; y < w; ++y)
                            q[y] ^= A[y];
                        K(q), this.reset = !0;
                    }
                    else
                        this.start = y;
                } return this; }, X.prototype.encode = function (F, Y) { var $ = 255 & F, y = 1, C = [$]; for ($ = 255 & (F >>= 8); $ > 0;)
                    C.unshift($), $ = 255 & (F >>= 8), ++y; return Y ? C.push(y) : C.unshift(y), this.update(C), C.length; }, X.prototype.encodeString = function (F) { var Y, $ = typeof F; if ($ !== "string") {
                    if ($ !== "object")
                        throw new Error(c);
                    if (F === null)
                        throw new Error(c);
                    if (o && F.constructor === ArrayBuffer)
                        F = new Uint8Array(F);
                    else if (!(Array.isArray(F) || o && ArrayBuffer.isView(F)))
                        throw new Error(c);
                    Y = !0;
                } var y = 0, C = F.length; if (Y)
                    y = C;
                else
                    for (var A = 0; A < F.length; ++A) {
                        var U = F.charCodeAt(A);
                        U < 128 ? y += 1 : U < 2048 ? y += 2 : U < 55296 || U >= 57344 ? y += 3 : (U = 65536 + ((1023 & U) << 10 | 1023 & F.charCodeAt(++A)), y += 4);
                    } return y += this.encode(8 * y), this.update(F), y; }, X.prototype.bytepad = function (F, Y) { for (var $ = this.encode(Y), y = 0; y < F.length; ++y)
                    $ += this.encodeString(F[y]); var C = Y - $ % Y, A = []; return A.length = C, this.update(A), this; }, X.prototype.finalize = function () { if (!this.finalized) {
                    this.finalized = !0;
                    var F = this.blocks, Y = this.lastByteIndex, $ = this.blockCount, y = this.s;
                    if (F[Y >> 2] |= this.padding[3 & Y], this.lastByteIndex === this.byteCount)
                        for (F[0] = F[$], Y = 1; Y < $ + 1; ++Y)
                            F[Y] = 0;
                    for (F[$ - 1] |= 2147483648, Y = 0; Y < $; ++Y)
                        y[Y] ^= F[Y];
                    K(y);
                } }, X.prototype.toString = X.prototype.hex = function () { this.finalize(); for (var F, Y = this.blockCount, $ = this.s, y = this.outputBlocks, C = this.extraBytes, A = 0, U = 0, z = ""; U < y;) {
                    for (A = 0; A < Y && U < y; ++A, ++U)
                        F = $[A], z += h[F >> 4 & 15] + h[15 & F] + h[F >> 12 & 15] + h[F >> 8 & 15] + h[F >> 20 & 15] + h[F >> 16 & 15] + h[F >> 28 & 15] + h[F >> 24 & 15];
                    U % Y == 0 && (K($), A = 0);
                } return C && (F = $[A], z += h[F >> 4 & 15] + h[15 & F], C > 1 && (z += h[F >> 12 & 15] + h[F >> 8 & 15]), C > 2 && (z += h[F >> 20 & 15] + h[F >> 16 & 15])), z; }, X.prototype.arrayBuffer = function () { this.finalize(); var F, Y = this.blockCount, $ = this.s, y = this.outputBlocks, C = this.extraBytes, A = 0, U = 0, z = this.outputBits >> 3; F = C ? new ArrayBuffer(y + 1 << 2) : new ArrayBuffer(z); for (var w = new Uint32Array(F); U < y;) {
                    for (A = 0; A < Y && U < y; ++A, ++U)
                        w[U] = $[A];
                    U % Y == 0 && K($);
                } return C && (w[A] = $[A], F = F.slice(0, z)), F; }, X.prototype.buffer = X.prototype.arrayBuffer, X.prototype.digest = X.prototype.array = function () { this.finalize(); for (var F, Y, $ = this.blockCount, y = this.s, C = this.outputBlocks, A = this.extraBytes, U = 0, z = 0, w = []; z < C;) {
                    for (U = 0; U < $ && z < C; ++U, ++z)
                        F = z << 2, Y = y[U], w[F] = 255 & Y, w[F + 1] = Y >> 8 & 255, w[F + 2] = Y >> 16 & 255, w[F + 3] = Y >> 24 & 255;
                    z % $ == 0 && K(y);
                } return A && (F = z << 2, Y = y[U], w[F] = 255 & Y, A > 1 && (w[F + 1] = Y >> 8 & 255), A > 2 && (w[F + 2] = Y >> 16 & 255)), w; }, Q.prototype = new X, Q.prototype.finalize = function () { return this.encode(this.outputBits, !0), X.prototype.finalize.call(this); }; var K = function (F) { var Y, $, y, C, A, U, z, w, O, q, H, V, J, Z, tt, nt, rt, it, st, at, ct, lt, pt, mt, Tt, vt, Rt, Bt, wt, kt, Wt, Ct, Ft, te, jt, Kt, re, St, Nt, ne, Vt, qt, ee, Ot, ft, gt, bt, _t, Lt, Pt, Mt, Yt, Dt, zt, he, Gt, Ut, de, Zt, Xt, ie, Qt, $t; for (y = 0; y < 48; y += 2)
                    C = F[0] ^ F[10] ^ F[20] ^ F[30] ^ F[40], A = F[1] ^ F[11] ^ F[21] ^ F[31] ^ F[41], U = F[2] ^ F[12] ^ F[22] ^ F[32] ^ F[42], z = F[3] ^ F[13] ^ F[23] ^ F[33] ^ F[43], w = F[4] ^ F[14] ^ F[24] ^ F[34] ^ F[44], O = F[5] ^ F[15] ^ F[25] ^ F[35] ^ F[45], q = F[6] ^ F[16] ^ F[26] ^ F[36] ^ F[46], H = F[7] ^ F[17] ^ F[27] ^ F[37] ^ F[47], Y = (V = F[8] ^ F[18] ^ F[28] ^ F[38] ^ F[48]) ^ (U << 1 | z >>> 31), $ = (J = F[9] ^ F[19] ^ F[29] ^ F[39] ^ F[49]) ^ (z << 1 | U >>> 31), F[0] ^= Y, F[1] ^= $, F[10] ^= Y, F[11] ^= $, F[20] ^= Y, F[21] ^= $, F[30] ^= Y, F[31] ^= $, F[40] ^= Y, F[41] ^= $, Y = C ^ (w << 1 | O >>> 31), $ = A ^ (O << 1 | w >>> 31), F[2] ^= Y, F[3] ^= $, F[12] ^= Y, F[13] ^= $, F[22] ^= Y, F[23] ^= $, F[32] ^= Y, F[33] ^= $, F[42] ^= Y, F[43] ^= $, Y = U ^ (q << 1 | H >>> 31), $ = z ^ (H << 1 | q >>> 31), F[4] ^= Y, F[5] ^= $, F[14] ^= Y, F[15] ^= $, F[24] ^= Y, F[25] ^= $, F[34] ^= Y, F[35] ^= $, F[44] ^= Y, F[45] ^= $, Y = w ^ (V << 1 | J >>> 31), $ = O ^ (J << 1 | V >>> 31), F[6] ^= Y, F[7] ^= $, F[16] ^= Y, F[17] ^= $, F[26] ^= Y, F[27] ^= $, F[36] ^= Y, F[37] ^= $, F[46] ^= Y, F[47] ^= $, Y = q ^ (C << 1 | A >>> 31), $ = H ^ (A << 1 | C >>> 31), F[8] ^= Y, F[9] ^= $, F[18] ^= Y, F[19] ^= $, F[28] ^= Y, F[29] ^= $, F[38] ^= Y, F[39] ^= $, F[48] ^= Y, F[49] ^= $, Z = F[0], tt = F[1], gt = F[11] << 4 | F[10] >>> 28, bt = F[10] << 4 | F[11] >>> 28, Bt = F[20] << 3 | F[21] >>> 29, wt = F[21] << 3 | F[20] >>> 29, Xt = F[31] << 9 | F[30] >>> 23, ie = F[30] << 9 | F[31] >>> 23, qt = F[40] << 18 | F[41] >>> 14, ee = F[41] << 18 | F[40] >>> 14, te = F[2] << 1 | F[3] >>> 31, jt = F[3] << 1 | F[2] >>> 31, nt = F[13] << 12 | F[12] >>> 20, rt = F[12] << 12 | F[13] >>> 20, _t = F[22] << 10 | F[23] >>> 22, Lt = F[23] << 10 | F[22] >>> 22, kt = F[33] << 13 | F[32] >>> 19, Wt = F[32] << 13 | F[33] >>> 19, Qt = F[42] << 2 | F[43] >>> 30, $t = F[43] << 2 | F[42] >>> 30, zt = F[5] << 30 | F[4] >>> 2, he = F[4] << 30 | F[5] >>> 2, Kt = F[14] << 6 | F[15] >>> 26, re = F[15] << 6 | F[14] >>> 26, it = F[25] << 11 | F[24] >>> 21, st = F[24] << 11 | F[25] >>> 21, Pt = F[34] << 15 | F[35] >>> 17, Mt = F[35] << 15 | F[34] >>> 17, Ct = F[45] << 29 | F[44] >>> 3, Ft = F[44] << 29 | F[45] >>> 3, mt = F[6] << 28 | F[7] >>> 4, Tt = F[7] << 28 | F[6] >>> 4, Gt = F[17] << 23 | F[16] >>> 9, Ut = F[16] << 23 | F[17] >>> 9, St = F[26] << 25 | F[27] >>> 7, Nt = F[27] << 25 | F[26] >>> 7, at = F[36] << 21 | F[37] >>> 11, ct = F[37] << 21 | F[36] >>> 11, Yt = F[47] << 24 | F[46] >>> 8, Dt = F[46] << 24 | F[47] >>> 8, Ot = F[8] << 27 | F[9] >>> 5, ft = F[9] << 27 | F[8] >>> 5, vt = F[18] << 20 | F[19] >>> 12, Rt = F[19] << 20 | F[18] >>> 12, de = F[29] << 7 | F[28] >>> 25, Zt = F[28] << 7 | F[29] >>> 25, ne = F[38] << 8 | F[39] >>> 24, Vt = F[39] << 8 | F[38] >>> 24, lt = F[48] << 14 | F[49] >>> 18, pt = F[49] << 14 | F[48] >>> 18, F[0] = Z ^ ~nt & it, F[1] = tt ^ ~rt & st, F[10] = mt ^ ~vt & Bt, F[11] = Tt ^ ~Rt & wt, F[20] = te ^ ~Kt & St, F[21] = jt ^ ~re & Nt, F[30] = Ot ^ ~gt & _t, F[31] = ft ^ ~bt & Lt, F[40] = zt ^ ~Gt & de, F[41] = he ^ ~Ut & Zt, F[2] = nt ^ ~it & at, F[3] = rt ^ ~st & ct, F[12] = vt ^ ~Bt & kt, F[13] = Rt ^ ~wt & Wt, F[22] = Kt ^ ~St & ne, F[23] = re ^ ~Nt & Vt, F[32] = gt ^ ~_t & Pt, F[33] = bt ^ ~Lt & Mt, F[42] = Gt ^ ~de & Xt, F[43] = Ut ^ ~Zt & ie, F[4] = it ^ ~at & lt, F[5] = st ^ ~ct & pt, F[14] = Bt ^ ~kt & Ct, F[15] = wt ^ ~Wt & Ft, F[24] = St ^ ~ne & qt, F[25] = Nt ^ ~Vt & ee, F[34] = _t ^ ~Pt & Yt, F[35] = Lt ^ ~Mt & Dt, F[44] = de ^ ~Xt & Qt, F[45] = Zt ^ ~ie & $t, F[6] = at ^ ~lt & Z, F[7] = ct ^ ~pt & tt, F[16] = kt ^ ~Ct & mt, F[17] = Wt ^ ~Ft & Tt, F[26] = ne ^ ~qt & te, F[27] = Vt ^ ~ee & jt, F[36] = Pt ^ ~Yt & Ot, F[37] = Mt ^ ~Dt & ft, F[46] = Xt ^ ~Qt & zt, F[47] = ie ^ ~$t & he, F[8] = lt ^ ~Z & nt, F[9] = pt ^ ~tt & rt, F[18] = Ct ^ ~mt & vt, F[19] = Ft ^ ~Tt & Rt, F[28] = qt ^ ~te & Kt, F[29] = ee ^ ~jt & re, F[38] = Yt ^ ~Ot & gt, F[39] = Dt ^ ~ft & bt, F[48] = Qt ^ ~zt & Gt, F[49] = $t ^ ~he & Ut, F[0] ^= p[y], F[1] ^= p[y + 1]; }; if (u)
                    E.exports = T;
                else {
                    for (P = 0; P < B.length; ++P)
                        t[B[P]] = T[B[P]];
                    i && ((e = function () { return T; }.call(m, f, m, E)) === void 0 || (E.exports = e));
                } }(); }).call(this, f(9), f(10));
            }, function (E, m) { (function (f) { E.exports = f; }).call(this, {}); }, function (E, m, f) {
                "use strict";
                E.exports = f(512);
            }, function (E, m, f) {
                "use strict";
                !function (d, r) { var e = { version: "3.0.0", x86: {}, x64: {}, inputValidation: !0 }; function c(p) { if (!Array.isArray(p) && !ArrayBuffer.isView(p))
                    return !1; for (var g = 0; g < p.length; g++)
                    if (!Number.isInteger(p[g]) || p[g] < 0 || p[g] > 255)
                        return !1; return !0; } function n(p, g) { return (65535 & p) * g + (((p >>> 16) * g & 65535) << 16); } function t(p, g) { return p << g | p >>> 32 - g; } function s(p) { return p = n(p ^= p >>> 16, 2246822507), p = n(p ^= p >>> 13, 3266489909), p ^= p >>> 16; } function u(p, g) { p = [p[0] >>> 16, 65535 & p[0], p[1] >>> 16, 65535 & p[1]], g = [g[0] >>> 16, 65535 & g[0], g[1] >>> 16, 65535 & g[1]]; var b = [0, 0, 0, 0]; return b[3] += p[3] + g[3], b[2] += b[3] >>> 16, b[3] &= 65535, b[2] += p[2] + g[2], b[1] += b[2] >>> 16, b[2] &= 65535, b[1] += p[1] + g[1], b[0] += b[1] >>> 16, b[1] &= 65535, b[0] += p[0] + g[0], b[0] &= 65535, [b[0] << 16 | b[1], b[2] << 16 | b[3]]; } function i(p, g) { p = [p[0] >>> 16, 65535 & p[0], p[1] >>> 16, 65535 & p[1]], g = [g[0] >>> 16, 65535 & g[0], g[1] >>> 16, 65535 & g[1]]; var b = [0, 0, 0, 0]; return b[3] += p[3] * g[3], b[2] += b[3] >>> 16, b[3] &= 65535, b[2] += p[2] * g[3], b[1] += b[2] >>> 16, b[2] &= 65535, b[2] += p[3] * g[2], b[1] += b[2] >>> 16, b[2] &= 65535, b[1] += p[1] * g[3], b[0] += b[1] >>> 16, b[1] &= 65535, b[1] += p[2] * g[2], b[0] += b[1] >>> 16, b[1] &= 65535, b[1] += p[3] * g[1], b[0] += b[1] >>> 16, b[1] &= 65535, b[0] += p[0] * g[3] + p[1] * g[2] + p[2] * g[1] + p[3] * g[0], b[0] &= 65535, [b[0] << 16 | b[1], b[2] << 16 | b[3]]; } function o(p, g) { return (g %= 64) === 32 ? [p[1], p[0]] : g < 32 ? [p[0] << g | p[1] >>> 32 - g, p[1] << g | p[0] >>> 32 - g] : (g -= 32, [p[1] << g | p[0] >>> 32 - g, p[0] << g | p[1] >>> 32 - g]); } function h(p, g) { return (g %= 64) === 0 ? p : g < 32 ? [p[0] << g | p[1] >>> 32 - g, p[1] << g] : [p[1] << g - 32, 0]; } function a(p, g) { return [p[0] ^ g[0], p[1] ^ g[1]]; } function l(p) { return p = a(p, [0, p[0] >>> 1]), p = a(p = i(p, [4283543511, 3981806797]), [0, p[0] >>> 1]), p = a(p = i(p, [3301882366, 444984403]), [0, p[0] >>> 1]); } e.x86.hash32 = function (p, g) { if (!e.inputValidation || c(p)) {
                    g = g || 0;
                    for (var b = p.length % 4, I = p.length - b, v = g, R = 0, _ = 3432918353, k = 461845907, x = 0; x < I; x += 4)
                        R = n(R = p[x] | p[x + 1] << 8 | p[x + 2] << 16 | p[x + 3] << 24, _), R = n(R = t(R, 15), k), v = n(v = t(v ^= R, 13), 5) + 3864292196;
                    switch (R = 0, b) {
                        case 3: R ^= p[x + 2] << 16;
                        case 2: R ^= p[x + 1] << 8;
                        case 1: R = n(R ^= p[x], _), v ^= R = n(R = t(R, 15), k);
                    }
                    return (v = s(v ^= p.length)) >>> 0;
                } }, e.x86.hash128 = function (p, g) { if (!e.inputValidation || c(p)) {
                    g = g || 0;
                    for (var b = p.length % 16, I = p.length - b, v = g, R = g, _ = g, k = g, x = 0, M = 0, N = 0, S = 0, T = 597399067, B = 2869860233, P = 951274213, L = 2716044179, j = 0; j < I; j += 16)
                        x = p[j] | p[j + 1] << 8 | p[j + 2] << 16 | p[j + 3] << 24, M = p[j + 4] | p[j + 5] << 8 | p[j + 6] << 16 | p[j + 7] << 24, N = p[j + 8] | p[j + 9] << 8 | p[j + 10] << 16 | p[j + 11] << 24, S = p[j + 12] | p[j + 13] << 8 | p[j + 14] << 16 | p[j + 15] << 24, x = t(x = n(x, T), 15), v = t(v ^= x = n(x, B), 19), v = n(v += R, 5) + 1444728091, M = t(M = n(M, B), 16), R = t(R ^= M = n(M, P), 17), R = n(R += _, 5) + 197830471, N = t(N = n(N, P), 17), _ = t(_ ^= N = n(N, L), 15), _ = n(_ += k, 5) + 2530024501, S = t(S = n(S, L), 18), k = t(k ^= S = n(S, T), 13), k = n(k += v, 5) + 850148119;
                    switch (x = 0, M = 0, N = 0, S = 0, b) {
                        case 15: S ^= p[j + 14] << 16;
                        case 14: S ^= p[j + 13] << 8;
                        case 13: S = n(S ^= p[j + 12], L), k ^= S = n(S = t(S, 18), T);
                        case 12: N ^= p[j + 11] << 24;
                        case 11: N ^= p[j + 10] << 16;
                        case 10: N ^= p[j + 9] << 8;
                        case 9: N = n(N ^= p[j + 8], P), _ ^= N = n(N = t(N, 17), L);
                        case 8: M ^= p[j + 7] << 24;
                        case 7: M ^= p[j + 6] << 16;
                        case 6: M ^= p[j + 5] << 8;
                        case 5: M = n(M ^= p[j + 4], B), R ^= M = n(M = t(M, 16), P);
                        case 4: x ^= p[j + 3] << 24;
                        case 3: x ^= p[j + 2] << 16;
                        case 2: x ^= p[j + 1] << 8;
                        case 1: x = n(x ^= p[j], T), v ^= x = n(x = t(x, 15), B);
                    }
                    return v ^= p.length, v += R ^= p.length, v += _ ^= p.length, R += v += k ^= p.length, _ += v, k += v, v = s(v), v += R = s(R), v += _ = s(_), R += v += k = s(k), _ += v, k += v, ("00000000" + (v >>> 0).toString(16)).slice(-8) + ("00000000" + (R >>> 0).toString(16)).slice(-8) + ("00000000" + (_ >>> 0).toString(16)).slice(-8) + ("00000000" + (k >>> 0).toString(16)).slice(-8);
                } }, e.x64.hash128 = function (p, g) { if (!e.inputValidation || c(p)) {
                    g = g || 0;
                    for (var b = p.length % 16, I = p.length - b, v = [0, g], R = [0, g], _ = [0, 0], k = [0, 0], x = [2277735313, 289559509], M = [1291169091, 658871167], N = 0; N < I; N += 16)
                        _ = [p[N + 4] | p[N + 5] << 8 | p[N + 6] << 16 | p[N + 7] << 24, p[N] | p[N + 1] << 8 | p[N + 2] << 16 | p[N + 3] << 24], k = [p[N + 12] | p[N + 13] << 8 | p[N + 14] << 16 | p[N + 15] << 24, p[N + 8] | p[N + 9] << 8 | p[N + 10] << 16 | p[N + 11] << 24], _ = o(_ = i(_, x), 31), v = u(v = o(v = a(v, _ = i(_, M)), 27), R), v = u(i(v, [0, 5]), [0, 1390208809]), k = o(k = i(k, M), 33), R = u(R = o(R = a(R, k = i(k, x)), 31), v), R = u(i(R, [0, 5]), [0, 944331445]);
                    switch (_ = [0, 0], k = [0, 0], b) {
                        case 15: k = a(k, h([0, p[N + 14]], 48));
                        case 14: k = a(k, h([0, p[N + 13]], 40));
                        case 13: k = a(k, h([0, p[N + 12]], 32));
                        case 12: k = a(k, h([0, p[N + 11]], 24));
                        case 11: k = a(k, h([0, p[N + 10]], 16));
                        case 10: k = a(k, h([0, p[N + 9]], 8));
                        case 9: k = i(k = a(k, [0, p[N + 8]]), M), R = a(R, k = i(k = o(k, 33), x));
                        case 8: _ = a(_, h([0, p[N + 7]], 56));
                        case 7: _ = a(_, h([0, p[N + 6]], 48));
                        case 6: _ = a(_, h([0, p[N + 5]], 40));
                        case 5: _ = a(_, h([0, p[N + 4]], 32));
                        case 4: _ = a(_, h([0, p[N + 3]], 24));
                        case 3: _ = a(_, h([0, p[N + 2]], 16));
                        case 2: _ = a(_, h([0, p[N + 1]], 8));
                        case 1: _ = i(_ = a(_, [0, p[N]]), x), v = a(v, _ = i(_ = o(_, 31), M));
                    }
                    return v = u(v = a(v, [0, p.length]), R = a(R, [0, p.length])), R = u(R, v), v = u(v = l(v), R = l(R)), R = u(R, v), ("00000000" + (v[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (v[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (R[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (R[1] >>> 0).toString(16)).slice(-8);
                } }, E.exports && (m = E.exports = e), m.murmurHash3 = e; }();
            }, function (E, m, f) {
                "use strict";
                E.exports = { fromNumberTo32BitBuf: d => { const r = new Uint8Array(4); for (let e = 0; e < 4; e++)
                        r[e] = 255 & d, d >>= 8; return r; } };
            }, function (E, m, f) {
                "use strict";
                const d = f(515), r = { init: d.blake2bInit, update: d.blake2bUpdate, digest: d.blake2bFinal }, e = { init: d.blake2sInit, update: d.blake2sUpdate, digest: d.blake2sFinal }, c = (n, t) => async (s) => { const u = t.init(n, null); return t.update(u, s), t.digest(u); };
                E.exports = n => { for (let t = 0; t < 64; t++)
                    n[45569 + t] = c(t + 1, r); for (let t = 0; t < 32; t++)
                    n[45633 + t] = c(t + 1, e); };
            }, function (E, m, f) {
                "use strict";
                var d = f(516), r = f(517);
                E.exports = { blake2b: d.blake2b, blake2bHex: d.blake2bHex, blake2bInit: d.blake2bInit, blake2bUpdate: d.blake2bUpdate, blake2bFinal: d.blake2bFinal, blake2s: r.blake2s, blake2sHex: r.blake2sHex, blake2sInit: r.blake2sInit, blake2sUpdate: r.blake2sUpdate, blake2sFinal: r.blake2sFinal };
            }, function (E, m, f) {
                "use strict";
                var d = f(241);
                function r(g, b, I) { var v = g[b] + g[I], R = g[b + 1] + g[I + 1]; v >= 4294967296 && R++, g[b] = v, g[b + 1] = R; }
                function e(g, b, I, v) { var R = g[b] + I; I < 0 && (R += 4294967296); var _ = g[b + 1] + v; R >= 4294967296 && _++, g[b] = R, g[b + 1] = _; }
                function c(g, b) { return g[b] ^ g[b + 1] << 8 ^ g[b + 2] << 16 ^ g[b + 3] << 24; }
                function n(g, b, I, v, R, _) { var k = i[R], x = i[R + 1], M = i[_], N = i[_ + 1]; r(u, g, b), e(u, g, k, x); var S = u[v] ^ u[g], T = u[v + 1] ^ u[g + 1]; u[v] = T, u[v + 1] = S, r(u, I, v), S = u[b] ^ u[I], T = u[b + 1] ^ u[I + 1], u[b] = S >>> 24 ^ T << 8, u[b + 1] = T >>> 24 ^ S << 8, r(u, g, b), e(u, g, M, N), S = u[v] ^ u[g], T = u[v + 1] ^ u[g + 1], u[v] = S >>> 16 ^ T << 16, u[v + 1] = T >>> 16 ^ S << 16, r(u, I, v), S = u[b] ^ u[I], T = u[b + 1] ^ u[I + 1], u[b] = T >>> 31 ^ S << 1, u[b + 1] = S >>> 31 ^ T << 1; }
                var t = new Uint32Array([4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137, 1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225]), s = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3].map(function (g) { return 2 * g; })), u = new Uint32Array(32), i = new Uint32Array(32);
                function o(g, b) { var I = 0; for (I = 0; I < 16; I++)
                    u[I] = g.h[I], u[I + 16] = t[I]; for (u[24] = u[24] ^ g.t, u[25] = u[25] ^ g.t / 4294967296, b && (u[28] = ~u[28], u[29] = ~u[29]), I = 0; I < 32; I++)
                    i[I] = c(g.b, 4 * I); for (I = 0; I < 12; I++)
                    n(0, 8, 16, 24, s[16 * I + 0], s[16 * I + 1]), n(2, 10, 18, 26, s[16 * I + 2], s[16 * I + 3]), n(4, 12, 20, 28, s[16 * I + 4], s[16 * I + 5]), n(6, 14, 22, 30, s[16 * I + 6], s[16 * I + 7]), n(0, 10, 20, 30, s[16 * I + 8], s[16 * I + 9]), n(2, 12, 22, 24, s[16 * I + 10], s[16 * I + 11]), n(4, 14, 16, 26, s[16 * I + 12], s[16 * I + 13]), n(6, 8, 18, 28, s[16 * I + 14], s[16 * I + 15]); for (I = 0; I < 16; I++)
                    g.h[I] = g.h[I] ^ u[I] ^ u[I + 16]; }
                function h(g, b) { if (g === 0 || g > 64)
                    throw new Error("Illegal output length, expected 0 < length <= 64"); if (b && b.length > 64)
                    throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64"); for (var I = { b: new Uint8Array(128), h: new Uint32Array(16), t: 0, c: 0, outlen: g }, v = 0; v < 16; v++)
                    I.h[v] = t[v]; var R = b ? b.length : 0; return I.h[0] ^= 16842752 ^ R << 8 ^ g, b && (a(I, b), I.c = 128), I; }
                function a(g, b) { for (var I = 0; I < b.length; I++)
                    g.c === 128 && (g.t += g.c, o(g, !1), g.c = 0), g.b[g.c++] = b[I]; }
                function l(g) { for (g.t += g.c; g.c < 128;)
                    g.b[g.c++] = 0; o(g, !0); for (var b = new Uint8Array(g.outlen), I = 0; I < g.outlen; I++)
                    b[I] = g.h[I >> 2] >> 8 * (3 & I); return b; }
                function p(g, b, I) { I = I || 64, g = d.normalizeInput(g); var v = h(I, b); return a(v, g), l(v); }
                E.exports = { blake2b: p, blake2bHex: function (g, b, I) { var v = p(g, b, I); return d.toHex(v); }, blake2bInit: h, blake2bUpdate: a, blake2bFinal: l };
            }, function (E, m, f) {
                "use strict";
                var d = f(241);
                function r(p, g) { return p[g] ^ p[g + 1] << 8 ^ p[g + 2] << 16 ^ p[g + 3] << 24; }
                function e(p, g, b, I, v, R) { s[p] = s[p] + s[g] + v, s[I] = c(s[I] ^ s[p], 16), s[b] = s[b] + s[I], s[g] = c(s[g] ^ s[b], 12), s[p] = s[p] + s[g] + R, s[I] = c(s[I] ^ s[p], 8), s[b] = s[b] + s[I], s[g] = c(s[g] ^ s[b], 7); }
                function c(p, g) { return p >>> g ^ p << 32 - g; }
                var n = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), t = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0]), s = new Uint32Array(16), u = new Uint32Array(16);
                function i(p, g) { var b = 0; for (b = 0; b < 8; b++)
                    s[b] = p.h[b], s[b + 8] = n[b]; for (s[12] ^= p.t, s[13] ^= p.t / 4294967296, g && (s[14] = ~s[14]), b = 0; b < 16; b++)
                    u[b] = r(p.b, 4 * b); for (b = 0; b < 10; b++)
                    e(0, 4, 8, 12, u[t[16 * b + 0]], u[t[16 * b + 1]]), e(1, 5, 9, 13, u[t[16 * b + 2]], u[t[16 * b + 3]]), e(2, 6, 10, 14, u[t[16 * b + 4]], u[t[16 * b + 5]]), e(3, 7, 11, 15, u[t[16 * b + 6]], u[t[16 * b + 7]]), e(0, 5, 10, 15, u[t[16 * b + 8]], u[t[16 * b + 9]]), e(1, 6, 11, 12, u[t[16 * b + 10]], u[t[16 * b + 11]]), e(2, 7, 8, 13, u[t[16 * b + 12]], u[t[16 * b + 13]]), e(3, 4, 9, 14, u[t[16 * b + 14]], u[t[16 * b + 15]]); for (b = 0; b < 8; b++)
                    p.h[b] ^= s[b] ^ s[b + 8]; }
                function o(p, g) { if (!(p > 0 && p <= 32))
                    throw new Error("Incorrect output length, should be in [1, 32]"); var b = g ? g.length : 0; if (g && !(b > 0 && b <= 32))
                    throw new Error("Incorrect key length, should be in [1, 32]"); var I = { h: new Uint32Array(n), b: new Uint32Array(64), c: 0, t: 0, outlen: p }; return I.h[0] ^= 16842752 ^ b << 8 ^ p, b > 0 && (h(I, g), I.c = 64), I; }
                function h(p, g) { for (var b = 0; b < g.length; b++)
                    p.c === 64 && (p.t += p.c, i(p, !1), p.c = 0), p.b[p.c++] = g[b]; }
                function a(p) { for (p.t += p.c; p.c < 64;)
                    p.b[p.c++] = 0; i(p, !0); for (var g = new Uint8Array(p.outlen), b = 0; b < p.outlen; b++)
                    g[b] = p.h[b >> 2] >> 8 * (3 & b) & 255; return g; }
                function l(p, g, b) { b = b || 32, p = d.normalizeInput(p); var I = o(b, g); return h(I, p), a(I); }
                E.exports = { blake2s: l, blake2sHex: function (p, g, b) { var I = l(p, g, b); return d.toHex(I); }, blake2sInit: o, blake2sUpdate: h, blake2sFinal: a };
            }, function (E, m, f) {
                "use strict";
                const { mergeOptions: d } = f(23), { isTest: r } = f(216), e = f(1)("ipfs"), { DAGNode: c } = f(17), n = f(29), t = f(18), s = f(535), u = f(536), i = f(537), o = f(538), h = f(544), a = f(545), l = f(546), p = f(580), g = f(611), b = f(620), I = f(621), v = f(622), R = f(626), _ = f(632), k = f(638), x = f(679), M = f(680), N = f(288), S = f(681), T = f(87), B = f(686), P = f(689), L = f(690), j = f(714), D = f(722), G = f(732), W = f(807), X = f(809), Q = f(810), K = f(815), F = f(1087), Y = f(154), $ = f(1107), y = f(1108), C = f(1109);
                class A {
                    constructor({ print: q, storage: H, options: V }) { const { peerId: J, repo: Z, keychain: tt } = H, nt = Y.create(F), rt = B(V.preload), it = new X(H.repo), st = Q({ blockService: it, print: q, options: V.ipld }), at = $({ path: Z.path, repoOwner: V.repoOwner }), ct = o(), lt = h({ network: nt }), pt = new p(V), mt = S.reader({ ipld: st, preload: rt }), Tt = new g({ dns: ct, ipns: pt, dagReader: mt, peerId: J, isOnline: lt, keychain: tt, options: V }), vt = a({ ipld: st, name: Tt }), Rt = new T({ repo: Z, dagReader: mt }), Bt = new l({ gcLock: at, pinManager: Rt, dagReader: mt }), wt = new _({ blockService: it, preload: rt, gcLock: at, pinManager: Rt, pin: Bt }), kt = new S({ ipld: st, preload: rt, gcLock: at, pin: Bt, dagReader: mt }), Wt = Object.assign(b({ ipld: st, resolve: vt, preload: rt }), { local: I({ repo: H.repo }) }), { add: Ct, addAll: Ft, cat: te, get: jt, ls: Kt } = new k({ gcLock: at, preload: rt, pin: Bt, block: wt, ipld: st, options: V.EXPERIMENTAL }), re = L({ ipld: st, block: wt, blockService: it, repo: Z, preload: rt, options: V }), St = P({ files: re, preload: rt, options: V.preload }); this.preload = rt, this.name = Tt, this.ipld = st, this.ipns = pt, this.pin = Bt, this.resolve = vt, this.block = wt, this.refs = Wt, this.start = u({ network: nt, peerId: J, repo: Z, blockService: it, preload: rt, ipns: pt, mfsPreload: St, print: q, keychain: tt, options: V }), this.stop = i({ network: nt, preload: rt, mfsPreload: St, blockService: it, ipns: pt, repo: Z }), this.dht = C({ network: nt, repo: Z }), this.dns = ct, this.isOnline = lt, this.id = M({ network: nt, peerId: J }), this.version = x({ repo: Z }), this.bitswap = new v({ network: nt }), this.bootstrap = new R({ repo: Z }), this.config = N({ repo: Z }), this.ping = y({ network: nt }), this.add = Ct, this.addAll = Ft, this.cat = te, this.get = jt, this.ls = Kt, this.dag = kt, this.files = re, this.key = new j({ keychain: tt }), this.object = new D({ ipld: st, preload: rt, gcLock: at, dag: kt }), this.repo = new G({ gcLock: at, pin: Bt, repo: Z, refs: Wt }), this.stats = new W({ repo: Z, network: nt }); }
                    static async create(q = {}) { const H = (q = d(w(), q)).silent ? e : console.log, V = { ...d(U(q), q), print: H }, J = await K.start(V), Z = await J.repo.config.getAll(), tt = new A({ storage: J, print: H, options: { ...q, config: Z } }); if (await tt.preload.start(), tt.ipns.startOffline(J), J.isNew && !V.emptyRepo) {
                        const nt = await z(tt);
                        e("adding default assets"), await s({ addAll: tt.addAll, print: H }), e("initializing IPNS keyspace"), await tt.ipns.initializeKeyspace(J.peerId.privKey, nt.toString());
                    } return q.start !== !1 && await tt.start(), tt; }
                }
                E.exports = A;
                const U = ({ init: O }) => typeof O == "object" ? O : {}, z = async (O) => { const q = new c(new n("directory").marshal()), H = await O.dag.put(q, { version: 0, format: t.DAG_PB, hashAlg: t.SHA2_256, preload: !1 }); return await O.pin.add(H), H; }, w = () => ({ start: !0, EXPERIMENTAL: {}, preload: { enabled: !r, addresses: ["/dns4/node0.preload.ipfs.io/https", "/dns4/node1.preload.ipfs.io/https", "/dns4/node2.preload.ipfs.io/https", "/dns4/node3.preload.ipfs.io/https"] } });
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.urlAlphabet = void 0, m.urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
            }, function (E, m, f) {
                "use strict";
                const { nanoid: d } = f(243);
                E.exports = (r = e => e) => r(d());
            }, function (E, m, f) {
                "use strict";
                E.exports = f(244).TextEncoder;
            }, function (E, m, f) {
                "use strict";
                const d = f(242), r = f(246), e = f(248);
                E.exports = class extends r {
                    constructor() { super(), this.data = {}; }
                    async put(c, n) { this.data[c.toString()] = n; }
                    async get(c) { if (!await this.has(c))
                        throw e.notFoundError(); return this.data[c.toString()]; }
                    async has(c) { return this.data[c.toString()] !== void 0; }
                    async delete(c) { delete this.data[c.toString()]; }
                    *_all() { yield* Object.entries(this.data).map(([c, n]) => ({ key: new d(c), value: n })); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { return Date.now(); };
            }, function (E, m, f) {
                "use strict";
                class d extends Error {
                    constructor(e = "request timed out") { super(e), this.name = "TimeoutError", this.code = d.code; }
                }
                d.code = "ERR_TIMEOUT", m.TimeoutError = d;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { function r(n) { let t, s = null; function u(...i) { if (!u.enabled)
                    return; const o = u, h = Number(new Date), a = h - (t || h); o.diff = a, o.prev = t, o.curr = h, t = h, i[0] = r.coerce(i[0]), typeof i[0] != "string" && i.unshift("%O"); let l = 0; i[0] = i[0].replace(/%([a-zA-Z%])/g, (p, g) => { if (p === "%%")
                    return "%"; l++; const b = r.formatters[g]; if (typeof b == "function") {
                    const I = i[l];
                    p = b.call(o, I), i.splice(l, 1), l--;
                } return p; }), r.formatArgs.call(o, i), (o.log || r.log).apply(o, i); } return u.namespace = n, u.useColors = r.useColors(), u.color = r.selectColor(n), u.extend = e, u.destroy = r.destroy, Object.defineProperty(u, "enabled", { enumerable: !0, configurable: !1, get: () => s === null ? r.enabled(n) : s, set: i => { s = i; } }), typeof r.init == "function" && r.init(u), u; } function e(n, t) { const s = r(this.namespace + (t === void 0 ? ":" : t) + n); return s.log = this.log, s; } function c(n) { return n.toString().substring(2, n.toString().length - 2).replace(/\.\*\?$/, "*"); } return r.debug = r, r.default = r, r.coerce = function (n) { return n instanceof Error ? n.stack || n.message : n; }, r.disable = function () { const n = [...r.names.map(c), ...r.skips.map(c).map(t => "-" + t)].join(","); return r.enable(""), n; }, r.enable = function (n) { let t; r.save(n), r.names = [], r.skips = []; const s = (typeof n == "string" ? n : "").split(/[\s,]+/), u = s.length; for (t = 0; t < u; t++)
                    s[t] && ((n = s[t].replace(/\*/g, ".*?"))[0] === "-" ? r.skips.push(new RegExp("^" + n.substr(1) + "$")) : r.names.push(new RegExp("^" + n + "$"))); }, r.enabled = function (n) { if (n[n.length - 1] === "*")
                    return !0; let t, s; for (t = 0, s = r.skips.length; t < s; t++)
                    if (r.skips[t].test(n))
                        return !1; for (t = 0, s = r.names.length; t < s; t++)
                    if (r.names[t].test(n))
                        return !0; return !1; }, r.humanize = f(526), r.destroy = function () { console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."); }, Object.keys(d).forEach(n => { r[n] = d[n]; }), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function (n) { let t = 0; for (let s = 0; s < n.length; s++)
                    t = (t << 5) - t + n.charCodeAt(s), t |= 0; return r.colors[Math.abs(t) % r.colors.length]; }, r.enable(r.load()), r; };
            }, function (E, m, f) {
                "use strict";
                var d = 1e3, r = 6e4, e = 60 * r, c = 24 * e;
                function n(t, s, u, i) { var o = s >= 1.5 * u; return Math.round(t / u) + " " + i + (o ? "s" : ""); }
                E.exports = function (t, s) { s = s || {}; var u = typeof t; if (u === "string" && t.length > 0)
                    return function (i) { if ((i = String(i)).length > 100)
                        return; var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i); if (!o)
                        return; var h = parseFloat(o[1]); switch ((o[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y": return 315576e5 * h;
                        case "weeks":
                        case "week":
                        case "w": return 6048e5 * h;
                        case "days":
                        case "day":
                        case "d": return h * c;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h": return h * e;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m": return h * r;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s": return h * d;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms": return h;
                        default: return;
                    } }(t); if (u === "number" && isFinite(t))
                    return s.long ? function (i) { var o = Math.abs(i); return o >= c ? n(i, o, c, "day") : o >= e ? n(i, o, e, "hour") : o >= r ? n(i, o, r, "minute") : o >= d ? n(i, o, d, "second") : i + " ms"; }(t) : function (i) { var o = Math.abs(i); return o >= c ? Math.round(i / c) + "d" : o >= e ? Math.round(i / e) + "h" : o >= r ? Math.round(i / r) + "m" : o >= d ? Math.round(i / d) + "s" : i + "ms"; }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(250);
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { var d = function (c, n) { return r(c.slice(), n); }; function r(c, n) { typeof n != "function" && (n = function (o, h) { return String(o).localeCompare(h); }); var t = c.length; if (t <= 1)
                    return c; for (var s = new Array(t), u = 1; u < t; u *= 2) {
                    e(c, n, u, s);
                    var i = c;
                    c = s, s = i;
                } return c; } d.inplace = function (c, n) { var t = r(c, n); return t !== c && e(t, null, c.length, c), c; }; var e = function (c, n, t, s) { var u, i, o, h, a, l = c.length, p = 0, g = 2 * t; for (u = 0; u < l; u += g)
                    for (o = (i = u + t) + t, i > l && (i = l), o > l && (o = l), h = u, a = i;;)
                        if (h < i && a < o)
                            n(c[h], c[a]) <= 0 ? s[p++] = c[h++] : s[p++] = c[a++];
                        else if (h < i)
                            s[p++] = c[h++];
                        else {
                            if (!(a < o))
                                break;
                            s[p++] = c[a++];
                        } }; return d; }();
            }, function (E, m, f) {
                "use strict";
                const d = f(61), r = f(255);
                E.exports = async (e, c = {}) => { const n = await r.cid(e.serialize(), c); return new d(c.name || "", e.size, n); };
            }, function (E, m, f) {
                "use strict";
                const d = f(251), r = f(256);
                E.exports = (e, c) => { const n = (t => { if (r.isDAGLink(t))
                    return t; if (!("cid" in t || "hash" in t || "Hash" in t || "multihash" in t))
                    throw new Error("Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`."); return new r(t.Name || t.name, t.Tsize || t.size, t.Hash || t.multihash || t.hash || t.cid); })(c); e.Links.push(n), d(e.Links); };
            }, function (E, m, f) {
                "use strict";
                const d = f(61);
                E.exports.createDagLinkFromB58EncodedHash = function (r) { return new d(r.Name || r.name || "", r.Tsize || r.Size || r.size || 0, r.Hash || r.hash || r.multihash || r.cid); };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(20);
                E.exports = (e, c) => { let n = null; if (typeof c == "string" ? n = t => t.Name === c : (c instanceof Uint8Array || d.isCID(c)) && (n = t => r(t.Hash, c)), !n)
                    throw new Error("second arg needs to be a name or CID"); {
                    const t = e.Links;
                    let s = 0;
                    for (; s < t.length;)
                        n(t[s]) ? t.splice(s, 1) : s++;
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(257);
                m.resolve = (e, c) => { let n = r.deserialize(e); const t = c.split("/").filter(Boolean); for (; t.length;) {
                    const s = t.shift();
                    if (n[s] === void 0) {
                        for (const u of n.Links)
                            if (u.Name === s)
                                return { value: u.Hash, remainderPath: t.join("/") };
                        throw new Error(`Object has no property '${s}'`);
                    }
                    if (n = n[s], d.isCID(n))
                        return { value: n, remainderPath: t.join("/") };
                } return { value: n, remainderPath: "" }; }, m.tree = function* (e) { const c = r.deserialize(e); yield "Data", yield "Links"; for (let n = 0; n < c.Links.length; n++)
                    yield "Links/" + n, yield `Links/${n}/Name`, yield `Links/${n}/Tsize`, yield `Links/${n}/Hash`; };
            }, function (E, m, f) {
                "use strict";
                E.exports = `
syntax = "proto2";

message Data {
  enum DataType {
    Raw = 0;
    Directory = 1;
    File = 2;
    Metadata = 3;
    Symlink = 4;
    HAMTShard = 5;
  }

  required DataType Type = 1;
  optional bytes Data = 2;
  optional uint64 filesize = 3;
  repeated uint64 blocksizes = 4;
  optional uint64 hashType = 5;
  optional uint64 fanout = 6;
  optional uint32 mode = 7;
  optional UnixTime mtime = 8;
}

message UnixTime {
  required int64 Seconds = 1;
  optional fixed32 FractionalNanoseconds = 2;
}

message Metadata {
  optional string MimeType = 1;
}
`;
            }, function (E, m, f) {
                "use strict";
                E.exports = () => { };
            }, function (E, m, f) {
                "use strict";
                const d = f(154);
                E.exports = ({ network: r, preload: e, peerId: c, keychain: n, repo: t, ipns: s, blockService: u, mfsPreload: i, print: o, options: h }) => async () => { const { bitswap: a, libp2p: l } = await d.start(r, { peerId: c, repo: t, print: o, options: h }); u.setExchange(a), await Promise.all([s.startOnline({ keychain: n, libp2p: l, peerId: c, repo: t }), e.start(), i.start()]); };
            }, function (E, m, f) {
                "use strict";
                const d = f(154);
                E.exports = ({ network: r, preload: e, blockService: c, ipns: n, repo: t, mfsPreload: s }) => async () => { c.unsetExchange(), await Promise.all([e.stop(), n.stop(), s.stop(), d.stop(r), t.close()]); };
            }, function (E, m, f) {
                "use strict";
                const d = f(539), r = f(2);
                E.exports = () => r(async (e, c = {}) => { if (typeof e != "string")
                    throw new Error("Invalid arguments, domain must be a string"); return e = function (n) { return n.endsWith(".eth") && (n = n.replace(/.eth$/, ".eth.link")), n; }(e), d(e, c); });
            }, function (E, m, f) {
                "use strict";
                const d = f(258), { default: r } = f(86), e = f(132), c = new d(1e3), n = new r({ concurrency: 4 }), t = s => { if (s.Path)
                    return s.Path; throw new Error(s.Message); };
                E.exports = async (s, u) => (async (i, o = {}) => { const h = new URLSearchParams(o); h.set("arg", i); const a = h.toString(); if (!o.nocache && c.has(a)) {
                    const p = c.get(a);
                    return t(p);
                } const l = await n.add(async () => { const p = await e.get("https://ipfs.io/api/v0/dns", { searchParams: h }), g = new URL(p.url).search.slice(1), b = await p.json(); return c.set(g, b, 6e4), b; }); return t(l); })(s, u);
            }, function (E, m, f) {
                "use strict";
                var d = Object.prototype.hasOwnProperty, r = "~";
                function e() { }
                function c(u, i, o) { this.fn = u, this.context = i, this.once = o || !1; }
                function n(u, i, o, h, a) { if (typeof o != "function")
                    throw new TypeError("The listener must be a function"); var l = new c(o, h || u, a), p = r ? r + i : i; return u._events[p] ? u._events[p].fn ? u._events[p] = [u._events[p], l] : u._events[p].push(l) : (u._events[p] = l, u._eventsCount++), u; }
                function t(u, i) { --u._eventsCount == 0 ? u._events = new e : delete u._events[i]; }
                function s() { this._events = new e, this._eventsCount = 0; }
                Object.create && (e.prototype = Object.create(null), new e().__proto__ || (r = !1)), s.prototype.eventNames = function () { var u, i, o = []; if (this._eventsCount === 0)
                    return o; for (i in u = this._events)
                    d.call(u, i) && o.push(r ? i.slice(1) : i); return Object.getOwnPropertySymbols ? o.concat(Object.getOwnPropertySymbols(u)) : o; }, s.prototype.listeners = function (u) { var i = r ? r + u : u, o = this._events[i]; if (!o)
                    return []; if (o.fn)
                    return [o.fn]; for (var h = 0, a = o.length, l = new Array(a); h < a; h++)
                    l[h] = o[h].fn; return l; }, s.prototype.listenerCount = function (u) { var i = r ? r + u : u, o = this._events[i]; return o ? o.fn ? 1 : o.length : 0; }, s.prototype.emit = function (u, i, o, h, a, l) { var p = r ? r + u : u; if (!this._events[p])
                    return !1; var g, b, I = this._events[p], v = arguments.length; if (I.fn) {
                    switch (I.once && this.removeListener(u, I.fn, void 0, !0), v) {
                        case 1: return I.fn.call(I.context), !0;
                        case 2: return I.fn.call(I.context, i), !0;
                        case 3: return I.fn.call(I.context, i, o), !0;
                        case 4: return I.fn.call(I.context, i, o, h), !0;
                        case 5: return I.fn.call(I.context, i, o, h, a), !0;
                        case 6: return I.fn.call(I.context, i, o, h, a, l), !0;
                    }
                    for (b = 1, g = new Array(v - 1); b < v; b++)
                        g[b - 1] = arguments[b];
                    I.fn.apply(I.context, g);
                }
                else {
                    var R, _ = I.length;
                    for (b = 0; b < _; b++)
                        switch (I[b].once && this.removeListener(u, I[b].fn, void 0, !0), v) {
                            case 1:
                                I[b].fn.call(I[b].context);
                                break;
                            case 2:
                                I[b].fn.call(I[b].context, i);
                                break;
                            case 3:
                                I[b].fn.call(I[b].context, i, o);
                                break;
                            case 4:
                                I[b].fn.call(I[b].context, i, o, h);
                                break;
                            default:
                                if (!g)
                                    for (R = 1, g = new Array(v - 1); R < v; R++)
                                        g[R - 1] = arguments[R];
                                I[b].fn.apply(I[b].context, g);
                        }
                } return !0; }, s.prototype.on = function (u, i, o) { return n(this, u, i, o, !1); }, s.prototype.once = function (u, i, o) { return n(this, u, i, o, !0); }, s.prototype.removeListener = function (u, i, o, h) { var a = r ? r + u : u; if (!this._events[a])
                    return this; if (!i)
                    return t(this, a), this; var l = this._events[a]; if (l.fn)
                    l.fn !== i || h && !l.once || o && l.context !== o || t(this, a);
                else {
                    for (var p = 0, g = [], b = l.length; p < b; p++)
                        (l[p].fn !== i || h && !l[p].once || o && l[p].context !== o) && g.push(l[p]);
                    g.length ? this._events[a] = g.length === 1 ? g[0] : g : t(this, a);
                } return this; }, s.prototype.removeAllListeners = function (u) { var i; return u ? (i = r ? r + u : u, this._events[i] && t(this, i)) : (this._events = new e, this._eventsCount = 0), this; }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prefixed = r, s.EventEmitter = s, E.exports = s;
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r) => (r = r || (() => { }), d.then(e => new Promise(c => { c(r()); }).then(() => e), e => new Promise(c => { c(r()); }).then(() => { throw e; })));
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 });
                const d = f(543);
                m.default = class {
                    constructor() { this._queue = []; }
                    enqueue(r, e) { const c = { priority: (e = Object.assign({ priority: 0 }, e)).priority, run: r }; if (this.size && this._queue[this.size - 1].priority >= e.priority)
                        return void this._queue.push(c); const n = d.default(this._queue, c, (t, s) => s.priority - t.priority); this._queue.splice(n, 0, c); }
                    dequeue() { const r = this._queue.shift(); return r == null ? void 0 : r.run; }
                    filter(r) { return this._queue.filter(e => e.priority === r.priority).map(e => e.run); }
                    get size() { return this._queue.length; }
                };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (d, r, e) { let c = 0, n = d.length; for (; n > 0;) {
                    const t = n / 2 | 0;
                    let s = c + t;
                    e(d[s], r) <= 0 ? (c = ++s, n -= t + 1) : n = t;
                } return c; };
            }, function (E, m, f) {
                "use strict";
                E.exports = ({ network: d }) => () => { const r = d.try(); return r != null && r.libp2p.isStarted(); };
            }, function (E, m, f) {
                "use strict";
                const d = f(52), r = f(4), { cidToString: e } = f(259), c = f(2);
                E.exports = ({ ipld: n, name: t }) => c(async function (s, u = {}) { if (!d.path(s))
                    throw new Error("invalid argument " + s); if (d.ipnsPath(s)) {
                    if (!t)
                        throw new Error("failed to resolve IPNS path: name API unavailable");
                    for await (const g of t.resolve(s, u))
                        s = g;
                } const [, , i, ...o] = s.split("/"), h = new r(i); if (o.length === 0)
                    return "/ipfs/" + e(h, { base: u.cidBase }); s = o.join("/"); const a = n.resolve(h, s); let l = h, p = s; for await (const g of a)
                    r.isCID(g.value) && (l = g.value, p = g.remainderPath); return `/ipfs/${e(l, { base: u.cidBase })}${p ? "/" + p : ""}`; });
            }, function (E, m, f) {
                "use strict";
                const d = f(547), r = f(548), e = f(577), c = f(578), n = f(579);
                E.exports = class {
                    constructor({ gcLock: t, dagReader: s, pinManager: u }) { const i = r({ gcLock: t, dagReader: s, pinManager: u }); this.addAll = i, this.add = d({ addAll: i }); const o = n({ gcLock: t, dagReader: s, pinManager: u }); this.rmAll = o, this.rm = c({ rmAll: o }), this.ls = e({ dagReader: s, pinManager: u }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(40);
                E.exports = ({ addAll: r }) => async (e, c = {}) => await d(r({ path: e, ...c }, c));
            }, function (E, m, f) {
                "use strict";
                const { resolvePath: d } = f(23), r = f(87), { PinTypes: e } = r, c = f(2), n = f(162);
                E.exports = ({ pinManager: t, gcLock: s, dagReader: u }) => c(async function* (i, o = {}) { const h = async function* () { for await (const { path: l, recursive: p, metadata: g } of n(i)) {
                    const b = await d(u, l), { reason: I } = await t.isPinnedWithType(b, [e.recursive, e.direct]);
                    if (I === "recursive" && !p)
                        throw new Error(b + " already pinned recursively");
                    p ? await t.pinRecursively(b, { metadata: g }) : await t.pinDirectly(b, { metadata: g }), yield b;
                } }; if (!Boolean(o.lock))
                    return void (yield* h()); const a = await s.readLock(); try {
                    yield* h();
                }
                finally {
                    a();
                } });
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(155).util, e = f(4), c = (n, t = [], s = !0) => (s && d.isBuffer(n) && (n = r.deserialize(n)), function* () { for (let u of Object.keys(n)) {
                    let i = t.slice();
                    i.push(u);
                    let o = n[u];
                    if (o && typeof o == "object")
                        if (Array.isArray(o))
                            for (let h = 0; h < o.length; h++) {
                                let a = i.slice();
                                a.push(h);
                                let l = o[h];
                                e.isCID(l) ? yield [a.join("/"), l] : typeof l == "object" && (yield* c(l, i, !1));
                            }
                        else
                            e.isCID(o) ? yield [i.join("/"), o] : yield* c(o, i, !1);
                } }()); E.exports = c; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                m.Diagnose = f(551), m.Decoder = f(261), m.Encoder = f(554), m.Simple = f(262), m.Tagged = f(263), m.decodeAll = m.Decoder.decodeAll, m.decodeFirst = m.Decoder.decodeFirst, m.diagnose = m.Diagnose.diagnose, m.encode = m.Encoder.encode, m.decode = m.Decoder.decode, m.leveldb = { decode: m.Decoder.decodeAll, encode: m.Encoder.encode, buffer: !0, name: "cbor" };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(261), e = f(156);
                class c extends r {
                    createTag(s, u) { return `${s}(${u})`; }
                    createInt(s) { return super.createInt(s).toString(); }
                    createInt32(s, u) { return super.createInt32(s, u).toString(); }
                    createInt64(s, u, i, o) { return super.createInt64(s, u, i, o).toString(); }
                    createInt32Neg(s, u) { return super.createInt32Neg(s, u).toString(); }
                    createInt64Neg(s, u, i, o) { return super.createInt64Neg(s, u, i, o).toString(); }
                    createTrue() { return "true"; }
                    createFalse() { return "false"; }
                    createFloat(s) { const u = super.createFloat(s); return e.isNegativeZero(s) ? "-0_1" : u + "_1"; }
                    createFloatSingle(s, u, i, o) { return super.createFloatSingle(s, u, i, o) + "_2"; }
                    createFloatDouble(s, u, i, o, h, a, l, p) { return super.createFloatDouble(s, u, i, o, h, a, l, p) + "_3"; }
                    createByteString(s, u) { const i = s.join(", "); return u === -1 ? `(_ ${i})` : "h'" + i; }
                    createByteStringFromHeap(s, u) { return `h'${d.from(super.createByteStringFromHeap(s, u)).toString("hex")}'`; }
                    createInfinity() { return "Infinity_1"; }
                    createInfinityNeg() { return "-Infinity_1"; }
                    createNaN() { return "NaN_1"; }
                    createNaNNeg() { return "-NaN_1"; }
                    createNull() { return "null"; }
                    createUndefined() { return "undefined"; }
                    createSimpleUnassigned(s) { return `simple(${s})`; }
                    createArray(s, u) { const i = super.createArray(s, u); return u === -1 ? `[_ ${i.join(", ")}]` : `[${i.join(", ")}]`; }
                    createMap(s, u) { const i = super.createMap(s), o = Array.from(i.keys()).reduce(n(i), ""); return u === -1 ? `{_ ${o}}` : `{${o}}`; }
                    createObject(s, u) { const i = super.createObject(s), o = Object.keys(i).reduce(n(i), ""); return u === -1 ? `{_ ${o}}` : `{${o}}`; }
                    createUtf8String(s, u) { const i = s.join(", "); return u === -1 ? `(_ ${i})` : `"${i}"`; }
                    createUtf8StringFromHeap(s, u) { return `"${d.from(super.createUtf8StringFromHeap(s, u)).toString("utf8")}"`; }
                    static diagnose(s, u) { return typeof s == "string" && (s = d.from(s, u || "hex")), new c().decodeFirst(s); }
                }
                function n(t) { return (s, u) => s ? `${s}, ${u}: ${t[u]}` : `${u}: ${t[u]}`; }
                E.exports = c;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { var c = new d.Uint8Array(e), n = r.pushInt, t = r.pushInt32, s = r.pushInt32Neg, u = r.pushInt64, i = r.pushInt64Neg, o = r.pushFloat, h = r.pushFloatSingle, a = r.pushFloatDouble, l = r.pushTrue, p = r.pushFalse, g = r.pushUndefined, b = r.pushNull, I = r.pushInfinity, v = r.pushInfinityNeg, R = r.pushNaN, _ = r.pushNaNNeg, k = r.pushArrayStart, x = r.pushArrayStartFixed, M = r.pushArrayStartFixed32, N = r.pushArrayStartFixed64, S = r.pushObjectStart, T = r.pushObjectStartFixed, B = r.pushObjectStartFixed32, P = r.pushObjectStartFixed64, L = r.pushByteString, j = r.pushByteStringStart, D = r.pushUtf8String, G = r.pushUtf8StringStart, W = r.pushSimpleUnassigned, X = r.pushTagStart, Q = r.pushTagStart4, K = r.pushTagStart8, F = r.pushTagUnassigned, Y = r.pushBreak, $ = d.Math.pow, y = 0, C = 0, A = 0; function U(ot) { for (ot = ot | 0, y = 0, C = ot; (y | 0) < (C | 0) && !(A = yt[c[y] & 255](c[y] | 0) | 0, (A | 0) > 0);)
                    ; return A | 0; } function z(ot) { return ot = ot | 0, ((y | 0) + (ot | 0) | 0) < (C | 0) ? 0 : 1; } function w(ot) { return ot = ot | 0, c[ot | 0] << 8 | c[ot + 1 | 0] | 0; } function O(ot) { return ot = ot | 0, c[ot | 0] << 24 | c[ot + 1 | 0] << 16 | c[ot + 2 | 0] << 8 | c[ot + 3 | 0] | 0; } function q(ot) { return ot = ot | 0, n(ot | 0), y = y + 1 | 0, 0; } function H(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (n(c[y + 1 | 0] | 0), y = y + 2 | 0, 0); } function V(ot) { return ot = ot | 0, z(2) | 0 ? 1 : (n(w(y + 1 | 0) | 0), y = y + 3 | 0, 0); } function J(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (t(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0), y = y + 5 | 0, 0); } function Z(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (u(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0, w(y + 5 | 0) | 0, w(y + 7 | 0) | 0), y = y + 9 | 0, 0); } function tt(ot) { return ot = ot | 0, n(-1 - (ot - 32 | 0) | 0), y = y + 1 | 0, 0; } function nt(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (n(-1 - (c[y + 1 | 0] | 0) | 0), y = y + 2 | 0, 0); } function rt(ot) { ot = ot | 0; var Et = 0; return z(2) | 0 ? 1 : (Et = w(y + 1 | 0) | 0, n(-1 - (Et | 0) | 0), y = y + 3 | 0, 0); } function it(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (s(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0), y = y + 5 | 0, 0); } function st(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (i(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0, w(y + 5 | 0) | 0, w(y + 7 | 0) | 0), y = y + 9 | 0, 0); } function at(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return At = ot - 64 | 0, z(At | 0) | 0 ? 1 : (Et = y + 1 | 0, It = (y + 1 | 0) + (At | 0) | 0, L(Et | 0, It | 0), y = It | 0, 0); } function ct(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(1) | 0 ? 1 : (At = c[y + 1 | 0] | 0, Et = y + 2 | 0, It = (y + 2 | 0) + (At | 0) | 0, z(At + 1 | 0) | 0 ? 1 : (L(Et | 0, It | 0), y = It | 0, 0)); } function lt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(2) | 0 ? 1 : (At = w(y + 1 | 0) | 0, Et = y + 3 | 0, It = (y + 3 | 0) + (At | 0) | 0, z(At + 2 | 0) | 0 ? 1 : (L(Et | 0, It | 0), y = It | 0, 0)); } function pt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(4) | 0 ? 1 : (At = O(y + 1 | 0) | 0, Et = y + 5 | 0, It = (y + 5 | 0) + (At | 0) | 0, z(At + 4 | 0) | 0 ? 1 : (L(Et | 0, It | 0), y = It | 0, 0)); } function mt(ot) { return ot = ot | 0, 1; } function Tt(ot) { return ot = ot | 0, j(), y = y + 1 | 0, 0; } function vt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return At = ot - 96 | 0, z(At | 0) | 0 ? 1 : (Et = y + 1 | 0, It = (y + 1 | 0) + (At | 0) | 0, D(Et | 0, It | 0), y = It | 0, 0); } function Rt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(1) | 0 ? 1 : (At = c[y + 1 | 0] | 0, Et = y + 2 | 0, It = (y + 2 | 0) + (At | 0) | 0, z(At + 1 | 0) | 0 ? 1 : (D(Et | 0, It | 0), y = It | 0, 0)); } function Bt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(2) | 0 ? 1 : (At = w(y + 1 | 0) | 0, Et = y + 3 | 0, It = (y + 3 | 0) + (At | 0) | 0, z(At + 2 | 0) | 0 ? 1 : (D(Et | 0, It | 0), y = It | 0, 0)); } function wt(ot) { ot = ot | 0; var Et = 0, It = 0, At = 0; return z(4) | 0 ? 1 : (At = O(y + 1 | 0) | 0, Et = y + 5 | 0, It = (y + 5 | 0) + (At | 0) | 0, z(At + 4 | 0) | 0 ? 1 : (D(Et | 0, It | 0), y = It | 0, 0)); } function kt(ot) { return ot = ot | 0, 1; } function Wt(ot) { return ot = ot | 0, G(), y = y + 1 | 0, 0; } function Ct(ot) { return ot = ot | 0, x(ot - 128 | 0), y = y + 1 | 0, 0; } function Ft(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (x(c[y + 1 | 0] | 0), y = y + 2 | 0, 0); } function te(ot) { return ot = ot | 0, z(2) | 0 ? 1 : (x(w(y + 1 | 0) | 0), y = y + 3 | 0, 0); } function jt(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (M(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0), y = y + 5 | 0, 0); } function Kt(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (N(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0, w(y + 5 | 0) | 0, w(y + 7 | 0) | 0), y = y + 9 | 0, 0); } function re(ot) { return ot = ot | 0, k(), y = y + 1 | 0, 0; } function St(ot) { ot = ot | 0; var Et = 0; return Et = ot - 160 | 0, z(Et | 0) | 0 ? 1 : (T(Et | 0), y = y + 1 | 0, 0); } function Nt(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (T(c[y + 1 | 0] | 0), y = y + 2 | 0, 0); } function ne(ot) { return ot = ot | 0, z(2) | 0 ? 1 : (T(w(y + 1 | 0) | 0), y = y + 3 | 0, 0); } function Vt(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (B(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0), y = y + 5 | 0, 0); } function qt(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (P(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0, w(y + 5 | 0) | 0, w(y + 7 | 0) | 0), y = y + 9 | 0, 0); } function ee(ot) { return ot = ot | 0, S(), y = y + 1 | 0, 0; } function Ot(ot) { return ot = ot | 0, X(ot - 192 | 0 | 0), y = y + 1 | 0, 0; } function ft(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function gt(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function bt(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function _t(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function Lt(ot) { return ot = ot | 0, X(ot - 192 | 0 | 0), y = y + 1 | 0, 0; } function Pt(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function Mt(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function Yt(ot) { return ot | 0, X(ot | 0), y = y + 1 | 0, 0; } function Dt(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (X(c[y + 1 | 0] | 0), y = y + 2 | 0, 0); } function zt(ot) { return ot = ot | 0, z(2) | 0 ? 1 : (X(w(y + 1 | 0) | 0), y = y + 3 | 0, 0); } function he(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (Q(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0), y = y + 5 | 0, 0); } function Gt(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (K(w(y + 1 | 0) | 0, w(y + 3 | 0) | 0, w(y + 5 | 0) | 0, w(y + 7 | 0) | 0), y = y + 9 | 0, 0); } function Ut(ot) { return ot = ot | 0, W((ot | 0) - 224 | 0), y = y + 1 | 0, 0; } function de(ot) { return ot = ot | 0, p(), y = y + 1 | 0, 0; } function Zt(ot) { return ot = ot | 0, l(), y = y + 1 | 0, 0; } function Xt(ot) { return ot = ot | 0, b(), y = y + 1 | 0, 0; } function ie(ot) { return ot = ot | 0, g(), y = y + 1 | 0, 0; } function Qt(ot) { return ot = ot | 0, z(1) | 0 ? 1 : (W(c[y + 1 | 0] | 0), y = y + 2 | 0, 0); } function $t(ot) { ot = ot | 0; var Et = 0, It = 0, At = 1, ut = 0, et = 0, ht = 0; return z(2) | 0 ? 1 : (Et = c[y + 1 | 0] | 0, It = c[y + 2 | 0] | 0, (Et | 0) & 128 && (At = -1), ut = +(((Et | 0) & 124) >> 2), et = +(((Et | 0) & 3) << 8 | It), +ut == 0 ? o(+(+At * 5960464477539063e-23 * +et)) : +ut == 31 ? +At == 1 ? +et > 0 ? R() : I() : +et > 0 ? _() : v() : o(+(+At * $(2, +(+ut - 25)) * +(1024 + et))), y = y + 3 | 0, 0); } function ye(ot) { return ot = ot | 0, z(4) | 0 ? 1 : (h(c[y + 1 | 0] | 0, c[y + 2 | 0] | 0, c[y + 3 | 0] | 0, c[y + 4 | 0] | 0), y = y + 5 | 0, 0); } function se(ot) { return ot = ot | 0, z(8) | 0 ? 1 : (a(c[y + 1 | 0] | 0, c[y + 2 | 0] | 0, c[y + 3 | 0] | 0, c[y + 4 | 0] | 0, c[y + 5 | 0] | 0, c[y + 6 | 0] | 0, c[y + 7 | 0] | 0, c[y + 8 | 0] | 0), y = y + 9 | 0, 0); } function Ht(ot) { return ot = ot | 0, 1; } function dt(ot) { return ot = ot | 0, Y(), y = y + 1 | 0, 0; } var yt = [q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, q, H, V, J, Z, Ht, Ht, Ht, Ht, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, tt, nt, rt, it, st, Ht, Ht, Ht, Ht, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, at, ct, lt, pt, mt, Ht, Ht, Ht, Tt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, vt, Rt, Bt, wt, kt, Ht, Ht, Ht, Wt, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ct, Ft, te, jt, Kt, Ht, Ht, Ht, re, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, St, Nt, ne, Vt, qt, Ht, Ht, Ht, ee, Ot, Ot, Ot, Ot, Ot, Ot, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Lt, Dt, zt, he, Gt, Ht, Ht, Ht, Ht, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, Ut, de, Zt, Xt, ie, Qt, $t, ye, se, Ht, Ht, Ht, dt]; return { parse: U }; };
            }, function (E, m, f) {
                "use strict";
                const { URLWithLegacySupport: d, format: r } = f(265);
                E.exports = (e, c = {}, n = {}, t) => { let s, u = c.protocol ? c.protocol.replace(":", "") : "http"; u = (n[u] || t || u) + ":"; try {
                    s = new d(e);
                }
                catch (o) {
                    s = {};
                } const i = Object.assign({}, c, { protocol: u || s.protocol, host: c.host || s.host }); return new d(e, r(i)).toString(); };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), { URL: r } = f(264), e = f(30).BigNumber, c = f(156), n = f(113), t = n.MT, s = n.NUMBYTES, u = n.SHIFT32, i = n.SYMS, o = n.TAG, h = n.MT.SIMPLE_FLOAT << 5 | n.NUMBYTES.TWO, a = n.MT.SIMPLE_FLOAT << 5 | n.NUMBYTES.FOUR, l = n.MT.SIMPLE_FLOAT << 5 | n.NUMBYTES.EIGHT, p = n.MT.SIMPLE_FLOAT << 5 | n.SIMPLE.TRUE, g = n.MT.SIMPLE_FLOAT << 5 | n.SIMPLE.FALSE, b = n.MT.SIMPLE_FLOAT << 5 | n.SIMPLE.UNDEFINED, I = n.MT.SIMPLE_FLOAT << 5 | n.SIMPLE.NULL, v = new e("0x20000000000000"), R = d.from("f97e00", "hex"), _ = d.from("f9fc00", "hex"), k = d.from("f97c00", "hex");
                class x {
                    constructor(N) { N = N || {}, this.streaming = typeof N.stream == "function", this.onData = N.stream, this.semanticTypes = [[r, this._pushUrl], [e, this._pushBigNumber]]; const S = N.genTypes || [], T = S.length; for (let B = 0; B < T; B++)
                        this.addSemanticType(S[B][0], S[B][1]); this._reset(); }
                    addSemanticType(N, S) { const T = this.semanticTypes.length; for (let B = 0; B < T; B++)
                        if (this.semanticTypes[B][0] === N) {
                            const P = this.semanticTypes[B][1];
                            return this.semanticTypes[B][1] = S, P;
                        } return this.semanticTypes.push([N, S]), null; }
                    push(N) { return !N || (this.result[this.offset] = N, this.resultMethod[this.offset] = 0, this.resultLength[this.offset] = N.length, this.offset++, this.streaming && this.onData(this.finalize()), !0); }
                    pushWrite(N, S, T) { return this.result[this.offset] = N, this.resultMethod[this.offset] = S, this.resultLength[this.offset] = T, this.offset++, this.streaming && this.onData(this.finalize()), !0; }
                    _pushUInt8(N) { return this.pushWrite(N, 1, 1); }
                    _pushUInt16BE(N) { return this.pushWrite(N, 2, 2); }
                    _pushUInt32BE(N) { return this.pushWrite(N, 3, 4); }
                    _pushDoubleBE(N) { return this.pushWrite(N, 4, 8); }
                    _pushNaN() { return this.push(R); }
                    _pushInfinity(N) { const S = N < 0 ? _ : k; return this.push(S); }
                    _pushFloat(N) { const S = d.allocUnsafe(2); if (c.writeHalf(S, N) && c.parseHalf(S) === N)
                        return this._pushUInt8(h) && this.push(S); const T = d.allocUnsafe(4); return T.writeFloatBE(N, 0), T.readFloatBE(0) === N ? this._pushUInt8(a) && this.push(T) : this._pushUInt8(l) && this._pushDoubleBE(N); }
                    _pushInt(N, S, T) { const B = S << 5; return N < 24 ? this._pushUInt8(B | N) : N <= 255 ? this._pushUInt8(B | s.ONE) && this._pushUInt8(N) : N <= 65535 ? this._pushUInt8(B | s.TWO) && this._pushUInt16BE(N) : N <= 4294967295 ? this._pushUInt8(B | s.FOUR) && this._pushUInt32BE(N) : N <= Number.MAX_SAFE_INTEGER ? this._pushUInt8(B | s.EIGHT) && this._pushUInt32BE(Math.floor(N / u)) && this._pushUInt32BE(N % u) : S === t.NEG_INT ? this._pushFloat(T) : this._pushFloat(N); }
                    _pushIntNum(N) { return N < 0 ? this._pushInt(-N - 1, t.NEG_INT, N) : this._pushInt(N, t.POS_INT); }
                    _pushNumber(N) { switch (!1) {
                        case N == N: return this._pushNaN(N);
                        case isFinite(N): return this._pushInfinity(N);
                        case N % 1 != 0: return this._pushIntNum(N);
                        default: return this._pushFloat(N);
                    } }
                    _pushString(N) { const S = d.byteLength(N, "utf8"); return this._pushInt(S, t.UTF8_STRING) && this.pushWrite(N, 5, S); }
                    _pushBoolean(N) { return this._pushUInt8(N ? p : g); }
                    _pushUndefined(N) { return this._pushUInt8(b); }
                    _pushArray(N, S) { const T = S.length; if (!N._pushInt(T, t.ARRAY))
                        return !1; for (let B = 0; B < T; B++)
                        if (!N.pushAny(S[B]))
                            return !1; return !0; }
                    _pushTag(N) { return this._pushInt(N, t.TAG); }
                    _pushDate(N, S) { return N._pushTag(o.DATE_EPOCH) && N.pushAny(Math.round(S / 1e3)); }
                    _pushBuffer(N, S) { return N._pushInt(S.length, t.BYTE_STRING) && N.push(S); }
                    _pushNoFilter(N, S) { return N._pushBuffer(N, S.slice()); }
                    _pushRegexp(N, S) { return N._pushTag(o.REGEXP) && N.pushAny(S.source); }
                    _pushSet(N, S) { if (!N._pushInt(S.size, t.ARRAY))
                        return !1; for (const T of S)
                        if (!N.pushAny(T))
                            return !1; return !0; }
                    _pushUrl(N, S) { return N._pushTag(o.URI) && N.pushAny(S.format()); }
                    _pushBigint(N) { let S = o.POS_BIGINT; N.isNegative() && (N = N.negated().minus(1), S = o.NEG_BIGINT); let T = N.toString(16); T.length % 2 && (T = "0" + T); const B = d.from(T, "hex"); return this._pushTag(S) && this._pushBuffer(this, B); }
                    _pushBigNumber(N, S) { if (S.isNaN())
                        return N._pushNaN(); if (!S.isFinite())
                        return N._pushInfinity(S.isNegative() ? -1 / 0 : 1 / 0); if (S.isInteger())
                        return N._pushBigint(S); if (!N._pushTag(o.DECIMAL_FRAC) || !N._pushInt(2, t.ARRAY))
                        return !1; const T = S.decimalPlaces(), B = S.multipliedBy(new e(10).pow(T)); return !!N._pushIntNum(-T) && (B.abs().isLessThan(v) ? N._pushIntNum(B.toNumber()) : N._pushBigint(B)); }
                    _pushMap(N, S) { return !!N._pushInt(S.size, t.MAP) && this._pushRawMap(S.size, Array.from(S)); }
                    _pushObject(N) { if (!N)
                        return this._pushUInt8(I); for (var S = this.semanticTypes.length, T = 0; T < S; T++)
                        if (N instanceof this.semanticTypes[T][0])
                            return this.semanticTypes[T][1].call(N, this, N); var B = N.encodeCBOR; if (typeof B == "function")
                        return B.call(N, this); var P = Object.keys(N), L = P.length; return !!this._pushInt(L, t.MAP) && this._pushRawMap(L, P.map(j => [j, N[j]])); }
                    _pushRawMap(N, S) { S = S.map(function (B) { return B[0] = x.encode(B[0]), B; }).sort(c.keySorter); for (var T = 0; T < N; T++) {
                        if (!this.push(S[T][0]))
                            return !1;
                        if (!this.pushAny(S[T][1]))
                            return !1;
                    } return !0; }
                    write(N) { return this.pushAny(N); }
                    pushAny(N) { switch (function (S) { return {}.toString.call(S).slice(8, -1); }(N)) {
                        case "Number": return this._pushNumber(N);
                        case "String": return this._pushString(N);
                        case "Boolean": return this._pushBoolean(N);
                        case "Object": return this._pushObject(N);
                        case "Array": return this._pushArray(this, N);
                        case "Uint8Array": return this._pushBuffer(this, d.isBuffer(N) ? N : d.from(N));
                        case "Null": return this._pushUInt8(I);
                        case "Undefined": return this._pushUndefined(N);
                        case "Map": return this._pushMap(this, N);
                        case "Set": return this._pushSet(this, N);
                        case "URL": return this._pushUrl(this, N);
                        case "BigNumber": return this._pushBigNumber(this, N);
                        case "Date": return this._pushDate(this, N);
                        case "RegExp": return this._pushRegexp(this, N);
                        case "Symbol": switch (N) {
                            case i.NULL: return this._pushObject(null);
                            case i.UNDEFINED: return this._pushUndefined(void 0);
                            default: throw new Error("Unknown symbol: " + N.toString());
                        }
                        default: throw new Error("Unknown type: " + typeof N + ", " + (N ? N.toString() : ""));
                    } }
                    finalize() { if (this.offset === 0)
                        return null; for (var N = this.result, S = this.resultLength, T = this.resultMethod, B = this.offset, P = 0, L = 0; L < B; L++)
                        P += S[L]; var j = d.allocUnsafe(P), D = 0, G = 0; for (L = 0; L < B; L++) {
                        switch (G = S[L], T[L]) {
                            case 0:
                                N[L].copy(j, D);
                                break;
                            case 1:
                                j.writeUInt8(N[L], D, !0);
                                break;
                            case 2:
                                j.writeUInt16BE(N[L], D, !0);
                                break;
                            case 3:
                                j.writeUInt32BE(N[L], D, !0);
                                break;
                            case 4:
                                j.writeDoubleBE(N[L], D, !0);
                                break;
                            case 5:
                                j.write(N[L], D, G, "utf8");
                                break;
                            default: throw new Error("unkown method");
                        }
                        D += G;
                    } var W = j; return this._reset(), W; }
                    _reset() { this.result = [], this.resultMethod = [], this.resultLength = [], this.offset = 0; }
                    static encode(N) { const S = new x; if (!S.pushAny(N))
                        throw new Error("Failed to encode input"); return S.finalize(); }
                }
                E.exports = x;
            }, function (E, m, f) {
                "use strict";
                var d = f(556);
                E.exports = function (r) { if (!(r instanceof Object))
                    throw new TypeError('"obj" must be an object (or inherit from it)'); return function e(c, n) { for (var t in n = new d(c, n), c) {
                    var s = c[t];
                    if (s instanceof Object && (n.contains(s) || e(s, n)))
                        return !0;
                } return !1; }(r); };
            }, function (E, m, f) {
                "use strict";
                function d(r, e) { this.value = r, this.next = e; }
                E.exports = d, d.prototype.contains = function (r) { for (var e = this; e;) {
                    if (e.value === r)
                        return !0;
                    e = e.next;
                } return !1; };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(260);
                m.resolve = (c, n) => { let t = r.deserialize(c); const s = n.split("/").filter(Boolean); for (; s.length;) {
                    const u = s.shift();
                    if (t[u] === void 0)
                        throw new Error(`Object has no property '${u}'`);
                    if (t = t[u], d.isCID(t))
                        return { value: t, remainderPath: s.join("/") };
                } return { value: t, remainderPath: "" }; };
                const e = function* (c, n) { if (!(c instanceof Uint8Array || d.isCID(c) || typeof c == "string" || c === null))
                    for (const t of Object.keys(c)) {
                        const s = n === void 0 ? t : n + "/" + t;
                        yield s, yield* e(c[t], s);
                    } };
                m.tree = function* (c) { const n = r.deserialize(c); yield* e(n); };
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    const r = f(63), e = f(64), c = (f(65), f(90), f(116)), n = f(54), t = f(30).BigNumber, s = f(91), u = n.MT, i = n.NUMBYTES, o = n.SYMS;
                    function h(l) { return l > 1 ? "s" : ""; }
                    class a extends r.Transform {
                        constructor(p) { const g = Object.assign({ max_depth: 10 }, p, { readableObjectMode: !1, writableObjectMode: !1 }), b = g.max_depth; delete g.max_depth, super(g), this.depth = 1, this.max_depth = b, this.all = new s, this.parser = new c(g), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("start-string", this._on_start_string.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("error", this._on_error.bind(this)), this.parser.on("data", this._on_data.bind(this)), this.parser.bs.on("read", this._on_read.bind(this)); }
                        _transform(p, g, b) { this.parser.write(p, g, b); }
                        _flush(p) { return this.parser._flush(p); }
                        static comment(p, g, b) { if (p == null)
                            throw new Error("input required"); let I = typeof p == "string" ? "hex" : void 0, v = 10; switch (typeof g) {
                            case "function":
                                b = g;
                                break;
                            case "string":
                                I = g;
                                break;
                            case "number":
                                v = g;
                                break;
                            case "object":
                                const x = g.encoding, M = g.max_depth;
                                I = x !== null && x !== void 0 ? x : I, v = M !== null && M !== void 0 ? M : v;
                                break;
                            case "undefined": break;
                            default: throw new Error("Unknown option type");
                        } const R = new s, _ = new a({ max_depth: v }); let k = null; return typeof b == "function" ? (_.on("end", () => { b(null, R.toString("utf8")); }), _.on("error", b)) : k = new Promise((x, M) => (_.on("end", () => { x(R.toString("utf8")); }), _.on("error", M))), _.pipe(R), _.end(p, I), k; }
                        _on_error(p) {
                            return this.push("ERROR: ") && this.push(p.toString()) && this.push(`
`);
                        }
                        _on_read(p) { this.all.write(p); const g = p.toString("hex"); this.push(new Array(this.depth + 1).join("  ")), this.push(g); let b = 2 * (this.max_depth - this.depth); return b -= g.length, b < 1 && (b = 1), this.push(new Array(b + 1).join(" ")), this.push("-- "); }
                        _on_more(p, g, b, I) {
                            this.depth++;
                            let v = "";
                            switch (p) {
                                case u.POS_INT:
                                    v = "Positive number,";
                                    break;
                                case u.NEG_INT:
                                    v = "Negative number,";
                                    break;
                                case u.ARRAY:
                                    v = "Array, length";
                                    break;
                                case u.MAP:
                                    v = "Map, count";
                                    break;
                                case u.BYTE_STRING:
                                    v = "Bytes, length";
                                    break;
                                case u.UTF8_STRING:
                                    v = "String, length";
                                    break;
                                case u.SIMPLE_FLOAT: v = g === 1 ? "Simple value," : "Float,";
                            }
                            return this.push(v + " next " + g + " byte" + h(g) + `
`);
                        }
                        _on_start_string(p, g, b, I) {
                            this.depth++;
                            let v = "";
                            switch (p) {
                                case u.BYTE_STRING:
                                    v = "Bytes, length: " + g;
                                    break;
                                case u.UTF8_STRING: v = "String, length: " + g.toString();
                            }
                            return this.push(v + `
`);
                        }
                        _on_start(p, g, b, I) {
                            if (this.depth++, g !== o.BREAK)
                                switch (b) {
                                    case u.ARRAY:
                                        this.push(`[${I}], `);
                                        break;
                                    case u.MAP: I % 2 ? this.push(`{Val:${Math.floor(I / 2)}}, `) : this.push(`{Key:${Math.floor(I / 2)}}, `);
                                }
                            switch (p) {
                                case u.TAG:
                                    this.push("Tag #" + g);
                                    break;
                                case u.ARRAY:
                                    g === o.STREAM ? this.push("Array (streaming)") : this.push(`Array, ${g} item${h(g)}`);
                                    break;
                                case u.MAP:
                                    g === o.STREAM ? this.push("Map (streaming)") : this.push(`Map, ${g} pair${h(g)}`);
                                    break;
                                case u.BYTE_STRING:
                                    this.push("Bytes (streaming)");
                                    break;
                                case u.UTF8_STRING: this.push("String (streaming)");
                            }
                            return this.push(`
`);
                        }
                        _on_stop(p) { return this.depth--; }
                        _on_value(p, g, b, I) {
                            if (p !== o.BREAK)
                                switch (g) {
                                    case u.ARRAY:
                                        this.push(`[${b}], `);
                                        break;
                                    case u.MAP: b % 2 ? this.push(`{Val:${Math.floor(b / 2)}}, `) : this.push(`{Key:${Math.floor(b / 2)}}, `);
                                }
                            switch (p === o.BREAK ? this.push(`BREAK
`) : p === o.NULL ? this.push(`null
`) : p === o.UNDEFINED ? this.push(`undefined
`) : typeof p == "string" ? (this.depth--, p.length > 0 && (this.push(JSON.stringify(p)), this.push(`
`))) : d.isBuffer(p) ? (this.depth--, p.length > 0 && (this.push(p.toString("hex")), this.push(`
`))) : p instanceof t ? (this.push(p.toString()), this.push(`
`)) : (this.push(e.inspect(p)), this.push(`
`)), I) {
                                case i.ONE:
                                case i.TWO:
                                case i.FOUR:
                                case i.EIGHT: this.depth--;
                            }
                        }
                        _on_data() {
                            return this.push("0x"), this.push(this.all.read().toString("hex")), this.push(`
`);
                        }
                    }
                    E.exports = a;
                }).call(this, f(3).Buffer);
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                var d = f(115).Buffer, r = f(561);
                E.exports = function () { function e() { !function (c, n) { if (!(c instanceof n))
                    throw new TypeError("Cannot call a class as a function"); }(this, e), this.head = null, this.tail = null, this.length = 0; } return e.prototype.push = function (c) { var n = { data: c, next: null }; this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length; }, e.prototype.unshift = function (c) { var n = { data: c, next: this.head }; this.length === 0 && (this.tail = n), this.head = n, ++this.length; }, e.prototype.shift = function () { if (this.length !== 0) {
                    var c = this.head.data;
                    return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, c;
                } }, e.prototype.clear = function () { this.head = this.tail = null, this.length = 0; }, e.prototype.join = function (c) { if (this.length === 0)
                    return ""; for (var n = this.head, t = "" + n.data; n = n.next;)
                    t += c + n.data; return t; }, e.prototype.concat = function (c) { if (this.length === 0)
                    return d.alloc(0); if (this.length === 1)
                    return this.head.data; for (var n, t, s, u = d.allocUnsafe(c >>> 0), i = this.head, o = 0; i;)
                    n = i.data, t = u, s = o, n.copy(t, s), o += i.data.length, i = i.next; return u; }, e; }(), r && r.inspect && r.inspect.custom && (E.exports.prototype[r.inspect.custom] = function () { var e = r.inspect({ length: this.length }); return this.constructor.name + " " + e; });
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                E.exports = e;
                var d = f(272), r = Object.create(f(89));
                function e(c) { if (!(this instanceof e))
                    return new e(c); d.call(this, c); }
                r.inherits = f(15), r.inherits(e, d), e.prototype._transform = function (c, n, t) { t(null, c); };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(158);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(53);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(157).Transform;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(157).PassThrough;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { return d && typeof d == "object" && typeof d.copy == "function" && typeof d.fill == "function" && typeof d.readUInt8 == "function"; };
            }, function (E, m, f) {
                "use strict";
                typeof Object.create == "function" ? E.exports = function (d, r) { d.super_ = r, d.prototype = Object.create(r.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } }); } : E.exports = function (d, r) { d.super_ = r; var e = function () { }; e.prototype = r.prototype, d.prototype = new e, d.prototype.constructor = d; };
            }, function (E, m, f) {
                "use strict";
                const d = f(63), r = f(91), e = d.Transform;
                E.exports = class extends e {
                    constructor(c) { super(c), this._writableState.objectMode = !1, this._readableState.objectMode = !0, this.bs = new r, this.__restart(); }
                    _transform(c, n, t) { for (this.bs.write(c); this.bs.length >= this.__needed;) {
                        let s;
                        const u = this.__needed === null ? void 0 : this.bs.read(this.__needed);
                        try {
                            s = this.__parser.next(u);
                        }
                        catch (i) {
                            return t(i);
                        }
                        this.__needed && (this.__fresh = !1), s.done ? (this.push(s.value), this.__restart()) : this.__needed = s.value || 0;
                    } return t(); }
                    *_parse() { throw new Error("Must be implemented in subclass"); }
                    __restart() { this.__needed = null, this.__parser = this._parse(), this.__fresh = !0; }
                    _flush(c) { c(this.__fresh ? null : new Error("unexpected end of input")); }
                };
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e; !function (c) { m && m.nodeType, d && d.nodeType; var n = typeof r == "object" && r; n.global !== n && n.window !== n && n.self; var t, s = 2147483647, u = /^xn--/, i = /[^\x20-\x7E]/, o = /[\x2E\u3002\uFF0E\uFF61]/g, h = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, a = Math.floor, l = String.fromCharCode; function p(M) { throw new RangeError(h[M]); } function g(M, N) { for (var S = M.length, T = []; S--;)
                    T[S] = N(M[S]); return T; } function b(M, N) { var S = M.split("@"), T = ""; return S.length > 1 && (T = S[0] + "@", M = S[1]), T + g((M = M.replace(o, ".")).split("."), N).join("."); } function I(M) { for (var N, S, T = [], B = 0, P = M.length; B < P;)
                    (N = M.charCodeAt(B++)) >= 55296 && N <= 56319 && B < P ? (64512 & (S = M.charCodeAt(B++))) == 56320 ? T.push(((1023 & N) << 10) + (1023 & S) + 65536) : (T.push(N), B--) : T.push(N); return T; } function v(M) { return g(M, function (N) { var S = ""; return N > 65535 && (S += l((N -= 65536) >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), S += l(N); }).join(""); } function R(M, N) { return M + 22 + 75 * (M < 26) - ((N != 0) << 5); } function _(M, N, S) { var T = 0; for (M = S ? a(M / 700) : M >> 1, M += a(M / N); M > 455; T += 36)
                    M = a(M / 35); return a(T + 36 * M / (M + 38)); } function k(M) { var N, S, T, B, P, L, j, D, G, W, X, Q = [], K = M.length, F = 0, Y = 128, $ = 72; for ((S = M.lastIndexOf("-")) < 0 && (S = 0), T = 0; T < S; ++T)
                    M.charCodeAt(T) >= 128 && p("not-basic"), Q.push(M.charCodeAt(T)); for (B = S > 0 ? S + 1 : 0; B < K;) {
                    for (P = F, L = 1, j = 36; B >= K && p("invalid-input"), ((D = (X = M.charCodeAt(B++)) - 48 < 10 ? X - 22 : X - 65 < 26 ? X - 65 : X - 97 < 26 ? X - 97 : 36) >= 36 || D > a((s - F) / L)) && p("overflow"), F += D * L, !(D < (G = j <= $ ? 1 : j >= $ + 26 ? 26 : j - $)); j += 36)
                        L > a(s / (W = 36 - G)) && p("overflow"), L *= W;
                    $ = _(F - P, N = Q.length + 1, P == 0), a(F / N) > s - Y && p("overflow"), Y += a(F / N), F %= N, Q.splice(F++, 0, Y);
                } return v(Q); } function x(M) { var N, S, T, B, P, L, j, D, G, W, X, Q, K, F, Y, $ = []; for (Q = (M = I(M)).length, N = 128, S = 0, P = 72, L = 0; L < Q; ++L)
                    (X = M[L]) < 128 && $.push(l(X)); for (T = B = $.length, B && $.push("-"); T < Q;) {
                    for (j = s, L = 0; L < Q; ++L)
                        (X = M[L]) >= N && X < j && (j = X);
                    for (j - N > a((s - S) / (K = T + 1)) && p("overflow"), S += (j - N) * K, N = j, L = 0; L < Q; ++L)
                        if ((X = M[L]) < N && ++S > s && p("overflow"), X == N) {
                            for (D = S, G = 36; !(D < (W = G <= P ? 1 : G >= P + 26 ? 26 : G - P)); G += 36)
                                Y = D - W, F = 36 - W, $.push(l(R(W + Y % F, 0))), D = a(Y / F);
                            $.push(l(R(D, 0))), P = _(S, K, T == B), S = 0, ++T;
                        }
                    ++S, ++N;
                } return $.join(""); } t = { version: "1.4.1", ucs2: { decode: I, encode: v }, decode: k, encode: x, toASCII: function (M) { return b(M, function (N) { return i.test(N) ? "xn--" + x(N) : N; }); }, toUnicode: function (M) { return b(M, function (N) { return u.test(N) ? k(N.slice(4).toLowerCase()) : N; }); } }, (e = function () { return t; }.call(m, f, m, d)) === void 0 || (d.exports = e); }(); }).call(this, f(107)(E), f(10));
            }, function (E, m, f) {
                "use strict";
                E.exports = { isString: function (d) { return typeof d == "string"; }, isObject: function (d) { return typeof d == "object" && d !== null; }, isNull: function (d) { return d === null; }, isNullOrUndefined: function (d) { return d == null; } };
            }, function (E, m, f) {
                "use strict";
                m.decode = m.parse = f(573), m.encode = m.stringify = f(574);
            }, function (E, m, f) {
                "use strict";
                function d(r, e) { return Object.prototype.hasOwnProperty.call(r, e); }
                E.exports = function (r, e, c, n) { e = e || "&", c = c || "="; var t = {}; if (typeof r != "string" || r.length === 0)
                    return t; var s = /\+/g; r = r.split(e); var u = 1e3; n && typeof n.maxKeys == "number" && (u = n.maxKeys); var i = r.length; u > 0 && i > u && (i = u); for (var o = 0; o < i; ++o) {
                    var h, a, l, p, g = r[o].replace(s, "%20"), b = g.indexOf(c);
                    b >= 0 ? (h = g.substr(0, b), a = g.substr(b + 1)) : (h = g, a = ""), l = decodeURIComponent(h), p = decodeURIComponent(a), d(t, l) ? Array.isArray(t[l]) ? t[l].push(p) : t[l] = [t[l], p] : t[l] = p;
                } return t; };
            }, function (E, m, f) {
                "use strict";
                var d = function (r) { switch (typeof r) {
                    case "string": return r;
                    case "boolean": return r ? "true" : "false";
                    case "number": return isFinite(r) ? r : "";
                    default: return "";
                } };
                E.exports = function (r, e, c, n) { return e = e || "&", c = c || "=", r === null && (r = void 0), typeof r == "object" ? Object.keys(r).map(function (t) { var s = encodeURIComponent(d(t)) + c; return Array.isArray(r[t]) ? r[t].map(function (u) { return s + encodeURIComponent(d(u)); }).join(e) : s + encodeURIComponent(d(r[t])); }).join(e) : n ? encodeURIComponent(d(n)) + c + encodeURIComponent(d(r)) : ""; };
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    const r = f(63), e = f(64), c = f(116), n = (f(90), f(65)), t = f(54), s = f(30).BigNumber, u = f(91), i = t.MT, o = t.SYMS;
                    class h extends r.Transform {
                        constructor(l) {
                            const p = Object.assign({ separator: `
`, stream_errors: !1 }, l, { readableObjectMode: !1, writableObjectMode: !1 }), g = p.separator;
                            delete p.separator;
                            const b = p.stream_errors;
                            delete p.stream_errors, super(p), this.float_bytes = -1, this.separator = g, this.stream_errors = b, this.parser = new c(p), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("data", this._on_data.bind(this)), this.parser.on("error", this._on_error.bind(this));
                        }
                        _transform(l, p, g) { return this.parser.write(l, p, g); }
                        _flush(l) { return this.parser._flush(p => this.stream_errors ? (p && this._on_error(p), l()) : l(p)); }
                        static diagnose(l, p, g) { if (l == null)
                            throw new Error("input required"); let b = {}, I = "hex"; switch (typeof p) {
                            case "function":
                                g = p, I = n.guessEncoding(l);
                                break;
                            case "object":
                                b = n.extend({}, p), I = b.encoding != null ? b.encoding : n.guessEncoding(l), delete b.encoding;
                                break;
                            default: I = p !== null && p !== void 0 ? p : "hex";
                        } const v = new u, R = new h(b); let _ = null; return typeof g == "function" ? (R.on("end", () => g(null, v.toString("utf8"))), R.on("error", g)) : _ = new Promise((k, x) => (R.on("end", () => k(v.toString("utf8"))), R.on("error", x))), R.pipe(v), R.end(l, I), _; }
                        _on_error(l) { return this.stream_errors ? this.push(l.toString()) : this.emit("error", l); }
                        _on_more(l, p, g, b) { if (l === i.SIMPLE_FLOAT)
                            return this.float_bytes = { 2: 1, 4: 2, 8: 3 }[p]; }
                        _fore(l, p) { switch (l) {
                            case i.BYTE_STRING:
                            case i.UTF8_STRING:
                            case i.ARRAY:
                                if (p > 0)
                                    return this.push(", ");
                                break;
                            case i.MAP: if (p > 0)
                                return p % 2 ? this.push(": ") : this.push(", ");
                        } }
                        _on_value(l, p, g) { if (l !== o.BREAK)
                            return this._fore(p, g), this.push((() => { switch (!1) {
                                case l !== o.NULL: return "null";
                                case l !== o.UNDEFINED: return "undefined";
                                case typeof l != "string": return JSON.stringify(l);
                                case !(this.float_bytes > 0):
                                    const b = this.float_bytes;
                                    return this.float_bytes = -1, e.inspect(l) + "_" + b;
                                case !d.isBuffer(l): return "h'" + l.toString("hex") + "'";
                                case !(l instanceof s): return l.toString();
                                default: return e.inspect(l);
                            } })()); }
                        _on_start(l, p, g, b) { switch (this._fore(g, b), l) {
                            case i.TAG:
                                this.push(p + "(");
                                break;
                            case i.ARRAY:
                                this.push("[");
                                break;
                            case i.MAP:
                                this.push("{");
                                break;
                            case i.BYTE_STRING:
                            case i.UTF8_STRING: this.push("(");
                        } if (p === o.STREAM)
                            return this.push("_ "); }
                        _on_stop(l) { switch (l) {
                            case i.TAG: return this.push(")");
                            case i.ARRAY: return this.push("]");
                            case i.MAP: return this.push("}");
                            case i.BYTE_STRING:
                            case i.UTF8_STRING: return this.push(")");
                        } }
                        _on_data() { return this.push(this.separator); }
                    }
                    E.exports = h;
                }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(273), e = f(116), c = f(54).MT; class n extends Map {
                    constructor(s) { super(s); }
                    static _encode(s) { return r.encodeCanonical(s).toString("base64"); }
                    static _decode(s) { return e.decodeFirstSync(s, "base64"); }
                    get(s) { return super.get(n._encode(s)); }
                    set(s, u) { return super.set(n._encode(s), u); }
                    delete(s) { return super.delete(n._encode(s)); }
                    has(s) { return super.has(n._encode(s)); }
                    *keys() { for (const s of super.keys())
                        yield n._decode(s); }
                    *entries() { for (const s of super.entries())
                        yield [n._decode(s[0]), s[1]]; }
                    [Symbol.iterator]() { return this.entries(); }
                    forEach(s, u) { if (typeof s != "function")
                        throw new TypeError("Must be function"); for (const i of super.entries())
                        s.call(this, i[1], n._decode(i[0]), this); }
                    encodeCBOR(s) { if (!s._pushInt(this.size, c.MAP))
                        return !1; if (s.canonical) {
                        const u = Array.from(super.entries()).map(i => [d.from(i[0], "base64"), i[1]]);
                        u.sort((i, o) => i[0].compare(o[0]));
                        for (const i of u)
                            if (!s.push(i[0]) || !s.pushAny(i[1]))
                                return !1;
                    }
                    else
                        for (const u of super.entries())
                            if (!s.push(d.from(u[0], "base64")) || !s.pushAny(u[1]))
                                return !1; return !0; }
                } E.exports = n; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = f(87), { PinTypes: r } = d, e = f(162), { resolvePath: c } = f(23), n = f(2);
                function t(s, u, i) { const o = { type: s, cid: u }; return i && (o.metadata = i), o; }
                E.exports = ({ pinManager: s, dagReader: u }) => n(async function* (i = {}) { let o = r.all; if (i.type ? (o = i.type, typeof i.type == "string" && (o = i.type.toLowerCase()), d.checkPinType(o)) : i.type = r.all, i.paths) {
                    let h = !1;
                    for await (const { path: a } of e(i.paths)) {
                        const l = await c(u, a), { reason: p, pinned: g, parent: b, metadata: I } = await s.isPinnedWithType(l, o);
                        if (!g)
                            throw new Error(`path '${a}' is not pinned`);
                        switch (p) {
                            case r.direct:
                            case r.recursive:
                                h = !0, yield t(p, l, I);
                                break;
                            default: h = !0, yield t(`${r.indirect} through ${b}`, l, I);
                        }
                    }
                    if (!h)
                        throw new Error("No match found");
                }
                else {
                    if (o === r.recursive || o === r.all)
                        for await (const { cid: h, metadata: a } of s.recursiveKeys())
                            yield t(r.recursive, h, a);
                    if (o === r.indirect || o === r.all)
                        for await (const h of s.indirectKeys(i))
                            yield t(r.indirect, h);
                    if (o === r.direct || o === r.all)
                        for await (const { cid: h, metadata: a } of s.directKeys())
                            yield t(r.direct, h, a);
                } });
            }, function (E, m, f) {
                "use strict";
                const d = f(40);
                E.exports = ({ rmAll: r }) => async (e, c) => await d(r({ path: e, ...c }, c));
            }, function (E, m, f) {
                "use strict";
                const d = f(162), { resolvePath: r } = f(23), e = f(2), { PinTypes: c } = f(87);
                E.exports = ({ pinManager: n, gcLock: t, dagReader: s }) => e(async function* (u, i = {}) { const o = await t.readLock(); try {
                    for await (const { path: h, recursive: a } of d(u)) {
                        const l = await r(s, h), { pinned: p, reason: g } = await n.isPinnedWithType(l, c.all);
                        if (!p)
                            throw new Error(l + " is not pinned");
                        switch (g) {
                            case c.recursive:
                                if (!a)
                                    throw new Error(l + " is pinned recursively");
                                await n.unpin(l), yield l;
                                break;
                            case c.direct:
                                await n.unpin(l), yield l;
                                break;
                            default: throw new Error(`${l} is pinned indirectly under ${g}`);
                        }
                    }
                }
                finally {
                    o();
                } });
            }, function (E, m, f) {
                "use strict";
                const d = f(581), r = f(592), e = f(278), { NotInitializedError: c, AlreadyInitializedError: n } = f(111), t = f(1)("ipfs:components:ipns");
                E.exports = class {
                    constructor(s = {}) { this.options = s, this.offline = null, this.online = null; }
                    getIPNS() { const s = this.online || this.offline; if (s)
                        return s; throw new c; }
                    get routing() { return this.getIPNS().routing; }
                    startOffline({ repo: s, peerId: u, keychain: i }) { if (this.offline != null)
                        throw new n; t("initializing IPNS keyspace"); const o = new e(s), h = new d(o, s.datastore, u, i, this.options); this.offline = h; }
                    async startOnline({ libp2p: s, repo: u, peerId: i, keychain: o }) { if (this.online != null)
                        throw new n; const h = r({ libp2p: s, repo: u, peerId: i, options: this.options }), a = new d(h, u.datastore, i, o, this.options); await a.republisher.start(), this.online = a; }
                    async stop() { const s = this.online; s && (await s.republisher.stop(), this.online = null); }
                    publish(s, u, i) { return this.getIPNS().publish(s, u, i); }
                    resolve(s, u) { return this.getIPNS().resolve(s, u); }
                    initializeKeyspace(s, u) { return this.getIPNS().initializeKeyspace(s, u); }
                };
            }, function (E, m, f) {
                "use strict";
                const { createFromPrivKey: d } = f(7), r = f(0), e = f(1), c = Object.assign(e("ipfs:ipns"), { error: e("ipfs:ipns:error") }), n = f(582), t = f(590), s = f(591), { normalizePath: u } = f(23), i = f(258);
                E.exports = class {
                    constructor(o, h, a, l, p) { this.publisher = new n(o, h), this.republisher = new t(this.publisher, h, a, l, p), this.resolver = new s(o), this.cache = new i(1e3), this.routing = o; }
                    async publish(o, h, a = n.defaultRecordLifetime) { try {
                        h = u(h);
                        const l = await d(o.bytes);
                        await this.publisher.publishWithEOL(o, h, a), c(`IPNS value ${h} was published correctly`);
                        const p = l.toB58String(), g = parseFloat(a), b = g < 6e4 ? g : 6e4;
                        return this.cache.set(p, h, b), c(`IPNS value ${h} was cached correctly`), { name: p, value: h };
                    }
                    catch (l) {
                        throw c.error(l), l;
                    } }
                    async resolve(o, h = {}) { if (typeof o != "string")
                        throw r(new Error("name received is not valid"), "ERR_INVALID_NAME"); if (!h.nocache && !h.recursive) {
                        const a = o.split("/")[2], l = this.cache.get(a);
                        if (l)
                            return l;
                    } try {
                        const a = await this.resolver.resolve(o, h);
                        return c(`IPNS record from ${o} was resolved correctly`), a;
                    }
                    catch (a) {
                        throw c.error(a), a;
                    } }
                    async initializeKeyspace(o, h) { return this.publish(o, h, n.defaultRecordLifetime); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(7), { Key: r, Errors: e } = f(11), c = f(0), n = f(1), t = Object.assign(n("ipfs:ipns:publisher"), { error: n("ipfs:ipns:publisher:error") }), s = f(5), u = f(92), i = e.notFoundError().code;
                class o {
                    constructor(a, l) { this._routing = a, this._datastore = l; }
                    async publishWithEOL(a, l, p) { if (!a || !a.bytes)
                        throw c(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY"); const g = await d.createFromPrivKey(a.bytes), b = await this._updateOrCreateRecord(a, l, p, g); return this._putRecordToRouting(b, g); }
                    publish(a, l) { return this.publishWithEOL(a, l, 36e5); }
                    async _putRecordToRouting(a, l) { if (!d.isPeerId(l)) {
                        const I = "peerId received is not valid";
                        throw t.error(I), c(new Error(I), "ERR_INVALID_PEER_ID");
                    } const p = l._pubKey, g = await u.embedPublicKey(p, a), b = u.getIdKeys(l.toBytes()); return await this._publishEntry(b.routingKey, g || a), await this._publishPublicKey(b.routingPubKey, p), g || a; }
                    async _publishEntry(a, l) { if (!r.isKey(a)) {
                        const g = "datastore key does not have a valid format";
                        throw t.error(g), c(new Error(g), "ERR_INVALID_DATASTORE_KEY");
                    } let p; try {
                        p = u.marshal(l);
                    }
                    catch (g) {
                        throw t.error(g), g;
                    } try {
                        const g = await this._routing.put(a.uint8Array(), p);
                        return t(`ipns record for ${s(a.uint8Array(), "base64")} was stored in the routing`), g;
                    }
                    catch (g) {
                        const b = `ipns record for ${s(a.uint8Array(), "base64")} could not be stored in the routing`;
                        throw t.error(b), t.error(g), c(new Error(b), "ERR_PUTTING_TO_ROUTING");
                    } }
                    async _publishPublicKey(a, l) { if (!r.isKey(a)) {
                        const p = "datastore key does not have a valid format";
                        throw t.error(p), c(new Error(p), "ERR_INVALID_DATASTORE_KEY");
                    } if (!l || !l.bytes) {
                        const p = "one or more of the provided parameters are not defined";
                        throw t.error(p), c(new Error(p), "ERR_UNDEFINED_PARAMETER");
                    } try {
                        const p = await this._routing.put(a.uint8Array(), l.bytes);
                        return t(`public key for ${s(a.uint8Array(), "base64")} was stored in the routing`), p;
                    }
                    catch (p) {
                        const g = `public key for ${s(a.uint8Array(), "base64")} could not be stored in the routing`;
                        throw t.error(g), t.error(p), c(new Error(g), "ERR_PUTTING_TO_ROUTING");
                    } }
                    async _getPublished(a, l = {}) { if (!d.isPeerId(a)) {
                        const g = "peerId received is not valid";
                        throw t.error(g), c(new Error(g), "ERR_INVALID_PEER_ID");
                    } const p = l.checkRouting !== !1; try {
                        const g = await this._datastore.get(u.getLocalKey(a.id));
                        return this._unmarshalData(g);
                    }
                    catch (g) {
                        if (g.code !== i) {
                            const b = `unexpected error getting the ipns record ${a.id} from datastore`;
                            throw t.error(b), c(new Error(b), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
                        }
                        if (!p)
                            throw c(g);
                        try {
                            const b = u.getIdKeys(a.toBytes()), I = await this._routing.get(b.routingKey.uint8Array());
                            return this._unmarshalData(I);
                        }
                        catch (b) {
                            throw t.error(b), b;
                        }
                    } }
                    _unmarshalData(a) { try {
                        return u.unmarshal(a);
                    }
                    catch (l) {
                        throw c(l, "ERR_INVALID_RECORD_DATA");
                    } }
                    async _updateOrCreateRecord(a, l, p, g) { if (!d.isPeerId(g)) {
                        const _ = "peerId received is not valid";
                        throw t.error(_), c(new Error(_), "ERR_INVALID_PEER_ID");
                    } const b = { checkRouting: !0 }; let I; try {
                        I = await this._getPublished(g, b);
                    }
                    catch (_) {
                        if (_.code !== i) {
                            const k = `unexpected error when determining the last published IPNS record for ${g.id} ${_.stack}`;
                            throw t.error(k), c(new Error(k), "ERR_DETERMINING_PUBLISHED_RECORD");
                        }
                    } let v, R = 0; I && I.sequence !== void 0 && (R = I.value.toString() !== l ? I.sequence + 1 : I.sequence); try {
                        v = await u.create(a, l, R, p);
                    }
                    catch (_) {
                        const k = `ipns record for ${l} could not be created`;
                        throw t.error(_), c(new Error(k), "ERR_CREATING_IPNS_RECORD");
                    } try {
                        const _ = u.marshal(v);
                        return await this._datastore.put(u.getLocalKey(g.id), _), t(`ipns record for ${l} was stored in the datastore`), v;
                    }
                    catch (_) {
                        const k = `ipns record for ${l} could not be stored in the datastore`;
                        throw t.error(k), c(new Error(k), "ERR_STORING_IN_DATASTORE");
                    } }
                }
                o.defaultRecordLifetime = 36e5, E.exports = o;
            }, function (E, m, f) {
                "use strict";
                !function () {
                    E.exports = i;
                    var d = 100982246400, r = 864e13, e = 4294967296, c = Math.trunc || function (v) { var R = v - v % 1; return R === 0 && (v < 0 || v === 0 && 1 / v != 1 / 0) ? -0 : R; }, n = i.prototype;
                    i.fromDate = function (v) { return new i(+v); }, i.fromInt64BE = p(0, 1, 2, 3, 0, 4), i.fromInt64LE = p(3, 2, 1, 0, 4, 0), i.fromString = function (v) { var R, _ = new i, k = (v += "").replace(/^\s*[+\-]?\d+/, function (x) { var M = +x, N = 1970 + (M - 1970) % 400; return _.year = M - N, N; }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function (x, M, N) { return M < 0 && (N *= -1), R = 6e4 * (60 * +M + +N), ""; }).replace(/\.\d+$/, function (x) { return _.nano = +(x + "000000000").substr(1, 9), ""; }).split(/\D+/); if (k.length > 1 ? k[1]-- : k[1] = 0, _.time = R = Date.UTC.apply(Date, k) - (R || 0), isNaN(R))
                        throw new TypeError("Invalid Date"); return o(_); }, i.fromTimeT = function (v) { return a(v, 0); }, n.year = 0, n.time = 0, n.nano = 0, n.addNano = function (v) { return this.nano += +v || 0, this; }, n.getNano = function () { var v = o(this); return (v.time % 1e3 * 1e6 + +v.nano + 1e9) % 1e9; }, n.getTimeT = function () { var v = o(this), R = Math.floor(v.time / 1e3), _ = v.year; return _ && (R += 1168776 * _ * 86400 / 3200), R; }, n.getYear = function () { return this.toDate().getUTCFullYear() + this.year; }, n.toDate = function () { return h(o(this).time); }, n.toJSON = function () { return this.toString().replace(/0{1,6}Z$/, "Z"); }, n.toString = function (v) { var R = this, _ = R.toDate(), k = { H: function () { return b(_.getUTCHours()); }, L: function () { return I(_.getUTCMilliseconds(), 3); }, M: function () { return b(_.getUTCMinutes()); }, N: function () { return I(R.getNano(), 9); }, S: function () { return b(_.getUTCSeconds()); }, Y: function () { var x = R.getYear(); return x > 999999 ? "+" + x : x > 9999 ? "+" + I(x, 6) : x >= 0 ? I(x, 4) : x >= -999999 ? "-" + I(-x, 6) : x; }, a: function () { return s[_.getUTCDay()]; }, b: function () { return t[_.getUTCMonth()]; }, d: function () { return b(_.getUTCDate()); }, e: function () { return x = _.getUTCDate(), (x > 9 ? "" : " ") + (0 | x); var x; }, m: function () { return b(_.getUTCMonth() + 1); } }; return function x(M) { return M.replace(/%./g, function (N) { var S = N[1], T = u[S], B = k[S]; return T ? x(T) : B ? B() : N; }); }(v || "%Y-%m-%dT%H:%M:%S.%NZ"); }, n.writeInt64BE = l(0, 1, 2, 3, 0, 4), n.writeInt64LE = l(3, 2, 1, 0, 4, 0);
                    var t = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], s = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], u = { "%": "%", F: "%Y-%m-%d", n: `
`, R: "%H:%M", T: "%H:%M:%S", t: "	", X: "%T", Z: "GMT", z: "+0000" };
                    return i;
                    function i(v, R, _) { var k = this; if (!(k instanceof i))
                        return new i(v, R, _); k.time = +v || 0, k.nano = +R || 0, k.year = +_ || 0, o(k); }
                    function o(v) { var R, _, k = v.year, x = v.time, M = v.nano; if (M < 0 || 1e6 <= M) {
                        var N = Math.floor(M / 1e6);
                        M -= 1e6 * N, x += N, R = 1;
                    } var S = k % 3200; if (x < -r || r < x || S) {
                        (_ = c(x / 1009822464e5)) && (k += 3200 * _, x -= 1009822464e5 * _);
                        var T = h(x);
                        T.setUTCFullYear(S + T.getUTCFullYear());
                        var B = (x = +T) + 1009822464e5 * (_ = c((k -= S) / 3200));
                        _ && -r <= B && B <= r && (k -= 3200 * _, x = B), R = 1;
                    } return R && (v.year = k, v.time = x, v.nano = M), v; }
                    function h(v) { var R = new Date(0); return R.setTime(v), R; }
                    function a(v, R) { R |= 0, v = +v || 0; var _ = c((R *= e) / d) + c(v / d), k = R % d + v % d, x = c(k / d); return x && (_ += x, k -= x * d), new i(1e3 * k, 0, 3200 * _); }
                    function l(v, R, _, k, x, M) { return function (S, T) { var B = o(this); S || (S = new Array(8)), g(S, T |= 0); var P = Math.floor(B.time / 1e3), L = 31556952 * B.year, j = c(L / e) + c(P / e), D = L % e + P % e, G = Math.floor(D / e); return G && (j += G, D -= G * e), N(S, T + x, j), N(S, T + M, D), S; }; function N(S, T, B) { S[T + v] = B >> 24 & 255, S[T + R] = B >> 16 & 255, S[T + _] = B >> 8 & 255, S[T + k] = 255 & B; } }
                    function p(v, R, _, k, x, M) { return function (S, T) { g(S, T |= 0); var B = N(S, T + x); return a(N(S, T + M), B); }; function N(S, T) { return 16777216 * S[T + v] + (S[T + R] << 16 | S[T + _] << 8 | S[T + k]); } }
                    function g(v, R) { var _ = v && v.length; if (_ == null)
                        throw new TypeError("Invalid Buffer"); if (_ < R + 8)
                        throw new RangeError("Out of range"); }
                    function b(v) { return (v > 9 ? "" : "0") + (0 | v); }
                    function I(v, R) { return ("000000000" + (0 | v)).substr(-R); }
                }();
            }, function (E, m, f) {
                "use strict";
                const { encoding: d } = f(25), { TextEncoder: r } = f(80), e = new r;
                E.exports = function (c, n = "utf8") { return n === "utf8" || n === "utf-8" ? e.encode(c) : n === "ascii" ? function (t) { const s = new Uint8Array(t.length); for (let u = 0; u < t.length; u++)
                    s[u] = t.charCodeAt(u); return s; }(c) : d(n).decode(c); };
            }, function (E, m, f) {
                "use strict";
                const { encoding: d } = f(25), { TextDecoder: r } = f(80), e = new r("utf8");
                E.exports = function (c, n = "utf8") { return n === "utf8" || n === "utf-8" ? e.decode(c) : n === "ascii" ? function (t) { let s = ""; for (let u = 0; u < t.length; u++)
                    s += String.fromCharCode(t[u]); return s; }(c) : d(n).encode(c); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { r || (r = d.reduce((n, t) => n + t.length, 0)); const e = new Uint8Array(r); let c = 0; for (const n of d)
                    e.set(n, c), c += n.length; return e; };
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message IpnsEntry {
  enum ValidityType {
		EOL = 0; // setting an EOL says "this record is valid until..."
	}

  required bytes value = 1;
	required bytes signature = 2;

	optional ValidityType validityType = 3;
	optional bytes validity = 4;

	optional uint64 sequence = 5;

	optional uint64 ttl = 6;

	// in order for nodes to properly validate a record upon receipt, they need the public
	// key associated with it. For old RSA keys, its easiest if we just send this as part of
	// the record itself. For newer ed25519 keys, the public key can be embedded in the
	// peerID, making this field unnecessary.
	optional bytes pubKey = 7;
}
`).IpnsEntry;
            }, function (E, m, f) {
                "use strict";
                E.exports.toRFC3339 = d => `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, "0")}-${String(d.getUTCDate()).padStart(2, "0")}T${String(d.getUTCHours()).padStart(2, "0")}:${String(d.getUTCMinutes()).padStart(2, "0")}:${String(d.getUTCSeconds()).padStart(2, "0")}.${1e3 * d.getUTCMilliseconds() * 1e3}Z`, E.exports.parseRFC3339 = d => { const r = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"), e = String(d).trim().match(r); if (!e)
                    throw new Error("Invalid format"); const c = parseInt(e[1], 10), n = parseInt(e[2], 10) - 1, t = parseInt(e[3], 10), s = parseInt(e[4], 10), u = parseInt(e[5], 10), i = parseInt(e[6], 10), o = parseInt(e[7].slice(0, -6), 10); return new Date(Date.UTC(c, n, t, s, u, i, o)); };
            }, function (E, m, f) {
                "use strict";
                m.ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD", m.ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY", m.ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION", m.ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION", m.ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT", m.ERR_PEER_ID_FROM_PUBLIC_KEY = "ERR_PEER_ID_FROM_PUBLIC_KEY", m.ERR_PUBLIC_KEY_FROM_ID = "ERR_PUBLIC_KEY_FROM_ID", m.ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
            }, function (E, m, f) {
                "use strict";
                const d = f(92), r = f(39), e = f(7), c = f(0), n = f(1), t = Object.assign(n("ipfs:ipns:republisher"), { error: n("ipfs:ipns:republisher:error") });
                E.exports = class {
                    constructor(s, u, i, o, h = {}) { this._publisher = s, this._datastore = u, this._peerId = i, this._keychain = o, this._options = h, this._republishHandle = null; }
                    async start() { if (this._republishHandle)
                        throw c(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING"); const s = { _task: null, _inflightTask: null, _timeoutId: null, runPeriodically: h => { s._timeoutId = setTimeout(async () => { s._timeoutId = null; try {
                            s._inflightTask = s._task(), await s._inflightTask, s._task && s.runPeriodically(h);
                        }
                        catch (a) {
                            t.error(a);
                        } }, h()); }, cancel: async () => { s._timeoutId != null && clearTimeout(s._timeoutId), s._task = null, await s._inflightTask; } }, { privKey: u } = this._peerId, { pass: i } = this._options; let o = !0; s._task = () => this._republishEntries(u, i), s.runPeriodically(() => o ? (o = !1, this._options.initialBroadcastInterval || 6e4) : this._options.broadcastInterval || 144e5), this._republishHandle = s; }
                    async stop() { const s = this._republishHandle; if (!s)
                        throw c(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING"); this._republishHandle = null, await s.cancel(); }
                    async _republishEntries(s, u) { try {
                        await this._republishEntry(s);
                    }
                    catch (i) {
                        const o = "cannot republish entry for the node's private key";
                        return void t.error(o);
                    } if (u)
                        try {
                            const i = await this._keychain.listKeys();
                            for (const o of i) {
                                const h = await this._keychain.exportKey(o.name, u), a = await r.keys.import(h, u);
                                await this._republishEntry(a);
                            }
                        }
                        catch (i) {
                            t.error(i);
                        } }
                    async _republishEntry(s) { if (!s || !s.bytes)
                        throw c(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY"); try {
                        const u = await e.createFromPrivKey(s.bytes), i = await this._getPreviousValue(u);
                        await this._publisher.publishWithEOL(s, i, 864e5);
                    }
                    catch (u) {
                        if (u.code === "ERR_NO_ENTRY_FOUND")
                            return;
                        throw u;
                    } }
                    async _getPreviousValue(s) { if (!e.isPeerId(s))
                        throw c(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID"); try {
                        const u = await this._datastore.get(d.getLocalKey(s.id));
                        if (!(u instanceof Uint8Array))
                            throw c(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
                        try {
                            return d.unmarshal(u).value;
                        }
                        catch (i) {
                            throw t.error(i), c(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
                        }
                    }
                    catch (u) {
                        throw u && u.notFound ? c(new Error("no previous entry for record with id: " + s.id), "ERR_NO_ENTRY_FOUND") : u;
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(92), r = f(7), e = f(0), c = f(1), n = Object.assign(c("ipfs:ipns:resolver"), { error: c("ipfs:ipns:resolver:error") }), t = f(5), { Errors: s } = f(11), u = s.notFoundError().code;
                E.exports = class {
                    constructor(i) { this._routing = i; }
                    async resolve(i, o = {}) { if (typeof i != "string")
                        throw e(new Error("invalid name"), "ERR_INVALID_NAME"); const h = o.recursive && o.recursive.toString() === "true", a = i.split("/"); if (a.length !== 3 || a[0] !== "")
                        throw e(new Error("invalid name"), "ERR_INVALID_NAME"); const l = a[2]; let p; h && (p = 32); const g = await this.resolver(l, p); return n(i + " was locally resolved correctly"), g; }
                    async resolver(i, o) { if (o === 0) {
                        const l = "could not resolve name (recursion limit of 32 exceeded)";
                        throw n.error(l), e(new Error(l), "ERR_RESOLVE_RECURSION_LIMIT");
                    } const h = await this._resolveName(i), a = h.split("/"); return a[1] !== "ipfs" && o ? this.resolver(a[2], o - 1) : h; }
                    async _resolveName(i) { const o = r.createFromCID(i), { routingKey: h } = d.getIdKeys(o.toBytes()); let a, l; try {
                        a = await this._routing.get(h.uint8Array());
                    }
                    catch (p) {
                        throw n.error("could not get record from routing", p), p.code === u ? e(new Error(`record requested for ${i} was not found in the network`), "ERR_NO_RECORD_FOUND") : e(new Error("unexpected error getting the ipns record " + o.toString()), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
                    } try {
                        l = d.unmarshal(a);
                    }
                    catch (p) {
                        throw n.error("could not unmarshal record", p), e(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_RECORD_RECEIVED");
                    } return this._validateRecord(o, l); }
                    async _validateRecord(i, o) { const h = await d.extractPublicKey(i, o); return await d.validate(h, o), t(o.value); }
                };
            }, function (E, m, f) {
                "use strict";
                const { TieredDatastore: d } = f(163), r = f(164), e = f(277), c = f(278);
                E.exports = ({ libp2p: n, repo: t, peerId: s, options: u }) => { const i = []; let o; if (r(u, "EXPERIMENTAL.ipnsPubsub", !1)) {
                    const h = n.pubsub, a = t.datastore;
                    o = new e(h, a, s), i.push(o);
                } if (r(u, "offline") || !r(u, "libp2p.config.dht.enabled", !1)) {
                    const h = new c(t);
                    i.push(h);
                }
                else
                    i.push(n._dht); return new d(i); };
            }, function (E, m, f) {
                "use strict";
                const { Adapter: d, Key: r } = f(11), e = f(274), c = f(117), { utf8Encoder: n } = f(275), t = new r(e.SHARDING_FN), s = new r(e.README_FN);
                class u extends d {
                    constructor(o, h) { super(), this.child = new c(o, { convert: this._convertKey.bind(this), invert: this._invertKey.bind(this) }), this.shard = h; }
                    open() { return this.child.open(); }
                    _convertKey(o) { const h = o.toString(); return h === t.toString() || h === s.toString() ? o : new r(this.shard.fun(h)).child(o); }
                    _invertKey(o) { const h = o.toString(); return h === t.toString() || h === s.toString() ? o : r.withNamespaces(o.list().slice(1)); }
                    static async createOrOpen(o, h) { try {
                        await u.create(o, h);
                    }
                    catch (a) {
                        if (a && a.message !== "datastore exists")
                            throw a;
                    } return u.open(o); }
                    static async open(o) { const h = await e.readShardFun("/", o); return new u(o, h); }
                    static async create(o, h) {
                        if (!await o.has(t)) {
                            const p = typeof o.putRaw == "function" ? o.putRaw.bind(o) : o.put.bind(o);
                            return Promise.all([p(t, n.encode(h.toString() + `
`)), p(s, n.encode(e.readme))]);
                        }
                        const a = (await e.readShardFun("/", o) || "").toString(), l = h.toString();
                        throw a !== l ? new Error(`specified fun ${l} does not match repo shard fun ${a}`) : new Error("datastore exists");
                    }
                    put(o, h, a) { return this.child.put(o, h, a); }
                    get(o, h) { return this.child.get(o, h); }
                    has(o, h) { return this.child.has(o, h); }
                    delete(o, h) { return this.child.delete(o, h); }
                    batch() { return this.child.batch(); }
                    query(o, h) { const a = { keysOnly: o.keysOnly, offset: o.offset, limit: o.limit, filters: [l => l.key.toString() !== t.toString(), l => l.key.toString() !== s.toString()] }; if (o.prefix != null && a.filters.push(l => this._invertKey(l.key).toString().startsWith(o.prefix)), o.filters != null) {
                        const l = o.filters.map(p => g => p(Object.assign({}, g, { key: this._invertKey(g.key) })));
                        a.filters = a.filters.concat(l);
                    } return o.orders != null && (a.orders = o.orders.map(l => async (p) => { p.forEach(b => { b.key = this._invertKey(b.key); }); const g = await l(p); return g.forEach(b => { b.key = this._convertKey(b.key); }), g; })), this.child.query(a, h); }
                    close() { return this.child.close(); }
                }
                E.exports = u;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(276).TextEncoder;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(276).TextDecoder;
            }, function (E, m, f) {
                "use strict";
                E.exports = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`;
            }, function (E, m, f) {
                "use strict";
                const { Adapter: d, Key: r, Errors: e, utils: { filter: c, take: n, sortAll: t, replaceStartWith: s } } = f(11), u = f(117);
                E.exports = class extends d {
                    constructor(i) { super(), this.mounts = i.slice(); }
                    open() { return Promise.all(this.mounts.map(i => i.datastore.open())); }
                    _lookup(i) { for (const o of this.mounts)
                        if (o.prefix.toString() === i.toString() || o.prefix.isAncestorOf(i)) {
                            const h = s(i.toString(), o.prefix.toString());
                            return { datastore: o.datastore, mountpoint: o.prefix, rest: new r(h) };
                        } }
                    put(i, o, h) { const a = this._lookup(i); if (a == null)
                        throw e.dbWriteFailedError(new Error("No datastore mounted for this key")); return a.datastore.put(a.rest, o, h); }
                    get(i, o) { const h = this._lookup(i); if (h == null)
                        throw e.notFoundError(new Error("No datastore mounted for this key")); return h.datastore.get(h.rest, o); }
                    has(i, o) { const h = this._lookup(i); return h != null && h.datastore.has(h.rest, o); }
                    delete(i, o) { const h = this._lookup(i); if (h == null)
                        throw e.dbDeleteFailedError(new Error("No datastore mounted for this key")); return h.datastore.delete(h.rest, o); }
                    close() { return Promise.all(this.mounts.map(i => i.datastore.close())); }
                    batch() { const i = {}, o = h => { const a = this._lookup(h); if (a == null)
                        throw new Error("No datastore mounted for this key"); const l = a.mountpoint.toString(); return i[l] == null && (i[l] = a.datastore.batch()), { batch: i[l], rest: a.rest }; }; return { put: (h, a) => { const l = o(h); l.batch.put(l.rest, a); }, delete: h => { const a = o(h); a.batch.delete(a.rest); }, commit: h => Promise.all(Object.keys(i).map(a => i[a].commit(h))) }; }
                    query(i, o) { const h = this.mounts.map(p => { const g = new u(p.datastore, { convert: I => { throw new Error("should never be called"); }, invert: I => p.prefix.child(I) }); let b; return i.prefix != null && (b = s(i.prefix, p.prefix.toString())), g.query({ prefix: b, filters: i.filters, keysOnly: i.keysOnly }, o); }); let a = (l = h, async function* () { for (let p = 0; p < l.length; p++)
                        for await (const g of l[p])
                            yield g; }()); var l; if (i.filters && i.filters.forEach(p => { a = c(a, p); }), i.orders && i.orders.forEach(p => { a = t(a, p); }), i.offset != null) {
                        let p = 0;
                        a = c(a, () => p++ >= i.offset);
                    } return i.limit != null && (a = n(a, i.limit)), a; }
                };
            }, function (E, m, f) {
                "use strict";
                const { Adapter: d, Errors: r } = f(11), e = f(1)("datastore:core:tiered");
                E.exports = class extends d {
                    constructor(c) { super(), this.stores = c.slice(); }
                    async open() { try {
                        await Promise.all(this.stores.map(c => c.open()));
                    }
                    catch (c) {
                        throw r.dbOpenFailedError();
                    } }
                    async put(c, n) { try {
                        await Promise.all(this.stores.map(t => t.put(c, n)));
                    }
                    catch (t) {
                        throw r.dbWriteFailedError();
                    } }
                    async get(c, n) { for (const t of this.stores)
                        try {
                            const s = await t.get(c, n);
                            if (s)
                                return s;
                        }
                        catch (s) {
                            e(s);
                        } throw r.notFoundError(); }
                    async has(c, n) { for (const t of this.stores)
                        if (await t.has(c, n))
                            return !0; return !1; }
                    async delete(c, n) { try {
                        await Promise.all(this.stores.map(t => t.delete(c, n)));
                    }
                    catch (t) {
                        throw r.dbDeleteFailedError();
                    } }
                    async close() { await Promise.all(this.stores.map(c => c.close())); }
                    batch() { const c = this.stores.map(n => n.batch()); return { put: (n, t) => { c.forEach(s => s.put(n, t)); }, delete: n => { c.forEach(t => t.delete(n)); }, commit: async (n) => { for (const t of c)
                            await t.commit(n); } }; }
                    query(c, n) { return this.stores[this.stores.length - 1].query(c, n); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, r = f(117);
                E.exports = class extends r {
                    constructor(e, c) { super(e, { convert: n => c.child(n), invert(n) { if (c.toString() === "/")
                            return n; if (!c.isAncestorOf(n))
                            throw new Error(`Expected prefix: (${c.toString()}) in key: ${n.toString()}`); return new d(n.toString().slice(c.toString().length), !1); } }), this.prefix = c; }
                    query(e) { return e.prefix && this.prefix.toString() !== "/" ? super.query(Object.assign({}, e, { prefix: this.prefix.child(new d(e.prefix)).toString() })) : super.query(e); }
                };
            }, function (E, m, f) {
                "use strict";
                const { Key: d, Adapter: r } = f(11), { encodeBase32: e, keyToTopic: c, topicToKey: n } = f(601), t = f(0), s = f(1), u = s("datastore-pubsub:publisher");
                u.error = s("datastore-pubsub:publisher:error"), E.exports = class extends r {
                    constructor(i, o, h, a, l) { if (super(), !a)
                        throw t(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS"); if (typeof a.validate != "function")
                        throw t(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS"); if (typeof a.select != "function")
                        throw t(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS"); if (l && typeof l != "function")
                        throw t(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS"); this._pubsub = i, this._datastore = o, this._peerId = h, this._validator = a, this._handleSubscriptionKeyFn = l, this._onMessage = this._onMessage.bind(this); }
                    async put(i, o) { if (!(i instanceof Uint8Array)) {
                        const a = "datastore key does not have a valid format";
                        throw u.error(a), t(new Error(a), "ERR_INVALID_DATASTORE_KEY");
                    } if (!(o instanceof Uint8Array)) {
                        const a = "received value is not a Uint8Array";
                        throw u.error(a), t(new Error(a), "ERR_INVALID_VALUE_RECEIVED");
                    } const h = c(i); return u("publish value for topic " + h), this._pubsub.publish(h, o); }
                    async get(i) { if (!(i instanceof Uint8Array)) {
                        const a = "datastore key does not have a valid format";
                        throw u.error(a), t(new Error(a), "ERR_INVALID_DATASTORE_KEY");
                    } const o = c(i), h = await this._pubsub.getTopics(); if (h && Array.isArray(h) && h.indexOf(o) > -1)
                        return this._getLocal(i); try {
                        await this._pubsub.subscribe(o, this._onMessage);
                    }
                    catch (a) {
                        const l = "cannot subscribe topic " + o;
                        throw u.error(l), t(new Error(l), "ERR_SUBSCRIBING_TOPIC");
                    } return u("subscribed values for key " + o), this._getLocal(i); }
                    unsubscribe(i) { const o = c(i); return this._pubsub.unsubscribe(o, this._onMessage); }
                    async _getLocal(i) { const o = new d("/" + e(i), !1); let h; try {
                        h = await this._datastore.get(o);
                    }
                    catch (a) {
                        if (a.code !== "ERR_NOT_FOUND") {
                            const p = "unexpected error getting the ipns record for " + o.toString();
                            throw u.error(p), t(new Error(p), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
                        }
                        const l = "local record requested was not found for " + o.toString();
                        throw u.error(l), t(new Error(l), "ERR_NOT_FOUND");
                    } if (!(h instanceof Uint8Array)) {
                        const a = "found record that we couldn't convert to a value";
                        throw u.error(a), t(new Error(a), "ERR_INVALID_RECORD_RECEIVED");
                    } return h; }
                    async _onMessage(i) { const { data: o, from: h, topicIDs: a } = i; let l; try {
                        l = n(a[0]);
                    }
                    catch (p) {
                        return void u.error(p);
                    } if (u("message received for topic " + a[0]), h !== this._peerId.toB58String()) {
                        if (this._handleSubscriptionKeyFn) {
                            let p;
                            try {
                                p = await this._handleSubscriptionKeyFn(l);
                            }
                            catch (g) {
                                return void u.error("message discarded by the subscriptionKeyFn");
                            }
                            l = p;
                        }
                        try {
                            await this._storeIfSubscriptionIsBetter(l, o);
                        }
                        catch (p) {
                            u.error(p);
                        }
                    }
                    else
                        u("message discarded as it is from the same peer"); }
                    async _storeIfSubscriptionIsBetter(i, o) { let h = !1; try {
                        h = await this._isBetter(i, o);
                    }
                    catch (a) {
                        if (a.code !== "ERR_NOT_VALID_RECORD")
                            throw a;
                    } h && await this._storeRecord(i, o); }
                    async _validateRecord(i, o) { return this._validator.validate(i, o); }
                    async _selectRecord(i, o) { return await this._validator.select(i, o) === 0; }
                    async _isBetter(i, o) { let h, a; try {
                        a = await this._validateRecord(o, i);
                    }
                    catch (g) {
                        h = g;
                    } if (h || !a) {
                        const g = "record received through pubsub is not valid";
                        throw u.error(g), t(new Error(g), "ERR_NOT_VALID_RECORD");
                    } const l = new d(i); let p; try {
                        p = await this._getLocal(l.uint8Array());
                    }
                    catch (g) {
                        return !0;
                    } return !p.equals(o) && this._selectRecord(o, p); }
                    async _storeRecord(i, o) { const h = new d("/" + e(i), !1); await this._datastore.put(h, o), u(`record for ${c(i)} was stored in the datastore`); }
                    open() { const i = "open function was not implemented yet"; throw u.error(i), t(new Error(i), "ERR_NOT_IMPLEMENTED_YET"); }
                    has(i) { const o = "has function was not implemented yet"; throw u.error(o), t(new Error(o), "ERR_NOT_IMPLEMENTED_YET"); }
                    delete(i) { const o = "delete function was not implemented yet"; throw u.error(o), t(new Error(o), "ERR_NOT_IMPLEMENTED_YET"); }
                    close() { const i = "close function was not implemented yet"; throw u.error(i), t(new Error(i), "ERR_NOT_IMPLEMENTED_YET"); }
                    batch() { const i = "batch function was not implemented yet"; throw u.error(i), t(new Error(i), "ERR_NOT_IMPLEMENTED_YET"); }
                    query() { const i = "query function was not implemented yet"; throw u.error(i), t(new Error(i), "ERR_NOT_IMPLEMENTED_YET"); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(5), e = f(6);
                E.exports.encodeBase32 = c => r(c, "base32"), E.exports.keyToTopic = c => ((typeof c == "string" || c instanceof String) && (c = e(c)), "/record/" + r(c, "base64url")), E.exports.topicToKey = c => { if (c.substring(0, "/record/".length) !== "/record/")
                    throw d(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE"); const n = c.substring("/record/".length); return e(n, "base64url"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(21)(f(603)).Record, r = f(604);
                class e {
                    constructor(n, t, s) { if (!(n instanceof Uint8Array))
                        throw new Error("key must be a Uint8Array"); if (!(t instanceof Uint8Array))
                        throw new Error("value must be a Uint8Array"); this.key = n, this.value = t, this.timeReceived = s; }
                    serialize() { return d.encode(this.prepareSerialize()); }
                    prepareSerialize() { return { key: this.key, value: this.value, timeReceived: this.timeReceived && r.toRFC3339(this.timeReceived) }; }
                    static deserialize(n) { const t = d.decode(n); return e.fromDeserialized(t); }
                    static fromDeserialized(n) { let t; return n.timeReceived && (t = r.parseRFC3339(n.timeReceived)), new e(n.key, n.value, t); }
                }
                E.exports = e;
            }, function (E, m, f) {
                "use strict";
                E.exports = `// Record represents a dht record that contains a value
// for a key value pair
message Record {
  // The key that references this record
  bytes key = 1;

  // The actual value this record is storing
  bytes value = 2;

  // Note: These fields were removed from the Record message
  // hash of the authors public key
  // optional bytes author = 3;
  // A PKI signature for the key+value+author
  // optional bytes signature = 4;

  // Time the record was received, set by receiver
  optional string timeReceived = 5;
}`;
            }, function (E, m, f) {
                "use strict";
                E.exports.toRFC3339 = d => `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, "0")}-${String(d.getUTCDate()).padStart(2, "0")}T${String(d.getUTCHours()).padStart(2, "0")}:${String(d.getUTCMinutes()).padStart(2, "0")}:${String(d.getUTCSeconds()).padStart(2, "0")}.${1e3 * d.getUTCMilliseconds() * 1e3}Z`, E.exports.parseRFC3339 = d => { const r = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"), e = String(d).trim().match(r); if (!e)
                    throw new Error("Invalid format"); const c = parseInt(e[1], 10), n = parseInt(e[2], 10) - 1, t = parseInt(e[3], 10), s = parseInt(e[4], 10), u = parseInt(e[5], 10), i = parseInt(e[6], 10), o = parseInt(e[7].slice(0, -6), 10); return new Date(Date.UTC(c, n, t, s, u, i, o)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(5);
                E.exports = { verifyRecord: (e, c) => { const n = c.key, t = r(n).split("/"); if (t.length < 3)
                        return; const s = e[t[1].toString()]; if (!s)
                        throw d(new Error("Invalid record keytype"), "ERR_INVALID_RECORD_KEY_TYPE"); return s.func(n, c.value); }, validators: f(606) };
            }, function (E, m, f) {
                "use strict";
                E.exports = { pk: f(607) };
            }, function (E, m, f) {
                "use strict";
                const d = f(16), r = f(0), e = f(5), c = f(20);
                E.exports = { func: async (n, t) => { if (!(n instanceof Uint8Array))
                        throw r(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER"); if (n.byteLength < 5)
                        throw r(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT"); if (e(n.subarray(0, 4)) !== "/pk/")
                        throw r(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX"); const s = n.slice(4), u = await d(t, "sha2-256"); if (!c(s, u))
                        throw r(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH"); }, sign: !1 };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(5);
                E.exports = { bestRecord: (e, c, n) => { if (n.length === 0)
                        throw d(new Error("No records given"), "ERR_NO_RECORDS_RECEIVED"); const t = r(c).split("/"); if (t.length < 3)
                        throw d(new Error("Record key does not have a selector function"), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY"); const s = e[t[1].toString()]; if (!s) {
                        const u = "Unrecognized key prefix: " + t[1];
                        throw d(new Error(u), "ERR_UNRECOGNIZED_KEY_PREFIX");
                    } return s(c, n); }, selectors: f(609) };
            }, function (E, m, f) {
                "use strict";
                E.exports = { pk: f(610) };
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r) => 0;
            }, function (E, m, f) {
                "use strict";
                const d = f(612), r = f(614), e = f(616);
                E.exports = class {
                    constructor({ dns: c, ipns: n, dagReader: t, peerId: s, isOnline: u, keychain: i, options: o }) { this.publish = d({ ipns: n, dagReader: t, peerId: s, isOnline: u, keychain: i }), this.resolve = r({ dns: c, ipns: n, peerId: s, isOnline: u, options: o }), this.pubsub = new e({ ipns: n, options: o.EXPERIMENTAL }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(153).default, e = f(39), c = f(0), n = Object.assign(d("ipfs:name:publish"), { error: d("ipfs:name:publish:error") }), { OFFLINE_ERROR: t, normalizePath: s } = f(23), u = f(2), { resolvePath: i } = f(613);
                E.exports = ({ ipns: o, dagReader: h, peerId: a, isOnline: l, keychain: p }) => { const g = async (b) => { if (b === "self")
                    return a.privKey; try {
                    const I = await p.exportKey(b, "temp");
                    return await e.keys.import(I, "temp");
                }
                catch (I) {
                    throw n.error(I), c(I, "ERR_CANNOT_GET_KEY");
                } }; return u(async function (b, I = {}) { const v = !(I.resolve === !1), R = I.lifetime || "24h", _ = I.key || "self"; if (!l())
                    throw c(new Error(t), "OFFLINE_ERROR"); try {
                    b = s(b);
                }
                catch (M) {
                    throw n.error(M), M;
                } let k = 0; try {
                    k = r(R) || 0, k = parseFloat(k.toFixed(6));
                }
                catch (M) {
                    throw n.error(M), M;
                } const x = await Promise.all([g(_), v ? i({ ipns: o, dagReader: h }, b) : Promise.resolve()]); return o.publish(x[0], b, k); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(52);
                m.resolvePath = ({ ipns: r, dagReader: e }, c) => d.ipnsPath(c) ? r.resolve(c) : e.get(c.substring("/ipfs/".length));
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(0), { mergeOptions: e } = f(23), c = f(4), n = f(615), t = Object.assign(d("ipfs:name:resolve"), { error: d("ipfs:name:resolve:error") }), { OFFLINE_ERROR: s } = f(23), u = f(2), i = (o, h) => h.length > 0 ? o + "/" + h.join("/") : o;
                E.exports = ({ dns: o, ipns: h, peerId: a, isOnline: l, options: { offline: p } }) => u(async function* (g, b = {}) { if (b = e({ nocache: !1, recursive: !0 }, b), p && b && b.nocache)
                    throw r(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE"); g || (g = a.toB58String()), g.startsWith("/ipns/") || (g = "/ipns/" + g); const [I, v, ...R] = g.slice(1).split("/"); try {
                    new c(v);
                }
                catch (_) {
                    if (n(v))
                        return void (yield i(await o(v, b), R));
                    throw t.error(_), r(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
                } if (!l() && !p)
                    throw r(new Error(s), "OFFLINE_ERROR"); yield i(await h.resolve(`/${I}/${v}`, b), R); });
            }, function (E, m, f) {
                "use strict";
                var d = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
                E.exports = function (r, e) { if (e == null && (e = !1), r.length < 2)
                    return !1; if (r.length > 255)
                    return !1; var c = r[r.length - 1]; if (e) {
                    if (c !== ".")
                        return !1;
                }
                else if (c === ".")
                    return !1; return d.test(r); };
            }, function (E, m, f) {
                "use strict";
                const d = f(617), r = f(618), e = f(619);
                E.exports = class {
                    constructor({ ipns: c, options: n }) { this.cancel = d({ ipns: c, options: n }), this.state = r({ ipns: c, options: n }), this.subs = e({ ipns: c, options: n }); }
                };
            }, function (E, m, f) {
                "use strict";
                const { getPubsubRouting: d } = f(165), r = f(2);
                E.exports = ({ ipns: e, options: c }) => r(async function (n, t) { return d(e, c).cancel(n, t); });
            }, function (E, m, f) {
                "use strict";
                const { getPubsubRouting: d } = f(165), r = f(2);
                E.exports = ({ ipns: e, options: c }) => r(async function (n) { try {
                    return { enabled: Boolean(d(e, c)) };
                }
                catch (t) {
                    return { enabled: !1 };
                } });
            }, function (E, m, f) {
                "use strict";
                const { getPubsubRouting: d } = f(165), r = f(2);
                E.exports = ({ ipns: e, options: c }) => r(async function (n) { return d(e, c).getSubscriptions(n); });
            }, function (E, m, f) {
                "use strict";
                const d = f(52), r = f(4), { DAGNode: e } = f(17), { normalizeCidPath: c } = f(23), { Errors: n } = f(11), t = n.notFoundError().code, s = f(2), u = { default: "<dst>", edges: "<src> -> <dst>" };
                async function* i(h, a, l, p) { const g = (await h(l)).split("/")[2]; for await (const b of async function* (I, v, R, _) { const k = new Set; yield* async function* x(M, N) { const S = N + 1; if (!(S > R))
                    try {
                        for (const T of await async function (B, P) { const L = await B.get(new r(P)); return e.isDAGNode(L) ? L.Links.map(({ Name: j, Hash: D }) => ({ name: j, cid: new r(D) })) : function j(D, G = "") { let W = []; for (const [X, Q] of Object.entries(D))
                            r.isCID(Q) ? W.push({ name: G + X, cid: Q }) : typeof Q == "object" && (W = W.concat(j(Q, G + X + "/"))); return W; }(L); }(I, M.cid))
                            yield { parent: M, node: T, isDuplicate: _ && k.has(T.cid.toString()) }, _ && k.add(T.cid.toString()), yield* x(T, S);
                    }
                    catch (T) {
                        throw T.code === t && (T.message = "Could not find object with CID: " + M.cid), T;
                    } }({ cid: v }, 0); }(a, g, p.maxDepth, p.unique))
                    b.parent && (b.isDuplicate || (yield { ref: o(b.parent.cid, b.node.cid, b.node.name, p.format) })); }
                function o(h, a, l, p) { let g = p.replace(/<src>/g, h.toString()); return g = g.replace(/<dst>/g, a.toString()), g = g.replace(/<linkname>/g, l), g; }
                E.exports = function ({ ipld: h, resolve: a, preload: l }) { return s(async function* (p, g = {}) { if (g.maxDepth === 0)
                    return; if (g.edges && g.format && g.format !== u.default)
                    throw new Error("Cannot set edges to true and also specify format"); g.format = g.edges ? u.edges : g.format || u.default, typeof g.maxDepth != "number" && (g.maxDepth = g.recursive ? 1 / 0 : 1); const b = (Array.isArray(p) ? p : [p]).map(I => function (v, R, _) { const k = c(R), x = k.split("/")[0]; if (!d.cid(x))
                    throw new Error(`Error resolving path '${k}': '${x}' is not a valid CID`); return _.preload !== !1 && v(x), "/ipfs/" + k; }(l, I, g)); for (const I of b)
                    yield* i(a, h, I, g); }); }, E.exports.Format = u;
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = function ({ repo: r }) { return d(async function* (e = {}) { for await (const c of r.blocks.query({ keysOnly: !0, signal: e.signal }))
                    yield { ref: c.toString() }; }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(623), r = f(624), e = f(625), c = f(280);
                E.exports = class {
                    constructor({ network: n }) { this.wantlist = d({ network: n }), this.wantlistForPeer = r({ network: n }), this.unwant = e({ network: n }), this.stat = c({ network: n }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ network: r }) => d(async function (e = {}) { const { bitswap: c } = await r.use(e), n = c.getWantlist(e); return Array.from(n).map(t => t[1].cid); });
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(2);
                E.exports = ({ network: e }) => r(async function (c, n = {}) { const { bitswap: t } = await e.use(n), s = t.wantlistForPeer(d.createFromCID(c), n); return Array.from(s).map(u => u[1].cid); });
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), e = f(2);
                E.exports = ({ network: c }) => e(async function (n, t) { const { bitswap: s } = await c.use(t); Array.isArray(n) || (n = [n]); try {
                    n = n.map(u => new d(u));
                }
                catch (u) {
                    throw r(u, "ERR_INVALID_CID");
                } return s.unwant(n, t); });
            }, function (E, m, f) {
                "use strict";
                const d = f(627), r = f(628), e = f(629), c = f(630), n = f(631);
                E.exports = class {
                    constructor({ repo: t }) { this.add = d({ repo: t }), this.list = e({ repo: t }), this.rm = n({ repo: t }), this.clear = r({ repo: t }), this.reset = c({ repo: t }); }
                };
            }, function (E, m, f) {
                "use strict";
                const { isValidMultiaddr: d } = f(281), r = f(2);
                E.exports = ({ repo: e }) => r(async function (c, n = {}) { if (!d(c))
                    throw new Error(c + " is not a valid Multiaddr"); const t = await e.config.getAll(n); return t.Bootstrap.indexOf(c.toString()) === -1 && t.Bootstrap.push(c.toString()), await e.config.replace(t), { Peers: [c] }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(2), r = f(13);
                E.exports = ({ repo: e }) => d(async function (c = {}) { const n = await e.config.getAll(c), t = n.Bootstrap || []; return n.Bootstrap = [], await e.config.replace(n), { Peers: t.map(s => new r(s)) }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(2), r = f(13);
                E.exports = ({ repo: e }) => d(async function (c) { return { Peers: (await e.config.get("Bootstrap", c) || []).map(n => new r(n)) }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(166), r = f(2), e = f(13);
                E.exports = ({ repo: c }) => r(async function (n = {}) { const t = await c.config.getAll(n); return t.Bootstrap = d().Bootstrap, await c.config.replace(t), { Peers: d().Bootstrap.map(s => new e(s)) }; });
            }, function (E, m, f) {
                "use strict";
                const { isValidMultiaddr: d } = f(281), r = f(2);
                E.exports = ({ repo: e }) => r(async function (c, n = {}) { if (!d(c))
                    throw new Error(c + " is not a valid Multiaddr"); const t = await e.config.getAll(n); return t.Bootstrap = (t.Bootstrap || []).filter(s => s.toString() !== c.toString()), await e.config.replace(t), { Peers: [c] }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(633), r = f(634), e = f(636), c = f(637);
                E.exports = class {
                    constructor({ blockService: n, preload: t, gcLock: s, pinManager: u, pin: i }) { this.get = d({ blockService: n, preload: t }), this.put = r({ blockService: n, preload: t, gcLock: s, pin: i }), this.rm = e({ blockService: n, gcLock: s, pinManager: u }), this.stat = c({ blockService: n, preload: t }); }
                };
            }, function (E, m, f) {
                "use strict";
                const { cleanCid: d } = f(167), r = f(2);
                E.exports = ({ blockService: e, preload: c }) => r(async function (n, t = {}) { return n = d(n), t.preload !== !1 && c(n), e.get(n, t); });
            }, function (E, m, f) {
                "use strict";
                const d = f(93), r = f(16), e = f(4), c = f(52), n = f(2);
                E.exports = ({ blockService: t, pin: s, gcLock: u, preload: i }) => n(async function (o, h = {}) { if (Array.isArray(o))
                    throw new Error("Array is not supported"); if (!d.isBlock(o)) {
                    const l = o;
                    if (h.cid && c.cid(h.cid)) {
                        const p = e.isCID(h.cid) ? h.cid : new e(h.cid);
                        o = new d(l, p);
                    }
                    else {
                        const p = h.mhtype || "sha2-256", g = h.format || "dag-pb";
                        let b = 1;
                        b = h.version == null ? p === "sha2-256" && g === "dag-pb" ? 0 : 1 : h.version;
                        const I = await r(o, p), v = new e(b, g, I);
                        o = new d(l, v);
                    }
                } const a = await u.readLock(); try {
                    return await t.put(o, { signal: h.signal }), h.preload !== !1 && i(o.cid), h.pin === !0 && await s.add(o.cid, { recursive: !0, signal: h.signal }), o;
                }
                finally {
                    a();
                } });
            }, function (E) { E.exports = JSON.parse('{"name":"ipld-block","version":"0.11.0","description":"JavaScript Implementation of IPLD Block","leadMaintainer":"Volker Mische <volker.mische@gmail.com>","main":"src/index.js","scripts":{"lint":"aegir lint","check":"tsc --noEmit --noErrorTruncation","build":"npm run build:js && npm run build:types","build:js":"aegir build","build:types":"tsc --emitDeclarationOnly --declarationDir dist","test":"aegir test","test:node":"aegir test --target node","test:browser":"aegir test --target browser","release":"aegir release --docs","release-minor":"aegir release --type minor --docs","release-major":"aegir release --type major --docs","coverage":"aegir coverage","coverage-publish":"aegir coverage --provider coveralls","docs":"aegir docs","prepare":"npm run build:types"},"pre-push":["lint","test"],"repository":{"type":"git","url":"git+https://github.com/ipld/js-ipld-block.git"},"keywords":["IPLD"],"license":"MIT","bugs":{"url":"https://github.com/ipld/js-ipld-block/issues"},"homepage":"https://github.com/ipld/js-ipld-block#readme","devDependencies":{"aegir":"^27.0.0","uint8arrays":"^1.0.0","typescript":"^4.0.3"},"dependencies":{"cids":"^1.0.0"},"engines":{"node":">=6.0.0","npm":">=3.0.0"},"typesVersions":{"*":{"*":["dist/*"]}},"contributors":["David Dias <daviddias.p@gmail.com>","Volker Mische <volker.mische@gmail.com>","Friedel Ziegelmayer <dignifiedquire@gmail.com>","Irakli Gozalishvili <contact@gozala.io>","achingbrain <alex@achingbrain.net>","\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>","Alan Shaw <alan.shaw@protocol.ai>","Charlie <the_charlie_daly@hotmail.co.uk>","Diogo Silva <fsdiogo@gmail.com>","Hugo Dias <hugomrdias@gmail.com>","Mikeal Rogers <mikeal.rogers@gmail.com>","Richard Littauer <richard.littauer@gmail.com>","Richard Schneider <makaretu@gmail.com>","Xmader <xmader@outlook.com>"]}'); }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), { parallelMap: e, filter: c } = f(55), { pipe: n } = f(27), { PinTypes: t } = f(87), { cleanCid: s } = f(167), u = f(2);
                E.exports = ({ blockService: i, gcLock: o, pinManager: h }) => u(async function* (a, l = {}) { Array.isArray(a) || (a = [a]); const p = await o.writeLock(); try {
                    yield* n(a, e(8, async (g) => { const b = { cid: g = s(g) }; try {
                        const I = await h.isPinnedWithType(g, t.all);
                        if (I.pinned)
                            throw d.isCID(I.reason) ? r(new Error("pinned via " + I.reason)) : r(new Error("pinned: " + I.reason));
                        if (!await i._repo.blocks.has(g))
                            throw r(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
                        await i.delete(g);
                    }
                    catch (I) {
                        l.force || (I.message = `cannot remove ${g}: ${I.message}`, b.error = I);
                    } return b; }), c(() => !l.quiet));
                }
                finally {
                    p();
                } });
            }, function (E, m, f) {
                "use strict";
                const { cleanCid: d } = f(167), r = f(2);
                E.exports = ({ blockService: e, preload: c }) => r(async function (n, t = {}) { return n = d(n), t.preload !== !1 && c(n), { cid: n, size: (await e.get(n)).data.length }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(639), r = f(640), e = f(668), c = f(677), n = f(678);
                E.exports = class {
                    constructor({ preload: t, gcLock: s, pin: u, block: i, ipld: o, options: h }) { const a = r({ preload: t, gcLock: s, block: i, pin: u, options: h }); this.addAll = a, this.add = d({ addAll: a }), this.cat = e({ ipld: o, preload: t }), this.get = c({ ipld: o, preload: t }), this.ls = n({ ipld: o, preload: t }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(40);
                E.exports = ({ addAll: r }) => async function (e, c) { const n = e, t = await d(r(n, c)); if (t == null)
                    throw Error("Failed to add a file, if you see this please report a bug"); return t; };
            }, function (E, m, f) {
                "use strict";
                const d = f(168), r = f(663), { parseChunkerString: e } = f(667), { pipe: c } = f(27), n = f(2), t = f(24).bind({ ignoreUndefined: !0 });
                E.exports = ({ block: s, gcLock: u, preload: i, pin: o, options: h }) => { const a = h && h.sharding; return n(async function* (l, p = {}) { const g = t({ shardSplitThreshold: a ? 1e3 : 1 / 0, strategy: "balanced" }, p, { ...e(p.chunker) }); g.hashAlg && g.hashAlg !== "sha2-256" && g.cidVersion !== 1 && (g.cidVersion = 1), g.trickle && (g.strategy = "trickle"), g.strategy === "trickle" && (g.leafType = "raw", g.reduceSingleLeafToSelf = !1), g.cidVersion > 0 && g.rawLeaves === void 0 && (g.rawLeaves = !0), g.hashAlg !== void 0 && g.rawLeaves === void 0 && (g.rawLeaves = !0), delete g.trickle; const b = {}; if (g.progress) {
                    const R = g.progress;
                    g.progress = (_, k) => { b[k] || (b[k] = 0), b[k] += _, R(b[k], k); };
                } const I = c(r(l), R => d(R, s, { ...g, pin: !1 }), function (R) { return async function* (_) { for await (const k of _) {
                    let x = k.cid;
                    R.cidVersion === 1 && (x = x.toV1());
                    let M = k.path ? k.path : x.toString();
                    R.wrapWithDirectory && !k.path && (M = ""), yield { path: M, cid: x, size: k.size, mode: k.unixfs && k.unixfs.mode, mtime: k.unixfs && k.unixfs.mtime };
                } }; }(g), function (R, _) { return async function* (k) { for await (const x of k)
                    (!x.path || _.wrapWithDirectory ? x.path === "" : !x.path.includes("/")) && !_.onlyHash && _.preload !== !1 && R(x.cid), yield x; }; }(i, g), function (R, _) { return async function* (k) { for await (const x of k) {
                    const M = !x.path.includes("/");
                    (_.pin == null || _.pin) && M && !_.onlyHash && await R.add(x.cid, { preload: !1, lock: !1 }), yield x;
                } }; }(o, g)), v = await u.readLock(); try {
                    for await (const R of I)
                        delete b[R.path], yield R;
                }
                finally {
                    v();
                } }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(642), r = f(643);
                E.exports = async function* (e, c, n) { for await (const t of e)
                    if (t.path && (t.path.substring(0, 2) === "./" && (n.wrapWithDirectory = !0), t.path = t.path.split("/").filter(s => s && s !== ".").join("/")), t.content) {
                        let s, u, i = t.content;
                        (i[Symbol.asyncIterator] || i[Symbol.iterator]) && i.length === void 0 || (i = { [Symbol.iterator]: function* () { yield t.content; } }), s = typeof n.chunker == "function" ? n.chunker : n.chunker === "rabin" ? f(648) : f(653), u = typeof n.chunkValidator == "function" ? n.chunkValidator : f(654), yield () => r(t, s(u(i, n), n), c, n);
                    }
                    else
                        yield () => d(t, c, n); };
            }, function (E, m, f) {
                "use strict";
                const d = f(29), r = f(67), { DAGNode: e } = f(17);
                E.exports = async (c, n, t) => { const s = new d({ type: "directory", mtime: c.mtime, mode: c.mode }), u = new e(s.marshal()).serialize(); return { cid: await r(u, n, t), path: c.path, unixfs: s, size: u.length }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(29), e = f(67), { DAGNode: c, DAGLink: n } = f(17), t = f(88), s = f(282), u = f(16).multihash, i = { flat: f(644), balanced: f(645), trickle: f(646) };
                E.exports = async (o, h, a, l) => { const p = i[l.strategy]; if (!p)
                    throw d(new Error("Unknown importer build strategy name: " + l.strategy), "ERR_BAD_STRATEGY"); const g = await t(p(async function* (b, I, v, R) { let _, k, x = -1; k = typeof R.bufferImporter == "function" ? R.bufferImporter : f(647); for await (const M of s(k(b, I, v, R), R.blockWriteConcurrency))
                    x++, x !== 0 ? (x === 1 && (yield _, _ = null), yield M) : _ = M; _ && (_.single = !0, yield _); }(o, h, a, l), ((b, I, v) => async function (R) { if (R.length === 1 && R[0].single && v.reduceSingleLeafToSelf) {
                    const N = R[0];
                    if (N.cid.codec === "raw" && (b.mtime !== void 0 || b.mode !== void 0)) {
                        let { data: S } = await I.get(N.cid, v);
                        N.unixfs = new r({ type: "file", mtime: b.mtime, mode: b.mode, data: S });
                        const T = u.decode(N.cid.multihash);
                        S = new c(N.unixfs.marshal()).serialize(), N.cid = await e(S, I, { ...v, codec: "dag-pb", hashAlg: T.name, cidVersion: v.cidVersion }), N.size = S.length;
                    }
                    return { cid: N.cid, path: b.path, unixfs: N.unixfs, size: N.size };
                } const _ = new r({ type: "file", mtime: b.mtime, mode: b.mode }), k = R.filter(N => !(N.cid.codec !== "raw" || !N.size) || !(N.unixfs.data || !N.unixfs.fileSize()) || Boolean(N.unixfs.data.length)).map(N => N.cid.codec === "raw" ? (_.addBlockSize(N.size), new n(N.name, N.size, N.cid)) : (N.unixfs.data ? _.addBlockSize(N.unixfs.data.length) : _.addBlockSize(N.unixfs.fileSize()), new n(N.name, N.size, N.cid))), x = new c(_.marshal(), k), M = x.serialize(); return { cid: await e(M, I, v), path: b.path, unixfs: _, size: M.length + x.Links.reduce((N, S) => N + S.Tsize, 0) }; })(o, a, l), l)); if (g.length > 1)
                    throw d(new Error("expected a maximum of 1 roots and got " + g.length), "ETOOMANYROOTS"); return g[0]; };
            }, function (E, m, f) {
                "use strict";
                const d = f(88);
                E.exports = async function* (r, e) { yield await e(await d(r)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(169);
                E.exports = async function* (r, e, c) { yield await async function n(t, s, u) { const i = []; for await (const o of d(t, u.maxChildrenPerNode))
                    i.push(await s(o)); return i.length > 1 ? n(i, s, u) : i[0]; }(r, e, c); };
            }, function (E, m, f) {
                "use strict";
                const d = f(169);
                E.exports = function* (c, n, t) { yield async function (s, u, i) { let o, h = 0, a = 1, l = o = new e(i.layerRepeat); for await (const p of d(s, i.maxChildrenPerNode))
                    l.isFull() && (l !== o && o.addChild(await l.reduce(u)), h && h % i.layerRepeat == 0 && a++, l = new r(a, i.layerRepeat, h), h++), l.append(p); return l && l !== o && o.addChild(await l.reduce(u)), o.reduce(u); }(c, n, t); };
                class r {
                    constructor(n, t, s) { this.maxDepth = n, this.layerRepeat = t, this.currentDepth = 1, this.iteration = s, this.root = this.node = this.parent = { children: [], depth: this.currentDepth, maxDepth: n, maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat }; }
                    isFull() { if (!this.root.data)
                        return !1; if (this.currentDepth < this.maxDepth && this.node.maxChildren)
                        return this._addNextNodeToParent(this.node), !1; const n = this._findParent(this.node, this.currentDepth); return !n || (this._addNextNodeToParent(n), !1); }
                    _addNextNodeToParent(n) { this.parent = n; const t = { children: [], depth: n.depth + 1, parent: n, maxDepth: this.maxDepth, maxChildren: Math.floor(n.children.length / this.layerRepeat) * this.layerRepeat }; n.children.push(t), this.currentDepth = t.depth, this.node = t; }
                    append(n) { this.node.data = n; }
                    reduce(n) { return this._reduce(this.root, n); }
                    async _reduce(n, t) { let s = []; return n.children.length && (s = await Promise.all(n.children.filter(u => u.data).map(u => this._reduce(u, t)))), t(n.data.concat(s)); }
                    _findParent(n, t) { const s = n.parent; if (s && s.depth !== 0)
                        return s.children.length !== s.maxChildren && s.maxChildren ? s : this._findParent(s, t); }
                }
                class e extends r {
                    constructor(n) { super(0, n), this.root.depth = 0, this.currentDepth = 1; }
                    addChild(n) { this.root.children.push(n); }
                    reduce(n) { return n(this.root.data.concat(this.root.children)); }
                }
            }, function (E, m, f) {
                "use strict";
                const d = f(29), r = f(67), { DAGNode: e } = f(17);
                E.exports = async function* (c, n, t, s) { for await (let u of n)
                    yield async () => { let i; s.progress(u.length, c.path); const o = { ...s }; return s.rawLeaves ? (o.codec = "raw", o.cidVersion = 1) : (i = new d({ type: s.leafType, data: u, mtime: c.mtime, mode: c.mode }), u = new e(i.marshal()).serialize()), { cid: await r(u, t, o), unixfs: i, size: u.length }; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(34), { create: r } = f(649), e = f(0);
                E.exports = async function* (n, t) { const s = c(); let u, i, o; if (t.minChunkSize && t.maxChunkSize && t.avgChunkSize)
                    o = t.avgChunkSize, u = t.minChunkSize, i = t.maxChunkSize;
                else {
                    if (!t.avgChunkSize)
                        throw e(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
                    o = t.avgChunkSize, u = o / 3, i = o + o / 2;
                } if (u < 16)
                    throw e(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE"); i < u && (i = u), o < u && (o = u); const h = Math.floor(Math.log2(o)); for await (const a of s(n, { min: u, max: i, bits: h, window: t.window, polynomial: t.polynomial }))
                    yield a; };
                const c = () => async function* (n, t) { const s = await r(t.bits, t.min, t.max, t.window), u = new d; for await (const h of n) {
                    u.append(h);
                    const a = s.fingerprint(h);
                    for (let l = 0; l < a.length; l++) {
                        var i = a[l], o = u.slice(0, i);
                        u.consume(i), yield o;
                    }
                } u.length && (yield u.slice(0)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(650), r = f(651);
                E.exports = { Rabin: d, create: async (e, c, n, t, s) => { const u = await r(); return new d(u, e, c, n, t, s); } };
            }, function (E, m, f) {
                "use strict";
                E.exports = class {
                    constructor(d, r = 12, e = 8192, c = 32768, n = 64, t) { this.bits = r, this.min = e, this.max = c, this.asModule = d, this.rabin = new d.Rabin(r, e, c, n, t), this.polynomial = t; }
                    fingerprint(d) { const { __retain: r, __release: e, __allocArray: c, __getInt32Array: n, Int32Array_ID: t, Uint8Array_ID: s } = this.asModule, u = r(c(t, new Int32Array(Math.ceil(d.length / this.min)))), i = r(c(s, d)), o = n(this.rabin.fingerprint(i, u)); e(i), e(u); const h = []; for (let a = 0; a < o.length && o[a] !== 0; a++)
                        h[a] = o[a]; return h; }
                };
            }, function (E, m, f) {
                "use strict";
                const { instantiate: d } = f(652);
                function r(e = {}) { if (!r.supported)
                    return null; var c = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 3, 127, 127, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 5, 9, 3, 6, 2, 5, 7, 6, 3, 4, 2, 7, 9, 12, 13, 5, 6, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 7, 8, 8, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 249, 35, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 66, 2, 1, 127, 1, 126, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 2, 3, 64, 32, 1, 65, 192, 0, 72, 4, 64, 32, 0, 32, 2, 131, 66, 0, 86, 4, 64, 65, 63, 32, 1, 107, 15, 11, 32, 2, 66, 1, 136, 33, 2, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 127, 11, 165, 1, 2, 2, 127, 1, 126, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 4, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 1, 32, 4, 131, 66, 0, 86, 13, 2, 26, 32, 4, 66, 1, 136, 33, 4, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 3, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 192, 0, 72, 4, 64, 65, 63, 32, 2, 107, 32, 0, 32, 4, 131, 66, 0, 86, 13, 2, 26, 32, 4, 66, 1, 136, 33, 4, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 127, 11, 32, 3, 107, 34, 2, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 2, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 32, 2, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 164, 9, 2, 1, 127, 6, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 7, 32, 0, 41, 3, 72, 34, 8, 33, 9, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 8, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 9, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 65, 0, 33, 5, 3, 64, 32, 5, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 65, 0, 33, 3, 32, 7, 66, 8, 134, 33, 7, 32, 0, 41, 3, 72, 34, 8, 33, 9, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 8, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 4, 3, 64, 32, 4, 65, 192, 0, 72, 4, 64, 65, 63, 32, 4, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 9, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 32, 5, 65, 1, 106, 33, 5, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 7, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 2, 127, 32, 0, 41, 3, 72, 33, 6, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 192, 0, 72, 4, 64, 65, 63, 32, 2, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 7, 66, 1, 136, 33, 7, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 127, 11, 172, 33, 8, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 4, 32, 2, 172, 32, 8, 134, 34, 9, 33, 7, 2, 127, 32, 0, 41, 3, 72, 34, 10, 33, 11, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 11, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 5, 3, 64, 32, 5, 65, 192, 0, 72, 4, 64, 65, 63, 32, 5, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 5, 65, 1, 106, 33, 5, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 10, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 32, 4, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 7, 32, 9, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 65, 0, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 65, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 32, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 65, 0, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 65, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]); return d(new Response(new Blob([c], { type: "application/wasm" })), e); }
                r.supported = typeof WebAssembly != "undefined", E.exports = r;
            }, function (E, m, f) {
                "use strict";
                const d = typeof BigUint64Array != "undefined", r = Symbol();
                function e(o, h) { const a = new Uint32Array(o), l = new Uint16Array(o); var p = a[h + -4 >>> 2] >>> 1, g = h >>> 1; if (p <= 1024)
                    return String.fromCharCode.apply(String, l.subarray(g, g + p)); const b = []; do {
                    const I = l[g + 1024 - 1], v = I >= 55296 && I < 56320 ? 1023 : 1024;
                    b.push(String.fromCharCode.apply(String, l.subarray(g, g += v))), p -= v;
                } while (p > 1024); return b.join("") + String.fromCharCode.apply(String, l.subarray(g, g + p)); }
                function c(o) { const h = {}; function a(p, g) { return p ? e(p.buffer, g) : "<yet unknown>"; } const l = o.env = o.env || {}; return l.abort = l.abort || function (p, g, b, I) { const v = h.memory || l.memory; throw Error("abort: " + a(v, p) + " at " + a(v, g) + ":" + b + ":" + I); }, l.trace = l.trace || function (p, g) { const b = h.memory || l.memory; console.log("trace: " + a(b, p) + (g ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + g).join(", ")); }, o.Math = o.Math || Math, o.Date = o.Date || Date, h; }
                function n(o, h) { const a = h.exports, l = a.memory, p = a.table, g = a.__alloc, b = a.__retain, I = a.__rtti_base || -1; function v(S) { const T = new Uint32Array(l.buffer); if ((S >>>= 0) >= T[I >>> 2])
                    throw Error("invalid id: " + S); return T[(I + 4 >>> 2) + 2 * S]; } function R(S) { const T = new Uint32Array(l.buffer); if ((S >>>= 0) >= T[I >>> 2])
                    throw Error("invalid id: " + S); return T[(I + 4 >>> 2) + 2 * S + 1]; } function _(S) { return 31 - Math.clz32(S >>> 5 & 31); } function k(S, T, B) { const P = l.buffer; if (B)
                    switch (S) {
                        case 2: return new Float32Array(P);
                        case 3: return new Float64Array(P);
                    }
                else
                    switch (S) {
                        case 0: return new (T ? Int8Array : Uint8Array)(P);
                        case 1: return new (T ? Int16Array : Uint16Array)(P);
                        case 2: return new (T ? Int32Array : Uint32Array)(P);
                        case 3: return new (T ? BigInt64Array : BigUint64Array)(P);
                    } throw Error("unsupported align: " + S); } function x(S) { const T = new Uint32Array(l.buffer), B = T[S + -8 >>> 2], P = v(B); if (!(1 & P))
                    throw Error("not an array: " + B); const L = _(P); var j = T[S + 4 >>> 2]; const D = 2 & P ? T[S + 12 >>> 2] : T[j + -4 >>> 2] >>> L; return k(L, 1024 & P, 2048 & P).subarray(j >>>= L, j + D); } function M(S, T, B) { return new S(N(S, T, B)); } function N(S, T, B) { const P = l.buffer, L = new Uint32Array(P), j = L[B + 4 >>> 2]; return new S(P, j, L[j + -4 >>> 2] >>> T); } return o.__allocString = function (S) { const T = S.length, B = g(T << 1, 1), P = new Uint16Array(l.buffer); for (var L = 0, j = B >>> 1; L < T; ++L)
                    P[j + L] = S.charCodeAt(L); return B; }, o.__getString = function (S) { const T = l.buffer; if (new Uint32Array(T)[S + -8 >>> 2] !== 1)
                    throw Error("not a string: " + S); return e(T, S); }, o.__allocArray = function (S, T) { const B = v(S); if (!(3 & B))
                    throw Error("not an array: " + S + " @ " + B); const P = _(B), L = T.length, j = g(L << P, 0), D = g(2 & B ? 16 : 12, S), G = new Uint32Array(l.buffer); G[D + 0 >>> 2] = b(j), G[D + 4 >>> 2] = j, G[D + 8 >>> 2] = L << P, 2 & B && (G[D + 12 >>> 2] = L); const W = k(P, 1024 & B, 2048 & B); if (8192 & B)
                    for (let X = 0; X < L; ++X)
                        W[(j >>> P) + X] = b(T[X]);
                else
                    W.set(T, j >>> P); return D; }, o.__getArrayView = x, o.__getArray = function (S) { const T = x(S), B = T.length, P = new Array(B); for (let L = 0; L < B; L++)
                    P[L] = T[L]; return P; }, o.__getArrayBuffer = function (S) { const T = l.buffer, B = new Uint32Array(T)[S + -4 >>> 2]; return T.slice(S, S + B); }, o.__getInt8Array = M.bind(null, Int8Array, 0), o.__getInt8ArrayView = N.bind(null, Int8Array, 0), o.__getUint8Array = M.bind(null, Uint8Array, 0), o.__getUint8ArrayView = N.bind(null, Uint8Array, 0), o.__getUint8ClampedArray = M.bind(null, Uint8ClampedArray, 0), o.__getUint8ClampedArrayView = N.bind(null, Uint8ClampedArray, 0), o.__getInt16Array = M.bind(null, Int16Array, 1), o.__getInt16ArrayView = N.bind(null, Int16Array, 1), o.__getUint16Array = M.bind(null, Uint16Array, 1), o.__getUint16ArrayView = N.bind(null, Uint16Array, 1), o.__getInt32Array = M.bind(null, Int32Array, 2), o.__getInt32ArrayView = N.bind(null, Int32Array, 2), o.__getUint32Array = M.bind(null, Uint32Array, 2), o.__getUint32ArrayView = N.bind(null, Uint32Array, 2), d && (o.__getInt64Array = M.bind(null, BigInt64Array, 3), o.__getInt64ArrayView = N.bind(null, BigInt64Array, 3), o.__getUint64Array = M.bind(null, BigUint64Array, 3), o.__getUint64ArrayView = N.bind(null, BigUint64Array, 3)), o.__getFloat32Array = M.bind(null, Float32Array, 2), o.__getFloat32ArrayView = N.bind(null, Float32Array, 2), o.__getFloat64Array = M.bind(null, Float64Array, 3), o.__getFloat64ArrayView = N.bind(null, Float64Array, 3), o.__instanceof = function (S, T) { const B = new Uint32Array(l.buffer); var P = B[S + -8 >>> 2]; if (P <= B[I >>> 2])
                    do
                        if (P == T)
                            return !0;
                    while (P = R(P)); return !1; }, o.memory = o.memory || l, o.table = o.table || p, i(a, o); }
                function t(o) { return typeof Response != "undefined" && o instanceof Response; }
                async function s(o, h) { return t(o = await o) ? u(o, h) : n(c(h || (h = {})), await WebAssembly.instantiate(o instanceof WebAssembly.Module ? o : await WebAssembly.compile(o), h)); }
                async function u(o, h) { return WebAssembly.instantiateStreaming ? n(c(h || (h = {})), (await WebAssembly.instantiateStreaming(o, h)).instance) : s(t(o = await o) ? o.arrayBuffer() : o, h); }
                function i(o, h) { var a = h ? Object.create(h) : {}, l = o.__argumentsLength ? function (p) { o.__argumentsLength.value = p; } : o.__setArgumentsLength || o.__setargc || function () { }; for (let p in o) {
                    if (!Object.prototype.hasOwnProperty.call(o, p))
                        continue;
                    const g = o[p];
                    let b = p.split("."), I = a;
                    for (; b.length > 1;) {
                        let _ = b.shift();
                        Object.prototype.hasOwnProperty.call(I, _) || (I[_] = {}), I = I[_];
                    }
                    let v = b[0], R = v.indexOf("#");
                    if (R >= 0) {
                        let _ = v.substring(0, R), k = I[_];
                        if (k === void 0 || !k.prototype) {
                            let x = function (...M) { return x.wrap(x.prototype.constructor(0, ...M)); };
                            x.prototype = { valueOf: function () { return this[r]; } }, x.wrap = function (M) { return Object.create(x.prototype, { [r]: { value: M, writable: !1 } }); }, k && Object.getOwnPropertyNames(k).forEach(M => Object.defineProperty(x, M, Object.getOwnPropertyDescriptor(k, M))), I[_] = x;
                        }
                        if (v = v.substring(R + 1), I = I[_].prototype, /^(get|set):/.test(v)) {
                            if (!Object.prototype.hasOwnProperty.call(I, v = v.substring(4))) {
                                let x = o[p.replace("set:", "get:")], M = o[p.replace("get:", "set:")];
                                Object.defineProperty(I, v, { get: function () { return x(this[r]); }, set: function (N) { M(this[r], N); }, enumerable: !0 });
                            }
                        }
                        else
                            v === "constructor" ? (I[v] = (...x) => (l(x.length), g(...x))).original = g : (I[v] = function (...x) { return l(x.length), g(this[r], ...x); }).original = g;
                    }
                    else
                        /^(get|set):/.test(v) ? Object.prototype.hasOwnProperty.call(I, v = v.substring(4)) || Object.defineProperty(I, v, { get: o[p.replace("set:", "get:")], set: o[p.replace("get:", "set:")], enumerable: !0 }) : typeof g == "function" && g !== l ? (I[v] = (..._) => (l(_.length), g(..._))).original = g : I[v] = g;
                } return a; }
                m.instantiate = s, m.instantiateSync = function (o, h) { return n(c(h || (h = {})), new WebAssembly.Instance(o instanceof WebAssembly.Module ? o : new WebAssembly.Module(o), h)); }, m.instantiateStreaming = u, m.demangle = i;
            }, function (E, m, f) {
                "use strict";
                const d = f(34);
                E.exports = async function* (r, e) { let c = new d, n = 0, t = !1; const s = e.maxChunkSize; for await (const u of r)
                    for (c.append(u), n += u.length; n >= s;)
                        if (yield c.slice(0, s), t = !0, s === c.length)
                            c = new d, n = 0;
                        else {
                            const i = new d;
                            i.append(c.shallowSlice(s)), c = i, n -= s;
                        } t && !n || (yield c.slice(0, n)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(6);
                E.exports = async function* (e) { for await (const c of e) {
                    if (c.length === void 0)
                        throw d(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
                    typeof c == "string" || c instanceof String ? yield r(c) : Array.isArray(c) ? yield Uint8Array.from(c) : yield c;
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(656), r = f(657), e = f(170), c = f(662);
                async function n(s, u, i) { const o = c(s.path || ""), h = o.length - 1; let a = u, l = ""; for (let p = 0; p < o.length; p++) {
                    const g = o[p];
                    l += `${l ? "/" : ""}${g}`;
                    const b = p === h;
                    if (a.dirty = !0, a.cid = null, a.size = null, b)
                        await a.put(g, s), u = await r(null, a, i.shardSplitThreshold, i);
                    else {
                        let I = await a.get(g);
                        I && I instanceof e || (I = new d({ dir: !0, parent: a, parentKey: g, path: l, dirty: !0, flat: !0, mtime: I && I.unixfs && I.unixfs.mtime, mode: I && I.unixfs && I.unixfs.mode }, i)), await a.put(g, I), a = I;
                    }
                } return u; }
                async function* t(s, u) { s instanceof e ? yield* s.flush(s.path, u) : s && s.unixfs && s.unixfs.isDirectory() && (yield s); }
                E.exports = async function* (s, u, i) { let o = new d({ root: !0, dir: !0, path: "", dirty: !0, flat: !0 }, i); for await (const h of s)
                    h && (o = await n(h, o, i), h.unixfs && h.unixfs.isDirectory() || (yield h)); if (i.wrapWithDirectory)
                    yield* t(o, u);
                else
                    for await (const h of o.eachChildSeries())
                        h && (yield* t(h.child, u)); };
            }, function (E, m, f) {
                "use strict";
                const { DAGLink: d, DAGNode: r } = f(17), e = f(29), c = f(170), n = f(67);
                E.exports = class extends c {
                    constructor(t, s) { super(t, s), this._children = {}; }
                    put(t, s) { this.cid = void 0, this.size = void 0, this._children[t] = s; }
                    get(t) { return this._children[t]; }
                    childCount() { return Object.keys(this._children).length; }
                    directChildrenCount() { return this.childCount(); }
                    onlyChild() { return this._children[Object.keys(this._children)[0]]; }
                    *eachChildSeries() { const t = Object.keys(this._children); for (let s = 0; s < t.length; s++) {
                        const u = t[s];
                        yield { key: u, child: this._children[u] };
                    } }
                    async *flush(t, s) { const u = Object.keys(this._children), i = []; for (let g = 0; g < u.length; g++) {
                        let b = this._children[u[g]];
                        if (typeof b.flush == "function")
                            for await (const I of b.flush(b.path, s))
                                b = I, yield b;
                        i.push(new d(u[g], b.size, b.cid));
                    } const o = new e({ type: "directory", mtime: this.mtime, mode: this.mode }), h = new r(o.marshal(), i), a = h.serialize(), l = await n(a, s, this.options), p = a.length + h.Links.reduce((g, b) => g + b.Tsize, 0); this.cid = l, this.size = p, yield { cid: l, unixfs: o, path: t, size: p }; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(171);
                E.exports = async function r(e, c, n, t) { let s = c; c.flat && c.directChildrenCount() >= n && (s = await async function (i, o) { const h = new d({ root: i.root, dir: !0, parent: i.parent, parentKey: i.parentKey, path: i.path, dirty: i.dirty, flat: !1, mtime: i.mtime, mode: i.mode }, o); for await (const { key: a, child: l } of i.eachChildSeries())
                    await h.put(a, l); return h; }(c, t)); const u = s.parent; return u ? (s !== c && (e && (e.parent = s), await u.put(s.parentKey, s)), r(s, u, n, t)) : s; };
            }, function (E, m, f) {
                "use strict";
                const d = f(172);
                E.exports = function (r) { return new d(r); }, E.exports.isBucket = d.isBucket;
            }, function (E, m, f) {
                "use strict";
                function d(n, t) { return n + r(t); }
                function r(n) { let t = n; return t -= t >> 1 & 1431655765, t = (858993459 & t) + (t >> 2 & 858993459), 16843009 * (t + (t >> 4) & 252645135) >> 24; }
                function e(n, t) { return n[0] - t[0]; }
                function c(n) { return n[1]; }
                E.exports = class {
                    constructor() { this._bitArrays = [], this._data = [], this._length = 0, this._changedLength = !1, this._changedData = !1; }
                    set(n, t) { let s = this._internalPositionFor(n, !1); if (t === void 0)
                        s !== -1 && (this._unsetInternalPos(s), this._unsetBit(n), this._changedLength = !0, this._changedData = !0);
                    else {
                        let u = !1;
                        s === -1 ? (s = this._data.length, this._setBit(n), this._changedData = !0) : u = !0, this._setInternalPos(s, n, t, u), this._changedLength = !0;
                    } }
                    unset(n) { this.set(n, void 0); }
                    get(n) { this._sortData(); const t = this._internalPositionFor(n, !0); if (t !== -1)
                        return this._data[t][1]; }
                    push(n) { return this.set(this.length, n), this.length; }
                    get length() { if (this._sortData(), this._changedLength) {
                        const n = this._data[this._data.length - 1];
                        this._length = n ? n[0] + 1 : 0, this._changedLength = !1;
                    } return this._length; }
                    forEach(n) { let t = 0; for (; t < this.length;)
                        n(this.get(t), t, this), t++; }
                    map(n) { let t = 0, s = new Array(this.length); for (; t < this.length;)
                        s[t] = n(this.get(t), t, this), t++; return s; }
                    reduce(n, t) { let s = 0, u = t; for (; s < this.length;)
                        u = n(u, this.get(s), s), s++; return u; }
                    find(n) { let t, s, u = 0; for (; u < this.length && !t;)
                        s = this.get(u), t = n(s), u++; return t ? s : void 0; }
                    _internalPositionFor(n, t) { const s = this._bytePosFor(n, t); if (s >= this._bitArrays.length)
                        return -1; const u = this._bitArrays[s], i = n - 7 * s; return (u & 1 << i) > 0 ? this._bitArrays.slice(0, s).reduce(d, 0) + r(u & ~(4294967295 << i + 1)) - 1 : -1; }
                    _bytePosFor(n, t) { const s = Math.floor(n / 7), u = s + 1; for (; !t && this._bitArrays.length < u;)
                        this._bitArrays.push(0); return s; }
                    _setBit(n) { const t = this._bytePosFor(n, !1); this._bitArrays[t] |= 1 << n - 7 * t; }
                    _unsetBit(n) { const t = this._bytePosFor(n, !1); this._bitArrays[t] &= ~(1 << n - 7 * t); }
                    _setInternalPos(n, t, s, u) { const i = this._data, o = [t, s]; if (u)
                        this._sortData(), i[n] = o;
                    else {
                        if (i.length)
                            if (i[i.length - 1][0] >= t)
                                i.push(o);
                            else if (i[0][0] <= t)
                                i.unshift(o);
                            else {
                                const h = Math.round(i.length / 2);
                                this._data = i.slice(0, h).concat(o).concat(i.slice(h));
                            }
                        else
                            this._data.push(o);
                        this._changedData = !0, this._changedLength = !0;
                    } }
                    _unsetInternalPos(n) { this._data.splice(n, 1); }
                    _sortData() { this._changedData && this._data.sort(e), this._changedData = !1; }
                    bitField() { const n = []; let t, s = 8, u = 0, i = 0; const o = this._bitArrays.slice(); for (; o.length || u;) {
                        u === 0 && (t = o.shift(), u = 7);
                        const a = Math.min(u, s);
                        i |= (t & ~(255 << a)) << 8 - s, t >>>= a, u -= a, s -= a, s && (u || o.length) || (n.push(i), i = 0, s = 8);
                    } for (var h = n.length - 1; h > 0 && !(n[h] !== 0); h--)
                        n.pop(); return n; }
                    compactArray() { return this._sortData(), this._data.map(c); }
                };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(661); E.exports = function (c) { return function (n) { return n instanceof e ? n : new e(n, c); }; }; class e {
                    constructor(n, t) { if (typeof n != "string" && !d.isBuffer(n))
                        throw new Error("can only hash strings or buffers"); this._value = n, this._hashFn = t, this._depth = -1, this._availableBits = 0, this._currentBufferIndex = 0, this._buffers = []; }
                    async take(n) { let t = n; for (; this._availableBits < t;)
                        await this._produceMoreBits(); let s = 0; for (; t > 0;) {
                        const u = this._buffers[this._currentBufferIndex], i = Math.min(u.availableBits(), t);
                        s = (s << i) + u.take(i), t -= i, this._availableBits -= i, u.availableBits() === 0 && this._currentBufferIndex++;
                    } return s; }
                    untake(n) { let t = n; for (; t > 0;) {
                        const s = this._buffers[this._currentBufferIndex], u = Math.min(s.totalBits() - s.availableBits(), t);
                        s.untake(u), t -= u, this._availableBits += u, this._currentBufferIndex > 0 && s.totalBits() === s.availableBits() && (this._depth--, this._currentBufferIndex--);
                    } }
                    async _produceMoreBits() { this._depth++; const n = this._depth ? this._value + this._depth : this._value, t = await this._hashFn(n), s = new r(t); this._buffers.push(s), this._availableBits += s.availableBits(); }
                } }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                const d = [255, 254, 252, 248, 240, 224, 192, 128], r = [1, 3, 7, 15, 31, 63, 127, 255];
                function e(c, n, t) { return (c & function (s, u) { return d[s] & r[Math.min(u + s - 1, 7)]; }(n, t)) >>> n; }
                E.exports = class {
                    constructor(c) { this._value = c, this._currentBytePos = c.length - 1, this._currentBitPos = 7; }
                    availableBits() { return this._currentBitPos + 1 + 8 * this._currentBytePos; }
                    totalBits() { return 8 * this._value.length; }
                    take(c) { let n = c, t = 0; for (; n && this._haveBits();) {
                        const s = this._value[this._currentBytePos], u = this._currentBitPos + 1, i = Math.min(u, n);
                        t = (t << i) + e(s, u - i, i), n -= i, this._currentBitPos -= i, this._currentBitPos < 0 && (this._currentBitPos = 7, this._currentBytePos--);
                    } return t; }
                    untake(c) { for (this._currentBitPos += c; this._currentBitPos > 7;)
                        this._currentBitPos -= 8, this._currentBytePos += 1; }
                    _haveBits() { return this._currentBytePos >= 0; }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = (d = "") => (d.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
            }, function (E, m, f) {
                "use strict";
                const d = f(664), r = f(666);
                E.exports = e => r(e, d);
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(6), e = f(173), c = f(665), n = f(284), t = f(88), s = f(174), { isBytes: u, isReadableStream: i, isBlob: o } = f(285);
                function h(a) { return a instanceof Uint8Array ? a : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength) : a instanceof ArrayBuffer ? new Uint8Array(a) : Array.isArray(a) ? Uint8Array.from(a) : r(a); }
                E.exports = async function* (a) { if (u(a) || typeof a == "string" || a instanceof String)
                    yield h(a);
                else {
                    if (!o(a)) {
                        if (i(a) && (a = e(a)), a[Symbol.iterator] || a[Symbol.asyncIterator]) {
                            const l = n(a), { value: p, done: g } = await l.peek();
                            if (g)
                                return void (yield* []);
                            if (l.push(p), Number.isInteger(p))
                                return void (yield Uint8Array.from(await t(l)));
                            if (u(p) || typeof p == "string" || p instanceof String)
                                return void (yield* s(l, h));
                        }
                        throw d(new Error("Unexpected input: " + a), "ERR_UNEXPECTED_INPUT");
                    }
                    yield* c(a);
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(173);
                E.exports = function (r) { return typeof r.stream == "function" ? d(r.stream()) : d(new Response(r).body); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(173), e = f(284), c = f(174), { isBytes: n, isBlob: t, isReadableStream: s, isFileObject: u, mtimeToObject: i, modeToNumber: o } = f(285);
                async function h(a, l) { const { path: p, mode: g, mtime: b, content: I } = a, v = { path: p || "", mode: o(g), mtime: i(b) }; return I ? v.content = await l(I) : p || (v.content = await l(a)), v; }
                E.exports = async function* (a, l) { if (a == null)
                    throw d(new Error("Unexpected input: " + a), "ERR_UNEXPECTED_INPUT"); if (typeof a == "string" || a instanceof String)
                    yield h(a, l);
                else if (n(a) || t(a))
                    yield h(a, l);
                else {
                    if (s(a) && (a = r(a)), a[Symbol.iterator] || a[Symbol.asyncIterator]) {
                        const p = e(a), { value: g, done: b } = await p.peek();
                        if (b)
                            return void (yield* []);
                        if (p.push(g), Number.isInteger(g) || n(g))
                            return void (yield h(p, l));
                        if (u(g) || t(g) || typeof g == "string" || g instanceof String)
                            return void (yield* c(p, I => h(I, l)));
                        if (g[Symbol.iterator] || g[Symbol.asyncIterator] || s(g))
                            return void (yield* c(p, I => h(I, l)));
                    }
                    if (!u(a))
                        throw d(new Error("Unexpected input: " + typeof a), "ERR_UNEXPECTED_INPUT");
                    yield h(a, l);
                } };
            }, function (E, m, f) {
                "use strict";
                const d = e => { const c = {}, n = e.split("-"); switch (n.length) {
                    case 1:
                        c.avgChunkSize = 262144;
                        break;
                    case 2:
                        c.avgChunkSize = r(n[1], "avg");
                        break;
                    case 4:
                        c.minChunkSize = r(n[1], "min"), c.avgChunkSize = r(n[2], "avg"), c.maxChunkSize = r(n[3], "max");
                        break;
                    default: throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
                } return c; }, r = (e, c) => { const n = parseInt(e); if (isNaN(n))
                    throw new Error(`Chunker parameter ${c} must be an integer`); return n; };
                E.exports = { parseChunkSize: r, parseRabinString: d, parseChunkerString: e => { if (e) {
                        if (e.startsWith("size-")) {
                            const c = e.split("-")[1], n = parseInt(c);
                            if (isNaN(n))
                                throw new Error("Chunker parameter size must be an integer");
                            return { chunker: "fixed", maxChunkSize: n };
                        }
                        if (e.startsWith("rabin"))
                            return { chunker: "rabin", ...d(e) };
                        throw new Error("Unrecognized chunker option: " + e);
                    } return { chunker: "fixed" }; } };
            }, function (E, m, f) {
                "use strict";
                const d = f(37), { normalizeCidPath: r } = f(23), e = f(2);
                E.exports = function ({ ipld: c, preload: n }) { return e(async function* (t, s = {}) { if (t = r(t), s.preload !== !1) {
                    const i = t.split("/");
                    n(i[0]);
                } const u = await d(t, c, s); if (u.unixfs && u.unixfs.type.includes("dir"))
                    throw new Error("this dag node is a directory"); if (!u.content)
                    throw new Error("this dag node has no content"); yield* u.content(s); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = { "dag-pb": f(670), raw: f(674), "dag-cbor": f(675), identity: f(676) }, e = (c, n, t, s, u, i, o) => { const h = r[c.codec]; if (!h)
                    throw d(new Error("No resolver for codec " + c.codec), "ERR_NO_RESOLVER"); return h(c, n, t, s, e, u, i, o); };
                E.exports = e;
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(29), e = f(671), c = { raw: f(286), file: f(286), directory: f(672), "hamt-sharded-directory": f(673), metadata: (n, t, s, u, i, o, h) => { }, symlink: (n, t, s, u, i, o, h) => { } };
                E.exports = async (n, t, s, u, i, o, h, a) => { const l = await h.get(n, a); let p, g; t || (t = n.toBaseEncodedString()); try {
                    p = r.unmarshal(l.Data);
                }
                catch (b) {
                    throw d(b, "ERR_NOT_UNIXFS");
                } if (s || (s = t), u.length) {
                    let b;
                    if (b = p && p.type === "hamt-sharded-directory" ? await e(l, u[0], h) : ((v, R) => { const _ = v.Links.find(k => k.Name === R); return _ && _.Hash; })(l, u[0]), !b)
                        throw d(new Error("file does not exist"), "ERR_NOT_FOUND");
                    const I = u.shift();
                    g = { cid: b, toResolve: u, name: I, path: `${s}/${I}` };
                } return { entry: { name: t, path: s, cid: n, node: l, content: c[p.type](n, l, p, s, i, o, h, a), unixfs: p, depth: o }, next: g }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(172), r = f(16), e = f(6), c = async function (s) { const u = e(s), i = (await r(u, "murmur3-128")).slice(2, 10), o = i.length, h = new Uint8Array(o); for (let a = 0; a < o; a++)
                    h[o - a - 1] = i[a]; return h; };
                c.code = 34;
                const n = s => s.toString("16").toUpperCase().padStart(2, "0").substring(0, 2), t = async (s, u, i, o, h) => { var a, l, p; o || ((o = { rootBucket: new d({ hashFn: c }), hamtDepth: 1 }).lastBucket = o.rootBucket), await (a = s.Links, l = o.lastBucket, p = o.rootBucket, Promise.all(a.map(R => { if (R.Name.length === 2) {
                    const _ = parseInt(R.Name, 16);
                    return l._putObjectAt(_, new d({ hashFn: c }, l, _));
                } return p.put(R.Name.substring(2), !0); }))); const g = await o.rootBucket._findNewBucketAndPos(u); let b = n(g.pos); const I = (R => { let _ = R.bucket; const k = []; for (; _._parent;)
                    k.push(_), _ = _._parent; return k.push(_), k.reverse(); })(g); I.length > o.hamtDepth && (o.lastBucket = I[o.hamtDepth], b = n(o.lastBucket._posAtParent)); const v = s.Links.find(R => { const _ = R.Name.substring(0, 2), k = R.Name.substring(2); if (_ === b && (!k || k === u))
                    return !0; }); return v ? v.Name.substring(2) === u ? v.Hash : (o.hamtDepth++, s = await i.get(v.Hash, h), t(s, u, i, o, h)) : null; };
                E.exports = t;
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r, e, c, n, t, s, u) => async function* (i = {}) { const o = i.offset || 0, h = i.length || r.Links.length, a = r.Links.slice(o, h); for (const l of a) {
                    const p = await n(l.Hash, l.Name, `${c}/${l.Name}`, [], t + 1, s, i);
                    yield p.entry;
                } };
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r, e, c, n, t, s) => (u = {}) => async function* i(o, h, a, l, p, g) { const b = o.Links; for (const I of b) {
                    const v = I.Name.substring(2);
                    if (v) {
                        const R = await a(I.Hash, v, `${h}/${v}`, [], l + 1, p);
                        yield R.entry;
                    }
                    else {
                        o = await p.get(I.Hash);
                        for await (const R of i(o, h, a, l, p, g))
                            yield R;
                    }
                } }(r, c, n, t, s, u);
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(175), e = f(176);
                E.exports = async (c, n, t, s, u, i, o, h) => { if (s.length)
                    throw d(new Error(`No link named ${t} found in raw node ${c.toBaseEncodedString()}`), "ERR_NOT_FOUND"); const a = await o.get(c, h); return { entry: { name: n, path: t, cid: c, node: a, content: (l = a, function* (p = {}) { const { offset: g, length: b } = e(l.length, p.offset, p.length); yield r(l, 0, g, g + b); }), depth: i } }; var l; };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0);
                E.exports = async (e, c, n, t, s, u, i, o) => { const h = await i.get(e, o); let a = h, l = n; for (; t.length;) {
                    const p = t[0];
                    if (!(p in a))
                        throw r(new Error(`No property named ${p} found in cbor node ${e.toBaseEncodedString()}`), "ERR_NO_PROP");
                    if (t.shift(), l = `${l}/${p}`, d.isCID(a[p]))
                        return { entry: { name: c, path: n, cid: e, node: h, depth: u }, next: { cid: a[p], name: p, path: l, toResolve: t } };
                    a = a[p];
                } return { entry: { name: c, path: n, cid: e, node: h, depth: u } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(175), e = f(176), c = f(16).multihash;
                E.exports = async (n, t, s, u, i, o, h, a) => { if (u.length)
                    throw d(new Error(`No link named ${s} found in raw node ${n.toBaseEncodedString()}`), "ERR_NOT_FOUND"); const l = await c.decode(n.multihash); return { entry: { name: t, path: s, cid: n, node: l, content: (p = l.digest, function* (g = {}) { const { offset: b, length: I } = e(p.length, g.offset, g.length); yield r(p, 0, b, b + I); }), depth: o } }; var p; };
            }, function (E, m, f) {
                "use strict";
                const d = f(37), r = f(0), { normalizeCidPath: e, mapFile: c } = f(23), n = f(2);
                E.exports = function ({ ipld: t, preload: s }) { return n(async function* (u, i = {}) { if (i.preload !== !1) {
                    let o;
                    try {
                        o = e(u).split("/");
                    }
                    catch (h) {
                        throw r(h, "ERR_INVALID_PATH");
                    }
                    s(o[0]);
                } for await (const o of d.recursive(u, t, i))
                    yield c(o, { ...i, includeContent: !0 }); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(37), r = f(0), { normalizeCidPath: e, mapFile: c } = f(23), n = f(2);
                E.exports = function ({ ipld: t, preload: s }) { return n(async function* (u, i = {}) { const o = e(u), h = i.recursive, a = o.split("/"); i.preload !== !1 && s(a[0]); const l = await d(u, t, i); if (!l.unixfs)
                    throw r(new Error("dag node was not a UnixFS node"), "ERR_NOT_UNIXFS"); if (l.unixfs.type !== "file") {
                    if (!l.unixfs.type.includes("dir"))
                        throw r(new Error("Unknown UnixFS type " + l.unixfs.type), "ERR_UNKNOWN_UNIXFS_TYPE");
                    if (h) {
                        for await (const p of d.recursive(l.cid, t, i))
                            l.cid.toBaseEncodedString() !== p.cid.toBaseEncodedString() && (yield c(p, i));
                        return;
                    }
                    for await (let p of l.content())
                        p = c(p, i), p.depth--, yield p;
                }
                else
                    yield c(l, i); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(287), r = f(2), e = { gitHead: "", ...d };
                E.exports = ({ repo: c }) => r(async function (n) { const t = await c.version.get(n); return { version: e.version, repo: t, commit: e.gitHead, "interface-ipfs-core": e.devDependencies["interface-ipfs-core"] }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(287).version, r = f(13), e = f(2), c = f(5);
                E.exports = ({ peerId: n, network: t }) => e(async function (s) { const u = n.toB58String(); let i = [], o = []; const h = t.try(); if (h) {
                    const { libp2p: a } = h;
                    i = a.transportManager.getAddrs(), o = Array.from(a.upgrader.protocols.keys());
                } return { id: u, publicKey: c(n.pubKey.bytes, "base64pad"), addresses: i.map(a => { const l = a.toString(); return l.endsWith("/p2p/" + u) ? l : `${l}/p2p/${u}`; }).sort().map(a => r(a)), agentVersion: "js-ipfs/" + d, protocolVersion: "9000", protocols: o.sort() }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(682), r = f(683), e = f(684), c = f(685);
                class n {
                    constructor(s) { this.get = d(s), this.resolve = r(s), this.tree = e(s); }
                }
                E.exports = class {
                    constructor({ ipld: t, pin: s, preload: u, gcLock: i, dagReader: o }) { const { get: h, resolve: a, tree: l } = o, p = c({ ipld: t, preload: u, pin: s, gcLock: i }); this.get = h, this.resolve = a, this.tree = l, this.put = p; }
                    static reader(t) { return new n(t); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(2), r = f(266), e = f(40), c = f(110);
                E.exports = ({ ipld: n, preload: t }) => d(async function (s, u = {}) { const { cid: i, path: o } = c(s); return o && (u.path = o), u.preload !== !1 && t(i), u.path ? u.localResolve ? await r(n.resolve(i, u.path)) : await e(n.resolve(i, u.path)) : { value: await n.get(i, u), remainderPath: "" }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(2), e = f(110);
                E.exports = ({ ipld: c, preload: n }) => r(async function (t, s = {}) { const { cid: u, path: i } = e(t); s.preload !== !1 && n(u), i && (s.path = i); let o = u, h = s.path || ""; if (h.startsWith("/") && (h = h.substring(1)), s.path)
                    try {
                        for await (const { value: a, remainderPath: l } of c.resolve(u, s.path, { signal: s.signal })) {
                            if (!d.isCID(a))
                                break;
                            h = l, o = a;
                        }
                    }
                    catch (a) {
                        throw a.message.startsWith("Object has no property") && (a.message = `no link named "${h.split("/")[0]}" under ${o}`, a.code = "ERR_NO_LINK"), a;
                    } return { cid: o, remainderPath: h || "" }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(2), r = f(110);
                E.exports = ({ ipld: e, preload: c }) => d(async function* (n, t = {}) { const { cid: s, path: u } = r(n); u && (t.path = u), t.preload !== !1 && c(s), yield* e.tree(s, t.path, t); });
            }, function (E, m, f) {
                "use strict";
                const d = f(18), r = u => d[u.toUpperCase().replace(/-/g, "_")], e = f(2);
                E.exports = ({ ipld: u, pin: i, gcLock: o, preload: h }) => e(async function (a, l = {}) { const { cidVersion: p, format: g, hashAlg: b } = c(l), I = l.pin ? await o.readLock() : null; try {
                    const v = await u.put(a, g, { hashAlg: b, cidVersion: p, signal: l.signal });
                    return l.pin && await i.add(v, { lock: !1 }), l.preload !== !1 && h(v), v;
                }
                finally {
                    I && I();
                } });
                const c = u => { if (u.cid && (u.format || u.hashAlg))
                    throw new Error("Can't put dag node. Please provide either `cid` OR `format` and `hashAlg` options."); if (u.format && !u.hashAlg || !u.format && u.hashAlg)
                    throw new Error("Can't put dag node. Please provide `format` AND `hashAlg` options."); const { hashAlg: i, format: o } = u.cid != null ? { format: u.cid.code, hashAlg: void 0 } : n({ ...s, ...u }); return { cidVersion: t({ ...u, format: o, hashAlg: i }), format: o, hashAlg: i }; }, n = ({ format: u, hashAlg: i }) => ({ format: typeof u == "string" ? r(u) : u, hashAlg: typeof i == "string" ? r(i) : i }), t = ({ version: u, cid: i, format: o, hashAlg: h }) => typeof u == "number" ? u : i ? i.version : o === d.DAG_PB && h === d.SHA2_256 ? 0 : 1, s = { format: d.DAG_CBOR, hashAlg: d.SHA2_256 };
            }, function (E, m, f) {
                "use strict";
                const d = f(289), r = f(1), e = f(4), c = f(687), n = f(136), t = f(688), s = f(112), u = Object.assign(r("ipfs:preload"), { error: r("ipfs:preload:error") });
                E.exports = (i = {}) => { if (i.enabled = Boolean(i.enabled), i.addresses = i.addresses || [], i.cache = i.cache || 1e3, !i.enabled || !i.addresses.length) {
                    u("preload disabled");
                    const g = () => { };
                    return Object.assign(g, { start: () => { }, stop: () => { } });
                } let o = !0, h = []; const a = i.addresses.map(d), l = s(i.cache), p = async (g) => { try {
                    if (o)
                        throw new Error(`preload ${g} but preloader is not started`);
                    if (typeof g != "string" && (g = new e(g).toString()), l.has(g))
                        return;
                    l.set(g, !0);
                    const b = c(a);
                    let I = !1;
                    const v = Date.now();
                    for (const R of b) {
                        if (o)
                            throw new Error("preload aborted for " + g);
                        let _;
                        try {
                            _ = new n, h = h.concat(_), await t(`${R}/api/v0/refs?r=true&arg=${encodeURIComponent(g)}`, { signal: _.signal }), I = !0;
                        }
                        catch (k) {
                            k.type !== "aborted" && u.error(k);
                        }
                        finally {
                            h = h.filter(k => k !== _);
                        }
                        if (I)
                            break;
                    }
                    u(`${I ? "" : "un"}successfully preloaded ${g} in ${Date.now() - v}ms`);
                }
                catch (b) {
                    u.error(b);
                } }; return p.start = () => { o = !1; }, p.stop = () => { o = !0, u(`aborting ${h.length} pending preload request(s)`), h.forEach(g => g.abort()), h = []; }, p; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { if (!Array.isArray(d))
                    throw new TypeError("Expected Array, got " + typeof d); for (var r, e, c = d.length, n = d.slice(); c;)
                    r = Math.floor(Math.random() * c--), e = n[c], n[c] = n[r], n[r] = e; return n; };
            }, function (E, m, f) {
                "use strict";
                const { default: d } = f(86), r = f(132), e = f(1), c = Object.assign(e("ipfs:preload"), { error: e("ipfs:preload:error") }), n = new d({ concurrency: 4 });
                E.exports = function (t, s = {}) { return c(t), n.add(async () => { const u = (await r.post(t, { signal: s.signal })).body.getReader(); try {
                    for (;;) {
                        const { done: i } = await u.read();
                        if (i)
                            return;
                    }
                }
                finally {
                    u.releaseLock();
                } }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), { cidToString: r } = f(259), e = Object.assign(d("ipfs:mfs-preload"), { error: d("ipfs:mfs-preload:error") });
                E.exports = ({ preload: c, files: n, options: t = {} }) => { if (t.interval = t.interval || 3e4, !t.enabled) {
                    e("MFS preload disabled");
                    const o = async () => { };
                    return { start: o, stop: o };
                } let s, u; const i = async () => { try {
                    const o = await n.stat("/"), h = r(o.cid, { base: "base32" });
                    s !== h && (e(`preloading updated MFS root ${s} -> ${o.cid}`), await c(o.cid), s = h);
                }
                catch (o) {
                    e.error("failed to preload MFS root", o);
                }
                finally {
                    u = setTimeout(i, t.interval);
                } }; return { async start() { const o = await n.stat("/"); s = r(o.cid, { base: "base32" }), e("monitoring MFS root " + o.cid), u = setTimeout(i, t.interval); }, stop() { clearTimeout(u); } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(290), r = f(52), e = { stat: f(119) }, c = { chmod: f(703), cp: f(178), flush: f(707), mkdir: f(179), mv: f(708), rm: f(181), touch: f(709) }, n = { write: f(710), read: f(712), ls: f(713) }, t = ({ options: u, mfs: i, operations: o, lock: h }) => { Object.keys(o).forEach(a => { i[a] = h(o[a](u)); }); }, s = { repoOwner: !0, ipld: null, repo: null };
                E.exports = ({ ipld: u, block: i, blockService: o, repo: h, preload: a, options: l }) => { const p = function (b) { const { repoOwner: I } = Object.assign({}, s || {}, b); b.repo = { blocks: b.blocks, datastore: b.datastore }; const v = d(I), R = {}; return t({ options: b, mfs: R, operations: e, lock: _ => v.readLock(_) }), t({ options: b, mfs: R, operations: c, lock: _ => v.writeLock(_) }), Object.keys(n).forEach(_ => { R[_] = n[_](b); }), R; }({ ipld: u, block: i, blocks: o, datastore: h.root, repoOwner: l.repoOwner }), g = b => (...I) => { const v = I.filter(R => r.ipfsPath(R) || r.cid(R)); if (v.length) {
                    const R = I[I.length - 1];
                    R && R.preload !== !1 && v.forEach(_ => a(_));
                } return b(...I); }; return { ...p, chmod: p.chmod, cp: g(p.cp), mkdir: p.mkdir, stat: g(p.stat), rm: p.rm, read: g(p.read), touch: p.touch, write: p.write, mv: g(p.mv), flush: p.flush, ls: g(async function* (...b) { for await (const I of p.ls(...b))
                        yield { ...I, size: I.size || 0 }; }) }; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(12).EventEmitter, e = f(292), { WORKER_REQUEST_READ_LOCK: c, WORKER_RELEASE_READ_LOCK: n, MASTER_GRANT_READ_LOCK: t, WORKER_REQUEST_WRITE_LOCK: s, WORKER_RELEASE_WRITE_LOCK: u, MASTER_GRANT_WRITE_LOCK: i } = f(293); let o; const h = (l, p, g, b, I) => (v, R) => { R && R.type === g && l.emit(p, R.name, () => (v.send({ type: I, name: R.name, identifier: R.identifier }), new Promise(_ => { const k = x => { x && x.type === b && x.identifier === R.identifier && (v.removeListener("message", k), _()); }; v.on("message", k); }))); }, a = (l, p, g, b) => () => { const I = e.generate(); return d.send({ type: p, identifier: I, name: l }), new Promise(v => { const R = _ => { _ && _.type === g && _.identifier === I && (d.removeListener("message", R), v(() => { d.send({ type: b, identifier: I, name: l }); })); }; d.on("message", R); }); }; E.exports = l => { try {
                    if (o = f(700), !Object.keys(o).length)
                        return;
                }
                catch (p) {
                    return;
                } if (o.isMaster || l.singleProcess) {
                    const p = new r;
                    return o.on("message", h(p, "requestReadLock", c, n, t)), o.on("message", h(p, "requestWriteLock", s, u, i)), p;
                } return { isWorker: !0, readLock: p => a(p, c, t, n), writeLock: p => a(p, s, i, u) }; }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(118), r = f(694), e = f(698), c = f(699) || 0;
                function n() { return r(c); }
                E.exports = n, E.exports.generate = n, E.exports.seed = function (t) { return d.seed(t), E.exports; }, E.exports.worker = function (t) { return c = t, E.exports; }, E.exports.characters = function (t) { return t !== void 0 && d.characters(t), d.shuffled(); }, E.exports.isValid = e;
            }, function (E, m, f) {
                "use strict";
                var d = 1;
                E.exports = { nextValue: function () { return (d = (9301 * d + 49297) % 233280) / 233280; }, seed: function (r) { d = r; } };
            }, function (E, m, f) {
                "use strict";
                var d, r, e = f(695);
                f(118), E.exports = function (c) { var n = "", t = Math.floor(.001 * (Date.now() - 1567752802062)); return t === r ? d++ : (d = 0, r = t), n += e(7), n += e(c), d > 0 && (n += e(d)), n += e(t); };
            }, function (E, m, f) {
                "use strict";
                var d = f(118), r = f(696), e = f(697);
                E.exports = function (c) { for (var n, t = 0, s = ""; !n;)
                    s += e(r, d.get(), 1), n = c < Math.pow(16, t + 1), t++; return s; };
            }, function (E, m, f) {
                "use strict";
                var d, r = typeof window == "object" && (window.crypto || window.msCrypto);
                d = r && r.getRandomValues ? function (e) { return r.getRandomValues(new Uint8Array(e)); } : function (e) { for (var c = [], n = 0; n < e; n++)
                    c.push(Math.floor(256 * Math.random())); return c; }, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { for (var c = (2 << Math.log(r.length - 1) / Math.LN2) - 1, n = -~(1.6 * c * e / r.length), t = "";;)
                    for (var s = d(n), u = n; u--;)
                        if ((t += r[s[u] & c] || "").length === +e)
                            return t; };
            }, function (E, m, f) {
                "use strict";
                var d = f(118);
                E.exports = function (r) { return !(!r || typeof r != "string" || r.length < 6) && !new RegExp("[^" + d.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]").test(r); };
            }, function (E, m, f) {
                "use strict";
                E.exports = 0;
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                const d = f(12).EventEmitter, r = f(292), { WORKER_REQUEST_READ_LOCK: e, WORKER_RELEASE_READ_LOCK: c, MASTER_GRANT_READ_LOCK: n, WORKER_REQUEST_WRITE_LOCK: t, WORKER_RELEASE_WRITE_LOCK: s, MASTER_GRANT_WRITE_LOCK: u } = f(293), i = f(294), o = f(133)(), h = (p, g, b, I, v) => (R, _) => { if (!_ || !_.data || _.data.type !== b)
                    return; const k = { type: _.data.type, name: _.data.name, identifier: _.data.identifier }; p.emit(g, k.name, () => (R.postMessage({ type: v, name: k.name, identifier: k.identifier }), new Promise(x => { const M = N => { if (!N || !N.data)
                    return; const S = { type: N.data.type, name: N.data.name, identifier: N.data.identifier }; S && S.type === I && S.identifier === k.identifier && (R.removeEventListener("message", M), x()); }; R.addEventListener("message", M); }))); }, a = (p, g, b, I) => () => { const v = r.generate(); return o.postMessage({ type: g, identifier: v, name: p }), new Promise(R => { const _ = k => { if (!k || !k.data)
                    return; const x = { type: k.data.type, identifier: k.data.identifier }; x && x.type === b && x.identifier === v && (o.removeEventListener("message", _), R(() => { o.postMessage({ type: I, identifier: v, name: p }); })); }; o.addEventListener("message", _); }); }, l = { singleProcess: !1 };
                E.exports = p => { if (p = Object.assign({}, l, p), !!o.document || p.singleProcess) {
                    const g = new d;
                    return i.addEventListener("message", h(g, "requestReadLock", e, c, n)), i.addEventListener("message", h(g, "requestWriteLock", t, s, u)), g;
                } return { isWorker: !0, readLock: g => a(g, e, n, c), writeLock: g => a(g, t, u, s) }; };
            }, function (E, m, f) {
                "use strict";
                var d;
                E.exports.timeout = function (r, e) { var c, n = new d; return Promise.race([r, new Promise(function (t, s) { c = setTimeout(function () { s(n); }, e); })]).then(function (t) { return clearTimeout(c), t; }, function (t) { throw clearTimeout(c), t; }); }, (d = E.exports.TimeoutError = function () { Error.call(this), this.stack = Error().stack, this.message = "Timeout"; }).prototype = Object.create(Error.prototype), d.prototype.name = "TimeoutError";
            }, function (E, m, f) {
                "use strict";
                const d = f(24).bind({ ignoreUndefined: !0 }), r = f(41), e = f(1)("ipfs:mfs:touch"), c = f(0), n = f(29), t = f(94), s = f(68), u = f(69), i = f(70), { DAGNode: o } = f(17), h = f(18), a = f(16).multihash, { pipe: l } = f(27), p = f(168), g = f(37), b = f(40), I = f(178), v = f(181), R = f(67), _ = f(2), k = { flush: !0, shardSplitThreshold: 1e3, hashAlg: "sha2-256", cidVersion: 0, recursive: !1, signal: void 0 };
                function x(N, S, T) { S || (S = 0); const B = N.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/); if (!B)
                    throw new Error("Invalid file mode: " + N); let [, P, L, j] = B; P !== "a" && P || (P = "ugo"); let D = function (G, W, X) { let Q = 0; return (G.includes("x") || G.includes("X") && (X || 1 & W || 8 & W || 64 & W)) && (Q += 1), G.includes("w") && (Q += 2), G.includes("r") && (Q += 4), Q; }(j, S, T); return D = function (G, W) { let X = 0; return G.includes("u") && (X += W << 6), G.includes("g") && (X += W << 3), G.includes("o") && (X += W), X; }(P, D), D = function (G, W, X) { return W.includes("t") && (X += parseInt("1000", 8)), W.includes("s") && (G.includes("u") && (X += parseInt("4000", 8)), G.includes("g") && (X += parseInt("2000", 8))), X; }(P, j, D), L === "=" ? (P.includes("u") && (S &= parseInt("7077", 8), S |= D), P.includes("g") && (S &= parseInt("7707", 8), S |= D), P.includes("o") && (S &= parseInt("7770", 8), S |= D), S) : L === "+" ? D | S : L === "-" ? D ^ S : void 0; }
                function M(N, S) { return N instanceof String && (N = N.toString()), typeof N == "string" && (N = N.match(/^\d+$/g) ? parseInt(N, 8) : N.split(",").reduce((T, B) => x(B, T, S.isDirectory()), S.mode)), N; }
                E.exports = N => _(async function (S, T, B = {}) { const P = d(k, B); e("Fetching stats for " + S); const { cid: L, mfsDirectory: j, name: D } = await r(N, S, P); if (L.codec !== "dag-pb")
                    throw c(new Error(S + " was not a UnixFS node"), "ERR_NOT_UNIXFS"); if (P.recursive) {
                    const y = await l(async function* () { for await (const C of g.recursive(L, N.ipld)) {
                        let A = await N.ipld.get(C.cid);
                        C.unixfs.mode = M(T, C.unixfs), A = new o(C.unixfs.marshal(), A.Links), yield { path: C.path, content: A };
                    } }, C => p(C, N.block, { ...P, pin: !1, dagBuilder: async function* (A, U, z) { for await (const w of A)
                            yield async function () { return { cid: await R(w.content.serialize(), U, z), path: w.path, unixfs: n.unmarshal(w.content.Data), node: w.content }; }; } }), C => b(C));
                    return await v(N)(S, P), void await I(N)("/ipfs/" + y.cid, S, P);
                } let G = await N.ipld.get(L); const W = n.unmarshal(G.Data); W.mode = M(T, W), G = new o(W.marshal(), G.Links); const X = await N.ipld.put(G, h.DAG_PB, { cidVersion: L.version, hashAlg: a.names[P.hashAlg || k.hashAlg], onlyHash: !P.flush }), Q = await t(N, j), K = Q[Q.length - 1], F = await N.ipld.get(K.cid), Y = await s(N, { parent: F, name: D, cid: X, size: G.serialize().length, flush: P.flush, hashAlg: P.hashAlg, cidVersion: L.version }); K.cid = Y.cid; const $ = await u(N, Q, P); await i(N, $, P); });
            }, function (E, m, f) {
                "use strict";
                const d = f(29), { DAGNode: r } = f(17), e = f(18), c = f(16).multihash;
                E.exports = async (n, t, s) => { const u = c.names[s.hashAlg], i = new d({ type: t, mode: s.mode, mtime: s.mtime }), o = new r(i.marshal()); return { cid: await n.ipld.put(o, e.DAG_PB, { cidVersion: s.cidVersion, hashAlg: u, onlyHash: !s.flush }), node: o }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(180);
                E.exports = async function (r, e, c) { const { sources: n, options: t } = await d(r, e, c); return { destination: n.pop(), sources: n, options: t }; };
            }, function (E, m, f) {
                "use strict";
                const { DAGNode: d, DAGLink: r } = f(17), e = f(4), c = f(1)("ipfs:mfs:core:utils:remove-link"), n = f(29), { generatePath: t, updateHamtDirectory: s } = f(296), u = f(0), i = f(18), o = f(16).multihash, h = async (g, b) => { const I = o.names[b.hashAlg]; b.parent.rmLink(b.name); const v = await g.ipld.put(b.parent, i.DAG_PB, { cidVersion: b.cidVersion, hashAlg: I }); return c("Updated regular directory " + v), { node: b.parent, cid: v }; }, a = async (g, b) => { const { rootBucket: I, path: v } = await t(g, b.name, b.parent); await I.del(b.name); const { node: R } = await l(g, v, { name: b.name, cid: b.cid, size: b.size, hashAlg: b.hashAlg, cidVersion: b.cidVersion, flush: b.flush }, b); return s(g, R.Links, I, b); }, l = async (g, b, I, v) => { const { bucket: R, prefix: _, node: k } = b.pop(), x = k.Links.find(T => T.Name.substring(0, 2) === _); if (!x)
                    throw u(new Error(`No link found with prefix ${_} for file ${I.name}`), "ERR_NOT_FOUND"); if (x.Name === `${_}${I.name}`)
                    return c("Removing existing link " + x.Name), k.rmLink(x.Name), await R.del(I.name), s(g, k.Links, R, v); c(`Descending into sub-shard ${x.Name} for ${_}${I.name}`); const M = await l(g, b, I, v); let N = _; M.node.Links.length === 1 && (c("Removing subshard for " + _), M.cid = M.node.Links[0].Hash, M.node = M.node.Links[0], N = `${_}${M.node.Name.substring(2)}`), c(`Updating shard ${_} with name ${N}`); const S = d.isDAGNode(M.node) ? M.node.size : M.node.Tsize; return p(g, R, k, _, N, S, M.cid, v); }, p = (g, b, I, v, R, _, k, x) => (I.rmLink(v), I.addLink(new r(R, _, k)), s(g, I.Links, b, x));
                E.exports = async (g, b) => { if (!b.parentCid && !b.parent)
                    throw u(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT"); if (b.parentCid && !e.isCID(b.parentCid))
                    throw u(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID"); if (b.parent || (c("Loading parent node " + b.parentCid), b.parent = await g.ipld.get(b.parentCid)), !b.name)
                    throw u(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME"); return n.unmarshal(b.parent.Data).type === "hamt-sharded-directory" ? (c(`Removing ${b.name} from sharded directory`), a(g, b)) : (c(`Removing link ${b.name} regular directory`), h(g, b)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(119), r = f(2), e = f(24).bind({ ignoreUndefined: !0 }), c = { timeout: void 0, signal: void 0 };
                E.exports = n => r(async function (t, s = {}) { s = e(c, s); const { cid: u } = await d(n)(t, s); return u; });
            }, function (E, m, f) {
                "use strict";
                const d = f(180), r = f(178), e = f(181), c = f(2), n = { parents: !1, recursive: !1, flush: !0, cidVersion: 0, hashAlg: "sha2-256", shardSplitThreshold: 1e3, signal: void 0 };
                E.exports = t => c(async function (...s) { const { sources: u, options: i } = await d(t, s, n), o = u.map(a => a.path).concat(i), h = u.slice(0, -1).map(a => a.path).concat(Object.assign(i, { recursive: !0 })); await r(t).apply(null, o), await e(t).apply(null, h); });
            }, function (E, m, f) {
                "use strict";
                const d = f(24).bind({ ignoreUndefined: !0 }), r = f(41), e = f(1)("ipfs:mfs:touch"), c = f(0), n = f(29), t = f(94), s = f(68), u = f(69), i = f(70), { DAGNode: o } = f(17), h = f(18), a = f(16).multihash, l = f(2), p = { mtime: void 0, flush: !0, shardSplitThreshold: 1e3, cidVersion: 0, hashAlg: "sha2-256", signal: void 0 };
                E.exports = g => l(async function (b, I = {}) { const v = d(p, I); v.mtime = v.mtime || new Date, e(`Touching ${b} mtime: ${v.mtime}`); const { cid: R, mfsDirectory: _, name: k, exists: x } = await r(g, b, v); let M, N, S = v.cidVersion; if (x) {
                    if (R.codec !== "dag-pb")
                        throw c(new Error(b + " was not a UnixFS node"), "ERR_NOT_UNIXFS");
                    S = R.version, M = await g.ipld.get(R);
                    const D = n.unmarshal(M.Data);
                    D.mtime = v.mtime, M = new o(D.marshal(), M.Links), N = await g.ipld.put(M, h.DAG_PB, { cidVersion: R.version, hashAlg: a.names["sha2-256"], onlyHash: !v.flush });
                }
                else {
                    const D = new n({ type: "file", mtime: v.mtime });
                    M = new o(D.marshal()), N = await g.ipld.put(M, h.DAG_PB, { cidVersion: v.cidVersion, hashAlg: a.names["sha2-256"], onlyHash: !v.flush });
                } const T = await t(g, _), B = T[T.length - 1], P = await g.ipld.get(B.cid), L = await s(g, { parent: P, name: k, cid: N, size: M.serialize().length, flush: v.flush, shardSplitThreshold: v.shardSplitThreshold, hashAlg: "sha2-256", cidVersion: S }); B.cid = L.cid; const j = await u(g, T, v); await i(g, j, v); });
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:mfs:write"), r = f(168), e = f(119), c = f(179), n = f(68), t = f(24).bind({ ignoreUndefined: !0 }), s = f(290), u = f(711), i = f(41), o = f(177), h = f(94), a = f(69), l = f(70), p = f(0), { MFS_MAX_CHUNK_SIZE: g } = f(23), b = f(40), I = f(2), v = { offset: 0, length: void 0, create: !1, truncate: !1, rawLeaves: !1, reduceSingleLeafToSelf: !1, cidVersion: 0, hashAlg: "sha2-256", parents: !1, progress: () => { }, strategy: "trickle", flush: !0, leafType: "raw", shardSplitThreshold: 1e3, mode: void 0, mtime: void 0, signal: void 0 };
                E.exports = S => I(async function (T, B, P = {}) { let L, j, D; if (P = t(v, P), d("Reading source, destination and parent"), await s().readLock(async () => { L = await u(B), j = await i(S, T, P), D = await i(S, j.mfsDirectory, P); })(), d("Read source, destination and parent"), !P.parents && !D.exists)
                    throw p(new Error("directory does not exist"), "ERR_NO_EXIST"); if (!P.create && !j.exists)
                    throw p(new Error("file does not exist"), "ERR_NO_EXIST"); return R(S, T, L, j, P); });
                const R = async (S, T, B, P, L) => { const j = await _(S, B, P, L); await s().writeLock(async () => { const D = o(T), G = D.pop(); let W = !1; try {
                    await e(S)("/" + D.join("/"), L), W = !0;
                }
                catch (y) {
                    if (y.code !== "ERR_NOT_FOUND")
                        throw y;
                } W || await c(S)("/" + D.join("/"), L); const X = await i(S, T, L), Q = await h(S, X.mfsDirectory), K = Q[Q.length - 1]; if (!K.type.includes("directory"))
                    throw p(new Error(`cannot write to ${K.name}: Not a directory`), "ERR_NOT_A_DIRECTORY"); const F = await S.ipld.get(K.cid), Y = await n(S, { parent: F, name: G, cid: j.cid, size: j.size, flush: L.flush, shardSplitThreshold: L.shardSplitThreshold, hashAlg: L.hashAlg, cidVersion: L.cidVersion }); K.cid = Y.cid; const $ = await a(S, Q, L); await l(S, $, L); })(); }, _ = async (S, T, B, P) => { B.exists ? d(`Overwriting file ${B.cid} offset ${P.offset} length ${P.length}`) : d(`Writing file offset ${P.offset} length ${P.length}`); const L = []; if (P.offset > 0)
                    if (B.unixfs) {
                        if (d(`Writing first ${P.offset} bytes of original file`), L.push(() => B.content({ offset: 0, length: P.offset })), B.unixfs.fileSize() < P.offset) {
                            const X = P.offset - B.unixfs.fileSize();
                            d(`Writing zeros for extra ${X} bytes`), L.push(x(X));
                        }
                    }
                    else
                        d(`Writing zeros for first ${P.offset} bytes`), L.push(x(P.offset)); L.push(k(T, P.length)); const j = N(M(L), X => { if (B.unixfs && !P.truncate) {
                    const Q = B.unixfs.fileSize();
                    if (Q > X)
                        return d(`Writing last ${Q - X} of ${Q} bytes from original file starting at offset ${X}`), B.content({ offset: X });
                    d("Not writing last bytes from original file");
                } return { [Symbol.asyncIterator]: async function* () { } }; }); let D, G; P.mode !== void 0 && P.mode !== null ? D = P.mode : B && B.unixfs && (D = B.unixfs.mode), P.mtime !== void 0 && P.mtine !== null ? G = P.mtime : B && B.unixfs && (G = B.unixfs.mtime); const W = await b(r([{ content: j, mode: D, mtime: G }], S.block, { progress: P.progress, hashAlg: P.hashAlg, cidVersion: P.cidVersion, strategy: P.strategy, rawLeaves: P.rawLeaves, reduceSingleLeafToSelf: P.reduceSingleLeafToSelf, leafType: P.leafType, pin: !1 })); return d("Wrote " + W.cid), { cid: W.cid, size: W.size }; }, k = (S, T) => async function* () { let B = 0; for await (const P of S) {
                    if (B += P.length, B > T)
                        return void (yield P.slice(0, T - B));
                    yield P;
                } }, x = (S, T = g) => { const B = new Uint8Array(T), P = { [Symbol.asyncIterator]: function* () { for (;;)
                        yield B.slice(); } }; return k(P, S); }, M = async function* (S) { for (let T = 0; T < S.length; T++)
                    yield* S[T](); }, N = async function* (S, T) { let B = 0; for await (const P of S)
                    B += P.length, yield P; for await (const P of T(B))
                    B += P.length, yield P; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(0), e = f(1)("ipfs:mfs:utils:to-async-iterator"), { MFS_MAX_CHUNK_SIZE: c } = f(23), n = f(6); E.exports = t => { if (!t)
                    throw r(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH"); if ((typeof t == "string" || t instanceof String) && (e("Content was a string"), t = n(t)), t.length)
                    return e("Content was array-like"), { [Symbol.asyncIterator]: function* () { yield t; } }; if (t[Symbol.asyncIterator])
                    return e("Content was an async iterator"), t; if (t[Symbol.iterator])
                    return e("Content was an iterator"), t; if (d.Blob && t instanceof d.Blob) {
                    e("Content was an HTML5 Blob");
                    let s = 0;
                    const u = { next: () => s > t.size ? { done: !0 } : new Promise((i, o) => { const h = t.slice(s, c); s += c; const a = new d.FileReader, l = p => { if (a.removeEventListener("loadend", l, !1), p.error)
                            return o(p.error); i({ done: !1, value: new Uint8Array(a.result) }); }; a.addEventListener("loadend", l), a.readAsArrayBuffer(h); }) };
                    return { [Symbol.asyncIterator]: () => u };
                } throw r(new Error(`Don't know how to convert ${t} into an async iterator`), "ERR_INVALID_PARAMS"); }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = f(37), r = f(24).bind({ ignoreUndefined: !0 }), e = f(41), c = f(0), n = f(2), t = { offset: 0, length: 1 / 0, signal: void 0 };
                E.exports = s => n(function (u, i = {}) { return i = r(t, i), { [Symbol.asyncIterator]: async function* () { const o = await e(s, u, i), h = await d(o.mfsPath, s.ipld); if (h.unixfs.type !== "file")
                        throw c(new Error(u + " was not a file"), "ERR_NOT_FILE"); if (!h.content)
                        throw c(new Error("Could not load content stream from " + u), "ERR_NO_CONTENT"); for await (const a of h.content({ offset: i.offset, length: i.length }))
                        yield a; } }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(37), r = f(41), e = f(2), c = n => { let t, s, u = "file", i = n.node.size || n.node.length; n.unixfs && (i = n.unixfs.fileSize(), u = n.unixfs.type, n.unixfs.type === "hamt-sharded-directory" && (u = "directory"), t = n.unixfs.mode, s = n.unixfs.mtime); const o = { cid: n.cid, name: n.name, type: u, size: i }; return s !== void 0 && (o.mtime = s), t !== void 0 && (o.mode = t), o; };
                E.exports = n => e(async function* (t, s = {}) { const u = await r(n, t, s), i = await d(u.mfsPath, n.ipld); if (i.unixfs && i.unixfs.type.includes("directory"))
                    for await (const o of i.content(s))
                        yield c(o);
                else
                    yield c(i); });
            }, function (E, m, f) {
                "use strict";
                const d = f(715), r = f(716), e = f(717), c = f(718), n = f(719), t = f(720), s = f(721);
                E.exports = class {
                    constructor({ keychain: u }) { this.gen = r({ keychain: u }), this.list = n({ keychain: u }), this.rm = s({ keychain: u }), this.rename = t({ keychain: u }), this.export = d({ keychain: u }), this.import = e({ keychain: u }), this.info = c({ keychain: u }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e, c, n) => r.exportKey(e, c, n));
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e, c = {}) => r.createKey(e, c.type || "rsa", c.size || 2048));
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e, c, n, t) => r.importKey(e, c, n, t));
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e, c = {}) => r.findKeyByName(e, c));
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e = {}) => r.listKeys(e));
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d(async (e, c, n = {}) => { const t = await r.renameKey(e, c, n); return { was: e, now: t.name, id: t.id, overwrite: !1 }; });
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ keychain: r }) => d((e, c) => r.removeKey(e, c));
            }, function (E, m, f) {
                "use strict";
                const d = f(723), r = f(56), e = f(724), c = f(725), n = f(95), t = f(726), s = f(727);
                E.exports = class {
                    constructor({ ipld: u, preload: i, dag: o, gcLock: h }) { this.data = d({ ipld: u, preload: i }), this.get = r({ ipld: u, preload: i }), this.links = e({ dag: o }), this.new = c({ ipld: u, preload: i }), this.put = n({ ipld: u, preload: i, gcLock: h }), this.stat = t({ ipld: u, preload: i }), this.patch = new s({ ipld: u, preload: i, gcLock: h }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ ipld: r, preload: e }) => { const c = f(56)({ ipld: r, preload: e }); return d(async function (n, t) { return (await c(n, t)).Data; }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(17).DAGLink, r = f(4), e = f(2);
                E.exports = ({ dag: c }) => e(async function (n, t = {}) { const s = new r(n), u = await c.get(s, t); if (s.codec === "raw")
                    return []; if (s.codec === "dag-pb")
                    return u.value.Links; if (s.codec === "dag-cbor")
                    return function i(o, h = []) { for (const a in o) {
                        const l = o[a];
                        if (a === "/" && Object.keys(o).length === 1)
                            try {
                                h.push(new d("", 0, new r(l)));
                                continue;
                            }
                            catch (p) { }
                        r.isCID(l) ? h.push(new d("", 0, l)) : (Array.isArray(l) && i(l, h), l && typeof l == "object" && i(l, h));
                    } return h; }(u); throw new Error("Cannot resolve links from codec " + s.codec); });
            }, function (E, m, f) {
                "use strict";
                const d = f(17).DAGNode, r = f(18), e = f(29), c = f(2);
                E.exports = ({ ipld: n, preload: t }) => c(async function (s = {}) { let u; if (s.template) {
                    if (s.template !== "unixfs-dir")
                        throw new Error("unknown template");
                    u = new e("directory").marshal();
                }
                else
                    u = new Uint8Array(0); const i = new d(u), o = await n.put(i, r.DAG_PB, { cidVersion: 0, hashAlg: r.SHA2_256, signal: s.signal }); return s.preload !== !1 && t(o), o; });
            }, function (E, m, f) {
                "use strict";
                const d = f(17), r = f(2);
                E.exports = ({ ipld: e, preload: c }) => { const n = f(56)({ ipld: e, preload: c }); return r(async function (t, s = {}) { const u = await n(t, s), i = d.util.serialize(u), o = await d.util.cid(i, { cidVersion: 0 }), h = i.length, a = u.Links.reduce((l, p) => l + p.Tsize, 0); return { Hash: o.toBaseEncodedString(), NumLinks: u.Links.length, BlockSize: h, LinksSize: h - u.Data.length, DataSize: u.Data.length, CumulativeSize: h + a }; }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(728), r = f(729), e = f(730), c = f(731);
                E.exports = class {
                    constructor({ ipld: n, preload: t, gcLock: s }) { this.addLink = d({ ipld: n, preload: t, gcLock: s }), this.appendData = r({ ipld: n, preload: t, gcLock: s }), this.rmLink = e({ ipld: n, preload: t, gcLock: s }), this.setData = c({ ipld: n, preload: t, gcLock: s }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ ipld: r, gcLock: e, preload: c }) => { const n = f(56)({ ipld: r, preload: c }), t = f(95)({ ipld: r, gcLock: e, preload: c }); return d(async function (s, u, i) { const o = await n(s, i); return o.addLink(u), t(o, i); }); };
            }, function (E, m, f) {
                "use strict";
                const { DAGNode: d } = f(17), r = f(2), e = f(31);
                E.exports = ({ ipld: c, gcLock: n, preload: t }) => { const s = f(56)({ ipld: c, preload: t }), u = f(95)({ ipld: c, gcLock: n, preload: t }); return r(async function (i, o, h) { const a = await s(i, h), l = e([a.Data, o]); return u(new d(l, a.Links), h); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(2);
                E.exports = ({ ipld: r, gcLock: e, preload: c }) => { const n = f(56)({ ipld: r, preload: c }), t = f(95)({ ipld: r, gcLock: e, preload: c }); return d(async function (s, u, i) { const o = await n(s, i); return o.rmLink(u.Name || u.name), t(o, i); }); };
            }, function (E, m, f) {
                "use strict";
                const { DAGNode: d } = f(17), r = f(2);
                E.exports = ({ ipld: e, gcLock: c, preload: n }) => { const t = f(56)({ ipld: e, preload: n }), s = f(95)({ ipld: e, gcLock: c, preload: n }); return r(async function (u, i, o) { const h = await t(u, o); return s(new d(i, h.Links), o); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(733), r = f(297), e = f(734);
                E.exports = class {
                    constructor({ gcLock: c, pin: n, repo: t, refs: s }) { this.gc = d({ gcLock: c, pin: n, refs: s, repo: t }), this.stat = r({ repo: t }), this.version = e({ repo: t }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(1)("ipfs:repo:gc"), { MFS_ROOT_KEY: e } = f(23), c = f(2), { Errors: n } = f(11), t = n.notFoundError().code, { parallelMerge: s, transform: u, map: i } = f(55), o = f(25);
                E.exports = ({ gcLock: h, pin: a, refs: l, repo: p }) => c(async function* (g = {}) { const b = Date.now(); r("Creating set of marked blocks"); const I = await h.writeLock(); try {
                    const v = await async function ({ pin: _, refs: k, repo: x }) { const M = i(({ cid: T }) => T, _.ls()), N = async function* () { let T; try {
                        T = await x.root.get(e);
                    }
                    catch (P) {
                        if (P.code === t)
                            return void r("No blocks in MFS");
                        throw P;
                    } const B = new d(T); yield B; for await (const { ref: P } of k(B, { recursive: !0 }))
                        yield new d(P); }(), S = new Set; for await (const T of s(M, N))
                        S.add(o.encode("base32", T.multihash).toString()); return S; }({ pin: a, refs: l, repo: p }), R = p.blocks.query({ keysOnly: !0 });
                    yield* async function* ({ repo: _ }, k, x) { let M = 0, N = 0; const S = async (T) => { M++; try {
                        const B = o.encode("base32", T.multihash).toString();
                        if (k.has(B))
                            return null;
                        const P = { cid: T };
                        try {
                            await _.blocks.delete(T), N++;
                        }
                        catch (L) {
                            P.err = new Error(`Could not delete block with CID ${T}: ${L.message}`);
                        }
                        return P;
                    }
                    catch (B) {
                        const P = "Could delete block with CID " + T;
                        return r(P, B), { err: new Error(P + ": " + B.message) };
                    } }; for await (const T of u(256, S, x))
                        T && (yield T); r(`Marked set has ${k.size} unique blocks. Blockstore has ${M} blocks. Deleted ${N} blocks.`); }({ repo: p }, v, R), r(`Complete (${Date.now() - b}ms)`);
                }
                finally {
                    I();
                } });
            }, function (E, m, f) {
                "use strict";
                const { repoVersion: d } = f(182), r = f(2);
                E.exports = ({ repo: e }) => r(async function (c) { try {
                    await e._checkInitialized(c);
                }
                catch (n) {
                    if ([/Key not found in database \[\/version\]/, /ENOENT/, /repo is not initialized yet/].some(t => t.test(n.message)))
                        return d;
                    throw n;
                } return e.version.get(c); });
            }, function (E, m, f) {
                "use strict";
                const d = f(736), r = f(742), e = f(744), c = f(183), n = f(1)("ipfs:repo:migrator");
                function t(u) { return u = u || d, Array.isArray(u) && u.length !== 0 ? u[u.length - 1].version : 0; }
                function s(u, i, o, h = !1) { let a = 0; for (const l of u) {
                    if (l.version > o)
                        break;
                    if (l.version > i) {
                        if (h && !l.revert)
                            throw new c.NonReversibleMigrationError(`It is not possible to revert to version ${i} because migration version ${l.version} is not reversible. Cancelling reversion.`);
                        a++;
                    }
                } if (a !== o - i)
                    throw new c.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${i} to ${o}`); }
                m.getCurrentRepoVersion = r.getVersion, m.errors = c, m.getLatestMigrationVersion = t, m.migrate = async function (u, i, o, { ignoreLock: h = !1, onProgress: a, isDryRun: l = !1, migrations: p }) { if (p = p || d, !u)
                    throw new c.RequiredParameterError("Path argument is required!"); if (!i)
                    throw new c.RequiredParameterError("repoOptions argument is required!"); if (!o)
                    throw new c.RequiredParameterError("toVersion argument is required!"); if (!Number.isInteger(o) || o <= 0)
                    throw new c.InvalidValueError("Version has to be positive integer!"); const g = await r.getVersion(u, i); if (g === o)
                    return void n("Nothing to migrate."); if (g > o)
                    throw new c.InvalidValueError(`Current repo's version (${g}) is higher then toVersion (${o}), you probably wanted to revert it?`); let b; s(p, g, o), l || h || (b = await e.lock(g, u)); try {
                    for (const I of p) {
                        if (o !== void 0 && I.version > o)
                            break;
                        if (!(I.version <= g)) {
                            n("Migrating version " + I.version);
                            try {
                                if (!l) {
                                    let v;
                                    a && (v = (R, _) => a(I.version, R.toFixed(2), _)), await I.migrate(u, i, v);
                                }
                            }
                            catch (v) {
                                const R = I.version - 1;
                                throw n("An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: " + R), await r.setVersion(u, R, i), new Error(`During migration to version ${I.version} exception was raised: ${v.stack || v.message || v}`);
                            }
                            n(`Migrating to version ${I.version} finished`);
                        }
                    }
                    l || await r.setVersion(u, o || t(p), i), n("Repo successfully migrated ", o !== void 0 ? `to version ${o}!` : "to latest version!");
                }
                finally {
                    l || h || await b.close();
                } }, m.revert = async function (u, i, o, { ignoreLock: h = !1, onProgress: a, isDryRun: l = !1, migrations: p }) { if (p = p || d, !u)
                    throw new c.RequiredParameterError("Path argument is required!"); if (!i)
                    throw new c.RequiredParameterError("repoOptions argument is required!"); if (!o)
                    throw new c.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!"); if (!Number.isInteger(o) || o <= 0)
                    throw new c.InvalidValueError("Version has to be positive integer!"); const g = await r.getVersion(u, i); if (g === o)
                    return void n("Nothing to revert."); if (g < o)
                    throw new c.InvalidValueError(`Current repo's version (${g}) is lower then toVersion (${o}), you probably wanted to migrate it?`); let b; s(p, o, g, !0), l || h || (b = await e.lock(g, u)), n(`Reverting from version ${g} to ${o}`); try {
                    const I = p.slice().reverse();
                    for (const v of I) {
                        if (v.version <= o)
                            break;
                        if (!(v.version > g)) {
                            n("Reverting migration version " + v.version);
                            try {
                                if (!l) {
                                    let R;
                                    a && (R = (_, k) => a(v.version, _.toFixed(2), k)), await v.revert(u, i, R);
                                }
                            }
                            catch (R) {
                                const _ = v.version;
                                throw n("An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: " + _), await r.setVersion(u, _, i), R.message = `During reversion to version ${v.version} exception was raised: ${R.message}`, R;
                            }
                            n(`Reverting to version ${v.version} finished`);
                        }
                    }
                    l || await r.setVersion(u, o, i), n(`All migrations successfully reverted to version ${o}!`);
                }
                finally {
                    l || h || await b.close();
                } };
            }, function (E, m, f) {
                "use strict";
                const d = { description: "Empty migration.", migrate: () => { }, revert: () => { }, empty: !0 };
                E.exports = [Object.assign({ version: 1 }, d), Object.assign({ version: 2 }, d), Object.assign({ version: 3 }, d), Object.assign({ version: 4 }, d), Object.assign({ version: 5 }, d), Object.assign({ version: 6 }, d), Object.assign({ version: 7 }, d), f(737), f(738)];
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(11).Key, e = f(25), c = f(1)("ipfs:repo:migrator:migration-8"), n = f(5), { createStore: t } = f(120), s = f(299);
                function u(h) { const a = e.decode("b" + h.toString().slice(1)); let l = new d(a).multihash; return l = e.encode("base32", l).slice(1), l = n(l).toUpperCase(), new r("/" + l, !1); }
                function i(h) { const a = e.decode("b" + h.toString().slice(1)), l = e.encode("base32", new d(1, "raw", a).bytes).slice(1); return new r(("/" + n(l)).toUpperCase(), !1); }
                async function o(h, a, l, p) { const g = await t(h, "blocks", a); let b; await g.open(), l && (b = await s(g.query({ keysOnly: !0, filters: [({ key: I }) => p(I).toString() !== I.toString()] }))); try {
                    let I = 0;
                    for await (const v of g.query({})) {
                        const R = p(v.key);
                        R.toString() !== v.key.toString() && (I += 1, c(`Migrating Block from ${v.key} to ${R}`), await g.delete(v.key), await g.put(R, v.value), l && l(I / b * 100, `Migrated Block from ${v.key} to ${R}`));
                    }
                }
                finally {
                    await g.close();
                } }
                E.exports = { version: 8, description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32", migrate: (h, a, l) => o(h, a, l, u), revert: (h, a, l) => o(h, a, l, i) };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(17), e = f(267), c = f(18), n = f(25), t = f(739), { createStore: s } = f(120), { cidToKey: u, PIN_DS_KEY: i, PinTypes: o } = f(300), h = f(299);
                async function a(g, b, I, v) { if (!await b.has(i))
                    return; const R = await b.get(i), _ = new d(R), k = await g.get(u(_)), x = r.util.deserialize(k); let M, N = 0; v && (M = await h(t.loadSet(g, x, o.recursive)) + await h(t.loadSet(g, x, o.direct))); for await (const S of t.loadSet(g, x, o.recursive)) {
                    N++;
                    const T = { depth: 1 / 0 };
                    S.version !== 0 && (T.version = S.version), S.codec !== "dag-pb" && (T.codec = c.getNumber(S.codec)), await I.put(u(S), e.encode(T)), v && v(N / M * 100, "Migrated recursive pin " + S);
                } for await (const S of t.loadSet(g, x, o.direct)) {
                    N++;
                    const T = { depth: 0 };
                    S.version !== 0 && (T.version = S.version), S.codec !== "dag-pb" && (T.codec = c.getNumber(S.codec)), await I.put(u(S), e.encode(T)), v(N / M * 100, "Migrated direct pin " + S);
                } await g.delete(u(_)), await b.delete(i); }
                async function l(g, b, I, v) { let R, _ = [], k = [], x = 0; v && (R = await h(I.query({ keysOnly: !0 }))); for await (const { key: S, value: T } of I.query({})) {
                    x++;
                    const B = e.decode(T), P = new d(B.version || 0, B.codec && c.getName(B.codec) || "dag-pb", n.decode("b" + S.toString().split("/").pop()));
                    B.depth === 0 ? (v && v(x / R * 100, "Reverted direct pin " + P), k.push(P)) : (v && v(x / R * 100, "Reverted recursive pin " + P), _.push(P));
                } v(100, "Updating pin root"); const M = new r.DAGNode(new Uint8Array, [await t.storeSet(g, o.recursive, _), await t.storeSet(g, o.direct, k)]).serialize(), N = await r.util.cid(M, { cidVersion: 0, hashAlg: c.SHA2_256 }); await g.put(u(N), M), await b.put(i, N.multihash); }
                async function p(g, b, I, v) { const R = await s(g, "blocks", b), _ = await s(g, "datastore", b), k = await s(g, "pins", b); await R.open(), await _.open(), await k.open(); try {
                    await v(R, _, k, I);
                }
                finally {
                    await k.close(), await _.close(), await R.close();
                } }
                E.exports = { version: 9, description: "Migrates pins to datastore", migrate: (g, b, I) => p(g, b, I, a), revert: (g, b, I) => p(g, b, I, l) };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(21), e = f(740), c = f(19), n = f(17), { DAGNode: t, DAGLink: s } = n, u = f(18), i = f(741), { cidToKey: o, DEFAULT_FANOUT: h, MAX_ITEMS: a, EMPTY_KEY: l } = f(300), p = f(31), g = f(252), b = f(5), I = f(6), v = f(20), R = r(i);
                function _(x, M) { const N = new Uint8Array(4); new DataView(N.buffer).setUint32(0, x, !0); const S = I(function (B) { return new d(B).toBaseEncodedString(); }(M)), T = p([N, S], N.byteLength + S.byteLength); return e(b(T)); }
                async function* k(x, M) { const N = function (T) { const B = T.Data, P = c.decode(B), L = c.decode.bytes; if (L <= 0)
                    throw new Error("Invalid Set header length"); if (L + P > B.length)
                    throw new Error("Impossibly large set header length"); const j = B.slice(L, P + L), D = R.Set.decode(j); if (D.version !== 1)
                    throw new Error("Unsupported Set version: " + D.version); if (D.fanout > T.Links.length)
                    throw new Error("Impossibly large fanout"); return { header: D, data: B.slice(P + L) }; }(M); let S = 0; for (const T of M.Links) {
                    if (S < N.header.fanout) {
                        const B = T.Hash;
                        if (!v(l, B.bytes)) {
                            const P = await x.get(o(B)), L = n.util.deserialize(P);
                            yield* k(x, L);
                        }
                    }
                    else
                        yield T.Hash;
                    S++;
                } }
                E.exports = { loadSet: async function* (x, M, N) { const S = M.Links.find(P => P.Name === N); if (!S)
                        throw new Error("No link found with name " + N); const T = await x.get(o(S.Hash)), B = n.util.deserialize(T); yield* k(x, B); }, storeSet: async function (x, M, N) { const S = await function (P, L) { return async function j(D, G) { const W = R.Set.encode({ version: 1, fanout: h, seed: G }), X = c.encode(W.length), Q = p([X, W]), K = []; for (let Y = 0; Y < h; Y++)
                        K.push(new s("", 1, l)); if (D.length <= a) {
                        const Y = D.map(C => ({ link: new s("", 1, C.key), data: C.data || new Uint8Array })).sort((C, A) => g(C.link.Hash.bytes, A.link.Hash.bytes)), $ = K.concat(Y.map(C => C.link)), y = p([Q, ...Y.map(C => C.data)]);
                        return new t(y, $);
                    } {
                        const Y = D.reduce((y, C) => { const A = _(G, C.key) % h; return y[A] = A in y ? y[A].concat([C]) : [C], y; }, []);
                        let $ = 0;
                        for (const y of Y) {
                            const C = await j(y, G + 1);
                            await F(C, $), $++;
                        }
                        return new t(Q, K);
                    } async function F(Y, $) { const y = n.util.serialize(Y), C = await n.util.cid(y, { cidVersion: 0, hashAlg: u.SHA2_256 }); await P.put(o(C), y), K[$] = new s("", Y.size, C); } }(L, 0); }(x, N.map(P => ({ key: P, data: null }))), T = S.serialize(S), B = await n.util.cid(T, { cidVersion: 0, hashAlg: u.SHA2_256 }); return await x.put(o(B), T), new s(M, S.size, B); } };
            }, function (E, m, f) {
                "use strict";
                function d(r) { for (var e = d.BASE, c = 0, n = r.length; c < n; c++)
                    e ^= r.charCodeAt(c), e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24); return e >>> 0; }
                d.BASE = 2166136261, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                E.exports = `
  syntax = "proto2";

  package ipfs.pin;

  option go_package = "pb";

  message Set {
    optional uint32 version = 1;
    optional uint32 fanout = 2;
    optional fixed32 seed = 3;
  }
`;
            }, function (E, m, f) {
                "use strict";
                const d = f(743), { MissingRepoOptionsError: r, NotInitializedRepoError: e } = f(183), { VERSION_KEY: c, createStore: n } = f(120), t = f(6);
                m.getVersion = async function (s, u) { if (!await d.isRepoInitialized(s, u))
                    throw new e(`Repo in path ${s} is not initialized!`); if (!u)
                    throw new r("Please pass repo options when trying to open a repo"); const i = await n(s, "root", u); await i.open(); const o = parseInt(await i.get(c)); return await i.close(), o; }, m.setVersion = async function (s, u, i) { if (!i)
                    throw new r("Please pass repo options when trying to open a repo"); const o = await n(s, "root", i); await o.open(), await o.put(c, t(String(u))), await o.close(); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:repo:migrator:repo:init"), { CONFIG_KEY: r, VERSION_KEY: e, createStore: c } = f(120), { MissingRepoOptionsError: n } = f(183);
                m.isRepoInitialized = async function (t, s) { if (!s)
                    throw new n("Please pass repo options when trying to open a repo"); let u; try {
                    u = await c(t, "root", s), await u.open();
                    const i = await u.has(e), o = await u.has(r);
                    return !(!i || !o) || (d("Version entry present: " + i), d("Config entry present: " + o), !1);
                }
                catch (i) {
                    return d("While checking if repo is initialized error was thrown: " + i.message), !1;
                }
                finally {
                    u !== void 0 && await u.close();
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:repo:migrator:repo_mem_lock"), r = {};
                m.lock = async function (e, c) { const n = c + "/repo.lock"; if (d("locking %s", n), r[n] === !0)
                    throw Error("There is already present lock for: " + n); return r[n] = !0, { close() { r[n] && (d("releasing lock %s", n), delete r[n]); } }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (s, u) { return typeof s == "string" ? t(s) : typeof s == "number" ? n(s, u) : null; }, E.exports.format = n, E.exports.parse = t;
                var d = /\B(?=(\d{3})+(?!\d))/g, r = /(?:\.0*|(\.[^0]+)0+)$/, e = { b: 1, kb: 1024, mb: 1 << 20, gb: 1 << 30, tb: Math.pow(1024, 4), pb: Math.pow(1024, 5) }, c = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
                function n(s, u) { if (!Number.isFinite(s))
                    return null; var i = Math.abs(s), o = u && u.thousandsSeparator || "", h = u && u.unitSeparator || "", a = u && u.decimalPlaces !== void 0 ? u.decimalPlaces : 2, l = Boolean(u && u.fixedDecimals), p = u && u.unit || ""; p && e[p.toLowerCase()] || (p = i >= e.pb ? "PB" : i >= e.tb ? "TB" : i >= e.gb ? "GB" : i >= e.mb ? "MB" : i >= e.kb ? "KB" : "B"); var g = (s / e[p.toLowerCase()]).toFixed(a); return l || (g = g.replace(r, "$1")), o && (g = g.replace(d, o)), g + h + p; }
                function t(s) { if (typeof s == "number" && !isNaN(s))
                    return s; if (typeof s != "string")
                    return null; var u, i = c.exec(s), o = "b"; return i ? (u = parseFloat(i[1]), o = i[4].toLowerCase()) : (u = parseInt(s, 10), o = "b"), Math.floor(e[o] * u); }
            }, function (E, m, f) {
                "use strict";
                E.exports = function (...d) { return d.length === 0 ? "." : d.join("/"); };
            }, function (E, m, f) {
                "use strict";
                E.exports = { repoVersion: 9 };
            }, function (E, m, f) {
                "use strict";
                m.create = function (d, r, e) { return new e.storageBackends[d](r, Object.assign({}, e.storageBackendOptions[d] || {})); };
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, r = f(1)("ipfs:repo:version"), e = f(5), c = f(6), n = new d("version");
                E.exports = t => ({ exists: async () => t.has(n), async get() { const s = await t.get(n); return parseInt(e(s), 10); }, set: async (s) => t.put(n, c(String(s))), async check(s) { const u = await this.get(); return r("comparing version: %s and %s", u, s), u === s || u === 6 && s === 7 || s === 6 && u === 7; } });
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, { default: r } = f(86), e = f(298), c = f(751), n = f(0), t = f(184), s = f(5), u = f(6), i = new d("config");
                E.exports = o => { const h = new r({ concurrency: 1 }), a = { getAll: async (g = {}) => a.get(void 0, g), async get(g, b = {}) { g || (g = void 0); const I = await o.get(i); if (b.signal && b.signal.aborted)
                        return; const v = JSON.parse(s(I)); if (g !== void 0 && e(v, g) === void 0)
                        throw new t.NotFoundError(`Key ${g} does not exist in config`); return g !== void 0 ? e(v, g) : v; }, async set(g, b, I = {}) { if (arguments.length === 1)
                        b = g, g = void 0;
                    else if (!g || typeof g != "string")
                        throw n(new Error("Invalid key type: " + typeof g), "ERR_INVALID_KEY"); if (b === void 0 || b instanceof Uint8Array)
                        throw n(new Error("Invalid value type: " + typeof b), "ERR_INVALID_VALUE"); return h.add(() => l({ key: g, value: b }, I.signal)); }, async replace(g, b = {}) { if (!g || g instanceof Uint8Array)
                        throw n(new Error("Invalid value type: " + typeof g), "ERR_INVALID_VALUE"); return h.add(() => l({ key: void 0, value: g }, b.signal)); }, exists: async () => o.has(i) }; return a; async function l(g, b) { if (b && b.aborted)
                    return; const I = g.key, v = g.value; if (I) {
                    const R = await a.get();
                    return c(R, I, v), p(R);
                } return p(v); } function p(g) { const b = u(JSON.stringify(g, null, 2)); return o.put(i, b); } };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { typeof r == "string" && (r = r.split(".")), typeof r == "symbol" && (r = [r]); var c, n = r.pop(); if (!n)
                    return !1; for (; c = r.shift();)
                    if (d[c] === void 0 && (d[c] = {}), !(d = d[c]) || typeof d != "object")
                        return !1; return d[n] = e, !0; };
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, r = f(753), e = f(5), c = f(6), n = new d("datastore_spec");
                E.exports = t => ({ exists: async () => t.has(n), async get() { const s = await t.get(n); return JSON.parse(e(s)); }, set: async (s) => t.put(n, c(JSON.stringify(r(s, { deep: !0 })))) });
            }, function (E, m, f) {
                "use strict";
                const d = f(134);
                E.exports = (r, e = {}) => { if (!d(r) && !Array.isArray(r))
                    throw new TypeError("Expected a plain object or array"); const { deep: c } = e, n = [], t = [], s = i => { const o = n.indexOf(i); if (o !== -1)
                    return t[o]; const h = []; return n.push(i), t.push(h), h.push(...i.map(a => Array.isArray(a) ? s(a) : d(a) ? u(a) : a)), h; }, u = i => { const o = n.indexOf(i); if (o !== -1)
                    return t[o]; const h = {}, a = Object.keys(i).sort(e.compare); n.push(i), t.push(h); for (const l of a) {
                    const p = i[l];
                    c && Array.isArray(p) ? h[l] = s(p) : h[l] = c && d(p) ? u(p) : p;
                } return h; }; return Array.isArray(r) ? c ? s(r) : r.slice() : u(r); };
            }, function (E, m, f) {
                "use strict";
                const d = f(11).Key, r = f(6), e = new d("api");
                E.exports = c => ({ async get() { const n = await c.get(e); return n && n.toString(); }, set: async (n) => c.put(e, r(n.toString())), delete: async () => c.delete(e) });
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(163), e = r.ShardingDatastore, c = f(93), { cidToKey: n, keyToCid: t } = f(301), s = f(174), u = f(247), i = f(96); E.exports = async (o, h) => function (a) { return { async *query(l, p) { for await (const { key: g, value: b } of a.query(l, p))
                        l.keysOnly ? yield t(g) : yield new c(b, t(g)); }, async get(l, p) { const g = n(l), b = await a.get(g, p); return new c(b, l); }, async *getMany(l, p) { for await (const g of l)
                        yield this.get(g, p); }, async put(l, p) { if (!c.isBlock(l))
                        throw new Error("invalid block"); const g = n(l.cid); return await a.has(g, p) || await a.put(g, l.data, p), l; }, async *putMany(l, p) { const g = i(); (d && d.nextTick ? d.nextTick : setImmediate)(async () => { try {
                        await u(a.putMany(async function* () { for await (const b of l) {
                            const I = n(b.cid);
                            await a.has(I, p) || (yield { key: I, value: b.data }), g.push(b);
                        } }())), g.end();
                    }
                    catch (b) {
                        g.end(b);
                    } }), yield* g; }, has: async (l, p) => a.has(n(l), p), delete: async (l, p) => a.delete(n(l), p), async *deleteMany(l, p) { yield* a.deleteMany(s(l, g => n(g)), p); }, close: async () => a.close() }; }(await function (a, l) { if (l.sharding) {
                    const p = new r.shard.NextToLast(2);
                    return e.createOrOpen(a, p);
                } return a; }(o, h)); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = class {
                    constructor(d) { if (!(d > 0) || (d - 1 & d) != 0)
                        throw new Error("Max size for a FixedFIFO should be a power of two"); this.buffer = new Array(d), this.mask = d - 1, this.top = 0, this.btm = 0, this.next = null; }
                    push(d) { return this.buffer[this.top] === void 0 && (this.buffer[this.top] = d, this.top = this.top + 1 & this.mask, !0); }
                    shift() { const d = this.buffer[this.btm]; if (d !== void 0)
                        return this.buffer[this.btm] = void 0, this.btm = this.btm + 1 & this.mask, d; }
                    isEmpty() { return this.buffer[this.btm] === void 0; }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = { lock: "memory", storageBackends: { root: f(97), blocks: f(97), keys: f(97), datastore: f(97), pins: f(97) }, storageBackendOptions: { root: { extension: "", prefix: "", version: 2 }, blocks: { sharding: !1, prefix: "", version: 2 }, keys: { sharding: !1, prefix: "", version: 2 }, datastore: { sharding: !1, prefix: "", version: 2 }, pins: { sharding: !1, prefix: "", version: 2 } } };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(759)(f(793));
            }, function (E, m, f) {
                "use strict";
                var d = f(760), r = f(789);
                E.exports = function (e) { function c(t, s, u) { return typeof t == "function" ? u = t : typeof s == "function" && (u = s), n(s) || (s = n(t) ? t : {}), d(r(e(t, s), s), s, u); } function n(t) { return typeof t == "object" && t !== null; } return ["destroy", "repair"].forEach(function (t) { typeof e[t] == "function" && (c[t] = function () { e[t].apply(e, arguments); }); }), c.errors = d.errors, c; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(12).EventEmitter, e = f(64).inherits, c = f(71), n = f(761), t = f(771), s = f(780), u = f(188), i = f(185), o = f(784), h = f(314), a = f(122).getCallback, l = f(122).getOptions, p = u.WriteError, g = u.ReadError, b = u.NotFoundError, I = u.OpenError, v = u.InitializationError; function R(k, x, M) { if (!(this instanceof R))
                    return new R(k, x, M); var N, S = this; if (r.call(this), this.setMaxListeners(1 / 0), typeof x == "function" && (M = x, x = {}), x = x || {}, !k || typeof k != "object") {
                    if (N = new v("First argument must be an abstract-leveldown compliant store"), typeof M == "function")
                        return d.nextTick(M, N);
                    throw N;
                } o.strictEqual(typeof k.status, "string", ".status required, old abstract-leveldown"), this.options = l(x), this._db = k, this.db = new n(k), this.open(M || function (T) { T && S.emit("error", T); }), this.supports = i(this.db.supports, { status: !1, deferredOpen: !0, openCallback: !0, promises: !0, streams: !0 }), Object.keys(this.supports.additionalMethods).forEach(function (T) { this[T] == null && (this[T] = function () { return this.db[T].apply(this.db, arguments); }); }, this); } function _(k, x) { if (!k._isOpening() && !k.isOpen())
                    return d.nextTick(x, new g("Database is not open")), !0; } R.prototype.emit = r.prototype.emit, R.prototype.once = r.prototype.once, e(R, r), R.prototype.open = function (k, x) { var M, N = this; return typeof k == "function" && (x = k, k = null), x || (M = (x = h()).promise), k || (k = this.options), this.isOpen() ? (d.nextTick(x, null, N), M) : this._isOpening() ? (this.once("open", function () { x(null, N); }), M) : (this.emit("opening"), this.db.open(k, function (S) { if (S)
                    return x(new I(S)); N.db = N._db, x(null, N), N.emit("open"), N.emit("ready"); }), M); }, R.prototype.close = function (k) { var x, M = this; return k || (x = (k = h()).promise), this.isOpen() ? (this.db.close(function () { M.emit("closed"), k.apply(null, arguments); }), this.emit("closing"), this.db = new n(this._db)) : this.isClosed() ? d.nextTick(k) : this.db.status === "closing" ? this.once("closed", k) : this._isOpening() && this.once("open", function () { M.close(k); }), x; }, R.prototype.isOpen = function () { return this.db.status === "open"; }, R.prototype._isOpening = function () { return this.db.status === "opening"; }, R.prototype.isClosed = function () { return /^clos|new/.test(this.db.status); }, R.prototype.get = function (k, x, M) { var N; return (M = a(x, M)) || (N = (M = h()).promise), _(this, M) || (x = l(x), this.db.get(k, x, function (S, T) { if (S)
                    return S = /notfound/i.test(S) || S.notFound ? new b("Key not found in database [" + k + "]", S) : new g(S), M(S); M(null, T); })), N; }, R.prototype.put = function (k, x, M, N) { var S, T = this; return (N = a(M, N)) || (S = (N = h()).promise), _(this, N) || (M = l(M), this.db.put(k, x, M, function (B) { if (B)
                    return N(new p(B)); T.emit("put", k, x), N(); })), S; }, R.prototype.del = function (k, x, M) { var N, S = this; return (M = a(x, M)) || (N = (M = h()).promise), _(this, M) || (x = l(x), this.db.del(k, x, function (T) { if (T)
                    return M(new p(T)); S.emit("del", k), M(); })), N; }, R.prototype.batch = function (k, x, M) { if (!arguments.length)
                    return new s(this); var N, S = this; return (M = typeof k == "function" ? k : a(x, M)) || (N = (M = h()).promise), _(this, M) || (x = l(x), this.db.batch(k, x, function (T) { if (T)
                    return M(new p(T)); S.emit("batch", k), M(); })), N; }, R.prototype.iterator = function (k) { return this.db.iterator(k); }, R.prototype.clear = function (k, x) { var M, N = this; return x = a(k, x), k = l(k), x || (M = (x = h()).promise), _(this, x) || this.db.clear(k, function (S) { if (S)
                    return x(new p(S)); N.emit("clear", k), x(); }), M; }, R.prototype.readStream = R.prototype.createReadStream = function (k) { return typeof (k = c({ keys: !0, values: !0 }, k)).limit != "number" && (k.limit = -1), new t(this.db.iterator(k), k); }, R.prototype.keyStream = R.prototype.createKeyStream = function (k) { return this.createReadStream(c(k, { keys: !0, values: !1 })); }, R.prototype.valueStream = R.prototype.createValueStream = function (k) { return this.createReadStream(c(k, { keys: !1, values: !0 })); }, R.prototype.toString = function () { return "LevelUP"; }, R.prototype.type = "levelup", R.errors = u, E.exports = R.default = R; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                var d = f(303).AbstractLevelDOWN, r = f(15), e = f(770), c = "put get del batch clear".split(" "), n = "approximateSize compactRange".split(" ");
                function t(u) { d.call(this, u.supports || {}), n.forEach(function (i) { typeof u[i] != "function" || this.supports.additionalMethods[i] || (this.supports.additionalMethods[i] = !0); }, this), this._db = u, this._operations = [], s(this); }
                function s(u) { c.forEach(function (i) { u["_" + i] = function () { this._operations.push({ method: i, args: arguments }); }; }), Object.keys(u.supports.additionalMethods).forEach(function (i) { u[i] = function () { this._operations.push({ method: i, args: arguments }); }; }), u._iterator = function (i) { var o = new e(u, i); return this._operations.push({ iterator: o }), o; }; }
                r(t, d), t.prototype.type = "deferred-leveldown", t.prototype._open = function (u, i) { var o = this; this._db.open(u, function (h) { if (h)
                    return i(h); o._operations.forEach(function (a) { a.iterator ? a.iterator.setDb(o._db) : o._db[a.method].apply(o._db, a.args); }), o._operations = [], function (a) { c.concat("iterator").forEach(function (l) { a["_" + l] = function () { return this._db[l].apply(this._db, arguments); }; }), Object.keys(a.supports.additionalMethods).forEach(function (l) { a[l] = function () { return this._db[l].apply(this._db, arguments); }; }); }(o), i(); }); }, t.prototype._close = function (u) { var i = this; this._db.close(function (o) { if (o)
                    return u(o); s(i), u(); }); }, t.prototype._serializeKey = function (u) { return u; }, t.prototype._serializeValue = function (u) { return u; }, E.exports = t, E.exports.DeferredIterator = e;
            }, function (E, m, f) {
                "use strict";
                var d = f(71), r = f(185), e = f(3).Buffer, c = f(304), n = f(306), t = f(186), s = Object.prototype.hasOwnProperty, u = "start end gt gte lt lte".split(" ");
                function i(a) { this.status = "new", this.supports = r(a, { status: !0 }); }
                function o(a, l) { var p = {}; for (var g in l)
                    if (s.call(l, g)) {
                        var b = l[g];
                        h(g) && (b = a._serializeKey(b)), p[g] = b;
                    } return p; }
                function h(a) { return u.indexOf(a) !== -1; }
                i.prototype.open = function (a, l) { var p = this, g = this.status; if (typeof a == "function" && (l = a), typeof l != "function")
                    throw new Error("open() requires a callback argument"); typeof a == "object" && a !== null || (a = {}), a.createIfMissing = a.createIfMissing !== !1, a.errorIfExists = !!a.errorIfExists, this.status = "opening", this._open(a, function (b) { if (b)
                    return p.status = g, l(b); p.status = "open", l(); }); }, i.prototype._open = function (a, l) { t(l); }, i.prototype.close = function (a) { var l = this, p = this.status; if (typeof a != "function")
                    throw new Error("close() requires a callback argument"); this.status = "closing", this._close(function (g) { if (g)
                    return l.status = p, a(g); l.status = "closed", a(); }); }, i.prototype._close = function (a) { t(a); }, i.prototype.get = function (a, l, p) { if (typeof l == "function" && (p = l), typeof p != "function")
                    throw new Error("get() requires a callback argument"); var g = this._checkKey(a); if (g)
                    return t(p, g); a = this._serializeKey(a), typeof l == "object" && l !== null || (l = {}), l.asBuffer = l.asBuffer !== !1, this._get(a, l, p); }, i.prototype._get = function (a, l, p) { t(function () { p(new Error("NotFound")); }); }, i.prototype.put = function (a, l, p, g) { if (typeof p == "function" && (g = p), typeof g != "function")
                    throw new Error("put() requires a callback argument"); var b = this._checkKey(a) || this._checkValue(l); if (b)
                    return t(g, b); a = this._serializeKey(a), l = this._serializeValue(l), typeof p == "object" && p !== null || (p = {}), this._put(a, l, p, g); }, i.prototype._put = function (a, l, p, g) { t(g); }, i.prototype.del = function (a, l, p) { if (typeof l == "function" && (p = l), typeof p != "function")
                    throw new Error("del() requires a callback argument"); var g = this._checkKey(a); if (g)
                    return t(p, g); a = this._serializeKey(a), typeof l == "object" && l !== null || (l = {}), this._del(a, l, p); }, i.prototype._del = function (a, l, p) { t(p); }, i.prototype.batch = function (a, l, p) { if (!arguments.length)
                    return this._chainedBatch(); if (typeof l == "function" && (p = l), typeof a == "function" && (p = a), typeof p != "function")
                    throw new Error("batch(array) requires a callback argument"); if (!Array.isArray(a))
                    return t(p, new Error("batch(array) requires an array argument")); if (a.length === 0)
                    return t(p); typeof l == "object" && l !== null || (l = {}); for (var g = new Array(a.length), b = 0; b < a.length; b++) {
                    if (typeof a[b] != "object" || a[b] === null)
                        return t(p, new Error("batch(array) element must be an object and not `null`"));
                    var I = d(a[b]);
                    if (I.type !== "put" && I.type !== "del")
                        return t(p, new Error("`type` must be 'put' or 'del'"));
                    var v = this._checkKey(I.key);
                    if (v)
                        return t(p, v);
                    if (I.key = this._serializeKey(I.key), I.type === "put") {
                        var R = this._checkValue(I.value);
                        if (R)
                            return t(p, R);
                        I.value = this._serializeValue(I.value);
                    }
                    g[b] = I;
                } this._batch(g, l, p); }, i.prototype._batch = function (a, l, p) { t(p); }, i.prototype.clear = function (a, l) { if (typeof a == "function")
                    l = a;
                else if (typeof l != "function")
                    throw new Error("clear() requires a callback argument"); (a = o(this, a)).reverse = !!a.reverse, a.limit = "limit" in a ? a.limit : -1, this._clear(a, l); }, i.prototype._clear = function (a, l) { a.keys = !0, a.values = !1, a.keyAsBuffer = !0, a.valueAsBuffer = !0; var p = this._iterator(a), g = {}, b = this, I = function (v) { if (v)
                    return p.end(function () { l(v); }); p.next(function (R, _) { return R ? I(R) : _ === void 0 ? p.end(l) : void b._del(_, g, I); }); }; I(); }, i.prototype._setupIteratorOptions = function (a) { return (a = o(this, a)).reverse = !!a.reverse, a.keys = a.keys !== !1, a.values = a.values !== !1, a.limit = "limit" in a ? a.limit : -1, a.keyAsBuffer = a.keyAsBuffer !== !1, a.valueAsBuffer = a.valueAsBuffer !== !1, a; }, i.prototype.iterator = function (a) { return typeof a == "object" && a !== null || (a = {}), a = this._setupIteratorOptions(a), this._iterator(a); }, i.prototype._iterator = function (a) { return new c(this); }, i.prototype._chainedBatch = function () { return new n(this); }, i.prototype._serializeKey = function (a) { return a; }, i.prototype._serializeValue = function (a) { return a; }, i.prototype._checkKey = function (a) { return a == null ? new Error("key cannot be `null` or `undefined`") : e.isBuffer(a) && a.length === 0 ? new Error("key cannot be an empty Buffer") : a === "" ? new Error("key cannot be an empty String") : Array.isArray(a) && a.length === 0 ? new Error("key cannot be an empty Array") : void 0; }, i.prototype._checkValue = function (a) { if (a == null)
                    return new Error("value cannot be `null` or `undefined`"); }, i.prototype._nextTick = t, E.exports = i;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (r) { for (var e = 1; e < arguments.length; e++) {
                    var c = arguments[e];
                    for (var n in c)
                        d.call(c, n) && (r[n] = c[n]);
                } return r; };
                var d = Object.prototype.hasOwnProperty;
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return typeof d.queueMicrotask == "function"; }, m.install = function (r) { return function () { d.queueMicrotask(r); }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = d.MutationObserver || d.WebKitMutationObserver; m.test = function () { return r; }, m.install = function (e) { var c = 0, n = new r(e), t = d.document.createTextNode(""); return n.observe(t, { characterData: !0 }), function () { t.data = c = ++c % 2; }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return !d.setImmediate && d.MessageChannel !== void 0; }, m.install = function (r) { var e = new d.MessageChannel; return e.port1.onmessage = r, function () { e.port2.postMessage(0); }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return "document" in d && "onreadystatechange" in d.document.createElement("script"); }, m.install = function (r) { return function () { var e = d.document.createElement("script"); return e.onreadystatechange = function () { r(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null; }, d.document.documentElement.appendChild(e), r; }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                m.test = function () { return !0; }, m.install = function (d) { return function () { setTimeout(d, 0); }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(303).AbstractIterator;
                function r(e, c) { d.call(this, e), this._options = c, this._iterator = null, this._operations = []; }
                f(15)(r, d), r.prototype.setDb = function (e) { var c = this._iterator = e.iterator(this._options); this._operations.forEach(function (n) { c[n.method].apply(c, n.args); }); }, r.prototype._operation = function (e, c) { if (this._iterator)
                    return this._iterator[e].apply(this._iterator, c); this._operations.push({ method: e, args: c }); }, "next end".split(" ").forEach(function (e) { r.prototype["_" + e] = function () { this._operation(e, arguments); }; }), r.prototype.seek = function () { this._operation("seek", arguments); }, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                var d = f(15), r = f(772).Readable, e = f(71);
                function c(n, t) { if (!(this instanceof c))
                    return new c(n, t); t = t || {}, r.call(this, e(t, { objectMode: !0 })), this._iterator = n, this._options = t, this.on("end", this.destroy.bind(this, null, null)); }
                E.exports = c, d(c, r), c.prototype._read = function () { var n = this, t = this._options; this.destroyed || this._iterator.next(function (s, u, i) { if (!n.destroyed)
                    return s ? n.destroy(s) : void (u === void 0 && i === void 0 ? n.push(null) : t.keys !== !1 && t.values === !1 ? n.push(u) : t.keys === !1 && t.values !== !1 ? n.push(i) : n.push({ key: u, value: i })); }); }, c.prototype._destroy = function (n, t) { this._iterator.end(function (s) { t(n || s); }); };
            }, function (E, m, f) {
                "use strict";
                (m = E.exports = f(307)).Stream = m, m.Readable = m, m.Writable = f(311), m.Duplex = f(73), m.Transform = f(313), m.PassThrough = f(778), m.finished = f(187), m.pipeline = f(779);
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                function d(s, u) { var i = Object.keys(s); if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(s);
                    u && (o = o.filter(function (h) { return Object.getOwnPropertyDescriptor(s, h).enumerable; })), i.push.apply(i, o);
                } return i; }
                function r(s, u, i) { return u in s ? Object.defineProperty(s, u, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : s[u] = i, s; }
                function e(s, u) { for (var i = 0; i < u.length; i++) {
                    var o = u[i];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(s, o.key, o);
                } }
                var c = f(3).Buffer, n = f(775).inspect, t = n && n.custom || "inspect";
                E.exports = function () { function s() { !function (h, a) { if (!(h instanceof a))
                    throw new TypeError("Cannot call a class as a function"); }(this, s), this.head = null, this.tail = null, this.length = 0; } var u, i, o; return u = s, (i = [{ key: "push", value: function (h) { var a = { data: h, next: null }; this.length > 0 ? this.tail.next = a : this.head = a, this.tail = a, ++this.length; } }, { key: "unshift", value: function (h) { var a = { data: h, next: this.head }; this.length === 0 && (this.tail = a), this.head = a, ++this.length; } }, { key: "shift", value: function () { if (this.length !== 0) {
                            var h = this.head.data;
                            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
                        } } }, { key: "clear", value: function () { this.head = this.tail = null, this.length = 0; } }, { key: "join", value: function (h) { if (this.length === 0)
                            return ""; for (var a = this.head, l = "" + a.data; a = a.next;)
                            l += h + a.data; return l; } }, { key: "concat", value: function (h) { if (this.length === 0)
                            return c.alloc(0); for (var a, l, p, g = c.allocUnsafe(h >>> 0), b = this.head, I = 0; b;)
                            a = b.data, l = g, p = I, c.prototype.copy.call(a, l, p), I += b.data.length, b = b.next; return g; } }, { key: "consume", value: function (h, a) { var l; return h < this.head.data.length ? (l = this.head.data.slice(0, h), this.head.data = this.head.data.slice(h)) : l = h === this.head.data.length ? this.shift() : a ? this._getString(h) : this._getBuffer(h), l; } }, { key: "first", value: function () { return this.head.data; } }, { key: "_getString", value: function (h) { var a = this.head, l = 1, p = a.data; for (h -= p.length; a = a.next;) {
                            var g = a.data, b = h > g.length ? g.length : h;
                            if (b === g.length ? p += g : p += g.slice(0, h), (h -= b) == 0) {
                                b === g.length ? (++l, a.next ? this.head = a.next : this.head = this.tail = null) : (this.head = a, a.data = g.slice(b));
                                break;
                            }
                            ++l;
                        } return this.length -= l, p; } }, { key: "_getBuffer", value: function (h) { var a = c.allocUnsafe(h), l = this.head, p = 1; for (l.data.copy(a), h -= l.data.length; l = l.next;) {
                            var g = l.data, b = h > g.length ? g.length : h;
                            if (g.copy(a, a.length - h, 0, b), (h -= b) == 0) {
                                b === g.length ? (++p, l.next ? this.head = l.next : this.head = this.tail = null) : (this.head = l, l.data = g.slice(b));
                                break;
                            }
                            ++p;
                        } return this.length -= p, a; } }, { key: t, value: function (h, a) { return n(this, function (l) { for (var p = 1; p < arguments.length; p++) {
                            var g = arguments[p] != null ? arguments[p] : {};
                            p % 2 ? d(Object(g), !0).forEach(function (b) { r(l, b, g[b]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(g)) : d(Object(g)).forEach(function (b) { Object.defineProperty(l, b, Object.getOwnPropertyDescriptor(g, b)); });
                        } return l; }({}, a, { depth: 0, customInspect: !1 })); } }]) && e(u.prototype, i), o && e(u, o), s; }();
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                (function (d) { var r; function e(I, v, R) { return v in I ? Object.defineProperty(I, v, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : I[v] = R, I; } var c = f(187), n = Symbol("lastResolve"), t = Symbol("lastReject"), s = Symbol("error"), u = Symbol("ended"), i = Symbol("lastPromise"), o = Symbol("handlePromise"), h = Symbol("stream"); function a(I, v) { return { value: I, done: v }; } function l(I) { var v = I[n]; if (v !== null) {
                    var R = I[h].read();
                    R !== null && (I[i] = null, I[n] = null, I[t] = null, v(a(R, !1)));
                } } function p(I) { d.nextTick(l, I); } var g = Object.getPrototypeOf(function () { }), b = Object.setPrototypeOf((e(r = { get stream() { return this[h]; }, next: function () { var I = this, v = this[s]; if (v !== null)
                        return Promise.reject(v); if (this[u])
                        return Promise.resolve(a(void 0, !0)); if (this[h].destroyed)
                        return new Promise(function (x, M) { d.nextTick(function () { I[s] ? M(I[s]) : x(a(void 0, !0)); }); }); var R, _ = this[i]; if (_)
                        R = new Promise(function (x, M) { return function (N, S) { x.then(function () { M[u] ? N(a(void 0, !0)) : M[o](N, S); }, S); }; }(_, this));
                    else {
                        var k = this[h].read();
                        if (k !== null)
                            return Promise.resolve(a(k, !1));
                        R = new Promise(this[o]);
                    } return this[i] = R, R; } }, Symbol.asyncIterator, function () { return this; }), e(r, "return", function () { var I = this; return new Promise(function (v, R) { I[h].destroy(null, function (_) { _ ? R(_) : v(a(void 0, !0)); }); }); }), r), g); E.exports = function (I) { var v, R = Object.create(b, (e(v = {}, h, { value: I, writable: !0 }), e(v, n, { value: null, writable: !0 }), e(v, t, { value: null, writable: !0 }), e(v, s, { value: null, writable: !0 }), e(v, u, { value: I._readableState.endEmitted, writable: !0 }), e(v, o, { value: function (_, k) { var x = R[h].read(); x ? (R[i] = null, R[n] = null, R[t] = null, _(a(x, !1))) : (R[n] = _, R[t] = k); }, writable: !0 }), v)); return R[i] = null, c(I, function (_) { if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                    var k = R[t];
                    return k !== null && (R[i] = null, R[n] = null, R[t] = null, k(_)), void (R[s] = _);
                } var x = R[n]; x !== null && (R[i] = null, R[n] = null, R[t] = null, x(a(void 0, !0))), R[u] = !0; }), I.on("readable", p.bind(null, R)), R; }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { throw new Error("Readable.from is not available in the browser"); };
            }, function (E, m, f) {
                "use strict";
                E.exports = r;
                var d = f(313);
                function r(e) { if (!(this instanceof r))
                    return new r(e); d.call(this, e); }
                f(15)(r, d), r.prototype._transform = function (e, c, n) { n(null, e); };
            }, function (E, m, f) {
                "use strict";
                var d, r = f(72).codes, e = r.ERR_MISSING_ARGS, c = r.ERR_STREAM_DESTROYED;
                function n(o) { if (o)
                    throw o; }
                function t(o, h, a, l) { l = function (b) { var I = !1; return function () { I || (I = !0, b.apply(void 0, arguments)); }; }(l); var p = !1; o.on("close", function () { p = !0; }), d === void 0 && (d = f(187)), d(o, { readable: h, writable: a }, function (b) { if (b)
                    return l(b); p = !0, l(); }); var g = !1; return function (b) { if (!p && !g)
                    return g = !0, function (I) { return I.setHeader && typeof I.abort == "function"; }(o) ? o.abort() : typeof o.destroy == "function" ? o.destroy() : void l(b || new c("pipe")); }; }
                function s(o) { o(); }
                function u(o, h) { return o.pipe(h); }
                function i(o) { return o.length ? typeof o[o.length - 1] != "function" ? n : o.pop() : n; }
                E.exports = function () { for (var o = arguments.length, h = new Array(o), a = 0; a < o; a++)
                    h[a] = arguments[a]; var l, p = i(h); if (Array.isArray(h[0]) && (h = h[0]), h.length < 2)
                    throw new e("streams"); var g = h.map(function (b, I) { var v = I < h.length - 1; return t(b, v, I > 0, function (R) { l || (l = R), R && g.forEach(s), v || (g.forEach(s), p(l)); }); }); return h.reduce(u); };
            }, function (E, m, f) {
                "use strict";
                var d = f(188).WriteError, r = f(314), e = f(122).getCallback, c = f(122).getOptions;
                function n(t) { this.db = this._levelup = t, this.batch = t.db.batch(), this.ops = [], this.length = 0; }
                n.prototype.put = function (t, s) { try {
                    this.batch.put(t, s);
                }
                catch (u) {
                    throw new d(u);
                } return this.ops.push({ type: "put", key: t, value: s }), this.length++, this; }, n.prototype.del = function (t) { try {
                    this.batch.del(t);
                }
                catch (s) {
                    throw new d(s);
                } return this.ops.push({ type: "del", key: t }), this.length++, this; }, n.prototype.clear = function () { try {
                    this.batch.clear();
                }
                catch (t) {
                    throw new d(t);
                } return this.ops = [], this.length = 0, this; }, n.prototype.write = function (t, s) { var u, i = this._levelup, o = this.ops; (s = e(t, s)) || (u = (s = r()).promise), t = c(t); try {
                    this.batch.write(t, function (h) { if (h)
                        return s(new d(h)); i.emit("batch", o), s(); });
                }
                catch (h) {
                    throw new d(h);
                } return u; }, E.exports = n;
            }, function (E, m, f) {
                "use strict";
                var d = E.exports.all = [{ errno: -2, code: "ENOENT", description: "no such file or directory" }, { errno: -1, code: "UNKNOWN", description: "unknown error" }, { errno: 0, code: "OK", description: "success" }, { errno: 1, code: "EOF", description: "end of file" }, { errno: 2, code: "EADDRINFO", description: "getaddrinfo error" }, { errno: 3, code: "EACCES", description: "permission denied" }, { errno: 4, code: "EAGAIN", description: "resource temporarily unavailable" }, { errno: 5, code: "EADDRINUSE", description: "address already in use" }, { errno: 6, code: "EADDRNOTAVAIL", description: "address not available" }, { errno: 7, code: "EAFNOSUPPORT", description: "address family not supported" }, { errno: 8, code: "EALREADY", description: "connection already in progress" }, { errno: 9, code: "EBADF", description: "bad file descriptor" }, { errno: 10, code: "EBUSY", description: "resource busy or locked" }, { errno: 11, code: "ECONNABORTED", description: "software caused connection abort" }, { errno: 12, code: "ECONNREFUSED", description: "connection refused" }, { errno: 13, code: "ECONNRESET", description: "connection reset by peer" }, { errno: 14, code: "EDESTADDRREQ", description: "destination address required" }, { errno: 15, code: "EFAULT", description: "bad address in system call argument" }, { errno: 16, code: "EHOSTUNREACH", description: "host is unreachable" }, { errno: 17, code: "EINTR", description: "interrupted system call" }, { errno: 18, code: "EINVAL", description: "invalid argument" }, { errno: 19, code: "EISCONN", description: "socket is already connected" }, { errno: 20, code: "EMFILE", description: "too many open files" }, { errno: 21, code: "EMSGSIZE", description: "message too long" }, { errno: 22, code: "ENETDOWN", description: "network is down" }, { errno: 23, code: "ENETUNREACH", description: "network is unreachable" }, { errno: 24, code: "ENFILE", description: "file table overflow" }, { errno: 25, code: "ENOBUFS", description: "no buffer space available" }, { errno: 26, code: "ENOMEM", description: "not enough memory" }, { errno: 27, code: "ENOTDIR", description: "not a directory" }, { errno: 28, code: "EISDIR", description: "illegal operation on a directory" }, { errno: 29, code: "ENONET", description: "machine is not on the network" }, { errno: 31, code: "ENOTCONN", description: "socket is not connected" }, { errno: 32, code: "ENOTSOCK", description: "socket operation on non-socket" }, { errno: 33, code: "ENOTSUP", description: "operation not supported on socket" }, { errno: 34, code: "ENOENT", description: "no such file or directory" }, { errno: 35, code: "ENOSYS", description: "function not implemented" }, { errno: 36, code: "EPIPE", description: "broken pipe" }, { errno: 37, code: "EPROTO", description: "protocol error" }, { errno: 38, code: "EPROTONOSUPPORT", description: "protocol not supported" }, { errno: 39, code: "EPROTOTYPE", description: "protocol wrong type for socket" }, { errno: 40, code: "ETIMEDOUT", description: "connection timed out" }, { errno: 41, code: "ECHARSET", description: "invalid Unicode character" }, { errno: 42, code: "EAIFAMNOSUPPORT", description: "address family for hostname not supported" }, { errno: 44, code: "EAISERVICE", description: "servname not supported for ai_socktype" }, { errno: 45, code: "EAISOCKTYPE", description: "ai_socktype not supported" }, { errno: 46, code: "ESHUTDOWN", description: "cannot send after transport endpoint shutdown" }, { errno: 47, code: "EEXIST", description: "file already exists" }, { errno: 48, code: "ESRCH", description: "no such process" }, { errno: 49, code: "ENAMETOOLONG", description: "name too long" }, { errno: 50, code: "EPERM", description: "operation not permitted" }, { errno: 51, code: "ELOOP", description: "too many symbolic links encountered" }, { errno: 52, code: "EXDEV", description: "cross-device link not permitted" }, { errno: 53, code: "ENOTEMPTY", description: "directory not empty" }, { errno: 54, code: "ENOSPC", description: "no space left on device" }, { errno: 55, code: "EIO", description: "i/o error" }, { errno: 56, code: "EROFS", description: "read-only file system" }, { errno: 57, code: "ENODEV", description: "no such device" }, { errno: 58, code: "ESPIPE", description: "invalid seek" }, { errno: 59, code: "ECANCELED", description: "operation canceled" }];
                E.exports.errno = {}, E.exports.code = {}, d.forEach(function (r) { E.exports.errno[r.errno] = r, E.exports.code[r.code] = r; }), E.exports.custom = f(782)(E.exports), E.exports.create = E.exports.custom.createError;
            }, function (E, m, f) {
                "use strict";
                var d = f(783);
                function r(c, n, t) { n && typeof n != "string" && (n = n.message || n.name), d(this, { type: c, name: c, cause: typeof n != "string" ? n : t, message: n }, "ewr"); }
                function e(c, n) { Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), r.call(this, "CustomError", c, n); }
                e.prototype = new Error, E.exports = function (c) { var n = function (t, s) { return function (u, i, o) { var h = function (a, l) { r.call(this, i, a, l), i == "FilesystemError" && (this.code = this.cause.code, this.path = this.cause.path, this.errno = this.cause.errno, this.message = (u.errno[this.cause.errno] ? u.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "")), Error.call(this), Error.captureStackTrace && Error.captureStackTrace(this, h); }; return h.prototype = o ? new o : new e, h; }(c, t, s); }; return { CustomError: e, FilesystemError: n("FilesystemError"), createError: n }; };
            }, function (E, m, f) {
                "use strict";
                var d;
                d = function () { var r = typeof Object.defineProperty == "function" ? function (e, c, n) { return Object.defineProperty(e, c, n), e; } : function (e, c, n) { return e[c] = n.value, e; }; return function (e, c, n, t) { var s; if (t = function (u, i) { var o = typeof i == "object", h = !o && typeof i == "string", a = function (l) { return o ? !!i[l] : !!h && i.indexOf(l[0]) > -1; }; return { enumerable: a("enumerable"), configurable: a("configurable"), writable: a("writable"), value: u }; }(n, t), typeof c == "object") {
                    for (s in c)
                        Object.hasOwnProperty.call(c, s) && (t.value = c[s], r(e, s, t));
                    return e;
                } return r(e, c, t); }; }, E.exports ? E.exports = d() : (void 0).prr = d();
            }, function (E, m, f) {
                "use strict";
                (function (d) {
                    var r = f(785);
                    function e(M, N) { if (M === N)
                        return 0; for (var S = M.length, T = N.length, B = 0, P = Math.min(S, T); B < P; ++B)
                        if (M[B] !== N[B]) {
                            S = M[B], T = N[B];
                            break;
                        } return S < T ? -1 : T < S ? 1 : 0; }
                    function c(M) { return d.Buffer && typeof d.Buffer.isBuffer == "function" ? d.Buffer.isBuffer(M) : !(M == null || !M._isBuffer); }
                    var n = f(786), t = Object.prototype.hasOwnProperty, s = Array.prototype.slice, u = function () { }.name === "foo";
                    function i(M) { return Object.prototype.toString.call(M); }
                    function o(M) { return !c(M) && typeof d.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(M) : !!M && (M instanceof DataView || !!(M.buffer && M.buffer instanceof ArrayBuffer))); }
                    var h = E.exports = I, a = /\s*function\s+([^\(\s]*)\s*/;
                    function l(M) { if (n.isFunction(M)) {
                        if (u)
                            return M.name;
                        var N = M.toString().match(a);
                        return N && N[1];
                    } }
                    function p(M, N) { return typeof M == "string" ? M.length < N ? M : M.slice(0, N) : M; }
                    function g(M) { if (u || !n.isFunction(M))
                        return n.inspect(M); var N = l(M); return "[Function" + (N ? ": " + N : "") + "]"; }
                    function b(M, N, S, T, B) { throw new h.AssertionError({ message: S, actual: M, expected: N, operator: T, stackStartFunction: B }); }
                    function I(M, N) { M || b(M, !0, N, "==", h.ok); }
                    function v(M, N, S, T) { if (M === N)
                        return !0; if (c(M) && c(N))
                        return e(M, N) === 0; if (n.isDate(M) && n.isDate(N))
                        return M.getTime() === N.getTime(); if (n.isRegExp(M) && n.isRegExp(N))
                        return M.source === N.source && M.global === N.global && M.multiline === N.multiline && M.lastIndex === N.lastIndex && M.ignoreCase === N.ignoreCase; if (M !== null && typeof M == "object" || N !== null && typeof N == "object") {
                        if (o(M) && o(N) && i(M) === i(N) && !(M instanceof Float32Array || M instanceof Float64Array))
                            return e(new Uint8Array(M.buffer), new Uint8Array(N.buffer)) === 0;
                        if (c(M) !== c(N))
                            return !1;
                        var B = (T = T || { actual: [], expected: [] }).actual.indexOf(M);
                        return B !== -1 && B === T.expected.indexOf(N) || (T.actual.push(M), T.expected.push(N), function (P, L, j, D) { if (P == null || L == null)
                            return !1; if (n.isPrimitive(P) || n.isPrimitive(L))
                            return P === L; if (j && Object.getPrototypeOf(P) !== Object.getPrototypeOf(L))
                            return !1; var G = R(P), W = R(L); if (G && !W || !G && W)
                            return !1; if (G)
                            return P = s.call(P), L = s.call(L), v(P, L, j); var X, Q, K = x(P), F = x(L); if (K.length !== F.length)
                            return !1; for (K.sort(), F.sort(), Q = K.length - 1; Q >= 0; Q--)
                            if (K[Q] !== F[Q])
                                return !1; for (Q = K.length - 1; Q >= 0; Q--)
                            if (X = K[Q], !v(P[X], L[X], j, D))
                                return !1; return !0; }(M, N, S, T));
                    } return S ? M === N : M == N; }
                    function R(M) { return Object.prototype.toString.call(M) == "[object Arguments]"; }
                    function _(M, N) { if (!M || !N)
                        return !1; if (Object.prototype.toString.call(N) == "[object RegExp]")
                        return N.test(M); try {
                        if (M instanceof N)
                            return !0;
                    }
                    catch (S) { } return !Error.isPrototypeOf(N) && N.call({}, M) === !0; }
                    function k(M, N, S, T) { var B; if (typeof N != "function")
                        throw new TypeError('"block" argument must be a function'); typeof S == "string" && (T = S, S = null), B = function (j) { var D; try {
                        j();
                    }
                    catch (G) {
                        D = G;
                    } return D; }(N), T = (S && S.name ? " (" + S.name + ")." : ".") + (T ? " " + T : "."), M && !B && b(B, S, "Missing expected exception" + T); var P = typeof T == "string", L = !M && B && !S; if ((!M && n.isError(B) && P && _(B, S) || L) && b(B, S, "Got unwanted exception" + T), M && B && S && !_(B, S) || !M && B)
                        throw B; }
                    h.AssertionError = function (M) {
                        this.name = "AssertionError", this.actual = M.actual, this.expected = M.expected, this.operator = M.operator, M.message ? (this.message = M.message, this.generatedMessage = !1) : (this.message = function (j) { return p(g(j.actual), 128) + " " + j.operator + " " + p(g(j.expected), 128); }(this), this.generatedMessage = !0);
                        var N = M.stackStartFunction || b;
                        if (Error.captureStackTrace)
                            Error.captureStackTrace(this, N);
                        else {
                            var S = new Error;
                            if (S.stack) {
                                var T = S.stack, B = l(N), P = T.indexOf(`
` + B);
                                if (P >= 0) {
                                    var L = T.indexOf(`
`, P + 1);
                                    T = T.substring(L + 1);
                                }
                                this.stack = T;
                            }
                        }
                    }, n.inherits(h.AssertionError, Error), h.fail = b, h.ok = I, h.equal = function (M, N, S) { M != N && b(M, N, S, "==", h.equal); }, h.notEqual = function (M, N, S) { M == N && b(M, N, S, "!=", h.notEqual); }, h.deepEqual = function (M, N, S) { v(M, N, !1) || b(M, N, S, "deepEqual", h.deepEqual); }, h.deepStrictEqual = function (M, N, S) { v(M, N, !0) || b(M, N, S, "deepStrictEqual", h.deepStrictEqual); }, h.notDeepEqual = function (M, N, S) { v(M, N, !1) && b(M, N, S, "notDeepEqual", h.notDeepEqual); }, h.notDeepStrictEqual = function M(N, S, T) { v(N, S, !0) && b(N, S, T, "notDeepStrictEqual", M); }, h.strictEqual = function (M, N, S) { M !== N && b(M, N, S, "===", h.strictEqual); }, h.notStrictEqual = function (M, N, S) { M === N && b(M, N, S, "!==", h.notStrictEqual); }, h.throws = function (M, N, S) { k(!0, M, N, S); }, h.doesNotThrow = function (M, N, S) { k(!1, M, N, S); }, h.ifError = function (M) { if (M)
                        throw M; }, h.strict = r(function M(N, S) { N || b(N, !0, S, "==", M); }, h, { equal: h.strictEqual, deepEqual: h.deepStrictEqual, notEqual: h.notStrictEqual, notDeepEqual: h.notDeepStrictEqual }), h.strict.strict = h.strict;
                    var x = Object.keys || function (M) { var N = []; for (var S in M)
                        t.call(M, S) && N.push(S); return N; };
                }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                var d = Object.getOwnPropertySymbols, r = Object.prototype.hasOwnProperty, e = Object.prototype.propertyIsEnumerable;
                function c(n) { if (n == null)
                    throw new TypeError("Object.assign cannot be called with null or undefined"); return Object(n); }
                E.exports = function () { try {
                    if (!Object.assign)
                        return !1;
                    var n = new String("abc");
                    if (n[5] = "de", Object.getOwnPropertyNames(n)[0] === "5")
                        return !1;
                    for (var t = {}, s = 0; s < 10; s++)
                        t["_" + String.fromCharCode(s)] = s;
                    if (Object.getOwnPropertyNames(t).map(function (i) { return t[i]; }).join("") !== "0123456789")
                        return !1;
                    var u = {};
                    return "abcdefghijklmnopqrst".split("").forEach(function (i) { u[i] = i; }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
                }
                catch (i) {
                    return !1;
                } }() ? Object.assign : function (n, t) { for (var s, u, i = c(n), o = 1; o < arguments.length; o++) {
                    for (var h in s = Object(arguments[o]))
                        r.call(s, h) && (i[h] = s[h]);
                    if (d) {
                        u = d(s);
                        for (var a = 0; a < u.length; a++)
                            e.call(s, u[a]) && (i[u[a]] = s[u[a]]);
                    }
                } return i; };
            }, function (E, m, f) {
                "use strict";
                (function (d, r) {
                    var e = /%[sdj%]/g;
                    m.format = function (P) { if (!b(P)) {
                        for (var L = [], j = 0; j < arguments.length; j++)
                            L.push(t(arguments[j]));
                        return L.join(" ");
                    } j = 1; for (var D = arguments, G = D.length, W = String(P).replace(e, function (Q) { if (Q === "%%")
                        return "%"; if (j >= G)
                        return Q; switch (Q) {
                        case "%s": return String(D[j++]);
                        case "%d": return Number(D[j++]);
                        case "%j": try {
                            return JSON.stringify(D[j++]);
                        }
                        catch (K) {
                            return "[Circular]";
                        }
                        default: return Q;
                    } }), X = D[j]; j < G; X = D[++j])
                        p(X) || !R(X) ? W += " " + X : W += " " + t(X); return W; }, m.deprecate = function (P, L) { if (I(d.process))
                        return function () { return m.deprecate(P, L).apply(this, arguments); }; if (r.noDeprecation === !0)
                        return P; var j = !1; return function () { if (!j) {
                        if (r.throwDeprecation)
                            throw new Error(L);
                        r.traceDeprecation ? console.trace(L) : console.error(L), j = !0;
                    } return P.apply(this, arguments); }; };
                    var c, n = {};
                    function t(P, L) { var j = { seen: [], stylize: u }; return arguments.length >= 3 && (j.depth = arguments[2]), arguments.length >= 4 && (j.colors = arguments[3]), l(L) ? j.showHidden = L : L && m._extend(j, L), I(j.showHidden) && (j.showHidden = !1), I(j.depth) && (j.depth = 2), I(j.colors) && (j.colors = !1), I(j.customInspect) && (j.customInspect = !0), j.colors && (j.stylize = s), i(j, P, j.depth); }
                    function s(P, L) { var j = t.styles[L]; return j ? "[" + t.colors[j][0] + "m" + P + "[" + t.colors[j][1] + "m" : P; }
                    function u(P, L) { return P; }
                    function i(P, L, j) {
                        if (P.customInspect && L && x(L.inspect) && L.inspect !== m.inspect && (!L.constructor || L.constructor.prototype !== L)) {
                            var D = L.inspect(j, P);
                            return b(D) || (D = i(P, D, j)), D;
                        }
                        var G = function (y, C) { if (I(C))
                            return y.stylize("undefined", "undefined"); if (b(C)) {
                            var A = "'" + JSON.stringify(C).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                            return y.stylize(A, "string");
                        } if (g(C))
                            return y.stylize("" + C, "number"); if (l(C))
                            return y.stylize("" + C, "boolean"); if (p(C))
                            return y.stylize("null", "null"); }(P, L);
                        if (G)
                            return G;
                        var W = Object.keys(L), X = function (y) { var C = {}; return y.forEach(function (A, U) { C[A] = !0; }), C; }(W);
                        if (P.showHidden && (W = Object.getOwnPropertyNames(L)), k(L) && (W.indexOf("message") >= 0 || W.indexOf("description") >= 0))
                            return o(L);
                        if (W.length === 0) {
                            if (x(L)) {
                                var Q = L.name ? ": " + L.name : "";
                                return P.stylize("[Function" + Q + "]", "special");
                            }
                            if (v(L))
                                return P.stylize(RegExp.prototype.toString.call(L), "regexp");
                            if (_(L))
                                return P.stylize(Date.prototype.toString.call(L), "date");
                            if (k(L))
                                return o(L);
                        }
                        var K, F = "", Y = !1, $ = ["{", "}"];
                        return (a(L) && (Y = !0, $ = ["[", "]"]), x(L)) && (F = " [Function" + (L.name ? ": " + L.name : "") + "]"), v(L) && (F = " " + RegExp.prototype.toString.call(L)), _(L) && (F = " " + Date.prototype.toUTCString.call(L)), k(L) && (F = " " + o(L)), W.length !== 0 || Y && L.length != 0 ? j < 0 ? v(L) ? P.stylize(RegExp.prototype.toString.call(L), "regexp") : P.stylize("[Object]", "special") : (P.seen.push(L), K = Y ? function (y, C, A, U, z) { for (var w = [], O = 0, q = C.length; O < q; ++O)
                            B(C, String(O)) ? w.push(h(y, C, A, U, String(O), !0)) : w.push(""); return z.forEach(function (H) { H.match(/^\d+$/) || w.push(h(y, C, A, U, H, !0)); }), w; }(P, L, j, X, W) : W.map(function (y) { return h(P, L, j, X, y, Y); }), P.seen.pop(), function (y, C, A) {
                            return y.reduce(function (U, z) {
                                return z.indexOf(`
`) >= 0, U + z.replace(/\u001b\[\d\d?m/g, "").length + 1;
                            }, 0) > 60 ? A[0] + (C === "" ? "" : C + `
 `) + " " + y.join(`,
  `) + " " + A[1] : A[0] + C + " " + y.join(", ") + " " + A[1];
                        }(K, F, $)) : $[0] + F + $[1];
                    }
                    function o(P) { return "[" + Error.prototype.toString.call(P) + "]"; }
                    function h(P, L, j, D, G, W) {
                        var X, Q, K;
                        if ((K = Object.getOwnPropertyDescriptor(L, G) || { value: L[G] }).get ? Q = K.set ? P.stylize("[Getter/Setter]", "special") : P.stylize("[Getter]", "special") : K.set && (Q = P.stylize("[Setter]", "special")), B(D, G) || (X = "[" + G + "]"), Q || (P.seen.indexOf(K.value) < 0 ? (Q = p(j) ? i(P, K.value, null) : i(P, K.value, j - 1)).indexOf(`
`) > -1 && (Q = W ? Q.split(`
`).map(function (F) { return "  " + F; }).join(`
`).substr(2) : `
` + Q.split(`
`).map(function (F) { return "   " + F; }).join(`
`)) : Q = P.stylize("[Circular]", "special")), I(X)) {
                            if (W && G.match(/^\d+$/))
                                return Q;
                            (X = JSON.stringify("" + G)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (X = X.substr(1, X.length - 2), X = P.stylize(X, "name")) : (X = X.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), X = P.stylize(X, "string"));
                        }
                        return X + ": " + Q;
                    }
                    function a(P) { return Array.isArray(P); }
                    function l(P) { return typeof P == "boolean"; }
                    function p(P) { return P === null; }
                    function g(P) { return typeof P == "number"; }
                    function b(P) { return typeof P == "string"; }
                    function I(P) { return P === void 0; }
                    function v(P) { return R(P) && M(P) === "[object RegExp]"; }
                    function R(P) { return typeof P == "object" && P !== null; }
                    function _(P) { return R(P) && M(P) === "[object Date]"; }
                    function k(P) { return R(P) && (M(P) === "[object Error]" || P instanceof Error); }
                    function x(P) { return typeof P == "function"; }
                    function M(P) { return Object.prototype.toString.call(P); }
                    function N(P) { return P < 10 ? "0" + P.toString(10) : P.toString(10); }
                    m.debuglog = function (P) { if (I(c) && (c = { NODE_ENV: "production" }.NODE_DEBUG || ""), P = P.toUpperCase(), !n[P])
                        if (new RegExp("\\b" + P + "\\b", "i").test(c)) {
                            var L = r.pid;
                            n[P] = function () { var j = m.format.apply(m, arguments); console.error("%s %d: %s", P, L, j); };
                        }
                        else
                            n[P] = function () { }; return n[P]; }, m.inspect = t, t.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, t.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, m.isArray = a, m.isBoolean = l, m.isNull = p, m.isNullOrUndefined = function (P) { return P == null; }, m.isNumber = g, m.isString = b, m.isSymbol = function (P) { return typeof P == "symbol"; }, m.isUndefined = I, m.isRegExp = v, m.isObject = R, m.isDate = _, m.isError = k, m.isFunction = x, m.isPrimitive = function (P) { return P === null || typeof P == "boolean" || typeof P == "number" || typeof P == "string" || typeof P == "symbol" || P === void 0; }, m.isBuffer = f(787);
                    var S = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
                    function T() { var P = new Date, L = [N(P.getHours()), N(P.getMinutes()), N(P.getSeconds())].join(":"); return [P.getDate(), S[P.getMonth()], L].join(" "); }
                    function B(P, L) { return Object.prototype.hasOwnProperty.call(P, L); }
                    m.log = function () { console.log("%s - %s", T(), m.format.apply(m, arguments)); }, m.inherits = f(788), m._extend = function (P, L) { if (!L || !R(L))
                        return P; for (var j = Object.keys(L), D = j.length; D--;)
                        P[j[D]] = L[j[D]]; return P; };
                }).call(this, f(10), f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { return d && typeof d == "object" && typeof d.copy == "function" && typeof d.fill == "function" && typeof d.readUInt8 == "function"; };
            }, function (E, m, f) {
                "use strict";
                typeof Object.create == "function" ? E.exports = function (d, r) { d.super_ = r, d.prototype = Object.create(r.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } }); } : E.exports = function (d, r) { d.super_ = r; var e = function () { }; e.prototype = r.prototype, d.prototype = new e, d.prototype.constructor = d; };
            }, function (E, m, f) {
                "use strict";
                var d = f(189).AbstractLevelDOWN, r = f(189).AbstractChainedBatch, e = f(189).AbstractIterator, c = f(15), n = f(791), t = f(188).EncodingError, s = ["approximateSize", "compactRange"];
                function u(h, a) { if (!(this instanceof u))
                    return new u(h, a); var l = h.supports || {}, p = l.additionalMethods || {}; d.call(this, l), this.supports.encodings = !0, this.supports.additionalMethods = {}, s.forEach(function (g) { var b = typeof h[g] == "function"; (p[g] || b) && (this.supports.additionalMethods[g] = !0, this[g] = function (I, v, R, _) { return I = this.codec.encodeKey(I, R), v = this.codec.encodeKey(v, R), this.db[g](I, v, R, _); }); }, this), (a = a || {}).keyEncoding === void 0 && (a.keyEncoding = "utf8"), a.valueEncoding === void 0 && (a.valueEncoding = "utf8"), this.db = h, this.codec = new n(a); }
                function i(h, a) { e.call(this, h), this.codec = h.codec, this.keys = a.keys, this.values = a.values, this.opts = this.codec.encodeLtgt(a), this.it = h.db.iterator(this.opts); }
                function o(h, a) { r.call(this, h), this.codec = h.codec, this.batch = h.db.batch(); }
                E.exports = u.default = u, c(u, d), u.prototype.type = "encoding-down", u.prototype._serializeKey = u.prototype._serializeValue = function (h) { return h; }, u.prototype._open = function (h, a) { this.db.open(h, a); }, u.prototype._close = function (h) { this.db.close(h); }, u.prototype._put = function (h, a, l, p) { h = this.codec.encodeKey(h, l), a = this.codec.encodeValue(a, l), this.db.put(h, a, l, p); }, u.prototype._get = function (h, a, l) { var p = this; h = this.codec.encodeKey(h, a), a.asBuffer = this.codec.valueAsBuffer(a), this.db.get(h, a, function (g, b) { if (g)
                    return l(g); try {
                    b = p.codec.decodeValue(b, a);
                }
                catch (I) {
                    return l(new t(I));
                } l(null, b); }); }, u.prototype._del = function (h, a, l) { h = this.codec.encodeKey(h, a), this.db.del(h, a, l); }, u.prototype._chainedBatch = function () { return new o(this); }, u.prototype._batch = function (h, a, l) { h = this.codec.encodeBatch(h, a), this.db.batch(h, a, l); }, u.prototype._iterator = function (h) { return h.keyAsBuffer = this.codec.keyAsBuffer(h), h.valueAsBuffer = this.codec.valueAsBuffer(h), new i(this, h); }, u.prototype._clear = function (h, a) { h = this.codec.encodeLtgt(h), this.db.clear(h, a); }, c(i, e), i.prototype._next = function (h) { var a = this; this.it.next(function (l, p, g) { if (l)
                    return h(l); try {
                    p = a.keys && p !== void 0 ? a.codec.decodeKey(p, a.opts) : void 0, g = a.values && g !== void 0 ? a.codec.decodeValue(g, a.opts) : void 0;
                }
                catch (b) {
                    return h(new t(b));
                } h(null, p, g); }); }, i.prototype._seek = function (h) { h = this.codec.encodeKey(h, this.opts), this.it.seek(h); }, i.prototype._end = function (h) { this.it.end(h); }, c(o, r), o.prototype._put = function (h, a) { h = this.codec.encodeKey(h), a = this.codec.encodeValue(a), this.batch.put(h, a); }, o.prototype._del = function (h) { h = this.codec.encodeKey(h), this.batch.del(h); }, o.prototype._clear = function () { this.batch.clear(); }, o.prototype._write = function (h, a) { this.batch.write(h, a); };
            }, function (E, m, f) {
                "use strict";
                var d = f(71), r = f(185), e = f(3).Buffer, c = f(315), n = f(316), t = f(190), s = Object.prototype.hasOwnProperty, u = "start end gt gte lt lte".split(" ");
                function i(a) { this.status = "new", this.supports = r(a, { status: !0 }); }
                function o(a, l) { var p = {}; for (var g in l)
                    if (s.call(l, g)) {
                        var b = l[g];
                        h(g) && (b = a._serializeKey(b)), p[g] = b;
                    } return p; }
                function h(a) { return u.indexOf(a) !== -1; }
                i.prototype.open = function (a, l) { var p = this, g = this.status; if (typeof a == "function" && (l = a), typeof l != "function")
                    throw new Error("open() requires a callback argument"); typeof a == "object" && a !== null || (a = {}), a.createIfMissing = a.createIfMissing !== !1, a.errorIfExists = !!a.errorIfExists, this.status = "opening", this._open(a, function (b) { if (b)
                    return p.status = g, l(b); p.status = "open", l(); }); }, i.prototype._open = function (a, l) { t(l); }, i.prototype.close = function (a) { var l = this, p = this.status; if (typeof a != "function")
                    throw new Error("close() requires a callback argument"); this.status = "closing", this._close(function (g) { if (g)
                    return l.status = p, a(g); l.status = "closed", a(); }); }, i.prototype._close = function (a) { t(a); }, i.prototype.get = function (a, l, p) { if (typeof l == "function" && (p = l), typeof p != "function")
                    throw new Error("get() requires a callback argument"); var g = this._checkKey(a); if (g)
                    return t(p, g); a = this._serializeKey(a), typeof l == "object" && l !== null || (l = {}), l.asBuffer = l.asBuffer !== !1, this._get(a, l, p); }, i.prototype._get = function (a, l, p) { t(function () { p(new Error("NotFound")); }); }, i.prototype.put = function (a, l, p, g) { if (typeof p == "function" && (g = p), typeof g != "function")
                    throw new Error("put() requires a callback argument"); var b = this._checkKey(a) || this._checkValue(l); if (b)
                    return t(g, b); a = this._serializeKey(a), l = this._serializeValue(l), typeof p == "object" && p !== null || (p = {}), this._put(a, l, p, g); }, i.prototype._put = function (a, l, p, g) { t(g); }, i.prototype.del = function (a, l, p) { if (typeof l == "function" && (p = l), typeof p != "function")
                    throw new Error("del() requires a callback argument"); var g = this._checkKey(a); if (g)
                    return t(p, g); a = this._serializeKey(a), typeof l == "object" && l !== null || (l = {}), this._del(a, l, p); }, i.prototype._del = function (a, l, p) { t(p); }, i.prototype.batch = function (a, l, p) { if (!arguments.length)
                    return this._chainedBatch(); if (typeof l == "function" && (p = l), typeof a == "function" && (p = a), typeof p != "function")
                    throw new Error("batch(array) requires a callback argument"); if (!Array.isArray(a))
                    return t(p, new Error("batch(array) requires an array argument")); if (a.length === 0)
                    return t(p); typeof l == "object" && l !== null || (l = {}); for (var g = new Array(a.length), b = 0; b < a.length; b++) {
                    if (typeof a[b] != "object" || a[b] === null)
                        return t(p, new Error("batch(array) element must be an object and not `null`"));
                    var I = d(a[b]);
                    if (I.type !== "put" && I.type !== "del")
                        return t(p, new Error("`type` must be 'put' or 'del'"));
                    var v = this._checkKey(I.key);
                    if (v)
                        return t(p, v);
                    if (I.key = this._serializeKey(I.key), I.type === "put") {
                        var R = this._checkValue(I.value);
                        if (R)
                            return t(p, R);
                        I.value = this._serializeValue(I.value);
                    }
                    g[b] = I;
                } this._batch(g, l, p); }, i.prototype._batch = function (a, l, p) { t(p); }, i.prototype.clear = function (a, l) { if (typeof a == "function")
                    l = a;
                else if (typeof l != "function")
                    throw new Error("clear() requires a callback argument"); (a = o(this, a)).reverse = !!a.reverse, a.limit = "limit" in a ? a.limit : -1, this._clear(a, l); }, i.prototype._clear = function (a, l) { a.keys = !0, a.values = !1, a.keyAsBuffer = !0, a.valueAsBuffer = !0; var p = this._iterator(a), g = {}, b = this, I = function (v) { if (v)
                    return p.end(function () { l(v); }); p.next(function (R, _) { return R ? I(R) : _ === void 0 ? p.end(l) : void b._del(_, g, I); }); }; I(); }, i.prototype._setupIteratorOptions = function (a) { return (a = o(this, a)).reverse = !!a.reverse, a.keys = a.keys !== !1, a.values = a.values !== !1, a.limit = "limit" in a ? a.limit : -1, a.keyAsBuffer = a.keyAsBuffer !== !1, a.valueAsBuffer = a.valueAsBuffer !== !1, a; }, i.prototype.iterator = function (a) { return typeof a == "object" && a !== null || (a = {}), a = this._setupIteratorOptions(a), this._iterator(a); }, i.prototype._iterator = function (a) { return new c(this); }, i.prototype._chainedBatch = function () { return new n(this); }, i.prototype._serializeKey = function (a) { return a; }, i.prototype._serializeValue = function (a) { return a; }, i.prototype._checkKey = function (a) { return a == null ? new Error("key cannot be `null` or `undefined`") : e.isBuffer(a) && a.length === 0 ? new Error("key cannot be an empty Buffer") : a === "" ? new Error("key cannot be an empty String") : Array.isArray(a) && a.length === 0 ? new Error("key cannot be an empty Array") : void 0; }, i.prototype._checkValue = function (a) { if (a == null)
                    return new Error("value cannot be `null` or `undefined`"); }, i.prototype._nextTick = t, E.exports = i;
            }, function (E, m, f) {
                "use strict";
                var d = f(792);
                function r(c) { if (!(this instanceof r))
                    return new r(c); this.opts = c || {}, this.encodings = d; }
                E.exports = r, r.prototype._encoding = function (c) { return typeof c == "string" && (c = d[c]), c || (c = d.id), c; }, r.prototype._keyEncoding = function (c, n) { return this._encoding(n && n.keyEncoding || c && c.keyEncoding || this.opts.keyEncoding); }, r.prototype._valueEncoding = function (c, n) { return this._encoding(n && (n.valueEncoding || n.encoding) || c && (c.valueEncoding || c.encoding) || this.opts.valueEncoding || this.opts.encoding); }, r.prototype.encodeKey = function (c, n, t) { return this._keyEncoding(n, t).encode(c); }, r.prototype.encodeValue = function (c, n, t) { return this._valueEncoding(n, t).encode(c); }, r.prototype.decodeKey = function (c, n) { return this._keyEncoding(n).decode(c); }, r.prototype.decodeValue = function (c, n) { return this._valueEncoding(n).decode(c); }, r.prototype.encodeBatch = function (c, n) { var t = this; return c.map(function (s) { var u = { type: s.type, key: t.encodeKey(s.key, n, s) }; return t.keyAsBuffer(n, s) && (u.keyEncoding = "binary"), s.prefix && (u.prefix = s.prefix), "value" in s && (u.value = t.encodeValue(s.value, n, s), t.valueAsBuffer(n, s) && (u.valueEncoding = "binary")), u; }); };
                var e = ["lt", "gt", "lte", "gte", "start", "end"];
                r.prototype.encodeLtgt = function (c) { var n = this, t = {}; return Object.keys(c).forEach(function (s) { t[s] = e.indexOf(s) > -1 ? n.encodeKey(c[s], c) : c[s]; }), t; }, r.prototype.createStreamDecoder = function (c) { var n = this; return c.keys && c.values ? function (t, s) { return { key: n.decodeKey(t, c), value: n.decodeValue(s, c) }; } : c.keys ? function (t) { return n.decodeKey(t, c); } : c.values ? function (t, s) { return n.decodeValue(s, c); } : function () { }; }, r.prototype.keyAsBuffer = function (c) { return this._keyEncoding(c).buffer; }, r.prototype.valueAsBuffer = function (c) { return this._valueEncoding(c).buffer; };
            }, function (E, m, f) {
                "use strict";
                var d = f(3).Buffer;
                m.utf8 = m["utf-8"] = { encode: function (c) { return e(c) ? c : String(c); }, decode: r, buffer: !1, type: "utf8" }, m.json = { encode: JSON.stringify, decode: JSON.parse, buffer: !1, type: "json" }, m.binary = { encode: function (c) { return e(c) ? c : d.from(c); }, decode: r, buffer: !0, type: "binary" }, m.none = { encode: r, decode: r, buffer: !1, type: "id" }, m.id = m.none;
                function r(c) { return c; }
                function e(c) { return c == null || d.isBuffer(c); }
                ["hex", "ascii", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le"].forEach(function (c) { m[c] = { encode: function (n) { return e(n) ? n : d.from(n, c); }, decode: function (n) { return n.toString(c); }, buffer: !0, type: c }; });
            }, function (E, m, f) {
                "use strict";
                (function (d) { E.exports = u; var r = f(317).AbstractLevelDOWN, e = f(15), c = f(795), n = f(320), t = f(321), s = f(805); function u(i, o) { if (!(this instanceof u))
                    return new u(i, o); if (r.call(this), o = o || {}, typeof i != "string")
                    throw new Error("constructor requires a location string argument"); this.location = i, this.prefix = o.prefix == null ? "level-js-" : o.prefix, this.version = parseInt(o.version || 1, 10); } e(u, r), u.binaryKeys = s.binaryKeys(indexedDB), u.arrayKeys = s.arrayKeys(indexedDB), u.prototype._open = function (i, o) { var h = indexedDB.open(this.prefix + this.location, this.version), a = this; h.onerror = function () { o(h.error || new Error("unknown error")); }, h.onsuccess = function () { a.db = h.result, o(); }, h.onupgradeneeded = function (l) { var p = l.target.result; p.objectStoreNames.contains(a.location) || p.createObjectStore(a.location); }; }, u.prototype.store = function (i) { return this.db.transaction([this.location], i).objectStore(this.location); }, u.prototype.await = function (i, o) { var h = i.transaction; h.onabort = function () { o(h.error || new Error("aborted by user")); }, h.oncomplete = function () { o(null, i.result); }; }, u.prototype._get = function (i, o, h) { var a = this.store("readonly"); try {
                    var l = a.get(i);
                }
                catch (p) {
                    return t(function () { h(p); });
                } this.await(l, function (p, g) { return p ? h(p) : g === void 0 ? h(new Error("NotFound")) : (o.asBuffer && (g = n(g)), void h(null, g)); }); }, u.prototype._del = function (i, o, h) { var a = this.store("readwrite"); try {
                    var l = a.delete(i);
                }
                catch (p) {
                    return t(function () { h(p); });
                } this.await(l, h); }, u.prototype._put = function (i, o, h, a) { var l = this.store("readwrite"); try {
                    var p = l.put(o, i);
                }
                catch (g) {
                    return t(function () { a(g); });
                } this.await(p, a); }, u.prototype._serializeKey = function (i) { return d.isBuffer(i) ? u.binaryKeys ? i : i.toString() : Array.isArray(i) ? u.arrayKeys ? i.map(this._serializeKey, this) : String(i) : i; }, u.prototype._serializeValue = function (i) { return i; }, u.prototype._iterator = function (i) { return new c(this, this.location, i); }, u.prototype._batch = function (i, o, h) { if (i.length === 0)
                    return t(h); var a, l = this.store("readwrite"), p = l.transaction, g = 0; p.onabort = function () { h(a || p.error || new Error("aborted by user")); }, p.oncomplete = function () { h(); }, function b() { var I = i[g++], v = I.key; try {
                    var R = I.type === "del" ? l.delete(v) : l.put(I.value, v);
                }
                catch (_) {
                    return a = _, void p.abort();
                } g < i.length && (R.onsuccess = b); }(); }, u.prototype._close = function (i) { this.db.close(), t(i); }, u.destroy = function (i, o, h) { typeof o == "function" && (h = o, o = "level-js-"); var a = indexedDB.deleteDatabase(o + i); a.onsuccess = function () { h(); }, a.onerror = function (l) { h(l); }; }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e = f(71), c = f(318), n = f(319), t = Object.prototype.hasOwnProperty, s = "start end gt gte lt lte".split(" "); function u() { this.status = "new"; } function i(o) { return s.indexOf(o) !== -1; } u.prototype.open = function (o, h) { var a = this, l = this.status; if (typeof o == "function" && (h = o), typeof h != "function")
                    throw new Error("open() requires a callback argument"); typeof o == "object" && o !== null || (o = {}), o.createIfMissing = o.createIfMissing !== !1, o.errorIfExists = !!o.errorIfExists, this.status = "opening", this._open(o, function (p) { if (p)
                    return a.status = l, h(p); a.status = "open", h(); }); }, u.prototype._open = function (o, h) { d.nextTick(h); }, u.prototype.close = function (o) { var h = this, a = this.status; if (typeof o != "function")
                    throw new Error("close() requires a callback argument"); this.status = "closing", this._close(function (l) { if (l)
                    return h.status = a, o(l); h.status = "closed", o(); }); }, u.prototype._close = function (o) { d.nextTick(o); }, u.prototype.get = function (o, h, a) { if (typeof h == "function" && (a = h), typeof a != "function")
                    throw new Error("get() requires a callback argument"); var l = this._checkKey(o); if (l)
                    return d.nextTick(a, l); o = this._serializeKey(o), typeof h == "object" && h !== null || (h = {}), h.asBuffer = h.asBuffer !== !1, this._get(o, h, a); }, u.prototype._get = function (o, h, a) { d.nextTick(function () { a(new Error("NotFound")); }); }, u.prototype.put = function (o, h, a, l) { if (typeof a == "function" && (l = a), typeof l != "function")
                    throw new Error("put() requires a callback argument"); var p = this._checkKey(o) || this._checkValue(h); if (p)
                    return d.nextTick(l, p); o = this._serializeKey(o), h = this._serializeValue(h), typeof a == "object" && a !== null || (a = {}), this._put(o, h, a, l); }, u.prototype._put = function (o, h, a, l) { d.nextTick(l); }, u.prototype.del = function (o, h, a) { if (typeof h == "function" && (a = h), typeof a != "function")
                    throw new Error("del() requires a callback argument"); var l = this._checkKey(o); if (l)
                    return d.nextTick(a, l); o = this._serializeKey(o), typeof h == "object" && h !== null || (h = {}), this._del(o, h, a); }, u.prototype._del = function (o, h, a) { d.nextTick(a); }, u.prototype.batch = function (o, h, a) { if (!arguments.length)
                    return this._chainedBatch(); if (typeof h == "function" && (a = h), typeof o == "function" && (a = o), typeof a != "function")
                    throw new Error("batch(array) requires a callback argument"); if (!Array.isArray(o))
                    return d.nextTick(a, new Error("batch(array) requires an array argument")); if (o.length === 0)
                    return d.nextTick(a); typeof h == "object" && h !== null || (h = {}); for (var l = new Array(o.length), p = 0; p < o.length; p++) {
                    if (typeof o[p] != "object" || o[p] === null)
                        return d.nextTick(a, new Error("batch(array) element must be an object and not `null`"));
                    var g = e(o[p]);
                    if (g.type !== "put" && g.type !== "del")
                        return d.nextTick(a, new Error("`type` must be 'put' or 'del'"));
                    var b = this._checkKey(g.key);
                    if (b)
                        return d.nextTick(a, b);
                    if (g.key = this._serializeKey(g.key), g.type === "put") {
                        var I = this._checkValue(g.value);
                        if (I)
                            return d.nextTick(a, I);
                        g.value = this._serializeValue(g.value);
                    }
                    l[p] = g;
                } this._batch(l, h, a); }, u.prototype._batch = function (o, h, a) { d.nextTick(a); }, u.prototype._setupIteratorOptions = function (o) { return (o = function (h, a) { var l = {}; for (var p in a)
                    if (t.call(a, p)) {
                        var g = a[p];
                        i(p) && (g = h._serializeKey(g)), l[p] = g;
                    } return l; }(this, o)).reverse = !!o.reverse, o.keys = o.keys !== !1, o.values = o.values !== !1, o.limit = "limit" in o ? o.limit : -1, o.keyAsBuffer = o.keyAsBuffer !== !1, o.valueAsBuffer = o.valueAsBuffer !== !1, o; }, u.prototype.iterator = function (o) { return typeof o == "object" && o !== null || (o = {}), o = this._setupIteratorOptions(o), this._iterator(o); }, u.prototype._iterator = function (o) { return new c(this); }, u.prototype._chainedBatch = function () { return new n(this); }, u.prototype._serializeKey = function (o) { return o; }, u.prototype._serializeValue = function (o) { return o; }, u.prototype._checkKey = function (o) { return o == null ? new Error("key cannot be `null` or `undefined`") : r.isBuffer(o) && o.length === 0 ? new Error("key cannot be an empty Buffer") : o === "" ? new Error("key cannot be an empty String") : Array.isArray(o) && o.length === 0 ? new Error("key cannot be an empty Array") : void 0; }, u.prototype._checkValue = function (o) { if (o == null)
                    return new Error("value cannot be `null` or `undefined`"); }, E.exports = u; }).call(this, f(9), f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d = f(15), r = f(317).AbstractIterator, e = f(796), c = f(320), n = f(321), t = function () { };
                function s(u, i, o) { if (r.call(this, u), this._limit = o.limit, this._count = 0, this._callback = null, this._cache = [], this._completed = !1, this._aborted = !1, this._error = null, this._transaction = null, this._keyAsBuffer = o.keyAsBuffer, this._valueAsBuffer = o.valueAsBuffer, this._limit !== 0) {
                    try {
                        var h = this.createKeyRange(o);
                    }
                    catch (a) {
                        return void (this._completed = !0);
                    }
                    this.createIterator(i, h, o.reverse);
                }
                else
                    this._completed = !0; }
                E.exports = s, d(s, r), s.prototype.createKeyRange = function (u) { var i = e.lowerBound(u), o = e.upperBound(u), h = e.lowerBoundExclusive(u), a = e.upperBoundExclusive(u); return i !== void 0 && o !== void 0 ? IDBKeyRange.bound(i, o, h, a) : i !== void 0 ? IDBKeyRange.lowerBound(i, h) : o !== void 0 ? IDBKeyRange.upperBound(o, a) : null; }, s.prototype.createIterator = function (u, i, o) { var h = this, a = this.db.db.transaction([u], "readonly"); a.objectStore(u).openCursor(i, o ? "prev" : "next").onsuccess = function (l) { var p = l.target.result; p && h.onItem(p); }, this._transaction = a, a.onabort = function () { h.onAbort(h._transaction.error || new Error("aborted by user")); }, a.oncomplete = function () { h.onComplete(); }; }, s.prototype.onItem = function (u) { this._cache.push(u.key, u.value), (this._limit <= 0 || ++this._count < this._limit) && u.continue(), this.maybeNext(); }, s.prototype.onAbort = function (u) { this._aborted = !0, this._error = u, this.maybeNext(); }, s.prototype.onComplete = function () { this._completed = !0, this.maybeNext(); }, s.prototype.maybeNext = function () { this._callback && (this._next(this._callback), this._callback = null); }, s.prototype._next = function (u) { if (this._aborted) {
                    var i = this._error;
                    this._error = null, n(function () { u(i); });
                }
                else if (this._cache.length > 0) {
                    var o = this._cache.shift(), h = this._cache.shift();
                    this._keyAsBuffer && (o = c(o)), this._valueAsBuffer && (h = c(h)), n(function () { u(null, o, h); });
                }
                else
                    this._completed ? n(u) : this._callback = u; }, s.prototype._end = function (u) { if (this._aborted || this._completed) {
                    var i = this._error;
                    n(function () { u(i); });
                }
                else
                    this.onItem = t, this.onAbort = u, this.onComplete = u; };
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r(p) { return p !== void 0 && p !== ""; } function e(p, g) { return Object.hasOwnProperty.call(p, g); } function c(p, g) { return Object.hasOwnProperty.call(p, g) && g; } m.compare = function (p, g) { if (d.isBuffer(p)) {
                    for (var b = Math.min(p.length, g.length), I = 0; I < b; I++) {
                        var v = p[I] - g[I];
                        if (v)
                            return v;
                    }
                    return p.length - g.length;
                } return p < g ? -1 : p > g ? 1 : 0; }; var n = m.lowerBoundKey = function (p) { return c(p, "gt") || c(p, "gte") || c(p, "min") || (p.reverse ? c(p, "end") : c(p, "start")) || void 0; }, t = m.lowerBound = function (p, g) { var b = n(p); return b ? p[b] : g; }, s = m.lowerBoundInclusive = function (p) { return !e(p, "gt"); }, u = m.upperBoundInclusive = function (p) { return !e(p, "lt"); }, i = m.lowerBoundExclusive = function (p) { return !s(p); }, o = m.upperBoundExclusive = function (p) { return !u(p); }, h = m.upperBoundKey = function (p) { return c(p, "lt") || c(p, "lte") || c(p, "max") || (p.reverse ? c(p, "start") : c(p, "end")) || void 0; }, a = m.upperBound = function (p, g) { var b = h(p); return b ? p[b] : g; }; function l(p) { return p; } m.start = function (p, g) { return p.reverse ? a(p, g) : t(p, g); }, m.end = function (p, g) { return p.reverse ? t(p, g) : a(p, g); }, m.startInclusive = function (p) { return p.reverse ? u(p) : s(p); }, m.endInclusive = function (p) { return p.reverse ? s(p) : u(p); }, m.toLtgt = function (p, g, b, I, v) { g = g || {}, b = b || l; var R = arguments.length > 3, _ = m.lowerBoundKey(p), k = m.upperBoundKey(p); return _ ? _ === "gt" ? g.gt = b(p.gt, !1) : g.gte = b(p[_], !1) : R && (g.gte = b(I, !1)), k ? k === "lt" ? g.lt = b(p.lt, !0) : g.lte = b(p[k], !0) : R && (g.lte = b(v, !0)), p.reverse != null && (g.reverse = !!p.reverse), e(g, "max") && delete g.max, e(g, "min") && delete g.min, e(g, "start") && delete g.start, e(g, "end") && delete g.end, g; }, m.contains = function (p, g, b) { b = b || m.compare; var I = t(p); if (r(I) && ((v = b(g, I)) < 0 || v === 0 && i(p)))
                    return !1; var v, R = a(p); return !(r(R) && ((v = b(g, R)) > 0 || v === 0 && o(p))); }, m.filter = function (p, g) { return function (b) { return m.contains(p, b, g); }; }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = f(798).strict; E.exports = function (e) { if (r(e)) {
                    var c = d.from(e.buffer);
                    return e.byteLength !== e.buffer.byteLength && (c = c.slice(e.byteOffset, e.byteOffset + e.byteLength)), c;
                } return d.from(e); }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = e, e.strict = c, e.loose = n;
                var d = Object.prototype.toString, r = { "[object Int8Array]": !0, "[object Int16Array]": !0, "[object Int32Array]": !0, "[object Uint8Array]": !0, "[object Uint8ClampedArray]": !0, "[object Uint16Array]": !0, "[object Uint32Array]": !0, "[object Float32Array]": !0, "[object Float64Array]": !0 };
                function e(t) { return c(t) || n(t); }
                function c(t) { return t instanceof Int8Array || t instanceof Int16Array || t instanceof Int32Array || t instanceof Uint8Array || t instanceof Uint8ClampedArray || t instanceof Uint16Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array; }
                function n(t) { return r[d.call(t)]; }
            }, function (E, m, f) {
                "use strict";
                var d, r, e, c = [f(800), f(801), f(802), f(803), f(804)], n = -1, t = [], s = !1;
                function u() { d && r && (d = !1, r.length ? t = r.concat(t) : n = -1, t.length && i()); }
                function i() { if (!d) {
                    s = !1, d = !0;
                    for (var l = t.length, p = setTimeout(u); l;) {
                        for (r = t, t = []; r && ++n < l;)
                            r[n].run();
                        n = -1, l = t.length;
                    }
                    r = null, n = -1, d = !1, clearTimeout(p);
                } }
                for (var o = -1, h = c.length; ++o < h;)
                    if (c[o] && c[o].test && c[o].test()) {
                        e = c[o].install(i);
                        break;
                    }
                function a(l, p) { this.fun = l, this.array = p; }
                a.prototype.run = function () { var l = this.fun, p = this.array; switch (p.length) {
                    case 0: return l();
                    case 1: return l(p[0]);
                    case 2: return l(p[0], p[1]);
                    case 3: return l(p[0], p[1], p[2]);
                    default: return l.apply(null, p);
                } }, E.exports = function (l) { var p = new Array(arguments.length - 1); if (arguments.length > 1)
                    for (var g = 1; g < arguments.length; g++)
                        p[g - 1] = arguments[g]; t.push(new a(l, p)), s || d || (s = !0, e()); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return d !== void 0 && !d.browser; }, m.install = function (r) { return function () { d.nextTick(r); }; }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = d.MutationObserver || d.WebKitMutationObserver; m.test = function () { return r; }, m.install = function (e) { var c = 0, n = new r(e), t = d.document.createTextNode(""); return n.observe(t, { characterData: !0 }), function () { t.data = c = ++c % 2; }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return !d.setImmediate && d.MessageChannel !== void 0; }, m.install = function (r) { var e = new d.MessageChannel; return e.port1.onmessage = r, function () { e.port2.postMessage(0); }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                (function (d) { m.test = function () { return "document" in d && "onreadystatechange" in d.document.createElement("script"); }, m.install = function (r) { return function () { var e = d.document.createElement("script"); return e.onreadystatechange = function () { r(), e.onreadystatechange = null, e.parentNode.removeChild(e), e = null; }, d.document.documentElement.appendChild(e), r; }; }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                m.test = function () { return !0; }, m.install = function (d) { return function () { setTimeout(d, 0); }; };
            }, function (E, m, f) {
                "use strict";
                m.test = function (d) { return function (r) { try {
                    return r.cmp(d, 0), !0;
                }
                catch (e) {
                    return !1;
                } }; }, m.binaryKeys = m.test(new Uint8Array(0)), m.arrayKeys = m.test([1]);
            }, function (E, m, f) {
                "use strict";
                E.exports = { Spec: { type: "mount", mounts: [{ mountpoint: "/blocks", type: "measure", prefix: "flatfs.datastore", child: { type: "flatfs", path: "blocks", sync: !0, shardFunc: "/repo/flatfs/shard/v1/next-to-last/2" } }, { mountpoint: "/", type: "measure", prefix: "leveldb.datastore", child: { type: "levelds", path: "datastore", compression: "none" } }] } };
            }, function (E, m, f) {
                "use strict";
                const d = f(808), r = f(297), e = f(280);
                E.exports = class {
                    constructor({ repo: c, network: n }) { this.repo = r({ repo: c }), this.bw = d({ network: n }), this.bitswap = e({ network: n }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(30).default, r = f(153).default, e = f(0), c = f(2);
                function n(t, s) { let u; if (u = s.peer ? t.metrics.forPeer(s.peer) : s.proto ? t.metrics.forProtocol(s.proto) : t.metrics.global, !u)
                    return { totalIn: new d(0), totalOut: new d(0), rateIn: new d(0), rateOut: new d(0) }; const { movingAverages: i, snapshot: o } = u; return { totalIn: o.dataReceived, totalOut: o.dataSent, rateIn: new d(i.dataReceived[6e4].movingAverage() / 60), rateOut: new d(i.dataSent[6e4].movingAverage() / 60) }; }
                E.exports = ({ network: t }) => c(async function* (s = {}) { const { libp2p: u } = await t.use(s); if (!s.poll)
                    return void (yield n(u, s)); const i = s.interval || 1e3; let o, h = -1; try {
                    if (h = typeof i == "string" ? r(i) || -1 : i, !h || h < 0)
                        throw new Error("invalid duration");
                }
                catch (a) {
                    throw e(a, "ERR_INVALID_POLL_INTERVAL");
                } try {
                    for (;;)
                        yield n(u, s), await new Promise(a => { o = setTimeout(a, h); });
                }
                finally {
                    clearTimeout(o);
                } });
            }, function (E, m, f) {
                "use strict";
                const { map: d } = f(55), r = f(0);
                E.exports = class {
                    constructor(e) { this._repo = e, this._bitswap = null; }
                    setExchange(e) { this._bitswap = e; }
                    unsetExchange() { this._bitswap = null; }
                    hasExchange() { return this._bitswap != null; }
                    put(e, c) { return this.hasExchange() ? this._bitswap.put(e, c) : this._repo.blocks.put(e, c); }
                    putMany(e, c) { return this.hasExchange() ? this._bitswap.putMany(e, c) : this._repo.blocks.putMany(e, c); }
                    get(e, c) { return this.hasExchange() ? this._bitswap.get(e, c) : this._repo.blocks.get(e, c); }
                    getMany(e, c) { if (!Array.isArray(e))
                        throw new Error("first arg must be an array of cids"); return this.hasExchange() ? this._bitswap.getMany(e, c) : d(n => this._repo.blocks.get(n, c))(e); }
                    async delete(e, c) { if (!await this._repo.blocks.has(e))
                        throw r(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND"); return this._repo.blocks.delete(e, c); }
                    deleteMany(e, c) { const n = this._repo; return this._repo.blocks.deleteMany(async function* () { for await (const t of e) {
                        if (!await n.blocks.has(t))
                            throw r(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND");
                        yield t;
                    } }(), c); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(811), r = f(812);
                E.exports = ({ blockService: e, print: c, options: n }) => new r(d(e, n, c));
            }, function (E, m, f) {
                "use strict";
                const d = f(24), r = f(18), e = { get [r.DAG_PB]() { return f(17); }, get [r.DAG_CBOR]() { return f(155); }, get [r.RAW]() { return f(323); } };
                E.exports = (c, n = {}, t) => d.call({ concatArrays: !0 }, { blockService: c, loadFormat: s => { if (t("Loading IPLD format", s), e[s])
                        return e[s]; throw new Error(`Missing IPLD format "${r.getName(s)}"`); } }, n);
            }, function (E, m, f) {
                "use strict";
                const d = f(93), r = f(4), e = f(24), c = f(155), n = f(17), t = f(323), s = f(18), u = f(813), { extendIterator: i } = f(814);
                class o {
                    constructor(a) { const l = e(o.defaultOptions, a); if (!l.blockService)
                        throw new Error("Missing blockservice"); this.bs = l.blockService, this.resolvers = {}, typeof l.loadFormat != "function" ? this.loadFormat = p => { const g = s.print[p]; throw new Error(`No resolver found for codec "${g}"`); } : this.loadFormat = l.loadFormat; for (const p of l.formats)
                        this.addFormat(p); }
                    addFormat(a) { const l = a.codec; if (this.resolvers[a.codec]) {
                        const p = s.print[l];
                        throw new Error(`Resolver already exists for codec "${p}"`);
                    } return this.resolvers[l] = a, this; }
                    removeFormat(a) { return this.resolvers[a] && delete this.resolvers[a], this; }
                    resolve(a, l, p) { if (!r.isCID(a))
                        throw new Error("`cid` argument must be a CID"); if (typeof l != "string")
                        throw new Error("`path` argument must be a string"); const g = async function* () { for (; a !== null;) {
                        const b = await this.getFormat(a.codec), I = await this.bs.get(a, p), v = b.resolver.resolve(I.data, l);
                        l = v.remainderPath;
                        let R = v.value;
                        if (Object.keys(R).length === 1 && "/" in R)
                            try {
                                R = new r(R["/"]);
                            }
                            catch (_) {
                                R = null;
                            }
                        a = r.isCID(R) ? R : null, yield { remainderPath: l, value: R };
                    } }.bind(this); return i(g()); }
                    async get(a, l) { const p = await this.bs.get(a, l); return (await this.getFormat(p.cid.codec)).util.deserialize(p.data); }
                    getMany(a, l) { if (!u.isIterable(a) || typeof a == "string" || a instanceof Uint8Array)
                        throw new Error("`cids` must be an iterable of CIDs"); const p = async function* () { for await (const g of a)
                        yield this.get(g, l); }.bind(this); return i(p()); }
                    async put(a, l, p) { if (l === void 0)
                        throw new Error("`put` requires a format"); if (typeof l != "number")
                        throw new Error("`format` parameter must be number (multicodec)"); const g = await this.getFormat(l), b = { hashAlg: g.defaultHashAlg, cidVersion: 1, onlyHash: !1 }, I = e(b, p), v = { cidVersion: I.cidVersion, hashAlg: I.hashAlg, onlyHash: I.onlyHash }, R = g.util.serialize(a), _ = await g.util.cid(R, v); if (!I.onlyHash) {
                        const k = new d(R, _);
                        await this.bs.put(k, I);
                    } return _; }
                    putMany(a, l, p) { if (!u.isIterable(a) || typeof a == "string" || a instanceof Uint8Array)
                        throw new Error("`nodes` must be an iterable"); if (l === void 0)
                        throw new Error("`put` requires a format"); if (typeof l != "number")
                        throw new Error("`format` parameter must be number (multicodec)"); let g, b; const I = async function* () { for await (const v of a) {
                        if (g === void 0) {
                            b = await this.getFormat(l);
                            const R = { hashAlg: b.defaultHashAlg, cidVersion: 1, onlyHash: !1 };
                            g = e(R, p);
                        }
                        yield this.put(v, l, g);
                    } }.bind(this); return i(I()); }
                    async remove(a, l) { return this.bs.delete(a, l); }
                    removeMany(a, l) { if (!u.isIterable(a) || typeof a == "string" || a instanceof Uint8Array)
                        throw new Error("`cids` must be an iterable of CIDs"); const p = async function* () { for await (const g of a)
                        yield this.remove(g, l); }.bind(this); return i(p()); }
                    tree(a, l, p) { typeof l == "object" && (p = l, l = void 0), l = l || ""; const g = e({ recursive: !1 }, p), b = async (v, R) => { const _ = (await this.getFormat(v.cid.codec)).resolver.resolve(v.data, R); return r.isCID(_.value) ? _.value : null; }, I = async function* () { const v = []; let R; const _ = [{ cid: a, basePath: "" }]; let k; for (; v.length > 0 || _.length > 0;) {
                        if (v.length === 0 && _.length > 0) {
                            ({ cid: a, basePath: k } = _.shift());
                            const N = await this.getFormat(a.codec);
                            R = await this.bs.get(a, g);
                            const S = N.resolver.tree(R.data);
                            v.push(...S);
                        }
                        const x = v.shift();
                        let M = k + x;
                        g.recursive && (a = await b(R, x)) !== null && _.push({ cid: a, basePath: M + "/" }), M.startsWith(l) && M.length > l.length && (l.length > 0 && (M = M.slice(l.length + 1)), yield M);
                    } }.bind(this); return i(I()); }
                    async getFormat(a) { if (typeof a == "string") {
                        const p = a.toUpperCase().replace(/-/g, "_");
                        a = s[p];
                    } if (this.resolvers[a])
                        return this.resolvers[a]; const l = await this.loadFormat(a); return this.addFormat(l), l; }
                }
                o.defaultOptions = { formats: [c, n, t] }, E.exports = o;
            }, function (E, m, f) {
                "use strict";
                function d(g) { return !isNaN(parseFloat(g)) && isFinite(g); }
                function r(g) { return g !== null && typeof g == "object" && g.constructor === Object; }
                function e(g) { return c(g) && typeof g.length == "number"; }
                function c(g) { return typeof g == "object" && g !== null; }
                function n(g) { return g !== void 0; }
                function t(g) { return !n(g); }
                function s(g) { return g === null; }
                function u(g) { return n(g) && !s(g) && !Number.isNaN(g); }
                function i(g) { return typeof g == "function" && /^class /.test(Function.prototype.toString.call(g)); }
                function o(g) { if (g === null)
                    return !0; switch (typeof g) {
                    case "string":
                    case "number":
                    case "symbol":
                    case "undefined":
                    case "boolean": return !0;
                    default: return !1;
                } }
                function h(g) { if (g) {
                    const b = n(Promise) && g instanceof Promise, I = g.then && typeof g.then == "function";
                    return !(!b && !I);
                } return !1; }
                function a(g) { return !(g === null || !n(g)) && (typeof g[Symbol.iterator] == "function" || typeof g[Symbol.asyncIterator] == "function"); }
                function l(g) { return typeof g == "string"; }
                function p(g) { return typeof g == "function"; }
                f.r(m), f.d(m, "isNumber", function () { return d; }), f.d(m, "isPlainObject", function () { return r; }), f.d(m, "isArrayLike", function () { return e; }), f.d(m, "isObject", function () { return c; }), f.d(m, "isDefined", function () { return n; }), f.d(m, "isUndefined", function () { return t; }), f.d(m, "isNull", function () { return s; }), f.d(m, "isDefinedValue", function () { return u; }), f.d(m, "isClass", function () { return i; }), f.d(m, "isPrimitive", function () { return o; }), f.d(m, "isPromise", function () { return h; }), f.d(m, "isIterable", function () { return a; }), f.d(m, "isString", function () { return l; }), f.d(m, "isFunction", function () { return p; }), m.default = { isNumber: d, isPlainObject: r, isArrayLike: e, isObject: c, isDefined: n, isUndefined: t, isNull: s, isDefinedValue: u, isClass: i, isPrimitive: o, isPromise: h, isIterable: a, isString: l, isFunction: p };
            }, function (E, m, f) {
                "use strict";
                m.first = async (d) => { for await (const r of d)
                    return r; }, m.last = async (d) => { let r; for await (r of d)
                    ; return r; }, m.all = async (d) => { const r = []; for await (const e of d)
                    r.push(e); return r; }, m.extendIterator = d => (d.first = () => m.first(d), d.last = () => m.last(d), d.all = () => m.all(d), d);
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("ipfs:components:peer:storage"), r = f(816), e = f(166), { ERR_REPO_NOT_INITIALIZED: c } = f(182).errors, n = f(6), t = f(5), s = f(7), { mergeOptions: u } = f(23), i = f(288), { NotEnabledError: o } = f(111), h = f(324);
                class a {
                    constructor(M, N, S, T, B) { this.print = T, this.peerId = M, this.keychain = N, this.repo = S, this.print = T, this.isNew = B; }
                    static async start(M) { const { repoAutoMigrate: N, repo: S, print: T, silent: B } = M, P = typeof S == "string" || S == null ? r({ path: S, autoMigrate: N, silent: B }) : S, { peerId: L, keychain: j, isNew: D } = await l(P, M); return new a(L, j, P, T, D); }
                }
                E.exports = a;
                const l = async (x, M) => { const N = await p(x); if (N == null)
                    return { ...await R(x, M), isNew: !1 }; if (N.code === c) {
                    if (M.allowNew === !1)
                        throw new o("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
                    return { ...await g(x, M), isNew: !0 };
                } throw N; }, p = async (x) => { if (!x.closed)
                    return null; try {
                    return await x.open(), null;
                }
                catch (M) {
                    return M;
                } }, g = async (x, M) => { const N = await x.exists(); if (d("repo exists?", N), N === !0)
                    throw new Error("repo already exists"); const S = M.privateKey ? await b(M.privateKey) : await I(M), T = v(S); d("peer identity: %s", T.PeerID); const B = { ...u(k(e(), M.profiles), M.config), Identity: T }; await x.init(B), await x.open(), d("repo opened"); const P = h({ options: void 0, multiaddrs: void 0, peerId: S, repo: x, config: B, keychainConfig: { pass: M.pass } }); return P.keychain && P.keychain.opts && (await P.loadKeychain(), await x.config.set("Keychain", { dek: P.keychain.opts.dek })), { peerId: S, keychain: P.keychain }; }, b = x => (d("using user-supplied private-key"), typeof x == "object" ? x : s.createFromPrivKey(n(x, "base64pad"))), I = ({ print: x, algorithm: M = "RSA", bits: N = 2048 }) => (x("generating %s-bit (rsa only) %s keypair...", N, M), s.create({ keyType: M, bits: N })), v = x => ({ PeerID: x.toB58String(), PrivKey: t(x.privKey.bytes, "base64pad") }), R = async (x, { config: M, profiles: N, pass: S }) => { const T = await x.config.getAll(), B = _(k(T, N), M); T !== B && await x.config.replace(B); const P = await s.createFromPrivKey(B.Identity.PrivKey), L = h({ options: void 0, multiaddrs: void 0, peerId: P, repo: x, config: B, keychainConfig: { pass: S, ...B.Keychain } }); return L.keychain && await L.loadKeychain(), { peerId: P, keychain: L.keychain }; }, _ = (x, M) => M ? u(x, M) : x, k = (x, M) => (M || []).reduce((N, S) => { const T = i.profiles[S]; if (!T)
                    throw new Error(`Could not find profile with name '${S}'`); return d("applying profile %s", S), T.transform(N); }, x);
            }, function (E, m, f) {
                "use strict";
                const d = f(182);
                E.exports = (r = {}) => { const e = r.path || "ipfs"; return new d(e, { autoMigrate: r.autoMigrate }); };
            }, function (E, m, f) {
                "use strict";
                E.exports = { gossipsub: f(325) };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(12), e = f(0), c = f(27), n = f(819), { codes: t } = f(191), s = f(326), u = f(823), i = f(829), { signMessage: o, verifySignature: h } = f(830);
                E.exports = class extends r {
                    constructor({ debugName: a, multicodecs: l, libp2p: p, signMessages: g = !0, strictSigning: b = !0, canRelayMessage: I = !1, emitSelf: v = !1 }) { if (typeof a != "string")
                        throw new Error("a debugname `string` is required"); if (!l)
                        throw new Error("multicodecs are required"); if (!p)
                        throw new Error("libp2p is required"); super(), this.log = d(a), this.log.err = d(a + ":error"), this.multicodecs = i.ensureArray(l), this._libp2p = p, this.registrar = p.registrar, this.peerId = p.peerId, this.started = !1, this.topics = new Map, this.subscriptions = new Set, this.peers = new Map, this.signMessages = g, this.strictSigning = b, this.canRelayMessage = I, this.emitSelf = v, this.topicValidators = new Map, this._registrarId = void 0, this._onIncomingStream = this._onIncomingStream.bind(this), this._onPeerConnected = this._onPeerConnected.bind(this), this._onPeerDisconnected = this._onPeerDisconnected.bind(this); }
                    start() { if (this.started)
                        return; this.log("starting"), this.registrar.handle(this.multicodecs, this._onIncomingStream); const a = new n({ multicodecs: this.multicodecs, handlers: { onConnect: this._onPeerConnected, onDisconnect: this._onPeerDisconnected } }); this._registrarId = this.registrar.register(a), this.log("started"), this.started = !0; }
                    stop() { this.started && (this.registrar.unregister(this._registrarId), this.log("stopping"), this.peers.forEach(a => a.close()), this.peers = new Map, this.subscriptions = new Set, this.started = !1, this.log("stopped")); }
                    _onIncomingStream({ protocol: a, stream: l, connection: p }) { const g = p.remotePeer, b = g.toB58String(), I = this._addPeer(g, a); I.attachInboundStream(l), this._processMessages(b, I.inboundStream, I); }
                    async _onPeerConnected(a, l) { const p = a.toB58String(); this.log("connected", p); try {
                        const { stream: g, protocol: b } = await l.newStream(this.multicodecs), I = this._addPeer(a, b);
                        await I.attachOutboundStream(g);
                    }
                    catch (g) {
                        this.log.err(g);
                    } this._sendSubscriptions(p, Array.from(this.subscriptions), !0); }
                    _onPeerDisconnected(a, l) { const p = a.toB58String(); this.log("connection ended", p, l ? l.message : ""), this._removePeer(a); }
                    _addPeer(a, l) { const p = a.toB58String(), g = this.peers.get(p); if (g)
                        return g; this.log("new peer", p); const b = new u({ id: a, protocol: l }); return this.peers.set(p, b), b.once("close", () => this._removePeer(a)), b; }
                    _removePeer(a) { if (!a)
                        return; const l = a.toB58String(), p = this.peers.get(l); if (p) {
                        p.removeAllListeners(), p.close(), this.log("delete peer", l), this.peers.delete(l);
                        for (const g of this.topics.values())
                            g.delete(l);
                        return p;
                    } }
                    async _processMessages(a, l, p) { try {
                        await c(l, async (g) => { for await (const b of g) {
                            const I = b instanceof Uint8Array ? b : b.slice(), v = this._decodeRpc(I);
                            this._processRpc(a, p, v);
                        } });
                    }
                    catch (g) {
                        this._onPeerDisconnected(p.id, g);
                    } }
                    _processRpc(a, l, p) { this.log("rpc from", a); const g = p.subscriptions, b = p.msgs; return g.length && (g.forEach(I => this._processRpcSubOpt(a, I)), this.emit("pubsub:subscription-change", l.id, g)), this._acceptFrom(a) ? (b.length && b.forEach(I => { if (!this.canRelayMessage && !I.topicIDs.some(R => this.subscriptions.has(R)))
                        return void this.log("received message we didn't subscribe to. Dropping."); const v = i.normalizeInRpcMessage(I, a); this._processRpcMessage(v); }), !0) : (this.log("received message from unacceptable peer %s", a), !1); }
                    _processRpcSubOpt(a, l) { const p = l.topicID; let g = this.topics.get(p); g || (g = new Set, this.topics.set(p, g)), l.subscribe ? g.add(a) : g.delete(a); }
                    async _processRpcMessage(a) { if (this.peerId.toB58String() !== a.from || this.emitSelf) {
                        try {
                            await this.validate(a);
                        }
                        catch (l) {
                            return void this.log("Message is invalid, dropping it. %O", l);
                        }
                        this._emitMessage(a), this._publish(i.normalizeOutRpcMessage(a));
                    } }
                    _emitMessage(a) { a.topicIDs.forEach(l => { this.subscriptions.has(l) && this.emit(l, a); }); }
                    getMsgId(a) { return i.msgId(a.from, a.seqno); }
                    _acceptFrom(a) { return !0; }
                    _decodeRpc(a) { return s.rpc.RPC.decode(a); }
                    _encodeRpc(a) { return s.rpc.RPC.encode(a); }
                    _sendRpc(a, l) { const p = this.peers.get(a); if (p && p.isWritable)
                        p.write(this._encodeRpc(l));
                    else {
                        const g = `Cannot send RPC to ${a} as there is no open stream to it available`;
                        this.log.err(g);
                    } }
                    _sendSubscriptions(a, l, p) { return this._sendRpc(a, { subscriptions: l.map(g => ({ topicID: g, subscribe: p })) }); }
                    async validate(a) { if (this.strictSigning && !a.signature)
                        throw e(new Error("Signing required and no signature was present"), t.ERR_MISSING_SIGNATURE); if (a.signature && !await h(a))
                        throw e(new Error("Invalid message signature"), t.ERR_INVALID_SIGNATURE); for (const l of a.topicIDs) {
                        const p = this.topicValidators.get(l);
                        p && await p(l, a);
                    } }
                    _buildMessage(a) { const l = i.normalizeOutRpcMessage(a); return this.signMessages ? o(this.peerId, l) : a; }
                    getSubscribers(a) { if (!this.started)
                        throw e(new Error("not started yet"), "ERR_NOT_STARTED_YET"); if (!a || typeof a != "string")
                        throw e(new Error("a string topic must be provided"), "ERR_NOT_VALID_TOPIC"); const l = this.topics.get(a); return l ? Array.from(l) : []; }
                    async publish(a, l) { if (!this.started)
                        throw new Error("Pubsub has not started"); this.log("publish", a, l); const p = this.peerId.toB58String(); let g = { receivedFrom: p, from: p, data: l, seqno: i.randomSeqno(), topicIDs: [a] }; const b = await this._buildMessage(g); g = i.normalizeInRpcMessage(b), this.emitSelf && this._emitMessage(g), await this._publish(g); }
                    _publish(a) { throw e(new Error("publish must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED"); }
                    subscribe(a) { if (!this.started)
                        throw new Error("Pubsub has not started"); this.subscriptions.has(a) || (this.subscriptions.add(a), this.peers.forEach((l, p) => this._sendSubscriptions(p, [a], !0))); }
                    unsubscribe(a) { if (!this.started)
                        throw new Error("Pubsub is not started"); this.subscriptions.has(a) && this.listenerCount(a) === 0 && (this.subscriptions.delete(a), this.peers.forEach((l, p) => this._sendSubscriptions(p, [a], !1))); }
                    getTopics() { if (!this.started)
                        throw new Error("Pubsub is not started"); return Array.from(this.subscriptions); }
                }, E.exports.message = s, E.exports.utils = i;
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = f(820);
                E.exports = d(class extends r {
                    constructor({ min: e, max: c, multicodecs: n, handlers: t }) { if (super({ min: e, max: c, handlers: t }), !n)
                        throw new Error("one or more multicodec should be provided"); if (!t)
                        throw new Error("the handlers should be provided"); if (typeof t.onConnect != "function")
                        throw new Error("the 'onConnect' handler must be provided"); if (typeof t.onDisconnect != "function")
                        throw new Error("the 'onDisconnect' handler must be provided"); this.multicodecs = Array.isArray(n) ? n : [n], this._registrar = void 0, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerConnect = this._onPeerConnect.bind(this); }
                    set registrar(e) { this._registrar = e, this._registrar.peerStore.on("change:protocols", this._onProtocolChange), this._registrar.connectionManager.on("peer:connect", this._onPeerConnect), this._updatePeers(this._registrar.peerStore.peers.values()); }
                    _updatePeers(e) { for (const { id: c, protocols: n } of e)
                        if (this.multicodecs.filter(t => n.includes(t)).length) {
                            this.peers.add(c.toB58String());
                            const t = this._registrar.getConnection(c);
                            t && this._onConnect(c, t);
                        }
                        else
                            this.peers.delete(c.toB58String()); }
                    _onProtocolChange({ peerId: e, protocols: c }) { const n = this.peers.has(e.toB58String()), t = c.filter(s => this.multicodecs.includes(s)); n && t.length === 0 && this._onDisconnect(e); for (const s of c)
                        if (this.multicodecs.includes(s)) {
                            const u = this._registrar.peerStore.get(e);
                            return void this._updatePeers([u]);
                        } }
                    _onPeerConnect(e) { const c = e.remotePeer, n = this._registrar.peerStore.protoBook.get(c); n && this.multicodecs.find(t => n.includes(t)) && (this.peers.add(c.toB58String()), this._onConnect(c, e)); }
                }, { className: "MulticodecTopology", symbolName: "@libp2p/js-interfaces/topology/multicodec-topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = () => { };
                E.exports = d(class {
                    constructor({ min: e = 0, max: c = 1 / 0, handlers: n = {} }) { this.min = e, this.max = c, this._onConnect = n.onConnect || r, this._onDisconnect = n.onDisconnect || r, this.peers = new Set; }
                    set registrar(e) { this._registrar = e; }
                    disconnect(e) { this._onDisconnect(e); }
                }, { className: "Topology", symbolName: "@libp2p/js-interfaces/topology" });
            }, function (E, m, f) {
                "use strict";
                E.exports = `
message RPC {
  repeated SubOpts subscriptions = 1;
  repeated Message msgs = 2;

  message SubOpts {
    optional bool subscribe = 1; // subscribe or unsubcribe
    optional string topicID = 2;
  }

  message Message {
    optional bytes from = 1;
    optional bytes data = 2;
    optional bytes seqno = 3;
    repeated string topicIDs = 4;
    optional bytes signature = 5;
    optional bytes key = 6;
  }
}`;
            }, function (E, m, f) {
                "use strict";
                E.exports = `
// topicCID = cid(merkledag_protobuf(topicDescriptor)); (not the topic.name)
message TopicDescriptor {
  optional string name = 1;
  optional AuthOpts auth = 2;
  optional EncOpts enc = 2;

  message AuthOpts {
    optional AuthMode mode = 1;
    repeated bytes keys = 2; // root keys to trust

    enum AuthMode {
      NONE = 0; // no authentication, anyone can publish
      KEY = 1; // only messages signed by keys in the topic descriptor are accepted
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }

  message EncOpts {
    optional EncMode mode = 1;
    repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

    enum EncMode {
      NONE = 0; // no encryption, anyone can read
      SHAREDKEY = 1; // messages are encrypted with shared key
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }
}`;
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(35), e = f(96), c = f(27), n = f(45), t = f(47), s = f(1), u = s("libp2p-pubsub:peer-streams");
                u.error = s("libp2p-pubsub:peer-streams:error"), E.exports = class extends d {
                    constructor({ id: i, protocol: o }) { super(), this.id = i, this.protocol = o, this._rawOutboundStream = null, this._rawInboundStream = null, this._inboundAbortController = null, this.outboundStream = null, this.inboundStream = null; }
                    get isReadable() { return Boolean(this.inboundStream); }
                    get isWritable() { return Boolean(this.outboundStream); }
                    write(i) { if (!this.isWritable) {
                        const o = this.id.toB58String();
                        throw new Error("No writable connection to " + o);
                    } this.outboundStream.push(i); }
                    attachInboundStream(i) { this._inboundAbortController = new t, this._rawInboundStream = i, this.inboundStream = n(c(this._rawInboundStream, r.decode()), this._inboundAbortController.signal, { returnOnAbort: !0 }), this.emit("stream:inbound"); }
                    async attachOutboundStream(i) { const o = this.outboundStream; o && await this.outboundStream.end(!1), this._rawOutboundStream = i, this.outboundStream = e({ onEnd: h => { this._rawOutboundStream.reset && this._rawOutboundStream.reset(), this._rawOutboundStream = null, this.outboundStream = null, h !== !1 && this.emit("close"); } }), c(this.outboundStream, r.encode(), this._rawOutboundStream).catch(h => { u.error(h); }), o || this.emit("stream:outbound"); }
                    close() { this.outboundStream && this.outboundStream.end(), this.inboundStream && this._inboundAbortController.abort(), this._rawOutboundStream = null, this.outboundStream = null, this._rawInboundStream = null, this.inboundStream = null, this.emit("close"); }
                };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(34), e = f(327);
                function c(n) { n = n || {}; const t = Math.max(n.poolSize || 10240, n.minPoolSize || 8), s = n.lengthEncoder || e; return u => async function* () { let i = d.alloc(t), o = 0; for await (const h of u) {
                    s(h.length, i, o);
                    const a = i.slice(o, o + s.bytes);
                    o += s.bytes, i.length - o < 8 && (i = d.alloc(t), o = 0), yield new r().append(a).append(h);
                } }(); }
                c.single = (n, t) => { const s = (t = t || {}).lengthEncoder || e; return new r([s(n.length), n]); }, E.exports = c, E.exports.MIN_POOL_SIZE = 8, E.exports.DEFAULT_POOL_SIZE = 10240;
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = f(34), e = f(328), c = d.alloc(0), n = "readLength", t = "readData", s = { [n]: (i, o, h, a) => { let l; o = o.append(i); try {
                        l = a.lengthDecoder(o);
                    }
                    catch (p) {
                        if (o.length > a.maxLengthLength)
                            throw Object.assign(p, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
                        if (p instanceof RangeError)
                            return { mode: n, buffer: o };
                        throw p;
                    } if (l > a.maxDataLength)
                        throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" }); return i = o.shallowSlice(a.lengthDecoder.bytes), o = new r, a.onLength && a.onLength(l), l <= 0 ? (a.onData && a.onData(c), { mode: n, chunk: i, buffer: o, data: c }) : { mode: t, chunk: i, buffer: o, state: { dataLength: l } }; }, [t]: (i, o, h, a) => { if ((o = o.append(i)).length < h.dataLength)
                        return { mode: t, buffer: o, state: h }; const { dataLength: l } = h, p = o.shallowSlice(0, l); return i = o.length > l ? o.shallowSlice(l) : null, o = new r, a.onData && a.onData(p), { mode: n, chunk: i, buffer: o, data: p }; } };
                function u(i) { return (i = i || {}).lengthDecoder = i.lengthDecoder || e, i.maxLengthLength = i.maxLengthLength || 8, i.maxDataLength = i.maxDataLength || 4194304, o => async function* () { let h, a = new r, l = n; for await (let p of o)
                    for (; p;) {
                        const g = s[l](p, a, h, i);
                        ({ mode: l, chunk: p, buffer: a, state: h } = g), g.data && (yield g.data);
                    } if (a.length)
                    throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" }); }(); }
                u.fromReader = (i, o) => { o = o || {}; let h = 1; const a = { [Symbol.asyncIterator]() { return this; }, next: async () => { try {
                        return await i.next(h);
                    }
                    catch (l) {
                        if (l.code === "ERR_UNDER_READ")
                            return { done: !0, value: null };
                        throw l;
                    }
                    finally {
                        h = 1;
                    } } }; return o.onLength = l => { h = l; }, u(o)(a); }, E.exports = u, E.exports.MAX_LENGTH_LENGTH = 8, E.exports.MAX_DATA_LENGTH = 4194304;
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), r = (e, c, n) => ((c = c || d.allocUnsafe(4)).writeInt32BE(e, n), c);
                r.bytes = 4, E.exports = r;
            }, function (E, m, f) {
                "use strict";
                const d = r => { if (r.length < 4)
                    throw RangeError("Could not decode int32BE"); return r.readInt32BE(0); };
                d.bytes = 4, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                E.exports = class extends Error {
                    constructor(d, r) { super(d || "The operation was aborted"), this.type = "aborted", this.code = r || "ABORT_ERR"; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(106), r = f(5), e = f(6), c = f(7);
                (m = E.exports).randomSeqno = () => d(8), m.msgId = (n, t) => { const s = c.createFromB58String(n).id, u = new Uint8Array(s.length + t.length); return u.set(s, 0), u.set(t, s.length), u; }, m.anyMatch = (n, t) => { let s; s = Array.isArray(t) ? u => t.indexOf(u) > -1 : u => t.has(u); for (const u of n)
                    if (s(u))
                        return !0; return !1; }, m.ensureArray = n => Array.isArray(n) ? n : [n], m.normalizeInRpcMessage = (n, t) => { const s = Object.assign({}, n); return n.from instanceof Uint8Array && (s.from = r(n.from, "base58btc")), t && (s.receivedFrom = t), s; }, m.normalizeOutRpcMessage = n => { const t = Object.assign({}, n); return (typeof n.from == "string" || n.from instanceof String) && (t.from = e(n.from, "base58btc")), (typeof n.data == "string" || n.data instanceof String) && (t.data = e(n.data)), t; };
            }, function (E, m, f) {
                "use strict";
                const d = f(7), { Message: r } = f(326), e = f(31), c = f(6)("libp2p-pubsub:");
                async function n(t) { const s = d.createFromCID(t.from); if (t.key) {
                    const u = await d.createFromPubKey(t.key);
                    if (u.isEqual(s))
                        return u.pubKey;
                    throw new Error("Public Key does not match the originator");
                } if (s.pubKey)
                    return s.pubKey; throw new Error("Could not get the public key from the originator id"); }
                E.exports = { messagePublicKey: n, signMessage: async function (t, s) { const u = e([c, r.encode(s)]), i = await t.privKey.sign(u); return { ...s, signature: i, key: t.pubKey.bytes }; }, SignPrefix: c, verifySignature: async function (t) { const s = { ...t }; delete s.signature, delete s.key, s.from = d.createFromCID(s.from).toBytes(); const u = e([c, r.encode(s)]); return (await n(t)).verify(u, t.signature); } };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.MessageCache = void 0;
                const d = f(74);
                m.MessageCache = class {
                    constructor(r, e, c) { this.msgs = new Map, this.peertx = new Map, this.history = []; for (let n = 0; n < e; n++)
                        this.history[n] = []; this.gossip = r, this.msgIdFn = c; }
                    put(r) { const e = this.getMsgId(r), c = d.messageIdToString(e); this.msgs.set(c, r), this.history[0].push({ msgID: e, topics: r.topicIDs }); }
                    getMsgId(r) { return this.msgIdFn(r); }
                    get(r) { return this.msgs.get(d.messageIdToString(r)); }
                    getForPeer(r, e) { const c = d.messageIdToString(r), n = this.msgs.get(c); if (!n)
                        return [void 0, 0]; let t = this.peertx.get(c); t || (t = new Map, this.peertx.set(c, t)); const s = (t.get(e) || 0) + 1; return t.set(e, s), [n, s]; }
                    getGossipIDs(r) { const e = []; for (let c = 0; c < this.gossip; c++)
                        this.history[c].forEach(n => { for (const t of n.topics)
                            if (t === r) {
                                e.push(n.msgID);
                                break;
                            } }); return e; }
                    shift() { this.history[this.history.length - 1].forEach(r => { const e = d.messageIdToString(r.msgID); this.msgs.delete(e), this.peertx.delete(e); }), this.history.pop(), this.history.unshift([]); }
                };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.createGossipRpc = void 0, m.createGossipRpc = function (d = [], r = {}) { return { subscriptions: [], msgs: d, control: Object.assign({ ihave: [], iwant: [], graft: [], prune: [] }, r) }; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.shuffle = void 0, m.shuffle = function (d) { if (d.length <= 1)
                    return d; for (let r = 0; r < d.length; r++) {
                    const e = Math.floor(Math.random() * Math.floor(d.length)), c = d[r];
                    d[r] = d[e], d[e] = c;
                } return d; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.hasGossipProtocol = void 0;
                const d = f(75);
                m.hasGossipProtocol = function (r) { return r === d.GossipsubIDv10 || r === d.GossipsubIDv11; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.messageIdToString = void 0;
                const d = f(5);
                m.messageIdToString = function (r) { return d(r, "base64"); };
            }, function (E, m, f) {
                "use strict";
                var d = function (c) { return c && c.__esModule ? c : { default: c }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.RPCCodec = void 0;
                const r = d(f(837)), e = f(21)(r.default);
                m.RPCCodec = e.RPC;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = `
message RPC {
  repeated SubOpts subscriptions = 1;
  repeated Message msgs = 2;
  optional ControlMessage control = 3;

  message SubOpts {
    optional bool subscribe = 1; // subscribe or unsubcribe
    optional string topicID = 2;
  }

  message Message {
    optional bytes from = 1;
    optional bytes data = 2;
    optional bytes seqno = 3;
    repeated string topicIDs = 4; 
    optional bytes signature = 5;
    optional bytes key = 6;
  }

  message ControlMessage {
    repeated ControlIHave ihave = 1;
    repeated ControlIWant iwant = 2;
    repeated ControlGraft graft = 3;
    repeated ControlPrune prune = 4;
  }

  message ControlIHave {
    optional string topicID = 1;
    repeated bytes messageIDs = 2;
  }

  message ControlIWant {
    repeated bytes messageIDs = 1;  
  }

  message ControlGraft {
    optional string topicID = 1;
  }

  message ControlPrune {
    optional string topicID = 1;
    repeated PeerInfo peers = 2;
    optional uint64 backoff = 3;
  }

  message PeerInfo {
    optional bytes peerID = 1;
    optional bytes signedPeerRecord = 2;
  }
}`;
            }, function (E, m, f) {
                "use strict";
                var d = Object.create ? function (s, u, i, o) { o === void 0 && (o = i), Object.defineProperty(s, o, { enumerable: !0, get: function () { return u[i]; } }); } : function (s, u, i, o) { o === void 0 && (o = i), s[o] = u[i]; }, r = Object.create ? function (s, u) { Object.defineProperty(s, "default", { enumerable: !0, value: u }); } : function (s, u) { s.default = u; }, e = function (s) { if (s && s.__esModule)
                    return s; var u = {}; if (s != null)
                    for (var i in s)
                        i !== "default" && Object.hasOwnProperty.call(s, i) && d(u, s, i); return r(u, s), u; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.Heartbeat = void 0;
                const c = e(f(75)), n = f(329), t = f(74);
                m.Heartbeat = class {
                    constructor(s) { this.gossipsub = s; }
                    start() { if (this._heartbeatTimer)
                        return; const s = this._heartbeat.bind(this), u = setTimeout(() => { s(), this._heartbeatTimer.runPeriodically(s, c.GossipsubHeartbeatInterval); }, c.GossipsubHeartbeatInitialDelay); this._heartbeatTimer = { _intervalId: void 0, runPeriodically: (i, o) => { this._heartbeatTimer._intervalId = setInterval(i, o); }, cancel: () => { clearTimeout(u), clearInterval(this._heartbeatTimer._intervalId); } }; }
                    stop() { this._heartbeatTimer && (this._heartbeatTimer.cancel(), this._heartbeatTimer = null); }
                    _heartbeat() { const { D: s, Dlo: u, Dhi: i, Dscore: o, Dout: h } = this.gossipsub._options; this.gossipsub.heartbeatTicks++; const a = new Map, l = v => { let R = a.get(v); return R === void 0 && (R = this.gossipsub.score.score(v), a.set(v, R)), R; }, p = new Map, g = new Map, b = new Map; this.gossipsub._clearBackoff(), this.gossipsub.peerhave.clear(), this.gossipsub.iasked.clear(), this.gossipsub._applyIwantPenalties(), this.gossipsub._directConnect(), this.gossipsub.mesh.forEach((v, R) => { const _ = x => { this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", x, R), this.gossipsub.score.prune(x, R), this.gossipsub._addBackoff(x, R), v.delete(x); const M = g.get(x); M ? M.push(R) : g.set(x, [R]); }, k = x => { this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", x, R), this.gossipsub.score.graft(x, R), v.add(x); const M = p.get(x); M ? M.push(R) : p.set(x, [R]); }; if (v.forEach(x => { const M = l(x); M < 0 && (this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", x, M, R), _(x), b.set(x, !0)); }), v.size < u) {
                        const x = this.gossipsub.backoff.get(R), M = s - v.size;
                        n.getGossipPeers(this.gossipsub, R, M, N => !v.has(N) && !this.gossipsub.direct.has(N) && (!x || !x.has(N)) && l(N) >= 0).forEach(k);
                    } if (v.size > i) {
                        let x = Array.from(v);
                        x.sort((N, S) => l(S) - l(N)), x = x.slice(0, o).concat(t.shuffle(x.slice(o)));
                        let M = 0;
                        if (x.slice(0, s).forEach(N => { this.gossipsub.outbound.get(N) && M++; }), M < h) {
                            const N = T => { const B = x[T]; for (let P = T; P > 0; P--)
                                x[P] = x[P - 1]; x[0] = B; };
                            if (M > 0) {
                                let T = M;
                                for (let B = 1; B < s && T > 0; B++)
                                    this.gossipsub.outbound.get(x[B]) && (N(B), T--);
                            }
                            let S = s - M;
                            for (let T = s; T < x.length && S > 0; T++)
                                this.gossipsub.outbound.get(x[T]) && (N(T), S--);
                        }
                        x.slice(s).forEach(_);
                    } if (v.size >= u) {
                        let x = 0;
                        if (v.forEach(M => { this.gossipsub.outbound.get(M) && x++; }), x < h) {
                            const M = h - x, N = this.gossipsub.backoff.get(R);
                            n.getGossipPeers(this.gossipsub, R, M, S => !v.has(S) && !this.gossipsub.direct.has(S) && (!N || !N.has(S)) && l(S) >= 0).forEach(k);
                        }
                    } if (this.gossipsub.heartbeatTicks % c.GossipsubOpportunisticGraftTicks == 0 && v.size > 1) {
                        const x = Array.from(v).sort((S, T) => l(S) - l(T)), M = v.size / 2, N = l(x[M]);
                        if (N < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
                            const S = this.gossipsub.backoff.get(R);
                            n.getGossipPeers(this.gossipsub, R, c.GossipsubOpportunisticGraftPeers, T => v.has(T) && !this.gossipsub.direct.has(T) && (!S || !S.has(T)) && l(T) > N).forEach(T => { this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", T, R), k(T); });
                        }
                    } this.gossipsub._emitGossip(R, v); }); const I = this.gossipsub._now(); this.gossipsub.lastpub.forEach((v, R) => { v + c.GossipsubFanoutTTL < I && (this.gossipsub.fanout.delete(R), this.gossipsub.lastpub.delete(R)); }), this.gossipsub.fanout.forEach((v, R) => { const _ = this.gossipsub.topics.get(R); if (v.forEach(k => { (!_.has(k) || l(k) < this.gossipsub._options.scoreThresholds.publishThreshold) && v.delete(k); }), v.size < s) {
                        const k = s - v.size;
                        n.getGossipPeers(this.gossipsub, R, k, x => !v.has(x) && !this.gossipsub.direct.has(x) && l(x) >= this.gossipsub._options.scoreThresholds.publishThreshold).forEach(x => { v.add(x); });
                    } this.gossipsub._emitGossip(R, v); }), this.gossipsub._sendGraftPrune(p, g, b), this.gossipsub._flush(), this.gossipsub.messageCache.shift(), this.gossipsub.emit("gossipsub:heartbeat"); }
                };
            }, function (E, m, f) {
                "use strict";
                var d = Object.create ? function (e, c, n, t) { t === void 0 && (t = n), Object.defineProperty(e, t, { enumerable: !0, get: function () { return c[n]; } }); } : function (e, c, n, t) { t === void 0 && (t = n), e[t] = c[n]; }, r = function (e, c) { for (var n in e)
                    n === "default" || c.hasOwnProperty(n) || d(c, e, n); };
                Object.defineProperty(m, "__esModule", { value: !0 }), r(f(330), m), r(f(840), m), r(f(841), m);
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.validatePeerScoreThresholds = m.createPeerScoreThresholds = m.defaultPeerScoreThresholds = void 0;
                const d = f(331), r = f(0);
                m.defaultPeerScoreThresholds = { gossipThreshold: -10, publishThreshold: -50, graylistThreshold: -80, acceptPXThreshold: 10, opportunisticGraftThreshold: 20 }, m.createPeerScoreThresholds = function (e = {}) { return Object.assign(Object.assign({}, m.defaultPeerScoreThresholds), e); }, m.validatePeerScoreThresholds = function (e) { if (e.gossipThreshold > 0)
                    throw r(new Error("invalid gossip threshold; it must be <= 0"), d.ERR_INVALID_PEER_SCORE_THRESHOLDS); if (e.publishThreshold > 0 || e.publishThreshold > e.gossipThreshold)
                    throw r(new Error("invalid publish threshold; it must be <= 0 and <= gossip threshold"), d.ERR_INVALID_PEER_SCORE_THRESHOLDS); if (e.graylistThreshold > 0 || e.graylistThreshold > e.publishThreshold)
                    throw r(new Error("invalid graylist threshold; it must be <= 0 and <= publish threshold"), d.ERR_INVALID_PEER_SCORE_THRESHOLDS); if (e.acceptPXThreshold < 0)
                    throw r(new Error("invalid accept PX threshold; it must be >= 0"), d.ERR_INVALID_PEER_SCORE_THRESHOLDS); if (e.opportunisticGraftThreshold < 0)
                    throw r(new Error("invalid opportunistic grafting threshold; it must be >= 0"), d.ERR_INVALID_PEER_SCORE_THRESHOLDS); };
            }, function (E, m, f) {
                "use strict";
                var d = function (l) { return l && l.__esModule ? l : { default: l }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.PeerScore = void 0;
                const r = f(330), e = f(842), c = f(843), n = f(844), t = f(75), s = d(f(7)), u = f(1), i = f(191), { ERR_INVALID_SIGNATURE: o, ERR_MISSING_SIGNATURE: h } = i.codes, a = u("libp2p:gossipsub:score");
                m.PeerScore = class {
                    constructor(l, p, g) { r.validatePeerScoreParams(l), this.params = l, this._connectionManager = p, this.peerStats = new Map, this.peerIPs = new Map, this.deliveryRecords = new n.MessageDeliveries, this.msgId = g; }
                    start() { this._backgroundInterval ? a("Peer score already running") : (this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval), a("started")); }
                    stop() { this._backgroundInterval ? (clearInterval(this._backgroundInterval), delete this._backgroundInterval, this.peerIPs.clear(), this.peerStats.clear(), this.deliveryRecords.clear(), a("stopped")) : a("Peer score already stopped"); }
                    background() { this._refreshScores(), this._updateIPs(), this.deliveryRecords.gc(); }
                    _refreshScores() { const l = Date.now(), p = this.params.decayToZero; this.peerStats.forEach((g, b) => { g.connected ? (Object.entries(g.topics).forEach(([I, v]) => { const R = this.params.topics[I]; R && (v.firstMessageDeliveries *= R.firstMessageDeliveriesDecay, v.firstMessageDeliveries < p && (v.firstMessageDeliveries = 0), v.meshMessageDeliveries *= R.meshMessageDeliveriesDecay, v.meshMessageDeliveries < p && (v.meshMessageDeliveries = 0), v.meshFailurePenalty *= R.meshFailurePenaltyDecay, v.meshFailurePenalty < p && (v.meshFailurePenalty = 0), v.invalidMessageDeliveries *= R.invalidMessageDeliveriesDecay, v.invalidMessageDeliveries < p && (v.invalidMessageDeliveries = 0), v.inMesh && (v.meshTime = l - v.graftTime, v.meshTime > R.meshMessageDeliveriesActivation && (v.meshMessageDeliveriesActive = !0))); }), g.behaviourPenalty *= this.params.behaviourPenaltyDecay, g.behaviourPenalty < p && (g.behaviourPenalty = 0)) : l > g.expire && (this._removeIPs(b, g.ips), this.peerStats.delete(b)); }); }
                    score(l) { const p = this.peerStats.get(l); return p ? c.computeScore(l, p, this.params, this.peerIPs) : 0; }
                    addPenalty(l, p) { const g = this.peerStats.get(l); g && (g.behaviourPenalty += p); }
                    addPeer(l) { const p = e.createPeerStats({ connected: !0 }); this.peerStats.set(l, p); const g = this._getIPs(l); this._setIPs(l, g, p.ips), p.ips = g; }
                    removePeer(l) { const p = this.peerStats.get(l); if (p) {
                        if (this.score(l) > 0)
                            return this._removeIPs(l, p.ips), void this.peerStats.delete(l);
                        Object.entries(p.topics).forEach(([g, b]) => { b.firstMessageDeliveries = 0; const I = this.params.topics[g].meshMessageDeliveriesThreshold; if (b.inMesh && b.meshMessageDeliveriesActive && b.meshMessageDeliveries < I) {
                            const v = I - b.meshMessageDeliveries;
                            b.meshFailurePenalty += v * v;
                        } b.inMesh = !1; }), p.connected = !1, p.expire = Date.now() + this.params.retainScore;
                    } }
                    graft(l, p) { const g = this.peerStats.get(l); if (!g)
                        return; const b = e.ensureTopicStats(p, g, this.params); b && (b.inMesh = !0, b.graftTime = Date.now(), b.meshTime = 0, b.meshMessageDeliveriesActive = !1); }
                    prune(l, p) { const g = this.peerStats.get(l); if (!g)
                        return; const b = e.ensureTopicStats(p, g, this.params); if (!b)
                        return; const I = this.params.topics[p].meshMessageDeliveriesThreshold; if (b.meshMessageDeliveriesActive && b.meshMessageDeliveries < I) {
                        const v = I - b.meshMessageDeliveries;
                        b.meshFailurePenalty += v * v;
                    } b.inMesh = !1; }
                    validateMessage(l) { this.deliveryRecords.ensureRecord(this.msgId(l)); }
                    deliverMessage(l) { const p = l.receivedFrom; this._markFirstMessageDelivery(p, l); const g = this.deliveryRecords.ensureRecord(this.msgId(l)), b = Date.now(); g.status === n.DeliveryRecordStatus.unknown ? (g.status = n.DeliveryRecordStatus.valid, g.validated = b, g.peers.forEach(I => { I !== p && this._markDuplicateMessageDelivery(I, l); })) : a("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", p, b - g.firstSeen, n.DeliveryRecordStatus[g.status]); }
                    rejectMessage(l, p) { const g = l.receivedFrom; switch (p) {
                        case h:
                        case o: return void this._markInvalidMessageDelivery(g, l);
                    } const b = this.deliveryRecords.ensureRecord(this.msgId(l)); if (b.status === n.DeliveryRecordStatus.unknown) {
                        switch (p) {
                            case t.ERR_TOPIC_VALIDATOR_IGNORE: return void (b.status = n.DeliveryRecordStatus.ignored);
                        }
                        b.status = n.DeliveryRecordStatus.invalid, this._markInvalidMessageDelivery(g, l), b.peers.forEach(I => { this._markInvalidMessageDelivery(I, l); });
                    }
                    else
                        a("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", g, Date.now() - b.firstSeen, n.DeliveryRecordStatus[b.status]); }
                    duplicateMessage(l) { const p = l.receivedFrom, g = this.deliveryRecords.ensureRecord(this.msgId(l)); if (!g.peers.has(p))
                        switch (g.status) {
                            case n.DeliveryRecordStatus.unknown:
                                g.peers.add(p);
                                break;
                            case n.DeliveryRecordStatus.valid:
                                g.peers.add(p), this._markDuplicateMessageDelivery(p, l, g.validated);
                                break;
                            case n.DeliveryRecordStatus.invalid: this._markInvalidMessageDelivery(p, l);
                        } }
                    _markInvalidMessageDelivery(l, p) { const g = this.peerStats.get(l); g && p.topicIDs.forEach(b => { const I = e.ensureTopicStats(b, g, this.params); I && (I.invalidMessageDeliveries += 1); }); }
                    _markFirstMessageDelivery(l, p) { const g = this.peerStats.get(l); g && p.topicIDs.forEach(b => { const I = e.ensureTopicStats(b, g, this.params); if (!I)
                        return; let v = this.params.topics[b].firstMessageDeliveriesCap; I.firstMessageDeliveries += 1, I.firstMessageDeliveries > v && (I.firstMessageDeliveries = v), I.inMesh && (v = this.params.topics[b].meshMessageDeliveriesCap, I.meshMessageDeliveries += 1, I.meshMessageDeliveries > v && (I.meshMessageDeliveries = v)); }); }
                    _markDuplicateMessageDelivery(l, p, g = 0) { const b = this.peerStats.get(l); if (!b)
                        return; const I = g ? Date.now() : 0; p.topicIDs.forEach(v => { const R = e.ensureTopicStats(v, b, this.params); if (!R)
                        return; if (!R.inMesh)
                        return; const _ = this.params.topics[v]; if (g && I > g + _.meshMessageDeliveriesWindow)
                        return; const k = _.meshMessageDeliveriesCap; R.meshMessageDeliveries += 1, R.meshMessageDeliveries > k && (R.meshMessageDeliveries = k); }); }
                    _getIPs(l) { return this._connectionManager.getAll(s.default.createFromB58String(l)).map(p => p.remoteAddr.toOptions().host); }
                    _setIPs(l, p, g) { t: for (const b of p) {
                        for (const v of g)
                            if (b === v)
                                continue t;
                        let I = this.peerIPs.get(b);
                        I || (I = new Set, this.peerIPs.set(b, I)), I.add(l);
                    } t: for (const b of g) {
                        for (const v of p)
                            if (b === v)
                                continue t;
                        const I = this.peerIPs.get(b);
                        I && (I.delete(l), I.size || this.peerIPs.delete(b));
                    } }
                    _removeIPs(l, p) { p.forEach(g => { const b = this.peerIPs.get(g); b && (b.delete(l), b.size || this.peerIPs.delete(g)); }); }
                    _updateIPs() { this.peerStats.forEach((l, p) => { const g = this._getIPs(p); this._setIPs(p, g, l.ips), l.ips = g; }); }
                };
            }, function (E, m, f) {
                "use strict";
                function d(r = {}) { return Object.assign({ inMesh: !1, graftTime: 0, meshTime: 0, firstMessageDeliveries: 0, meshMessageDeliveries: 0, meshMessageDeliveriesActive: !1, meshFailurePenalty: 0, invalidMessageDeliveries: 0 }, r); }
                Object.defineProperty(m, "__esModule", { value: !0 }), m.ensureTopicStats = m.createTopicStats = m.createPeerStats = void 0, m.createPeerStats = function (r = {}) { return Object.assign(Object.assign({ connected: !1, expire: 0, ips: [], behaviourPenalty: 0 }, r), { topics: r.topics ? Object.entries(r.topics).reduce((e, [c, n]) => (e[c] = d(n), e), {}) : {} }); }, m.createTopicStats = d, m.ensureTopicStats = function (r, e, c) { let n = e.topics[r]; return n || (c.topics[r] ? (e.topics[r] = n = d(), n) : void 0); };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.computeScore = void 0, m.computeScore = function (d, r, e, c) { let n = 0; Object.entries(r.topics).forEach(([u, i]) => { const o = e.topics[u]; if (!o)
                    return; let h = 0; if (i.inMesh) {
                    let a = i.meshTime / o.timeInMeshQuantum;
                    a > o.timeInMeshCap && (a = o.timeInMeshCap), h += a * o.timeInMeshWeight;
                } if (h += i.firstMessageDeliveries * o.firstMessageDeliveriesWeight, i.meshMessageDeliveriesActive && i.meshMessageDeliveries < o.meshMessageDeliveriesThreshold) {
                    const a = o.meshMessageDeliveriesThreshold - i.meshMessageDeliveries;
                    h += a * a * o.meshMessageDeliveriesWeight;
                } h += i.meshFailurePenalty * o.meshFailurePenaltyWeight, h += i.invalidMessageDeliveries * i.invalidMessageDeliveries * o.invalidMessageDeliveriesWeight, n += h * o.topicWeight; }), e.topicScoreCap > 0 && n > e.topicScoreCap && (n = e.topicScoreCap); const t = e.appSpecificScore(d); n += t * e.appSpecificWeight, r.ips.forEach(u => { if (e.IPColocationFactorWhitelist.has(u))
                    return; const i = c.get(u), o = i ? i.size : 0; if (o > e.IPColocationFactorThreshold) {
                    const h = o - e.IPColocationFactorThreshold;
                    n += h * h * e.IPColocationFactorWeight;
                } }); const s = r.behaviourPenalty * r.behaviourPenalty; return n += s * e.behaviourPenaltyWeight, n; };
            }, function (E, m, f) {
                "use strict";
                var d = function (t) { return t && t.__esModule ? t : { default: t }; };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.MessageDeliveries = m.DeliveryRecordStatus = void 0;
                const r = f(75), e = d(f(845)), c = f(74);
                var n;
                !function (t) { t[t.unknown = 0] = "unknown", t[t.valid = 1] = "valid", t[t.invalid = 2] = "invalid", t[t.ignored = 3] = "ignored"; }(n = m.DeliveryRecordStatus || (m.DeliveryRecordStatus = {})), m.MessageDeliveries = class {
                    constructor() { this.records = new Map, this.queue = new e.default; }
                    ensureRecord(t) { const s = c.messageIdToString(t); let u = this.records.get(s); if (u)
                        return u; u = { status: n.unknown, firstSeen: Date.now(), validated: 0, peers: new Set }, this.records.set(s, u); const i = { msgId: s, expire: Date.now() + r.TimeCacheDuration }; return this.queue.push(i), u; }
                    gc() { const t = Date.now(); let s = this.queue.peekFront(); for (; s && s.expire < t;)
                        this.records.delete(s.msgId), this.queue.shift(), s = this.queue.peekFront(); }
                    clear() { this.records.clear(), this.queue.clear(); }
                };
            }, function (E, m, f) {
                "use strict";
                function d(r) { this._head = 0, this._tail = 0, this._capacityMask = 3, this._list = new Array(4), Array.isArray(r) && this._fromArray(r); }
                d.prototype.peekAt = function (r) { var e = r; if (e === (0 | e)) {
                    var c = this.size();
                    if (!(e >= c || e < -c))
                        return e < 0 && (e += c), e = this._head + e & this._capacityMask, this._list[e];
                } }, d.prototype.get = function (r) { return this.peekAt(r); }, d.prototype.peek = function () { if (this._head !== this._tail)
                    return this._list[this._head]; }, d.prototype.peekFront = function () { return this.peek(); }, d.prototype.peekBack = function () { return this.peekAt(-1); }, Object.defineProperty(d.prototype, "length", { get: function () { return this.size(); } }), d.prototype.size = function () { return this._head === this._tail ? 0 : this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail); }, d.prototype.unshift = function (r) { if (r === void 0)
                    return this.size(); var e = this._list.length; return this._head = this._head - 1 + e & this._capacityMask, this._list[this._head] = r, this._tail === this._head && this._growArray(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail); }, d.prototype.shift = function () { var r = this._head; if (r !== this._tail) {
                    var e = this._list[r];
                    return this._list[r] = void 0, this._head = r + 1 & this._capacityMask, r < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2 && this._shrinkArray(), e;
                } }, d.prototype.push = function (r) { if (r === void 0)
                    return this.size(); var e = this._tail; return this._list[e] = r, this._tail = e + 1 & this._capacityMask, this._tail === this._head && this._growArray(), this._head < this._tail ? this._tail - this._head : this._capacityMask + 1 - (this._head - this._tail); }, d.prototype.pop = function () { var r = this._tail; if (r !== this._head) {
                    var e = this._list.length;
                    this._tail = r - 1 + e & this._capacityMask;
                    var c = this._list[this._tail];
                    return this._list[this._tail] = void 0, this._head < 2 && r > 1e4 && r <= e >>> 2 && this._shrinkArray(), c;
                } }, d.prototype.removeOne = function (r) { var e = r; if (e === (0 | e) && this._head !== this._tail) {
                    var c = this.size(), n = this._list.length;
                    if (!(e >= c || e < -c)) {
                        e < 0 && (e += c), e = this._head + e & this._capacityMask;
                        var t, s = this._list[e];
                        if (r < c / 2) {
                            for (t = r; t > 0; t--)
                                this._list[e] = this._list[e = e - 1 + n & this._capacityMask];
                            this._list[e] = void 0, this._head = this._head + 1 + n & this._capacityMask;
                        }
                        else {
                            for (t = c - 1 - r; t > 0; t--)
                                this._list[e] = this._list[e = e + 1 + n & this._capacityMask];
                            this._list[e] = void 0, this._tail = this._tail - 1 + n & this._capacityMask;
                        }
                        return s;
                    }
                } }, d.prototype.remove = function (r, e) { var c, n = r, t = e; if (n === (0 | n) && this._head !== this._tail) {
                    var s = this.size(), u = this._list.length;
                    if (!(n >= s || n < -s || e < 1)) {
                        if (n < 0 && (n += s), e === 1 || !e)
                            return (c = new Array(1))[0] = this.removeOne(n), c;
                        if (n === 0 && n + e >= s)
                            return c = this.toArray(), this.clear(), c;
                        var i;
                        for (n + e > s && (e = s - n), c = new Array(e), i = 0; i < e; i++)
                            c[i] = this._list[this._head + n + i & this._capacityMask];
                        if (n = this._head + n & this._capacityMask, r + e === s) {
                            for (this._tail = this._tail - e + u & this._capacityMask, i = e; i > 0; i--)
                                this._list[n = n + 1 + u & this._capacityMask] = void 0;
                            return c;
                        }
                        if (r === 0) {
                            for (this._head = this._head + e + u & this._capacityMask, i = e - 1; i > 0; i--)
                                this._list[n = n + 1 + u & this._capacityMask] = void 0;
                            return c;
                        }
                        if (n < s / 2) {
                            for (this._head = this._head + r + e + u & this._capacityMask, i = r; i > 0; i--)
                                this.unshift(this._list[n = n - 1 + u & this._capacityMask]);
                            for (n = this._head - 1 + u & this._capacityMask; t > 0;)
                                this._list[n = n - 1 + u & this._capacityMask] = void 0, t--;
                            r < 0 && (this._tail = n);
                        }
                        else {
                            for (this._tail = n, n = n + e + u & this._capacityMask, i = s - (e + r); i > 0; i--)
                                this.push(this._list[n++]);
                            for (n = this._tail; t > 0;)
                                this._list[n = n + 1 + u & this._capacityMask] = void 0, t--;
                        }
                        return this._head < 2 && this._tail > 1e4 && this._tail <= u >>> 2 && this._shrinkArray(), c;
                    }
                } }, d.prototype.splice = function (r, e) { var c = r; if (c === (0 | c)) {
                    var n = this.size();
                    if (c < 0 && (c += n), !(c > n)) {
                        if (arguments.length > 2) {
                            var t, s, u, i = arguments.length, o = this._list.length, h = 2;
                            if (!n || c < n / 2) {
                                for (s = new Array(c), t = 0; t < c; t++)
                                    s[t] = this._list[this._head + t & this._capacityMask];
                                for (e === 0 ? (u = [], c > 0 && (this._head = this._head + c + o & this._capacityMask)) : (u = this.remove(c, e), this._head = this._head + c + o & this._capacityMask); i > h;)
                                    this.unshift(arguments[--i]);
                                for (t = c; t > 0; t--)
                                    this.unshift(s[t - 1]);
                            }
                            else {
                                var a = (s = new Array(n - (c + e))).length;
                                for (t = 0; t < a; t++)
                                    s[t] = this._list[this._head + c + e + t & this._capacityMask];
                                for (e === 0 ? (u = [], c != n && (this._tail = this._head + c + o & this._capacityMask)) : (u = this.remove(c, e), this._tail = this._tail - a + o & this._capacityMask); h < i;)
                                    this.push(arguments[h++]);
                                for (t = 0; t < a; t++)
                                    this.push(s[t]);
                            }
                            return u;
                        }
                        return this.remove(c, e);
                    }
                } }, d.prototype.clear = function () { this._head = 0, this._tail = 0; }, d.prototype.isEmpty = function () { return this._head === this._tail; }, d.prototype.toArray = function () { return this._copyArray(!1); }, d.prototype._fromArray = function (r) { for (var e = 0; e < r.length; e++)
                    this.push(r[e]); }, d.prototype._copyArray = function (r) { var e, c = [], n = this._list, t = n.length; if (r || this._head > this._tail) {
                    for (e = this._head; e < t; e++)
                        c.push(n[e]);
                    for (e = 0; e < this._tail; e++)
                        c.push(n[e]);
                }
                else
                    for (e = this._head; e < this._tail; e++)
                        c.push(n[e]); return c; }, d.prototype._growArray = function () { this._head && (this._list = this._copyArray(!0), this._head = 0), this._tail = this._list.length, this._list.length *= 2, this._capacityMask = this._capacityMask << 1 | 1; }, d.prototype._shrinkArray = function () { this._list.length >>>= 1, this._capacityMask >>>= 1; }, E.exports = d;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.IWantTracer = void 0;
                const d = f(75), r = f(74), e = f(191), { ERR_INVALID_SIGNATURE: c, ERR_MISSING_SIGNATURE: n } = e.codes;
                m.IWantTracer = class {
                    constructor(t) { this.getMsgId = t, this.promises = new Map; }
                    addPromise(t, s) { const u = s[Math.floor(Math.random() * s.length)], i = r.messageIdToString(u); let o = this.promises.get(i); o || (o = new Map, this.promises.set(i, o)), o.has(t) || o.set(t, Date.now() + d.GossipsubIWantFollowupTime); }
                    getBrokenPromises() { const t = Date.now(), s = new Map; return this.promises.forEach((u, i) => { u.forEach((o, h) => { o < t && (s.set(h, (s.get(h) || 0) + 1), u.delete(h)); }), u.size || this.promises.delete(i); }), s; }
                    deliverMessage(t) { const s = this.getMsgId(t), u = r.messageIdToString(s); this.promises.delete(u); }
                    rejectMessage(t, s) { switch (s) {
                        case c:
                        case n: return;
                    } const u = this.getMsgId(t), i = r.messageIdToString(u); this.promises.delete(i); }
                    clear() { this.promises.clear(); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(848);
                E.exports = function r(e) { if (!(this instanceof r))
                    return new r(e); const c = (e = e || {}).validity || 30, n = new Map, t = d(() => { n.forEach((s, u) => { const i = s.validity || c; (function (o) { const h = new Date().getTime() - o.getTime(); return Math.floor(h / 1e3); })(s.timestamp) > i && n.delete(u); }); }, 200); this.put = (s, u, i) => { this.has(s) || n.set(s, { value: u, timestamp: new Date, validity: i }), t(); }, this.get = s => { if (n.has(s))
                    return n.get(s).value; throw new Error("key does not exist"); }, this.has = s => n.has(s); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r = /^\s+|\s+$/g, e = /^[-+]0x[0-9a-f]+$/i, c = /^0b[01]+$/i, n = /^0o[0-7]+$/i, t = parseInt, s = typeof d == "object" && d && d.Object === Object && d, u = typeof self == "object" && self && self.Object === Object && self, i = s || u || Function("return this")(), o = Object.prototype.toString, h = Math.max, a = Math.min, l = function () { return i.Date.now(); }; function p(I, v, R) { var _, k, x, M, N, S, T = 0, B = !1, P = !1, L = !0; if (typeof I != "function")
                    throw new TypeError("Expected a function"); function j(K) { var F = _, Y = k; return _ = k = void 0, T = K, M = I.apply(Y, F); } function D(K) { return T = K, N = setTimeout(W, v), B ? j(K) : M; } function G(K) { var F = K - S; return S === void 0 || F >= v || F < 0 || P && K - T >= x; } function W() { var K = l(); if (G(K))
                    return X(K); N = setTimeout(W, function (F) { var Y = v - (F - S); return P ? a(Y, x - (F - T)) : Y; }(K)); } function X(K) { return N = void 0, L && _ ? j(K) : (_ = k = void 0, M); } function Q() { var K = l(), F = G(K); if (_ = arguments, k = this, S = K, F) {
                    if (N === void 0)
                        return D(S);
                    if (P)
                        return N = setTimeout(W, v), j(S);
                } return N === void 0 && (N = setTimeout(W, v)), M; } return v = b(v) || 0, g(R) && (B = !!R.leading, x = (P = "maxWait" in R) ? h(b(R.maxWait) || 0, v) : x, L = "trailing" in R ? !!R.trailing : L), Q.cancel = function () { N !== void 0 && clearTimeout(N), T = 0, _ = S = k = N = void 0; }, Q.flush = function () { return N === void 0 ? M : X(l()); }, Q; } function g(I) { var v = typeof I; return !!I && (v == "object" || v == "function"); } function b(I) { if (typeof I == "number")
                    return I; if (function (_) { return typeof _ == "symbol" || function (k) { return !!k && typeof k == "object"; }(_) && o.call(_) == "[object Symbol]"; }(I))
                    return NaN; if (g(I)) {
                    var v = typeof I.valueOf == "function" ? I.valueOf() : I;
                    I = g(v) ? v + "" : v;
                } if (typeof I != "string")
                    return I === 0 ? I : +I; I = I.replace(r, ""); var R = c.test(I); return R || n.test(I) ? t(I.slice(2), R ? 2 : 8) : e.test(I) ? NaN : +I; } E.exports = function (I, v, R) { var _ = !0, k = !0; if (typeof I != "function")
                    throw new TypeError("Expected a function"); return g(R) && (_ = "leading" in R ? !!R.leading : _, k = "trailing" in R ? !!R.trailing : k), p(I, v, { leading: _, maxWait: v, trailing: k }); }; }).call(this, f(10));
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message Envelope {
  // public_key is the public key of the keypair the enclosed payload was
  // signed with.
  bytes public_key = 1;

  // payload_type encodes the type of payload, so that it can be deserialized
  // deterministically.
  bytes payload_type = 2;

  // payload is the actual payload carried inside this envelope.
  bytes payload = 3;

  // signature is the signature produced by the private key corresponding to
  // the enclosed public key, over the payload, prefixing a domain string for
  // additional security.
  bytes signature = 5;
}
`).Envelope;
            }, function (E, m, f) {
                "use strict";
                const { EventEmitter: d } = f(12), r = f(1), e = f(194), c = r("libp2p");
                c.error = r("libp2p:error");
                const n = f(0), t = f(7), s = f(851), u = f(856), i = f(334), { validate: o } = f(857), { codes: h, messages: a } = f(28), l = f(870), p = f(871), g = f(874), b = f(878), I = f(882), v = f(894), R = f(336), _ = f(897), k = f(345), x = f(913), M = f(914), N = f(918), S = f(920), { IdentifyService: T, multicodecs: B } = f(922);
                class P extends d {
                    constructor(j) { if (super(), this._options = o(j), this.peerId = this._options.peerId, this.datastore = this._options.datastore, this.peerStore = this.datastore && this._options.peerStore.persistence ? new M({ peerId: this.peerId, datastore: this.datastore, ...this._options.peerStore }) : new k({ peerId: this.peerId }), this.addresses = this._options.addresses, this.addressManager = new l(this._options.addresses), this._modules = this._options.modules, this._config = this._options.config, this._transport = [], this._discovery = new Map, this._options.connectionManager.minPeers && (this._options.connectionManager.minConnections = this._options.connectionManager.minPeers), this.connectionManager = new p(this, { autoDial: this._config.peerDiscovery.autoDial, ...this._options.connectionManager }), this._options.metrics.enabled && (this.metrics = new v({ ...this._options.metrics, connectionManager: this.connectionManager })), this._options.keychain && this._options.keychain.datastore) {
                        c("creating keychain");
                        const D = I.generateOptions();
                        this.keychain = new I(this._options.keychain.datastore, { passPhrase: this._options.keychain.pass, ...D, ...this._options.keychain }), c("keychain constructed");
                    } if (this.upgrader = new _({ localPeer: this.peerId, metrics: this.metrics, onConnection: D => this.connectionManager.onConnect(D), onConnectionEnd: D => this.connectionManager.onDisconnect(D) }), this.transportManager = new R({ libp2p: this, upgrader: this.upgrader, faultTolerance: this._options.transportManager.faultTolerance }), this.registrar = new N({ peerStore: this.peerStore, connectionManager: this.connectionManager }), this.handle = this.handle.bind(this), this.registrar.handle = this.handle, !this._modules.connEncryption || !this._modules.connEncryption.length)
                        throw n(new Error(a.CONN_ENCRYPTION_REQUIRED), h.CONN_ENCRYPTION_REQUIRED); if ((this._modules.connEncryption.forEach(D => { this.upgrader.cryptos.set(D.protocol, D); }), this.dialer = new b({ transportManager: this.transportManager, peerStore: this.peerStore, concurrency: this._options.dialer.maxParallelDials, perPeerLimit: this._options.dialer.maxDialsPerPeer, timeout: this._options.dialer.dialTimeout, resolvers: this._options.dialer.resolvers }), this._modules.transport.forEach(D => { const G = D.prototype[Symbol.toStringTag], W = this._config.transport[G]; this.transportManager.add(G, D, W); }), this._config.relay.enabled && this.transportManager.add(g.prototype[Symbol.toStringTag], g), this._modules.streamMuxer) && (this._modules.streamMuxer.forEach(D => { this.upgrader.muxers.set(D.multicodec, D); }), this.identifyService = new T({ libp2p: this, protocols: this.upgrader.protocols }), this.handle(Object.values(B), this.identifyService.handleMessage)), this._modules.connProtector)
                        this.upgrader.protector = this._modules.connProtector;
                    else if (e.process !== void 0 && e.process.env && e.process.env.LIBP2P_FORCE_PNET)
                        throw new Error("Private network is enforced, but no protector was provided"); if (this._modules.dht) {
                        const D = this._modules.dht;
                        this._dht = new D({ libp2p: this, dialer: this.dialer, peerId: this.peerId, peerStore: this.peerStore, registrar: this.registrar, datastore: this.datastore, ...this._config.dht });
                    } if (this._modules.pubsub) {
                        const D = this._modules.pubsub;
                        this.pubsub = x(D, this, this._config.pubsub);
                    } this.peerRouting = s(this), this.contentRouting = u(this), S.mount(this), this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this); }
                    emit(j, ...D) { j !== "error" || this._events.error ? super.emit(j, ...D) : c.error(...D); }
                    async start() { c("libp2p is starting"); try {
                        await this._onStarting(), await this._onDidStart(), c("libp2p has started");
                    }
                    catch (j) {
                        throw this.emit("error", j), c.error("An error occurred starting libp2p", j), await this.stop(), j;
                    } }
                    async stop() { c("libp2p is stopping"); try {
                        for (const j of this._discovery.values())
                            j.removeListener("peer", this._onDiscoveryPeer);
                        await Promise.all(Array.from(this._discovery.values(), j => j.stop())), this._discovery = new Map, await this.peerStore.stop(), await this.connectionManager.stop(), await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]), await this.transportManager.close(), S.unmount(this), this.dialer.destroy();
                    }
                    catch (j) {
                        j && (c.error(j), this.emit("error", j));
                    } this._isStarted = !1, c("libp2p has stopped"); }
                    async loadKeychain() { try {
                        await this.keychain.findKeyByName("self");
                    }
                    catch (j) {
                        await this.keychain.importPeer("self", this.peerId);
                    } }
                    isStarted() { return this._isStarted; }
                    get connections() { return this.connectionManager.connections; }
                    dial(j, D) { return this.dialProtocol(j, null, D); }
                    async dialProtocol(j, D, G) { const { id: W, multiaddrs: X } = i(j); if (W.equals(this.peerId))
                        throw n(new Error("Cannot dial self"), h.ERR_DIALED_SELF); let Q = this.connectionManager.get(W); return Q ? X && this.peerStore.addressBook.add(W, X) : Q = await this.dialer.connectToPeer(j, G), D ? Q.newStream(D) : Q; }
                    get multiaddrs() { const j = this.addressManager.getNoAnnounceAddrs(); return this.transportManager.getAddrs().concat(this.addressManager.getAnnounceAddrs()).filter((D, G, W) => W.findIndex(X => X.equals(D)) === G && !j.find(X => X.equals(D))); }
                    async hangUp(j) { const { id: D } = i(j), G = this.connectionManager.connections.get(D.toB58String()); G && await Promise.all(G.map(W => W.close())); }
                    ping(j) { const { id: D, multiaddrs: G } = i(j); return S(this, G ? G[0] : D); }
                    handle(j, D) { (j = Array.isArray(j) ? j : [j]).forEach(G => { this.upgrader.protocols.set(G, D); }), this.isStarted() && this.identifyService && this.identifyService.pushToPeerStore(this.peerStore); }
                    unhandle(j) { (j = Array.isArray(j) ? j : [j]).forEach(D => { this.upgrader.protocols.delete(D); }), this.isStarted() && this.identifyService && this.identifyService.pushToPeerStore(this.peerStore); }
                    async _onStarting() { await this.transportManager.listen(), await this.peerStore.start(), this._config.pubsub.enabled && this.pubsub && this.pubsub.start(), this._config.dht.enabled && (this._dht && this._dht.start(), this._dht.on("peer", this._onDiscoveryPeer)), this.metrics && this.metrics.start(); }
                    async _onDidStart() { this._isStarted = !0, this.peerStore.on("peer", j => { this.emit("peer:discovery", j), this._maybeConnect(j); }); for (const j of this.peerStore.peers.values())
                        this.emit("peer:discovery", j.id); this.connectionManager.start(), await this._setupPeerDiscovery(); }
                    _onDiscoveryPeer(j) { j.id.toB58String() !== this.peerId.toB58String() ? (j.multiaddrs && this.peerStore.addressBook.add(j.id, j.multiaddrs), j.protocols && this.peerStore.protoBook.set(j.id, j.protocols)) : c.error(new Error(h.ERR_DISCOVERED_SELF)); }
                    async _maybeConnect(j) { if (this._config.peerDiscovery.autoDial === !0 && !this.connectionManager.get(j) && (this._options.connectionManager.minConnections || 0) > this.connectionManager.size) {
                        c("connecting to discovered peer %s", j.toB58String());
                        try {
                            await this.dialer.connectToPeer(j);
                        }
                        catch (D) {
                            c.error("could not connect to discovered peer", D);
                        }
                    } }
                    async _setupPeerDiscovery() { const j = D => { let G = { enabled: !0 }; if (D.tag && this._config.peerDiscovery && this._config.peerDiscovery[D.tag] && (G = { ...G, ...this._config.peerDiscovery[D.tag] }), G.enabled && !this._discovery.has(D.tag)) {
                        let W;
                        W = typeof D == "function" ? new D(Object.assign({}, G, { peerId: this.peerId, libp2p: this })) : D, W.on("peer", this._onDiscoveryPeer), this._discovery.set(D.tag, W);
                    } }; for (const D of this._modules.peerDiscovery || [])
                        j(D); for (const D of this.transportManager.getTransports())
                        D.discovery && j(D.discovery); await Promise.all(Array.from(this._discovery.values(), D => D.start())); }
                }
                P.create = async function (L = {}) { if (L.peerId)
                    return new P(L); const j = await t.create(); return L.peerId = j, new P(L); }, E.exports = P;
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(195);
                E.exports = e => { const c = e._modules.peerRouting || []; return e._dht && c.unshift(e._dht), { findPeer: async (n, t) => { if (!c.length)
                        throw d(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE"); return r(c.map(async (s) => { const u = await s.findPeer(n, t); if (!u || Object.keys(u).length === 0)
                        throw d(new Error("not found"), "NOT_FOUND"); return u; })); } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(332), r = f(333);
                class e extends Error {
                }
                E.exports = (c, n) => new r((t, s, u) => { const { count: i, filter: o = () => !0 } = n; if (!Number.isFinite(i))
                    return void s(new TypeError("Expected a finite number, got " + typeof n.count)); const h = [], a = []; let l = 0, p = !1; const g = new Set, b = () => { for (const I of c)
                    g.has(I) || typeof I.cancel != "function" || I.cancel(); }; u(b); for (const I of c)
                    l++, (async () => { try {
                        const v = await I;
                        if (p)
                            return;
                        if (!o(v))
                            throw new e("Value does not satisfy filter");
                        h.push(v);
                    }
                    catch (v) {
                        a.push(v);
                    }
                    finally {
                        g.add(I), !p && (h.length === i && (t(h), p = !0), l - a.length < i && (s(new d(a)), p = !0), p) && b();
                    } })(); i > l && (s(new RangeError(`Expected input to contain at least ${n.count} items, but contains ${l} items`)), b()); }), E.exports.AggregateError = d, E.exports.FilterError = e;
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r = 1, e) => { if (e = { indent: " ", includeEmptyLines: !1, ...e }, typeof d != "string")
                    throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof d}\``); if (typeof r != "number")
                    throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``); if (typeof e.indent != "string")
                    throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof e.indent}\``); if (r === 0)
                    return d; const c = e.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm; return d.replace(c, e.indent.repeat(r)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(855), r = /\s+at.*(?:\(|\s)(.*)\)?/, e = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/, c = d.homedir === void 0 ? "" : d.homedir();
                E.exports = (n, t) => (t = Object.assign({ pretty: !1 }, t), n.replace(/\\/g, "/").split(`
`).filter(s => { const u = s.match(r); if (u === null || !u[1])
                    return !0; const i = u[1]; return !i.includes(".app/Contents/Resources/electron.asar") && !i.includes(".app/Contents/Resources/default_app.asar") && !e.test(i); }).filter(s => s.trim() !== "").map(s => t.pretty ? s.replace(r, (u, i) => u.replace(i, i.replace(c, "~"))) : s).join(`
`));
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                const d = f(0), { messages: r, codes: e } = f(28), c = f(88), n = f(195);
                E.exports = t => { const s = t._modules.contentRouting || [], u = t._dht; return u && s.unshift(u), { async *findProviders(i, o) { if (!s.length)
                        throw d(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE"); const h = await n(s.map(async (a) => { const l = await c(a.findProviders(i, o)); if (!l || !l.length)
                        throw d(new Error("not found"), "NOT_FOUND"); return l; })); for (const a of h)
                        yield a; }, async provide(i) { if (!s.length)
                        throw d(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE"); return Promise.all(s.map(o => o.provide(i))); }, async put(i, o, h) { if (!t.isStarted() || !u.isStarted)
                        throw d(new Error(r.NOT_STARTED_YET), e.DHT_NOT_STARTED); return u.put(i, o, h); }, async get(i, o) { if (!t.isStarted() || !u.isStarted)
                        throw d(new Error(r.NOT_STARTED_YET), e.DHT_NOT_STARTED); return u.get(i, o); }, async getMany(i, o, h) { if (!t.isStarted() || !u.isStarted)
                        throw d(new Error(r.NOT_STARTED_YET), e.DHT_NOT_STARTED); return u.getMany(i, o, h); } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(24), { dnsaddrResolver: r } = f(858), e = f(196), { AGENT_VERSION: c } = f(335), { FaultTolerance: n } = f(336), t = { addresses: { listen: [], announce: [], noAnnounce: [] }, connectionManager: { minConnections: 25 }, transportManager: { faultTolerance: n.FATAL_ALL }, dialer: { maxParallelDials: e.MAX_PARALLEL_DIALS, maxDialsPerPeer: e.MAX_PER_PEER_DIALS, dialTimeout: e.DIAL_TIMEOUT, resolvers: { dnsaddr: r } }, host: { agentVersion: c }, metrics: { enabled: !1 }, peerStore: { persistence: !1, threshold: 5 }, config: { dht: { enabled: !1, kBucketSize: 20, randomWalk: { enabled: !1, queriesPerPeriod: 1, interval: 3e5, timeout: 1e4 } }, peerDiscovery: { autoDial: !0 }, pubsub: { enabled: !0, emitSelf: !0, signMessages: !0, strictSigning: !0 }, relay: { enabled: !0, hop: { enabled: !1, active: !1 } }, transport: {} } };
                E.exports.validate = s => { if ((s = d(t, s)).modules.transport.length < 1)
                    throw new Error("'options.modules.transport' must contain at least 1 transport"); return s; };
            }, function (E, m, f) {
                "use strict";
                f(13);
                const d = f(109), { code: r } = d("dnsaddr");
                E.exports = { dnsaddrResolver: async function (e) { const { Resolver: c } = f(859), n = new c, t = e.getPeerId(), [, s] = e.stringTuples().find(([i]) => i === r) || []; let u = (await n.resolveTxt("_dnsaddr." + s)).flat().map(i => i.split("=")[1]); return t && (u = u.filter(i => i.includes(t))), u; } };
            }, function (E, m, f) {
                "use strict";
                let d;
                try {
                    if (d = f(860).promises, !d)
                        throw new Error("no dns available");
                }
                catch (r) {
                    d = f(861);
                }
                E.exports = d;
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("dns-over-http-resolver");
                r.error = d("dns-over-http-resolver:error");
                const e = f(862), { buildResource: c, fetch: n, getCacheKey: t } = f(864);
                class s {
                    constructor({ maxCache: i = 100 } = {}) { this._cache = new e({ max: i }), this._servers = ["https://cloudflare-dns.com/dns-query", "https://dns.google/resolve"]; }
                    getServers() { return this._servers; }
                    _getShuffledServers() { const i = [].concat(this._servers); for (let o = i.length - 1; o > 0; o--) {
                        const h = Math.floor(Math.random() * o), a = i[o];
                        i[o] = i[h], i[h] = a;
                    } return i; }
                    setServers(i) { this._servers = i; }
                    resolve(i, o = "A") { switch (o) {
                        case "A": return this.resolve4(i);
                        case "AAAA": return this.resolve6(i);
                        case "TXT": return this.resolveTxt(i);
                        default: throw new Error(o + " is not supported");
                    } }
                    async resolve4(i) { const o = this._cache.get(t(i, "A")); if (o)
                        return o; for (const h of this._getShuffledServers())
                        try {
                            const a = await n(c({ serverResolver: h, hostname: i, recordType: "A" })), l = await a.json(), p = l.Answer.map(b => b.data), g = Math.min(l.Answer.map(b => b.TTL));
                            return this._cache.set(t(i, "A"), p, { ttl: g }), p;
                        }
                        catch (a) {
                            r.error(`${h} could not resolve ${i} record A`);
                        } throw new Error(`Could not resolve ${i} record A`); }
                    async resolve6(i) { const o = this._cache.get(t(i, "AAAA")); if (o)
                        return o; for (const h of this._getShuffledServers())
                        try {
                            const a = await n(c({ serverResolver: h, hostname: i, recordType: "AAAA" })), l = await a.json(), p = l.Answer.map(b => b.data), g = Math.min(l.Answer.map(b => b.TTL));
                            return this._cache.set(t(i, "AAAA"), p, { ttl: g }), p;
                        }
                        catch (a) {
                            r.error(`${h} could not resolve ${i} record AAAA`);
                        } throw new Error(`Could not resolve ${i} record AAAA`); }
                    async resolveTxt(i) { const o = this._cache.get(t(i, "TXT")); if (o)
                        return o; for (const h of this._getShuffledServers())
                        try {
                            const a = await n(c({ serverResolver: h, hostname: i, recordType: "TXT" })), l = await a.json(), p = l.Answer.map(b => [b.data.replace(/['"]+/g, "")]), g = Math.min(l.Answer.map(b => b.TTL));
                            return this._cache.set(t(i, "TXT"), p, { ttl: g }), p;
                        }
                        catch (a) {
                            r.error(`${h} could not resolve ${i} record TXT`);
                        } throw new Error(`Could not resolve ${i} record TXT`); }
                }
                s.Resolver = s, E.exports = s;
            }, function (E, m, f) {
                "use strict";
                E.exports = c;
                var d = f(863), r = c.prototype, e = new Date % 1e9;
                function c(n) { n = n || {}, this.id = n.id || (1e9 * Math.random() >>> 0) + e++, this.max = n.max || 1 / 0, this.items = n.items || [], this._lookup = {}, this.size = this.items.length, this.lastModified = new Date(n.lastModified || new Date); for (var t, s, u = this.items.length; u--;)
                    t = this.items[u], s = new Date(t.expires) - new Date, this._lookup[t.key] = t, s > 0 ? this.expire(t.key, s) : s <= 0 && this.delete(t.key); }
                r.has = function (n) { return n in this._lookup; }, r.get = function (n) { if (!this.has(n))
                    return null; var t = this._lookup[n]; return t.refresh && this.expire(n, t.refresh), this.items.splice(this.items.indexOf(t), 1), this.items.push(t), t.value; }, r.meta = function (n) { if (!this.has(n))
                    return null; var t = this._lookup[n]; return "meta" in t ? t.meta : null; }, r.set = function (n, t, s) { var u = this._lookup[n], i = this._lookup[n] = { key: n, value: t }; return this.lastModified = new Date, u ? (clearTimeout(u.timeout), this.items.splice(this.items.indexOf(u), 1, i)) : (this.size >= this.max && this.delete(this.items[0].key), this.items.push(i), this.size++), s && ("ttl" in s && this.expire(n, s.ttl), "meta" in s && (i.meta = s.meta), s.refresh && (i.refresh = s.ttl)), this; }, r.delete = function (n) { var t = this._lookup[n]; return !!t && (this.lastModified = new Date, this.items.splice(this.items.indexOf(t), 1), clearTimeout(t.timeout), delete this._lookup[n], this.size--, this); }, r.expire = function (n, t) { var s = t || 0, u = this._lookup[n]; if (!u)
                    return this; if (typeof s == "string" && (s = d(t)), typeof s != "number")
                    throw new TypeError("Expiration time must be a string or number."); return clearTimeout(u.timeout), u.timeout = setTimeout(this.delete.bind(this, u.key), s), u.expires = Number(new Date) + s, this; }, r.clear = function () { for (var n = this.items.length; n--;)
                    this.delete(this.items[n].key); return this; }, r.toJSON = function () { for (var n, t = new Array(this.items.length), s = t.length; s--;)
                    n = this.items[s], t[s] = { key: n.key, meta: n.meta, value: n.value, expires: n.expires, refresh: n.refresh }; return { id: this.id, max: isFinite(this.max) ? this.max : void 0, lastModified: this.lastModified, items: t }; };
            }, function (E, m, f) {
                "use strict";
                var d = 1e3, r = 6e4, e = 60 * r, c = 24 * e;
                function n(t, s, u, i) { var o = s >= 1.5 * u; return Math.round(t / u) + " " + i + (o ? "s" : ""); }
                E.exports = function (t, s) { s = s || {}; var u = typeof t; if (u === "string" && t.length > 0)
                    return function (i) { if ((i = String(i)).length > 100)
                        return; var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i); if (!o)
                        return; var h = parseFloat(o[1]); switch ((o[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y": return 315576e5 * h;
                        case "weeks":
                        case "week":
                        case "w": return 6048e5 * h;
                        case "days":
                        case "day":
                        case "d": return h * c;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h": return h * e;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m": return h * r;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s": return h * d;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms": return h;
                        default: return;
                    } }(t); if (u === "number" && isFinite(t))
                    return s.long ? function (i) { var o = Math.abs(i); return o >= c ? n(i, o, c, "day") : o >= e ? n(i, o, e, "hour") : o >= r ? n(i, o, r, "minute") : o >= d ? n(i, o, d, "second") : i + " ms"; }(t) : function (i) { var o = Math.abs(i); return o >= c ? Math.round(i / c) + "d" : o >= e ? Math.round(i / e) + "h" : o >= r ? Math.round(i / r) + "m" : o >= d ? Math.round(i / d) + "s" : i + "ms"; }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); };
            }, function (E, m, f) {
                "use strict";
                const { default: d, Headers: r } = f(217);
                E.exports.buildResource = function ({ serverResolver: e, hostname: c, recordType: n }) { return `${e}?name=${c}&type=${n}`; }, E.exports.fetch = function (e) { return d(e, { headers: new r({ accept: "application/dns-json" }) }); }, E.exports.getCacheKey = function (e, c) { return `${c}_${e}`; };
            }, function (E) { E.exports = JSON.parse('{"name":"libp2p","version":"0.29.4","description":"JavaScript implementation of libp2p, a modular peer to peer network stack","leadMaintainer":"Jacob Heun <jacobheun@gmail.com>","main":"src/index.js","files":["dist","src"],"scripts":{"lint":"aegir lint","build":"aegir build","test":"npm run test:node && npm run test:browser","test:node":"aegir test -t node -f \\"./test/**/*.{node,spec}.js\\"","test:browser":"aegir test -t browser","release":"aegir release -t node -t browser","release-minor":"aegir release --type minor -t node -t browser","release-major":"aegir release --type major -t node -t browser","coverage":"nyc --reporter=text --reporter=lcov npm run test:node"},"repository":{"type":"git","url":"https://github.com/libp2p/js-libp2p.git"},"keywords":["libp2p","network","p2p","peer","peer-to-peer","IPFS"],"bugs":{"url":"https://github.com/libp2p/js-libp2p/issues"},"homepage":"https://libp2p.io","license":"MIT","engines":{"node":">=12.0.0","npm":">=6.0.0"},"dependencies":{"abort-controller":"^3.0.0","aggregate-error":"^3.0.1","any-signal":"^1.1.0","bignumber.js":"^9.0.0","class-is":"^1.1.0","debug":"^4.1.1","err-code":"^2.0.0","events":"^3.1.0","hashlru":"^2.3.0","interface-datastore":"^2.0.0","ipfs-utils":"^2.2.0","it-all":"^1.0.1","it-buffer":"^0.1.2","it-handshake":"^1.0.1","it-length-prefixed":"^3.0.1","it-pipe":"^1.1.0","it-protocol-buffers":"^0.2.0","libp2p-crypto":"^0.18.0","libp2p-interfaces":"^0.5.1","libp2p-utils":"^0.2.0","mafmt":"^8.0.0","merge-options":"^2.0.0","moving-average":"^1.0.0","multiaddr":"^8.1.0","multicodec":"^2.0.0","multistream-select":"^1.0.0","mutable-proxy":"^1.0.0","node-forge":"^0.9.1","p-any":"^3.0.0","p-fifo":"^1.0.0","p-settle":"^4.0.1","peer-id":"^0.14.2","protons":"^2.0.0","retimer":"^2.0.0","sanitize-filename":"^1.6.3","streaming-iterables":"^5.0.2","timeout-abort-controller":"^1.1.1","varint":"^5.0.0","xsalsa20":"^1.0.2"},"devDependencies":{"@nodeutils/defaults-deep":"^1.1.0","abortable-iterator":"^3.0.0","aegir":"^27.0.0","chai":"^4.2.0","chai-as-promised":"^7.1.1","chai-bytes":"^0.1.2","chai-string":"^1.5.0","cids":"^1.0.0","delay":"^4.3.0","dirty-chai":"^2.0.1","interop-libp2p":"^0.3.0","ipfs-http-client":"^47.0.1","it-concat":"^1.0.0","it-pair":"^1.0.0","it-pushable":"^1.4.0","libp2p":".","libp2p-bootstrap":"^0.12.0","libp2p-delegated-content-routing":"^0.7.0","libp2p-delegated-peer-routing":"^0.7.0","libp2p-floodsub":"^0.23.0","libp2p-gossipsub":"^0.6.0","libp2p-kad-dht":"^0.20.0","libp2p-mdns":"^0.15.0","libp2p-mplex":"^0.10.1","libp2p-noise":"^2.0.0","libp2p-secio":"^0.13.1","libp2p-tcp":"^0.15.1","libp2p-webrtc-star":"^0.20.0","libp2p-websockets":"^0.14.0","multihashes":"^3.0.1","nock":"^13.0.3","p-defer":"^3.0.0","p-times":"^3.0.0","p-wait-for":"^3.1.0","promisify-es6":"^1.0.3","rimraf":"^3.0.2","sinon":"^9.0.2","uint8arrays":"^1.1.0"},"contributors":["David Dias <daviddias.p@gmail.com>","Jacob Heun <jacobheun@gmail.com>","Vasco Santos <vasco.santos@moxy.studio>","Alan Shaw <alan@tableflip.io>","Alex Potsides <alex@achingbrain.net>","Cayman <caymannava@gmail.com>","Pedro Teixeira <i@pgte.me>","Friedel Ziegelmayer <dignifiedquire@gmail.com>","Maciej Kr\xFCger <mkg20001@gmail.com>","Hugo Dias <mail@hugodias.me>","dirkmc <dirkmdev@gmail.com>","Volker Mische <volker.mische@gmail.com>","Richard Littauer <richard.littauer@gmail.com>","a1300 <matthias-knopp@gmx.net>","Elven <mon.samuel@qq.com>","Andrew Nesbitt <andrewnez@gmail.com>","Giovanni T. Parra <fiatjaf@gmail.com>","Ryan Bell <ryan@piing.net>","Thomas Eizinger <thomas@eizinger.io>","\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>","Didrik Nordstr\xF6m <didrik@betamos.se>","Irakli Gozalishvili <rfobic@gmail.com>","Ethan Lam <elmemphis2000@gmail.com>","Joel Gustafson <joelg@mit.edu>","Julien Bouquillon <contact@revolunet.com>","Kevin Kwok <antimatter15@gmail.com>","Nuno Nogueira <nunofmn@gmail.com>","Dmitriy Ryajov <dryajov@gmail.com>","RasmusErik Voel Jensen <github@solsort.com>","Diogo Silva <fsdiogo@gmail.com>","Samlior <samlior@foxmail.com>","Smite Chow <xiaopengyou@live.com>","Soeren <nikorpoulsen@gmail.com>","S\xF6nke Hahn <soenkehahn@gmail.com>","robertkiel <robert.kiel@validitylabs.org>","Tiago Alves <alvesjtiago@gmail.com>","Daijiro Wachi <daijiro.wachi@gmail.com>","Yusef Napora <yusef@napora.org>","Zane Starr <zcstarr@gmail.com>","Cindy Wu <ciindy.wu@gmail.com>","Chris Bratlien <chrisbratlien@gmail.com>","ebinks <elizabethjbinks@gmail.com>","Bernd Strehl <bernd.strehl@gmail.com>","Florian-Merle <florian.david.merle@gmail.com>","Francis Gulotta <wizard@roborooter.com>","Felipe Martins <felipebrasil93@gmail.com>","isan_rivkin <isanrivkin@gmail.com>","Henrique Dias <hacdias@gmail.com>","Fei Liu <liu.feiwood@gmail.com>"]}'); }, function (E, m, f) {
                "use strict";
                const d = f(867), r = f(868);
                E.exports = async (e, c = {}) => { const { concurrency: n = 1 / 0 } = c, t = r(n); return Promise.all(e.map(s => s && typeof s.then == "function" ? d(s) : d(typeof s == "function" ? t(() => s()) : Promise.resolve(s)))); };
            }, function (E, m, f) {
                "use strict";
                const d = async (r) => { try {
                    return { isFulfilled: !0, isRejected: !1, value: await r };
                }
                catch (e) {
                    return { isFulfilled: !1, isRejected: !0, reason: e };
                } };
                E.exports = d, E.exports.default = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(869), r = e => { if (!Number.isInteger(e) && e !== 1 / 0 || !(e > 0))
                    return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up")); const c = []; let n = 0; const t = () => { n--, c.length > 0 && c.shift()(); }, s = (i, o, ...h) => { n++; const a = d(i, ...h); o(a), a.then(t, t); }, u = (i, ...o) => new Promise(h => ((a, l, ...p) => { n < e ? s(a, l, ...p) : c.push(s.bind(null, a, l, ...p)); })(i, h, ...o)); return Object.defineProperties(u, { activeCount: { get: () => n }, pendingCount: { get: () => c.length }, clearQueue: { value: () => { c.length = 0; } } }), u; };
                E.exports = r, E.exports.default = r;
            }, function (E, m, f) {
                "use strict";
                const d = (r, ...e) => new Promise(c => { c(r(...e)); });
                E.exports = d, E.exports.default = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(1);
                d("libp2p:addresses").error = d("libp2p:addresses:error");
                const r = f(13);
                E.exports = class {
                    constructor({ listen: e = [], announce: c = [], noAnnounce: n = [] } = {}) { this.listen = new Set(e), this.announce = new Set(c), this.noAnnounce = new Set(n); }
                    getListenAddrs() { return Array.from(this.listen).map(e => r(e)); }
                    getAnnounceAddrs() { return Array.from(this.announce).map(e => r(e)); }
                    getNoAnnounceAddrs() { return Array.from(this.noAnnounce).map(e => r(e)); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:connection-manager");
                r.error = d("libp2p:connection-manager:error");
                const e = f(0), c = f(24), n = f(872), t = f(152), { EventEmitter: s } = f(12), u = f(7), { ERR_INVALID_PARAMETERS: i } = f(28), o = { maxConnections: 1 / 0, minConnections: 0, maxData: 1 / 0, maxSentData: 1 / 0, maxReceivedData: 1 / 0, maxEventLoopDelay: 1 / 0, pollInterval: 2e3, autoDialInterval: 1e4, movingAverageInterval: 6e4, defaultPeerValue: 1 };
                function h(a, l) { return a[1] - l[1]; }
                E.exports = class extends s {
                    constructor(a, l) { if (super(), this._libp2p = a, this._peerId = a.peerId.toB58String(), this._options = c.call({ ignoreUndefined: !0 }, o, l), this._options.maxConnections < this._options.minConnections)
                        throw e(new Error("Connection Manager maxConnections must be greater than minConnections"), i); r("options: %j", this._options), this._libp2p = a, this._peerValues = new Map, this.connections = new Map, this._started = !1, this._timer = null, this._autoDialTimeout = null, this._checkMetrics = this._checkMetrics.bind(this), this._autoDial = this._autoDial.bind(this); }
                    get size() { return Array.from(this.connections.values()).reduce((a, l) => a + l.length, 0); }
                    start() { this._libp2p.metrics && (this._timer = this._timer || t(this._checkMetrics, this._options.pollInterval)), this._latencyMonitor = new n({ latencyCheckIntervalMs: this._options.pollInterval, dataEmitIntervalMs: this._options.pollInterval }), this._onLatencyMeasure = this._onLatencyMeasure.bind(this), this._latencyMonitor.on("data", this._onLatencyMeasure), this._started = !0, r("started"), this._options.autoDial && this._autoDial(); }
                    async stop() { this._autoDialTimeout && this._autoDialTimeout.clear(), this._timer && this._timer.clear(), this._latencyMonitor && this._latencyMonitor.removeListener("data", this._onLatencyMeasure), this._started = !1, await this._close(), r("stopped"); }
                    async _close() { const a = []; for (const l of this.connections.values())
                        for (const p of l)
                            a.push(p.close()); await a, this.connections.clear(); }
                    setPeerValue(a, l) { if (l < 0 || l > 1)
                        throw new Error("value should be a number between 0 and 1"); a.toB58String && (a = a.toB58String()), this._peerValues.set(a, l); }
                    _checkMetrics() { const a = this._libp2p.metrics.global.movingAverages, l = a.dataReceived[this._options.movingAverageInterval].movingAverage(); this._checkMaxLimit("maxReceivedData", l); const p = a.dataSent[this._options.movingAverageInterval].movingAverage(); this._checkMaxLimit("maxSentData", p); const g = l + p; this._checkMaxLimit("maxData", g), r("metrics update", g), this._timer = t(this._checkMetrics, this._options.pollInterval); }
                    onConnect(a) { const l = a.remotePeer, p = l.toB58String(), g = this.connections.get(p); this.emit("peer:connect", a), g ? g.push(a) : this.connections.set(p, [a]), this._libp2p.peerStore.keyBook.set(l, l.pubKey), this._peerValues.has(p) || this._peerValues.set(p, this._options.defaultPeerValue), this._checkMaxLimit("maxConnections", this.size); }
                    onDisconnect(a) { const l = a.remotePeer.toB58String(); let p = this.connections.get(l); p && p.length > 1 ? (p = p.filter(g => g.id !== a.id), this.connections.set(l, p)) : p && (this.connections.delete(l), this._peerValues.delete(a.remotePeer.toB58String()), this.emit("peer:disconnect", a)); }
                    get(a) { const l = this.getAll(a); return l.length ? l[0] : null; }
                    getAll(a) { if (!u.isPeerId(a))
                        throw e(new Error("peerId must be an instance of peer-id"), i); const l = a.toB58String(), p = this.connections.get(l); return p ? p.filter(g => g.stat.status === "open") : []; }
                    _onLatencyMeasure(a) { this._checkMaxLimit("maxEventLoopDelay", a.avgMs); }
                    _checkMaxLimit(a, l) { const p = this._options[a]; r("checking limit of %s. current value: %d of %d", a, l, p), l > p && (r("%s: limit exceeded: %s, %d", this._peerId, a, l), this._maybeDisconnectOne()); }
                    async _autoDial() { const a = this._options.minConnections; if (this.size >= a)
                        return void (this._autoDialTimeout = t(this._autoDial, this._options.autoDialInterval)); const l = Array.from(this._libp2p.peerStore.peers.values()).sort((p, g) => !g.protocols || !g.protocols.length || p.protocols && p.protocols.length ? g.id.pubKey && !p.id.pubKey ? 1 : -1 : 1); for (let p = 0; p < l.length && this.size < a; p++)
                        if (!this.get(l[p].id)) {
                            r("connecting to a peerStore stored peer %s", l[p].id.toB58String());
                            try {
                                if (await this._libp2p.dialer.connectToPeer(l[p].id), !this._started)
                                    return;
                            }
                            catch (g) {
                                r.error("could not connect to peerStore stored peer", g);
                            }
                        } this._autoDialTimeout = t(this._autoDial, this._options.autoDialInterval); }
                    _maybeDisconnectOne() { if (this._options.minConnections < this.connections.size) {
                        const a = Array.from(this._peerValues).sort(h);
                        r("%s: sorted peer values: %j", this._peerId, a);
                        const l = a[0];
                        if (l) {
                            const p = l[0];
                            r("%s: lowest value peer is %s", this._peerId, p), r("%s: closing a connection to %j", this._peerId, p);
                            for (const g of this.connections.values())
                                if (g[0].remotePeer.toB58String() === p) {
                                    g[0].close();
                                    break;
                                }
                        }
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(194), r = f(12), e = f(873), c = f(1)("latency-monitor:LatencyMonitor");
                E.exports = class extends r {
                    constructor({ latencyCheckIntervalMs: n, dataEmitIntervalMs: t, asyncTestFn: s, latencyRandomPercentage: u } = {}) { super(); const i = this; i.latencyCheckIntervalMs = n || 500, i.latencyRandomPercentage = u || 10, i._latecyCheckMultiply = i.latencyRandomPercentage / 100 * 2 * i.latencyCheckIntervalMs, i._latecyCheckSubtract = i._latecyCheckMultiply / 2, i.dataEmitIntervalMs = t === null || t === 0 ? void 0 : t || 5e3, c("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", i.latencyCheckIntervalMs, i.dataEmitIntervalMs), i.dataEmitIntervalMs ? c("Expecting ~%s events per summary", i.latencyCheckIntervalMs / i.dataEmitIntervalMs) : c("Not emitting summaries"), i.asyncTestFn = s, d.process && d.process.hrtime ? (c("Using process.hrtime for timing"), i.now = d.process.hrtime, i.getDeltaMS = o => { const h = i.now(o); return 1e3 * h[0] + h[1] / 1e6; }) : typeof window != "undefined" && window.performance && window.performance.now ? (c("Using performance.now for timing"), i.now = window.performance.now.bind(window.performance), i.getDeltaMS = o => Math.round(i.now() - o)) : (c("Using Date.now for timing"), i.now = Date.now, i.getDeltaMS = o => i.now() - o), i._latencyData = i._initLatencyData(), typeof window != "undefined" && (i._visibilityChangeEmitter = new e, i._visibilityChangeEmitter.on("visibilityChange", o => { o ? i._startTimers() : (i._emitSummary(), i._stopTimers()); })), i._visibilityChangeEmitter && !i._visibilityChangeEmitter.isVisible() || i._startTimers(); }
                    _startTimers() { this._checkLatencyID || (this._checkLatency(), this.dataEmitIntervalMs && (this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs), typeof this._emitIntervalID.unref == "function" && this._emitIntervalID.unref())); }
                    _stopTimers() { this._checkLatencyID && (clearTimeout(this._checkLatencyID), this._checkLatencyID = void 0), this._emitIntervalID && (clearInterval(this._emitIntervalID), this._emitIntervalID = void 0); }
                    _emitSummary() { const n = this.getSummary(); n.events > 0 && this.emit("data", n); }
                    getSummary() { const n = { events: this._latencyData.events, minMs: this._latencyData.minMs, maxMs: this._latencyData.maxMs, avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY, lengthMs: this.getDeltaMS(this._latencyData.startTime) }; return this._latencyData = this._initLatencyData(), c("Summary: %O", n), n; }
                    _checkLatency() { const n = this, t = Math.random() * n._latecyCheckMultiply - n._latecyCheckSubtract, s = { deltaOffset: Math.ceil(n.latencyCheckIntervalMs + t), startTime: n.now() }, u = () => { if (!this._checkLatencyID)
                        return; const i = n.getDeltaMS(s.startTime) - s.deltaOffset; n._checkLatency(), n._latencyData.events++, n._latencyData.minMs = Math.min(n._latencyData.minMs, i), n._latencyData.maxMs = Math.max(n._latencyData.maxMs, i), n._latencyData.totalMs += i, c("MS: %s Data: %O", i, n._latencyData); }; c("localData: %O", s), this._checkLatencyID = setTimeout(() => { n.asyncTestFn ? (s.deltaOffset = 0, s.startTime = n.now(), n.asyncTestFn(u)) : (s.deltaOffset -= 1, u()); }, s.deltaOffset), typeof this._checkLatencyID.unref == "function" && this._checkLatencyID.unref(); }
                    _initLatencyData() { return { startTime: this.now(), minMs: Number.POSITIVE_INFINITY, maxMs: Number.NEGATIVE_INFINITY, events: 0, totalMs: 0 }; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(1)("latency-monitor:VisibilityChangeEmitter");
                E.exports = class extends d {
                    constructor() { super(), typeof document != "undefined" ? (this._initializeVisibilityVarNames(), this._addVisibilityChangeListener()) : r('This is not a browser, no "document" found. Stopping.'); }
                    _initializeVisibilityVarNames() { let e, c; document.hidden !== void 0 ? (e = "hidden", c = "visibilitychange") : document.mozHidden !== void 0 ? (e = "mozHidden", c = "mozvisibilitychange") : document.msHidden !== void 0 ? (e = "msHidden", c = "msvisibilitychange") : document.webkitHidden !== void 0 && (e = "webkitHidden", c = "webkitvisibilitychange"), this._hidden = e, this._visibilityChange = c; }
                    _addVisibilityChangeListener() { document.addEventListener === void 0 || document[this._hidden] === void 0 ? r("Checking page visibility requires a browser that supports the Page Visibility API.") : document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), !1); }
                    isVisible() { if (this._hidden !== void 0 && document[this._hidden] !== void 0)
                        return !document[this._hidden]; }
                    _handleVisibilityChange() { const e = !document[this._hidden]; r(e ? "Page Visible" : "Page Hidden"), this.emit("visibilityChange", e); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(60), r = f(13), e = f(7), c = f(26), { CircuitRelay: n } = f(98), t = f(1), s = t("libp2p:circuit");
                s.error = t("libp2p:circuit:error");
                const u = f(875), { relay: i } = f(197), o = f(876), { handleCanHop: h, handleHop: a, hop: l } = f(877), { handleStop: p } = f(339), g = f(198);
                E.exports = c(class {
                    constructor({ libp2p: b, upgrader: I }) { this._dialer = b.dialer, this._registrar = b.registrar, this._connectionManager = b.connectionManager, this._upgrader = I, this._options = b._config.relay, this._libp2p = b, this.peerId = b.peerId, this._registrar.handle(i, this._onProtocol.bind(this)); }
                    async _onProtocol({ connection: b, stream: I, protocol: v }) { const R = new g({ stream: I }), _ = await R.read(), k = this; let x; switch (_.type) {
                        case n.Type.CAN_HOP:
                            s("received CAN_HOP request from %s", b.remotePeer.toB58String()), await h({ circuit: k, connection: b, streamHandler: R });
                            break;
                        case n.Type.HOP:
                            s("received HOP request from %s", b.remotePeer.toB58String()), x = await a({ connection: b, request: _, streamHandler: R, circuit: k });
                            break;
                        case n.Type.STOP:
                            s("received STOP request from %s", b.remotePeer.toB58String()), x = await p({ connection: b, request: _, streamHandler: R, circuit: k });
                            break;
                        default: s("Request of type %s not supported", _.type);
                    } if (x) {
                        const M = r(_.dstPeer.addrs[0]), N = r(_.srcPeer.addrs[0]), S = u({ stream: x, remoteAddr: M, localAddr: N }), T = n.Type === n.Type.HOP ? "relay" : "inbound";
                        s("new %s connection %s", T, S.remoteAddr);
                        const B = await this._upgrader.upgradeInbound(S);
                        s("%s connection %s upgraded", T, S.remoteAddr), this.handler && this.handler(B);
                    } }
                    async dial(b, I) { const v = b.toString().split("/p2p-circuit"), R = r(v[0]), _ = r(v[v.length - 1]), k = e.createFromCID(R.getPeerId()), x = e.createFromCID(_.getPeerId()); let M = !1, N = this._connectionManager.get(k); N || (N = await this._dialer.connectToPeer(R, I), M = !0); try {
                        const S = await l({ connection: N, circuit: this, request: { type: n.Type.HOP, srcPeer: { id: this.peerId.toBytes(), addrs: this._libp2p.multiaddrs.map(P => P.bytes) }, dstPeer: { id: x.toBytes(), addrs: [r(_).bytes] } } }), T = R.encapsulate("/p2p-circuit/p2p/" + this.peerId.toB58String()), B = u({ stream: S, remoteAddr: b, localAddr: T });
                        return s("new outbound connection %s", B.remoteAddr), this._upgrader.upgradeOutbound(B);
                    }
                    catch (S) {
                        throw s.error("Circuit relay dial failed", S), M && await N.close(), S;
                    } }
                    createListener(b, I) { return typeof b == "function" && (I = b, b = {}), this.handler = I, o(this, b); }
                    filter(b) { return (b = Array.isArray(b) ? b : [b]).filter(I => d.Circuit.matches(I)); }
                }, { className: "Circuit", symbolName: "@libp2p/js-libp2p-circuit/circuit" });
            }, function (E, m, f) {
                "use strict";
                const d = f(45), r = f(1)("libp2p:stream:converter");
                E.exports = function ({ stream: e, remoteAddr: c, localAddr: n }, t = {}) { const { sink: s, source: u } = e, i = { async sink(h) { t.signal && (h = d(h, t.signal)); try {
                        await s(h);
                    }
                    catch (a) {
                        a.type !== "aborted" && r(a);
                    } o(); }, source: t.signal ? d(u, t.signal) : u, conn: e, localAddr: n, remoteAddr: c, timeline: { open: Date.now() }, close() { s([]), o(); } }; function o() { i.timeline.close || (i.timeline.close = Date.now()); } return i; };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(13), e = f(1);
                e("libp2p:circuit:listener").err = e("libp2p:circuit:error:listener"), E.exports = c => { const n = new d, t = new Map; return n.listen = async (s) => { const u = String(s).split("/p2p-circuit").find(h => h !== ""), i = await c._dialer.connectToPeer(r(u)), o = i.remoteAddr.encapsulate("/p2p-circuit"); t.set(i.remotePeer.toB58String(), o), n.emit("listening"); }, n.close = () => { }, n.getAddrs = () => { const s = []; for (const u of t.values())
                    s.push(u); return s; }, n; };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:circuit:hop");
                r.error = d("libp2p:circuit:hop:error");
                const e = f(7), { validateAddrs: c } = f(337), n = f(198), { CircuitRelay: t } = f(98), s = f(27), u = f(0), { codes: i } = f(28), { stop: o } = f(339), h = f(197);
                E.exports.handleHop = async function ({ connection: a, request: l, streamHandler: p, circuit: g }) { if (!g._options.hop.enabled)
                    return r("HOP request received but we are not acting as a relay"), p.end({ type: t.Type.STATUS, code: t.Status.HOP_CANT_SPEAK_RELAY }); try {
                    c(l, p);
                }
                catch (k) {
                    return r.error("invalid hop request via peer %s", a.remotePeer.toB58String(), k);
                } const b = new e(l.dstPeer.id), I = g._connectionManager.get(b); if (!I && !g._options.hop.active)
                    return r("HOP request received but we are not connected to the destination peer"), p.end({ type: t.Type.STATUS, code: t.Status.HOP_NO_CONN_TO_DST }); const v = { type: t.Type.STOP, dstPeer: l.dstPeer, srcPeer: l.srcPeer }; let R; try {
                    R = await o({ connection: I, request: v, circuit: g });
                }
                catch (k) {
                    return r.error(k);
                } r("hop request from %s is valid", a.remotePeer.toB58String()), p.write({ type: t.Type.STATUS, code: t.Status.SUCCESS }); const _ = p.rest(); return s(_, R, _); }, E.exports.hop = async function ({ connection: a, request: l }) { const { stream: p } = await a.newStream([h.relay]), g = new n({ stream: p }); g.write(l); const b = await g.read(); if (b.code === t.Status.SUCCESS)
                    return r("hop request was successful"), g.rest(); throw r("hop request failed with code %d, closing stream", b.code), g.close(), u(new Error("HOP request failed with code " + b.code), i.ERR_HOP_REQUEST_FAILED); }, E.exports.handleCanHop = function ({ connection: a, streamHandler: l, circuit: p }) { const g = p._options.hop.enabled; r("can hop (%s) request from %s", g, a.remotePeer.toB58String()), l.end({ type: t.Type.STATUS, code: g ? t.Status.SUCCESS : t.Status.HOP_CANT_SPEAK_RELAY }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(13), r = f(0), e = f(249), c = f(340), n = f(1), t = n("libp2p:dialer");
                t.error = n("libp2p:dialer:error");
                const { DialRequest: s } = f(880), u = f(334), { codes: i } = f(28), { DIAL_TIMEOUT: o, MAX_PARALLEL_DIALS: h, MAX_PER_PEER_DIALS: a } = f(196);
                E.exports = class {
                    constructor({ transportManager: l, peerStore: p, concurrency: g = h, timeout: b = o, perPeerLimit: I = a, resolvers: v = {} }) { this.transportManager = l, this.peerStore = p, this.concurrency = g, this.timeout = b, this.perPeerLimit = I, this.tokens = [...new Array(g)].map((R, _) => _), this._pendingDials = new Map; for (const [R, _] of Object.entries(v))
                        d.resolvers.set(R, _); }
                    destroy() { for (const l of this._pendingDials.values())
                        try {
                            l.controller.abort();
                        }
                        catch (p) {
                            t.error(p);
                        } this._pendingDials.clear(); }
                    async connectToPeer(l, p = {}) { const g = await this._createDialTarget(l); if (!g.addrs.length)
                        throw r(new Error("The dial request has no addresses"), i.ERR_NO_VALID_ADDRESSES); const b = this._pendingDials.get(g.id) || this._createPendingDial(g, p); try {
                        const I = await b.promise;
                        return t("dial succeeded to %s", g.id), I;
                    }
                    catch (I) {
                        throw b.controller.signal.aborted && (I.code = i.ERR_TIMEOUT), t.error(I), I;
                    }
                    finally {
                        b.destroy();
                    } }
                    async _createDialTarget(l) { const { id: p, multiaddrs: g } = u(l); g && this.peerStore.addressBook.add(p, g); let b = this.peerStore.addressBook.getMultiaddrsForPeer(p) || []; d.isMultiaddr(l) && (b = b.filter(v => !l.equals(v)), b.unshift(l)); const I = []; for (const v of b)
                        (await this._resolve(v)).forEach(R => I.push(R)); return { id: p.toB58String(), addrs: I }; }
                    _createPendingDial(l, p) { const g = new s({ addrs: l.addrs, dialAction: (_, k) => { if (k.signal.aborted)
                            throw r(new Error("already aborted"), i.ERR_ALREADY_ABORTED); return this.transportManager.dial(_, k); }, dialer: this }), b = new e(this.timeout), I = [b.signal]; p.signal && I.push(p.signal); const v = c(I), R = { dialRequest: g, controller: b, promise: g.run({ ...p, signal: v }), destroy: () => { b.clear(), this._pendingDials.delete(l.id); } }; return this._pendingDials.set(l.id, R), R; }
                    getTokens(l) { const p = Math.min(l, this.perPeerLimit, this.tokens.length), g = this.tokens.splice(0, p); return t("%d tokens request, returning %d, %d remaining", l, p, this.tokens.length), g; }
                    releaseToken(l) { this.tokens.indexOf(l) > -1 || (t("token %d released", l), this.tokens.push(l)); }
                    async _resolve(l) { if (!l.protoNames().includes("dnsaddr"))
                        return [l]; const p = await this._resolveRecord(l); return (await Promise.all(p.map(g => this._resolve(g)))).flat().reduce((g, b) => (g.find(I => I.equals(b)) || g.push(b), g), []); }
                    async _resolveRecord(l) { try {
                        return l = d(l.toString()), await l.resolve();
                    }
                    catch (p) {
                        return t.error(`multiaddr ${l} could not be resolved`), [];
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = AbortController;
            }, function (E, m, f) {
                "use strict";
                const d = f(47), r = f(340), e = f(1), c = f(0);
                e("libp2p:dialer:request").error = e("libp2p:dialer:request:error");
                const n = f(881), t = f(195);
                E.exports.DialRequest = class {
                    constructor({ addrs: s, dialAction: u, dialer: i }) { this.addrs = s, this.dialer = i, this.dialAction = u; }
                    async run(s) { const u = this.dialer.getTokens(this.addrs.length); if (u.length < 1)
                        throw c(new Error("No dial tokens available"), "ERR_NO_DIAL_TOKENS"); const i = new n; u.forEach(a => i.push(a)); const o = this.addrs.map(() => new d); let h = 0; try {
                        return await t(this.addrs.map(async (a, l) => { const p = await i.shift(); let g; try {
                            const b = o[l].signal;
                            g = await this.dialAction(a, { ...s, signal: r([b, s.signal]) }), o.splice(l, 1);
                        }
                        finally {
                            h++, this.addrs.length - h >= u.length ? i.push(p) : this.dialer.releaseToken(u.splice(u.indexOf(p), 1)[0]);
                        } return g; }));
                    }
                    finally {
                        o.map(a => a.abort()), u.forEach(a => this.dialer.releaseToken(a));
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(302), r = f(199);
                E.exports = class {
                    constructor() { this._buffer = new d, this._waitingConsumers = new d; }
                    push(e) { const { promise: c, resolve: n } = r(); return this._buffer.push({ chunk: e, resolve: n }), this._consume(), c; }
                    _consume() { for (; !this._waitingConsumers.isEmpty() && !this._buffer.isEmpty();) {
                        const e = this._waitingConsumers.shift(), c = this._buffer.shift();
                        e.resolve(c.chunk), c.resolve();
                    } }
                    shift() { const { promise: e, resolve: c } = r(); return this._waitingConsumers.push({ resolve: c }), this._consume(), e; }
                    isEmpty() { return this._buffer.isEmpty(); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(883), r = f(24), e = f(39), c = f(11), n = f(887), t = f(0), { Number: s } = f(194), u = f(5), i = f(6);
                f(146);
                const o = 14, h = 16, a = 1e3, l = { dek: { keyLength: 64, iterationCount: 1e4, salt: "you should override this value with a crypto secure random number", hash: "sha2-512" } };
                function p(v) { return !!v && typeof v == "string" && v === d(v.trim()); }
                async function g(v) { const R = 800 * Math.random() + 200; throw await new Promise(_ => setTimeout(_, R)), v; }
                function b(v) { return new c.Key("/pkcs8/" + v); }
                function I(v) { return new c.Key("/info/" + v); }
                E.exports = class {
                    constructor(v, R) { if (!v)
                        throw new Error("store is required"); if (this.store = v, this.opts = r(l, R), this.opts.passPhrase && this.opts.passPhrase.length < 20)
                        throw new Error("passPhrase must be least 20 characters"); if (this.opts.dek.keyLength < o)
                        throw new Error(`dek.keyLength must be least ${o} bytes`); if (this.opts.dek.salt.length < h)
                        throw new Error(`dek.saltLength must be least ${h} bytes`); if (this.opts.dek.iterationCount < a)
                        throw new Error("dek.iterationCount must be least " + a); const _ = this.opts.passPhrase ? e.pbkdf2(this.opts.passPhrase, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : ""; Object.defineProperty(this, "_", { value: () => _ }); }
                    get cms() { return new n(this); }
                    static generateOptions() { const v = Object.assign({}, l), R = 3 * Math.ceil(h / 3); return v.dek.salt = u(e.randomBytes(R), "base64"), v; }
                    static get options() { return l; }
                    async createKey(v, R, _) { const k = this; if (!p(v) || v === "self")
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); if (typeof R != "string")
                        return g(t(new Error(`Invalid key type '${R}'`), "ERR_INVALID_KEY_TYPE")); const x = b(v); if (await k.store.has(x))
                        return g(t(new Error(`Key '${v}' already exists`), "ERR_KEY_ALREADY_EXISTS")); switch (R.toLowerCase()) {
                        case "rsa": if (!s.isSafeInteger(_) || _ < 2048)
                            return g(t(new Error("Invalid RSA key size " + _), "ERR_INVALID_KEY_SIZE"));
                    } let M; try {
                        const N = await e.keys.generateKeyPair(R, _), S = await N.id(), T = await N.export(this._());
                        M = { name: v, id: S };
                        const B = k.store.batch();
                        B.put(x, i(T)), B.put(I(v), i(JSON.stringify(M))), await B.commit();
                    }
                    catch (N) {
                        return g(N);
                    } return M; }
                    async listKeys() { const v = this, R = { prefix: "/info/" }, _ = []; for await (const k of v.store.query(R))
                        _.push(JSON.parse(u(k.value))); return _; }
                    async findKeyById(v) { try {
                        return (await this.listKeys()).find(R => R.id === v);
                    }
                    catch (R) {
                        return g(R);
                    } }
                    async findKeyByName(v) { if (!p(v))
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); const R = I(v); try {
                        const _ = await this.store.get(R);
                        return JSON.parse(u(_));
                    }
                    catch (_) {
                        return g(t(new Error(`Key '${v}' does not exist. ${_.message}`), "ERR_KEY_NOT_FOUND"));
                    } }
                    async removeKey(v) { if (!p(v) || v === "self")
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); const R = b(v), _ = await this.findKeyByName(v), k = this.store.batch(); return k.delete(R), k.delete(I(v)), await k.commit(), _; }
                    async renameKey(v, R) { const _ = this; if (!p(v) || v === "self")
                        return g(t(new Error(`Invalid old key name '${v}'`), "ERR_OLD_KEY_NAME_INVALID")); if (!p(R) || R === "self")
                        return g(t(new Error(`Invalid new key name '${R}'`), "ERR_NEW_KEY_NAME_INVALID")); const k = b(v), x = b(R), M = I(v), N = I(R); if (await _.store.has(x))
                        return g(t(new Error(`Key '${R}' already exists`), "ERR_KEY_ALREADY_EXISTS")); try {
                        const S = await _.store.get(k), T = await _.store.get(M), B = JSON.parse(u(T));
                        B.name = R;
                        const P = _.store.batch();
                        return P.put(x, S), P.put(N, i(JSON.stringify(B))), P.delete(k), P.delete(M), await P.commit(), B;
                    }
                    catch (S) {
                        return g(S);
                    } }
                    async exportKey(v, R) { if (!p(v))
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); if (!R)
                        return g(t(new Error("Password is required"), "ERR_PASSWORD_REQUIRED")); const _ = b(v); try {
                        const k = await this.store.get(_), x = u(k);
                        return (await e.keys.import(x, this._())).export(R);
                    }
                    catch (k) {
                        return g(k);
                    } }
                    async importKey(v, R, _) { if (!p(v) || v === "self")
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); if (!R)
                        return g(t(new Error("PEM encoded key is required"), "ERR_PEM_REQUIRED")); const k = b(v); if (await this.store.has(k))
                        return g(t(new Error(`Key '${v}' already exists`), "ERR_KEY_ALREADY_EXISTS")); let x, M; try {
                        x = await e.keys.import(R, _);
                    }
                    catch (T) {
                        return g(t(new Error("Cannot read the key, most likely the password is wrong"), "ERR_CANNOT_READ_KEY"));
                    } try {
                        M = await x.id(), R = await x.export(this._());
                    }
                    catch (T) {
                        return g(T);
                    } const N = { name: v, id: M }, S = this.store.batch(); return S.put(k, i(R)), S.put(I(v), i(JSON.stringify(N))), await S.commit(), N; }
                    async importPeer(v, R) { const _ = this; if (!p(v))
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); if (!R || !R.privKey)
                        return g(t(new Error("Peer.privKey is required"), "ERR_MISSING_PRIVATE_KEY")); const k = R.privKey, x = b(v); if (await _.store.has(x))
                        return g(t(new Error(`Key '${v}' already exists`), "ERR_KEY_ALREADY_EXISTS")); try {
                        const M = await k.id(), N = await k.export(this._()), S = { name: v, id: M }, T = _.store.batch();
                        return T.put(x, i(N)), T.put(I(v), i(JSON.stringify(S))), await T.commit(), S;
                    }
                    catch (M) {
                        return g(M);
                    } }
                    async _getPrivateKey(v) { if (!p(v))
                        return g(t(new Error(`Invalid key name '${v}'`), "ERR_INVALID_KEY_NAME")); try {
                        const R = b(v), _ = await this.store.get(R);
                        return u(_);
                    }
                    catch (R) {
                        return g(t(new Error(`Key '${v}' does not exist. ${R.message}`), "ERR_KEY_NOT_FOUND"));
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                var d = f(884), r = /[\/\?<>\\:\*\|"]/g, e = /[\x00-\x1f\x80-\x9f]/g, c = /^\.+$/, n = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i, t = /[\. ]+$/;
                function s(u, i) { if (typeof u != "string")
                    throw new Error("Input must be string"); var o = u.replace(r, i).replace(e, i).replace(c, i).replace(n, i).replace(t, i); return d(o, 255); }
                E.exports = function (u, i) { var o = i && i.replacement || "", h = s(u, o); return o === "" ? h : s(h, ""); };
            }, function (E, m, f) {
                "use strict";
                var d = f(885), r = f(886);
                E.exports = d.bind(null, r);
            }, function (E, m, f) {
                "use strict";
                function d(e) { return e >= 55296 && e <= 56319; }
                function r(e) { return e >= 56320 && e <= 57343; }
                E.exports = function (e, c, n) { if (typeof c != "string")
                    throw new Error("Input must be string"); for (var t, s, u = c.length, i = 0, o = 0; o < u; o += 1) {
                    if (t = c.charCodeAt(o), s = c[o], d(t) && r(c.charCodeAt(o + 1)) && (s += c[o += 1]), (i += e(s)) === n)
                        return c.slice(0, o + 1);
                    if (i > n)
                        return c.slice(0, o - s.length + 1);
                } return c; };
            }, function (E, m, f) {
                "use strict";
                function d(e) { return e >= 55296 && e <= 56319; }
                function r(e) { return e >= 56320 && e <= 57343; }
                E.exports = function (e) { if (typeof e != "string")
                    throw new Error("Input must be string"); for (var c = e.length, n = 0, t = null, s = null, u = 0; u < c; u++)
                    r(t = e.charCodeAt(u)) ? s != null && d(s) ? n += 1 : n += 3 : t <= 127 ? n += 1 : t >= 128 && t <= 2047 ? n += 2 : t >= 2048 && t <= 65535 && (n += 3), s = t; return n; };
            }, function (E, m, f) {
                "use strict";
                f(888), f(227);
                const d = f(8), { certificateForKey: r, findAsync: e } = f(893), c = f(0), n = f(6), t = f(5);
                E.exports = class {
                    constructor(s) { if (!s)
                        throw c(new Error("keychain is required"), "ERR_KEYCHAIN_REQUIRED"); this.keychain = s; }
                    async encrypt(s, u) { if (!(u instanceof Uint8Array))
                        throw c(new Error("Plain data must be a Uint8Array"), "ERR_INVALID_PARAMS"); const i = await this.keychain.findKeyByName(s), o = await this.keychain._getPrivateKey(s), h = d.pki.decryptRsaPrivateKey(o, this.keychain._()), a = await r(i, h), l = d.pkcs7.createEnvelopedData(); l.addRecipient(a), l.content = d.util.createBuffer(u), l.encrypt(); const p = d.asn1.toDer(l.toAsn1()).getBytes(); return n(p, "ascii"); }
                    async decrypt(s) { if (!(s instanceof Uint8Array))
                        throw c(new Error("CMS data is required"), "ERR_INVALID_PARAMS"); let u; try {
                        const p = d.util.createBuffer(t(s, "ascii")), g = d.asn1.fromDer(p);
                        u = d.pkcs7.messageFromAsn1(g);
                    }
                    catch (p) {
                        throw c(new Error("Invalid CMS: " + p.message), "ERR_INVALID_CMS");
                    } const i = u.recipients.filter(p => p.issuer.find(g => g.shortName === "O" && g.value === "ipfs")).filter(p => p.issuer.find(g => g.shortName === "CN")).map(p => ({ recipient: p, keyId: p.issuer.find(g => g.shortName === "CN").value })), o = await e(i, async (p) => { try {
                        if (await this.keychain.findKeyById(p.keyId))
                            return !0;
                    }
                    catch (g) {
                        return !1;
                    } return !1; }); if (!o) {
                        const p = i.map(g => g.keyId);
                        throw c(new Error("Decryption needs one of the key(s): " + p.join(", ")), "ERR_MISSING_KEYS", { missingKeys: p });
                    } const h = await this.keychain.findKeyById(o.keyId), a = await this.keychain._getPrivateKey(h.name), l = d.pki.decryptRsaPrivateKey(a, this.keychain._()); return u.decrypt(o.recipient, l), n(u.content.getBytes(), "ascii"); }
                };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(83), f(44), f(143), f(82), f(145), f(889), f(50), f(14), f(341);
                var r = d.asn1, e = E.exports = d.pkcs7 = d.pkcs7 || {};
                function c(o) { var h = {}, a = []; if (!r.validate(o, e.asn1.recipientInfoValidator, h, a)) {
                    var l = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
                    throw l.errors = a, l;
                } return { version: h.version.charCodeAt(0), issuer: d.pki.RDNAttributesAsArray(h.issuer), serialNumber: d.util.createBuffer(h.serial).toHex(), encryptedContent: { algorithm: r.derToOid(h.encAlgorithm), parameter: h.encParameter.value, content: h.encKey } }; }
                function n(o) { for (var h, a = [], l = 0; l < o.length; ++l)
                    a.push((h = o[l], r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(h.version).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [d.pki.distinguishedNameToAsn1({ attributes: h.issuer }), r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, d.util.hexToBytes(h.serialNumber))]), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(h.encryptedContent.algorithm).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")]), r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, h.encryptedContent.content)]))); return a; }
                function t(o) { var h = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(o.version).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [d.pki.distinguishedNameToAsn1({ attributes: o.issuer }), r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, d.util.hexToBytes(o.serialNumber))]), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.digestAlgorithm).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")])]); if (o.authenticatedAttributesAsn1 && h.value.push(o.authenticatedAttributesAsn1), h.value.push(r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.signatureAlgorithm).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")])), h.value.push(r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, o.signature)), o.unauthenticatedAttributes.length > 0) {
                    for (var a = r.create(r.Class.CONTEXT_SPECIFIC, 1, !0, []), l = 0; l < o.unauthenticatedAttributes.length; ++l) {
                        var p = o.unauthenticatedAttributes[l];
                        a.values.push(s(p));
                    }
                    h.value.push(a);
                } return h; }
                function s(o) { var h; if (o.type === d.pki.oids.contentType)
                    h = r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.value).getBytes());
                else if (o.type === d.pki.oids.messageDigest)
                    h = r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, o.value.bytes());
                else if (o.type === d.pki.oids.signingTime) {
                    var a = new Date("1950-01-01T00:00:00Z"), l = new Date("2050-01-01T00:00:00Z"), p = o.value;
                    if (typeof p == "string") {
                        var g = Date.parse(p);
                        p = isNaN(g) ? p.length === 13 ? r.utcTimeToDate(p) : r.generalizedTimeToDate(p) : new Date(g);
                    }
                    h = p >= a && p < l ? r.create(r.Class.UNIVERSAL, r.Type.UTCTIME, !1, r.dateToUtcTime(p)) : r.create(r.Class.UNIVERSAL, r.Type.GENERALIZEDTIME, !1, r.dateToGeneralizedTime(p));
                } return r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.type).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SET, !0, [h])]); }
                function u(o, h, a) { var l = {}; if (!r.validate(h, a, l, [])) {
                    var p = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
                    throw p.errors = p, p;
                } if (r.derToOid(l.contentType) !== d.pki.oids.data)
                    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported."); if (l.encryptedContent) {
                    var g = "";
                    if (d.util.isArray(l.encryptedContent))
                        for (var b = 0; b < l.encryptedContent.length; ++b) {
                            if (l.encryptedContent[b].type !== r.Type.OCTETSTRING)
                                throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                            g += l.encryptedContent[b].value;
                        }
                    else
                        g = l.encryptedContent;
                    o.encryptedContent = { algorithm: r.derToOid(l.encAlgorithm), parameter: d.util.createBuffer(l.encParameter.value), content: d.util.createBuffer(g) };
                } if (l.content) {
                    if (g = "", d.util.isArray(l.content))
                        for (b = 0; b < l.content.length; ++b) {
                            if (l.content[b].type !== r.Type.OCTETSTRING)
                                throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                            g += l.content[b].value;
                        }
                    else
                        g = l.content;
                    o.content = d.util.createBuffer(g);
                } return o.version = l.version.charCodeAt(0), o.rawCapture = l, l; }
                function i(o) { if (o.encryptedContent.key === void 0)
                    throw new Error("Symmetric key not available."); if (o.content === void 0) {
                    var h;
                    switch (o.encryptedContent.algorithm) {
                        case d.pki.oids["aes128-CBC"]:
                        case d.pki.oids["aes192-CBC"]:
                        case d.pki.oids["aes256-CBC"]:
                            h = d.aes.createDecryptionCipher(o.encryptedContent.key);
                            break;
                        case d.pki.oids.desCBC:
                        case d.pki.oids["des-EDE3-CBC"]:
                            h = d.des.createDecryptionCipher(o.encryptedContent.key);
                            break;
                        default: throw new Error("Unsupported symmetric cipher, OID " + o.encryptedContent.algorithm);
                    }
                    if (h.start(o.encryptedContent.parameter), h.update(o.encryptedContent.content), !h.finish())
                        throw new Error("Symmetric decryption failed.");
                    o.content = h.output;
                } }
                e.messageFromPem = function (o) { var h = d.pem.decode(o)[0]; if (h.type !== "PKCS7") {
                    var a = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
                    throw a.headerType = h.type, a;
                } if (h.procType && h.procType.type === "ENCRYPTED")
                    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted."); var l = r.fromDer(h.body); return e.messageFromAsn1(l); }, e.messageToPem = function (o, h) { var a = { type: "PKCS7", body: r.toDer(o.toAsn1()).getBytes() }; return d.pem.encode(a, { maxline: h }); }, e.messageFromAsn1 = function (o) { var h = {}, a = []; if (!r.validate(o, e.asn1.contentInfoValidator, h, a)) {
                    var l = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
                    throw l.errors = a, l;
                } var p, g = r.derToOid(h.contentType); switch (g) {
                    case d.pki.oids.envelopedData:
                        p = e.createEnvelopedData();
                        break;
                    case d.pki.oids.encryptedData:
                        p = e.createEncryptedData();
                        break;
                    case d.pki.oids.signedData:
                        p = e.createSignedData();
                        break;
                    default: throw new Error("Cannot read PKCS#7 message. ContentType with OID " + g + " is not (yet) supported.");
                } return p.fromAsn1(h.content.value[0]), p; }, e.createSignedData = function () { var o = null; return o = { type: d.pki.oids.signedData, version: 1, certificates: [], crls: [], signers: [], digestAlgorithmIdentifiers: [], contentInfo: null, signerInfos: [], fromAsn1: function (h) { if (u(o, h, e.asn1.signedDataValidator), o.certificates = [], o.crls = [], o.digestAlgorithmIdentifiers = [], o.contentInfo = null, o.signerInfos = [], o.rawCapture.certificates)
                        for (var a = o.rawCapture.certificates.value, l = 0; l < a.length; ++l)
                            o.certificates.push(d.pki.certificateFromAsn1(a[l])); }, toAsn1: function () { o.contentInfo || o.sign(); for (var h = [], a = 0; a < o.certificates.length; ++a)
                        h.push(d.pki.certificateToAsn1(o.certificates[a])); var l = [], p = r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(o.version).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SET, !0, o.digestAlgorithmIdentifiers), o.contentInfo])]); return h.length > 0 && p.value[0].value.push(r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, h)), l.length > 0 && p.value[0].value.push(r.create(r.Class.CONTEXT_SPECIFIC, 1, !0, l)), p.value[0].value.push(r.create(r.Class.UNIVERSAL, r.Type.SET, !0, o.signerInfos)), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.type).getBytes()), p]); }, addSigner: function (h) { var a = h.issuer, l = h.serialNumber; if (h.certificate) {
                        var p = h.certificate;
                        typeof p == "string" && (p = d.pki.certificateFromPem(p)), a = p.issuer.attributes, l = p.serialNumber;
                    } var g = h.key; if (!g)
                        throw new Error("Could not add PKCS#7 signer; no private key specified."); typeof g == "string" && (g = d.pki.privateKeyFromPem(g)); var b = h.digestAlgorithm || d.pki.oids.sha1; switch (b) {
                        case d.pki.oids.sha1:
                        case d.pki.oids.sha256:
                        case d.pki.oids.sha384:
                        case d.pki.oids.sha512:
                        case d.pki.oids.md5: break;
                        default: throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + b);
                    } var I = h.authenticatedAttributes || []; if (I.length > 0) {
                        for (var v = !1, R = !1, _ = 0; _ < I.length; ++_) {
                            var k = I[_];
                            if (v || k.type !== d.pki.oids.contentType) {
                                if (!(R || k.type !== d.pki.oids.messageDigest)) {
                                    if (R = !0, v)
                                        break;
                                }
                            }
                            else if (v = !0, R)
                                break;
                        }
                        if (!v || !R)
                            throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
                    } o.signers.push({ key: g, version: 1, issuer: a, serialNumber: l, digestAlgorithm: b, signatureAlgorithm: d.pki.oids.rsaEncryption, signature: null, authenticatedAttributes: I, unauthenticatedAttributes: [] }); }, sign: function (h) { var a; (h = h || {}, typeof o.content != "object" || o.contentInfo === null) && (o.contentInfo = r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(d.pki.oids.data).getBytes())]), "content" in o && (o.content instanceof d.util.ByteBuffer ? a = o.content.bytes() : typeof o.content == "string" && (a = d.util.encodeUtf8(o.content)), h.detached ? o.detachedContent = r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, a) : o.contentInfo.value.push(r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, a)])))), o.signers.length !== 0 && function (l) { var p; if (p = o.detachedContent ? o.detachedContent : (p = o.contentInfo.value[1]).value[0], !p)
                        throw new Error("Could not sign PKCS#7 message; there is no content to sign."); var g = r.derToOid(o.contentInfo.value[0].value), b = r.toDer(p); for (var I in b.getByte(), r.getBerValueLength(b), b = b.getBytes(), l)
                        l[I].start().update(b); for (var v = new Date, R = 0; R < o.signers.length; ++R) {
                        var _ = o.signers[R];
                        if (_.authenticatedAttributes.length === 0) {
                            if (g !== d.pki.oids.data)
                                throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
                        }
                        else {
                            _.authenticatedAttributesAsn1 = r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, []);
                            for (var k = r.create(r.Class.UNIVERSAL, r.Type.SET, !0, []), x = 0; x < _.authenticatedAttributes.length; ++x) {
                                var M = _.authenticatedAttributes[x];
                                M.type === d.pki.oids.messageDigest ? M.value = l[_.digestAlgorithm].digest() : M.type === d.pki.oids.signingTime && (M.value || (M.value = v)), k.value.push(s(M)), _.authenticatedAttributesAsn1.value.push(s(M));
                            }
                            b = r.toDer(k).getBytes(), _.md.start().update(b);
                        }
                        _.signature = _.key.sign(_.md, "RSASSA-PKCS1-V1_5");
                    } o.signerInfos = function (N) { for (var S = [], T = 0; T < N.length; ++T)
                        S.push(t(N[T])); return S; }(o.signers); }(function () { for (var l = {}, p = 0; p < o.signers.length; ++p) {
                        var g = o.signers[p];
                        (b = g.digestAlgorithm) in l || (l[b] = d.md[d.pki.oids[b]].create()), g.authenticatedAttributes.length === 0 ? g.md = l[b] : g.md = d.md[d.pki.oids[b]].create();
                    } for (var b in o.digestAlgorithmIdentifiers = [], l)
                        o.digestAlgorithmIdentifiers.push(r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(b).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.NULL, !1, "")])); return l; }()); }, verify: function () { throw new Error("PKCS#7 signature verification not yet implemented."); }, addCertificate: function (h) { typeof h == "string" && (h = d.pki.certificateFromPem(h)), o.certificates.push(h); }, addCertificateRevokationList: function (h) { throw new Error("PKCS#7 CRL support not yet implemented."); } }; }, e.createEncryptedData = function () { var o = null; return o = { type: d.pki.oids.encryptedData, version: 0, encryptedContent: { algorithm: d.pki.oids["aes256-CBC"] }, fromAsn1: function (h) { u(o, h, e.asn1.encryptedDataValidator); }, decrypt: function (h) { h !== void 0 && (o.encryptedContent.key = h), i(o); } }; }, e.createEnvelopedData = function () { var o = null; return o = { type: d.pki.oids.envelopedData, version: 0, recipients: [], encryptedContent: { algorithm: d.pki.oids["aes256-CBC"] }, fromAsn1: function (h) { var a = u(o, h, e.asn1.envelopedDataValidator); o.recipients = function (l) { for (var p = [], g = 0; g < l.length; ++g)
                        p.push(c(l[g])); return p; }(a.recipientInfos.value); }, toAsn1: function () { return r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(o.type).getBytes()), r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.INTEGER, !1, r.integerToDer(o.version).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SET, !0, n(o.recipients)), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, (h = o.encryptedContent, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(d.pki.oids.data).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.SEQUENCE, !0, [r.create(r.Class.UNIVERSAL, r.Type.OID, !1, r.oidToDer(h.algorithm).getBytes()), r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, h.parameter.getBytes())]), r.create(r.Class.CONTEXT_SPECIFIC, 0, !0, [r.create(r.Class.UNIVERSAL, r.Type.OCTETSTRING, !1, h.content.getBytes())])]))])])]); var h; }, findRecipient: function (h) { for (var a = h.issuer.attributes, l = 0; l < o.recipients.length; ++l) {
                        var p = o.recipients[l], g = p.issuer;
                        if (p.serialNumber === h.serialNumber && g.length === a.length) {
                            for (var b = !0, I = 0; I < a.length; ++I)
                                if (g[I].type !== a[I].type || g[I].value !== a[I].value) {
                                    b = !1;
                                    break;
                                }
                            if (b)
                                return p;
                        }
                    } return null; }, decrypt: function (h, a) { if (o.encryptedContent.key === void 0 && h !== void 0 && a !== void 0)
                        switch (h.encryptedContent.algorithm) {
                            case d.pki.oids.rsaEncryption:
                            case d.pki.oids.desCBC:
                                var l = a.decrypt(h.encryptedContent.content);
                                o.encryptedContent.key = d.util.createBuffer(l);
                                break;
                            default: throw new Error("Unsupported asymmetric cipher, OID " + h.encryptedContent.algorithm);
                        } i(o); }, addRecipient: function (h) { o.recipients.push({ version: 0, issuer: h.issuer.attributes, serialNumber: h.serialNumber, encryptedContent: { algorithm: d.pki.oids.rsaEncryption, key: h.publicKey } }); }, encrypt: function (h, a) { if (o.encryptedContent.content === void 0) {
                        var l, p, g;
                        switch (a = a || o.encryptedContent.algorithm, h = h || o.encryptedContent.key, a) {
                            case d.pki.oids["aes128-CBC"]:
                                l = 16, p = 16, g = d.aes.createEncryptionCipher;
                                break;
                            case d.pki.oids["aes192-CBC"]:
                                l = 24, p = 16, g = d.aes.createEncryptionCipher;
                                break;
                            case d.pki.oids["aes256-CBC"]:
                                l = 32, p = 16, g = d.aes.createEncryptionCipher;
                                break;
                            case d.pki.oids["des-EDE3-CBC"]:
                                l = 24, p = 8, g = d.des.createEncryptionCipher;
                                break;
                            default: throw new Error("Unsupported symmetric cipher, OID " + a);
                        }
                        if (h === void 0)
                            h = d.util.createBuffer(d.random.getBytes(l));
                        else if (h.length() != l)
                            throw new Error("Symmetric key has wrong length; got " + h.length() + " bytes, expected " + l + ".");
                        o.encryptedContent.algorithm = a, o.encryptedContent.key = h, o.encryptedContent.parameter = d.util.createBuffer(d.random.getBytes(p));
                        var b = g(h);
                        if (b.start(o.encryptedContent.parameter.copy()), b.update(o.content), !b.finish())
                            throw new Error("Symmetric encryption failed.");
                        o.encryptedContent.content = b.output;
                    } for (var I = 0; I < o.recipients.length; ++I) {
                        var v = o.recipients[I];
                        if (v.encryptedContent.content === void 0)
                            switch (v.encryptedContent.algorithm) {
                                case d.pki.oids.rsaEncryption:
                                    v.encryptedContent.content = v.encryptedContent.key.encrypt(o.encryptedContent.key.data);
                                    break;
                                default: throw new Error("Unsupported asymmetric cipher, OID " + v.encryptedContent.algorithm);
                            }
                    } } }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(44), f(14);
                var r = d.asn1, e = E.exports = d.pkcs7asn1 = d.pkcs7asn1 || {};
                d.pkcs7 = d.pkcs7 || {}, d.pkcs7.asn1 = e;
                var c = { name: "ContentInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "ContentInfo.ContentType", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "contentType" }, { name: "ContentInfo.content", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, constructed: !0, optional: !0, captureAsn1: "content" }] };
                e.contentInfoValidator = c;
                var n = { name: "EncryptedContentInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "EncryptedContentInfo.contentType", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "contentType" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "encAlgorithm" }, { name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter", tagClass: r.Class.UNIVERSAL, captureAsn1: "encParameter" }] }, { name: "EncryptedContentInfo.encryptedContent", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, capture: "encryptedContent", captureAsn1: "encryptedContentAsn1" }] };
                e.envelopedDataValidator = { name: "EnvelopedData", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "EnvelopedData.Version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "version" }, { name: "EnvelopedData.RecipientInfos", tagClass: r.Class.UNIVERSAL, type: r.Type.SET, constructed: !0, captureAsn1: "recipientInfos" }].concat(n) }, e.encryptedDataValidator = { name: "EncryptedData", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "EncryptedData.Version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "version" }].concat(n) };
                var t = { name: "SignerInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "SignerInfo.version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1 }, { name: "SignerInfo.issuerAndSerialNumber", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "SignerInfo.issuerAndSerialNumber.issuer", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "issuer" }, { name: "SignerInfo.issuerAndSerialNumber.serialNumber", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "serial" }] }, { name: "SignerInfo.digestAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "SignerInfo.digestAlgorithm.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "digestAlgorithm" }, { name: "SignerInfo.digestAlgorithm.parameter", tagClass: r.Class.UNIVERSAL, constructed: !1, captureAsn1: "digestParameter", optional: !0 }] }, { name: "SignerInfo.authenticatedAttributes", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, constructed: !0, optional: !0, capture: "authenticatedAttributes" }, { name: "SignerInfo.digestEncryptionAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, capture: "signatureAlgorithm" }, { name: "SignerInfo.encryptedDigest", tagClass: r.Class.UNIVERSAL, type: r.Type.OCTETSTRING, constructed: !1, capture: "signature" }, { name: "SignerInfo.unauthenticatedAttributes", tagClass: r.Class.CONTEXT_SPECIFIC, type: 1, constructed: !0, optional: !0, capture: "unauthenticatedAttributes" }] };
                e.signedDataValidator = { name: "SignedData", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "SignedData.Version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "version" }, { name: "SignedData.DigestAlgorithms", tagClass: r.Class.UNIVERSAL, type: r.Type.SET, constructed: !0, captureAsn1: "digestAlgorithms" }, c, { name: "SignedData.Certificates", tagClass: r.Class.CONTEXT_SPECIFIC, type: 0, optional: !0, captureAsn1: "certificates" }, { name: "SignedData.CertificateRevocationLists", tagClass: r.Class.CONTEXT_SPECIFIC, type: 1, optional: !0, captureAsn1: "crls" }, { name: "SignedData.SignerInfos", tagClass: r.Class.UNIVERSAL, type: r.Type.SET, capture: "signerInfos", optional: !0, value: [t] }] }, e.recipientInfoValidator = { name: "RecipientInfo", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "RecipientInfo.version", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "version" }, { name: "RecipientInfo.issuerAndSerial", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "RecipientInfo.issuerAndSerial.issuer", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, captureAsn1: "issuer" }, { name: "RecipientInfo.issuerAndSerial.serialNumber", tagClass: r.Class.UNIVERSAL, type: r.Type.INTEGER, constructed: !1, capture: "serial" }] }, { name: "RecipientInfo.keyEncryptionAlgorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.SEQUENCE, constructed: !0, value: [{ name: "RecipientInfo.keyEncryptionAlgorithm.algorithm", tagClass: r.Class.UNIVERSAL, type: r.Type.OID, constructed: !1, capture: "encAlgorithm" }, { name: "RecipientInfo.keyEncryptionAlgorithm.parameter", tagClass: r.Class.UNIVERSAL, constructed: !1, captureAsn1: "encParameter" }] }, { name: "RecipientInfo.encryptedKey", tagClass: r.Class.UNIVERSAL, type: r.Type.OCTETSTRING, constructed: !1, capture: "encKey" }] };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(891), E.exports = d.mgf = d.mgf || {}, d.mgf.mgf1 = d.mgf1;
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(14), d.mgf = d.mgf || {}, (E.exports = d.mgf.mgf1 = d.mgf1 = d.mgf1 || {}).create = function (r) { return { generate: function (e, c) { for (var n = new d.util.ByteBuffer, t = Math.ceil(c / r.digestLength), s = 0; s < t; s++) {
                        var u = new d.util.ByteBuffer;
                        u.putInt32(s), r.start(), r.update(e + u.getBytes()), n.putBuffer(r.digest());
                    } return n.truncate(n.length() - c), n.getBytes(); } }; };
            }, function (E, m, f) {
                "use strict";
                var d = f(8);
                f(50), f(14), (E.exports = d.pss = d.pss || {}).create = function (r) { arguments.length === 3 && (r = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] }); var e, c = r.md, n = r.mgf, t = c.digestLength, s = r.salt || null; if (typeof s == "string" && (s = d.util.createBuffer(s)), "saltLength" in r)
                    e = r.saltLength;
                else {
                    if (s === null)
                        throw new Error("Salt length not specified or specific salt not given.");
                    e = s.length();
                } if (s !== null && s.length() !== e)
                    throw new Error("Given salt length does not match length of given salt."); var u = r.prng || d.random, i = { encode: function (o, h) { var a, l, p = h - 1, g = Math.ceil(p / 8), b = o.digest().getBytes(); if (g < t + e + 2)
                        throw new Error("Message is too long to encrypt."); l = s === null ? u.getBytesSync(e) : s.bytes(); var I = new d.util.ByteBuffer; I.fillWithByte(0, 8), I.putBytes(b), I.putBytes(l), c.start(), c.update(I.getBytes()); var v = c.digest().getBytes(), R = new d.util.ByteBuffer; R.fillWithByte(0, g - e - t - 2), R.putByte(1), R.putBytes(l); var _ = R.getBytes(), k = g - t - 1, x = n.generate(v, k), M = ""; for (a = 0; a < k; a++)
                        M += String.fromCharCode(_.charCodeAt(a) ^ x.charCodeAt(a)); var N = 65280 >> 8 * g - p & 255; return (M = String.fromCharCode(M.charCodeAt(0) & ~N) + M.substr(1)) + v + String.fromCharCode(188); }, verify: function (o, h, a) { var l, p = a - 1, g = Math.ceil(p / 8); if (h = h.substr(-g), g < t + e + 2)
                        throw new Error("Inconsistent parameters to PSS signature verification."); if (h.charCodeAt(g - 1) !== 188)
                        throw new Error("Encoded message does not end in 0xBC."); var b = g - t - 1, I = h.substr(0, b), v = h.substr(b, t), R = 65280 >> 8 * g - p & 255; if ((I.charCodeAt(0) & R) != 0)
                        throw new Error("Bits beyond keysize not zero as expected."); var _ = n.generate(v, b), k = ""; for (l = 0; l < b; l++)
                        k += String.fromCharCode(I.charCodeAt(l) ^ _.charCodeAt(l)); k = String.fromCharCode(k.charCodeAt(0) & ~R) + k.substr(1); var x = g - t - e - 2; for (l = 0; l < x; l++)
                        if (k.charCodeAt(l) !== 0)
                            throw new Error("Leftmost octets not zero as expected"); if (k.charCodeAt(x) !== 1)
                        throw new Error("Inconsistent PSS signature, 0x01 marker not found"); var M = k.substr(-e), N = new d.util.ByteBuffer; return N.fillWithByte(0, 8), N.putBytes(o), N.putBytes(M), c.start(), c.update(N.getBytes()), v === c.digest().getBytes(); } }; return i; };
            }, function (E, m, f) {
                "use strict";
                f(341);
                const d = f(8).pki;
                E.exports.certificateForKey = (r, e) => { const c = d.setRsaPublicKey(e.n, e.e), n = d.createCertificate(); n.publicKey = c, n.serialNumber = "01", n.validity.notBefore = new Date, n.validity.notAfter = new Date, n.validity.notAfter.setFullYear(n.validity.notBefore.getFullYear() + 10); const t = [{ name: "organizationName", value: "ipfs" }, { shortName: "OU", value: "keystore" }, { name: "commonName", value: r.id }]; return n.setSubject(t), n.setIssuer(t), n.setExtensions([{ name: "basicConstraints", cA: !0 }, { name: "keyUsage", keyCertSign: !0, digitalSignature: !0, nonRepudiation: !0, keyEncipherment: !0, dataEncipherment: !0 }, { name: "extKeyUsage", serverAuth: !0, clientAuth: !0, codeSigning: !0, emailProtection: !0, timeStamping: !0 }, { name: "nsCertType", client: !0, server: !0, email: !0, objsign: !0, sslCA: !0, emailCA: !0, objCA: !0 }]), n.sign(e), n; }, E.exports.findAsync = async function (r, e) { const c = r.map(e); return r[(await Promise.all(c)).findIndex(n => n)]; };
            }, function (E, m, f) {
                "use strict";
                const d = f(24), r = f(27), { tap: e } = f(55), c = f(895), { METRICS: n } = f(196), t = f(896), s = ["dataReceived", "dataSent"], u = { in: "dataReceived", out: "dataSent" };
                class i {
                    constructor(h) { this._options = d(n, h), this._globalStats = new t(s, this._options), this._peerStats = new Map, this._protocolStats = new Map, this._oldPeers = c(this._options.maxOldPeersRetention), this._running = !1, this._onMessage = this._onMessage.bind(this), this._connectionManager = h.connectionManager, this._connectionManager.on("peer:disconnect", a => { this.onPeerDisconnected(a.remotePeer); }); }
                    start() { this._running = !0; }
                    stop() { this._running = !1, this._globalStats.stop(); for (const h of this._peerStats.values())
                        h.stop(); for (const h of this._protocolStats.values())
                        h.stop(); }
                    get global() { return this._globalStats; }
                    get peers() { return Array.from(this._peerStats.keys()); }
                    forPeer(h) { const a = h.toB58String(); return this._peerStats.get(a) || this._oldPeers.get(a); }
                    get protocols() { return Array.from(this._protocolStats.keys()); }
                    forProtocol(h) { return this._protocolStats.get(h); }
                    onPeerDisconnected(h) { const a = h.toB58String(), l = this._peerStats.get(a); l && (l.stop(), this._peerStats.delete(a), this._oldPeers.set(a, l)); }
                    _onMessage({ remotePeer: h, protocol: a, direction: l, dataLength: p }) { if (!this._running)
                        return; const g = u[l]; let b = this.forPeer(h); if (b || (b = new t(s, this._options), this._peerStats.set(h.toB58String(), b)), b.push(g, p), this._globalStats.push(g, p), a) {
                        let I = this.forProtocol(a);
                        I || (I = new t(s, this._options), this._protocolStats.set(a, I)), I.push(g, p);
                    } }
                    updatePlaceholder(h, a) { if (!this._running)
                        return; const l = this.forPeer(h), p = a.toB58String(), g = this.forPeer(a); let b = l; g && (b = i.mergeStats(g, b), this._oldPeers.delete(p)), this._peerStats.delete(h.toB58String()), this._peerStats.set(p, b), b.start(); }
                    trackStream({ stream: h, remotePeer: a, protocol: l }) { const p = this, g = h.source; h.source = e(I => p._onMessage({ remotePeer: a, protocol: l, direction: "in", dataLength: I.length }))(g); const b = h.sink; return h.sink = I => r(I, e(v => p._onMessage({ remotePeer: a, protocol: l, direction: "out", dataLength: v.length })), b), h; }
                    static mergeStats(h, a) { return h.stop(), a.stop(), h._queue = [...h._queue, ...a._queue], h; }
                }
                E.exports = i;
            }, function (E, m, f) {
                "use strict";
                const d = f(112);
                E.exports = r => { const e = d(r); return e.delete = e.remove, e; };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(30), e = f(342), c = f(152);
                E.exports = class extends d {
                    constructor(n, t) { super(), this._options = t, this._queue = [], this._stats = {}, this._frequencyLastTime = Date.now(), this._frequencyAccumulators = {}, this._movingAverages = {}, this._update = this._update.bind(this); const s = this._options.movingAverageIntervals; for (var u = 0; u < n.length; u++) {
                        var i = n[u];
                        this._stats[i] = r(0), this._movingAverages[i] = {};
                        for (var o = 0; o < s.length; o++) {
                            var h = s[o];
                            (this._movingAverages[i][h] = e(h)).push(this._frequencyLastTime, 0);
                        }
                    } }
                    start() { this._queue.length && this._resetComputeTimeout(); }
                    stop() { this._timeout && (this._timeout.clear(), this._timeout = null); }
                    get snapshot() { return Object.assign({}, this._stats); }
                    get movingAverages() { return Object.assign({}, this._movingAverages); }
                    toJSON() { const n = this.snapshot, t = this.movingAverages, s = { dataReceived: n.dataReceived.toString(), dataSent: n.dataSent.toString(), movingAverages: {} }, u = Object.keys(t); for (const i of u) {
                        s.movingAverages[i] = {};
                        for (const o of Object.keys(t[i]))
                            s.movingAverages[i][o] = t[i][o].movingAverage();
                    } return s; }
                    push(n, t) { this._queue.push([n, t, Date.now()]), this._resetComputeTimeout(); }
                    _resetComputeTimeout() { this._timeout = c(this._update, this._nextTimeout()); }
                    _nextTimeout() { const n = this._queue.length / this._options.computeThrottleMaxQueueSize; return Math.max(this._options.computeThrottleTimeout * (1 - n), 0); }
                    _update() { if (this._timeout = null, this._queue.length) {
                        let n;
                        for (n of this._queue)
                            this._applyOp(n);
                        this._queue = [], this._updateFrequency(n[2]), this.emit("update", this._stats);
                    } }
                    _updateFrequency(n) { const t = n - this._frequencyLastTime; Object.keys(this._stats).forEach(s => { this._updateFrequencyFor(s, t, n); }), this._frequencyLastTime = n; }
                    _updateFrequencyFor(n, t, s) { const u = this._frequencyAccumulators[n] || 0; this._frequencyAccumulators[n] = 0; const i = u / (t || 1) * 1e3; let o = this._movingAverages[n]; o || (o = this._movingAverages[n] = {}); const h = this._options.movingAverageIntervals; for (var a = 0; a < h.length; a++) {
                        var l = h[a], p = o[l];
                        p || (p = o[l] = e(l)), p.push(s, i);
                    } }
                    _applyOp(n) { const t = n[0], s = n[1]; if (typeof s != "number")
                        throw new Error("invalid increment number:", s); let u; u = Object.prototype.hasOwnProperty.call(this._stats, t) ? this._stats[t] : this._stats[t] = r(0), this._stats[t] = u.plus(s), this._frequencyAccumulators[t] || (this._frequencyAccumulators[t] = 0), this._frequencyAccumulators[t] += s; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:upgrader");
                r.error = d("libp2p:upgrader:error");
                const e = f(898), { Connection: c } = f(902), n = f(344), t = f(7), s = f(27), u = f(0), i = f(904), { codes: o } = f(28);
                E.exports = class {
                    constructor({ localPeer: h, metrics: a, cryptos: l, muxers: p, onConnectionEnd: g = () => { }, onConnection: b = () => { } }) { this.localPeer = h, this.metrics = a, this.cryptos = l || new Map, this.muxers = p || new Map, this.protector = null, this.protocols = new Map, this.onConnection = b, this.onConnectionEnd = g; }
                    async upgradeInbound(h) { let a, l, p, g, b, I, v; if (this.metrics) {
                        ({ setTarget: I, proxy: v } = i());
                        const _ = parseInt(1e9 * Math.random()).toString(36) + Date.now();
                        I({ toB58String: () => _ }), h = this.metrics.trackStream({ stream: h, remotePeer: v });
                    } r("Starting the inbound connection upgrade"); let R = h; this.protector && (R = await this.protector.protect(h)); try {
                        ({ conn: a, remotePeer: l, protocol: b } = await this._encryptInbound(this.localPeer, R, this.cryptos)), this.muxers.size ? { stream: p, Muxer: g } = await this._multiplexInbound(a, this.muxers) : p = a;
                    }
                    catch (_) {
                        throw r.error("Failed to upgrade inbound connection", _), await h.close(_), _;
                    } return this.metrics && (this.metrics.updatePlaceholder(v, l), I(l)), r("Successfully upgraded inbound connection"), this._createConnection({ cryptoProtocol: b, direction: "inbound", maConn: h, upgradedConn: p, Muxer: g, remotePeer: l }); }
                    async upgradeOutbound(h) { let a, l, p, g, b, I, v, R; try {
                        a = t.createFromB58String(h.remoteAddr.getPeerId());
                    }
                    catch (k) {
                        r.error("multiaddr did not contain a valid peer id", k);
                    } if (this.metrics) {
                        ({ setTarget: v, proxy: R } = i());
                        const k = parseInt(1e9 * Math.random()).toString(36) + Date.now();
                        v({ toB58String: () => k }), h = this.metrics.trackStream({ stream: h, remotePeer: R });
                    } r("Starting the outbound connection upgrade"); let _ = h; this.protector && (_ = await this.protector.protect(h)); try {
                        ({ conn: l, remotePeer: p, protocol: b } = await this._encryptOutbound(this.localPeer, _, a, this.cryptos)), this.muxers.size ? { stream: g, Muxer: I } = await this._multiplexOutbound(l, this.muxers) : g = l;
                    }
                    catch (k) {
                        throw r.error("Failed to upgrade outbound connection", k), await h.close(k), k;
                    } return this.metrics && (this.metrics.updatePlaceholder(R, p), v(p)), r("Successfully upgraded outbound connection"), this._createConnection({ cryptoProtocol: b, direction: "outbound", maConn: h, upgradedConn: g, Muxer: I, remotePeer: p }); }
                    _createConnection({ cryptoProtocol: h, direction: a, maConn: l, upgradedConn: p, Muxer: g, remotePeer: b }) { let I, v, R; g && (I = new g({ onStream: async (x) => { const M = new e.Listener(x); try {
                            const { stream: N, protocol: S } = await M.handle(Array.from(this.protocols.keys()));
                            r("%s: incoming stream opened on %s", a, S), this.metrics && this.metrics.trackStream({ stream: N, remotePeer: b, protocol: S }), R.addStream(x, { protocol: S }), this._onStream({ connection: R, stream: { ...x, ...N }, protocol: S });
                        }
                        catch (N) {
                            r.error(N);
                        } }, onStreamEnd: x => { R.removeStream(x.id); } }), v = async (x) => { r("%s: starting new stream on %s", a, x); const M = I.newStream(), N = new e.Dialer(M); try {
                        const { stream: S, protocol: T } = await N.select(x);
                        return this.metrics && this.metrics.trackStream({ stream: S, remotePeer: b, protocol: T }), { stream: { ...M, ...S }, protocol: T };
                    }
                    catch (S) {
                        throw r.error("could not create new stream", S), u(S, o.ERR_UNSUPPORTED_PROTOCOL);
                    } }, s(p, I, p).catch(r.error)); const _ = l.timeline; l.timeline = new Proxy(_, { set: (...x) => (R && x[1] === "close" && x[2] && !_.close && (async () => { try {
                            R.stat.status === n.OPEN && await R.close();
                        }
                        catch (M) {
                            r.error(M);
                        }
                        finally {
                            this.onConnectionEnd(R);
                        } })(), Reflect.set(...x)) }), l.timeline.upgraded = Date.now(); const k = () => { throw u(new Error("connection is not multiplexed"), "ERR_CONNECTION_NOT_MULTIPLEXED"); }; return R = new c({ localAddr: l.localAddr, remoteAddr: l.remoteAddr, localPeer: this.localPeer, remotePeer: b, stat: { direction: a, timeline: l.timeline, multiplexer: g && g.multicodec, encryption: h }, newStream: v || k, getStreams: () => I ? I.streams : k, close: async (x) => { await l.close(x), I && I.streams.map(M => M.abort(x)); } }), this.onConnection(R), R; }
                    _onStream({ connection: h, stream: a, protocol: l }) { this.protocols.get(l)({ connection: h, stream: a, protocol: l }); }
                    async _encryptInbound(h, a, l) { const p = new e.Listener(a), g = Array.from(l.keys()); r("handling inbound crypto protocol selection", g); try {
                        const { stream: b, protocol: I } = await p.handle(g), v = l.get(I);
                        return r("encrypting inbound connection..."), { ...await v.secureInbound(h, b), protocol: I };
                    }
                    catch (b) {
                        throw u(b, o.ERR_ENCRYPTION_FAILED);
                    } }
                    async _encryptOutbound(h, a, l, p) { const g = new e.Dialer(a), b = Array.from(p.keys()); r("selecting outbound crypto protocol", b); try {
                        const { stream: I, protocol: v } = await g.select(b), R = p.get(v);
                        return r("encrypting outbound connection to %j", l), { ...await R.secureOutbound(h, I, l), protocol: v };
                    }
                    catch (I) {
                        throw u(I, o.ERR_ENCRYPTION_FAILED);
                    } }
                    async _multiplexOutbound(h, a) { const l = new e.Dialer(h), p = Array.from(a.keys()); r("outbound selecting muxer %s", p); try {
                        const { stream: g, protocol: b } = await l.select(p);
                        return r("%s selected as muxer protocol", b), { stream: g, Muxer: a.get(b) };
                    }
                    catch (g) {
                        throw u(g, o.ERR_MUXER_UNAVAILABLE);
                    } }
                    async _multiplexInbound(h, a) { const l = new e.Listener(h), p = Array.from(a.keys()); r("inbound handling muxers %s", p); try {
                        const { stream: g, protocol: b } = await l.handle(p);
                        return { stream: g, Muxer: a.get(b) };
                    }
                    catch (g) {
                        throw u(g, o.ERR_MUXER_UNAVAILABLE);
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(899), r = f(900), e = f(901), { PROTOCOL_ID: c } = f(343);
                m.PROTOCOL_ID = c;
                class n {
                    constructor(s) { this._stream = s, this._shaken = !1; }
                    async _handshake() { if (this._shaken)
                        return; const { stream: s } = await d(this._stream, c); this._stream = s, this._shaken = !0; }
                }
                m.Dialer = class extends n {
                    select(t) { return d(this._stream, t, this._shaken ? null : c); }
                    async ls() { await this._handshake(); const { stream: t, protocols: s } = await e(this._stream); return this._stream = t, s; }
                }, m.Listener = class extends n {
                    handle(t) { return r(this._stream, t); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("mss:select"), r = f(0), e = f(200), c = f(99);
                E.exports = async (n, t, s) => { t = Array.isArray(t) ? [...t] : [t]; const { reader: u, writer: i, rest: o, stream: h } = c(n), a = t.shift(); s ? (d('select: write ["%s", "%s"]', s, a), e.writeAll(i, [s, a])) : (d('select: write "%s"', a), e.write(i, a)); let l = (await e.read(u)).toString(); if (d('select: read "%s"', l), l === s && (l = (await e.read(u)).toString(), d('select: read "%s"', l)), l === a)
                    return o(), { stream: h, protocol: a }; for (const p of t) {
                    d('select: write "%s"', p), e.write(i, p);
                    const g = (await e.read(u)).toString();
                    if (d('select: read "%s" for "%s"', g, p), g === p)
                        return o(), { stream: h, protocol: p };
                } throw o(), r(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1)("mss:handle"), r = f(34), e = f(200), c = f(99), { PROTOCOL_ID: n } = f(343);
                E.exports = async (t, s) => { s = Array.isArray(s) ? s : [s]; const { writer: u, reader: i, rest: o, stream: h } = c(t); for (;;) {
                    const a = (await e.read(i)).toString();
                    if (d('read "%s"', a), a !== n) {
                        if (s.includes(a))
                            return e.write(u, a), d('respond with "%s" for "%s"', a, a), o(), { stream: h, protocol: a };
                        a !== "ls" ? (e.write(u, "na"), d('respond with "na" for "%s"', a)) : (e.write(u, new r(s.map(l => e.encode(l)))), d('respond with "%s" for %s', s, a));
                    }
                    else
                        d('respond with "%s" for "%s"', n, a), e.write(u, n);
                } };
            }, function (E, m, f) {
                "use strict";
                const d = f(338), r = f(1)("it-multistream-select:ls"), e = f(200), c = f(99), n = f(35), t = f(27);
                E.exports = async (s) => { const { reader: u, writer: i, rest: o, stream: h } = c(s); r('write "ls"'), e.write(i, "ls"), o(); const a = await e.read(u), l = d([a]), p = []; return await t(l, n.decode(), async (g) => { for await (const b of g)
                    p.push(b.shallowSlice(0, -1).toString()); }), { stream: h, protocols: p }; };
            }, function (E, m, f) {
                "use strict";
                m.Connection = f(903);
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(13), e = f(26), c = f(0), n = f(344);
                E.exports = e(class {
                    constructor({ localAddr: t, remoteAddr: s, localPeer: u, remotePeer: i, newStream: o, close: h, getStreams: a, stat: l }) { !function (p, g, b, I, v, R, _) { if (p && !r.isMultiaddr(p))
                        throw c(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS"); if (!d.isPeerId(g))
                        throw c(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS"); if (!d.isPeerId(b))
                        throw c(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS"); if (typeof I != "function")
                        throw c(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS"); if (typeof v != "function")
                        throw c(new Error("close must be a function"), "ERR_INVALID_PARAMETERS"); if (typeof R != "function")
                        throw c(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS"); if (!_)
                        throw c(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS"); if (_.direction !== "inbound" && _.direction !== "outbound")
                        throw c(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS"); if (!_.timeline)
                        throw c(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS"); if (!_.timeline.open)
                        throw c(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS"); if (!_.timeline.upgraded)
                        throw c(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS"); }(t, u, i, o, h, a, l), this.id = parseInt(1e9 * Math.random()).toString(36) + Date.now(), this.localAddr = t, this.remoteAddr = s, this.localPeer = u, this.remotePeer = i, this._stat = { ...l, status: n.OPEN }, this._newStream = o, this._close = h, this._getStreams = a, this.registry = new Map, this.tags = []; }
                    get stat() { return this._stat; }
                    get streams() { return this._getStreams(); }
                    async newStream(t) { if (this.stat.status === n.CLOSING)
                        throw c(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED"); if (this.stat.status === n.CLOSED)
                        throw c(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED"); Array.isArray(t) || (t = [t]); const { stream: s, protocol: u } = await this._newStream(t); return this.addStream(s, { protocol: u }), { stream: s, protocol: u }; }
                    addStream(t, { protocol: s, metadata: u = {} }) { this.registry.set(t.id, { protocol: s, ...u }); }
                    removeStream(t) { this.registry.delete(t); }
                    async close() { if (this.stat.status !== n.CLOSED) {
                        if (this._closing)
                            return this._closing;
                        this.stat.status = n.CLOSING, this._closing = await this._close(), this._stat.timeline.close = Date.now(), this.stat.status = n.CLOSED;
                    } }
                }, { className: "Connection", symbolName: "@libp2p/interface-connection/connection" });
            }, function (E, m, f) {
                "use strict";
                function d(r) { if (Array.isArray(r)) {
                    for (var e = 0, c = Array(r.length); e < r.length; e++)
                        c[e] = r[e];
                    return c;
                } return Array.from(r); }
                E.exports = function (r) { var e = void 0, c = void 0; function n(u) { if (!(u instanceof Object))
                    throw new Error('Target "' + u + '" is not an object'); c = u; } function t(u) { Object.keys(u).forEach(function (i) { var o = u[i]; if (typeof o != "function")
                    throw new Error('Trap "' + i + ": " + o + '" is not a function'); if (!Reflect[i])
                    throw new Error('Trap "' + i + ": " + o + '" is not a valid trap'); }), e = u; } n(function () { }), r && n(r), t(Reflect); var s = new Proxy({}, { get: function (u, i) { return function () { for (var o = arguments.length, h = Array(o), a = 0; a < o; a++)
                        h[a] = arguments[a]; return e[i].apply(null, [c].concat(d(h.slice(1)))); }; } }); return { setTarget: n, setHandler: t, getTarget: function () { return c; }, getHandler: function () { return e; }, proxy: new Proxy(c, s) }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1), e = r("libp2p:peer-store:address-book");
                e.error = r("libp2p:peer-store:address-book:error");
                const c = f(13), n = f(7), t = f(123), s = f(346), { codes: { ERR_INVALID_PARAMETERS: u } } = f(28), i = f(193);
                E.exports = class extends t {
                    constructor(o) { super({ peerStore: o, eventName: "change:multiaddrs", eventProperty: "multiaddrs", eventTransformer: h => h.addresses ? h.addresses.map(a => a.multiaddr) : [] }), this.data = new Map; }
                    consumePeerRecord(o) { let h; try {
                        h = s.createFromProtobuf(o.payload);
                    }
                    catch (b) {
                        return e.error("invalid peer record received"), !1;
                    } if (!h.peerId.equals(o.peerId))
                        return e("signing key does not match PeerId in the PeerRecord"), !1; if (!h.multiaddrs || !h.multiaddrs.length)
                        return !1; const a = h.peerId, l = a.toB58String(), p = (this.data.get(l) || {}).record; if (p && p.seqNumber >= h.seqNumber)
                        return !1; const g = this._toAddresses(h.multiaddrs, !0); return this._setData(a, { addresses: g, record: { raw: o.marshal(), seqNumber: h.seqNumber } }), e("stored provided peer record for " + l), !0; }
                    getRawEnvelope(o) { const h = this.data.get(o.toB58String()); if (h && h.record && h.record.raw)
                        return h.record.raw; }
                    getPeerRecord(o) { const h = this.getRawEnvelope(o); if (h)
                        return i.createFromProtobuf(h); }
                    set(o, h) { if (!n.isPeerId(o))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), u); const a = this._toAddresses(h), l = o.toB58String(), p = this.data.get(l) || {}, g = p.addresses; return a.length ? g && g.length === a.length && g.filter(b => a.some(I => b.multiaddr.equals(I.multiaddr))).length === g.length ? (e("the addresses provided to store are equal to the already stored for " + l), this) : (this._setData(o, { addresses: a, record: p.record }), e("stored provided multiaddrs for " + l), g || this._ps.emit("peer", o), this) : this; }
                    add(o, h) { if (!n.isPeerId(o))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), u); const a = this._toAddresses(h), l = o.toB58String(), p = this.data.get(l) || {}, g = p.addresses || []; return g.forEach(b => { a.find(I => I.multiaddr.equals(b.multiaddr)) || a.push(b); }), g && g.length === a.length ? (e("the addresses provided to store are already stored for " + l), this) : (this._setData(o, { addresses: a, record: p.record }), e("added provided multiaddrs for " + l), p.addresses || this._ps.emit("peer", o), this); }
                    get(o) { if (!n.isPeerId(o))
                        throw d(new Error("peerId must be an instance of peer-id"), u); const h = this.data.get(o.toB58String()); return h && h.addresses ? [...h.addresses] : void 0; }
                    _toAddresses(o, h = !1) { if (!o)
                        throw e.error("multiaddrs must be provided to store data"), d(new Error("multiaddrs must be provided"), u); const a = []; return o.forEach(l => { if (!c.isMultiaddr(l))
                        throw e.error(`multiaddr ${l} must be an instance of multiaddr`), d(new Error(`multiaddr ${l} must be an instance of multiaddr`), u); a.push({ multiaddr: l, isCertified: h }); }), a; }
                    getMultiaddrsForPeer(o) { if (!n.isPeerId(o))
                        throw d(new Error("peerId must be an instance of peer-id"), u); const h = this.data.get(o.toB58String()); if (h && h.addresses)
                        return h.addresses.map(a => { const l = a.multiaddr, p = l.getPeerId(); return p && p === o.toB58String() ? l : l.encapsulate("/p2p/" + o.toB58String()); }); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(0);
                E.exports = class {
                    constructor(r, e) { this.domain = r, this.codec = e; }
                    marshal() { throw d(new Error("marshal must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED"); }
                    equals(r) { throw d(new Error("equals must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED"); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { return d.length === r.length && r.sort() && d.sort().every((e, c) => r[c].equals(e)); };
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message PeerRecord {
    // AddressInfo is a wrapper around a binary multiaddr. It is defined as a
    // separate message to allow us to add per-address metadata in the future.
    message AddressInfo {
        bytes multiaddr = 1;
    }

    // peer_id contains a libp2p peer id in its binary representation.
    bytes peer_id = 1;

    // seq contains a monotonically-increasing sequence counter to order PeerRecords in time.
    uint64 seq = 2;

    // addresses is a list of public listen addresses for the peer.
    repeated AddressInfo addresses = 3;
}
`).PeerRecord;
            }, function (E, m, f) {
                "use strict";
                const d = f(18);
                E.exports.ENVELOPE_DOMAIN_PEER_RECORD = d.getName(d.LIBP2P_PEER_RECORD), E.exports.ENVELOPE_PAYLOAD_TYPE_PEER_RECORD = Uint8Array.from([3, 1]);
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1), e = r("libp2p:peer-store:key-book");
                e.error = r("libp2p:peer-store:key-book:error");
                const c = f(7), n = f(123), { codes: { ERR_INVALID_PARAMETERS: t } } = f(28);
                E.exports = class extends n {
                    constructor(s) { super({ peerStore: s, eventName: "change:pubkey", eventProperty: "pubkey", eventTransformer: u => u.pubKey }), this.data = new Map; }
                    set(s, u) { if (!c.isPeerId(s))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), t); const i = s.toB58String(); return !this.data.get(i) && u && (s.pubKey = u, this._setData(s, s), e("stored provided public key for " + i)), this; }
                    get(s) { if (!c.isPeerId(s))
                        throw d(new Error("peerId must be an instance of peer-id"), t); const u = this.data.get(s.toB58String()); return u ? u.pubKey : void 0; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1), e = r("libp2p:peer-store:proto-book");
                e.error = r("libp2p:peer-store:proto-book:error");
                const c = f(20), n = f(7), t = f(123), { codes: { ERR_INVALID_PARAMETERS: s } } = f(28);
                E.exports = class extends t {
                    constructor(u) { super({ peerStore: u, eventName: "change:metadata", eventProperty: "metadata" }), this.data = new Map; }
                    set(u, i, o) { if (!n.isPeerId(u))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), s); if (typeof i != "string" || !(o instanceof Uint8Array))
                        throw e.error("valid key and value must be provided to store data"), d(new Error("valid key and value must be provided"), s); return this._setValue(u, i, o), this; }
                    _setValue(u, i, o, { emit: h = !0 } = {}) { const a = u.toB58String(), l = this.data.get(a) || new Map, p = l.get(i); p && c(o, p) ? e(`the metadata provided to store is equal to the already stored for ${a} on ${i}`) : (l.set(i, o), this.data.set(a, l), h && this._emit(u, i)); }
                    get(u) { if (!n.isPeerId(u))
                        throw d(new Error("peerId must be an instance of peer-id"), s); return this.data.get(u.toB58String()); }
                    getValue(u, i) { if (!n.isPeerId(u))
                        throw d(new Error("peerId must be an instance of peer-id"), s); const o = this.data.get(u.toB58String()); return o && o.get(i); }
                    delete(u) { if (!n.isPeerId(u))
                        throw d(new Error("peerId must be an instance of peer-id"), s); return !!this.data.delete(u.toB58String()) && (this._emit(u), !0); }
                    deleteValue(u, i) { if (!n.isPeerId(u))
                        throw d(new Error("peerId must be an instance of peer-id"), s); const o = this.data.get(u.toB58String()); return !(!o || !o.delete(i)) && (this._emit(u, i), !0); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(1), e = r("libp2p:peer-store:proto-book");
                e.error = r("libp2p:peer-store:proto-book:error");
                const c = f(7), n = f(123), { codes: { ERR_INVALID_PARAMETERS: t } } = f(28);
                E.exports = class extends n {
                    constructor(s) { super({ peerStore: s, eventName: "change:protocols", eventProperty: "protocols", eventTransformer: u => Array.from(u) }), this.data = new Map; }
                    set(s, u) { if (!c.isPeerId(s))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), t); if (!u)
                        throw e.error("protocols must be provided to store data"), d(new Error("protocols must be provided"), t); const i = s.toB58String(), o = this.data.get(i), h = new Set(u); return o && (l = h, (a = o).size === l.size && [...a].every(p => l.has(p))) ? (e("the protocols provided to store are equal to the already stored for " + i), this) : (this._setData(s, h), e("stored provided protocols for " + i), this); var a, l; }
                    add(s, u) { if (!c.isPeerId(s))
                        throw e.error("peerId must be an instance of peer-id to store data"), d(new Error("peerId must be an instance of peer-id"), t); if (!u)
                        throw e.error("protocols must be provided to store data"), d(new Error("protocols must be provided"), t); const i = s.toB58String(), o = this.data.get(i) || new Set, h = new Set([...o, ...u]); return o.size === h.size ? (e("the protocols provided to store are already stored for " + i), this) : (u = [...h], this._setData(s, h), e("added provided protocols for " + i), this); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = (d, r, e) => new class extends d {
                    subscribe(c, n) { n && this.on(c, n), super.subscribe(c); }
                    unsubscribe(c, n) { n ? this.removeListener(c, n) : this.removeAllListeners(c), this.listenerCount(c) === 0 && super.unsubscribe(c); }
                }(r, e);
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:persistent-peer-store");
                r.error = d("libp2p:persistent-peer-store:error");
                const { Key: e } = f(11), c = f(13), n = f(7), t = f(345), { NAMESPACE_ADDRESS: s, NAMESPACE_COMMON: u, NAMESPACE_KEYS: i, NAMESPACE_METADATA: o, NAMESPACE_PROTOCOL: h } = f(915), a = f(916), l = f(917);
                E.exports = class extends t {
                    constructor({ peerId: p, datastore: g, threshold: b = 5 }) { super({ peerId: p }), this._datastore = g, this._dirtyPeers = new Set, this._dirtyMetadata = new Map, this.threshold = b, this._addDirtyPeer = this._addDirtyPeer.bind(this); }
                    async start() { r("PeerStore is starting"), this.on("change:protocols", this._addDirtyPeer), this.on("change:multiaddrs", this._addDirtyPeer), this.on("change:pubkey", this._addDirtyPeerKey), this.on("change:metadata", this._addDirtyPeerMetadata); for await (const p of this._datastore.query({ prefix: u }))
                        await this._processDatastoreEntry(p); r("PeerStore started"); }
                    async stop() { r("PeerStore is stopping"), this.removeAllListeners(), await this._commitData(), r("PeerStore stopped"); }
                    _addDirtyPeer({ peerId: p }) { const g = p.toB58String(); r("add dirty peer", g), this._dirtyPeers.add(g), this._dirtyPeers.size >= this.threshold && this._commitData().catch(b => { r.error("error committing data", b); }); }
                    _addDirtyPeerKey({ peerId: p }) { if (p.hasInlinePublicKey())
                        return; const g = p.toB58String(); r("add dirty peer key", g), this._dirtyPeers.add(g), this._dirtyPeers.size >= this.threshold && this._commitData().catch(b => { r.error("error committing data", b); }); }
                    _addDirtyPeerMetadata({ peerId: p, metadata: g }) { const b = p.toB58String(); r("add dirty metadata peer", b), this._dirtyPeers.add(b); const I = this._dirtyMetadata.get(b) || new Set; I.add(g), this._dirtyMetadata.set(b, I), this._dirtyPeers.size >= this.threshold && this._commitData().catch(v => { r.error("error committing data", v); }); }
                    async _commitData() { const p = Array.from(this._dirtyPeers); if (!p.length)
                        return; this._dirtyPeers.clear(), r("create batch commit"); const g = this._datastore.batch(); for (const b of p) {
                        const I = this.keyBook.data.get(b) || n.createFromCID(b);
                        this._batchAddressBook(I, g), !I.hasInlinePublicKey() && this._batchKeyBook(I, g), this._batchMetadataBook(I, g), this._batchProtoBook(I, g);
                    } await g.commit(), r("batch committed"); }
                    _batchAddressBook(p, g) { const b = p.toString(), I = new e(`${s}${b}`), v = this.addressBook.data.get(p.toB58String()); try {
                        if (!v)
                            return void g.delete(I);
                        const R = a.encode({ addrs: v.addresses.map(_ => ({ multiaddr: _.multiaddr.bytes, isCertified: _.isCertified })), certified_record: v.record ? { seq: v.record.seqNumber, raw: v.record.raw } : void 0 });
                        g.put(I, R);
                    }
                    catch (R) {
                        r.error(R);
                    } }
                    _batchKeyBook(p, g) { const b = p.toString(), I = new e(`${i}${b}`); try {
                        if (!p.pubKey)
                            return void g.delete(I);
                        const v = p.marshalPubKey();
                        g.put(I, v);
                    }
                    catch (v) {
                        r.error(v);
                    } }
                    _batchMetadataBook(p, g) { const b = p.toString(), I = this._dirtyMetadata.get(p.toB58String()) || []; try {
                        I.forEach(v => { const R = new e(`${o}${b}/${v}`), _ = this.metadataBook.getValue(p, v); _ ? g.put(R, _) : g.delete(R); });
                    }
                    catch (v) {
                        r.error(v);
                    } }
                    _batchProtoBook(p, g) { const b = p.toString(), I = new e(`${h}${b}`), v = this.protoBook.get(p); try {
                        if (!v)
                            return void g.delete(I);
                        const R = l.encode({ protocols: v });
                        g.put(I, R);
                    }
                    catch (R) {
                        r.error(R);
                    } }
                    async _processDatastoreEntry({ key: p, value: g }) { try {
                        const b = p.toString().split("/"), I = n.createFromCID(b[3]);
                        let v;
                        switch (b[2]) {
                            case "addrs":
                                v = a.decode(g), this.addressBook._setData(I, { addresses: v.addrs.map(R => ({ multiaddr: c(R.multiaddr), isCertified: Boolean(R.isCertified) })), record: v.certified_record ? { raw: v.certified_record.raw, seqNumber: v.certified_record.seq } : void 0 }, { emit: !1 });
                                break;
                            case "keys":
                                v = await n.createFromPubKey(g), this.keyBook._setData(v, v, { emit: !1 });
                                break;
                            case "metadata":
                                this.metadataBook._setValue(I, b[4], g, { emit: !1 });
                                break;
                            case "protos":
                                v = l.decode(g), this.protoBook._setData(I, new Set(v.protocols), { emit: !1 });
                                break;
                            default: r("invalid data persisted for: ", p.toString());
                        }
                    }
                    catch (b) {
                        r.error(b);
                    } }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports.NAMESPACE_COMMON = "/peers/", E.exports.NAMESPACE_ADDRESS = "/peers/addrs/", E.exports.NAMESPACE_KEYS = "/peers/keys/", E.exports.NAMESPACE_METADATA = "/peers/metadata/", E.exports.NAMESPACE_PROTOCOL = "/peers/protos/";
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message Addresses {
  // Address represents a single multiaddr.
  message Address {
    required bytes multiaddr = 1;

    // Flag to indicate if the address comes from a certified source.
    optional bool isCertified = 2;
  }

  // CertifiedRecord contains a serialized signed PeerRecord used to
  // populate the signedAddrs list.
  message CertifiedRecord {
    // The Seq counter from the signed PeerRecord envelope
    uint64 seq = 1;

    // The serialized bytes of the SignedEnvelope containing the PeerRecord.
    bytes raw = 2;
  }

  // The known multiaddrs.
  repeated Address addrs = 1;

  // The most recently received signed PeerRecord.
  CertifiedRecord certified_record = 2;
}
`).Addresses;
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message Protocols {
  repeated string protocols = 1;
}
`).Protocols;
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = f(0);
                d("libp2p:peer-store").error = d("libp2p:peer-store:error");
                const { ERR_INVALID_PARAMETERS: e } = f(28), c = f(919);
                E.exports = class {
                    constructor({ peerStore: n, connectionManager: t }) { this.peerStore = n, this.connectionManager = t, this.topologies = new Map, this._handle = void 0, this._onDisconnect = this._onDisconnect.bind(this), this.connectionManager.on("peer:disconnect", this._onDisconnect); }
                    get handle() { return this._handle; }
                    set handle(n) { this._handle = n; }
                    getConnection(n) { return this.connectionManager.get(n); }
                    register(n) { if (!c.isTopology(n))
                        throw r(new Error("topology must be an instance of interfaces/topology"), e); const t = parseInt(1e9 * Math.random()).toString(36) + Date.now(); return this.topologies.set(t, n), n.registrar = this, t; }
                    unregister(n) { return this.topologies.delete(n); }
                    _onDisconnect(n, t) { for (const [, s] of this.topologies)
                        s.disconnect(n.remotePeer, t); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = () => { };
                E.exports = d(class {
                    constructor({ min: e = 0, max: c = 1 / 0, handlers: n = {} }) { this.min = e, this.max = c, this._onConnect = n.onConnect || r, this._onDisconnect = n.onDisconnect || r, this.peers = new Set; }
                    set registrar(e) { this._registrar = e; }
                    disconnect(e) { this._onDisconnect(e); }
                }, { className: "Topology", symbolName: "@libp2p/js-interfaces/topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p-ping");
                r.error = d("libp2p-ping:error");
                const e = f(0), c = f(39), n = f(27), { toBuffer: t } = f(124), { collect: s, take: u } = f(55), { PROTOCOL: i, PING_LENGTH: o } = f(921);
                (m = E.exports = async function (h, a) { r("dialing %s to %s", i, a.toB58String ? a.toB58String() : a); const { stream: l } = await h.dialProtocol(a, i), p = new Date, g = c.randomBytes(o), [b] = await n([g], l, v => u(1, v), t, s), I = Date.now(); if (!g.equals(b))
                    throw e(new Error("Received wrong ping ack"), "ERR_WRONG_PING_ACK"); return I - p; }).mount = function (h) { h.handle(i, ({ stream: a }) => n(a, a)); }, m.unmount = function (h) { h.unhandle(i); };
            }, function (E, m, f) {
                "use strict";
                E.exports = { PROTOCOL: "/ipfs/ping/1.0.0", PING_LENGTH: 32 };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:identify");
                r.error = d("libp2p:identify:error");
                const e = f(0), c = f(923), n = f(35), t = f(27), { collect: s, take: u, consume: i } = f(55), o = f(6), h = f(7), a = f(13), { toBuffer: l } = f(124), p = f(925), g = f(193), b = f(346), { MULTICODEC_IDENTIFY: I, MULTICODEC_IDENTIFY_PUSH: v, AGENT_VERSION: R, PROTOCOL_VERSION: _ } = f(335), { codes: k } = f(28);
                class x {
                    static getCleanMultiaddr(N) { if (N && N.length > 0)
                        try {
                            return a(N);
                        }
                        catch (S) {
                            return null;
                        } return null; }
                    constructor({ libp2p: N, protocols: S }) { this.peerStore = N.peerStore, this.connectionManager = N.connectionManager, this.connectionManager.on("peer:connect", T => { const B = T.remotePeer; this.identify(T, B).catch(r.error); }), this.peerId = N.peerId, this._libp2p = N, this._protocols = S, this.handleMessage = this.handleMessage.bind(this), this._host = { agentVersion: R, protocolVersion: _, ...N._options.host }, this.peerStore.metadataBook.set(this.peerId, "AgentVersion", o(this._host.agentVersion)), this.peerStore.metadataBook.set(this.peerId, "ProtocolVersion", o(this._host.protocolVersion)); }
                    async push(N) { const S = await this._getSelfPeerRecord(), T = this._libp2p.multiaddrs.map(L => L.bytes), B = Array.from(this._protocols.keys()), P = N.map(async (L) => { try {
                        const { stream: j } = await L.newStream(v);
                        await t([{ listenAddrs: T, signedPeerRecord: S, protocols: B }], c.encode(p), j, i);
                    }
                    catch (j) {
                        r.error("could not push identify update to peer", j);
                    } }); return Promise.all(P); }
                    pushToPeerStore(N) { const S = []; let T; for (const B of N.peers.values())
                        B.protocols.includes(v) && (T = this.connectionManager.get(B.id)) && S.push(T); this.push(S); }
                    async identify(N) { const { stream: S } = await N.newStream(I), [T] = await t([], S, n.decode(), u(1), l, s); if (!T)
                        throw e(new Error("No data could be retrieved"), k.ERR_CONNECTION_ENDED); let B; try {
                        B = p.decode(T);
                    }
                    catch (X) {
                        throw e(X, k.ERR_INVALID_MESSAGE);
                    } let { publicKey: P, listenAddrs: L, protocols: j, observedAddr: D, signedPeerRecord: G } = B; const W = await h.createFromPubKey(P); if (N.remotePeer.toB58String() !== W.toB58String())
                        throw e(new Error("identified peer does not match the expected peer"), k.ERR_INVALID_PEER); D = x.getCleanMultiaddr(D); try {
                        const X = await g.openAndCertify(G, b.DOMAIN);
                        if (this.peerStore.addressBook.consumePeerRecord(X))
                            return void this.peerStore.protoBook.set(W, j);
                    }
                    catch (X) {
                        r("received invalid envelope, discard it and fallback to listenAddrs is available", X);
                    } try {
                        this.peerStore.addressBook.set(W, L.map(X => a(X)));
                    }
                    catch (X) {
                        r.error("received invalid addrs", X);
                    } this.peerStore.protoBook.set(W, j), this.peerStore.metadataBook.set(W, "AgentVersion", o(B.agentVersion)), r("received observed address of %s", D); }
                    handleMessage({ connection: N, stream: S, protocol: T }) { switch (T) {
                        case I: return this._handleIdentify({ connection: N, stream: S });
                        case v: return this._handlePush({ connection: N, stream: S });
                        default: r.error("cannot handle unknown protocol %s", T);
                    } }
                    async _handleIdentify({ connection: N, stream: S }) { let T = new Uint8Array(0); this.peerId.pubKey && (T = this.peerId.pubKey.bytes); const B = await this._getSelfPeerRecord(), P = p.encode({ protocolVersion: this._host.protocolVersion, agentVersion: this._host.agentVersion, publicKey: T, listenAddrs: this._libp2p.multiaddrs.map(L => L.bytes), signedPeerRecord: B, observedAddr: N.remoteAddr.bytes, protocols: Array.from(this._protocols.keys()) }); try {
                        await t([P], n.encode(), S, i);
                    }
                    catch (L) {
                        r.error("could not respond to identify request", L);
                    } }
                    async _handlePush({ connection: N, stream: S }) { let T; try {
                        const [P] = await t([], S, n.decode(), u(1), l, s);
                        T = p.decode(P);
                    }
                    catch (P) {
                        return r.error("received invalid message", P);
                    } const B = N.remotePeer; try {
                        const P = await g.openAndCertify(T.signedPeerRecord, b.DOMAIN);
                        if (this.peerStore.addressBook.consumePeerRecord(P))
                            return void this.peerStore.protoBook.set(B, T.protocols);
                    }
                    catch (P) {
                        r("received invalid envelope, discard it and fallback to listenAddrs is available", P);
                    } try {
                        this.peerStore.addressBook.set(B, T.listenAddrs.map(P => a(P)));
                    }
                    catch (P) {
                        r.error("received invalid addrs", P);
                    } this.peerStore.protoBook.set(B, T.protocols); }
                    async _getSelfPeerRecord() { const N = this.peerStore.addressBook.getRawEnvelope(this.peerId); if (N)
                        return N; try {
                        const S = new b({ peerId: this.peerId, multiaddrs: this._libp2p.multiaddrs }), T = await g.seal(S, this.peerId);
                        return this.peerStore.addressBook.consumePeerRecord(T), this.peerStore.addressBook.getRawEnvelope(this.peerId);
                    }
                    catch (S) {
                        r.error("failed to get self peer record");
                    } return null; }
                }
                E.exports.IdentifyService = x, E.exports.multicodecs = { IDENTIFY: I, IDENTIFY_PUSH: v }, E.exports.Message = p;
            }, function (E, m, f) {
                "use strict";
                const d = f(35), r = f(924), e = f(124);
                E.exports.encode = c => n => d.encode()(r.encode(c)(n)), E.exports.decode = c => n => r.decode(c)(e(d.decode()(n))), E.exports.it = r;
            }, function (E, m, f) {
                "use strict";
                E.exports.encode = d => r => async function* () { for await (const e of r)
                    yield d.encode(e); }(), E.exports.decode = d => r => async function* () { for await (const e of r)
                    yield d.decode(e); }();
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
message Identify {
  // protocolVersion determines compatibility between peers
  optional string protocolVersion = 5; // e.g. ipfs/1.0.0

  // agentVersion is like a UserAgent string in browsers, or client version in bittorrent
  // includes the client name and client.
  optional string agentVersion = 6; // e.g. go-ipfs/0.1.0

  // publicKey is this node's public key (which also gives its node.ID)
  // - may not need to be sent, as secure channel implies it has been sent.
  // - then again, if we change / disable secure channel, may still want it.
  optional bytes publicKey = 1;

  // listenAddrs are the multiaddrs the sender node listens for open connections on
  repeated bytes listenAddrs = 2;

  // oservedAddr is the multiaddr of the remote endpoint that the sender node perceives
  // this is useful information to convey to the other side, as it helps the remote endpoint
  // determine whether its connection to the local peer goes through NAT.
  optional bytes observedAddr = 4;

  repeated string protocols = 3;

  // signedPeerRecord contains a serialized SignedEnvelope containing a PeerRecord,
  // signed by the sending node. It contains the same addresses as the listenAddrs field, but
  // in a form that lets us share authenticated addrs with other peers.
  optional bytes signedPeerRecord = 8;
}
`).Identify;
            }, function (E, m, f) {
                "use strict";
                const d = f(927), r = f(949), e = f(990), { NOISE: c } = f(996), n = f(1038), t = f(325), s = f(279);
                E.exports = () => ({ dialer: { maxParallelDials: 150, maxDialsPerPeer: 4, dialTimeout: 1e4 }, modules: { transport: [d, r], streamMuxer: [e], connEncryption: [c], peerDiscovery: [], dht: n, pubsub: t }, config: { peerDiscovery: { autoDial: !0, bootstrap: { enabled: !0 }, webRTCStar: { enabled: !0 } }, dht: { kBucketSize: 20, enabled: !1, clientMode: !0, randomWalk: { enabled: !1 }, validators: { ipns: s.validator }, selectors: { ipns: s.selector } }, pubsub: { enabled: !0, emitSelf: !0 } }, metrics: { enabled: !0 }, peerStore: { persistence: !0, threshold: 1 } });
            }, function (E, m, f) {
                "use strict";
                const d = f(928), r = f(60), e = f(26), c = f(289), { AbortError: n } = f(45), t = f(1)("libp2p:websockets"), s = f(939), u = f(940), { CODE_CIRCUIT: i, CODE_P2P: o } = f(347);
                E.exports = e(class {
                    constructor({ upgrader: h }) { if (!h)
                        throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader."); this._upgrader = h; }
                    async dial(h, a = {}) { t("dialing %s", h); const l = await this._connect(h, a), p = u(l, { remoteAddr: h, signal: a.signal }); t("new outbound connection %s", p.remoteAddr); const g = await this._upgrader.upgradeOutbound(p); return t("outbound connection %s upgraded", p.remoteAddr), g; }
                    async _connect(h, a = {}) { if (a.signal && a.signal.aborted)
                        throw new n; const l = h.toOptions(); t("dialing %s:%s", l.host, l.port); const p = d(c(h), Object.assign({ binary: !0 }, a)); if (!a.signal)
                        return await p.connected(), t("connected %s", h), p; let g; const b = new Promise((I, v) => { if (g = () => { v(new n), p.close(); }, a.signal.aborted)
                        return g(); a.signal.addEventListener("abort", g); }); try {
                        await Promise.race([b, p.connected()]);
                    }
                    finally {
                        a.signal.removeEventListener("abort", g);
                    } return t("connected %s", h), p; }
                    createListener(h = {}, a) { return typeof h == "function" && (a = h, h = {}), s({ handler: a, upgrader: this._upgrader }, h); }
                    filter(h) { return (h = Array.isArray(h) ? h : [h]).filter(a => !a.protoCodes().includes(i) && (r.WebSockets.matches(a.decapsulateCode(o)) || r.WebSocketsSecure.matches(a.decapsulateCode(o)))); }
                }, { className: "WebSockets", symbolName: "@libp2p/js-libp2p-websockets/websockets" });
            }, function (E, m, f) {
                "use strict";
                var d = f(929), r = f(931), e = f(937);
                E.exports = function (c, n = {}) { const t = typeof window == "undefined" ? {} : window.location, s = e(c, t), u = new d(s, n.websocket), i = r(u, n); return i.remoteAddress = s, i.close = () => new Promise((o, h) => { u.addEventListener("close", o), u.close(); }), i.destroy = () => { u.terminate ? u.terminate() : u.close(); }, i.socket = u, i; }, E.exports.connect = E.exports;
            }, function (E, m, f) {
                "use strict";
                E.exports = typeof WebSocket == "undefined" ? f(930) : WebSocket;
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                const d = f(932), r = f(935);
                E.exports = (e, c) => { (c = c || {}).binaryType ? e.binaryType = c.binaryType : c.binary && (e.binaryType = "arraybuffer"); const n = { sink: r(e, c), source: d(e, c), connected: () => n.source.connected() }; return n; };
            }, function (E, m, f) {
                "use strict";
                const { Buffer: d } = f(3), { EventIterator: r } = f(933);
                E.exports = e => { const c = e.removeEventListener || e.removeListener, n = async function* () { const u = new r(({ push: o, stop: h, fail: a }) => (e.addEventListener("message", o), e.addEventListener("error", a), e.addEventListener("close", h), () => { c.call(e, "message", o), c.call(e, "error", a), c.call(e, "close", h); }), { highWaterMark: 1 / 0 }); for await (const { data: o } of u)
                    yield (i = o, i instanceof ArrayBuffer || i != null && i.constructor != null && i.constructor.name === "ArrayBuffer" && typeof i.byteLength == "number" ? d.from(o) : o); var i; }(); let t, s = e.readyState === 1; return e.addEventListener("open", () => { s = !0, t = null; }), e.addEventListener("close", () => { s = !1, t = null; }), e.addEventListener("error", u => { s || (t = u); }), n.connected = () => new Promise((u, i) => { if (s)
                    return u(); if (t)
                    return i(t); const o = l => { c.call(e, "open", h), c.call(e, "error", a), l(); }, h = () => o(u), a = l => o(() => i(l)); e.addEventListener("open", h), e.addEventListener("error", a); }), n; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 });
                const d = f(934);
                m.EventIterator = d.EventIterator, m.subscribe = function (r, e, c) { return new d.EventIterator(({ push: n }) => (this.addEventListener(r, n, e), () => this.removeEventListener(r, n, e)), c); }, m.default = d.EventIterator;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 });
                class d {
                    constructor() { this.pullQueue = [], this.pushQueue = [], this.eventHandlers = {}, this.isPaused = !1, this.isStopped = !1; }
                    push(c) { if (this.isStopped)
                        return; const n = { value: c, done: !1 }; if (this.pullQueue.length) {
                        const t = this.pullQueue.shift();
                        t && t.resolve(n);
                    }
                    else
                        this.pushQueue.push(Promise.resolve(n)), this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused && (this.isPaused = !0, this.eventHandlers.highWater ? this.eventHandlers.highWater() : console && console.warn(`EventIterator queue reached ${this.pushQueue.length} items`)); }
                    stop() { if (!this.isStopped) {
                        this.isStopped = !0, this.remove();
                        for (const c of this.pullQueue)
                            c.resolve({ value: void 0, done: !0 });
                        this.pullQueue.length = 0;
                    } }
                    fail(c) { if (!this.isStopped)
                        if (this.isStopped = !0, this.remove(), this.pullQueue.length) {
                            for (const n of this.pullQueue)
                                n.reject(c);
                            this.pullQueue.length = 0;
                        }
                        else {
                            const n = Promise.reject(c);
                            n.catch(() => { }), this.pushQueue.push(n);
                        } }
                    remove() { Promise.resolve().then(() => { this.removeCallback && this.removeCallback(); }); }
                    [Symbol.asyncIterator]() { return { next: c => { const n = this.pushQueue.shift(); return n ? (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused && (this.isPaused = !1, this.eventHandlers.lowWater && this.eventHandlers.lowWater()), n) : this.isStopped ? Promise.resolve({ value: void 0, done: !0 }) : new Promise((t, s) => { this.pullQueue.push({ resolve: t, reject: s }); }); }, return: () => (this.isStopped = !0, this.pushQueue.length = 0, this.remove(), Promise.resolve({ value: void 0, done: !0 })) }; }
                }
                class r {
                    constructor(c, { highWaterMark: n = 100, lowWaterMark: t = 1 } = {}) { const s = new d; s.highWaterMark = n, s.lowWaterMark = t, s.removeCallback = c({ push: u => s.push(u), stop: () => s.stop(), fail: u => s.fail(u), on: (u, i) => { s.eventHandlers[u] = i; } }) || (() => { }), this[Symbol.asyncIterator] = () => s[Symbol.asyncIterator](), Object.freeze(this); }
                }
                m.EventIterator = r, m.default = r;
            }, function (E, m, f) {
                "use strict";
                const d = f(936);
                E.exports = (r, e) => ((e = e || {}).closeOnEnd = e.closeOnEnd !== !1, async (c) => { for await (const n of c) {
                    try {
                        await d(r);
                    }
                    catch (t) {
                        if (t.message === "socket closed")
                            break;
                        throw t;
                    }
                    r.send(n);
                } if (e.closeOnEnd && r.readyState <= 1)
                    return new Promise((n, t) => { r.addEventListener("close", s => { if (s.wasClean || s.code === 1006)
                        n();
                    else {
                        const u = Object.assign(new Error("ws error"), { event: s });
                        t(u);
                    } }), setTimeout(() => r.close()); }); });
            }, function (E, m, f) {
                "use strict";
                E.exports = async (d) => { if (d.readyState >= 2)
                    throw new Error("socket closed"); if (d.readyState !== 1)
                    return new Promise((r, e) => { const c = d && (d.removeEventListener || d.removeListener); function n() { typeof c == "function" && (c.call(d, "open", t), c.call(d, "error", s)); } function t() { n(), r(); } function s(u) { n(), e(u); } d.addEventListener("open", t), d.addEventListener("error", s); }); };
            }, function (E, m, f) {
                "use strict";
                const d = f(938), r = { http: "ws", https: "wss" };
                E.exports = (e, c) => d(e, c, r, "ws");
            }, function (E, m, f) {
                "use strict";
                var d = f(161);
                E.exports = function (r, e, c, n) { var t; return c = c || {}, t = (r = d.parse(r, !1, !0)).protocol ? r.protocol : (c[t = e.protocol ? e.protocol.replace(/:$/, "") : "http"] || n || t) + ":", r.host && r.host[0] === ":" && (r.host = null), r.hostname ? d.format({ protocol: t, slashes: !0, hostname: r.hostname, port: r.port, pathname: r.pathname, search: r.search }) : (r.host = e.host, r.port ? d.format({ protocol: t, slashes: !0, host: e.hostname + ":" + r.port, port: r.port, pathname: r.pathname, search: r.search }) : r.pathname ? d.format({ protocol: t, slashes: !0, host: r.host, pathname: r.pathname, search: r.search }) : (r.pathname = e.pathname, r.search ? d.format({ protocol: t, slashes: !0, host: r.host, pathname: r.pathname, search: r.search }) : (r.search = e.search, r.format(r)))); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { throw new Error("WebSocket Servers can not be created in the browser!"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(45), { CLOSE_TIMEOUT: r } = f(347), e = f(348), c = f(62), n = f(1), t = n("libp2p:websockets:socket");
                t.error = n("libp2p:websockets:socket:error"), E.exports = (s, u = {}) => { const i = { async sink(o) { u.signal && (o = d(o, u.signal)); try {
                        await s.sink(async function* () { for await (const h of o)
                            yield h instanceof Uint8Array ? h : h.slice(); }());
                    }
                    catch (h) {
                        h.type !== "aborted" && t.error(h);
                    } }, source: u.signal ? d(s.source, u.signal) : s.source, conn: s, localAddr: u.localAddr || (s.localAddress && s.localPort ? e(s.localAddress, s.localPort) : void 0), remoteAddr: u.remoteAddr || e(s.remoteAddress, s.remotePort), timeline: { open: Date.now() }, async close() { const o = Date.now(); try {
                        await c(s.close(), r);
                    }
                    catch (h) {
                        const { host: a, port: l } = i.remoteAddr.toOptions();
                        t("timeout closing stream to %s:%s after %dms, destroying it manually", a, l, Date.now() - o), s.destroy();
                    }
                    finally {
                        i.timeline.close = Date.now();
                    } } }; return s.socket.once && s.socket.once("close", () => { i.timeline.close || (i.timeline.close = Date.now()); }), i; };
            }, function (E, m, f) {
                "use strict";
                m.Address4 = f(349), m.Address6 = f(942), m.v6 = { helpers: f(354) };
            }, function (E, m, f) {
                "use strict";
                var d = f(350).BigInteger, r = f(100).sprintf, e = f(943), c = f(352), n = f(353), t = f(944), s = f(945), u = f(201), i = f(202), o = f(349);
                function h(g) { return g = (g = g.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2')).replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2'); }
                function a(g, b) { this.groups = b === void 0 ? i.GROUPS : b, this.v4 = !1, this.subnet = "/128", this.subnetMask = 128, this.zone = "", this.address = g; var I = i.RE_SUBNET_STRING.exec(g); if (I) {
                    if (this.parsedSubnet = I[0].replace("/", ""), this.subnetMask = parseInt(this.parsedSubnet, 10), this.subnet = "/" + this.subnetMask, isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > i.BITS)
                        return this.valid = !1, void (this.error = "Invalid subnet mask.");
                    g = g.replace(i.RE_SUBNET_STRING, "");
                }
                else if (/\//.test(g))
                    return this.valid = !1, void (this.error = "Invalid subnet mask."); var v = i.RE_ZONE_STRING.exec(g); v && (this.zone = v[0], g = g.replace(i.RE_ZONE_STRING, "")), this.addressMinusSuffix = g, this.parsedAddress = this.parse(this.addressMinusSuffix); }
                function l(g) { return r("%04x", parseInt(g, 16)); }
                function p(g) { return 255 & g; }
                e(a.prototype, f(946)), e(a.prototype, f(947)), e(a.prototype, f(948)), a.fromBigInteger = function (g) { var b, I = c(g.toString(16), 32, "0"), v = []; for (b = 0; b < i.GROUPS; b++)
                    v.push(I.slice(4 * b, 4 * (b + 1))); return new a(v.join(":")); }, a.fromURL = function (g) { var b, I, v; if (g.indexOf("[") !== -1 && g.indexOf("]:") !== -1) {
                    if ((v = i.RE_URL_WITH_PORT.exec(g)) === null)
                        return { error: "failed to parse address with port", address: null, port: null };
                    b = v[1], I = v[2];
                }
                else if (g.indexOf("/") !== -1) {
                    if (g = g.replace(/^[a-z0-9]+:\/\//, ""), (v = i.RE_URL.exec(g)) === null)
                        return { error: "failed to parse address from URL", address: null, port: null };
                    b = v[1];
                }
                else
                    b = g; return I ? ((I = parseInt(I, 10)) < 0 || I > 65536) && (I = null) : I = null, { address: new a(b), port: I }; }, a.fromAddress4 = function (g) { g = new o(g); var b = i.BITS - (u.BITS - g.subnetMask); return new a("::ffff:" + g.correctForm() + "/" + b); }, a.fromArpa = function (g) { var b = g.replace(/(\.ip6\.arpa)?\.$/, ""); if (b.length !== 63)
                    return b = { error: "Not Valid 'ip6.arpa' form", address: null }; b = b.split(".").reverse(); for (var I = 7; I > 0; I--) {
                    var v = 4 * I;
                    b.splice(v, 0, ":");
                } return new a(b = b.join("")); }, a.prototype.microsoftTranscription = function () { return r("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-")); }, a.prototype.mask = function (g) { return g === void 0 && (g = this.subnetMask), this.getBitsBase2(0, g); }, a.prototype.possibleSubnets = function (g) { g === void 0 && (g = 128); var b = i.BITS - this.subnetMask - Math.abs(g - i.BITS); return b < 0 ? "0" : function (I) { for (var v = /(\d+)(\d{3})/; v.test(I);)
                    I = I.replace(v, "$1,$2"); return I; }(new d("2", 10).pow(b).toString(10)); }, a.prototype._startAddress = function () { return new d(this.mask() + n("0", i.BITS - this.subnetMask), 2); }, a.prototype.startAddress = function () { return a.fromBigInteger(this._startAddress()); }, a.prototype.startAddressExclusive = function () { var g = new d("1"); return a.fromBigInteger(this._startAddress().add(g)); }, a.prototype._endAddress = function () { return new d(this.mask() + n("1", i.BITS - this.subnetMask), 2); }, a.prototype.endAddress = function () { return a.fromBigInteger(this._endAddress()); }, a.prototype.endAddressExclusive = function () { var g = new d("1"); return a.fromBigInteger(this._endAddress().subtract(g)); }, a.prototype.getScope = function () { var g = i.SCOPES[this.getBits(12, 16)]; return this.getType() === "Global unicast" && g !== "Link local" && (g = "Global"), g; }, a.prototype.getType = function () { var g = this; return t(i.TYPES, function (b, I) { return g.isInSubnet(new a(I)); }) || "Global unicast"; }, a.prototype.getBits = function (g, b) { return new d(this.getBitsBase2(g, b), 2); }, a.prototype.getBitsBase2 = function (g, b) { return this.binaryZeroPad().slice(g, b); }, a.prototype.getBitsBase16 = function (g, b) { var I = b - g; return I % 4 != 0 ? null : c(this.getBits(g, b).toString(16), I / 4, "0"); }, a.prototype.getBitsPastSubnet = function () { return this.getBitsBase2(this.subnetMask, i.BITS); }, a.prototype.reverseForm = function (g) { g || (g = {}); var b = Math.floor(this.subnetMask / 4), I = this.canonicalForm().replace(/:/g, "").split("").slice(0, b).reverse().join("."); return b > 0 ? g.omitSuffix ? I : r("%s.ip6.arpa.", I) : g.omitSuffix ? "" : "ip6.arpa."; }, a.prototype.correctForm = function () { if (!this.parsedAddress)
                    return null; var g, b = [], I = 0, v = []; for (g = 0; g < this.parsedAddress.length; g++) {
                    var R = parseInt(this.parsedAddress[g], 16);
                    R === 0 && I++, R !== 0 && I > 0 && (I > 1 && v.push([g - I, g - 1]), I = 0);
                } I > 1 && v.push([this.parsedAddress.length - I, this.parsedAddress.length - 1]); var _ = v.map(function (M) { return M[1] - M[0] + 1; }); if (v.length > 0) {
                    var k = _.indexOf(s(_));
                    b = function (M, N) { var S, T = [], B = []; for (S = 0; S < M.length; S++)
                        S < N[0] ? T.push(M[S]) : S > N[1] && B.push(M[S]); return T.concat(["compact"]).concat(B); }(this.parsedAddress, v[k]);
                }
                else
                    b = this.parsedAddress; for (g = 0; g < b.length; g++)
                    b[g] !== "compact" && (b[g] = parseInt(b[g], 16).toString(16)); var x = b.join(":"); return x = (x = (x = x.replace(/^compact$/, "::")).replace(/^compact|compact$/, ":")).replace(/compact/, ""); }, a.prototype.binaryZeroPad = function () { return c(this.bigInteger().toString(2), i.BITS, "0"); }, a.prototype.parse4in6 = function (g) { var b = g.split(":"), I = b.slice(-1)[0].match(u.RE_ADDRESS); if (I) {
                    for (var v = new o(I[0]), R = 0; R < v.groups; R++)
                        if (/^0[0-9]+/.test(v.parsedAddress[R]))
                            return this.valid = !1, this.error = "IPv4 addresses can not have leading zeroes.", this.parseError = g.replace(u.RE_ADDRESS, v.parsedAddress.map(h).join(".")), null;
                    this.v4 = !0, b[b.length - 1] = v.toGroup6(), g = b.join(":");
                } return g; }, a.prototype.parse = function (g) { if (g = this.parse4in6(g), this.error)
                    return null; var b = g.match(i.RE_BAD_CHARACTERS); if (b)
                    return this.valid = !1, this.error = r("Bad character%s detected in address: %s", b.length > 1 ? "s" : "", b.join("")), this.parseError = g.replace(i.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'), null; var I = g.match(i.RE_BAD_ADDRESS); if (I)
                    return this.valid = !1, this.error = r("Address failed regex: %s", I.join("")), this.parseError = g.replace(i.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'), null; var v = [], R = g.split("::"); if (R.length === 2) {
                    var _ = R[0].split(":"), k = R[1].split(":");
                    _.length === 1 && _[0] === "" && (_ = []), k.length === 1 && k[0] === "" && (k = []);
                    var x = this.groups - (_.length + k.length);
                    if (!x)
                        return this.valid = !1, this.error = "Error parsing groups", null;
                    this.elidedGroups = x, this.elisionBegin = _.length, this.elisionEnd = _.length + this.elidedGroups, _.forEach(function (N) { v.push(N); });
                    for (var M = 0; M < x; M++)
                        v.push(0);
                    k.forEach(function (N) { v.push(N); });
                }
                else {
                    if (R.length !== 1)
                        return this.valid = !1, this.error = "Too many :: groups found", null;
                    v = g.split(":"), this.elidedGroups = 0;
                } return (v = v.map(function (N) { return r("%x", parseInt(N, 16)); })).length !== this.groups ? (this.valid = !1, this.error = "Incorrect number of groups found", null) : (this.valid = !0, v); }, a.prototype.canonicalForm = function () { return this.valid ? this.parsedAddress.map(l).join(":") : null; }, a.prototype.decimal = function () { return this.valid ? this.parsedAddress.map(function (g) { return r("%05d", parseInt(g, 16)); }).join(":") : null; }, a.prototype.bigInteger = function () { return this.valid ? new d(this.parsedAddress.map(l).join(""), 16) : null; }, a.prototype.to4 = function () { var g = this.binaryZeroPad().split(""); return o.fromHex(new d(g.slice(96, 128).join(""), 2).toString(16)); }, a.prototype.to4in6 = function () { var g = this.to4(), b = new a(this.parsedAddress.slice(0, 6).join(":"), 6), I = b.correctForm(), v = ""; return /:$/.test(I) || (v = ":"), b.correctForm() + v + g.address; }, a.prototype.inspectTeredo = function () { var g = this.getBitsBase16(0, 32), b = this.getBits(80, 96).xor(new d("ffff", 16)).toString(), I = o.fromHex(this.getBitsBase16(32, 64)), v = o.fromHex(this.getBits(96, 128).xor(new d("ffffffff", 16)).toString(16)), R = this.getBits(64, 80), _ = this.getBitsBase2(64, 80), k = R.testBit(15), x = R.testBit(14), M = R.testBit(8), N = R.testBit(9), S = new d(_.slice(2, 6) + _.slice(8, 16), 2).toString(10); return { prefix: r("%s:%s", g.slice(0, 4), g.slice(4, 8)), server4: I.address, client4: v.address, flags: _, coneNat: k, microsoft: { reserved: x, universalLocal: N, groupIndividual: M, nonce: S }, udpPort: b }; }, a.prototype.inspect6to4 = function () { var g = this.getBitsBase16(0, 16), b = o.fromHex(this.getBitsBase16(16, 48)); return { prefix: r("%s", g.slice(0, 4)), gateway: b.address }; }, a.prototype.to6to4 = function () { return this.is4() ? new a(["2002", this.getBitsBase16(96, 112), this.getBitsBase16(112, 128), "", "/16"].join(":")) : null; }, a.prototype.toByteArray = function () { var g = this.bigInteger().toByteArray(); return g.length === 17 && g[0] === 0 ? g.slice(1) : g; }, a.prototype.toUnsignedByteArray = function () { return this.toByteArray().map(p); }, a.fromByteArray = function (g) { return this.fromUnsignedByteArray(g.map(p)); }, a.fromUnsignedByteArray = function (g) { for (var b = new d("256", 10), I = new d("0", 10), v = new d("1", 10), R = g.length - 1; R >= 0; R--)
                    I = I.add(v.multiply(new d(g[R].toString(10), 10))), v = v.multiply(b); return a.fromBigInteger(I); }, E.exports = a;
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e = /^\[object .+?Constructor\]$/, c = /^(?:0|[1-9]\d*)$/, n = {}; n["[object Float32Array]"] = n["[object Float64Array]"] = n["[object Int8Array]"] = n["[object Int16Array]"] = n["[object Int32Array]"] = n["[object Uint8Array]"] = n["[object Uint8ClampedArray]"] = n["[object Uint16Array]"] = n["[object Uint32Array]"] = !0, n["[object Arguments]"] = n["[object Array]"] = n["[object ArrayBuffer]"] = n["[object Boolean]"] = n["[object DataView]"] = n["[object Date]"] = n["[object Error]"] = n["[object Function]"] = n["[object Map]"] = n["[object Number]"] = n["[object Object]"] = n["[object RegExp]"] = n["[object Set]"] = n["[object String]"] = n["[object WeakMap]"] = !1; var t = typeof d == "object" && d && d.Object === Object && d, s = typeof self == "object" && self && self.Object === Object && self, u = t || s || Function("return this")(), i = m && !m.nodeType && m, o = i && typeof r == "object" && r && !r.nodeType && r, h = o && o.exports === i, a = h && t.process, l = function () { try {
                    var ft = o && o.require && o.require("util").types;
                    return ft || a && a.binding && a.binding("util");
                }
                catch (gt) { } }(), p = l && l.isTypedArray; function g(ft, gt, bt) { switch (bt.length) {
                    case 0: return ft.call(gt);
                    case 1: return ft.call(gt, bt[0]);
                    case 2: return ft.call(gt, bt[0], bt[1]);
                    case 3: return ft.call(gt, bt[0], bt[1], bt[2]);
                } return ft.apply(gt, bt); } var b, I, v, R = Array.prototype, _ = Function.prototype, k = Object.prototype, x = u["__core-js_shared__"], M = _.toString, N = k.hasOwnProperty, S = (b = /[^.]+$/.exec(x && x.keys && x.keys.IE_PROTO || "")) ? "Symbol(src)_1." + b : "", T = k.toString, B = M.call(Object), P = RegExp("^" + M.call(N).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), L = h ? u.Buffer : void 0, j = u.Symbol, D = u.Uint8Array, G = L ? L.allocUnsafe : void 0, W = (I = Object.getPrototypeOf, v = Object, function (ft) { return I(v(ft)); }), X = Object.create, Q = k.propertyIsEnumerable, K = R.splice, F = j ? j.toStringTag : void 0, Y = function () { try {
                    var ft = vt(Object, "defineProperty");
                    return ft({}, "", {}), ft;
                }
                catch (gt) { } }(), $ = L ? L.isBuffer : void 0, y = Math.max, C = Date.now, A = vt(u, "Map"), U = vt(Object, "create"), z = function () { function ft() { } return function (gt) { if (!St(gt))
                    return {}; if (X)
                    return X(gt); ft.prototype = gt; var bt = new ft; return ft.prototype = void 0, bt; }; }(); function w(ft) { var gt = -1, bt = ft == null ? 0 : ft.length; for (this.clear(); ++gt < bt;) {
                    var _t = ft[gt];
                    this.set(_t[0], _t[1]);
                } } function O(ft) { var gt = -1, bt = ft == null ? 0 : ft.length; for (this.clear(); ++gt < bt;) {
                    var _t = ft[gt];
                    this.set(_t[0], _t[1]);
                } } function q(ft) { var gt = -1, bt = ft == null ? 0 : ft.length; for (this.clear(); ++gt < bt;) {
                    var _t = ft[gt];
                    this.set(_t[0], _t[1]);
                } } function H(ft) { var gt = this.__data__ = new O(ft); this.size = gt.size; } function V(ft, gt) { var bt = Ft(ft), _t = !bt && Ct(ft), Lt = !bt && !_t && jt(ft), Pt = !bt && !_t && !Lt && ne(ft), Mt = bt || _t || Lt || Pt, Yt = Mt ? function (he, Gt) { for (var Ut = -1, de = Array(he); ++Ut < he;)
                    de[Ut] = Gt(Ut); return de; }(ft.length, String) : [], Dt = Yt.length; for (var zt in ft)
                    !gt && !N.call(ft, zt) || Mt && (zt == "length" || Lt && (zt == "offset" || zt == "parent") || Pt && (zt == "buffer" || zt == "byteLength" || zt == "byteOffset") || Rt(zt, Dt)) || Yt.push(zt); return Yt; } function J(ft, gt, bt) { (bt !== void 0 && !Wt(ft[gt], bt) || bt === void 0 && !(gt in ft)) && nt(ft, gt, bt); } function Z(ft, gt, bt) { var _t = ft[gt]; N.call(ft, gt) && Wt(_t, bt) && (bt !== void 0 || gt in ft) || nt(ft, gt, bt); } function tt(ft, gt) { for (var bt = ft.length; bt--;)
                    if (Wt(ft[bt][0], gt))
                        return bt; return -1; } function nt(ft, gt, bt) { gt == "__proto__" && Y ? Y(ft, gt, { configurable: !0, enumerable: !0, value: bt, writable: !0 }) : ft[gt] = bt; } w.prototype.clear = function () { this.__data__ = U ? U(null) : {}, this.size = 0; }, w.prototype.delete = function (ft) { var gt = this.has(ft) && delete this.__data__[ft]; return this.size -= gt ? 1 : 0, gt; }, w.prototype.get = function (ft) { var gt = this.__data__; if (U) {
                    var bt = gt[ft];
                    return bt === "__lodash_hash_undefined__" ? void 0 : bt;
                } return N.call(gt, ft) ? gt[ft] : void 0; }, w.prototype.has = function (ft) { var gt = this.__data__; return U ? gt[ft] !== void 0 : N.call(gt, ft); }, w.prototype.set = function (ft, gt) { var bt = this.__data__; return this.size += this.has(ft) ? 0 : 1, bt[ft] = U && gt === void 0 ? "__lodash_hash_undefined__" : gt, this; }, O.prototype.clear = function () { this.__data__ = [], this.size = 0; }, O.prototype.delete = function (ft) { var gt = this.__data__, bt = tt(gt, ft); return !(bt < 0) && (bt == gt.length - 1 ? gt.pop() : K.call(gt, bt, 1), --this.size, !0); }, O.prototype.get = function (ft) { var gt = this.__data__, bt = tt(gt, ft); return bt < 0 ? void 0 : gt[bt][1]; }, O.prototype.has = function (ft) { return tt(this.__data__, ft) > -1; }, O.prototype.set = function (ft, gt) { var bt = this.__data__, _t = tt(bt, ft); return _t < 0 ? (++this.size, bt.push([ft, gt])) : bt[_t][1] = gt, this; }, q.prototype.clear = function () { this.size = 0, this.__data__ = { hash: new w, map: new (A || O), string: new w }; }, q.prototype.delete = function (ft) { var gt = Tt(this, ft).delete(ft); return this.size -= gt ? 1 : 0, gt; }, q.prototype.get = function (ft) { return Tt(this, ft).get(ft); }, q.prototype.has = function (ft) { return Tt(this, ft).has(ft); }, q.prototype.set = function (ft, gt) { var bt = Tt(this, ft), _t = bt.size; return bt.set(ft, gt), this.size += bt.size == _t ? 0 : 1, this; }, H.prototype.clear = function () { this.__data__ = new O, this.size = 0; }, H.prototype.delete = function (ft) { var gt = this.__data__, bt = gt.delete(ft); return this.size = gt.size, bt; }, H.prototype.get = function (ft) { return this.__data__.get(ft); }, H.prototype.has = function (ft) { return this.__data__.has(ft); }, H.prototype.set = function (ft, gt) { var bt = this.__data__; if (bt instanceof O) {
                    var _t = bt.__data__;
                    if (!A || _t.length < 199)
                        return _t.push([ft, gt]), this.size = ++bt.size, this;
                    bt = this.__data__ = new q(_t);
                } return bt.set(ft, gt), this.size = bt.size, this; }; var rt, it = function (ft, gt, bt) { for (var _t = -1, Lt = Object(ft), Pt = bt(ft), Mt = Pt.length; Mt--;) {
                    var Yt = Pt[rt ? Mt : ++_t];
                    if (gt(Lt[Yt], Yt, Lt) === !1)
                        break;
                } return ft; }; function st(ft) { return ft == null ? ft === void 0 ? "[object Undefined]" : "[object Null]" : F && F in Object(ft) ? function (gt) { var bt = N.call(gt, F), _t = gt[F]; try {
                    gt[F] = void 0;
                    var Lt = !0;
                }
                catch (Mt) { } var Pt = T.call(gt); return Lt && (bt ? gt[F] = _t : delete gt[F]), Pt; }(ft) : function (gt) { return T.call(gt); }(ft); } function at(ft) { return Nt(ft) && st(ft) == "[object Arguments]"; } function ct(ft) { return !(!St(ft) || function (gt) { return !!S && S in gt; }(ft)) && (Kt(ft) ? P : e).test(function (gt) { if (gt != null) {
                    try {
                        return M.call(gt);
                    }
                    catch (bt) { }
                    try {
                        return gt + "";
                    }
                    catch (bt) { }
                } return ""; }(ft)); } function lt(ft) { if (!St(ft))
                    return function (Lt) { var Pt = []; if (Lt != null)
                        for (var Mt in Object(Lt))
                            Pt.push(Mt); return Pt; }(ft); var gt = Bt(ft), bt = []; for (var _t in ft)
                    (_t != "constructor" || !gt && N.call(ft, _t)) && bt.push(_t); return bt; } function pt(ft, gt, bt, _t, Lt) { ft !== gt && it(gt, function (Pt, Mt) { if (Lt || (Lt = new H), St(Pt))
                    !function (Dt, zt, he, Gt, Ut, de, Zt) { var Xt = wt(Dt, he), ie = wt(zt, he), Qt = Zt.get(ie); if (Qt)
                        return void J(Dt, he, Qt); var $t = de ? de(Xt, ie, he + "", Dt, zt, Zt) : void 0, ye = $t === void 0; if (ye) {
                        var se = Ft(ie), Ht = !se && jt(ie), dt = !se && !Ht && ne(ie);
                        $t = ie, se || Ht || dt ? Ft(Xt) ? $t = Xt : Nt(At = Xt) && te(At) ? $t = function (ut, et) { var ht = -1, xt = ut.length; for (et || (et = Array(xt)); ++ht < xt;)
                            et[ht] = ut[ht]; return et; }(Xt) : Ht ? (ye = !1, $t = function (ut, et) { if (et)
                            return ut.slice(); var ht = ut.length, xt = G ? G(ht) : new ut.constructor(ht); return ut.copy(xt), xt; }(ie, !0)) : dt ? (ye = !1, yt = ie, ot = (Et = yt.buffer, It = new Et.constructor(Et.byteLength), new D(It).set(new D(Et)), It), $t = new yt.constructor(ot, yt.byteOffset, yt.length)) : $t = [] : function (ut) { if (!Nt(ut) || st(ut) != "[object Object]")
                            return !1; var et = W(ut); if (et === null)
                            return !0; var ht = N.call(et, "constructor") && et.constructor; return typeof ht == "function" && ht instanceof ht && M.call(ht) == B; }(ie) || Ct(ie) ? ($t = Xt, Ct(Xt) ? $t = function (ut) { return function (et, ht, xt, Jt) { var pe = !xt; xt || (xt = {}); for (var fe = -1, ce = ht.length; ++fe < ce;) {
                            var ue = ht[fe], le = Jt ? Jt(xt[ue], et[ue], ue, xt, et) : void 0;
                            le === void 0 && (le = et[ue]), pe ? nt(xt, ue, le) : Z(xt, ue, le);
                        } return xt; }(ut, Vt(ut)); }(Xt) : St(Xt) && !Kt(Xt) || ($t = function (ut) { return typeof ut.constructor != "function" || Bt(ut) ? {} : z(W(ut)); }(ie))) : ye = !1;
                    } var yt, ot, Et, It, At; ye && (Zt.set(ie, $t), Ut($t, ie, Gt, de, Zt), Zt.delete(ie)), J(Dt, he, $t); }(ft, gt, Mt, bt, pt, _t, Lt);
                else {
                    var Yt = _t ? _t(wt(ft, Mt), Pt, Mt + "", ft, gt, Lt) : void 0;
                    Yt === void 0 && (Yt = Pt), J(ft, Mt, Yt);
                } }, Vt); } function mt(ft, gt) { return kt(function (bt, _t, Lt) { return _t = y(_t === void 0 ? bt.length - 1 : _t, 0), function () { for (var Pt = arguments, Mt = -1, Yt = y(Pt.length - _t, 0), Dt = Array(Yt); ++Mt < Yt;)
                    Dt[Mt] = Pt[_t + Mt]; Mt = -1; for (var zt = Array(_t + 1); ++Mt < _t;)
                    zt[Mt] = Pt[Mt]; return zt[_t] = Lt(Dt), g(bt, this, zt); }; }(ft, gt, Ot), ft + ""); } function Tt(ft, gt) { var bt, _t, Lt = ft.__data__; return ((_t = typeof (bt = gt)) == "string" || _t == "number" || _t == "symbol" || _t == "boolean" ? bt !== "__proto__" : bt === null) ? Lt[typeof gt == "string" ? "string" : "hash"] : Lt.map; } function vt(ft, gt) { var bt = function (_t, Lt) { return _t == null ? void 0 : _t[Lt]; }(ft, gt); return ct(bt) ? bt : void 0; } function Rt(ft, gt) { var bt = typeof ft; return !!(gt = gt !== null && gt !== void 0 ? gt : 9007199254740991) && (bt == "number" || bt != "symbol" && c.test(ft)) && ft > -1 && ft % 1 == 0 && ft < gt; } function Bt(ft) { var gt = ft && ft.constructor; return ft === (typeof gt == "function" && gt.prototype || k); } function wt(ft, gt) { if ((gt !== "constructor" || typeof ft[gt] != "function") && gt != "__proto__")
                    return ft[gt]; } var kt = function (ft) { var gt = 0, bt = 0; return function () { var _t = C(), Lt = 16 - (_t - bt); if (bt = _t, Lt > 0) {
                    if (++gt >= 800)
                        return arguments[0];
                }
                else
                    gt = 0; return ft.apply(void 0, arguments); }; }(Y ? function (ft, gt) { return Y(ft, "toString", { configurable: !0, enumerable: !1, value: (bt = gt, function () { return bt; }), writable: !0 }); var bt; } : Ot); function Wt(ft, gt) { return ft === gt || ft != ft && gt != gt; } var Ct = at(function () { return arguments; }()) ? at : function (ft) { return Nt(ft) && N.call(ft, "callee") && !Q.call(ft, "callee"); }, Ft = Array.isArray; function te(ft) { return ft != null && re(ft.length) && !Kt(ft); } var jt = $ || function () { return !1; }; function Kt(ft) { if (!St(ft))
                    return !1; var gt = st(ft); return gt == "[object Function]" || gt == "[object GeneratorFunction]" || gt == "[object AsyncFunction]" || gt == "[object Proxy]"; } function re(ft) { return typeof ft == "number" && ft > -1 && ft % 1 == 0 && ft <= 9007199254740991; } function St(ft) { var gt = typeof ft; return ft != null && (gt == "object" || gt == "function"); } function Nt(ft) { return ft != null && typeof ft == "object"; } var ne = p ? function (ft) { return function (gt) { return ft(gt); }; }(p) : function (ft) { return Nt(ft) && re(ft.length) && !!n[st(ft)]; }; function Vt(ft) { return te(ft) ? V(ft, !0) : lt(ft); } var qt, ee = (qt = function (ft, gt, bt) { pt(ft, gt, bt); }, mt(function (ft, gt) { var bt = -1, _t = gt.length, Lt = _t > 1 ? gt[_t - 1] : void 0, Pt = _t > 2 ? gt[2] : void 0; for (Lt = qt.length > 3 && typeof Lt == "function" ? (_t--, Lt) : void 0, Pt && function (Yt, Dt, zt) { if (!St(zt))
                    return !1; var he = typeof Dt; return !!(he == "number" ? te(zt) && Rt(Dt, zt.length) : he == "string" && Dt in zt) && Wt(zt[Dt], Yt); }(gt[0], gt[1], Pt) && (Lt = _t < 3 ? void 0 : Lt, _t = 1), ft = Object(ft); ++bt < _t;) {
                    var Mt = gt[bt];
                    Mt && qt(ft, Mt, bt, Lt);
                } return ft; })); function Ot(ft) { return ft; } r.exports = ee; }).call(this, f(10), f(107)(E));
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { var e = "[object Arguments]", c = "[object Map]", n = "[object Object]", t = "[object Set]", s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, u = /^\w*$/, i = /^\./, o = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, h = /^\s+|\s+$/g, a = /\\(\\)?/g, l = /^[-+]0x[0-9a-f]+$/i, p = /^0b[01]+$/i, g = /^\[object .+?Constructor\]$/, b = /^0o[0-7]+$/i, I = /^(?:0|[1-9]\d*)$/, v = {}; v["[object Float32Array]"] = v["[object Float64Array]"] = v["[object Int8Array]"] = v["[object Int16Array]"] = v["[object Int32Array]"] = v["[object Uint8Array]"] = v["[object Uint8ClampedArray]"] = v["[object Uint16Array]"] = v["[object Uint32Array]"] = !0, v[e] = v["[object Array]"] = v["[object ArrayBuffer]"] = v["[object Boolean]"] = v["[object DataView]"] = v["[object Date]"] = v["[object Error]"] = v["[object Function]"] = v[c] = v["[object Number]"] = v[n] = v["[object RegExp]"] = v[t] = v["[object String]"] = v["[object WeakMap]"] = !1; var R = parseInt, _ = typeof d == "object" && d && d.Object === Object && d, k = typeof self == "object" && self && self.Object === Object && self, x = _ || k || Function("return this")(), M = m && !m.nodeType && m, N = M && typeof r == "object" && r && !r.nodeType && r, S = N && N.exports === M && _.process, T = function () { try {
                    return S && S.binding("util");
                }
                catch (dt) { } }(), B = T && T.isTypedArray; function P(dt, yt) { for (var ot = -1, Et = dt ? dt.length : 0; ++ot < Et;)
                    if (yt(dt[ot], ot, dt))
                        return !0; return !1; } function L(dt) { var yt = !1; if (dt != null && typeof dt.toString != "function")
                    try {
                        yt = !!(dt + "");
                    }
                    catch (ot) { } return yt; } function j(dt) { var yt = -1, ot = Array(dt.size); return dt.forEach(function (Et, It) { ot[++yt] = [It, Et]; }), ot; } function D(dt) { var yt = -1, ot = Array(dt.size); return dt.forEach(function (Et) { ot[++yt] = Et; }), ot; } var G, W, X, Q = Array.prototype, K = Function.prototype, F = Object.prototype, Y = x["__core-js_shared__"], $ = (G = /[^.]+$/.exec(Y && Y.keys && Y.keys.IE_PROTO || "")) ? "Symbol(src)_1." + G : "", y = K.toString, C = F.hasOwnProperty, A = F.toString, U = RegExp("^" + y.call(C).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), z = x.Symbol, w = x.Uint8Array, O = F.propertyIsEnumerable, q = Q.splice, H = (W = Object.keys, X = Object, function (dt) { return W(X(dt)); }), V = Math.max, J = ee(x, "DataView"), Z = ee(x, "Map"), tt = ee(x, "Promise"), nt = ee(x, "Set"), rt = ee(x, "WeakMap"), it = ee(Object, "create"), st = Mt(J), at = Mt(Z), ct = Mt(tt), lt = Mt(nt), pt = Mt(rt), mt = z ? z.prototype : void 0, Tt = mt ? mt.valueOf : void 0, vt = mt ? mt.toString : void 0; function Rt(dt) { var yt = -1, ot = dt ? dt.length : 0; for (this.clear(); ++yt < ot;) {
                    var Et = dt[yt];
                    this.set(Et[0], Et[1]);
                } } function Bt(dt) { var yt = -1, ot = dt ? dt.length : 0; for (this.clear(); ++yt < ot;) {
                    var Et = dt[yt];
                    this.set(Et[0], Et[1]);
                } } function wt(dt) { var yt = -1, ot = dt ? dt.length : 0; for (this.clear(); ++yt < ot;) {
                    var Et = dt[yt];
                    this.set(Et[0], Et[1]);
                } } function kt(dt) { var yt = -1, ot = dt ? dt.length : 0; for (this.__data__ = new wt; ++yt < ot;)
                    this.add(dt[yt]); } function Wt(dt) { this.__data__ = new Bt(dt); } function Ct(dt, yt) { var ot = Ut(dt) || Gt(dt) ? function (ut, et) { for (var ht = -1, xt = Array(ut); ++ht < ut;)
                    xt[ht] = et(ht); return xt; }(dt.length, String) : [], Et = ot.length, It = !!Et; for (var At in dt)
                    !yt && !C.call(dt, At) || It && (At == "length" || ft(At, Et)) || ot.push(At); return ot; } function Ft(dt, yt) { for (var ot = dt.length; ot--;)
                    if (he(dt[ot][0], yt))
                        return ot; return -1; } function te(dt, yt) { for (var ot = 0, Et = (yt = gt(yt, dt) ? [yt] : ne(yt)).length; dt != null && ot < Et;)
                    dt = dt[Pt(yt[ot++])]; return ot && ot == Et ? dt : void 0; } function jt(dt, yt) { return dt != null && yt in Object(dt); } function Kt(dt, yt, ot, Et, It) { return dt === yt || (dt == null || yt == null || !ie(dt) && !Qt(yt) ? dt != dt && yt != yt : function (At, ut, et, ht, xt, Jt) { var pe = Ut(At), fe = Ut(ut), ce = "[object Array]", ue = "[object Array]"; pe || (ce = (ce = Ot(At)) == e ? n : ce), fe || (ue = (ue = Ot(ut)) == e ? n : ue); var le = ce == n && !L(At), ve = ue == n && !L(ut), me = ce == ue; if (me && !le)
                    return Jt || (Jt = new Wt), pe || ye(At) ? Vt(At, ut, et, ht, xt, Jt) : function (ae, oe, Ie, we, Ee, ge, be) { switch (Ie) {
                        case "[object DataView]":
                            if (ae.byteLength != oe.byteLength || ae.byteOffset != oe.byteOffset)
                                return !1;
                            ae = ae.buffer, oe = oe.buffer;
                        case "[object ArrayBuffer]": return !(ae.byteLength != oe.byteLength || !we(new w(ae), new w(oe)));
                        case "[object Boolean]":
                        case "[object Date]":
                        case "[object Number]": return he(+ae, +oe);
                        case "[object Error]": return ae.name == oe.name && ae.message == oe.message;
                        case "[object RegExp]":
                        case "[object String]": return ae == oe + "";
                        case c: var Se = j;
                        case t:
                            var Me = 2 & ge;
                            if (Se || (Se = D), ae.size != oe.size && !Me)
                                return !1;
                            var xe = be.get(ae);
                            if (xe)
                                return xe == oe;
                            ge |= 1, be.set(ae, oe);
                            var Re = Vt(Se(ae), Se(oe), we, Ee, ge, be);
                            return be.delete(ae), Re;
                        case "[object Symbol]": if (Tt)
                            return Tt.call(ae) == Tt.call(oe);
                    } return !1; }(At, ut, ce, et, ht, xt, Jt); if (!(2 & xt)) {
                    var _e = le && C.call(At, "__wrapped__"), ke = ve && C.call(ut, "__wrapped__");
                    if (_e || ke) {
                        var Te = _e ? At.value() : At, Ce = ke ? ut.value() : ut;
                        return Jt || (Jt = new Wt), et(Te, Ce, ht, xt, Jt);
                    }
                } return me ? (Jt || (Jt = new Wt), function (ae, oe, Ie, we, Ee, ge) { var be = 2 & Ee, Se = se(ae), Me = Se.length, xe = se(oe).length; if (Me != xe && !be)
                    return !1; for (var Re = Me; Re--;) {
                    var Ae = Se[Re];
                    if (!(be ? Ae in oe : C.call(oe, Ae)))
                        return !1;
                } var Ue = ge.get(ae); if (Ue && ge.get(oe))
                    return Ue == oe; var Ne = !0; ge.set(ae, oe), ge.set(oe, ae); for (var Le = be; ++Re < Me;) {
                    Ae = Se[Re];
                    var Pe = ae[Ae], Be = oe[Ae];
                    if (we)
                        var je = be ? we(Be, Pe, Ae, oe, ae, ge) : we(Pe, Be, Ae, ae, oe, ge);
                    if (!(je === void 0 ? Pe === Be || Ie(Pe, Be, we, Ee, ge) : je)) {
                        Ne = !1;
                        break;
                    }
                    Le || (Le = Ae == "constructor");
                } if (Ne && !Le) {
                    var Oe = ae.constructor, De = oe.constructor;
                    Oe == De || !("constructor" in ae) || !("constructor" in oe) || typeof Oe == "function" && Oe instanceof Oe && typeof De == "function" && De instanceof De || (Ne = !1);
                } return ge.delete(ae), ge.delete(oe), Ne; }(At, ut, et, ht, xt, Jt)) : !1; }(dt, yt, Kt, ot, Et, It)); } function re(dt) { return !(!ie(dt) || function (yt) { return !!$ && $ in yt; }(dt)) && (Zt(dt) || L(dt) ? U : g).test(Mt(dt)); } function St(dt) { return typeof dt == "function" ? dt : dt == null ? Ht : typeof dt == "object" ? Ut(dt) ? function (Et, It) { return gt(Et) && bt(It) ? _t(Pt(Et), It) : function (At) { var ut = function (et, ht, xt) { var Jt = et == null ? void 0 : te(et, ht); return Jt === void 0 ? xt : Jt; }(At, Et); return ut === void 0 && ut === It ? function (et, ht) { return et != null && function (xt, Jt, pe) { Jt = gt(Jt, xt) ? [Jt] : ne(Jt); for (var fe, ce = -1, ue = Jt.length; ++ce < ue;) {
                    var le = Pt(Jt[ce]);
                    if (!(fe = xt != null && pe(xt, le)))
                        break;
                    xt = xt[le];
                } return fe || !!(ue = xt ? xt.length : 0) && Xt(ue) && ft(le, ue) && (Ut(xt) || Gt(xt)); }(et, ht, jt); }(At, Et) : Kt(It, ut, void 0, 3); }; }(dt[0], dt[1]) : function (Et) { var It = function (At) { for (var ut = se(At), et = ut.length; et--;) {
                    var ht = ut[et], xt = At[ht];
                    ut[et] = [ht, xt, bt(xt)];
                } return ut; }(Et); return It.length == 1 && It[0][2] ? _t(It[0][0], It[0][1]) : function (At) { return At === Et || function (ut, et, ht, xt) { var Jt = ht.length, pe = Jt, fe = !xt; if (ut == null)
                    return !pe; for (ut = Object(ut); Jt--;) {
                    var ce = ht[Jt];
                    if (fe && ce[2] ? ce[1] !== ut[ce[0]] : !(ce[0] in ut))
                        return !1;
                } for (; ++Jt < pe;) {
                    var ue = (ce = ht[Jt])[0], le = ut[ue], ve = ce[1];
                    if (fe && ce[2]) {
                        if (le === void 0 && !(ue in ut))
                            return !1;
                    }
                    else {
                        var me = new Wt;
                        if (xt)
                            var _e = xt(le, ve, ue, ut, et, me);
                        if (!(_e === void 0 ? Kt(ve, le, xt, 3, me) : _e))
                            return !1;
                    }
                } return !0; }(At, Et, It); }; }(dt) : gt(yt = dt) ? (ot = Pt(yt), function (Et) { return Et == null ? void 0 : Et[ot]; }) : function (Et) { return function (It) { return te(It, Et); }; }(yt); var yt, ot; } function Nt(dt) { if (ot = (yt = dt) && yt.constructor, Et = typeof ot == "function" && ot.prototype || F, yt !== Et)
                    return H(dt); var yt, ot, Et, It = []; for (var At in Object(dt))
                    C.call(dt, At) && At != "constructor" && It.push(At); return It; } function ne(dt) { return Ut(dt) ? dt : Lt(dt); } function Vt(dt, yt, ot, Et, It, At) { var ut = 2 & It, et = dt.length, ht = yt.length; if (et != ht && !(ut && ht > et))
                    return !1; var xt = At.get(dt); if (xt && At.get(yt))
                    return xt == yt; var Jt = -1, pe = !0, fe = 1 & It ? new kt : void 0; for (At.set(dt, yt), At.set(yt, dt); ++Jt < et;) {
                    var ce = dt[Jt], ue = yt[Jt];
                    if (Et)
                        var le = ut ? Et(ue, ce, Jt, yt, dt, At) : Et(ce, ue, Jt, dt, yt, At);
                    if (le !== void 0) {
                        if (le)
                            continue;
                        pe = !1;
                        break;
                    }
                    if (fe) {
                        if (!P(yt, function (ve, me) { if (!fe.has(me) && (ce === ve || ot(ce, ve, Et, It, At)))
                            return fe.add(me); })) {
                            pe = !1;
                            break;
                        }
                    }
                    else if (ce !== ue && !ot(ce, ue, Et, It, At)) {
                        pe = !1;
                        break;
                    }
                } return At.delete(dt), At.delete(yt), pe; } function qt(dt, yt) { var ot, Et, It = dt.__data__; return ((Et = typeof (ot = yt)) == "string" || Et == "number" || Et == "symbol" || Et == "boolean" ? ot !== "__proto__" : ot === null) ? It[typeof yt == "string" ? "string" : "hash"] : It.map; } function ee(dt, yt) { var ot = function (Et, It) { return Et == null ? void 0 : Et[It]; }(dt, yt); return re(ot) ? ot : void 0; } Rt.prototype.clear = function () { this.__data__ = it ? it(null) : {}; }, Rt.prototype.delete = function (dt) { return this.has(dt) && delete this.__data__[dt]; }, Rt.prototype.get = function (dt) { var yt = this.__data__; if (it) {
                    var ot = yt[dt];
                    return ot === "__lodash_hash_undefined__" ? void 0 : ot;
                } return C.call(yt, dt) ? yt[dt] : void 0; }, Rt.prototype.has = function (dt) { var yt = this.__data__; return it ? yt[dt] !== void 0 : C.call(yt, dt); }, Rt.prototype.set = function (dt, yt) { return this.__data__[dt] = it && yt === void 0 ? "__lodash_hash_undefined__" : yt, this; }, Bt.prototype.clear = function () { this.__data__ = []; }, Bt.prototype.delete = function (dt) { var yt = this.__data__, ot = Ft(yt, dt); return !(ot < 0) && (ot == yt.length - 1 ? yt.pop() : q.call(yt, ot, 1), !0); }, Bt.prototype.get = function (dt) { var yt = this.__data__, ot = Ft(yt, dt); return ot < 0 ? void 0 : yt[ot][1]; }, Bt.prototype.has = function (dt) { return Ft(this.__data__, dt) > -1; }, Bt.prototype.set = function (dt, yt) { var ot = this.__data__, Et = Ft(ot, dt); return Et < 0 ? ot.push([dt, yt]) : ot[Et][1] = yt, this; }, wt.prototype.clear = function () { this.__data__ = { hash: new Rt, map: new (Z || Bt), string: new Rt }; }, wt.prototype.delete = function (dt) { return qt(this, dt).delete(dt); }, wt.prototype.get = function (dt) { return qt(this, dt).get(dt); }, wt.prototype.has = function (dt) { return qt(this, dt).has(dt); }, wt.prototype.set = function (dt, yt) { return qt(this, dt).set(dt, yt), this; }, kt.prototype.add = kt.prototype.push = function (dt) { return this.__data__.set(dt, "__lodash_hash_undefined__"), this; }, kt.prototype.has = function (dt) { return this.__data__.has(dt); }, Wt.prototype.clear = function () { this.__data__ = new Bt; }, Wt.prototype.delete = function (dt) { return this.__data__.delete(dt); }, Wt.prototype.get = function (dt) { return this.__data__.get(dt); }, Wt.prototype.has = function (dt) { return this.__data__.has(dt); }, Wt.prototype.set = function (dt, yt) { var ot = this.__data__; if (ot instanceof Bt) {
                    var Et = ot.__data__;
                    if (!Z || Et.length < 199)
                        return Et.push([dt, yt]), this;
                    ot = this.__data__ = new wt(Et);
                } return ot.set(dt, yt), this; }; var Ot = function (dt) { return A.call(dt); }; function ft(dt, yt) { return !!(yt = yt !== null && yt !== void 0 ? yt : 9007199254740991) && (typeof dt == "number" || I.test(dt)) && dt > -1 && dt % 1 == 0 && dt < yt; } function gt(dt, yt) { if (Ut(dt))
                    return !1; var ot = typeof dt; return !(ot != "number" && ot != "symbol" && ot != "boolean" && dt != null && !$t(dt)) || (u.test(dt) || !s.test(dt)) || yt != null && dt in Object(yt); } function bt(dt) { return dt == dt && !ie(dt); } function _t(dt, yt) { return function (ot) { return ot != null && ot[dt] === yt && (yt !== void 0 || dt in Object(ot)); }; } (J && Ot(new J(new ArrayBuffer(1))) != "[object DataView]" || Z && Ot(new Z) != c || tt && Ot(tt.resolve()) != "[object Promise]" || nt && Ot(new nt) != t || rt && Ot(new rt) != "[object WeakMap]") && (Ot = function (dt) { var yt = A.call(dt), ot = yt == n ? dt.constructor : void 0, Et = ot ? Mt(ot) : void 0; if (Et)
                    switch (Et) {
                        case st: return "[object DataView]";
                        case at: return c;
                        case ct: return "[object Promise]";
                        case lt: return t;
                        case pt: return "[object WeakMap]";
                    } return yt; }); var Lt = zt(function (dt) { var yt; dt = (yt = dt) == null ? "" : function (Et) { if (typeof Et == "string")
                    return Et; if ($t(Et))
                    return vt ? vt.call(Et) : ""; var It = Et + ""; return It == "0" && 1 / Et == -1 / 0 ? "-0" : It; }(yt); var ot = []; return i.test(dt) && ot.push(""), dt.replace(o, function (Et, It, At, ut) { ot.push(At ? ut.replace(a, "$1") : It || Et); }), ot; }); function Pt(dt) { if (typeof dt == "string" || $t(dt))
                    return dt; var yt = dt + ""; return yt == "0" && 1 / dt == -1 / 0 ? "-0" : yt; } function Mt(dt) { if (dt != null) {
                    try {
                        return y.call(dt);
                    }
                    catch (yt) { }
                    try {
                        return dt + "";
                    }
                    catch (yt) { }
                } return ""; } var Yt, Dt = (Yt = function (dt, yt, ot) { var Et = dt ? dt.length : 0; if (!Et)
                    return -1; var It, At, ut = ot == null ? 0 : (It = function (et) { return et ? (et = function (ht) { if (typeof ht == "number")
                    return ht; if ($t(ht))
                    return NaN; if (ie(ht)) {
                    var xt = typeof ht.valueOf == "function" ? ht.valueOf() : ht;
                    ht = ie(xt) ? xt + "" : xt;
                } if (typeof ht != "string")
                    return ht === 0 ? ht : +ht; ht = ht.replace(h, ""); var Jt = p.test(ht); return Jt || b.test(ht) ? R(ht.slice(2), Jt ? 2 : 8) : l.test(ht) ? NaN : +ht; }(et)) === 1 / 0 || et === -1 / 0 ? 17976931348623157e292 * (et < 0 ? -1 : 1) : et == et ? et : 0 : et === 0 ? et : 0; }(ot), At = It % 1, It == It ? At ? It - At : It : 0); return ut < 0 && (ut = V(Et + ut, 0)), function (et, ht, xt, Jt) { for (var pe = et.length, fe = xt + (Jt ? 1 : -1); Jt ? fe-- : ++fe < pe;)
                    if (ht(et[fe], fe, et))
                        return fe; return -1; }(dt, St(yt), ut); }, function (dt, yt, ot) { var Et = Object(dt); if (!de(dt)) {
                    var It = St(yt);
                    dt = se(dt), yt = function (ut) { return It(Et[ut], ut, Et); };
                } var At = Yt(dt, yt, ot); return At > -1 ? Et[It ? dt[At] : At] : void 0; }); function zt(dt, yt) { if (typeof dt != "function" || yt && typeof yt != "function")
                    throw new TypeError("Expected a function"); var ot = function () { var Et = arguments, It = yt ? yt.apply(this, Et) : Et[0], At = ot.cache; if (At.has(It))
                    return At.get(It); var ut = dt.apply(this, Et); return ot.cache = At.set(It, ut), ut; }; return ot.cache = new (zt.Cache || wt), ot; } function he(dt, yt) { return dt === yt || dt != dt && yt != yt; } function Gt(dt) { return function (yt) { return Qt(yt) && de(yt); }(dt) && C.call(dt, "callee") && (!O.call(dt, "callee") || A.call(dt) == e); } zt.Cache = wt; var Ut = Array.isArray; function de(dt) { return dt != null && Xt(dt.length) && !Zt(dt); } function Zt(dt) { var yt = ie(dt) ? A.call(dt) : ""; return yt == "[object Function]" || yt == "[object GeneratorFunction]"; } function Xt(dt) { return typeof dt == "number" && dt > -1 && dt % 1 == 0 && dt <= 9007199254740991; } function ie(dt) { var yt = typeof dt; return !!dt && (yt == "object" || yt == "function"); } function Qt(dt) { return !!dt && typeof dt == "object"; } function $t(dt) { return typeof dt == "symbol" || Qt(dt) && A.call(dt) == "[object Symbol]"; } var ye = B ? function (dt) { return function (yt) { return dt(yt); }; }(B) : function (dt) { return Qt(dt) && Xt(dt.length) && !!v[A.call(dt)]; }; function se(dt) { return de(dt) ? Ct(dt) : Nt(dt); } function Ht(dt) { return dt; } r.exports = Dt; }).call(this, f(10), f(107)(E));
            }, function (E, m, f) {
                "use strict";
                var d = Object.prototype.toString;
                function r(n, t) { return n > t; }
                function e(n) { return typeof n == "symbol" || function (t) { return !!t && typeof t == "object"; }(n) && d.call(n) == "[object Symbol]"; }
                function c(n) { return n; }
                E.exports = function (n) { return n && n.length ? function (t, s, u) { for (var i = -1, o = t.length; ++i < o;) {
                    var h = t[i], a = s(h);
                    if (a != null && (l === void 0 ? a == a && !e(a) : u(a, l)))
                        var l = a, p = h;
                } return p; }(n, c, r) : void 0; };
            }, function (E, m, f) {
                "use strict";
                var d = f(351), r = f(202);
                m.isValid = function () { return this.valid; }, m.isInSubnet = d.isInSubnet, m.isCorrect = d.isCorrect(r.BITS), m.isCanonical = d.falseIfInvalid(function () { return this.addressMinusSuffix === this.canonicalForm(); }), m.isLinkLocal = d.falseIfInvalid(function () { return this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000"; }), m.isMulticast = d.falseIfInvalid(function () { return this.getType() === "Multicast"; }), m.is4 = d.falseIfInvalid(function () { return this.v4; }), m.isTeredo = d.falseIfInvalid(function () { return this.isInSubnet(new this.constructor("2001::/32")); }), m.is6to4 = d.falseIfInvalid(function () { return this.isInSubnet(new this.constructor("2002::/16")); }), m.isLoopback = d.falseIfInvalid(function () { return this.getType() === "Loopback"; });
            }, function (E, m, f) {
                "use strict";
                var d = f(201), r = f(354), e = f(100).sprintf;
                m.href = function (c) { return c = c === void 0 ? "" : e(":%s", c), e("http://[%s]%s/", this.correctForm(), c); }, m.link = function (c) { c || (c = {}), c.className === void 0 && (c.className = ""), c.prefix === void 0 && (c.prefix = "/#address="), c.v4 === void 0 && (c.v4 = !1); var n = this.correctForm; return c.v4 && (n = this.to4in6), c.className ? e('<a href="%1$s%2$s" class="%3$s">%2$s</a>', c.prefix, n.call(this), c.className) : e('<a href="%1$s%2$s">%2$s</a>', c.prefix, n.call(this)); }, m.group = function () { var c, n = this.address.match(d.RE_ADDRESS); if (n) {
                    var t = n[0].split(".");
                    this.address = this.address.replace(d.RE_ADDRESS, e('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', t.slice(0, 2).join("."), t.slice(2, 4).join(".")));
                } if (this.elidedGroups === 0)
                    return r.simpleGroup(this.address); var s = [], u = this.address.split("::"); u[0].length ? s.push(r.simpleGroup(u[0])) : s.push(""); var i = ["hover-group"]; for (c = this.elisionBegin; c < this.elisionBegin + this.elidedGroups; c++)
                    i.push(e("group-%d", c)); return s.push(e('<span class="%s"></span>', i.join(" "))), u[1].length ? s.push(r.simpleGroup(u[1], this.elisionEnd)) : s.push(""), s.join(":"); };
            }, function (E, m, f) {
                "use strict";
                var d = f(100).sprintf, r = f(202);
                function e(s) { return d("(%s)", s.join("|")); }
                function c(s) { return s.length < 4 ? d("0{0,%d}%s", 4 - s.length, s) : s; }
                function n(s) { var u = []; s.forEach(function (o, h) { parseInt(o, 16) === 0 && u.push(h); }); var i = u.map(function (o) { return s.map(function (h, a) { if (a === o) {
                    var l = a === 0 || a === r.GROUPS - 1 ? ":" : "";
                    return e([c(h), l]);
                } return c(h); }).join(":"); }); return i.push(s.map(c).join(":")), e(i); }
                function t(s, u, i) { var o = u ? "" : ":", h = i ? "" : ":", a = []; u || i || a.push("::"), u && i && a.push(""), (i && !u || !i && u) && a.push(":"), a.push(d("%s(:0{1,4}){1,%d}", o, s - 1)), a.push(d("(0{1,4}:){1,%d}%s", s - 1, h)), a.push(d("(0{1,4}:){%d}0{1,4}", s - 1)); for (var l = 1; l < s - 1; l++)
                    for (var p = 1; p < s - l; p++)
                        a.push(d("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", p, s - p - l - 1)); return e(a); }
                m.regularExpressionString = function (s) { s === void 0 && (s = !1); var u = [], i = new this.constructor(this.correctForm()); if (i.elidedGroups === 0)
                    u.push(n(i.parsedAddress));
                else if (i.elidedGroups === r.GROUPS)
                    u.push(t(r.GROUPS));
                else {
                    var o = i.address.split("::");
                    o[0].length && u.push(n(o[0].split(":"))), u.push(t(i.elidedGroups, o[0].length !== 0, o[1].length !== 0)), o[1].length && u.push(n(o[1].split(":"))), u = [u.join(":")];
                } return s || (u = [].concat("(?=^|", "[^A-Fa-f0-9:]", "|[^\\w\\:])(", u, ")(?=[^\\w\\:]|", "[^A-Fa-f0-9:]", "|$)")), u.join(""); }, m.regularExpression = function (s) { return new RegExp(this.regularExpressionString(s), "i"); };
            }, function (E, m, f) {
                "use strict";
                const d = f(1), r = d("libp2p:webrtc-star");
                r.error = d("libp2p:webrtc-star:error");
                const { EventEmitter: e } = f(12), c = f(0), n = f(26), { AbortError: t } = f(45), s = f(355), { supportsWebRTCDataChannels: u } = f(960), i = f(13), o = f(60), h = f(7), { CODE_CIRCUIT: a } = f(204), l = f(961), p = f(375), { cleanMultiaddr: g } = f(378);
                function b() { }
                E.exports = n(class {
                    constructor(I = {}) { if (!I.upgrader)
                        throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader."); this._upgrader = I.upgrader, this._signallingAddr = void 0, this.sioOptions = { transports: ["websocket"], "force new connection": !0 }, I.wrtc && (this.wrtc = I.wrtc), this.listenersRefs = {}, this.discovery = new e, this.discovery.tag = "webRTCStar", this.discovery._isStarted = !1, this.discovery.start = () => { this.discovery._isStarted = !0; }, this.discovery.stop = () => { this.discovery._isStarted = !1; }, this._peerDiscovered = this._peerDiscovered.bind(this); }
                    async dial(I, v = {}) { const R = await this._connect(I, v), _ = p(R, { remoteAddr: I, signal: v.signal }); r("new outbound connection %s", _.remoteAddr); const k = await this._upgrader.upgradeOutbound(_); return r("outbound connection %s upgraded", _.remoteAddr), k; }
                    _connect(I, v = {}) { if (v.signal && v.signal.aborted)
                        throw new t; const R = { initiator: !0, trickle: !1, ...v.spOptions || {} }; this.wrtc && (R.wrtc = this.wrtc); const _ = I.toOptions(), k = (~~(1e9 * Math.random())).toString(36) + Date.now(), x = this.listenersRefs[Object.keys(this.listenersRefs)[0]].io; return new Promise((M, N) => { const S = Date.now(); let T; r("dialing %s:%s", _.host, _.port); const B = new s(R), P = W => { if (!T) {
                        const X = `connection error ${_.host}:${_.port}: ${W.message}`;
                        r.error(X), G(W);
                    } }, L = () => { r("connnection timeout %s:%s", _.host, _.port); const W = c(new Error(`connection timeout after ${Date.now() - S}ms`), "ERR_CONNECT_TIMEOUT"); B.emit("error", W); }, j = () => { T = !0, r("connection opened %s:%s", _.host, _.port), G(null); }, D = () => { r.error("connection aborted %s:%s", _.host, _.port), B.destroy(), G(new t); }, G = W => { B.removeListener("timeout", L), B.removeListener("connect", j), v.signal && v.signal.removeEventListener("abort", D), W ? N(W) : M(B); }; B.on("error", P), B.once("timeout", L), B.once("connect", j), B.on("close", () => { B.removeListener("error", P); }), v.signal && v.signal.addEventListener("abort", D), B.on("signal", W => { x.emit("ss-handshake", { intentId: k, srcMultiaddr: this._signallingAddr.toString(), dstMultiaddr: I.toString(), signal: W }); }), x.on("ws-handshake", W => { W.intentId === k && W.err && N(c(W.err instanceof Error ? W.err : new Error(W.err), "ERR_SIGNALLING_FAILED")), W.intentId === k && W.answer && !B.destroyed && B.signal(W.signal); }); }); }
                    createListener(I = {}, v) { if (!u && !this.wrtc)
                        throw c(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT"); return typeof I == "function" && (v = I, I = {}), l({ handler: v = v || b, upgrader: this._upgrader }, this, I); }
                    filter(I) { return (I = Array.isArray(I) ? I : [I]).filter(v => !v.protoCodes().includes(a) && o.WebRTCStar.matches(v)); }
                    _peerDiscovered(I) { if (!this.discovery._isStarted)
                        return; r("Peer Discovered:", I), I = g(I); const v = i(I), R = h.createFromB58String(v.getPeerId()); this.discovery.emit("peer", { id: R, multiaddrs: [v] }); }
                }, { className: "WebRTCStar", symbolName: "@libp2p/js-libp2p-webrtc-star/webrtcstar" });
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { if (typeof globalThis == "undefined")
                    return null; var d = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate }; return d.RTCPeerConnection ? d : null; };
            }, function (E, m, f) {
                "use strict";
                (m = E.exports = f(357)).Stream = m, m.Readable = m, m.Writable = f(361), m.Duplex = f(77), m.Transform = f(362), m.PassThrough = f(957), m.finished = f(203), m.pipeline = f(958);
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                function d(s, u) { var i = Object.keys(s); if (Object.getOwnPropertySymbols) {
                    var o = Object.getOwnPropertySymbols(s);
                    u && (o = o.filter(function (h) { return Object.getOwnPropertyDescriptor(s, h).enumerable; })), i.push.apply(i, o);
                } return i; }
                function r(s, u, i) { return u in s ? Object.defineProperty(s, u, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : s[u] = i, s; }
                function e(s, u) { for (var i = 0; i < u.length; i++) {
                    var o = u[i];
                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(s, o.key, o);
                } }
                var c = f(3).Buffer, n = f(954).inspect, t = n && n.custom || "inspect";
                E.exports = function () { function s() { !function (h, a) { if (!(h instanceof a))
                    throw new TypeError("Cannot call a class as a function"); }(this, s), this.head = null, this.tail = null, this.length = 0; } var u, i, o; return u = s, (i = [{ key: "push", value: function (h) { var a = { data: h, next: null }; this.length > 0 ? this.tail.next = a : this.head = a, this.tail = a, ++this.length; } }, { key: "unshift", value: function (h) { var a = { data: h, next: this.head }; this.length === 0 && (this.tail = a), this.head = a, ++this.length; } }, { key: "shift", value: function () { if (this.length !== 0) {
                            var h = this.head.data;
                            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, h;
                        } } }, { key: "clear", value: function () { this.head = this.tail = null, this.length = 0; } }, { key: "join", value: function (h) { if (this.length === 0)
                            return ""; for (var a = this.head, l = "" + a.data; a = a.next;)
                            l += h + a.data; return l; } }, { key: "concat", value: function (h) { if (this.length === 0)
                            return c.alloc(0); for (var a, l, p, g = c.allocUnsafe(h >>> 0), b = this.head, I = 0; b;)
                            a = b.data, l = g, p = I, c.prototype.copy.call(a, l, p), I += b.data.length, b = b.next; return g; } }, { key: "consume", value: function (h, a) { var l; return h < this.head.data.length ? (l = this.head.data.slice(0, h), this.head.data = this.head.data.slice(h)) : l = h === this.head.data.length ? this.shift() : a ? this._getString(h) : this._getBuffer(h), l; } }, { key: "first", value: function () { return this.head.data; } }, { key: "_getString", value: function (h) { var a = this.head, l = 1, p = a.data; for (h -= p.length; a = a.next;) {
                            var g = a.data, b = h > g.length ? g.length : h;
                            if (b === g.length ? p += g : p += g.slice(0, h), (h -= b) == 0) {
                                b === g.length ? (++l, a.next ? this.head = a.next : this.head = this.tail = null) : (this.head = a, a.data = g.slice(b));
                                break;
                            }
                            ++l;
                        } return this.length -= l, p; } }, { key: "_getBuffer", value: function (h) { var a = c.allocUnsafe(h), l = this.head, p = 1; for (l.data.copy(a), h -= l.data.length; l = l.next;) {
                            var g = l.data, b = h > g.length ? g.length : h;
                            if (g.copy(a, a.length - h, 0, b), (h -= b) == 0) {
                                b === g.length ? (++p, l.next ? this.head = l.next : this.head = this.tail = null) : (this.head = l, l.data = g.slice(b));
                                break;
                            }
                            ++p;
                        } return this.length -= p, a; } }, { key: t, value: function (h, a) { return n(this, function (l) { for (var p = 1; p < arguments.length; p++) {
                            var g = arguments[p] != null ? arguments[p] : {};
                            p % 2 ? d(Object(g), !0).forEach(function (b) { r(l, b, g[b]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(g)) : d(Object(g)).forEach(function (b) { Object.defineProperty(l, b, Object.getOwnPropertyDescriptor(g, b)); });
                        } return l; }({}, a, { depth: 0, customInspect: !1 })); } }]) && e(u.prototype, i), o && e(u, o), s; }();
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                (function (d) { var r; function e(I, v, R) { return v in I ? Object.defineProperty(I, v, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : I[v] = R, I; } var c = f(203), n = Symbol("lastResolve"), t = Symbol("lastReject"), s = Symbol("error"), u = Symbol("ended"), i = Symbol("lastPromise"), o = Symbol("handlePromise"), h = Symbol("stream"); function a(I, v) { return { value: I, done: v }; } function l(I) { var v = I[n]; if (v !== null) {
                    var R = I[h].read();
                    R !== null && (I[i] = null, I[n] = null, I[t] = null, v(a(R, !1)));
                } } function p(I) { d.nextTick(l, I); } var g = Object.getPrototypeOf(function () { }), b = Object.setPrototypeOf((e(r = { get stream() { return this[h]; }, next: function () { var I = this, v = this[s]; if (v !== null)
                        return Promise.reject(v); if (this[u])
                        return Promise.resolve(a(void 0, !0)); if (this[h].destroyed)
                        return new Promise(function (x, M) { d.nextTick(function () { I[s] ? M(I[s]) : x(a(void 0, !0)); }); }); var R, _ = this[i]; if (_)
                        R = new Promise(function (x, M) { return function (N, S) { x.then(function () { M[u] ? N(a(void 0, !0)) : M[o](N, S); }, S); }; }(_, this));
                    else {
                        var k = this[h].read();
                        if (k !== null)
                            return Promise.resolve(a(k, !1));
                        R = new Promise(this[o]);
                    } return this[i] = R, R; } }, Symbol.asyncIterator, function () { return this; }), e(r, "return", function () { var I = this; return new Promise(function (v, R) { I[h].destroy(null, function (_) { _ ? R(_) : v(a(void 0, !0)); }); }); }), r), g); E.exports = function (I) { var v, R = Object.create(b, (e(v = {}, h, { value: I, writable: !0 }), e(v, n, { value: null, writable: !0 }), e(v, t, { value: null, writable: !0 }), e(v, s, { value: null, writable: !0 }), e(v, u, { value: I._readableState.endEmitted, writable: !0 }), e(v, o, { value: function (_, k) { var x = R[h].read(); x ? (R[i] = null, R[n] = null, R[t] = null, _(a(x, !1))) : (R[n] = _, R[t] = k); }, writable: !0 }), v)); return R[i] = null, c(I, function (_) { if (_ && _.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                    var k = R[t];
                    return k !== null && (R[i] = null, R[n] = null, R[t] = null, k(_)), void (R[s] = _);
                } var x = R[n]; x !== null && (R[i] = null, R[n] = null, R[t] = null, x(a(void 0, !0))), R[u] = !0; }), I.on("readable", p.bind(null, R)), R; }; }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { throw new Error("Readable.from is not available in the browser"); };
            }, function (E, m, f) {
                "use strict";
                E.exports = r;
                var d = f(362);
                function r(e) { if (!(this instanceof r))
                    return new r(e); d.call(this, e); }
                f(15)(r, d), r.prototype._transform = function (e, c, n) { n(null, e); };
            }, function (E, m, f) {
                "use strict";
                var d, r = f(76).codes, e = r.ERR_MISSING_ARGS, c = r.ERR_STREAM_DESTROYED;
                function n(o) { if (o)
                    throw o; }
                function t(o, h, a, l) { l = function (b) { var I = !1; return function () { I || (I = !0, b.apply(void 0, arguments)); }; }(l); var p = !1; o.on("close", function () { p = !0; }), d === void 0 && (d = f(203)), d(o, { readable: h, writable: a }, function (b) { if (b)
                    return l(b); p = !0, l(); }); var g = !1; return function (b) { if (!p && !g)
                    return g = !0, function (I) { return I.setHeader && typeof I.abort == "function"; }(o) ? o.abort() : typeof o.destroy == "function" ? o.destroy() : void l(b || new c("pipe")); }; }
                function s(o) { o(); }
                function u(o, h) { return o.pipe(h); }
                function i(o) { return o.length ? typeof o[o.length - 1] != "function" ? n : o.pop() : n; }
                E.exports = function () { for (var o = arguments.length, h = new Array(o), a = 0; a < o; a++)
                    h[a] = arguments[a]; var l, p = i(h); if (Array.isArray(h[0]) && (h = h[0]), h.length < 2)
                    throw new e("streams"); var g = h.map(function (b, I) { var v = I < h.length - 1; return t(b, v, I > 0, function (R) { l || (l = R), R && g.forEach(s), v || (g.forEach(s), p(l)); }); }); return h.reduce(u); };
            }, function (E, m, f) {
                "use strict";
                let d;
                E.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(globalThis) : r => (d || (d = Promise.resolve())).then(r).catch(e => setTimeout(() => { throw e; }, 0));
            }, function (E, m, f) {
                "use strict";
                const d = f(135);
                E.exports = { supportsFileReader: typeof self != "undefined" && "FileReader" in self, supportsWebRTC: "RTCPeerConnection" in d && typeof navigator != "undefined" && navigator.mediaDevices !== void 0 && "getUserMedia" in navigator.mediaDevices, supportsWebRTCDataChannels: "RTCPeerConnection" in d };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(1), e = r("libp2p:webrtc-star:listener");
                e.error = r("libp2p:webrtc-star:listener:error");
                const c = f(13), n = f(962), t = f(355), s = f(199), u = f(375), { cleanUrlSIO: i } = f(378), { CODE_P2P: o } = f(204), h = { transports: ["websocket"], "force new connection": !0 };
                E.exports = ({ handler: a, upgrader: l }, p, g = {}) => { const b = new d; let I; return b.__connections = [], b.__spChannels = new Map, b.__pendingIntents = new Map, b.listen = v => { const R = s(); I = v, !v.protoCodes().includes(o) && l.localPeer ? p._signallingAddr = v.encapsulate("/p2p/" + l.localPeer.toB58String()) : p._signallingAddr = v; const _ = i(v); return e("Dialing to Signalling Server on: " + _), b.io = n.connect(_, h), b.io.once("connect_error", k => R.reject(k)), b.io.once("error", k => { b.emit("error", k), b.emit("close"); }), b.io.on("ws-handshake", k => { if (k.answer || k.err || !k.intentId)
                    return; const x = k.intentId; let M = b.__pendingIntents.get(x); M || (M = [], b.__pendingIntents.set(x, M)); let N = b.__spChannels.get(x); if (N)
                    return void N.signal(k.signal); if (k.signal.type !== "offer")
                    return void M.push(k); const S = { trickle: !1, ...g }; p.wrtc && (S.wrtc = p.wrtc), N = new t(S); const T = B => { e.error("incoming connectioned errored", B); }; N.on("error", T), N.once("close", (...B) => { N.removeListener("error", T); }), N.on("signal", B => { k.signal = B, k.answer = !0, b.io.emit("ss-handshake", k); }), N.signal(k.signal); for (const B of M)
                    N.signal(B.signal); b.__pendingIntents.set(x, []), N.once("connect", async () => { const B = u(N); let P; e("new inbound connection %s", B.remoteAddr); try {
                    P = await l.upgradeInbound(B);
                }
                catch (L) {
                    return e.error("inbound connection failed to upgrade", L), B.close();
                } if (!P.remoteAddr)
                    try {
                        P.remoteAddr = v.decapsulateCode(o).encapsulate("/p2p/" + P.remotePeer.toB58String());
                    }
                    catch (L) {
                        e.error("could not determine remote address", L);
                    } e("inbound connection %s upgraded", B.remoteAddr), function (L, j, D) { L.__connections.push(j), j.conn.once("close", () => { L.__connections = L.__connections.filter(G => G !== j), L.__spChannels.delete(D), L.__pendingIntents.delete(D); }); }(b, B, x), b.emit("connection", P), a(P); }), b.__spChannels.set(x, N); }), b.io.on("ws-peer", p._peerDiscovered), b.io.on("connect", () => { b.io.emit("ss-join", p._signallingAddr.toString()); }), b.io.once("connect", () => { b.emit("listening"), R.resolve(); }), R.promise; }, b.close = async () => { b.io && b.io.emit("ss-leave"), await Promise.all(b.__connections.map(v => v.close())), b.emit("close"); }, b.getAddrs = () => [I], p.listenersRefs[c.toString()] = b, b; };
            }, function (E, m, f) {
                "use strict";
                var d = f(963), r = f(205), e = f(366), c = f(125)("socket.io-client");
                E.exports = m = t;
                var n = m.managers = {};
                function t(s, u) { typeof s == "object" && (u = s, s = void 0), u = u || {}; var i, o = d(s), h = o.source, a = o.id, l = o.path, p = n[a] && l in n[a].nsps; return u.forceNew || u["force new connection"] || u.multiplex === !1 || p ? (c("ignoring socket cache for %s", h), i = e(h, u)) : (n[a] || (c("new io instance for %s", h), n[a] = e(h, u)), i = n[a]), o.query && !u.query && (u.query = o.query), i.socket(o.path, u); }
                m.protocol = r.protocol, m.connect = t, m.Manager = f(366), m.Socket = f(372);
            }, function (E, m, f) {
                "use strict";
                var d = f(363), r = f(125)("socket.io-client:url");
                E.exports = function (e, c) { var n = e; c = c || typeof location != "undefined" && location, e == null && (e = c.protocol + "//" + c.host), typeof e == "string" && (e.charAt(0) === "/" && (e = e.charAt(1) === "/" ? c.protocol + e : c.host + e), /^(https?|wss?):\/\//.test(e) || (r("protocol-less url %s", e), e = c !== void 0 ? c.protocol + "//" + e : "https://" + e), r("parse %s", e), n = d(e)), n.port || (/^(http|ws)$/.test(n.protocol) ? n.port = "80" : /^(http|ws)s$/.test(n.protocol) && (n.port = "443")), n.path = n.path || "/"; var t = n.host.indexOf(":") !== -1 ? "[" + n.host + "]" : n.host; return n.id = n.protocol + "://" + t + ":" + n.port, n.href = n.protocol + "://" + t + (c && c.port === n.port ? "" : ":" + n.port), n; };
            }, function (E, m, f) {
                "use strict";
                function d(e) { var c; function n() { if (n.enabled) {
                    var t = n, s = +new Date, u = s - (c || s);
                    t.diff = u, t.prev = c, t.curr = s, c = s;
                    for (var i = new Array(arguments.length), o = 0; o < i.length; o++)
                        i[o] = arguments[o];
                    i[0] = m.coerce(i[0]), typeof i[0] != "string" && i.unshift("%O");
                    var h = 0;
                    i[0] = i[0].replace(/%([a-zA-Z%])/g, function (l, p) { if (l === "%%")
                        return l; h++; var g = m.formatters[p]; if (typeof g == "function") {
                        var b = i[h];
                        l = g.call(t, b), i.splice(h, 1), h--;
                    } return l; }), m.formatArgs.call(t, i);
                    var a = n.log || m.log || console.log.bind(console);
                    a.apply(t, i);
                } } return n.namespace = e, n.enabled = m.enabled(e), n.useColors = m.useColors(), n.color = function (t) { var s, u = 0; for (s in t)
                    u = (u << 5) - u + t.charCodeAt(s), u |= 0; return m.colors[Math.abs(u) % m.colors.length]; }(e), n.destroy = r, typeof m.init == "function" && m.init(n), m.instances.push(n), n; }
                function r() { var e = m.instances.indexOf(this); return e !== -1 && (m.instances.splice(e, 1), !0); }
                (m = E.exports = d.debug = d.default = d).coerce = function (e) { return e instanceof Error ? e.stack || e.message : e; }, m.disable = function () { m.enable(""); }, m.enable = function (e) { var c; m.save(e), m.names = [], m.skips = []; var n = (typeof e == "string" ? e : "").split(/[\s,]+/), t = n.length; for (c = 0; c < t; c++)
                    n[c] && ((e = n[c].replace(/\*/g, ".*?"))[0] === "-" ? m.skips.push(new RegExp("^" + e.substr(1) + "$")) : m.names.push(new RegExp("^" + e + "$"))); for (c = 0; c < m.instances.length; c++) {
                    var s = m.instances[c];
                    s.enabled = m.enabled(s.namespace);
                } }, m.enabled = function (e) { if (e[e.length - 1] === "*")
                    return !0; var c, n; for (c = 0, n = m.skips.length; c < n; c++)
                    if (m.skips[c].test(e))
                        return !1; for (c = 0, n = m.names.length; c < n; c++)
                    if (m.names[c].test(e))
                        return !0; return !1; }, m.humanize = f(965), m.instances = [], m.names = [], m.skips = [], m.formatters = {};
            }, function (E, m, f) {
                "use strict";
                var d = 1e3, r = 6e4, e = 60 * r, c = 24 * e;
                function n(t, s, u) { if (!(t < s))
                    return t < 1.5 * s ? Math.floor(t / s) + " " + u : Math.ceil(t / s) + " " + u + "s"; }
                E.exports = function (t, s) { s = s || {}; var u, i = typeof t; if (i === "string" && t.length > 0)
                    return function (o) { if ((o = String(o)).length > 100)
                        return; var h = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(o); if (!h)
                        return; var a = parseFloat(h[1]); switch ((h[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y": return 315576e5 * a;
                        case "days":
                        case "day":
                        case "d": return a * c;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h": return a * e;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m": return a * r;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s": return a * d;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms": return a;
                        default: return;
                    } }(t); if (i === "number" && isNaN(t) === !1)
                    return s.long ? n(u = t, c, "day") || n(u, e, "hour") || n(u, r, "minute") || n(u, d, "second") || u + " ms" : function (o) { return o >= c ? Math.round(o / c) + "d" : o >= e ? Math.round(o / e) + "h" : o >= r ? Math.round(o / r) + "m" : o >= d ? Math.round(o / d) + "s" : o + "ms"; }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); };
            }, function (E, m, f) {
                "use strict";
                (function (d) { function r() { var e; try {
                    e = m.storage.debug;
                }
                catch (c) { } return !e && d !== void 0 && "env" in d && (e = { NODE_ENV: "production" }.DEBUG), e; } (m = E.exports = f(967)).log = function () { return typeof console == "object" && console.log && Function.prototype.apply.call(console.log, console, arguments); }, m.formatArgs = function (e) { var c = this.useColors; if (e[0] = (c ? "%c" : "") + this.namespace + (c ? " %c" : " ") + e[0] + (c ? "%c " : " ") + "+" + m.humanize(this.diff), !c)
                    return; var n = "color: " + this.color; e.splice(1, 0, n, "color: inherit"); var t = 0, s = 0; e[0].replace(/%[a-zA-Z%]/g, function (u) { u !== "%%" && (t++, u === "%c" && (s = t)); }), e.splice(s, 0, n); }, m.save = function (e) { try {
                    e == null ? m.storage.removeItem("debug") : m.storage.debug = e;
                }
                catch (c) { } }, m.load = r, m.useColors = function () { return typeof window != "undefined" && window.process && window.process.type === "renderer" ? !0 : typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document != "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window != "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/); }, m.storage = typeof chrome != "undefined" && chrome.storage !== void 0 ? chrome.storage.local : function () { try {
                    return window.localStorage;
                }
                catch (e) { } }(), m.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], m.formatters.j = function (e) { try {
                    return JSON.stringify(e);
                }
                catch (c) {
                    return "[UnexpectedJSONParseError]: " + c.message;
                } }, m.enable(r()); }).call(this, f(9));
            }, function (E, m, f) {
                "use strict";
                function d(e) { var c; function n() { if (n.enabled) {
                    var t = n, s = +new Date, u = s - (c || s);
                    t.diff = u, t.prev = c, t.curr = s, c = s;
                    for (var i = new Array(arguments.length), o = 0; o < i.length; o++)
                        i[o] = arguments[o];
                    i[0] = m.coerce(i[0]), typeof i[0] != "string" && i.unshift("%O");
                    var h = 0;
                    i[0] = i[0].replace(/%([a-zA-Z%])/g, function (l, p) { if (l === "%%")
                        return l; h++; var g = m.formatters[p]; if (typeof g == "function") {
                        var b = i[h];
                        l = g.call(t, b), i.splice(h, 1), h--;
                    } return l; }), m.formatArgs.call(t, i);
                    var a = n.log || m.log || console.log.bind(console);
                    a.apply(t, i);
                } } return n.namespace = e, n.enabled = m.enabled(e), n.useColors = m.useColors(), n.color = function (t) { var s, u = 0; for (s in t)
                    u = (u << 5) - u + t.charCodeAt(s), u |= 0; return m.colors[Math.abs(u) % m.colors.length]; }(e), n.destroy = r, typeof m.init == "function" && m.init(n), m.instances.push(n), n; }
                function r() { var e = m.instances.indexOf(this); return e !== -1 && (m.instances.splice(e, 1), !0); }
                (m = E.exports = d.debug = d.default = d).coerce = function (e) { return e instanceof Error ? e.stack || e.message : e; }, m.disable = function () { m.enable(""); }, m.enable = function (e) { var c; m.save(e), m.names = [], m.skips = []; var n = (typeof e == "string" ? e : "").split(/[\s,]+/), t = n.length; for (c = 0; c < t; c++)
                    n[c] && ((e = n[c].replace(/\*/g, ".*?"))[0] === "-" ? m.skips.push(new RegExp("^" + e.substr(1) + "$")) : m.names.push(new RegExp("^" + e + "$"))); for (c = 0; c < m.instances.length; c++) {
                    var s = m.instances[c];
                    s.enabled = m.enabled(s.namespace);
                } }, m.enabled = function (e) { if (e[e.length - 1] === "*")
                    return !0; var c, n; for (c = 0, n = m.skips.length; c < n; c++)
                    if (m.skips[c].test(e))
                        return !1; for (c = 0, n = m.names.length; c < n; c++)
                    if (m.names[c].test(e))
                        return !0; return !1; }, m.humanize = f(968), m.instances = [], m.names = [], m.skips = [], m.formatters = {};
            }, function (E, m, f) {
                "use strict";
                var d = 1e3, r = 6e4, e = 60 * r, c = 24 * e;
                function n(t, s, u) { if (!(t < s))
                    return t < 1.5 * s ? Math.floor(t / s) + " " + u : Math.ceil(t / s) + " " + u + "s"; }
                E.exports = function (t, s) { s = s || {}; var u, i = typeof t; if (i === "string" && t.length > 0)
                    return function (o) { if ((o = String(o)).length > 100)
                        return; var h = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(o); if (!h)
                        return; var a = parseFloat(h[1]); switch ((h[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y": return 315576e5 * a;
                        case "days":
                        case "day":
                        case "d": return a * c;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h": return a * e;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m": return a * r;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s": return a * d;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms": return a;
                        default: return;
                    } }(t); if (i === "number" && isNaN(t) === !1)
                    return s.long ? n(u = t, c, "day") || n(u, e, "hour") || n(u, r, "minute") || n(u, d, "second") || u + " ms" : function (o) { return o >= c ? Math.round(o / c) + "d" : o >= e ? Math.round(o / e) + "h" : o >= r ? Math.round(o / r) + "m" : o >= d ? Math.round(o / d) + "s" : o + "ms"; }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); };
            }, function (E, m, f) {
                "use strict";
                var d = f(364), r = f(365), e = Object.prototype.toString, c = typeof Blob == "function" || typeof Blob != "undefined" && e.call(Blob) === "[object BlobConstructor]", n = typeof File == "function" || typeof File != "undefined" && e.call(File) === "[object FileConstructor]";
                m.deconstructPacket = function (t) { var s = [], u = t.data, i = t; return i.data = function o(h, a) { if (!h)
                    return h; if (r(h)) {
                    var l = { _placeholder: !0, num: a.length };
                    return a.push(h), l;
                } if (d(h)) {
                    for (var p = new Array(h.length), g = 0; g < h.length; g++)
                        p[g] = o(h[g], a);
                    return p;
                } if (typeof h == "object" && !(h instanceof Date)) {
                    p = {};
                    for (var b in h)
                        p[b] = o(h[b], a);
                    return p;
                } return h; }(u, s), i.attachments = s.length, { packet: i, buffers: s }; }, m.reconstructPacket = function (t, s) { return t.data = function u(i, o) { if (!i)
                    return i; if (i && i._placeholder)
                    return o[i.num]; if (d(i))
                    for (var h = 0; h < i.length; h++)
                        i[h] = u(i[h], o);
                else if (typeof i == "object")
                    for (var a in i)
                        i[a] = u(i[a], o); return i; }(t.data, s), t.attachments = void 0, t; }, m.removeBlobs = function (t, s) { var u = 0, i = t; !function o(h, a, l) { if (!h)
                    return h; if (c && h instanceof Blob || n && h instanceof File) {
                    u++;
                    var p = new FileReader;
                    p.onload = function () { l ? l[a] = this.result : i = this.result, --u || s(i); }, p.readAsArrayBuffer(h);
                }
                else if (d(h))
                    for (var g = 0; g < h.length; g++)
                        o(h[g], g, h);
                else if (typeof h == "object" && !r(h))
                    for (var b in h)
                        o(h[b], b, h); }(i), u || s(i); };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(971), E.exports.parser = f(79);
            }, function (E, m, f) {
                "use strict";
                var d = f(367), r = f(78), e = f(128)("engine.io-client:socket"), c = f(371), n = f(79), t = f(363), s = f(126);
                function u(i, o) { if (!(this instanceof u))
                    return new u(i, o); o = o || {}, i && typeof i == "object" && (o = i, i = null), i ? (i = t(i), o.hostname = i.host, o.secure = i.protocol === "https" || i.protocol === "wss", o.port = i.port, i.query && (o.query = i.query)) : o.host && (o.hostname = t(o.host).host), this.secure = o.secure != null ? o.secure : typeof location != "undefined" && location.protocol === "https:", o.hostname && !o.port && (o.port = this.secure ? "443" : "80"), this.agent = o.agent || !1, this.hostname = o.hostname || (typeof location != "undefined" ? location.hostname : "localhost"), this.port = o.port || (typeof location != "undefined" && location.port ? location.port : this.secure ? 443 : 80), this.query = o.query || {}, typeof this.query == "string" && (this.query = s.decode(this.query)), this.upgrade = o.upgrade !== !1, this.path = (o.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!o.forceJSONP, this.jsonp = o.jsonp !== !1, this.forceBase64 = !!o.forceBase64, this.enablesXDR = !!o.enablesXDR, this.withCredentials = o.withCredentials !== !1, this.timestampParam = o.timestampParam || "t", this.timestampRequests = o.timestampRequests, this.transports = o.transports || ["polling", "websocket"], this.transportOptions = o.transportOptions || {}, this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.policyPort = o.policyPort || 843, this.rememberUpgrade = o.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = o.onlyBinaryUpgrades, this.perMessageDeflate = o.perMessageDeflate !== !1 && (o.perMessageDeflate || {}), this.perMessageDeflate === !0 && (this.perMessageDeflate = {}), this.perMessageDeflate && this.perMessageDeflate.threshold == null && (this.perMessageDeflate.threshold = 1024), this.pfx = o.pfx || null, this.key = o.key || null, this.passphrase = o.passphrase || null, this.cert = o.cert || null, this.ca = o.ca || null, this.ciphers = o.ciphers || null, this.rejectUnauthorized = o.rejectUnauthorized === void 0 || o.rejectUnauthorized, this.forceNode = !!o.forceNode, this.isReactNative = typeof navigator != "undefined" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative", (typeof self == "undefined" || this.isReactNative) && (o.extraHeaders && Object.keys(o.extraHeaders).length > 0 && (this.extraHeaders = o.extraHeaders), o.localAddress && (this.localAddress = o.localAddress)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingIntervalTimer = null, this.pingTimeoutTimer = null, this.open(); }
                E.exports = u, u.priorWebsocketSuccess = !1, r(u.prototype), u.protocol = n.protocol, u.Socket = u, u.Transport = f(208), u.transports = f(367), u.parser = f(79), u.prototype.createTransport = function (i) { e('creating transport "%s"', i); var o = function (a) { var l = {}; for (var p in a)
                    a.hasOwnProperty(p) && (l[p] = a[p]); return l; }(this.query); o.EIO = n.protocol, o.transport = i; var h = this.transportOptions[i] || {}; return this.id && (o.sid = this.id), new d[i]({ query: o, socket: this, agent: h.agent || this.agent, hostname: h.hostname || this.hostname, port: h.port || this.port, secure: h.secure || this.secure, path: h.path || this.path, forceJSONP: h.forceJSONP || this.forceJSONP, jsonp: h.jsonp || this.jsonp, forceBase64: h.forceBase64 || this.forceBase64, enablesXDR: h.enablesXDR || this.enablesXDR, withCredentials: h.withCredentials || this.withCredentials, timestampRequests: h.timestampRequests || this.timestampRequests, timestampParam: h.timestampParam || this.timestampParam, policyPort: h.policyPort || this.policyPort, pfx: h.pfx || this.pfx, key: h.key || this.key, passphrase: h.passphrase || this.passphrase, cert: h.cert || this.cert, ca: h.ca || this.ca, ciphers: h.ciphers || this.ciphers, rejectUnauthorized: h.rejectUnauthorized || this.rejectUnauthorized, perMessageDeflate: h.perMessageDeflate || this.perMessageDeflate, extraHeaders: h.extraHeaders || this.extraHeaders, forceNode: h.forceNode || this.forceNode, localAddress: h.localAddress || this.localAddress, requestTimeout: h.requestTimeout || this.requestTimeout, protocols: h.protocols || void 0, isReactNative: this.isReactNative }); }, u.prototype.open = function () { var i; if (this.rememberUpgrade && u.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
                    i = "websocket";
                else {
                    if (this.transports.length === 0) {
                        var o = this;
                        return void setTimeout(function () { o.emit("error", "No transports available"); }, 0);
                    }
                    i = this.transports[0];
                } this.readyState = "opening"; try {
                    i = this.createTransport(i);
                }
                catch (h) {
                    return this.transports.shift(), void this.open();
                } i.open(), this.setTransport(i); }, u.prototype.setTransport = function (i) { e("setting transport %s", i.name); var o = this; this.transport && (e("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = i, i.on("drain", function () { o.onDrain(); }).on("packet", function (h) { o.onPacket(h); }).on("error", function (h) { o.onError(h); }).on("close", function () { o.onClose("transport close"); }); }, u.prototype.probe = function (i) { e('probing transport "%s"', i); var o = this.createTransport(i, { probe: 1 }), h = !1, a = this; function l() { if (a.onlyBinaryUpgrades) {
                    var _ = !this.supportsBinary && a.transport.supportsBinary;
                    h = h || _;
                } h || (e('probe transport "%s" opened', i), o.send([{ type: "ping", data: "probe" }]), o.once("packet", function (k) { if (!h)
                    if (k.type === "pong" && k.data === "probe") {
                        if (e('probe transport "%s" pong', i), a.upgrading = !0, a.emit("upgrading", o), !o)
                            return;
                        u.priorWebsocketSuccess = o.name === "websocket", e('pausing current transport "%s"', a.transport.name), a.transport.pause(function () { h || a.readyState !== "closed" && (e("changing transport and sending upgrade packet"), R(), a.setTransport(o), o.send([{ type: "upgrade" }]), a.emit("upgrade", o), o = null, a.upgrading = !1, a.flush()); });
                    }
                    else {
                        e('probe transport "%s" failed', i);
                        var x = new Error("probe error");
                        x.transport = o.name, a.emit("upgradeError", x);
                    } })); } function p() { h || (h = !0, R(), o.close(), o = null); } function g(_) { var k = new Error("probe error: " + _); k.transport = o.name, p(), e('probe transport "%s" failed because of error: %s', i, _), a.emit("upgradeError", k); } function b() { g("transport closed"); } function I() { g("socket closed"); } function v(_) { o && _.name !== o.name && (e('"%s" works - aborting "%s"', _.name, o.name), p()); } function R() { o.removeListener("open", l), o.removeListener("error", g), o.removeListener("close", b), a.removeListener("close", I), a.removeListener("upgrading", v); } u.priorWebsocketSuccess = !1, o.once("open", l), o.once("error", g), o.once("close", b), this.once("close", I), this.once("upgrading", v), o.open(); }, u.prototype.onOpen = function () { if (e("socket open"), this.readyState = "open", u.priorWebsocketSuccess = this.transport.name === "websocket", this.emit("open"), this.flush(), this.readyState === "open" && this.upgrade && this.transport.pause) {
                    e("starting upgrade probes");
                    for (var i = 0, o = this.upgrades.length; i < o; i++)
                        this.probe(this.upgrades[i]);
                } }, u.prototype.onPacket = function (i) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
                    switch (e('socket receive: type "%s", data "%s"', i.type, i.data), this.emit("packet", i), this.emit("heartbeat"), i.type) {
                        case "open":
                            this.onHandshake(JSON.parse(i.data));
                            break;
                        case "pong":
                            this.setPing(), this.emit("pong");
                            break;
                        case "error":
                            var o = new Error("server error");
                            o.code = i.data, this.onError(o);
                            break;
                        case "message": this.emit("data", i.data), this.emit("message", i.data);
                    }
                else
                    e('packet received with socket readyState "%s"', this.readyState); }, u.prototype.onHandshake = function (i) { this.emit("handshake", i), this.id = i.sid, this.transport.query.sid = i.sid, this.upgrades = this.filterUpgrades(i.upgrades), this.pingInterval = i.pingInterval, this.pingTimeout = i.pingTimeout, this.onOpen(), this.readyState !== "closed" && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat)); }, u.prototype.onHeartbeat = function (i) { clearTimeout(this.pingTimeoutTimer); var o = this; o.pingTimeoutTimer = setTimeout(function () { o.readyState !== "closed" && o.onClose("ping timeout"); }, i || o.pingInterval + o.pingTimeout); }, u.prototype.setPing = function () { var i = this; clearTimeout(i.pingIntervalTimer), i.pingIntervalTimer = setTimeout(function () { e("writing ping packet - expecting pong within %sms", i.pingTimeout), i.ping(), i.onHeartbeat(i.pingTimeout); }, i.pingInterval); }, u.prototype.ping = function () { var i = this; this.sendPacket("ping", function () { i.emit("ping"); }); }, u.prototype.onDrain = function () { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emit("drain") : this.flush(); }, u.prototype.flush = function () { this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length && (e("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush")); }, u.prototype.write = u.prototype.send = function (i, o, h) { return this.sendPacket("message", i, o, h), this; }, u.prototype.sendPacket = function (i, o, h, a) { if (typeof o == "function" && (a = o, o = void 0), typeof h == "function" && (a = h, h = null), this.readyState !== "closing" && this.readyState !== "closed") {
                    (h = h || {}).compress = h.compress !== !1;
                    var l = { type: i, data: o, options: h };
                    this.emit("packetCreate", l), this.writeBuffer.push(l), a && this.once("flush", a), this.flush();
                } }, u.prototype.close = function () { if (this.readyState === "opening" || this.readyState === "open") {
                    this.readyState = "closing";
                    var i = this;
                    this.writeBuffer.length ? this.once("drain", function () { this.upgrading ? a() : o(); }) : this.upgrading ? a() : o();
                } function o() { i.onClose("forced close"), e("socket closing - telling transport to close"), i.transport.close(); } function h() { i.removeListener("upgrade", h), i.removeListener("upgradeError", h), o(); } function a() { i.once("upgrade", h), i.once("upgradeError", h); } return this; }, u.prototype.onError = function (i) { e("socket error %j", i), u.priorWebsocketSuccess = !1, this.emit("error", i), this.onClose("transport error", i); }, u.prototype.onClose = function (i, o) { (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (e('socket close with reason: "%s"', i), clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", i, o), this.writeBuffer = [], this.prevBufferLen = 0); }, u.prototype.filterUpgrades = function (i) { for (var o = [], h = 0, a = i.length; h < a; h++)
                    ~c(this.transports, i[h]) && o.push(i[h]); return o; };
            }, function (E, m, f) {
                "use strict";
                try {
                    E.exports = typeof XMLHttpRequest != "undefined" && "withCredentials" in new XMLHttpRequest;
                }
                catch (d) {
                    E.exports = !1;
                }
            }, function (E, m, f) {
                "use strict";
                var d = f(206), r = f(368), e = f(78), c = f(127), n = f(128)("engine.io-client:polling-xhr"), t = f(207);
                function s() { }
                function u(h) { if (r.call(this, h), this.requestTimeout = h.requestTimeout, this.extraHeaders = h.extraHeaders, typeof location != "undefined") {
                    var a = location.protocol === "https:", l = location.port;
                    l || (l = a ? 443 : 80), this.xd = typeof location != "undefined" && h.hostname !== location.hostname || l !== h.port, this.xs = h.secure !== a;
                } }
                function i(h) { this.method = h.method || "GET", this.uri = h.uri, this.xd = !!h.xd, this.xs = !!h.xs, this.async = h.async !== !1, this.data = h.data !== void 0 ? h.data : null, this.agent = h.agent, this.isBinary = h.isBinary, this.supportsBinary = h.supportsBinary, this.enablesXDR = h.enablesXDR, this.withCredentials = h.withCredentials, this.requestTimeout = h.requestTimeout, this.pfx = h.pfx, this.key = h.key, this.passphrase = h.passphrase, this.cert = h.cert, this.ca = h.ca, this.ciphers = h.ciphers, this.rejectUnauthorized = h.rejectUnauthorized, this.extraHeaders = h.extraHeaders, this.create(); }
                (E.exports = u, E.exports.Request = i, c(u, r), u.prototype.supportsBinary = !0, u.prototype.request = function (h) { return (h = h || {}).uri = this.uri(), h.xd = this.xd, h.xs = this.xs, h.agent = this.agent || !1, h.supportsBinary = this.supportsBinary, h.enablesXDR = this.enablesXDR, h.withCredentials = this.withCredentials, h.pfx = this.pfx, h.key = this.key, h.passphrase = this.passphrase, h.cert = this.cert, h.ca = this.ca, h.ciphers = this.ciphers, h.rejectUnauthorized = this.rejectUnauthorized, h.requestTimeout = this.requestTimeout, h.extraHeaders = this.extraHeaders, new i(h); }, u.prototype.doWrite = function (h, a) { var l = typeof h != "string" && h !== void 0, p = this.request({ method: "POST", data: h, isBinary: l }), g = this; p.on("success", a), p.on("error", function (b) { g.onError("xhr post error", b); }), this.sendXhr = p; }, u.prototype.doPoll = function () { n("xhr poll"); var h = this.request(), a = this; h.on("data", function (l) { a.onData(l); }), h.on("error", function (l) { a.onError("xhr poll error", l); }), this.pollXhr = h; }, e(i.prototype), i.prototype.create = function () { var h = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR }; h.pfx = this.pfx, h.key = this.key, h.passphrase = this.passphrase, h.cert = this.cert, h.ca = this.ca, h.ciphers = this.ciphers, h.rejectUnauthorized = this.rejectUnauthorized; var a = this.xhr = new d(h), l = this; try {
                    n("xhr open %s: %s", this.method, this.uri), a.open(this.method, this.uri, this.async);
                    try {
                        if (this.extraHeaders)
                            for (var p in a.setDisableHeaderCheck && a.setDisableHeaderCheck(!0), this.extraHeaders)
                                this.extraHeaders.hasOwnProperty(p) && a.setRequestHeader(p, this.extraHeaders[p]);
                    }
                    catch (g) { }
                    if (this.method === "POST")
                        try {
                            this.isBinary ? a.setRequestHeader("Content-type", "application/octet-stream") : a.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
                        }
                        catch (g) { }
                    try {
                        a.setRequestHeader("Accept", "*/*");
                    }
                    catch (g) { }
                    "withCredentials" in a && (a.withCredentials = this.withCredentials), this.requestTimeout && (a.timeout = this.requestTimeout), this.hasXDR() ? (a.onload = function () { l.onLoad(); }, a.onerror = function () { l.onError(a.responseText); }) : a.onreadystatechange = function () { if (a.readyState === 2)
                        try {
                            var g = a.getResponseHeader("Content-Type");
                            (l.supportsBinary && g === "application/octet-stream" || g === "application/octet-stream; charset=UTF-8") && (a.responseType = "arraybuffer");
                        }
                        catch (b) { } a.readyState === 4 && (a.status === 200 || a.status === 1223 ? l.onLoad() : setTimeout(function () { l.onError(typeof a.status == "number" ? a.status : 0); }, 0)); }, n("xhr data %s", this.data), a.send(this.data);
                }
                catch (g) {
                    return void setTimeout(function () { l.onError(g); }, 0);
                } typeof document != "undefined" && (this.index = i.requestsCount++, i.requests[this.index] = this); }, i.prototype.onSuccess = function () { this.emit("success"), this.cleanup(); }, i.prototype.onData = function (h) { this.emit("data", h), this.onSuccess(); }, i.prototype.onError = function (h) { this.emit("error", h), this.cleanup(!0); }, i.prototype.cleanup = function (h) { if (this.xhr !== void 0 && this.xhr !== null) {
                    if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = s : this.xhr.onreadystatechange = s, h)
                        try {
                            this.xhr.abort();
                        }
                        catch (a) { }
                    typeof document != "undefined" && delete i.requests[this.index], this.xhr = null;
                } }, i.prototype.onLoad = function () { var h; try {
                    var a;
                    try {
                        a = this.xhr.getResponseHeader("Content-Type");
                    }
                    catch (l) { }
                    h = (a === "application/octet-stream" || a === "application/octet-stream; charset=UTF-8") && this.xhr.response || this.xhr.responseText;
                }
                catch (l) {
                    this.onError(l);
                } h != null && this.onData(h); }, i.prototype.hasXDR = function () { return typeof XDomainRequest != "undefined" && !this.xs && this.enablesXDR; }, i.prototype.abort = function () { this.cleanup(); }, i.requestsCount = 0, i.requests = {}, typeof document != "undefined") && (typeof attachEvent == "function" ? attachEvent("onunload", o) : typeof addEventListener == "function" && addEventListener("onpagehide" in t ? "pagehide" : "unload", o, !1));
                function o() { for (var h in i.requests)
                    i.requests.hasOwnProperty(h) && i.requests[h].abort(); }
            }, function (E, m, f) {
                "use strict";
                E.exports = Object.keys || function (d) { var r = [], e = Object.prototype.hasOwnProperty; for (var c in d)
                    e.call(d, c) && r.push(c); return r; };
            }, function (E, m, f) {
                "use strict";
                var d = {}.toString;
                E.exports = Array.isArray || function (r) { return d.call(r) == "[object Array]"; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { var c = d.byteLength; if (r = r || 0, e = e || c, d.slice)
                    return d.slice(r, e); if (r < 0 && (r += c), e < 0 && (e += c), e > c && (e = c), r >= c || r >= e || c === 0)
                    return new ArrayBuffer(0); for (var n = new Uint8Array(d), t = new Uint8Array(e - r), s = r, u = 0; s < e; s++, u++)
                    t[u] = n[s]; return t.buffer; };
            }, function (E, m, f) {
                "use strict";
                function d() { }
                E.exports = function (r, e, c) { var n = !1; return c = c || d, t.count = r, r === 0 ? e() : t; function t(s, u) { if (t.count <= 0)
                    throw new Error("after called too many times"); --t.count, s ? (n = !0, e(s), e = c) : t.count !== 0 || n || e(null, u); } };
            }, function (E, m, f) {
                "use strict";
                var d, r, e, c = String.fromCharCode;
                function n(h) { for (var a, l, p = [], g = 0, b = h.length; g < b;)
                    (a = h.charCodeAt(g++)) >= 55296 && a <= 56319 && g < b ? (64512 & (l = h.charCodeAt(g++))) == 56320 ? p.push(((1023 & a) << 10) + (1023 & l) + 65536) : (p.push(a), g--) : p.push(a); return p; }
                function t(h, a) { if (h >= 55296 && h <= 57343) {
                    if (a)
                        throw Error("Lone surrogate U+" + h.toString(16).toUpperCase() + " is not a scalar value");
                    return !1;
                } return !0; }
                function s(h, a) { return c(h >> a & 63 | 128); }
                function u(h, a) { if ((4294967168 & h) == 0)
                    return c(h); var l = ""; return (4294965248 & h) == 0 ? l = c(h >> 6 & 31 | 192) : (4294901760 & h) == 0 ? (t(h, a) || (h = 65533), l = c(h >> 12 & 15 | 224), l += s(h, 6)) : (4292870144 & h) == 0 && (l = c(h >> 18 & 7 | 240), l += s(h, 12), l += s(h, 6)), l += c(63 & h | 128); }
                function i() { if (e >= r)
                    throw Error("Invalid byte index"); var h = 255 & d[e]; if (e++, (192 & h) == 128)
                    return 63 & h; throw Error("Invalid continuation byte"); }
                function o(h) { var a, l; if (e > r)
                    throw Error("Invalid byte index"); if (e == r)
                    return !1; if (a = 255 & d[e], e++, (128 & a) == 0)
                    return a; if ((224 & a) == 192) {
                    if ((l = (31 & a) << 6 | i()) >= 128)
                        return l;
                    throw Error("Invalid continuation byte");
                } if ((240 & a) == 224) {
                    if ((l = (15 & a) << 12 | i() << 6 | i()) >= 2048)
                        return t(l, h) ? l : 65533;
                    throw Error("Invalid continuation byte");
                } if ((248 & a) == 240 && (l = (7 & a) << 18 | i() << 12 | i() << 6 | i()) >= 65536 && l <= 1114111)
                    return l; throw Error("Invalid UTF-8 detected"); }
                E.exports = { version: "2.1.2", encode: function (h, a) { for (var l = (a = a || {}).strict !== !1, p = n(h), g = p.length, b = -1, I = ""; ++b < g;)
                        I += u(p[b], l); return I; }, decode: function (h, a) { var l = (a = a || {}).strict !== !1; d = n(h), r = d.length, e = 0; for (var p, g = []; (p = o(l)) !== !1;)
                        g.push(p); return function (b) { for (var I, v = b.length, R = -1, _ = ""; ++R < v;)
                        (I = b[R]) > 65535 && (_ += c((I -= 65536) >>> 10 & 1023 | 55296), I = 56320 | 1023 & I), _ += c(I); return _; }(g); } };
            }, function (E, m, f) {
                "use strict";
                var d;
                d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m.encode = function (r) { var e, c = new Uint8Array(r), n = c.length, t = ""; for (e = 0; e < n; e += 3)
                    t += d[c[e] >> 2], t += d[(3 & c[e]) << 4 | c[e + 1] >> 4], t += d[(15 & c[e + 1]) << 2 | c[e + 2] >> 6], t += d[63 & c[e + 2]]; return n % 3 == 2 ? t = t.substring(0, t.length - 1) + "=" : n % 3 == 1 && (t = t.substring(0, t.length - 2) + "=="), t; }, m.decode = function (r) { var e, c, n, t, s, u = .75 * r.length, i = r.length, o = 0; r[r.length - 1] === "=" && (u--, r[r.length - 2] === "=" && u--); var h = new ArrayBuffer(u), a = new Uint8Array(h); for (e = 0; e < i; e += 4)
                    c = d.indexOf(r[e]), n = d.indexOf(r[e + 1]), t = d.indexOf(r[e + 2]), s = d.indexOf(r[e + 3]), a[o++] = c << 2 | n >> 4, a[o++] = (15 & n) << 4 | t >> 2, a[o++] = (3 & t) << 6 | 63 & s; return h; };
            }, function (E, m, f) {
                "use strict";
                var d = d !== void 0 ? d : typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : typeof MSBlobBuilder != "undefined" ? MSBlobBuilder : typeof MozBlobBuilder != "undefined" && MozBlobBuilder, r = function () { try {
                    return new Blob(["hi"]).size === 2;
                }
                catch (u) {
                    return !1;
                } }(), e = r && function () { try {
                    return new Blob([new Uint8Array([1, 2])]).size === 2;
                }
                catch (u) {
                    return !1;
                } }(), c = d && d.prototype.append && d.prototype.getBlob;
                function n(u) { return u.map(function (i) { if (i.buffer instanceof ArrayBuffer) {
                    var o = i.buffer;
                    if (i.byteLength !== o.byteLength) {
                        var h = new Uint8Array(i.byteLength);
                        h.set(new Uint8Array(o, i.byteOffset, i.byteLength)), o = h.buffer;
                    }
                    return o;
                } return i; }); }
                function t(u, i) { i = i || {}; var o = new d; return n(u).forEach(function (h) { o.append(h); }), i.type ? o.getBlob(i.type) : o.getBlob(); }
                function s(u, i) { return new Blob(n(u), i || {}); }
                typeof Blob != "undefined" && (t.prototype = Blob.prototype, s.prototype = Blob.prototype), E.exports = r ? e ? Blob : s : c ? t : void 0;
            }, function (E, m, f) {
                "use strict";
                function d(e) { var c; function n() { if (n.enabled) {
                    var t = n, s = +new Date, u = s - (c || s);
                    t.diff = u, t.prev = c, t.curr = s, c = s;
                    for (var i = new Array(arguments.length), o = 0; o < i.length; o++)
                        i[o] = arguments[o];
                    i[0] = m.coerce(i[0]), typeof i[0] != "string" && i.unshift("%O");
                    var h = 0;
                    i[0] = i[0].replace(/%([a-zA-Z%])/g, function (l, p) { if (l === "%%")
                        return l; h++; var g = m.formatters[p]; if (typeof g == "function") {
                        var b = i[h];
                        l = g.call(t, b), i.splice(h, 1), h--;
                    } return l; }), m.formatArgs.call(t, i);
                    var a = n.log || m.log || console.log.bind(console);
                    a.apply(t, i);
                } } return n.namespace = e, n.enabled = m.enabled(e), n.useColors = m.useColors(), n.color = function (t) { var s, u = 0; for (s in t)
                    u = (u << 5) - u + t.charCodeAt(s), u |= 0; return m.colors[Math.abs(u) % m.colors.length]; }(e), n.destroy = r, typeof m.init == "function" && m.init(n), m.instances.push(n), n; }
                function r() { var e = m.instances.indexOf(this); return e !== -1 && (m.instances.splice(e, 1), !0); }
                (m = E.exports = d.debug = d.default = d).coerce = function (e) { return e instanceof Error ? e.stack || e.message : e; }, m.disable = function () { m.enable(""); }, m.enable = function (e) { var c; m.save(e), m.names = [], m.skips = []; var n = (typeof e == "string" ? e : "").split(/[\s,]+/), t = n.length; for (c = 0; c < t; c++)
                    n[c] && ((e = n[c].replace(/\*/g, ".*?"))[0] === "-" ? m.skips.push(new RegExp("^" + e.substr(1) + "$")) : m.names.push(new RegExp("^" + e + "$"))); for (c = 0; c < m.instances.length; c++) {
                    var s = m.instances[c];
                    s.enabled = m.enabled(s.namespace);
                } }, m.enabled = function (e) { if (e[e.length - 1] === "*")
                    return !0; var c, n; for (c = 0, n = m.skips.length; c < n; c++)
                    if (m.skips[c].test(e))
                        return !1; for (c = 0, n = m.names.length; c < n; c++)
                    if (m.names[c].test(e))
                        return !0; return !1; }, m.humanize = f(982), m.instances = [], m.names = [], m.skips = [], m.formatters = {};
            }, function (E, m, f) {
                "use strict";
                var d = 1e3, r = 6e4, e = 60 * r, c = 24 * e;
                function n(t, s, u) { if (!(t < s))
                    return t < 1.5 * s ? Math.floor(t / s) + " " + u : Math.ceil(t / s) + " " + u + "s"; }
                E.exports = function (t, s) { s = s || {}; var u, i = typeof t; if (i === "string" && t.length > 0)
                    return function (o) { if ((o = String(o)).length > 100)
                        return; var h = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(o); if (!h)
                        return; var a = parseFloat(h[1]); switch ((h[2] || "ms").toLowerCase()) {
                        case "years":
                        case "year":
                        case "yrs":
                        case "yr":
                        case "y": return 315576e5 * a;
                        case "days":
                        case "day":
                        case "d": return a * c;
                        case "hours":
                        case "hour":
                        case "hrs":
                        case "hr":
                        case "h": return a * e;
                        case "minutes":
                        case "minute":
                        case "mins":
                        case "min":
                        case "m": return a * r;
                        case "seconds":
                        case "second":
                        case "secs":
                        case "sec":
                        case "s": return a * d;
                        case "milliseconds":
                        case "millisecond":
                        case "msecs":
                        case "msec":
                        case "ms": return a;
                        default: return;
                    } }(t); if (i === "number" && isNaN(t) === !1)
                    return s.long ? n(u = t, c, "day") || n(u, e, "hour") || n(u, r, "minute") || n(u, d, "second") || u + " ms" : function (o) { return o >= c ? Math.round(o / c) + "d" : o >= e ? Math.round(o / e) + "h" : o >= r ? Math.round(o / r) + "m" : o >= d ? Math.round(o / d) + "s" : o + "ms"; }(t); throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t)); };
            }, function (E, m, f) {
                "use strict";
                var d = f(368), r = f(127), e = f(207);
                E.exports = u;
                var c, n = /\n/g, t = /\\n/g;
                function s() { }
                function u(i) { d.call(this, i), this.query = this.query || {}, c || (c = e.___eio = e.___eio || []), this.index = c.length; var o = this; c.push(function (h) { o.onData(h); }), this.query.j = this.index, typeof addEventListener == "function" && addEventListener("beforeunload", function () { o.script && (o.script.onerror = s); }, !1); }
                r(u, d), u.prototype.supportsBinary = !1, u.prototype.doClose = function () { this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), d.prototype.doClose.call(this); }, u.prototype.doPoll = function () { var i = this, o = document.createElement("script"); this.script && (this.script.parentNode.removeChild(this.script), this.script = null), o.async = !0, o.src = this.uri(), o.onerror = function (a) { i.onError("jsonp poll error", a); }; var h = document.getElementsByTagName("script")[0]; h ? h.parentNode.insertBefore(o, h) : (document.head || document.body).appendChild(o), this.script = o, typeof navigator != "undefined" && /gecko/i.test(navigator.userAgent) && setTimeout(function () { var a = document.createElement("iframe"); document.body.appendChild(a), document.body.removeChild(a); }, 100); }, u.prototype.doWrite = function (i, o) {
                    var h = this;
                    if (!this.form) {
                        var a, l = document.createElement("form"), p = document.createElement("textarea"), g = this.iframeId = "eio_iframe_" + this.index;
                        l.className = "socketio", l.style.position = "absolute", l.style.top = "-1000px", l.style.left = "-1000px", l.target = g, l.method = "POST", l.setAttribute("accept-charset", "utf-8"), p.name = "d", l.appendChild(p), document.body.appendChild(l), this.form = l, this.area = p;
                    }
                    function b() { I(), o(); }
                    function I() { if (h.iframe)
                        try {
                            h.form.removeChild(h.iframe);
                        }
                        catch (R) {
                            h.onError("jsonp polling iframe removal error", R);
                        } try {
                        var v = '<iframe src="javascript:0" name="' + h.iframeId + '">';
                        a = document.createElement(v);
                    }
                    catch (R) {
                        (a = document.createElement("iframe")).name = h.iframeId, a.src = "javascript:0";
                    } a.id = h.iframeId, h.form.appendChild(a), h.iframe = a; }
                    this.form.action = this.uri(), I(), i = i.replace(t, `\\
`), this.area.value = i.replace(n, "\\n");
                    try {
                        this.form.submit();
                    }
                    catch (v) { }
                    this.iframe.attachEvent ? this.iframe.onreadystatechange = function () { h.iframe.readyState === "complete" && b(); } : this.iframe.onload = b;
                };
            }, function (E, m, f) {
                "use strict";
                (function (d) { var r, e, c = f(208), n = f(79), t = f(126), s = f(127), u = f(370), i = f(128)("engine.io-client:websocket"); if (typeof WebSocket != "undefined" ? r = WebSocket : typeof self != "undefined" && (r = self.WebSocket || self.MozWebSocket), typeof window == "undefined")
                    try {
                        e = f(985);
                    }
                    catch (a) { } var o = r || e; function h(a) { a && a.forceBase64 && (this.supportsBinary = !1), this.perMessageDeflate = a.perMessageDeflate, this.usingBrowserWebSocket = r && !a.forceNode, this.protocols = a.protocols, this.usingBrowserWebSocket || (o = e), c.call(this, a); } E.exports = h, s(h, c), h.prototype.name = "websocket", h.prototype.supportsBinary = !0, h.prototype.doOpen = function () { if (this.check()) {
                    var a = this.uri(), l = this.protocols, p = {};
                    this.isReactNative || (p.agent = this.agent, p.perMessageDeflate = this.perMessageDeflate, p.pfx = this.pfx, p.key = this.key, p.passphrase = this.passphrase, p.cert = this.cert, p.ca = this.ca, p.ciphers = this.ciphers, p.rejectUnauthorized = this.rejectUnauthorized), this.extraHeaders && (p.headers = this.extraHeaders), this.localAddress && (p.localAddress = this.localAddress);
                    try {
                        this.ws = this.usingBrowserWebSocket && !this.isReactNative ? l ? new o(a, l) : new o(a) : new o(a, l, p);
                    }
                    catch (g) {
                        return this.emit("error", g);
                    }
                    this.ws.binaryType === void 0 && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners();
                } }, h.prototype.addEventListeners = function () { var a = this; this.ws.onopen = function () { a.onOpen(); }, this.ws.onclose = function () { a.onClose(); }, this.ws.onmessage = function (l) { a.onData(l.data); }, this.ws.onerror = function (l) { a.onError("websocket error", l); }; }, h.prototype.write = function (a) { var l = this; this.writable = !1; for (var p = a.length, g = 0, b = p; g < b; g++)
                    !function (v) { n.encodePacket(v, l.supportsBinary, function (R) { if (!l.usingBrowserWebSocket) {
                        var _ = {};
                        (v.options && (_.compress = v.options.compress), l.perMessageDeflate) && ((typeof R == "string" ? d.byteLength(R) : R.length) < l.perMessageDeflate.threshold && (_.compress = !1));
                    } try {
                        l.usingBrowserWebSocket ? l.ws.send(R) : l.ws.send(R, _);
                    }
                    catch (k) {
                        i("websocket closed before onclose event");
                    } --p || I(); }); }(a[g]); function I() { l.emit("flush"), setTimeout(function () { l.writable = !0, l.emit("drain"); }, 0); } }, h.prototype.onClose = function () { c.prototype.onClose.call(this); }, h.prototype.doClose = function () { this.ws !== void 0 && this.ws.close(); }, h.prototype.uri = function () { var a = this.query || {}, l = this.secure ? "wss" : "ws", p = ""; return this.port && (l === "wss" && Number(this.port) !== 443 || l === "ws" && Number(this.port) !== 80) && (p = ":" + this.port), this.timestampRequests && (a[this.timestampParam] = u()), this.supportsBinary || (a.b64 = 1), (a = t.encode(a)).length && (a = "?" + a), l + "://" + (this.hostname.indexOf(":") !== -1 ? "[" + this.hostname + "]" : this.hostname) + p + this.path + a; }, h.prototype.check = function () { return !(!o || "__initialize" in o && this.name === h.prototype.name); }; }).call(this, f(3).Buffer);
            }, function (E, m) { }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { for (var e = [], c = (r = r || 0) || 0; c < d.length; c++)
                    e[c - r] = d[c]; return e; };
            }, function (E, m, f) {
                "use strict";
                function d(r) { r = r || {}, this.ms = r.min || 100, this.max = r.max || 1e4, this.factor = r.factor || 2, this.jitter = r.jitter > 0 && r.jitter <= 1 ? r.jitter : 0, this.attempts = 0; }
                E.exports = d, d.prototype.duration = function () { var r = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) {
                    var e = Math.random(), c = Math.floor(e * this.jitter * r);
                    r = (1 & Math.floor(10 * e)) == 0 ? r - c : r + c;
                } return 0 | Math.min(r, this.max); }, d.prototype.reset = function () { this.attempts = 0; }, d.prototype.setMin = function (r) { this.ms = r; }, d.prototype.setMax = function (r) { this.max = r; }, d.prototype.setJitter = function (r) { this.jitter = r; };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(209), E.exports.source = f(209), E.exports.sink = f(376), E.exports.transform = f(989), E.exports.duplex = f(377);
            }, function (E, m, f) {
                "use strict";
                const d = f(377);
                E.exports = r => async function* (e) { const c = d(r); c.sink(e).catch(n => { }), yield* c.source; };
            }, function (E, m, f) {
                "use strict";
                E.exports = f(991);
            }, function (E, m, f) {
                "use strict";
                const d = f(27), r = f(96), e = f(1)("libp2p:mplex"), c = f(45), n = f(992), t = f(379), { MessageTypes: s, MessageTypeNames: u } = f(380), i = f(995);
                class o {
                    constructor(a) { a = typeof (a = a || {}) == "function" ? { onStream: a } : a, this._streamId = 0, this._streams = { initiators: new Map, receivers: new Map }, this._options = a, this.sink = this._createSink(), this.source = this._createSource(), this.onStream = a.onStream, this.onStreamEnd = a.onStreamEnd; }
                    get streams() { const a = []; return this._streams.initiators.forEach(l => { a.push(l); }), this._streams.receivers.forEach(l => { a.push(l); }), a; }
                    newStream(a) { const l = this._streamId++; a = a == null ? l.toString() : String(a); const p = this._streams.initiators; return this._newStream({ id: l, name: a, type: "initiator", registry: p }); }
                    _newReceiverStream({ id: a, name: l }) { const p = this._streams.receivers; return this._newStream({ id: a, name: l, type: "receiver", registry: p }); }
                    _newStream({ id: a, name: l, type: p, registry: g }) { if (g.has(a))
                        throw new Error(`${p} stream ${a} already exists!`); e("new %s stream %s %s", p, a, l); const b = i({ id: a, name: l, send: I => (e.enabled && e("%s stream %s %s send", p, a, l, { ...I, type: u[I.type], data: I.data && I.data.slice() }), this.source.push(I)), type: p, onEnd: () => { e("%s stream %s %s ended", p, a, l), g.delete(a), this.onStreamEnd && this.onStreamEnd(b); }, maxMsgSize: this._options.maxMsgSize }); return g.set(a, b), b; }
                    _createSink() { return async (a) => { this._options.signal && (a = c(a, this._options.signal)); try {
                        await d(a, n.decode, t(this._options.maxMsgSize), async (l) => { for await (const p of l)
                            for (const g of p)
                                this._handleIncoming(g); });
                    }
                    catch (l) {
                        return e("error in sink", l), this.source.end(l);
                    } this.source.end(); }; }
                    _createSource() { const a = r({ onEnd: l => { const { initiators: p, receivers: g } = this._streams; for (const b of p.values())
                            b.abort(l); for (const b of g.values())
                            b.abort(l); }, writev: !0 }); return Object.assign(n.encode(a), { push: a.push, end: a.end, return: a.return }); }
                    _handleIncoming({ id: a, type: l, data: p }) { if (e.enabled && e("incoming message", { id: a, type: u[l], data: p.slice() }), l === s.NEW_STREAM && this.onStream) {
                        const b = this._newReceiverStream({ id: a, name: p.toString() });
                        return this.onStream(b);
                    } const g = (1 & l ? this._streams.initiators : this._streams.receivers).get(a); if (!g)
                        return e("missing stream %s", a); switch (l) {
                        case s.MESSAGE_INITIATOR:
                        case s.MESSAGE_RECEIVER:
                            g.source.push(p);
                            break;
                        case s.CLOSE_INITIATOR:
                        case s.CLOSE_RECEIVER:
                            g.close();
                            break;
                        case s.RESET_INITIATOR:
                        case s.RESET_RECEIVER:
                            g.reset();
                            break;
                        default: e("unknown message type %s", l);
                    } }
                }
                o.multicodec = "/mplex/6.7.0", E.exports = o;
            }, function (E, m, f) {
                "use strict";
                m.encode = f(993), m.decode = f(994);
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(34), e = new class {
                    constructor() { this._pool = new Uint8Array(10240), this._poolOffset = 0; }
                    write(c) { const n = this._pool; let t = this._poolOffset; d.encode(c.id << 3 | c.type, n, t), t += d.encode.bytes, d.encode(c.data ? c.data.length : 0, n, t), t += d.encode.bytes; const s = n.subarray(this._poolOffset, t); return 10240 - t < 100 ? (this._pool = new Uint8Array(10240), this._poolOffset = 0) : this._poolOffset = t, c.data ? [s, c.data] : s; }
                };
                E.exports = c => async function* () { for await (const n of c)
                    Array.isArray(n) ? yield new r(n.map(t => e.write(t))) : yield new r(e.write(n)); }();
            }, function (E, m, f) {
                "use strict";
                const d = f(19), r = f(34);
                E.exports = c => async function* () { const n = new e; for await (const t of c) {
                    const s = n.write(t);
                    s.length && (yield s);
                } }();
                class e {
                    constructor() { this._buffer = new r, this._bufferProxy = new Proxy({}, { get: (n, t) => t[0] === "l" ? this._buffer[t] : this._buffer.get(parseInt(t)) }), this._headerInfo = null; }
                    write(n) { if (!n || !n.length)
                        return []; this._buffer.append(n); const t = []; for (;;) {
                        if (!this._headerInfo)
                            try {
                                this._headerInfo = this._decodeHeader(this._bufferProxy);
                            }
                            catch (h) {
                                break;
                            }
                        const { id: s, type: u, length: i, offset: o } = this._headerInfo;
                        if (this._buffer.length - o < i)
                            break;
                        t.push({ id: s, type: u, data: this._buffer.shallowSlice(o, o + i) }), this._buffer.consume(o + i), this._headerInfo = null;
                    } return t; }
                    _decodeHeader(n) { const t = d.decode(n); let s = d.decode.bytes; const u = d.decode(n, s); return s += d.decode.bytes, { id: t >> 3, type: 7 & t, offset: s, length: u }; }
                }
            }, function (E, m, f) {
                "use strict";
                const d = f(45), r = f(47), e = f(1)("libp2p:mplex:stream"), c = f(96), n = f(34), t = f(0), { MAX_MSG_SIZE: s } = f(379), { InitiatorMessageTypes: u, ReceiverMessageTypes: i } = f(380);
                E.exports = ({ id: o, name: h, send: a, onEnd: l = () => { }, type: p = "initiator", maxMsgSize: g = s }) => { const b = new r, I = new r, v = p === "initiator" ? u : i, R = p === "initiator" ? "i" + o : "r" + o; h = String(h !== null && h !== void 0 ? h : o); let _, k = !1, x = !1; const M = S => { x || (x = !0, e("%s stream %s sink end", p, h, S), S && !_ && (_ = S), k && (N.timeline.close = Date.now(), l(_))); }, N = { close: () => N.source.end(), abort: S => { e("%s stream %s abort", p, h, S), N.source.end(S), b.abort(), M(S); }, reset: () => { const S = t(new Error("stream reset"), "ERR_MPLEX_STREAM_RESET"); I.abort(), N.source.end(S), M(S); }, sink: async (S) => { S = d(S, [{ signal: b.signal, options: { abortMessage: "stream aborted", abortCode: "ERR_MPLEX_STREAM_ABORT" } }, { signal: I.signal, options: { abortMessage: "stream reset", abortCode: "ERR_MPLEX_STREAM_RESET" } }]), p === "initiator" && a({ id: o, type: v.NEW_STREAM, data: h }); try {
                        for await (let T of S)
                            for (; T.length;) {
                                if (T.length <= g) {
                                    a({ id: o, type: v.MESSAGE, data: T });
                                    break;
                                }
                                T = n.isBufferList(T) ? T : new n(T), a({ id: o, type: v.MESSAGE, data: T.shallowSlice(0, g) }), T.consume(g);
                            }
                    }
                    catch (T) {
                        return T.code === "ERR_MPLEX_STREAM_RESET" ? e("%s stream %s reset", p, h) : (e("%s stream %s error", p, h, T), a({ id: o, type: v.RESET })), N.source.end(T), M(T);
                    } a({ id: o, type: v.CLOSE }), M(); }, source: c(S => { k || (k = !0, e("%s stream %s source end", p, h, S), S && !_ && (_ = S), x && (N.timeline.close = Date.now(), l(_))); }), timeline: { open: Date.now(), close: null }, id: R }; return N; };
            }, function (E, m, f) {
                "use strict";
                var d = Object.create ? function (c, n, t, s) { s === void 0 && (s = t), Object.defineProperty(c, s, { enumerable: !0, get: function () { return n[t]; } }); } : function (c, n, t, s) { s === void 0 && (s = t), c[s] = n[t]; }, r = function (c, n) { for (var t in c)
                    t === "default" || n.hasOwnProperty(t) || d(n, c, t); };
                Object.defineProperty(m, "__esModule", { value: !0 }), m.NOISE = void 0;
                const e = f(381);
                r(f(381), m), m.NOISE = new e.Noise;
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42), e = f(998), c = f(1001), { padRight: n } = f(1003); E.exports = class {
                    constructor(t, s, u) { r(typeof t == "string"), r(!s || typeof s == "string"), this.id = t, this.type = "ecdh", this.eid = s || null, this._pre = u || null, this._curve = null, this._edwards = null, this.native = 0; }
                    get curve() { return this._curve || (this._curve = e.curve(this.id)), this._curve; }
                    get edwards() { return this.eid && !this._edwards && (this._edwards = e.curve(this.eid, this._pre), this._edwards.precompute(c), this._pre = null), this._edwards; }
                    get size() { return this.curve.fieldSize; }
                    get bits() { return this.curve.fieldBits; }
                    privateKeyGenerate() { const t = c.randomBytes(this.curve.scalarSize); return this.curve.clamp(t); }
                    privateKeyVerify(t) { return r(d.isBuffer(t)), t.length === this.curve.scalarSize; }
                    privateKeyExport(t, s) { const u = this.publicKeyCreate(t), { x: i, y: o } = this.publicKeyExport(u, s); return { d: d.from(t), x: i, y: o }; }
                    privateKeyImport(t) { return r(t && typeof t == "object"), n(t.d, this.curve.scalarSize); }
                    publicKeyCreate(t) { const s = this.curve.decodeClamped(t); if (this.edwards && this.edwards.g.pre) {
                        const u = this.edwards.g.mulBlind(s);
                        return this.curve.pointFromEdwards(u).encode();
                    } return this.curve.g.toX().mulBlind(s, c).encode(); }
                    publicKeyConvert(t, s) { if (r(s == null || typeof s == "boolean"), !this.edwards)
                        throw new Error("No equivalent edwards curve."); const u = this.curve.decodePoint(t), i = this.edwards.pointFromMont(u); return s != null && i.isOdd() !== s ? i.neg().encode() : i.encode(); }
                    publicKeyFromUniform(t) { const s = this.curve.decodeUniform(t); return this.curve.pointFromUniform(s).encode(); }
                    publicKeyToUniform(t, s = c.randomInt()) { const u = this.curve.decodePoint(t), i = this.curve.pointToUniform(u, s); return this.curve.encodeUniform(i, s >>> 8); }
                    publicKeyFromHash(t, s = !1) { return this.curve.pointFromHash(t, s).encode(); }
                    publicKeyToHash(t, s = c.randomInt()) { const u = this.curve.decodePoint(t); return this.curve.pointToHash(u, s, c); }
                    publicKeyVerify(t) { let s; r(d.isBuffer(t)); try {
                        s = this.curve.decodeX(t);
                    }
                    catch (u) {
                        return !1;
                    } return s.validate(); }
                    publicKeyIsSmall(t) { let s; r(d.isBuffer(t)); try {
                        s = this.curve.decodeX(t);
                    }
                    catch (u) {
                        return !1;
                    } return !!s.validate() && s.isSmall(); }
                    publicKeyHasTorsion(t) { let s; r(d.isBuffer(t)); try {
                        s = this.curve.decodeX(t);
                    }
                    catch (u) {
                        return !1;
                    } return !!s.validate() && s.hasTorsion(); }
                    publicKeyExport(t, s) { const { x: u, y: i } = this.curve.decodePoint(t, s); return { x: this.curve.encodeField(u.fromRed()), y: this.curve.encodeField(i.fromRed()) }; }
                    publicKeyImport(t) { r(t && typeof t == "object"); const s = n(t.x, this.curve.fieldSize), u = this.curve.decodeX(s); if (!u.validate())
                        throw new Error("Invalid point."); return u.encode(); }
                    derive(t, s) { const u = this.curve.decodeX(t), i = this.curve.decodeClamped(s); return u.mulConst(i, c).encode(); }
                }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const { custom: r } = f(382), e = f(999), c = 0, n = 1, t = 2, s = 3, u = [-3, -1, -5, -7, 0, 7, 5, 1, 3]; let i = 0; class o {
                    constructor(y, C, A) { this.Point = null, this.id = null, this.uid = i++, this.ossl = null, this.type = "base", this.endian = "be", this.hash = null, this.prefix = null, this.context = !1, this.prime = null, this.p = null, this.red = null, this.fieldSize = 0, this.fieldBits = 0, this.adjustedSize = 0, this.signBit = 0, this.mask = 0, this.n = null, this.h = null, this.q = null, this.z = null, this.g = null, this.nh = null, this.scalarSize = 0, this.scalarBits = 0, this.zero = null, this.one = null, this.two = null, this.three = null, this.four = null, this.i2 = null, this.i3 = null, this.i4 = null, this.i6 = null, this.torsion = null, this.endo = null, this.hi = null, this._init(y, C, A); }
                    _init(y, C, A) { D(typeof y == "function"), D(typeof C == "string"), D(A && typeof A == "object"), D(A.red == null || A.red instanceof e.Red), D(A.p != null, "Must pass a prime."), D(A.id == null || typeof A.id == "string"), D(A.ossl == null || typeof A.ossl == "string"), D(A.endian == null || typeof A.endian == "string"), D(A.hash == null || typeof A.hash == "string"), D(A.prefix == null || typeof A.prefix == "string"), D(A.context == null || typeof A.context == "boolean"), D(A.prime == null || typeof A.prime == "string"), D(A.torsion == null || Array.isArray(A.torsion)), this.Point = y, this.id = A.id || null, this.ossl = A.ossl || null, this.type = C, this.endian = A.endian || (C === "short" ? "be" : "le"), this.hash = A.hash || null, this.prefix = A.prefix ? d.from(A.prefix, "binary") : null, this.context = A.context || !1, this.prime = A.prime || null, this.p = e.fromJSON(A.p), A.red ? this.red = A.red : (this.red = A.prime ? e.red(A.prime) : e.mont(this.p), this.red.precompute()), this.fieldSize = this.p.byteLength(), this.fieldBits = this.p.bitLength(), this.adjustedSize = this.fieldSize + ((7 & this.fieldBits) == 0), this.signBit = 8 * this.adjustedSize - 1, this.mask = 255, (7 & this.fieldBits) != 0 && (this.mask = (1 << (7 & this.fieldBits)) - 1), this.n = e.fromJSON(A.n || "0"), this.h = e.fromJSON(A.h || "1"), this.q = this.n.mul(this.h), this.z = e.fromJSON(A.z || "0").toRed(this.red), this.g = null, this.nh = this.n.ushrn(1), this.scalarSize = this.n.byteLength(), this.scalarBits = this.n.bitLength(), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.three = new e(3).toRed(this.red), this.four = new e(4).toRed(this.red), this.i2 = this.two.redInvert(), this.i3 = this.three.redInvert(), this.i4 = this.i2.redSqr(), this.i6 = this.i2.redMul(this.i3), this.torsion = new Array(this.h.word(0)); for (let U = 0; U < this.torsion.length; U++)
                        this.torsion[U] = this.point(); return this.endo = null, this.hi = null, this._scale = F(this._scale, this), this.isIsomorphic = F(this.isIsomorphic, this), this.isIsogenous = F(this.isIsogenous, this), D(this.p.sign() > 0 && this.p.isOdd()), D(this.n.sign() >= 0), D(this.h.sign() > 0 && this.h.cmpn(255) <= 0), D(this.endian === "be" || this.endian === "le"), this; }
                    _finalize(y) { if (D(y && typeof y == "object"), this.g = y.g ? this.pointFromJSON(y.g) : this.point(), y.torsion) {
                        D(y.torsion.length === this.torsion.length);
                        for (let C = 0; C < this.torsion.length; C++)
                            this.torsion[C] = this.pointFromJSON(y.torsion[C]);
                    } return this; }
                    _findTorsion() { D(!this.n.isZero()); const y = this.h.word(0), C = this.one.redNeg(), A = [this.point()], U = new Set; let z = y; for (; A.length < z;) {
                        let w;
                        C.redIAdd(this.one);
                        try {
                            w = this.pointFromX(C.clone());
                        }
                        catch (O) {
                            continue;
                        }
                        try {
                            w = w.mul(this.n);
                        }
                        catch (O) {
                            z = 2;
                            continue;
                        }
                        if (!w.isInfinity()) {
                            w.normalize();
                            for (const O of [w, w.neg()]) {
                                const q = O.key();
                                U.has(q) || (A.push(O), U.add(q));
                            }
                        }
                    } for (A.sort((w, O) => w.cmp(O)); A.length < y;)
                        A.push(this.point()); return A; }
                    _simpleMul(y, C) { D(y instanceof h), D(C instanceof e), D(!C.red); const A = C.bitLength(); C.isNeg() && (y = y.neg()); let U = this.jpoint(); for (let z = A - 1; z >= 0; z--) {
                        const w = C.bit(z);
                        U = U.dbl(), w === 1 && (U = U.add(y));
                    } return U; }
                    _simpleMulAdd(y, C) { D(Array.isArray(y)), D(Array.isArray(C)), D(y.length === C.length); const A = y.length, U = new Array(A), z = C; let w = 0; for (let q = 0; q < A; q++) {
                        const H = y[q], V = C[q];
                        if (D(H instanceof h), D(V instanceof e), D(!V.red), q > 0 && H.type !== y[q - 1].type)
                            throw new Error("Cannot mix points.");
                        U[q] = V.isNeg() ? H.neg() : H, w = Math.max(w, V.bitLength());
                    } let O = this.jpoint(); for (let q = w - 1; q >= 0; q--) {
                        O = O.dbl();
                        for (let H = 0; H < A; H++) {
                            const V = U[H];
                            z[H].bit(q) === 1 && (O = O.add(V));
                        }
                    } return O; }
                    _constMul(y, C, A) { return D(y instanceof h), this.n.isZero() ? this._simpleMul(y, C) : this.type === "short" && this.h.cmpn(1) === 0 ? this._coZLadderMul(y, C) : this._ladderMul(y, C); }
                    _ladderMul(y, C) { D(y instanceof h), D(C instanceof e), D(!C.red); const [A, U, z] = function (H, V) { D(H instanceof e), D(V instanceof e); const J = H.abs().add(V), Z = J.add(V), tt = J.bitLength(), nt = V.bitLength(); J.cinject(Z, tt - nt - 1 >>> 31); const rt = 1 & H.isNeg(), it = J.bitLength(), st = J.toArray("le"); return [rt, it, st]; }(C, this.q); let w = y.toJ().clone(), O = this.jpoint().clone(), q = 0; for (let H = U - 1; H >= 0; H--) {
                        const V = z[H >> 3] >> (7 & H) & 1;
                        w.swap(O, q ^ V), w = w.uadd(O), O = O.udbl(), q = V;
                    } return w.swap(O, q), O.swap(O.neg(), A), O; }
                    _coZLadderMul(y, C) { D(y instanceof h), D(C instanceof e), D(!C.red); const A = y.toJ().clone(), [U, z, w, O] = function (J, Z) { D(J instanceof e), D(Z instanceof e); const tt = J.mod(Z), nt = Z.sub(tt), rt = tt.bitLength(), it = nt.bitLength(), st = rt - it >>> 31; tt.cinject(nt, st); const at = tt.bitLength(), ct = tt.toArray("le"), lt = tt.ceq(Z.subn(1)); return [st, at, ct, lt]; }(C, this.n); let [q, H] = A.zdblu(), V = 0; for (let J = z - 2; J >= 0; J--) {
                        const Z = w[J >> 3] >> (7 & J) & 1;
                        q.swap(H, V ^ Z), [q, H] = H.zaddc(q), [H, q] = q.zaddu(H), V = Z;
                    } return q.swap(H, V), H.swap(A.neg(), O), H.swap(H.neg(), U), H; }
                    _fixedMul(y, C) { D(y instanceof h), D(C instanceof e), D(y.pre && y.pre.windows); const { width: A, bits: U, points: z } = y._getWindows(0, 0), w = 1 << A, O = (U + A - 1) / A >>> 0; let q = this.jpoint(); for (let H = 0; H < O; H++) {
                        const V = C.bits(H * A, A);
                        q = q.add(z[H * w + V]);
                    } return C.isNeg() && (q = q.neg()), q; }
                    _fixedNafMul(y, C) { D(y instanceof h), D(C instanceof e), D(y.pre && y.pre.doubles); const { step: A, points: U } = y._getDoubles(0, 0), z = function (H, V, J, Z) { D(Z >>> 0 === Z); const tt = L(H, V, J), nt = Math.ceil(tt.length / Z), rt = new Array(nt); let it = 0; for (let st = 0; st < tt.length; st += Z) {
                        let at = 0;
                        for (let ct = st + Z - 1; ct >= st; ct--)
                            at = (at << 1) + tt[ct];
                        rt[it++] = at;
                    } return D(it === nt), rt; }(C, 2, C.bitLength() + 1, A), w = ((1 << A + 1) - (A % 2 == 0 ? 2 : 1)) / 3; let O = this.jpoint(), q = this.jpoint(); for (let H = w; H > 0; H--) {
                        for (let V = 0; V < z.length; V++) {
                            const J = z[V];
                            J === H ? q = q.add(U[V]) : J === -H && (q = q.sub(U[V]));
                        }
                        O = O.add(q);
                    } return O; }
                    _windowMul(y, C, A) { D(y >>> 0 === y), D(C instanceof h), D(A instanceof e); const U = 1 << y, z = (Math.max(A.bitLength(), this.n.bitLength()) + y - 1) / y >>> 0, w = new Array(U), O = C.toJ(); w[0] = this.jpoint(), w[1] = O; for (let H = 2; H < U; H += 2)
                        w[H + 0] = w[H >> 1].dbl(), w[H + 1] = w[H].add(O); let q = this.jpoint(); for (let H = z - 1; H >= 0; H--) {
                        const V = A.bits(H * y, y);
                        H === z - 1 ? q = w[V] : (q = q.dblp(y), q = q.add(w[V]));
                    } return A.isNeg() && (q = q.neg()), q; }
                    _slideMul(y, C, A) { D(y >>> 0 === y), D(C instanceof h), D(A instanceof e); const U = 1 << y - 1, z = new Array(U), w = C.toJ(); z[0] = w.dblp(y - 1); for (let H = 1; H < U; H++)
                        z[H] = z[H - 1].add(w); let O = A.bitLength(), q = this.jpoint(); for (; O >= y;) {
                        const H = O - y, V = A.bits(H, y);
                        V < U ? (q = q.dbl(), O -= 1) : (q = q.dblp(y), q = q.add(z[V & ~U]), O = H);
                    } if (O > 0) {
                        const H = A.bits(0, O);
                        for (; O--;)
                            q = q.dbl(), H >> O & 1 && (q = q.add(C));
                    } return A.isNeg() && (q = q.neg()), q; }
                    _wnafMul(y, C, A) { D(C instanceof h), D(A instanceof e); const { width: U, points: z } = C._safeNAF(y), w = L(A, U, A.bitLength() + 1); let O = this.jpoint(); for (let q = w.length - 1; q >= 0; q--) {
                        const H = w[q];
                        q !== w.length - 1 && (O = O.dbl()), H > 0 ? O = O.add(z[H - 1 >> 1]) : H < 0 && (O = O.sub(z[-H - 1 >> 1]));
                    } return O; }
                    _wnafMulAdd(y, C, A) { D(y >>> 0 === y), D(Array.isArray(C)), D(Array.isArray(A)), D(C.length === A.length); const U = C.length, z = new Array(U), w = new Array(U); let O = 0; for (let Z = 0; Z < U; Z++) {
                        const tt = C[Z], nt = A[Z];
                        if (D(tt instanceof h), D(nt instanceof e), Z > 0 && tt.type !== C[Z - 1].type)
                            throw new Error("Cannot mix points.");
                        z[Z] = null, w[Z] = null, O = Math.max(O, nt.bitLength() + 1);
                    } let q = null, H = null, V = 0; for (let Z = 0; Z < U; Z++) {
                        const tt = C[Z], nt = A[Z], rt = tt._getNAF(0);
                        rt ? (z[V] = rt.points, w[V] = L(nt, rt.width, O), V += 1) : q ? (z[V] = q._getJNAF(tt), w[V] = j(H, nt, O), q = null, H = null, V += 1) : (q = tt, H = nt);
                    } if (q) {
                        const Z = q._safeNAF(y);
                        z[V] = Z.points, w[V] = L(H, Z.width, O), V += 1;
                    } let J = this.jpoint(); for (let Z = O - 1; Z >= 0; Z--) {
                        Z !== O - 1 && (J = J.dbl());
                        for (let tt = 0; tt < V; tt++) {
                            const nt = w[tt][Z];
                            nt > 0 ? J = J.add(z[tt][nt - 1 >> 1]) : nt < 0 && (J = J.sub(z[tt][-nt - 1 >> 1]));
                        }
                    } return J; }
                    _endoWnafMulAdd(y, C) { throw new Error("Not implemented."); }
                    _scale(y, C) { switch (D(y instanceof o), D(y.p.eq(this.p)), y.type) {
                        case "short": return this._scaleShort(y, C);
                        case "mont": return this._scaleMont(y, C);
                        case "edwards": return this._scaleEdwards(y, C);
                        default: throw new Error("Not implemented.");
                    } }
                    _scaleShort(y, C) { throw new Error("Not implemented."); }
                    _scaleMont(y, C) { throw new Error("Not implemented."); }
                    _scaleEdwards(y, C) { throw new Error("Not implemented."); }
                    isElliptic() { throw new Error("Not implemented."); }
                    jinv() { throw new Error("Not implemented."); }
                    isComplete() { return !1; }
                    precompute(y) { return D(!this.g.isInfinity(), "Must have base point."), D(!this.n.isZero(), "Must have order."), this.g.precompute(this.n.bitLength(), y), this; }
                    scalar(y, C, A) { const U = new e(y, C, A); return D(!U.red), this.n.isZero() ? U : U.imod(this.n); }
                    field(y, C, A) { const U = e.cast(y, C, A); return U.red ? U.forceRed(this.red) : U.toRed(this.red); }
                    point(y, C) { throw new Error("Not implemented."); }
                    jpoint(y, C, A) { throw new Error("Not implemented."); }
                    xpoint(y, C) { throw new Error("Not implemented."); }
                    cpoint(y, C, A, U) { if (D(y instanceof e), D(C instanceof e), D(A instanceof e), D(U instanceof e), C.isZero() || U.isZero())
                        return this.point(); const z = C.redMul(U).redInvert(), w = y.redMul(U).redMul(z), O = A.redMul(C).redMul(z); return this.point(w, O); }
                    solveX2(y) { throw new Error("Not implemented."); }
                    solveX(y) { return this.solveX2(y).redSqrt(); }
                    solveY2(y) { throw new Error("Not implemented."); }
                    solveY(y) { return this.solveY2(y).redSqrt(); }
                    validate(y) { throw new Error("Not implemented."); }
                    pointFromX(y, C) { throw new Error("Not implemented."); }
                    pointFromY(y, C) { throw new Error("Not implemented."); }
                    isIsomorphic(y) { throw new Error("Not implemented."); }
                    isIsogenous(y) { throw new Error("Not implemented."); }
                    pointFromShort(y) { throw new Error("Not implemented."); }
                    pointFromMont(y, C) { throw new Error("Not implemented."); }
                    pointFromEdwards(y) { throw new Error("Not implemented."); }
                    pointFromUniform(y) { throw new Error("Not implemented."); }
                    pointToUniform(y) { throw new Error("Not implemented."); }
                    pointFromHash(y, C = !1) { if (D(d.isBuffer(y)), D(typeof C == "boolean"), y.length !== 2 * this.fieldSize)
                        throw new Error("Invalid hash size."); const A = y.slice(0, this.fieldSize), U = y.slice(this.fieldSize), z = this.decodeUniform(A), w = this.decodeUniform(U), O = this.pointFromUniform(z), q = this.pointFromUniform(w), H = O.uadd(q); return C ? H.mulH() : H; }
                    pointToHash(y, C, A) { D(y instanceof this.Point), D(C >>> 0 === C); const U = C % this.torsion.length, z = y.add(this.torsion[U]); for (;;) {
                        const w = this.randomField(A), O = this.pointFromUniform(w);
                        if (O.neg().eq(O))
                            continue;
                        const q = z.usub(O), H = K(A);
                        let V;
                        try {
                            V = this.pointToUniform(q, 15 & H);
                        }
                        catch (tt) {
                            if (tt.message === "Invalid point.")
                                continue;
                            throw tt;
                        }
                        const J = this.encodeUniform(w, H >>> 8), Z = this.encodeUniform(V, H >>> 16);
                        return d.concat([J, Z]);
                    } }
                    randomScalar(y) { const C = this.n.isZero() ? this.p : this.n; return e.random(y, 1, C); }
                    randomField(y) { return e.random(y, 1, this.p).toRed(this.red); }
                    randomPoint(y) { let C; for (;;) {
                        const A = this.randomField(y), U = (1 & K(y)) != 0;
                        try {
                            C = this.pointFromX(A, U);
                        }
                        catch (z) {
                            continue;
                        }
                        return D(C.validate()), C.mulH();
                    } }
                    mulAll(y, C) { return this.jmulAll(y, C); }
                    mulAllSimple(y, C) { return this.jmulAllSimple(y, C); }
                    jmulAll(y, C) { return D(Array.isArray(y)), D(y.length === 0 || y[0] instanceof h), this.endo && y.length > 0 && y[0].type === c ? this._endoWnafMulAdd(y, C) : this._wnafMulAdd(5, y, C); }
                    jmulAllSimple(y, C) { return this._simpleMulAdd(y, C); }
                    mulH(y) { return D(y instanceof e), this.imulH(y.clone()); }
                    imulH(y) { D(y instanceof e), D(!y.red); const C = this.h.word(0); if ((C & C - 1) == 0) {
                        const A = this.h.bitLength();
                        return y.iushln(A - 1).imod(this.n);
                    } return y.imuln(C).imod(this.n); }
                    clamp(y) { D(d.isBuffer(y)), D(y.length === this.scalarSize), D(this.scalarSize <= this.fieldSize); let C = 7 & this.fieldBits || 8, A = 0, U = this.scalarSize - 1; return this.endian === "be" && ([A, U] = [U, A]), this.scalarSize < this.fieldSize && (C = 8), y[A] &= 255 & -this.h.word(0), y[U] &= (1 << C) - 1, y[U] |= 1 << C - 1, y; }
                    splitHash(y) { D(d.isBuffer(y)), D(y.length === 2 * this.adjustedSize), D(this.scalarSize <= this.adjustedSize); let C = 0; this.endian === "be" && (C = this.adjustedSize - this.scalarSize); const A = y.slice(C, C + this.scalarSize), U = y.slice(this.adjustedSize); return this.clamp(A), [A, U]; }
                    encodeField(y) { return D(y instanceof e), D(!y.red), y.encode(this.endian, this.fieldSize); }
                    decodeField(y) { if (D(d.isBuffer(y)), y.length !== this.fieldSize)
                        throw new Error("Invalid field element size."); return e.decode(y, this.endian); }
                    encodeAdjusted(y) { return D(y instanceof e), D(!y.red), y.encode(this.endian, this.adjustedSize); }
                    decodeAdjusted(y) { if (D(d.isBuffer(y)), y.length !== this.adjustedSize)
                        throw new Error("Invalid field element size."); return e.decode(y, this.endian); }
                    encodeScalar(y) { return D(y instanceof e), D(!y.red), y.encode(this.endian, this.scalarSize); }
                    decodeScalar(y) { if (D(d.isBuffer(y)), y.length !== this.scalarSize)
                        throw new Error("Invalid scalar size."); return e.decode(y, this.endian); }
                    encodeClamped(y) { return this.clamp(this.encodeScalar(y)); }
                    decodeClamped(y) { if (D(d.isBuffer(y)), y.length !== this.scalarSize)
                        throw new Error("Invalid scalar size."); const C = this.clamp(d.from(y)); return e.decode(C, this.endian); }
                    encodeUniform(y, C) { D(y instanceof e), D(C >>> 0 === C); const A = this.endian === "le" ? this.fieldSize - 1 : 0, U = y.fromRed().encode(this.endian, this.fieldSize); return U[A] |= C & ~this.mask & 255, U; }
                    decodeUniform(y) { if (D(d.isBuffer(y)), y.length !== this.fieldSize)
                        throw new Error("Invalid field size."); const C = e.decode(y, this.endian); return C.iumaskn(this.fieldBits), C.toRed(this.red); }
                    encodePoint(y, C) { return D(y instanceof h), y.encode(C); }
                    decodePoint(y) { throw new Error("Not implemented."); }
                    encodeX(y) { throw new Error("Not implemented."); }
                    decodeX(y) { throw new Error("Not implemented."); }
                    decodeEven(y) { throw new Error("Not implemented."); }
                    decodeSquare(y) { throw new Error("Not implemented."); }
                    toShort() { throw new Error("Not implemented."); }
                    toMont(y) { throw new Error("Not implemented."); }
                    toEdwards(y) { throw new Error("Not implemented."); }
                    pointToJSON(y, C) { return D(y instanceof h), y.toJSON(C); }
                    pointFromJSON(y) { throw new Error("Not implemented."); }
                    toJSON(y) { let C, A, U, z, w; return this.type === "edwards" && (C = this.prefix ? this.prefix.toString() : null, A = this.context), this.n.isZero() || (U = this.n.toJSON()), this.z.isZero() || (z = this.z.fromRed(), this.z.redIsHigh() && z.isub(this.p), z = z.toString(16)), this.endo && (w = this.endo.toJSON()), { id: this.id, ossl: this.ossl, type: this.type, endian: this.endian, hash: this.hash, prefix: C, context: A, prime: this.prime, p: this.p.toJSON(), a: void 0, b: void 0, d: void 0, n: U, h: this.h.toString(16), s: void 0, z, c: void 0, g: this.g.toJSON(y), endo: w }; }
                    static fromJSON(y) { return new this(y); }
                } class h {
                    constructor(y, C) { D(y instanceof o), D(C >>> 0 === C), this.curve = y, this.type = C, this.pre = null; }
                    _init() { throw new Error("Not implemented."); }
                    _getNAF(y) { if (D(y >>> 0 === y), this.pre && this.pre.naf)
                        return this.pre.naf; if (y === 0)
                        return null; const C = 1 << y - 2, A = new Array(C), U = C === 1 ? null : this.dbl(); A[0] = this; for (let z = 1; z < C; z++)
                        A[z] = A[z - 1].add(U); return new k(y, A); }
                    _safeNAF(y) { return this._getNAF(y); }
                    _getWindows(y, C) { if (D(y >>> 0 === y), D(C >>> 0 === C), this.pre && this.pre.windows)
                        return this.pre.windows; if (y === 0)
                        return null; const A = 1 << y, U = (C + y - 1) / y >>> 0, z = new Array(U * A); let w = this.toP(); for (let O = 0; O < U; O++) {
                        z[O * A] = this.curve.point();
                        for (let q = 1; q < A; q++)
                            z[O * A + q] = z[O * A + q - 1].add(w);
                        w = w.dblp(y);
                    } return new x(y, C, z); }
                    _getDoubles(y, C) { if (D(y >>> 0 === y), D(C >>> 0 === C), this.pre && this.pre.doubles)
                        return this.pre.doubles; if (y === 0)
                        return null; const A = Math.ceil(C / y) + 1, U = new Array(A); let z = this, w = 0; U[w++] = z; for (let O = 0; O < C; O += y) {
                        for (let q = 0; q < y; q++)
                            z = z.dbl();
                        U[w++] = z;
                    } return D(w === A), new M(y, U); }
                    _getBeta() { return null; }
                    _getBlinding(y) { if (this.pre && this.pre.blinding)
                        return this.pre.blinding; if (!y)
                        return null; if (this.curve.n.isZero())
                        return null; const C = this.curve.randomScalar(y), A = this.mul(C); return new N(C, A); }
                    _hasWindows(y) { if (D(y instanceof e), !this.pre || !this.pre.windows)
                        return !1; const { bits: C } = this.pre.windows; return C >= y.bitLength(); }
                    _hasDoubles(y) { if (D(y instanceof e), !this.pre || !this.pre.doubles)
                        return !1; const { step: C, points: A } = this.pre.doubles, U = y.bitLength() + 1; return A.length >= Math.ceil(U / C) + 1; }
                    _getJNAF(y) { return D(y instanceof h), D(y.type === this.type), [this, this.add(y), this.sub(y), y]; }
                    _blind(y, C) { if (D(y instanceof e), D(!y.red), this.pre && this.pre.blinding) {
                        const { blind: A, unblind: U } = this.pre.blinding;
                        return [this, y.sub(A), U];
                    } return C ? this.pre ? this.curve.n.isZero() ? [this, y, null] : [this, this.curve.randomScalar(C).mul(this.curve.n).iadd(y), null] : [this.randomize(C), y, null] : [this, y, null]; }
                    clone() { throw new Error("Not implemented."); }
                    swap(y, C) { throw new Error("Not implemented."); }
                    precompute(y, C) { return D(y >>> 0 === y), this.pre || (this.pre = new _), this.pre.naf || (this.pre.naf = this._getNAF(9)), this.pre.doubles || (this.pre.doubles = this._getDoubles(4, y + 1)), this.pre.beta || (this.pre.beta = this._getBeta()), this.pre.blinding || (this.pre.blinding = this._getBlinding(C)), this; }
                    validate() { return this.curve.validate(this); }
                    normalize() { return this; }
                    scale(y) { throw new Error("Not implemented."); }
                    randomize(y) { const C = this.curve.randomField(y); return this.scale(C); }
                    neg() { throw new Error("Not implemented."); }
                    add(y) { throw new Error("Not implemented."); }
                    sub(y) { return D(y instanceof h), this.add(y.neg()); }
                    dbl() { throw new Error("Not implemented."); }
                    dblp(y) { D(y >>> 0 === y); let C = this; for (let A = 0; A < y; A++)
                        C = C.dbl(); return C; }
                    uadd(y) { throw new Error("Not implemented."); }
                    usub(y) { return D(y instanceof h), this.uadd(y.neg()); }
                    udbl() { throw new Error("Not implemented."); }
                    zaddu(y) { throw new Error("Not implemented."); }
                    zaddc(y) { throw new Error("Not implemented."); }
                    zdblu() { throw new Error("Not implemented."); }
                    diffAdd(y, C) { throw new Error("Not implemented."); }
                    diffAddDbl(y, C) { throw new Error("Not implemented."); }
                    recover() { throw new Error("Not implemented."); }
                    getX() { throw new Error("Not implemented."); }
                    getY() { throw new Error("Not implemented."); }
                    eq(y) { throw new Error("Not implemented."); }
                    cmp(y) { throw new Error("Not implemented."); }
                    isInfinity() { throw new Error("Not implemented."); }
                    isOrder2() { throw new Error("Not implemented."); }
                    isOdd() { throw new Error("Not implemented."); }
                    isEven() { throw new Error("Not implemented."); }
                    isSquare() { throw new Error("Not implemented."); }
                    eqX(y) { throw new Error("Not implemented."); }
                    eqR(y) { throw new Error("Not implemented."); }
                    isSmall() { return !this.isInfinity() && this.jmulH().isInfinity(); }
                    hasTorsion() { return !this.isInfinity() && !this.jmul(this.curve.n).isInfinity(); }
                    order() { const { h: y, n: C } = this.curve; let A = this.toJ(), U = new e(1); for (; !A.isInfinity();) {
                        if (U.iaddn(1), U.cmp(y) > 0) {
                            U = C.clone();
                            break;
                        }
                        A = A.add(this);
                    } return U; }
                    mul(y) { return this.jmul(y); }
                    muln(y) { return this.jmuln(y); }
                    mulSimple(y) { return this.jmulSimple(y); }
                    mulBlind(y, C) { return this.jmulBlind(y, C); }
                    mulConst(y, C) { return this.jmulConst(y, C); }
                    mulAdd(y, C, A) { return this.jmulAdd(y, C, A); }
                    mulAddSimple(y, C, A) { return this.jmulAddSimple(y, C, A); }
                    mulH() { return this.jmulH(); }
                    div(y) { return this.jdiv(y); }
                    divn(y) { return this.jdivn(y); }
                    divH() { return this.jdivH(); }
                    jmul(y) { return this._hasDoubles(y) ? this.curve._fixedNafMul(this, y) : this.curve.endo && this.type === c ? this.curve._endoWnafMulAdd([this], [y]) : this.curve._wnafMul(5, this, y); }
                    jmuln(y) { return D((0 | y) === y), this.jmulSimple(new e(y)); }
                    jmulSimple(y) { return this.curve._simpleMul(this, y); }
                    jmulBlind(y, C = null) { const [A, U, z] = this._blind(y, C), w = A.jmul(U); return z ? w.add(z) : w; }
                    jmulConst(y, C = null) { const [A, U, z] = this._blind(y, C), w = this.curve._constMul(A, U, C); return z ? w.uadd(z) : w; }
                    jmulAdd(y, C, A) { return this.curve.endo && this.type === c ? this.curve._endoWnafMulAdd([this, C], [y, A]) : this.curve._wnafMulAdd(5, [this, C], [y, A]); }
                    jmulAddSimple(y, C, A) { return this.curve._simpleMulAdd([this, C], [y, A]); }
                    jmulH() { const y = this.curve.h.word(0); if ((y & y - 1) == 0) {
                        const C = this.curve.h.bitLength();
                        return this.toJ().dblp(C - 1);
                    } return this.jmulSimple(this.curve.h); }
                    jdiv(y) { return D(y instanceof e), D(!y.red), this.jmul(y.invert(this.curve.n)); }
                    jdivn(y) { return D(!this.curve.n.isZero()), this.curve.h.cmpn(y) === 0 ? this.jdivH() : this.jdiv(new e(y)); }
                    jdivH() { return this.curve.n.isZero() || this.curve.h.cmpn(1) === 0 ? this.toJ() : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)), this.jmul(this.curve.hi)); }
                    ladder(y) { throw new Error("Not implemented."); }
                    ladderSimple(y) { throw new Error("Not implemented."); }
                    ladderBlind(y, C) { throw new Error("Not implemented."); }
                    ladderConst(y, C) { throw new Error("Not implemented."); }
                    toP() { return this.normalize(); }
                    toJ() { return this; }
                    toX() { return this; }
                    key() { if (this.isInfinity())
                        return this.curve.uid + ":oo"; this.normalize(); const y = this.getX().toString(16), C = this.getY().toString(16); return `${this.curve.uid}:${y},${C}`; }
                    encode(y) { throw new Error("Not implemented."); }
                    static decode(y, C) { throw new Error("Not implemented."); }
                    encodeX() { throw new Error("Not implemented."); }
                    static decodeX(y, C) { throw new Error("Not implemented."); }
                    static decodeEven(y, C) { throw new Error("Not implemented."); }
                    static decodeSquare(y, C) { throw new Error("Not implemented."); }
                    toJSON(y) { throw new Error("Not implemented."); }
                    static fromJSON(y, C) { throw new Error("Not implemented."); }
                    [r]() { return "<Point>"; }
                } class a extends o {
                    constructor(y) { super(l, "short", y), this.a = e.fromJSON(y.a).toRed(this.red), this.b = e.fromJSON(y.b).toRed(this.red), this.c = e.fromJSON(y.c || "0").toRed(this.red), this.ai = this.a.isZero() ? this.zero : this.a.redInvert(), this.zi = this.z.isZero() ? this.zero : this.z.redInvert(), this.zeroA = this.a.isZero(), this.threeA = this.a.eq(this.three.redNeg()), this.redN = this.n.toRed(this.red), this.pmodn = this.p.clone(), this.highOrder = this.n.cmp(this.p) >= 0, this.smallGap = !1, this._finalize(y); }
                    _finalize(y) { return super._finalize(y), y.endo != null ? this.endo = S.fromJSON(this, y.endo) : this.endo = this._getEndomorphism(), this.n.isZero() || (this.pmodn = this.p.mod(this.n), this.smallGap = this.p.div(this.n).cmpn(1) <= 0), this; }
                    static _isomorphism(y, C, A, U) { if (D(y instanceof e), D(C instanceof e), D(A instanceof e), D(U == null || typeof U == "boolean"), D(!y.isZero() || !C.isZero()), A.isZero())
                        throw new Error("Invalid coefficient."); if (y.isZero()) {
                        const J = A;
                        return D(Q(J.redDiv(C)).redJacobi() === 1), [y.clone(), J.clone()];
                    } if (C.isZero()) {
                        const J = A, Z = J.redDiv(y).redSqrt();
                        if (Z.redJacobi() !== 1 && Z.redINeg(), Z.redJacobi() !== 1)
                            throw new Error("Invalid `a` coefficient.");
                        return [J.clone(), C.clone()];
                    } const z = A, w = z.redDiv(y), O = w.redSqrt(); if (U != null ? O.redIsOdd() !== U && O.redINeg() : O.redJacobi() !== 1 && O.redINeg(), O.redJacobi() !== 1)
                        throw new Error("Invalid `a` coefficient."); const q = w.redMul(O), H = y.redMul(w), V = C.redMul(q); return D(H.eq(z)), [H, V]; }
                    _short(y, C) { return a._isomorphism(this.a, this.b, y, C); }
                    _mont(y, C) { const [A, U] = this._findRS(C), z = U.redInvert(), w = A.redMuln(3).redMul(z); return y != null ? g._isomorphism(w, z, y) : [w, z]; }
                    _edwards(y, C) { const [A, U] = this._findRS(C), z = A.redMuln(3), w = U.redMuln(2), O = z.redAdd(w), q = z.redSub(w); return y != null ? v._isomorphism(O, q, y) : [O, q]; }
                    _findRS(y) { D(y == null || typeof y == "boolean"), D(this.h.word(0) >= 4), D(!this.n.isZero()); const C = this.one.redNeg(); let A; for (;;) {
                        C.redIAdd(this.one);
                        try {
                            A = this.pointFromX(C.clone());
                        }
                        catch (w) {
                            continue;
                        }
                        if (A = A.mul(this.n), !A.isInfinity() && A.y.isZero())
                            break;
                    } const U = A.x, z = U.redSqr().redMuln(3).redIAdd(this.a).redSqrt(); return y != null && z.redIsOdd() !== y && z.redINeg(), [U, z]; }
                    _scale0(y, C) { if (D(this.a.isZero() === y.isZero()), D(this.b.isZero() === C.isZero()), this.a.isZero()) {
                        const q = this.b.redDiv(this.field(C)), H = Q(q), V = H.redSqrt(), J = H.redMul(V);
                        return D(J.redSqr().eq(q)), D(!V.isZero()), [H, J];
                    } if (this.b.isZero()) {
                        const q = this.a.redDiv(this.field(y)), H = q.redSqrt();
                        H.redJacobi() !== 1 && H.redINeg();
                        const V = H.redSqrt(), J = H.redMul(V);
                        return D(J.redMul(V).eq(q)), D(!V.isZero()), [H, J];
                    } const A = this.a.redDiv(this.field(y)), U = this.b.redDiv(this.field(C)), z = A.redSqrt(); A.redMul(z).eq(U) || z.redINeg(), D(A.redMul(z).eq(U)); const w = z.redSqrt(), O = z.redMul(w); return D(!w.isZero()), [z, O]; }
                    _scale1(y, C) { const A = this.g.x.redDiv(this.field(y)), U = this.g.y.redDiv(this.field(C)), z = A.redSqrt(); return A.redMul(z).eq(U) || z.redINeg(), D(A.redMul(z).eq(U)), D(!z.isZero()), [A, U]; }
                    _scaleShort(y) { return D(y instanceof a), this.g.isInfinity() || y.g.isInfinity() ? this._scale0(y.a, y.b) : this._scale1(y.g.x, y.g.y); }
                    _scaleMont(y) { if (D(y instanceof g), this.g.isInfinity() || y.g.isInfinity()) {
                        const [w, O] = y._short();
                        return this._scale0(w, O);
                    } const { x: C, y: A } = y.g, U = C.redAdd(y.a3).redMul(y.bi), z = A.redMul(y.bi); return this._scale1(U, z); }
                    _scaleEdwards(y) { if (D(y instanceof v), this.g.isInfinity() || y.g.isInfinity()) {
                        const [ct, lt] = y._short();
                        return this._scale0(ct, lt);
                    } const { x: C, y: A, z: U } = y.g, z = y.a.redMuln(5), w = y.d.redMuln(5), O = y.d.redSub(y.a), q = w.redSub(y.a), H = y.d.redSub(z), V = A.redAdd(U), J = A.redSub(U), Z = q.redMul(A).redIAdd(H.redMul(U)), tt = J.redMuln(12), nt = O.redMul(V).redMul(U), rt = J.redMul(C).redIMuln(4), it = tt.redMul(rt).redInvert(), st = Z.redMul(rt).redMul(it), at = nt.redMul(tt).redMul(it); return this._scale1(st, at); }
                    _getEndomorphism(y = 0) { if (this.n.isZero() || this.g.isInfinity())
                        return null; if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
                        return null; const [C, A] = this._getEndoRoots(this.p), U = [C, A][1 & y].toRed(this.red), [z, w] = this._getEndoRoots(this.n), O = this.point(this.g.x.redMul(U), this.g.y); let q; this.g.mul(z).eq(O) ? q = z : (D(this.g.mul(w).eq(O)), q = w); const H = this._getEndoBasis(q), V = this._getEndoPrecomp(H); return new S(U, q, H, V); }
                    _getEndoRoots(y) { const C = y === this.p ? this.red : e.mont(y), A = new e(2).toRed(C), U = new e(3).toRed(C), z = A.redInvert(), w = U.redNeg().redSqrt().redMul(z), O = w.redNeg(); return [w.redSub(z).fromRed(), O.redSub(z).fromRed()].sort(e.cmp); }
                    _getEndoBasis(y) { const [C, A, U, z, w, O] = this._egcdSqrt(y), q = U, H = z.neg(), V = C.sqr().iadd(A.sqr()), J = w.sqr().iadd(O.sqr()); let Z, tt; return V.cmp(J) <= 0 ? (Z = C, tt = A.neg()) : (Z = w, tt = O.neg()), [new T(q, H), new T(Z, tt)]; }
                    _egcdSqrt(y) { D(y instanceof e), D(!y.red), D(y.sign() > 0), D(this.n.sign() > 0); const C = this.n.ushrn(this.n.bitLength() >>> 1); let A, U, z, w, O, q = y, H = this.n.clone(), V = new e(1), J = new e(0), Z = new e(0), tt = new e(1), nt = 0, rt = 0; for (; !q.isZero() && nt < 2;) {
                        const it = H.quo(q), st = H.sub(it.mul(q)), at = Z.sub(it.mul(V)), ct = tt.sub(it.mul(J));
                        rt === 0 && st.cmp(C) < 0 && (A = O, U = V, z = st, w = at, rt = 1), O = st, H = q, q = st, Z = V, V = at, tt = J, J = ct, nt += rt;
                    } return D(rt !== 0, "Could not find r < sqrt(n)."), [A, U, z, w, Z, V]; }
                    _getEndoPrecomp(y) { D(Array.isArray(y)), D(y.length === 2), D(y[0] instanceof T), D(y[1] instanceof T); const [C, A] = y, U = C.a.mul(A.b).isub(C.b.mul(A.a)), z = U.bitLength() + 16, w = e.shift(1, z), O = w.mul(A.b).divRound(U), q = w.mul(C.b).divRound(U); return D(U.eq(this.n)), [O, q]; }
                    _endoSplit(y) { D(y instanceof e), D(!y.red), D(!this.n.isZero()); const [C, A] = this.endo.basis, U = A.b.mul(y).divRound(this.n), z = C.b.neg().mul(y).divRound(this.n), w = U.mul(C.a), O = z.mul(A.a), q = U.ineg().mul(C.b), H = z.mul(A.b); return [y.sub(w).isub(O), q.isub(H)]; }
                    _endoBeta(y) { return D(y instanceof l), [y, y._getBeta()]; }
                    _endoWnafMulAdd(y, C) { D(Array.isArray(y)), D(Array.isArray(C)), D(y.length === C.length), D(this.endo != null); const A = y.length, U = new Array(2 * A), z = new Array(2 * A); for (let w = 0; w < A; w++) {
                        const [O, q] = this._endoBeta(y[w]), [H, V] = this._endoSplit(C[w]);
                        U[2 * w + 0] = O, z[2 * w + 0] = H, U[2 * w + 1] = q, z[2 * w + 1] = V;
                    } return this._wnafMulAdd(5, U, z); }
                    _icart(y) { const { a: C, b: A, i3: U, one: z } = this, w = U.redSqr().redMul(U), O = this.p.ushln(1).isubn(1).idivn(3), q = y.clone(); q.cinject(z, q.czero()); const H = q.redSqr(), V = H.redSqr(), J = V.redMul(H), Z = q.redMuln(6).redFermat(), tt = C.redMuln(3).redISub(V).redMul(Z), nt = tt.redSqr(), rt = J.redMul(w), it = H.redMul(U), st = nt.redISub(A).redISub(rt).redPow(O).redIAdd(it), at = q.redMul(st).redIAdd(tt); return this.point(st, at); }
                    _sswu(y) { const { b: C, z: A, ai: U, zi: z, one: w } = this, O = this.p.subn(2), q = A.redSqr(), H = C.redNeg().redMul(U), V = C.redMul(z).redMul(U), J = y.redSqr(), Z = J.redSqr(), tt = q.redMul(Z).redIAdd(A.redMul(J)).redPow(O), nt = H.redMul(w.redAdd(tt)); nt.cinject(V, tt.czero()); const rt = A.redMul(J).redMul(nt), it = this.solveY2(nt), st = this.solveY2(rt), at = 0 | it.redIsSquare(), ct = nt.cinject(rt, 1 ^ at), lt = it.cinject(st, 1 ^ at).redSqrt(); return lt.cinject(lt.redNeg(), lt.redIsOdd() ^ y.redIsOdd()), this.point(ct, lt); }
                    _sswui(y, C) { const { a: A, b: U, z } = this, { x: w, y: O } = y, q = 3 & C, H = A.redSqr().redMul(w.redSqr()), V = A.redMul(U).redMul(w).redIMuln(2), J = U.redSqr().redMuln(3), Z = A.redMul(w).redIAdd(U), [tt, nt] = G(H.redISub(V).redISub(J)), rt = Z.redSub(nt).redINeg(), it = Z.redAdd(nt).redINeg(), st = Z.redMul(z).redIMuln(2), at = U.redMul(z).redIMuln(2); rt.cinject(it, 1 & q), st.cinject(at, q >>> 1); const [ct, lt] = W(rt, st); if (lt.cinject(lt.redNeg(), lt.redIsOdd() ^ O.redIsOdd()), !(tt & ct))
                        throw new Error("Invalid point."); return lt; }
                    _svdwf(y) { const { c: C, z: A, zi: U, i2: z, i3: w } = this, O = this.p.subn(2), q = this.solveY2(A), H = w.redMul(U.redSqr()), V = y.redSqr(), J = V.redSqr(), Z = V.redAdd(q), tt = V.redMul(Z).redPow(O), nt = J.redMul(tt).redMul(C), rt = Z.redSqr().redMul(Z), it = C.redSub(A).redMul(z).redISub(nt), st = nt.redSub(C.redAdd(A).redMul(z)), at = A.redSub(rt.redMul(tt).redMul(H)), ct = this.solveY2(it), lt = this.solveY2(st), pt = this.solveY2(at), mt = 0 | ct.redIsSquare(), Tt = 0 | lt.redIsSquare(); return it.cinject(st, (1 ^ mt) & Tt), ct.cinject(lt, (1 ^ mt) & Tt), it.cinject(at, (1 ^ mt) & (1 ^ Tt)), ct.cinject(pt, (1 ^ mt) & (1 ^ Tt)), [it, ct]; }
                    _svdw(y) { const [C, A] = this._svdwf(y), U = A.redSqrt(); return U.cinject(U.redNeg(), U.redIsOdd() ^ y.redIsOdd()), this.point(C, U); }
                    _svdwi(y, C) { const { b: A, c: U, z, two: w } = this, { x: O, y: q } = y, H = 3 & C, V = z.redSqr(), J = V.redMul(z), Z = V.redSqr(), tt = J.redAdd(A), nt = tt.redMuln(2), rt = O.redSqr(), it = O.redMuln(2).redIAdd(z), st = O.redMul(V), at = U.redSub(it), ct = U.redAdd(it), lt = rt.redMul(V).redIAdd(Z).redIMuln(9), pt = O.redMul(J).redIMuln(18), mt = tt.redMul(O.redSub(z)).redIMuln(12), [Tt, vt] = G(lt.redISub(pt).redIAdd(mt)), Rt = H - 2 >>> 31 | Tt, Bt = vt.redMul(z), wt = J.redISub(st).redIMuln(3).redISub(nt), kt = tt.redMul(at), Wt = tt.redMul(ct), Ct = wt.redAdd(Bt), Ft = wt.redSub(Bt), te = w.clone(); kt.cinject(Wt, (1 ^ H) - 1 >>> 31), kt.cinject(Ct, (2 ^ H) - 1 >>> 31), kt.cinject(Ft, (3 ^ H) - 1 >>> 31), te.cinject(ct, (0 ^ H) - 1 >>> 31), te.cinject(at, (1 ^ H) - 1 >>> 31); const [jt, Kt] = W(kt, te), [re] = this._svdwf(Kt), St = re.ceq(O); if (Kt.cinject(Kt.redNeg(), Kt.redIsOdd() ^ q.redIsOdd()), !(Rt & jt & St))
                        throw new Error("Invalid point."); return Kt; }
                    isElliptic() { const { a: y, b: C } = this, A = y.redSqr().redMul(y); return !C.redSqr().redMuln(27).redIAdd(A.redMuln(4)).isZero(); }
                    jinv() { const { a: y, b: C } = this, A = y.redSqr().redMul(y), U = C.redSqr(), z = A.redMuln(4), w = z.redMuln(1728), O = U.redMuln(27).redIAdd(z); if (O.isZero())
                        throw new Error("Curve is not elliptic."); return w.redDiv(O).fromRed(); }
                    point(y, C, A = 0) { return new l(this, y, C, A); }
                    jpoint(y, C, A) { return new p(this, y, C, A); }
                    solveX(y) { if (D(y instanceof e), !this.a.isZero())
                        throw new Error("Not implemented."); return X(y.redSqr().redSub(this.b)); }
                    solveY2(y) { D(y instanceof e); const C = y.redSqr().redMul(y).redIAdd(this.b); return this.zeroA || (this.threeA ? C.redIAdd(y.redMuln(-3)) : C.redIAdd(this.a.redMul(y))), C; }
                    validate(y) { if (D(y instanceof l), y.inf)
                        return !0; const { x: C, y: A } = y, U = this.solveY2(C); return A.redSqr().eq(U); }
                    pointFromX(y, C = null) { D(y instanceof e), D(C == null || typeof C == "boolean"), y.red || (y = y.toRed(this.red)); const A = this.solveY(y); if (C != null) {
                        if (this.h.cmpn(1) > 0 && A.isZero() && C)
                            throw new Error("Invalid point.");
                        A.redIsOdd() !== C && A.redINeg();
                    } return this.point(y, A); }
                    pointFromY(y, C = 0) { D(y instanceof e), D(C >>> 0 === C), y.red || (y = y.toRed(this.red)); const A = this.solveX(y); if (C >= A.length)
                        throw new Error("Invalid X coordinate index."); const U = A[C]; return this.point(U, y); }
                    isIsomorphic(y) { if (D(y instanceof o), !y.p.eq(this.p))
                        return !1; let C, A; try {
                        [C, A] = this._scale(y);
                    }
                    catch (U) {
                        return !1;
                    } if (y.type === "short") {
                        const U = this.field(y.a).redMul(C.redSqr()), z = this.field(y.b).redMul(A.redSqr());
                        return this.a.eq(U) && this.b.eq(z);
                    } if (y.type === "mont") {
                        const { a3: U, bi: z } = y, w = this.field(U.redMul(z)).redMul(C);
                        return this.solveY2(w).isZero();
                    } if (y.type === "edwards") {
                        const U = this.field(y.ad6).redMul(C);
                        return this.solveY2(U).isZero();
                    } return !1; }
                    isIsogenous(y) { return D(y instanceof o), !1; }
                    pointFromShort(y) { if (D(y instanceof l), this.isIsomorphic(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        const [C, A] = this._scale(y.curve), U = this.field(y.x), z = this.field(y.y), w = U.redMul(C), O = z.redMul(A);
                        return this.point(w, O);
                    } throw new Error("Not implemented."); }
                    pointFromMont(y) { if (D(y instanceof b), this.isIsomorphic(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        const { a3: C, bi: A } = y.curve, [U, z] = this._scale(y.curve), w = y.x.redAdd(C).redMul(A), O = y.y.redMul(A);
                        return this.point(this.field(w).redMul(U), this.field(O).redMul(z));
                    } throw new Error("Not implemented."); }
                    pointFromEdwards(y) { if (D(y instanceof R), this.isIsomorphic(y.curve)) {
                        const { a: C, d: A, ad6: U } = y.curve, [z, w] = this._scale(y.curve);
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero()) {
                            const pt = this.field(U).redMul(z);
                            return this.point(pt, this.zero);
                        }
                        const { x: O, y: q, z: H } = y, V = C.redMuln(5), J = A.redMuln(5), Z = A.redSub(C), tt = J.redSub(C), nt = A.redSub(V), rt = q.redAdd(H), it = q.redSub(H), st = tt.redMul(q).redIAdd(nt.redMul(H)), at = it.redMuln(12), ct = Z.redMul(rt).redMul(H), lt = it.redMul(O).redIMuln(4);
                        return this.cpoint(this.field(st).redMul(z), this.field(at), this.field(ct).redMul(w), this.field(lt));
                    } throw new Error("Not implemented."); }
                    pointFromUniform(y) { if (D(y instanceof e), this.z.isZero() || this.b.isZero())
                        throw new Error("Not implemented."); if (!this.a.isZero())
                        return this._sswu(y); if (!this.c.isZero())
                        return this._svdw(y); throw new Error("Not implemented."); }
                    pointToUniform(y, C) { if (D(y instanceof l), D(C >>> 0 === C), this.z.isZero() || this.b.isZero())
                        throw new Error("Not implemented."); if (y.isInfinity())
                        throw new Error("Invalid point."); const A = (C >>> 4 & 15) % this.torsion.length, U = y.add(this.torsion[A]); if (!this.a.isZero())
                        return this._sswui(U, C); if (!this.c.isZero())
                        return this._svdwi(U, C); throw new Error("Not implemented."); }
                    mulAll(y, C) { return super.mulAll(y, C).toP(); }
                    mulAllSimple(y, C) { return super.mulAllSimple(y, C).toP(); }
                    decodePoint(y) { return l.decode(this, y); }
                    encodeX(y) { return D(y instanceof h), y.encodeX(); }
                    decodeEven(y) { return l.decodeEven(this, y); }
                    decodeSquare(y) { return l.decodeSquare(this, y); }
                    toShort(y, C, A = null) { const [U, z] = this._short(y, C), w = new a({ red: this.red, prime: this.prime, p: this.p, a: U, b: z, n: this.n, h: this.h }); if (A != null) {
                        const [, O] = w._scale(this);
                        O.redIsOdd() !== A && O.redINeg();
                    } this.g.isInfinity() || (w.g = w.pointFromShort(this.g)); for (let O = 0; O < this.h.word(0); O++)
                        w.torsion[O] = w.pointFromShort(this.torsion[O]); return w; }
                    toMont(y, C, A = null) { const [U, z] = this._mont(y, C), w = new g({ red: this.red, prime: this.prime, p: this.p, a: U, b: z, n: this.n, h: this.h }); if (A != null) {
                        const [, O] = this._scale(w);
                        O.redIsOdd() !== A && O.redINeg();
                    } this.g.isInfinity() || (w.g = w.pointFromShort(this.g)); for (let O = 0; O < this.h.word(0); O++)
                        w.torsion[O] = w.pointFromShort(this.torsion[O]); return w; }
                    toEdwards(y, C, A = null) { const [U, z] = this._edwards(y, C), w = new v({ red: this.red, prime: this.prime, p: this.p, a: U, d: z, n: this.n, h: this.h }); if (A != null) {
                        const [, O] = this._scale(w);
                        O.redIsOdd() !== A && O.redINeg();
                    } if (this.g.isInfinity() || (w.g = w.pointFromShort(this.g), w.g.normalize()), w.isComplete())
                        for (let O = 0; O < this.h.word(0); O++)
                            w.torsion[O] = w.pointFromShort(this.torsion[O]), w.torsion[O].normalize(); return w; }
                    pointFromJSON(y) { return l.fromJSON(this, y); }
                    toJSON(y) { const C = super.toJSON(y); return C.a = this.a.fromRed().toJSON(), C.b = this.b.fromRed().toJSON(), this.c.isZero() || (C.c = this.c.fromRed().toJSON()), C; }
                } class l extends h {
                    constructor(y, C, A, U) { D(y instanceof a), super(y, c), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = 1, C != null && this._init(C, A, U); }
                    _init(y, C, A) { D(y instanceof e), D(C instanceof e), this.x = y, this.y = C, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = 0 | A; }
                    _safeNAF(y) { return D(y >>> 0 === y), this.pre && this.pre.naf ? this.pre.naf : y > 1 ? this.toJ()._getNAF(y) : this._getNAF(y); }
                    _getBeta() { if (!this.curve.endo)
                        return null; if (this.pre && this.pre.beta)
                        return this.pre.beta; const y = this.x.redMul(this.curve.endo.beta), C = this.curve.point(y, this.y); return this.pre && (C.pre = this.pre.map(A => { const U = A.x.redMul(this.curve.endo.beta); return this.curve.point(U, A.y); }), this.pre.beta = C), C; }
                    _getJNAF(y) { if (D(y instanceof l), this.inf | y.inf)
                        return super._getJNAF(y); const C = [this, null, null, y]; return this.y.eq(y.y) ? (C[1] = this.add(y), C[2] = this.toJ().sub(y)) : this.y.eq(y.y.redNeg()) ? (C[1] = this.toJ().add(y), C[2] = this.sub(y)) : (C[1] = this.toJ().add(y), C[2] = this.toJ().sub(y)), C; }
                    clone() { return this.curve.point(this.x.clone(), this.y.clone(), this.inf); }
                    swap(y, C) { D(y instanceof l); const A = 1 & (C >> 31 | -C >> 31), U = this.inf, z = y.inf; return this.x.cswap(y.x, C), this.y.cswap(y.y, C), this.inf = U & (1 ^ A) | z & A, y.inf = z & (1 ^ A) | U & A, this; }
                    scale(y) { return this.toJ().scale(y); }
                    neg() { return this.inf ? this : this.curve.point(this.x, this.y.redNeg()); }
                    add(y) { if (D(y instanceof l), this.inf)
                        return y; if (y.inf)
                        return this; if (this.x.eq(y.x))
                        return this.y.eq(y.y) ? this.dbl() : this.curve.point(); if (this.y.eq(y.y)) {
                        const w = this.x.redNeg().redISub(y.x), O = this.y.redNeg();
                        return this.curve.point(w, O);
                    } const C = this.x.redSub(y.x), A = this.y.redSub(y.y).redDiv(C), U = A.redSqr().redISub(this.x).redISub(y.x), z = A.redMul(this.x.redSub(U)).redISub(this.y); return this.curve.point(U, z); }
                    dbl() { if (this.inf)
                        return this; if (this.y.isZero())
                        return this.curve.point(); const y = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a), C = this.y.redMuln(2), A = y.redDiv(C), U = A.redSqr().redISub(this.x).redISub(this.x), z = A.redMul(this.x.redSub(U)).redISub(this.y); return this.curve.point(U, z); }
                    dblp(y) { return this.toJ().dblp(y).toP(); }
                    uadd(y) { D(y instanceof l); const C = this.y.redAdd(y.y), A = this.x.redAdd(y.x).redSqr(), U = this.x.redMul(y.x), z = A.redISub(U).redIAdd(this.curve.a), w = C.czero() & z.czero(); C.cinject(this.x.redSub(y.x), w), z.cinject(this.y.redSub(y.y), w); const O = C.czero() & (1 ^ (this.inf | y.inf)); C.cinject(this.curve.one, C.czero()); const q = z.redMul(C.redFermat()), H = q.redSqr().redISub(this.x).redISub(y.x), V = q.redMul(this.x.redSub(H)).redISub(this.y), J = O | this.inf & y.inf; return H.cinject(y.x, this.inf), V.cinject(y.y, this.inf), H.cinject(this.x, y.inf), V.cinject(this.y, y.inf), H.cinject(this.curve.zero, J), V.cinject(this.curve.zero, J), this.curve.point(H, V, J); }
                    udbl() { return this.uadd(this); }
                    recover(y, C, A, U) { if (D(y instanceof e), D(C instanceof e), D(A instanceof e), D(U instanceof e), this.inf)
                        return this.curve.jpoint(); const z = C.redMul(U), w = z.redSqr(), O = w.redMul(z), q = this.x.redMul(z), H = y.redMul(U), V = A.redMul(C), J = this.curve.b.redMul(O).redIMuln(2), Z = q.redMul(H).redIAdd(this.curve.a.redMul(w)), tt = q.redAdd(H), nt = q.redISub(H), rt = J.redIAdd(Z.redMul(tt)), it = V.redMul(nt.redSqr()), st = rt.redISub(it), at = this.y.redMul(O).redIMuln(2), ct = y.redMul(at), lt = st.redMul(C), pt = C.redMul(at), mt = ct.redMul(pt), Tt = lt.redMul(pt.redSqr()), vt = pt; return this.curve.jpoint(mt, Tt, vt); }
                    getX() { if (this.inf)
                        throw new Error("Invalid point."); return this.x.fromRed(); }
                    getY() { if (this.inf)
                        throw new Error("Invalid point."); return this.y.fromRed(); }
                    eq(y) { return D(y instanceof l), this === y || (this.inf ? y.inf !== 0 : !y.inf && this.x.eq(y.x) && this.y.eq(y.y)); }
                    cmp(y) { return D(y instanceof l), this.inf && !y.inf ? -1 : !this.inf && y.inf ? 1 : this.inf && y.inf ? 0 : this.order().cmp(y.order()) || this.getX().cmp(y.getX()) || this.getY().cmp(y.getY()); }
                    isInfinity() { return this.inf !== 0; }
                    isOrder2() { return !this.inf && this.y.isZero(); }
                    isOdd() { return !this.inf && this.y.redIsOdd(); }
                    isEven() { return !this.inf && this.y.redIsEven(); }
                    isSquare() { return !this.inf && this.y.redJacobi() !== -1; }
                    eqX(y) { return D(y instanceof e), D(!y.red), !this.inf && this.getX().eq(y); }
                    eqR(y) { return D(y instanceof e), D(!y.red), D(!this.curve.n.isZero()), !this.inf && this.getX().imod(this.curve.n).eq(y); }
                    mul(y) { return super.mul(y).toP(); }
                    muln(y) { return super.muln(y).toP(); }
                    mulSimple(y) { return super.mulSimple(y).toP(); }
                    mulBlind(y, C) { return super.mulBlind(y, C).toP(); }
                    mulConst(y, C) { return super.mulConst(y, C).toP(); }
                    mulAdd(y, C, A) { return super.mulAdd(y, C, A).toP(); }
                    mulAddSimple(y, C, A) { return super.mulAddSimple(y, C, A).toP(); }
                    mulH() { return super.mulH().toP(); }
                    div(y) { return super.div(y).toP(); }
                    divn(y) { return super.divn(y).toP(); }
                    divH() { return super.divH().toP(); }
                    toP() { return this; }
                    toJ() { return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one); }
                    encode(y) { y == null && (y = !0), D(typeof y == "boolean"); const { fieldSize: C } = this.curve; if (this.inf)
                        throw new Error("Invalid point."); if (y) {
                        const w = d.alloc(1 + C), O = this.curve.encodeField(this.getX());
                        return w[0] = 2 | this.y.redIsOdd(), O.copy(w, 1), w;
                    } const A = d.alloc(1 + 2 * C), U = this.curve.encodeField(this.getX()), z = this.curve.encodeField(this.getY()); return A[0] = 4, U.copy(A, 1), z.copy(A, 1 + C), A; }
                    static decode(y, C) { D(y instanceof a), D(d.isBuffer(C)); const A = y.fieldSize; if (C.length < 1 + A)
                        throw new Error("Not a point."); const U = C[0]; switch (U) {
                        case 2:
                        case 3: {
                            if (C.length !== 1 + A)
                                throw new Error("Invalid point size for compressed.");
                            const z = y.decodeField(C.slice(1, 1 + A));
                            if (z.cmp(y.p) >= 0)
                                throw new Error("Invalid point.");
                            const w = y.pointFromX(z, U === 3);
                            return D(!w.isInfinity()), w;
                        }
                        case 4:
                        case 6:
                        case 7: {
                            if (C.length !== 1 + 2 * A)
                                throw new Error("Invalid point size for uncompressed.");
                            const z = y.decodeField(C.slice(1, 1 + A)), w = y.decodeField(C.slice(1 + A, 1 + 2 * A));
                            if (z.cmp(y.p) >= 0 || w.cmp(y.p) >= 0)
                                throw new Error("Invalid point.");
                            if (U !== 4 && U !== (6 | w.isOdd()))
                                throw new Error("Invalid hybrid encoding.");
                            const O = y.point(z, w);
                            if (!O.validate())
                                throw new Error("Invalid point.");
                            return D(!O.isInfinity()), O;
                        }
                        default: throw new Error("Unknown point format.");
                    } }
                    encodeX() { return this.curve.encodeField(this.getX()); }
                    static decodeEven(y, C) { D(y instanceof a); const A = y.decodeField(C); if (A.cmp(y.p) >= 0)
                        throw new Error("Invalid point."); return y.pointFromX(A, !1); }
                    static decodeSquare(y, C) { D(y instanceof a); const A = y.decodeField(C); if (A.cmp(y.p) >= 0)
                        throw new Error("Invalid point."); return y.pointFromX(A); }
                    toJSON(y) { if (this.inf)
                        return []; const C = this.getX().toJSON(), A = this.getY().toJSON(); return y === !0 && this.pre ? [C, A, this.pre.toJSON()] : [C, A]; }
                    toPretty() { if (this.inf)
                        return []; const y = 2 * this.curve.fieldSize; return [Y(this.getX(), y), Y(this.getY(), y)]; }
                    static fromJSON(y, C) { if (D(y instanceof a), D(Array.isArray(C)), D(C.length === 0 || C.length === 2 || C.length === 3), C.length === 0)
                        return y.point(); const A = e.fromJSON(C[0]), U = e.fromJSON(C[1]), z = y.point(A, U); return C.length > 2 && C[2] != null && (z.pre = _.fromJSON(z, C[2])), z; }
                    [r]() { return this.inf ? "<ShortPoint: Infinity>" : "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">"; }
                } class p extends h {
                    constructor(y, C, A, U) { D(y instanceof a), super(y, n), this.x = this.curve.one, this.y = this.curve.one, this.z = this.curve.zero, this.zOne = 0, C != null && this._init(C, A, U); }
                    _init(y, C, A) { D(y instanceof e), D(C instanceof e), D(A == null || A instanceof e), this.x = y, this.y = C, this.z = A || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = 0 | this.z.eq(this.curve.one); }
                    clone() { return this.curve.jpoint(this.x.clone(), this.y.clone(), this.z.clone()); }
                    swap(y, C) { D(y instanceof p); const A = 1 & (C >> 31 | -C >> 31), U = this.zOne, z = y.zOne; return this.x.cswap(y.x, C), this.y.cswap(y.y, C), this.z.cswap(y.z, C), this.zOne = U & (1 ^ A) | z & A, y.zOne = z & (1 ^ A) | U & A, this; }
                    validate() { const { a: y, b: C } = this.curve; if (this.isInfinity())
                        return !0; if (this.zOne)
                        return this.curve.validate(this.toP()); const A = this.y.redSqr(), U = this.x.redSqr().redMul(this.x), z = this.z.redSqr(), w = z.redSqr(), O = w.redMul(z), q = U.redIAdd(C.redMul(O)); return this.curve.zeroA || (this.curve.threeA ? q.redIAdd(w.redIMuln(-3).redMul(this.x)) : q.redIAdd(y.redMul(w).redMul(this.x))), A.eq(q); }
                    normalize() { if (this.zOne)
                        return this; if (this.isInfinity())
                        return this; const y = this.z.redInvert(), C = y.redSqr(); return this.x = this.x.redMul(C), this.y = this.y.redMul(C).redMul(y), this.z = this.curve.one, this.zOne = 1, this; }
                    scale(y) { if (D(y instanceof e), this.isInfinity())
                        return this.curve.jpoint(); const C = y.redSqr(), A = this.x.redMul(C), U = this.y.redMul(C).redMul(y), z = this.z.redMul(y); return this.curve.jpoint(A, U, z); }
                    neg() { return this.curve.jpoint(this.x, this.y.redNeg(), this.z); }
                    add(y) { return D(y instanceof h), y.type === c ? this._mixedAdd(y) : this._add(y); }
                    _add(y) { return D(y instanceof p), this.isInfinity() ? y : y.isInfinity() ? this : this.zOne && y.zOne ? this._addAA(y) : this.zOne ? y._addJA(this) : y.zOne ? this._addJA(y) : this._addJJ(y); }
                    _mixedAdd(y) { return D(y instanceof l), this.isInfinity() ? y.toJ() : y.isInfinity() ? this : this.zOne ? this._addAA(y) : this._addJA(y); }
                    _addJJ(y) { const C = this.z.redSqr(), A = y.z.redSqr(), U = this.x.redMul(A), z = y.x.redMul(C), w = this.y.redMul(y.z).redMul(A), O = y.y.redMul(this.z).redMul(C), q = z.redISub(U), H = O.redISub(w); if (q.isZero())
                        return H.isZero() ? this.dbl() : this.curve.jpoint(); const V = q.redSqr(), J = q.redMul(V), Z = U.redMul(V), tt = H.redSqr().redISub(J).redISub(Z).redISub(Z), nt = H.redMul(Z.redISub(tt)).redISub(w.redMul(J)), rt = this.z.redMul(y.z).redMul(q); return this.curve.jpoint(tt, nt, rt); }
                    _addJA(y) { const C = this.z.redSqr(), A = y.x.redMul(C), U = y.y.redMul(this.z).redMul(C), z = A.redISub(this.x), w = U.redISub(this.y).redIMuln(2); if (z.isZero())
                        return w.isZero() ? this.dbl() : this.curve.jpoint(); const O = z.redMuln(2).redSqr(), q = z.redMul(O), H = this.x.redMul(O), V = w.redSqr().redISub(q).redISub(H).redISub(H), J = w.redMul(H.redISub(V)).redISub(this.y.redMul(q).redIMuln(2)), Z = this.z.redMul(z).redIMuln(2); return this.curve.jpoint(V, J, Z); }
                    _addAA(y) { const C = y.x.redSub(this.x), A = y.y.redSub(this.y).redIMuln(2); if (C.isZero())
                        return A.isZero() ? this.dbl() : this.curve.jpoint(); const U = C.redSqr().redIMuln(4), z = C.redMul(U), w = this.x.redMul(U), O = A.redSqr().redISub(z).redISub(w).redISub(w), q = A.redMul(w.redISub(O)).redISub(this.y.redMul(z).redIMuln(2)), H = C.redIMuln(2); return this.curve.jpoint(O, q, H); }
                    dbl() { return this.isInfinity() ? this : this.y.isZero() ? this.curve.jpoint() : this.zOne ? this._dblA() : this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ(); }
                    _dblJ() { const y = this.x.redSqr(), C = this.y.redSqr(), A = this.z.redSqr(), U = this.x.redMul(C).redIMuln(4), z = y.redIMuln(3).redIAdd(this.curve.a.redMul(A.redSqr())), w = z.redSqr().redISub(U).redISub(U), O = w, q = z.redMul(U.redISub(w)).redISub(C.redSqr().redIMuln(8)), H = this.y.redMul(this.z).redIMuln(2); return this.curve.jpoint(O, q, H); }
                    _dblA() { const y = this.x.redSqr(), C = this.y.redSqr(), A = C.redSqr(), U = C.redIAdd(this.x).redSqr().redISub(y).redISub(A).redIMuln(2), z = y.redIMuln(3).redIAdd(this.curve.a), w = z.redSqr().redISub(U).redISub(U), O = w, q = z.redMul(U.redISub(w)).redISub(A.redIMuln(8)), H = this.y.redMuln(2); return this.curve.jpoint(O, q, H); }
                    _dbl0() { const y = this.x.redSqr(), C = this.y.redSqr(), A = C.redSqr(), U = C.redIAdd(this.x).redSqr().redISub(y).redISub(A).redIMuln(2), z = y.redIMuln(3), w = z.redSqr().redISub(U).redISub(U), O = z.redMul(U.redISub(w)).redISub(A.redIMuln(8)), q = this.y.redMul(this.z).redIMuln(2); return this.curve.jpoint(w, O, q); }
                    _dbl3() { const y = this.z.redSqr(), C = this.y.redSqr(), A = this.x.redMul(C), U = this.x.redSub(y), z = this.x.redAdd(y), w = U.redMul(z).redIMuln(3), O = A.redIMuln(4), q = O.redMuln(2), H = C.redSqr().redIMuln(8), V = w.redSqr().redISub(q), J = this.y.redAdd(this.z).redSqr().redISub(C).redISub(y), Z = w.redMul(O.redISub(V)).redISub(H); return this.curve.jpoint(V, Z, J); }
                    dblp(y) { return D(y >>> 0 === y), this.curve.zeroA || this.curve.threeA ? super.dblp(y) : y === 0 || this.isInfinity() ? this : this._dblp(y); }
                    _dblp(y) { const { a: C, i2: A } = this.curve; let U = this.x, z = this.z, w = this.y.redMuln(2), O = z.redPown(4); for (let q = 0; q < y; q++) {
                        if (w.isZero())
                            return this.curve.jpoint();
                        const H = U.redSqr(), V = w.redSqr(), J = V.redSqr(), Z = H.redIMuln(3).redIAdd(C.redMul(O)), tt = U.redMul(V), nt = Z.redSqr().redISub(tt).redISub(tt), rt = nt, it = Z.redMul(tt.redISub(nt)).redIMuln(2).redISub(J), st = w.redMul(z);
                        q + 1 < y && (O = O.redMul(J)), U = rt, w = it, z = st;
                    } return this.curve.jpoint(U, w.redMul(A), z); }
                    uadd(y) { return D(y instanceof h), y.type === c ? this._uadd(y.toJ()) : this._uadd(y); }
                    _uadd(y) { D(y instanceof p); const { zero: C, one: A } = this.curve, U = this.z.redSqr(), z = y.z.redSqr(), w = this.x.redMul(z), O = y.x.redMul(U), q = this.y.redMul(z).redMul(y.z), H = y.y.redMul(U).redMul(this.z), V = this.z.redMul(y.z), J = w.redAdd(O), Z = q.redAdd(H), tt = J.redSqr().redISub(w.redMul(O)); if (!this.curve.zeroA) {
                        const wt = V.redPown(4);
                        this.curve.threeA ? tt.redIAdd(wt.redIMuln(-3)) : tt.redIAdd(this.curve.a.redMul(wt));
                    } const nt = Z.czero() & tt.czero(); Z.cinject(w.redSub(O), nt), tt.cinject(q.redSub(H), nt); const rt = Z.redSqr(), it = J.redMul(rt), st = rt.redSqr(); st.cinject(C, nt); const at = tt.redSqr(), ct = V.redMul(Z), lt = it.redMuln(3).redISub(at).redISub(at), pt = at.redISub(it).redIMuln(4), mt = tt.redMul(lt).redISub(st).redIMuln(4), Tt = ct.redIMuln(2), vt = this.z.czero(), Rt = y.z.czero(), Bt = Tt.czero() & (1 ^ (vt | Rt)); return pt.cinject(y.x, vt), mt.cinject(y.y, vt), Tt.cinject(y.z, vt), pt.cinject(this.x, Rt), mt.cinject(this.y, Rt), Tt.cinject(this.z, Rt), pt.cinject(A, Bt), mt.cinject(A, Bt), Tt.cinject(C, Bt), this.curve.jpoint(pt, mt, Tt); }
                    udbl() { const y = this._udbl(), C = this.z.czero() | this.y.czero(); return y.x.cinject(this.curve.one, C), y.y.cinject(this.curve.one, C), y.z.cinject(this.curve.zero, C), y; }
                    _udbl() { return this.curve.zeroA ? this._dbl0() : this.curve.threeA ? this._dbl3() : this._dblJ(); }
                    zaddu(y) { D(y instanceof p); const C = this.x.redSub(y.x), A = this.y.redSub(y.y), U = C.redSqr(), z = this.x.redMul(U), w = y.x.redMul(U), O = z, q = A.redSqr().redISub(z).redISub(w), H = this.y.redMul(z.redSub(w)), V = A.redMul(O.redSub(q)).redISub(H), J = this.z.redMul(C), Z = J; return [this.curve.jpoint(q, V, Z), this.curve.jpoint(O, H, J)]; }
                    zaddc(y) { D(y instanceof p); const C = this.x.redSub(y.x), A = this.y.redSub(y.y), U = this.y.redAdd(y.y), z = C.redSqr(), w = this.x.redMul(z), O = y.x.redMul(z), q = U.redSqr().redISub(w).redISub(O), H = A.redSqr().redISub(w).redISub(O), V = this.y.redMul(O.redISub(w)), J = y.y.redMuln(2).redIAdd(A), Z = w.redISub(q), tt = q.redAdd(Z).redISub(H), nt = J.redMul(Z).redIAdd(V), rt = A.redMul(tt).redIAdd(V), it = this.z.redMul(C), st = it; return [this.curve.jpoint(H, rt, st), this.curve.jpoint(q, nt, it)]; }
                    zdblu() { const y = this.x.redSqr(), C = this.y.redSqr(), A = C.redSqr(), U = this.x.redAdd(C).redSqr(), z = y.redMuln(3); if (!this.curve.zeroA) {
                        const Z = this.z.redPown(4);
                        this.curve.threeA ? z.redIAdd(Z.redIMuln(-3)) : z.redIAdd(this.curve.a.redMul(Z));
                    } const w = U.redISub(y).redISub(A).redIMuln(2), O = z.redSqr().redISub(w).redISub(w), q = A.redIMuln(8), H = w.redSub(O).redMul(z).redISub(q), V = this.y.redMul(this.z).redIMuln(2), J = V; return [this.curve.jpoint(O, H, J), this.curve.jpoint(w, q, V)]; }
                    recover(y, C, A, U) { return this.toP().recover(y, C, A, U); }
                    getX() { if (this.isInfinity())
                        throw new Error("Invalid point."); return this.normalize(), this.x.fromRed(); }
                    getY() { if (this.isInfinity())
                        throw new Error("Invalid point."); return this.normalize(), this.y.fromRed(); }
                    eq(y) { if (D(y instanceof p), this === y)
                        return !0; if (this.isInfinity())
                        return y.isInfinity(); if (y.isInfinity())
                        return !1; if (this.z.eq(y.z))
                        return this.x.eq(y.x) && this.y.eq(y.y); const C = this.z.redSqr(), A = y.z.redSqr(), U = this.x.redMul(A), z = y.x.redMul(C); if (!U.eq(z))
                        return !1; const w = C.redMul(this.z), O = A.redMul(y.z), q = this.y.redMul(O), H = y.y.redMul(w); return q.eq(H); }
                    cmp(y) { D(y instanceof p); const C = this.isInfinity(), A = y.isInfinity(); return C && !A ? -1 : !C && A ? 1 : C && A ? 0 : this.order().cmp(y.order()) || this.getX().cmp(y.getX()) || this.getY().cmp(y.getY()); }
                    isInfinity() { return this.z.isZero(); }
                    isOrder2() { return !this.isInfinity() && this.y.isZero(); }
                    isOdd() { return !this.isInfinity() && (this.normalize(), this.y.redIsOdd()); }
                    isEven() { return !this.isInfinity() && (this.normalize(), this.y.redIsEven()); }
                    isSquare() { return !this.isInfinity() && this.y.redMul(this.z).redJacobi() !== -1; }
                    eqX(y) { if (D(y instanceof e), D(!y.red), this.isInfinity())
                        return !1; const C = this.z.redSqr(), A = y.toRed(this.curve.red).redMul(C); return this.x.eq(A); }
                    eqR(y) { if (D(y instanceof e), D(!y.red), !this.curve.smallGap)
                        return this.toP().eqR(y); if (this.isInfinity())
                        return !1; if (y.cmp(this.curve.p) >= 0)
                        return !1; const C = this.z.redSqr(), A = y.toRed(this.curve.red).redMul(C); if (this.x.eq(A))
                        return !0; if (this.curve.highOrder)
                        return !1; if (y.cmp(this.curve.pmodn) >= 0)
                        return !1; const U = this.curve.redN.redMul(C); return A.redIAdd(U), this.x.eq(A); }
                    toP() { return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y)); }
                    toJ() { return this; }
                    encode(y) { return this.toP().encode(y); }
                    static decode(y, C) { return l.decode(y, C).toJ(); }
                    encodeX() { return this.toP().encodeX(); }
                    static decodeEven(y, C) { return l.decodeEven(y, C).toJ(); }
                    static decodeSquare(y, C) { return l.decodeSquare(y, C).toJ(); }
                    toJSON(y) { return this.toP().toJSON(y); }
                    toPretty() { return this.toP().toPretty(); }
                    static fromJSON(y, C) { return l.fromJSON(y, C).toJ(); }
                    [r]() { return this.isInfinity() ? "<JPoint: Infinity>" : "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"; }
                } class g extends o {
                    constructor(y) { super(b, "mont", y), this.a = e.fromJSON(y.a).toRed(this.red), this.b = e.fromJSON(y.b).toRed(this.red), this.bi = this.b.redInvert(), this.a2 = this.a.redAdd(this.two), this.a24 = this.a2.redMul(this.i4), this.a3 = this.a.redMul(this.i3), this.a0 = this.a.redMul(this.bi), this.b0 = this.bi.redSqr(), this._finalize(y); }
                    static _isomorphism(y, C, A) { D(y instanceof e), D(C instanceof e), D(A instanceof e); const U = y.clone(), z = A.clone(); if (C.redDiv(A).redJacobi() !== 1)
                        throw new Error("Invalid `b` coefficient."); return [U, z]; }
                    _short(y, C) { const { a: A, b: U, three: z } = this, w = A.redSqr(), O = w.redMul(A), q = U.redSqr(), H = q.redMul(U), V = z.redSub(w), J = q.redMuln(3), Z = O.redMuln(2).redISub(A.redMuln(9)), tt = H.redMuln(27), nt = V.redDiv(J), rt = Z.redDiv(tt); return y != null ? a._isomorphism(nt, rt, y, C) : [nt, rt]; }
                    _mont(y) { return g._isomorphism(this.a, this.b, y); }
                    _edwards(y, C = !1) { D(typeof C == "boolean"); const { two: A, bi: U } = this, z = this.a.redAdd(A).redMul(U), w = this.a.redSub(A).redMul(U); return C && z.swap(w), y != null ? v._isomorphism(z, w, y) : [z, w]; }
                    _scaleShort(y) { D(y instanceof a); const [C, A] = y._scale(this); return [this.field(C.redInvert()), this.field(A.redInvert())]; }
                    _scaleMont(y) { return D(y instanceof g), this.g.isInfinity() || y.g.isInfinity() ? this.field(y.b).redDivSqrt(this.b) : this.g.y.redDiv(this.field(y.g.y)); }
                    _scaleEdwards(y, C) { D(y instanceof v); const A = y._scale(this, C); return this.field(A); }
                    _solveY0(y) { D(y instanceof e); const C = this.a0, A = this.b0, U = y.redSqr(); return U.redMul(y).redIAdd(C.redMul(U)).redIAdd(A.redMul(y)); }
                    _elligator2(y) { const C = this.a0.redNeg(), A = this.one.redAdd(this.z.redMul(y.redSqr())); A.cinject(this.one, A.czero()); const U = C.redMul(A.redFermat()), z = U.redNeg().redISub(this.a0), w = this._solveY0(U), O = this._solveY0(z), q = 0 | w.redIsSquare(), H = U.cinject(z, 1 ^ q), V = w.cinject(O, 1 ^ q).redSqrt(); V.cinject(V.redNeg(), V.redIsOdd() ^ y.redIsOdd()); const J = this.b.redMul(H), Z = this.b.redMul(V); return this.point(J, Z); }
                    _invert2(y, C) { const { x: A, y: U } = y, z = 1 & C, w = A.redMul(this.bi), O = U.redMul(this.bi), q = w.redAdd(this.a0), H = w; q.cswap(H, z); const V = q.redINeg(), J = H.redMul(this.z), [Z, tt] = W(V, J); if (tt.cinject(tt.redNeg(), tt.redIsOdd() ^ O.redIsOdd()), !Z)
                        throw new Error("Invalid point."); return tt; }
                    _constMul(y, C, A) { D(y instanceof b); const U = y.toX(), [z, w] = U.ladderConst(C, A), O = y.recover(z, w); return C.isNeg() ? O.neg() : O; }
                    isElliptic() { const y = this.a.redSqr(); return !this.b.redMul(y.redSub(this.four)).isZero(); }
                    jinv() { const { a: y, three: C, four: A } = this, U = y.redSqr(), z = U.redSub(C).redPown(3).redIMuln(256), w = U.redSub(A); if (w.isZero())
                        throw new Error("Curve is not elliptic."); return z.redDiv(w).fromRed(); }
                    point(y, C, A = 0) { return new b(this, y, C, A); }
                    jpoint(y, C, A) { return D(y == null && C == null && A == null), this.point(); }
                    xpoint(y, C) { return new I(this, y, C); }
                    solveY2(y) { D(y instanceof e); const C = y.redSqr(); return C.redMul(y).redIAdd(this.a.redMul(C)).redIAdd(y).redMul(this.bi); }
                    validate(y) { if (D(y instanceof b), y.isInfinity())
                        return !0; const { x: C, y: A } = y, U = this.solveY2(C); return A.redSqr().eq(U); }
                    pointFromX(y, C = null) { D(y instanceof e), D(C == null || typeof C == "boolean"), y.red || (y = y.toRed(this.red)); const A = this.solveY(y); if (C != null) {
                        if (A.isZero() && C)
                            throw new Error("Invalid point.");
                        A.redIsOdd() !== C && A.redINeg();
                    } return this.point(y, A); }
                    isIsomorphic(y, C) { if (D(y instanceof o), !y.p.eq(this.p))
                        return !1; if (y.type === "mont") {
                        const A = this.field(y.a), U = this.field(y.b);
                        return this.a.eq(A) ? this.b.isZero() ? !1 : U.redDiv(this.b).redJacobi() === 1 : !1;
                    } return y.isIsomorphic(this, C); }
                    isIsogenous(y) { return D(y instanceof o), y.type !== "mont" && y.isIsogenous(this); }
                    pointFromShort(y) { if (D(y instanceof l), this.isIsomorphic(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        const { a3: C, b: A } = this, [U, z] = this._scale(y.curve), w = this.field(y.x).redMul(U), O = this.field(y.y).redMul(z), q = A.redMul(w).redISub(C), H = A.redMul(O);
                        return this.point(q, H);
                    } throw new Error("Not implemented."); }
                    pointFromMont(y) { if (D(y instanceof b), this.isIsomorphic(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        const C = this._scale(y.curve), A = this.field(y.x), U = this.field(y.y), z = A, w = C.redMul(U);
                        return this.point(z, w);
                    } throw new Error("Not implemented."); }
                    pointFromEdwards(y) { D(y instanceof R), D(y.curve.p.eq(this.p)); const C = this.field(y.x), A = this.field(y.y), U = this.field(y.z); if (this.isIsogenous(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point(this.zero, this.zero);
                        const z = U.redSqr().redIMuln(2), w = A.redSqr(), O = C.redSqr(), q = z.redISub(O).redISub(w).redMul(A), H = O.redMul(C);
                        return this.cpoint(w, O, q, H);
                    } if (this.isIsomorphic(y.curve, !0)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point(this.zero, this.zero);
                        const z = this._scale(y.curve, !0), w = A.redAdd(U), O = A.redSub(U), q = z.redMul(U).redMul(w), H = C.redMul(O);
                        return this.cpoint(w, O, q, H);
                    } if (this.isIsomorphic(y.curve, !1)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point(this.zero, this.zero);
                        const z = this._scale(y.curve, !1), w = U.redAdd(A), O = U.redSub(A), q = z.redMul(U).redMul(w), H = C.redMul(O);
                        return this.cpoint(w, O, q, H);
                    } throw new Error("Not implemented."); }
                    pointFromUniform(y) { if (D(y instanceof e), this.z.isZero() || this.a.isZero())
                        throw new Error("Not implemented."); return this._elligator2(y); }
                    pointToUniform(y, C) { if (D(y instanceof b), D(C >>> 0 === C), this.z.isZero() || this.a.isZero())
                        throw new Error("Not implemented."); if (y.isInfinity())
                        throw new Error("Invalid point."); const A = (C >>> 4 & 15) % this.torsion.length, U = y.add(this.torsion[A]); return this._invert2(U, C); }
                    decodePoint(y, C) { return b.decode(this, y, C); }
                    encodeX(y) { return D(y instanceof I), y.encode(); }
                    decodeX(y) { return I.decode(this, y); }
                    toShort(y, C, A = null) { const [U, z] = this._short(y, C), w = new a({ red: this.red, prime: this.prime, p: this.p, a: U, b: z, n: this.n, h: this.h }); if (A != null) {
                        const [, O] = w._scale(this);
                        O.redIsOdd() !== A && O.redINeg();
                    } this.g.isInfinity() || (w.g = w.pointFromMont(this.g)); for (let O = 0; O < this.h.word(0); O++)
                        w.torsion[O] = w.pointFromMont(this.torsion[O]); return w; }
                    toMont(y, C = null) { const [A, U] = this._mont(y), z = new g({ red: this.red, prime: this.prime, p: this.p, a: A, b: U, n: this.n, h: this.h, z: this.z }); if (C != null) {
                        const w = z._scale(this);
                        w.redIsOdd() !== C && w.redINeg();
                    } this.g.isInfinity() || (z.g = z.pointFromMont(this.g)); for (let w = 0; w < this.h.word(0); w++)
                        z.torsion[w] = z.pointFromMont(this.torsion[w]); return z; }
                    toEdwards(y, C, A = null) { const [U, z] = this._edwards(y, C), w = new v({ red: this.red, prime: this.prime, p: this.p, a: U, d: z, n: this.n, h: this.h, z: this.z }); if (A != null) {
                        const O = w._scale(this, C);
                        O.redIsOdd() !== A && O.redINeg();
                    } if (this.g.isInfinity() || (w.g = w.pointFromMont(this.g), w.g.normalize()), w.isComplete())
                        for (let O = 0; O < this.h.word(0); O++)
                            w.torsion[O] = w.pointFromMont(this.torsion[O]), w.torsion[O].normalize(); return w; }
                    pointFromJSON(y) { return b.fromJSON(this, y); }
                    toJSON(y) { const C = super.toJSON(y); return C.a = this.a.fromRed().toJSON(), C.b = this.b.fromRed().toJSON(), C; }
                } class b extends h {
                    constructor(y, C, A, U) { D(y instanceof g), super(y, c), this.x = this.curve.zero, this.y = this.curve.zero, this.inf = 1, C != null && this._init(C, A, U); }
                    _init(y, C, A) { D(y instanceof e), D(C instanceof e), this.x = y, this.y = C, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = 0 | A; }
                    clone() { return this.curve.point(this.x.clone(), this.y.clone(), this.inf); }
                    swap(y, C) { D(y instanceof b); const A = 1 & (C >> 31 | -C >> 31), U = this.inf, z = y.inf; return this.x.cswap(y.x, C), this.y.cswap(y.y, C), this.inf = U & (1 ^ A) | z & A, y.inf = z & (1 ^ A) | U & A, this; }
                    scale(y) { return this.clone(); }
                    randomize(y) { return this.clone(); }
                    neg() { return this.inf ? this : this.curve.point(this.x, this.y.redNeg()); }
                    add(y) { if (D(y instanceof b), this.inf)
                        return y; if (y.inf)
                        return this; if (this.x.eq(y.x))
                        return this.y.eq(y.y) ? this.dbl() : this.curve.point(); const C = y.x.redSub(this.x), A = y.y.redSub(this.y).redDiv(C), U = this.curve.b.redMul(A.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(y.x), z = A.redMul(this.x.redSub(U)).redISub(this.y); return this.curve.point(U, z); }
                    dbl() { if (this.inf)
                        return this; if (this.y.isZero())
                        return this.curve.point(); const y = this.x.redSqr().redIMuln(3), C = this.curve.a.redMul(this.x).redIMuln(2), A = y.redIAdd(C).redIAdd(this.curve.one), U = this.curve.b.redMul(this.y).redIMuln(2), z = A.redDiv(U), w = this.curve.b.redMul(z.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x), O = z.redMul(this.x.redSub(w)).redISub(this.y); return this.curve.point(w, O); }
                    uadd(y) { D(y instanceof b); const C = y.x.redSub(this.x), A = y.y.redSub(this.y), U = this.x.redSqr().redIMuln(3), z = this.curve.a.redMul(this.x).redIMuln(2), w = U.redIAdd(z).redIAdd(this.curve.one), O = this.curve.b.redMul(this.y).redIMuln(2), q = C.czero() & A.czero(); A.cinject(w, q), C.cinject(O, q); const H = C.czero() & (1 ^ (this.inf | y.inf)); C.cinject(this.curve.one, C.czero()); const V = A.redMul(C.redFermat()), J = this.curve.b.redMul(V.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(y.x), Z = V.redMul(this.x.redSub(J)).redISub(this.y), tt = H | this.inf & y.inf; return J.cinject(y.x, this.inf), Z.cinject(y.y, this.inf), J.cinject(this.x, y.inf), Z.cinject(this.y, y.inf), J.cinject(this.curve.zero, tt), Z.cinject(this.curve.zero, tt), this.curve.point(J, Z, tt); }
                    udbl() { return this.uadd(this); }
                    recover(y, C) { if (D(y instanceof I), D(C instanceof I), this.inf)
                        return this.curve.point(); const A = this.x.redMul(y.z), U = y.x.redAdd(A), z = y.x.redSub(A).redSqr().redMul(C.x), w = this.curve.a.redMul(y.z).redIMuln(2), O = U.redIAdd(w), q = this.x.redMul(y.x).redIAdd(y.z), H = O.redMul(q), V = w.redMul(y.z), J = H.redISub(V).redMul(C.z), Z = this.curve.b.redMul(this.y).redIMuln(2).redMul(y.z).redMul(C.z), tt = Z.redMul(y.x), nt = J.redISub(z), rt = Z.redMul(y.z); if (rt.isZero())
                        return this.curve.point(); const it = rt.redInvert(), st = tt.redMul(it), at = nt.redMul(it); return this.curve.point(st, at); }
                    getX() { if (this.inf)
                        throw new Error("Invalid point."); return this.x.fromRed(); }
                    getY() { if (this.inf)
                        throw new Error("Invalid point."); return this.y.fromRed(); }
                    eq(y) { return D(y instanceof b), this === y || (this.inf ? y.inf !== 0 : !y.inf && this.x.eq(y.x) && this.y.eq(y.y)); }
                    cmp(y) { return D(y instanceof b), this.inf && !y.inf ? -1 : !this.inf && y.inf ? 1 : this.inf && y.inf ? 0 : this.order().cmp(y.order()) || this.getX().cmp(y.getX()) || this.getY().cmp(y.getY()); }
                    isInfinity() { return this.inf !== 0; }
                    isOrder2() { return !this.inf && this.y.isZero(); }
                    isOdd() { return !this.inf && this.y.redIsOdd(); }
                    isEven() { return !this.inf && this.y.redIsEven(); }
                    toP() { return this; }
                    toJ() { return this; }
                    toX() { return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one); }
                    encode() { return this.toX().encode(); }
                    static decode(y, C, A) { return D(y instanceof g), y.decodeX(C).toP(A); }
                    toJSON(y) { return this.inf ? [] : [this.getX().toJSON(), this.getY().toJSON()]; }
                    toPretty() { if (this.inf)
                        return []; const y = 2 * this.curve.fieldSize; return [Y(this.getX(), y), Y(this.getY(), y)]; }
                    static fromJSON(y, C) { if (D(y instanceof g), D(Array.isArray(C)), D(C.length === 0 || C.length === 2 || C.length === 3), C.length === 0)
                        return y.point(); const A = e.fromJSON(C[0]), U = e.fromJSON(C[1]); return y.point(A, U); }
                    [r]() { return this.inf ? "<MontPoint: Infinity>" : "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">"; }
                } class I extends h {
                    constructor(y, C, A) { D(y instanceof g), super(y, t), this.x = this.curve.one, this.z = this.curve.zero, C != null && this._init(C, A); }
                    _init(y, C) { D(y instanceof e), D(C == null || C instanceof e), this.x = y, this.z = C || this.curve.one, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)); }
                    clone() { return this.curve.xpoint(this.x.clone(), this.z.clone()); }
                    swap(y, C) { return D(y instanceof I), this.x.cswap(y.x, C), this.z.cswap(y.z, C), this; }
                    precompute(y, C) { return this; }
                    validate() { if (this.isInfinity())
                        return !0; const { x: y, z: C } = this, A = y.redSqr(), U = A.redMul(y), z = C.redSqr(), w = this.curve.a.redMul(A).redMul(C); return U.redIAdd(w).redIAdd(y.redMul(z)).redMul(this.curve.bi).redMul(C).redJacobi() !== -1; }
                    normalize() { return this.isInfinity() || this.z.eq(this.curve.one) || (this.x = this.x.redDiv(this.z), this.z = this.curve.one), this; }
                    scale(y) { if (D(y instanceof e), this.isInfinity())
                        return this.curve.xpoint(); const C = this.x.redMul(y), A = this.z.redMul(y); return this.curve.xpoint(C, A); }
                    neg() { return this; }
                    dbl() { const y = this.x.redAdd(this.z).redSqr(), C = this.x.redSub(this.z).redSqr(), A = y.redSub(C), U = y.redMul(C), z = A.redMul(C.redIAdd(this.curve.a24.redMul(A))); return this.curve.xpoint(U, z); }
                    diffAdd(y, C) { D(y instanceof I), D(C instanceof I); const A = y.x.redAdd(y.z), U = y.x.redSub(y.z), z = C.x.redAdd(C.z), w = C.x.redSub(C.z).redMul(A), O = z.redMul(U), q = this.z.redMul(w.redAdd(O).redSqr()), H = this.x.redMul(w.redISub(O).redSqr()); return this.curve.xpoint(q, H); }
                    diffAddDbl(y, C) { D(y instanceof I), D(C instanceof I); const A = y.x.redAdd(y.z), U = A.redSqr(), z = y.x.redSub(y.z), w = z.redSqr(), O = U.redSub(w), q = C.x.redAdd(C.z), H = C.x.redSub(C.z).redMul(A), V = q.redMul(z), J = this.z.redMul(H.redAdd(V).redSqr()), Z = this.x.redMul(H.redISub(V).redSqr()), tt = U.redMul(w), nt = O.redMul(w.redIAdd(this.curve.a24.redMul(O))); return [this.curve.xpoint(tt, nt), this.curve.xpoint(J, Z)]; }
                    getX() { if (this.isInfinity())
                        throw new Error("Invalid point."); return this.normalize(), this.x.fromRed(); }
                    getY(y) { return this.toP(y).getY(); }
                    eq(y) { if (D(y instanceof I), this === y)
                        return !0; if (this.isInfinity())
                        return y.isInfinity(); if (y.isInfinity())
                        return !1; if (this.z.eq(y.z))
                        return this.x.eq(y.x); const C = this.x.redMul(y.z), A = y.x.redMul(this.z); return C.eq(A); }
                    cmp(y) { D(y instanceof I); const C = this.isInfinity(), A = y.isInfinity(); return C && !A ? -1 : !C && A ? 1 : C && A ? 0 : this.order().cmp(y.order()) || this.getX().cmp(y.getX()); }
                    isInfinity() { return this.z.isZero(); }
                    isOrder2() { return !this.isInfinity() && this.x.isZero(); }
                    isOdd() { return !1; }
                    isEven() { return !1; }
                    hasTorsion() { return !this.isInfinity() && (!!this.x.isZero() || super.hasTorsion()); }
                    order() { try {
                        return this.toP().order();
                    }
                    catch (y) {
                        return new e(1);
                    } }
                    jmul(y) { return this.ladder(y)[0]; }
                    jmulSimple(y) { return this.ladderSimple(y)[0]; }
                    jmulBlind(y, C) { return this.ladderBlind(y, C)[0]; }
                    jmulConst(y, C) { return this.ladderConst(y, C)[0]; }
                    jmulAdd(y, C, A) { throw new Error("Not implemented."); }
                    jmulAddSimple(y, C, A) { throw new Error("Not implemented."); }
                    ladder(y) { D(y instanceof e), D(!y.red); const C = y.bitLength(); let A = this.curve.xpoint(), U = this; for (let z = C - 1; z >= 0; z--)
                        y.bit(z) === 0 ? [A, U] = this.diffAddDbl(A, U) : [U, A] = this.diffAddDbl(U, A); return [A, U]; }
                    ladderSimple(y) { D(y instanceof e), D(!y.red); const C = y.bitLength(); let A = this.curve.xpoint(), U = this; for (let z = C - 1; z >= 0; z--)
                        y.bit(z) === 0 ? (U = this.diffAdd(U, A), A = A.dbl()) : (A = this.diffAdd(A, U), U = U.dbl()); return [A, U]; }
                    ladderBlind(y, C) { return C ? this.randomize(C).ladder(y) : this.ladder(y); }
                    ladderConst(y, C) { D(y instanceof e), D(!y.red); const A = Math.max(y.bitLength(), this.curve.fieldBits), U = A + 7 >>> 3, z = y.toArray("le", U), w = C ? this.randomize(C) : this; let O = this.curve.xpoint().clone(), q = w.clone(), H = 0; for (let V = A - 1; V >= 0; V--) {
                        const J = z[V >> 3] >> (7 & V) & 1;
                        O.swap(q, H ^ J), [O, q] = w.diffAddDbl(O, q), H = J;
                    } return O.swap(q, H), [O, q]; }
                    toP(y = null) { return D(y == null || typeof y == "boolean"), this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, y)); }
                    toJ() { return this; }
                    toX() { return this; }
                    key() { if (this.isInfinity())
                        return this.curve.uid + ":oo"; this.normalize(); const y = this.getX().toString(16); return `${this.curve.uid}:${y}`; }
                    encode() { return this.curve.encodeField(this.getX()); }
                    static decode(y, C) { D(y instanceof g); const A = y.decodeField(C); A.iumaskn(y.fieldBits); const U = y.xpoint(A, y.one); return D(!U.isInfinity()), U; }
                    toJSON(y) { return this.toP().toJSON(y); }
                    toPretty() { return this.toP().toPretty(); }
                    static fromJSON(y, C) { return b.fromJSON(y, C).toX(); }
                    [r]() { return this.isInfinity() ? "<XPoint: Infinity>" : "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"; }
                } class v extends o {
                    constructor(y) { super(R, "edwards", y), this.a = e.fromJSON(y.a).toRed(this.red), this.d = e.fromJSON(y.d).toRed(this.red), this.s = e.fromJSON(y.s || "0").toRed(this.red), this.si = this.s.isZero() ? this.zero : this.s.redInvert(), this.k = this.d.redMuln(2), this.smi = -this.d.redNeg().word(0), this.ad6 = this.a.redAdd(this.d).redMul(this.i6), this.twisted = !this.a.eq(this.one), this.oneA = this.a.eq(this.one), this.mOneA = this.a.eq(this.one.redNeg()), this.smallD = this.prime != null && this.d.redNeg().length === 1, this.alt = null, this._finalize(y); }
                    static _isomorphism(y, C, A) { D(y instanceof e), D(C instanceof e), D(A instanceof e); const U = A.clone(), z = A.redMul(C).redDiv(y); if (y.redDiv(A).redJacobi() !== 1)
                        throw new Error("Invalid `a` coefficient."); return [U, z]; }
                    _short(y, C) { const { a: A, d: U } = this, z = A.redSqr(), w = z.redMul(A), O = U.redSqr(), q = O.redMul(U), H = A.redMul(U).redIMuln(14), V = z.redMul(U), J = A.redMul(O), Z = V.redIAdd(J).redIMuln(33), tt = z.redAdd(H).redIAdd(O).redDivn(-48), nt = Z.redISub(w).redISub(q).redDivn(864); return y != null ? a._isomorphism(tt, nt, y, C) : [tt, nt]; }
                    _mont(y, C = !1) { let A, U; D(typeof C == "boolean"), C ? (A = this.d.redAdd(this.a), U = this.d.redSub(this.a)) : (A = this.a.redAdd(this.d), U = this.a.redSub(this.d)); const z = U.redInvert(), w = A.redMuln(2).redMul(z), O = z.redMuln(4); return y != null ? g._isomorphism(w, O, y) : [w, O]; }
                    _edwards(y) { return v._isomorphism(this.a, this.d, y); }
                    _scaleShort(y) { D(y instanceof a); const [C, A] = y._scale(this); return [this.field(C.redInvert()), this.field(A.redInvert())]; }
                    _scaleMont(y, C = !1) { if (D(y instanceof g), D(typeof C == "boolean"), this.g.isInfinity() || y.g.isInfinity()) {
                        const [U] = y._edwards(null, C);
                        return this.field(U).redDivSqrt(this.a);
                    } const A = y.g.x.redDiv(y.g.y); return this.g.x.redDiv(this.field(A)); }
                    _scaleEdwards(y) { return D(y instanceof v), this.g.isInfinity() || y.g.isInfinity() ? this.field(y.a).redDivSqrt(this.a) : this.g.x.redDiv(this.field(y.g.x)); }
                    _mulA(y) { return D(y instanceof e), this.oneA ? y.clone() : this.mOneA ? y.redNeg() : this.a.redMul(y); }
                    _mulD(y) { return D(y instanceof e), this.smallD ? y.redMuln(this.smi) : this.d.redMul(y); }
                    _elligator1(y) { const { s: C, si: A, i2: U, one: z, two: w } = this, O = A.redSqr().redIMuln(2), q = C.redSqr().redMul(U), H = q.redSqr(), V = O.redAdd(q), J = V.redSqr().redISub(w), Z = O.redSub(z), tt = this.p.subn(2), nt = this.p.subn(1).iushrn(1), rt = this.p.addn(1).iushrn(2), it = z.redSub(y), st = z.redAdd(y), at = it.redMul(st.redPow(tt)), ct = at.redSqr(), lt = ct.redMul(at), pt = lt.redMul(ct).redAdd(J.redMul(lt)).redIAdd(at), mt = pt.redPow(nt), Tt = ct.redAdd(H).redPow(nt), vt = mt.redMul(Tt), Rt = mt.redMul(at), Bt = mt.redMul(pt).redPow(rt).redMul(vt), wt = z.redAdd(Rt), kt = V.redMul(Rt), Wt = wt.redSqr(), Ct = Z.redMul(C).redMul(Rt).redMul(wt), Ft = Bt.cinject(this.one, at.czero()), te = kt.redSub(Wt), jt = kt.redAdd(Wt); return this.cpoint(Ct, Ft, te, jt); }
                    _invert1(y, C) { const { s: A, si: U, i2: z, one: w } = this, { x: O, y: q, z: H } = y, V = 1 & C, J = U.redSqr().redIMuln(2), Z = A.redSqr().redMul(z), tt = Z.redSqr(), nt = J.redAdd(Z), rt = J.redSub(w), it = this.p.subn(2), st = this.p.subn(1).iushrn(1), at = this.p.addn(1).iushrn(2), ct = q.redSub(H), lt = q.redAdd(H).redIMuln(2), pt = ct.redMul(lt.redPow(it)), mt = w.redAdd(pt.redMul(nt)), Tt = mt.redSqr().redISub(w), vt = Tt.redPow(at), Rt = vt.redSqr().ceq(Tt), Bt = vt.redSub(mt), wt = w.redAdd(Bt), kt = rt.redMul(A).redMul(Bt).redMul(wt).redMul(O.redMul(H)), Wt = Bt.redSqr().redIAdd(tt), Ct = kt.redMul(Wt).redPow(st).redMul(Bt), Ft = w.redSub(Ct), te = w.redAdd(Ct), jt = Ft.redMul(te.redPow(it)); if (jt.cinject(jt.redNeg(), jt.redIsOdd() ^ V), !Rt)
                        throw new Error("Invalid point."); return jt; }
                    _alt() { return this.alt || (this.alt = this.toMont()), this.alt; }
                    isElliptic() { const y = this.a.redMul(this.d), C = this.a.redSub(this.d); return !y.redMul(C).isZero(); }
                    jinv() { const { a: y, d: C } = this, A = y.redMul(C), U = y.redSub(C).redPown(4), z = y.redSqr(), w = C.redSqr(), O = z.redAdd(A.redMuln(14)).redIAdd(w).redPown(3).redIMuln(16), q = A.redMul(U); if (q.isZero())
                        throw new Error("Curve is not elliptic."); return O.redDiv(q).fromRed(); }
                    isComplete() { return this.a.redJacobi() === 1 && this.d.redJacobi() === -1; }
                    point(y, C, A, U) { return new R(this, y, C, A, U); }
                    jpoint(y, C, A) { return D(y == null && C == null && A == null), this.point(); }
                    cpoint(y, C, A, U) { D(y instanceof e), D(C instanceof e), D(A instanceof e), D(U instanceof e); const z = y.redMul(U), w = A.redMul(C), O = C.redMul(U), q = y.redMul(A); return this.point(z, w, O, q); }
                    solveX2(y) { D(y instanceof e); const C = y.redSqr(), A = this._mulD(C).redISub(this.a); return C.redISub(this.one).redDiv(A); }
                    solveX(y) { const C = y.redSqr(), A = this._mulD(C).redISub(this.a); return C.redISub(this.one).redDivSqrt(A); }
                    solveY2(y) { D(y instanceof e); const C = y.redSqr(), A = this._mulA(C).redISub(this.one), U = this._mulD(C).redISub(this.one); return A.redDiv(U); }
                    solveY(y) { const C = y.redSqr(), A = this._mulA(C).redISub(this.one), U = this._mulD(C).redISub(this.one); return A.redDivSqrt(U); }
                    validate(y) { if (D(y instanceof R), y.zOne) {
                        const J = y.x.redSqr(), Z = y.y.redSqr(), tt = this._mulD(J).redMul(Z), nt = this._mulA(J).redIAdd(Z), rt = this.one.redAdd(tt), it = y.t, st = y.x.redMul(y.y);
                        return nt.eq(rt) && it.eq(st);
                    } const C = y.x.redSqr(), A = y.y.redSqr(), U = y.z.redSqr(), z = U.redSqr(), w = this._mulD(C).redMul(A), O = this._mulA(C).redIAdd(A).redMul(U), q = z.redIAdd(w), H = y.t.redMul(y.z), V = y.x.redMul(y.y); return O.eq(q) && H.eq(V); }
                    pointFromX(y, C = null) { D(y instanceof e), D(C == null || typeof C == "boolean"), y.red || (y = y.toRed(this.red)); const A = this.solveY(y); if (C != null) {
                        if (A.isZero() && C)
                            throw new Error("Invalid point.");
                        A.redIsOdd() !== C && A.redINeg();
                    } return this.point(y, A); }
                    pointFromY(y, C = null) { D(y instanceof e), D(C == null || typeof C == "boolean"), y.red || (y = y.toRed(this.red)); const A = this.solveX(y); if (C != null) {
                        if (A.isZero() && C)
                            throw new Error("Invalid point.");
                        A.redIsOdd() !== C && A.redINeg();
                    } return this.point(A, y); }
                    isIsomorphic(y, C = !1) { if (D(y instanceof o), D(typeof C == "boolean"), !y.p.eq(this.p))
                        return !1; if (y.type === "short")
                        return y.isIsomorphic(this); if (y.type === "mont") {
                        const A = this.field(y.a);
                        let U, z;
                        return C ? (U = this.d.redAdd(this.a), z = this.d.redSub(this.a)) : (U = this.a.redAdd(this.d), z = this.a.redSub(this.d)), A.redMul(z).eq(U.redIMuln(2));
                    } if (y.type === "edwards") {
                        const A = this.field(y.a), U = this.field(y.d);
                        return this.a.redMul(U).eq(A.redMul(this.d));
                    } return !1; }
                    isIsogenous(y) { if (D(y instanceof o), !y.p.eq(this.p))
                        return !1; if (y.type === "mont") {
                        if (!this.a.eq(this.one))
                            return !1;
                        const C = this.field(y.a), A = this.field(y.b), U = this.two.redSub(this.d.redMuln(4));
                        return C.eq(U) && A.eq(this.one);
                    } if (y.type === "edwards") {
                        const C = this.field(y.a), A = this.field(y.d);
                        return C.eq(this.a.redNeg()) && A.eq(this.d.redSub(this.a));
                    } return !1; }
                    pointFromShort(y) { if (D(y instanceof l), this.isIsomorphic(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.y.isZero())
                            return this.point(this.zero, this.one.redNeg());
                        const { a: C, d: A } = this, [U, z] = this._scale(y.curve), w = C.redMuln(5), O = A.redMuln(5), q = this.field(y.x).redMul(U), H = this.field(y.y).redMul(z), V = q.redMuln(6), J = q.redMuln(12), Z = V.redSub(C).redISub(A), tt = H.redMuln(6), nt = J.redSub(w).redIAdd(A), rt = J.redAdd(C).redISub(O);
                        return this.cpoint(Z, tt, nt, rt);
                    } throw new Error("Not implemented."); }
                    pointFromMont(y) { D(y instanceof b), D(y.curve.p.eq(this.p)); const C = this.field(y.x), A = this.field(y.y); if (this.isIsogenous(y.curve)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point();
                        const U = C.redSqr(), z = U.redMul(C), w = z.redMul(C), O = w.redMul(C), q = A.redSqr(), H = A.redMuln(4), V = U.redSub(this.one), J = U.redMuln(2), Z = q.redMuln(4), tt = z.redIMuln(2), nt = C.redMul(q).redIMuln(4), rt = U.redMul(q).redIMuln(2), it = q.redIMuln(2), st = H.redMul(V), at = w.redISub(J).redIAdd(Z).redIAdd(this.one), ct = O.redSub(tt).redISub(nt).redIAdd(C).redINeg(), lt = O.redISub(rt).redISub(tt).redISub(it).redIAdd(C);
                        return this.cpoint(st, at, ct, lt).divn(4);
                    } if (this.isIsomorphic(y.curve, !0)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point(this.zero, this.one.redNeg());
                        const U = this._scale(y.curve, !0).redMul(C), z = A, w = C.redAdd(this.one), O = C.redSub(this.one);
                        return this.cpoint(U, z, w, O);
                    } if (this.isIsomorphic(y.curve, !1)) {
                        if (y.isInfinity())
                            return this.point();
                        if (y.x.isZero())
                            return this.point(this.zero, this.one.redNeg());
                        const U = this._scale(y.curve, !1).redMul(C), z = A, w = C.redSub(this.one), O = C.redAdd(this.one);
                        return this.cpoint(U, z, w, O);
                    } throw new Error("Not implemented."); }
                    pointFromEdwards(y) { D(y instanceof R), D(y.curve.p.eq(this.p)); const C = this.field(y.curve.a), A = this.field(y.x), U = this.field(y.y), z = this.field(y.z), w = this.field(y.t); if (this.isIsogenous(y.curve)) {
                        const O = A.redMul(U), q = A.redSqr(), H = U.redSqr(), V = z.redSqr(), J = C.redMul(q), Z = O.redIMuln(2), tt = H.redSub(J), nt = H.redAdd(J), rt = V.redIMuln(2).redISub(nt), it = this.cpoint(Z, tt, nt, rt);
                        return this.twisted ? it : it.divn(4);
                    } if (this.isIsomorphic(y.curve)) {
                        const O = this._scale(y.curve), q = O.redMul(A), H = U, V = z, J = O.redMul(w);
                        return this.point(q, H, V, J);
                    } throw new Error("Not implemented."); }
                    pointFromUniform(y, C = null) { D(y instanceof e), D(y.red === this.red), D(C == null || C instanceof g), C || (C = this._alt()); const A = C.field(y), U = C.pointFromUniform(A); return this.pointFromMont(U); }
                    pointToUniform(y, C, A = null) { D(y instanceof R), D(C >>> 0 === C), D(A == null || A instanceof g), A || (A = this._alt()); const U = (C >> 4 & 15) % this.torsion.length, z = y.add(this.torsion[U]), w = A.pointFromEdwards(z), O = A.pointToUniform(w, 15 & C); return this.field(O); }
                    pointFromHash(y, C, A = null) { D(A == null || A instanceof g), A || (A = this._alt()); const U = A.pointFromHash(y, C); return this.pointFromMont(U); }
                    pointToHash(y, C, A, U = null) { D(y instanceof R), D(C >>> 0 === C), D(U == null || U instanceof g), U || (U = this._alt()); const z = C % this.torsion.length, w = y.add(this.torsion[z]), O = U.pointFromEdwards(w); return U.pointToHash(O, 0, A); }
                    decodePoint(y) { return R.decode(this, y); }
                    toShort(y, C, A = null) { const [U, z] = this._short(y, C), w = new a({ red: this.red, prime: this.prime, p: this.p, a: U, b: z, n: this.n, h: this.h }); if (A != null) {
                        const [, O] = w._scale(this);
                        O.redIsOdd() !== A && O.redINeg();
                    } this.g.isInfinity() || (w.g = w.pointFromEdwards(this.g)); for (let O = 0; O < this.h.word(0); O++)
                        w.torsion[O] = w.pointFromEdwards(this.torsion[O]); return w; }
                    toMont(y, C, A = null) { const [U, z] = this._mont(y, C), w = new g({ red: this.red, prime: this.prime, p: this.p, a: U, b: z, n: this.n, h: this.h, z: this.z }); if (A != null) {
                        const O = this._scale(w, C);
                        O.redIsOdd() !== A && O.redINeg();
                    } this.g.isInfinity() || (w.g = w.pointFromEdwards(this.g)); for (let O = 0; O < this.h.word(0); O++)
                        w.torsion[O] = w.pointFromEdwards(this.torsion[O]); return w; }
                    toEdwards(y, C = null) { const [A, U] = this._edwards(y), z = new v({ red: this.red, prime: this.prime, p: this.p, a: A, d: U, n: this.n, h: this.h, z: this.z }); if (C != null) {
                        const w = z._scale(this);
                        w.redIsOdd() !== C && w.redINeg();
                    } if (this.g.isInfinity() || (z.g = z.pointFromEdwards(this.g), z.g.normalize()), z.isComplete())
                        for (let w = 0; w < this.h.word(0); w++)
                            z.torsion[w] = z.pointFromEdwards(this.torsion[w]), z.torsion[w].normalize(); return z; }
                    pointFromJSON(y) { return R.fromJSON(this, y); }
                    toJSON(y) { const C = super.toJSON(y); return C.a = this.a.fromRed().toJSON(), C.d = this.d.fromRed().toJSON(), this.s.isZero() || (C.s = this.s.fromRed().toJSON()), C; }
                } class R extends h {
                    constructor(y, C, A, U, z) { D(y instanceof v), super(y, s), this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = 1, C != null && this._init(C, A, U, z); }
                    _init(y, C, A, U) { D(y instanceof e), D(C instanceof e), D(A == null || A instanceof e), D(U == null || U instanceof e), this.x = y, this.y = C, this.z = A || this.curve.one, this.t = U || null, this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = 0 | this.z.eq(this.curve.one), this._check(), this.t || (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redDiv(this.z))); }
                    _check() { if (this.z.isZero())
                        throw new Error("Invalid point."); }
                    clone() { return this.curve.point(this.x.clone(), this.y.clone(), this.z.clone(), this.t.clone()); }
                    swap(y, C) { D(y instanceof R); const A = 1 & (C >> 31 | -C >> 31), U = this.zOne, z = y.zOne; return this.x.cswap(y.x, C), this.y.cswap(y.y, C), this.z.cswap(y.z, C), this.t.cswap(y.t, C), this.zOne = U & (1 ^ A) | z & A, y.zOne = z & (1 ^ A) | U & A, this; }
                    normalize() { if (this.zOne)
                        return this; const y = this.z.redInvert(); return this.x = this.x.redMul(y), this.y = this.y.redMul(y), this.t = this.t.redMul(y), this.z = this.curve.one, this.zOne = 1, this; }
                    scale(y) { D(y instanceof e); const C = this.x.redMul(y), A = this.y.redMul(y), U = this.z.redMul(y), z = this.t.redMul(y); return this.curve.point(C, A, U, z); }
                    neg() { const y = this.x.redNeg(), C = this.y, A = this.z, U = this.t.redNeg(); return this.curve.point(y, C, A, U); }
                    add(y) { return D(y instanceof R), this.isInfinity() ? y : y.isInfinity() ? this : this.zOne ? y._add(this, 0) : this._add(y, 0); }
                    _add(y, C) { return this.curve.mOneA ? this._addM1(y, C) : this._addA(y, C); }
                    _addM1(y, C) { const A = y.zOne & (1 ^ C), U = this.y.redSub(this.x).redMul(y.y.redSub(y.x)), z = this.y.redAdd(this.x).redMul(y.y.redAdd(y.x)), w = this.t.redMul(this.curve.k).redMul(y.t), O = A ? this.z.redAdd(this.z) : this.z.redMul(y.z).redIMuln(2), q = z.redSub(U), H = O.redSub(w), V = O.redIAdd(w), J = z.redIAdd(U), Z = q.redMul(H), tt = V.redMul(J), nt = q.redMul(J), rt = H.redMul(V); return this.curve.point(Z, tt, rt, nt); }
                    _addA(y, C) { const A = y.zOne & (1 ^ C), U = this.x.redMul(y.x), z = this.y.redMul(y.y), w = this.curve._mulD(this.t).redMul(y.t), O = A ? this.z.clone() : this.z.redMul(y.z), q = this.x.redAdd(this.y).redMul(y.x.redAdd(y.y)).redISub(U).redISub(z), H = O.redSub(w), V = O.redIAdd(w), J = z.redISub(this.curve._mulA(U)), Z = q.redMul(H), tt = V.redMul(J), nt = q.redMul(J), rt = H.redMul(V); return this.curve.point(Z, tt, rt, nt); }
                    dbl() { return this.isInfinity() ? this : this._dbl(0); }
                    _dbl(y) { const C = this.zOne & (1 ^ y), A = this.x.redSqr(), U = this.y.redSqr(), z = C ? this.curve.two : this.z.redSqr().redIMuln(2), w = this.curve._mulA(A), O = this.x.redAdd(this.y).redSqr().redISub(A).redISub(U), q = w.redAdd(U), H = q.redSub(z), V = w.redISub(U), J = O.redMul(H), Z = q.redMul(V), tt = O.redMul(V), nt = H.redMul(q); return this.curve.point(J, Z, nt, tt); }
                    uadd(y) { return D(y instanceof R), this._add(y, 1); }
                    udbl() { return this._dbl(1); }
                    getX() { return this.normalize(), this.x.fromRed(); }
                    getY() { return this.normalize(), this.y.fromRed(); }
                    eq(y) { if (D(y instanceof R), D(!this.z.isZero()), D(!y.z.isZero()), this === y)
                        return !0; if (this.z.eq(y.z))
                        return this.x.eq(y.x) && this.y.eq(y.y); const C = this.x.redMul(y.z), A = y.x.redMul(this.z); if (!C.eq(A))
                        return !1; const U = this.y.redMul(y.z), z = y.y.redMul(this.z); return U.eq(z); }
                    cmp(y) { return D(y instanceof R), this.order().cmp(y.order()) || this.getY().cmp(y.getY()) || this.getX().cmp(y.getX()); }
                    isInfinity() { return D(!this.z.isZero()), !!this.x.isZero() && this.y.eq(this.z); }
                    isOrder2() { return !this.isInfinity() && this.x.isZero(); }
                    isOdd() { return this.normalize(), this.x.redIsOdd(); }
                    isEven() { return this.normalize(), this.x.redIsEven(); }
                    toP() { return this.normalize(); }
                    toJ() { return this; }
                    encode() { const y = this.getY(); return y.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(y); }
                    static decode(y, C) { D(y instanceof v); const A = y.decodeAdjusted(C), U = A.testn(y.signBit) !== 0; if (A.setn(y.signBit, 0), A.cmp(y.p) >= 0)
                        throw new Error("Invalid point."); return y.pointFromY(A, U); }
                    toJSON(y) { if (this.isInfinity())
                        return []; const C = this.getX().toJSON(), A = this.getY().toJSON(); return y === !0 && this.pre ? [C, A, this.pre.toJSON()] : [C, A]; }
                    toPretty() { const y = 2 * this.curve.fieldSize; return [Y(this.getX(), y), Y(this.getY(), y)]; }
                    static fromJSON(y, C) { if (D(y instanceof v), D(Array.isArray(C)), D(C.length === 0 || C.length === 2 || C.length === 3), C.length === 0)
                        return y.point(); const A = e.fromJSON(C[0]), U = e.fromJSON(C[1]), z = y.point(A, U); return C.length > 2 && C[2] != null && (z.pre = _.fromJSON(z, C[2])), z; }
                    [r]() { return this.isInfinity() ? "<EdwardsPoint: Infinity>" : "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">"; }
                } class _ {
                    constructor() { this.naf = null, this.windows = null, this.doubles = null, this.blinding = null, this.beta = null; }
                    map(y) { D(typeof y == "function"); const C = new this.constructor; return this.naf && (C.naf = this.naf.map(y)), this.doubles && (C.doubles = this.doubles.map(y)), C; }
                    toJSON() { return { naf: this.naf ? this.naf.toJSON() : null, windows: this.windows ? this.windows.toJSON() : null, doubles: this.doubles ? this.doubles.toJSON() : null, blinding: this.blinding ? this.blinding.toJSON() : void 0 }; }
                    fromJSON(y, C) { return D(y instanceof h), D(C && typeof C == "object"), C.naf != null && (this.naf = k.fromJSON(y, C.naf)), C.windows != null && (this.windows = x.fromJSON(y, C.windows)), C.doubles != null && (this.doubles = M.fromJSON(y, C.doubles)), C.blinding != null && (this.blinding = N.fromJSON(y, C.blinding)), this; }
                    static fromJSON(y, C) { return new this().fromJSON(y, C); }
                } class k {
                    constructor(y, C) { this.width = y, this.points = C; }
                    map(y) { D(typeof y == "function"); const { width: C } = this, A = []; for (const U of this.points)
                        A.push(y(U)); return new this.constructor(C, A); }
                    toJSON() { return { width: this.width, points: this.points.slice(1).map(y => y.toJSON()) }; }
                    static fromJSON(y, C) { D(y instanceof h), D(C && typeof C == "object"), D(C.width >>> 0 === C.width), D(Array.isArray(C.points)); const { curve: A } = y, { width: U } = C, z = [y]; for (const w of C.points)
                        z.push(A.pointFromJSON(w)); return new this(U, z); }
                } class x {
                    constructor(y, C, A) { this.width = y, this.bits = C, this.points = A; }
                    toJSON() { return { width: this.width, bits: this.bits, points: this.points.slice(1).map(y => y.toJSON()) }; }
                    static fromJSON(y, C) { D(y instanceof h), D(C && typeof C == "object"), D(C.width >>> 0 === C.width), D(C.bits >>> 0 === C.bits), D(Array.isArray(C.points)); const { curve: A } = y, { width: U, bits: z } = C, w = [y]; for (const O of C.points)
                        w.push(A.pointFromJSON(O)); return new this(U, z, w); }
                } class M {
                    constructor(y, C) { this.step = y, this.points = C; }
                    map(y) { D(typeof y == "function"); const { step: C } = this, A = []; for (const U of this.points)
                        A.push(y(U)); return new this.constructor(C, A); }
                    toJSON() { return { step: this.step, points: this.points.slice(1).map(y => y.toJSON()) }; }
                    static fromJSON(y, C) { D(y instanceof h), D(C && typeof C == "object"), D(C.step >>> 0 === C.step), D(Array.isArray(C.points)); const { curve: A } = y, { step: U } = C, z = [y]; for (const w of C.points)
                        z.push(A.pointFromJSON(w)); return new this(U, z); }
                } class N {
                    constructor(y, C) { this.blind = y, this.unblind = C; }
                    toJSON() { return { blind: this.blind.toJSON(), unblind: this.unblind.toJSON() }; }
                    static fromJSON(y, C) { D(y instanceof h), D(C && typeof C == "object"); const { curve: A } = y; return new this(e.fromJSON(C.blind), A.pointFromJSON(C.unblind)); }
                } class S {
                    constructor(y, C, A, U) { this.beta = y, this.lambda = C, this.basis = A, this.pre = U; }
                    toJSON() { return { beta: this.beta.fromRed().toJSON(), lambda: this.lambda.toJSON(), basis: [this.basis[0].toJSON(), this.basis[1].toJSON()], pre: [this.pre[0].toJSON(), this.pre[1].toJSON()] }; }
                    static fromJSON(y, C) { return D(y instanceof o), D(C && typeof C == "object"), D(Array.isArray(C.basis)), D(Array.isArray(C.pre)), D(C.basis.length === 2), D(C.pre.length === 2), new this(e.fromJSON(C.beta).toRed(y.red), e.fromJSON(C.lambda), [T.fromJSON(C.basis[0]), T.fromJSON(C.basis[1])], [e.fromJSON(C.pre[0]), e.fromJSON(C.pre[1])]); }
                } class T {
                    constructor(y, C) { this.a = y, this.b = C; }
                    toJSON() { return { a: this.a.toJSON(), b: this.b.toJSON() }; }
                    static fromJSON(y) { return D(y && typeof y == "object"), new this(e.fromJSON(y.a), e.fromJSON(y.b)); }
                } const B = { __proto__: null, P192: class extends a {
                        constructor($) { super({ id: "P192", ossl: "prime192v1", type: "short", endian: "be", hash: "SHA256", prime: "p192", p: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff ffffffff"], a: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff fffffffc"], b: ["64210519 e59c80e7 0fa7e9ab 72243049", "feb8deec c146b9b1"], n: ["ffffffff ffffffff ffffffff 99def836", "146bc9b1 b4d22831"], h: "1", z: "-5", g: [["188da80e b03090f6 7cbf20eb 43a18800", "f4ff0afd 82ff1012"], ["07192b95 ffc8da78 631011ed 6b24cdd5", "73f977a1 1e794811"], $] }); }
                    }, P224: class extends a {
                        constructor($) { super({ id: "P224", ossl: "secp224r1", type: "short", endian: "be", hash: "SHA256", prime: "p224", p: ["ffffffff ffffffff ffffffff ffffffff", "00000000 00000000 00000001"], a: ["ffffffff ffffffff ffffffff fffffffe", "ffffffff ffffffff fffffffe"], b: ["b4050a85 0c04b3ab f5413256 5044b0b7", "d7bfd8ba 270b3943 2355ffb4"], n: ["ffffffff ffffffff ffffffff ffff16a2", "e0b8f03e 13dd2945 5c5c2a3d"], h: "1", z: "1f", g: [["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3", "56c21122 343280d6 115c1d21"], ["bd376388 b5f723fb 4c22dfe6 cd4375a0", "5a074764 44d58199 85007e34"], $] }); }
                    }, P256: class extends a {
                        constructor($) { super({ id: "P256", ossl: "prime256v1", type: "short", endian: "be", hash: "SHA256", prime: null, p: ["ffffffff 00000001 00000000 00000000", "00000000 ffffffff ffffffff ffffffff"], a: ["ffffffff 00000001 00000000 00000000", "00000000 ffffffff ffffffff fffffffc"], b: ["5ac635d8 aa3a93e7 b3ebbd55 769886bc", "651d06b0 cc53b0f6 3bce3c3e 27d2604b"], n: ["ffffffff 00000000 ffffffff ffffffff", "bce6faad a7179e84 f3b9cac2 fc632551"], h: "1", z: "-a", g: [["6b17d1f2 e12c4247 f8bce6e5 63a440f2", "77037d81 2deb33a0 f4a13945 d898c296"], ["4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16", "2bce3357 6b315ece cbb64068 37bf51f5"], $] }); }
                    }, P384: class extends a {
                        constructor($) { super({ id: "P384", ossl: "secp384r1", type: "short", endian: "be", hash: "SHA384", prime: null, p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff fffffffe", "ffffffff 00000000 00000000 ffffffff"], a: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff fffffffe", "ffffffff 00000000 00000000 fffffffc"], b: ["b3312fa7 e23ee7e4 988e056b e3f82d19", "181d9c6e fe814112 0314088f 5013875a", "c656398d 8a2ed19d 2a85c8ed d3ec2aef"], n: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff c7634d81 f4372ddf", "581a0db2 48b0a77a ecec196a ccc52973"], h: "1", z: "-c", g: [["aa87ca22 be8b0537 8eb1c71e f320ad74", "6e1d3b62 8ba79b98 59f741e0 82542a38", "5502f25d bf55296c 3a545e38 72760ab7"], ["3617de4a 96262c6f 5d9e98bf 9292dc29", "f8f41dbd 289a147c e9da3113 b5f0b8c0", "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"], $] }); }
                    }, P521: class extends a {
                        constructor($) { super({ id: "P521", ossl: "secp521r1", type: "short", endian: "be", hash: "SHA512", prime: "p521", p: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff"], a: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "fffffffc"], b: ["00000051 953eb961 8e1c9a1f 929a21a0", "b68540ee a2da725b 99b315f3 b8b48991", "8ef109e1 56193951 ec7e937b 1652c0bd", "3bb1bf07 3573df88 3d2c34f1 ef451fd4", "6b503f00"], n: ["000001ff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffff", "fffffffa 51868783 bf2f966b 7fcc0148", "f709a5d0 3bb5c9b8 899c47ae bb6fb71e", "91386409"], h: "1", z: "-4", g: [["000000c6 858e06b7 0404e9cd 9e3ecb66", "2395b442 9c648139 053fb521 f828af60", "6b4d3dba a14b5e77 efe75928 fe1dc127", "a2ffa8de 3348b3c1 856a429b f97e7e31", "c2e5bd66"], ["00000118 39296a78 9a3bc004 5c8a5fb4", "2c7d1bd9 98f54449 579b4468 17afbd17", "273e662c 97ee7299 5ef42640 c550b901", "3fad0761 353c7086 a272c240 88be9476", "9fd16650"], $] }); }
                    }, SECP256K1: class extends a {
                        constructor($) { super({ id: "SECP256K1", ossl: "secp256k1", type: "short", endian: "be", hash: "SHA256", prime: "k256", p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe fffffc2f"], a: "0", b: "7", n: ["ffffffff ffffffff ffffffff fffffffe", "baaedce6 af48a03b bfd25e8c d0364141"], h: "1", z: "1", c: ["0a2d2ba9 3507f1df 233770c2 a797962c", "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"], g: [["79be667e f9dcbbac 55a06295 ce870b07", "029bfcdb 2dce28d9 59f2815b 16f81798"], ["483ada77 26a3c465 5da4fbfc 0e1108a8", "fd17b448 a6855419 9c47d08f fb10d4b8"], $], endo: { beta: ["7ae96a2b 657c0710 6e64479e ac3434e9", "9cf04975 12f58995 c1396c28 719501ee"], lambda: ["5363ad4c c05c30e0 a5261c02 8812645a", "122e22ea 20816678 df02967c 1b23bd72"], basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], pre: ["3086d221a7d46bcde86c90e49284eb153dab", "-e4437ed6010e88286f547fa90abfe4c42212"] } }); }
                    }, BRAINPOOLP256: class extends a {
                        constructor($) { super({ id: "BRAINPOOLP256", ossl: "brainpoolP256r1", type: "short", endian: "be", hash: "SHA256", prime: null, p: ["a9fb57db a1eea9bc 3e660a90 9d838d72", "6e3bf623 d5262028 2013481d 1f6e5377"], a: ["7d5a0975 fc2c3057 eef67530 417affe7", "fb8055c1 26dc5c6c e94a4b44 f330b5d9"], b: ["26dc5c6c e94a4b44 f330b5d9 bbd77cbf", "95841629 5cf7e1ce 6bccdc18 ff8c07b6"], n: ["a9fb57db a1eea9bc 3e660a90 9d838d71", "8c397aa3 b561a6f7 901e0e82 974856a7"], h: "1", z: "-2", g: [["8bd2aeb9 cb7e57cb 2c4b482f fc81b7af", "b9de27e1 e3bd23c2 3a4453bd 9ace3262"], ["547ef835 c3dac4fd 97f8461a 14611dc9", "c2774513 2ded8e54 5c1d54c7 2f046997"], $] }); }
                    }, BRAINPOOLP384: class extends a {
                        constructor($) { super({ id: "BRAINPOOLP384", ossl: "brainpoolP384r1", type: "short", endian: "be", hash: "SHA384", prime: null, p: ["8cb91e82 a3386d28 0f5d6f7e 50e641df", "152f7109 ed5456b4 12b1da19 7fb71123", "acd3a729 901d1a71 87470013 3107ec53"], a: ["7bc382c6 3d8c150c 3c72080a ce05afa0", "c2bea28e 4fb22787 139165ef ba91f90f", "8aa5814a 503ad4eb 04a8c7dd 22ce2826"], b: ["04a8c7dd 22ce2826 8b39b554 16f0447c", "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5", "7cb43902 95dbc994 3ab78696 fa504c11"], n: ["8cb91e82 a3386d28 0f5d6f7e 50e641df", "152f7109 ed5456b3 1f166e6c ac0425a7", "cf3ab6af 6b7fc310 3b883202 e9046565"], h: "1", z: "-5", g: [["1d1c64f0 68cf45ff a2a63a81 b7c13f6b", "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8", "e826e034 36d646aa ef87b2e2 47d4af1e"], ["8abe1d75 20f9c2a4 5cb1eb8e 95cfd552", "62b70b29 feec5864 e19c054f f9912928", "0e464621 77918111 42820341 263c5315"], $] }); }
                    }, BRAINPOOLP512: class extends a {
                        constructor($) { super({ id: "BRAINPOOLP512", ossl: "brainpoolP512r1", type: "short", endian: "be", hash: "SHA512", prime: null, p: ["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07", "cb308db3 b3c9d20e d6639cca 70330871", "7d4d9b00 9bc66842 aecda12a e6a380e6", "2881ff2f 2d82c685 28aa6056 583a48f3"], a: ["7830a331 8b603b89 e2327145 ac234cc5", "94cbdd8d 3df91610 a83441ca ea9863bc", "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5", "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"], b: ["3df91610 a83441ca ea9863bc 2ded5d5a", "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7", "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67", "984050b7 5ebae5dd 2809bd63 8016f723"], n: ["aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07", "cb308db3 b3c9d20e d6639cca 70330870", "553e5c41 4ca92619 41866119 7fac1047", "1db1d381 085ddadd b5879682 9ca90069"], h: "1", z: "7", g: [["81aee4bd d82ed964 5a21322e 9c4c6a93", "85ed9f70 b5d916c1 b43b62ee f4d0098e", "ff3b1f78 e2d0d48d 50d1687b 93b97d5f", "7c6d5047 406a5e68 8b352209 bcb9f822"], ["7dde385d 566332ec c0eabfa9 cf7822fd", "f209f700 24a57b1a a000c55b 881f8111", "b2dcde49 4a5f485e 5bca4bd8 8a2763ae", "d1ca2b2f a8f05406 78cd1e0f 3ad80892"], $] }); }
                    }, X25519: class extends g {
                        constructor() { super({ id: "X25519", ossl: "X25519", type: "mont", endian: "le", hash: "SHA512", prime: "p25519", p: ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffed"], a: "76d06", b: "1", n: ["10000000 00000000 00000000 00000000", "14def9de a2f79cd6 5812631a 5cf5d3ed"], h: "8", z: "2", g: [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000009"], ["5f51e65e 475f794b 1fe122d3 88b72eb3", "6dc2b281 92839e4d d6163a5d 81312c14"]], torsion: [[], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"], ["6be4f497 f9a9c2af c21fa77a d7f4a6ef", "635a11c7 284a9363 e9a248ef 9c884415"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"], ["141b0b68 06563d50 3de05885 280b5910", "9ca5ee38 d7b56c9c 165db710 6377bbd8"]], [["57119fd0 dd4e22d8 868e1c58 c45c4404", "5bef839c 55b1d0b1 248c50a3 bc959c5f"], ["68c59389 3d458e64 31c6ca00 45fb5015", "20a44346 8eaa68dd 0f103842 048065b7"]], [["57119fd0 dd4e22d8 868e1c58 c45c4404", "5bef839c 55b1d0b1 248c50a3 bc959c5f"], ["173a6c76 c2ba719b ce3935ff ba04afea", "df5bbcb9 71559722 f0efc7bd fb7f9a36"]], [["00b8495f 16056286 fdb1329c eb8d09da", "6ac49ff1 fae35616 aeb8413b 7c7aebe0"], ["3931c129 569e83a5 29482c14 e628b457", "933bfc29 ed801b4d 68871483 92507b1a"]], [["00b8495f 16056286 fdb1329c eb8d09da", "6ac49ff1 fae35616 aeb8413b 7c7aebe0"], ["46ce3ed6 a9617c5a d6b7d3eb 19d74ba8", "6cc403d6 127fe4b2 9778eb7c 6daf84d3"]]] }); }
                    }, X448: class extends g {
                        constructor() { super({ id: "X448", ossl: "X448", type: "mont", endian: "le", hash: "SHAKE256", prime: "p448", p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"], a: "262a6", b: "1", n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"], h: "4", z: "-1", g: [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000005"], ["7d235d12 95f5b1f6 6c98ab6e 58326fce", "cbae5d34 f55545d0 60f75dc2 8df3f6ed", "b8027e23 46430d21 1312c4b1 50677af7", "6fd7223d 457b5b1a"]], torsion: [[], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["ba4d3a08 29b6112f 8812e51b a0bb2abe", "bc1cb08e b48e5569 36ba50fd d2e7d68a", "f8cb3216 0522425b 3f990812 abbe635a", "d37a21e1 7551b193"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["45b2c5f7 d649eed0 77ed1ae4 5f44d541", "43e34f71 4b71aa96 c945af01 2d182975", "0734cde9 faddbda4 c066f7ed 54419ca5", "2c85de1e 8aae4e6c"]]] }); }
                    }, MONT448: class extends g {
                        constructor() { super({ id: "MONT448", ossl: null, type: "mont", endian: "le", hash: "SHAKE256", prime: "p448", p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"], a: ["b2cf97d2 d43459a9 31ed36b1 fc4e3cb5", "5d93f8d2 22746997 60ccffc6 49961ed6", "c5b05fca c24864ed 6fb59697 931b78da", "84ddecd8 ca2b5cfb"], b: "1", n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"], h: "4", z: "-1", g: [["ac0d24cc c6c75cb0 eb71f81e 7a6edf51", "48e88aee 009a2a24 e795687e c28e125a", "3e6730a6 0d46367b aa7fe99d 152128dc", "41321bc7 7817f059"], ["5a4437f6 80c0d0db 9b061276 d5d0ffcc", "e786ff33 b6a53d30 98746425 82e66f09", "4433dae7 7244a6e2 6b11e905 7228f483", "556c41a5 913f55fe"]], torsion: [[], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["bec92fd0 6da2acf2 b4e261e8 7cef0d34", "22e75c18 3c589857 b71924e5 73c2f9ce", "e18da5f2 466e2f39 3c2eedf0 f105a60a", "b40c717d 4f1e1fd7"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["4136d02f 925d530d 4b1d9e17 8310f2cb", "dd18a3e7 c3a767a8 48e6db19 8c3d0631", "1e725a0d b991d0c6 c3d1120f 0efa59f5", "4bf38e82 b0e1e028"]]] }); }
                    }, ED25519: class extends v {
                        constructor($) { super({ id: "ED25519", ossl: "ED25519", type: "edwards", endian: "le", hash: "SHA512", prefix: "SigEd25519 no Ed25519 collisions", context: !1, prime: "p25519", p: ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffed"], a: "-1", d: ["52036cee 2b6ffe73 8cc74079 7779e898", "00700a4d 4141d8ab 75eb4dca 135978a3"], n: ["10000000 00000000 00000000 00000000", "14def9de a2f79cd6 5812631a 5cf5d3ed"], h: "8", z: "2", g: [["216936d3 cd6e53fe c0a4e231 fdd6dc5c", "692cc760 9525a7b2 c9562d60 8f25d51a"], ["66666666 66666666 66666666 66666666", "66666666 66666666 66666666 66666658"], $], torsion: [[["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000001"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"], ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff ffffffec"]], [["2b832480 4fc1df0b 2b4d0099 3dfbd7a7", "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]], [["547cdb7f b03e20f4 d4b2ff66 c2042858", "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000"]], [["1fd5b9a0 06394a28 e9339932 38de4abb", "5c193c70 13e5e238 dea14646 c545d14a"], ["05fc536d 880238b1 3933c6d3 05acdfd5", "f098eff2 89f4c345 b027b2c2 8f95e826"]], [["602a465f f9c6b5d7 16cc66cd c721b544", "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"], ["05fc536d 880238b1 3933c6d3 05acdfd5", "f098eff2 89f4c345 b027b2c2 8f95e826"]], [["1fd5b9a0 06394a28 e9339932 38de4abb", "5c193c70 13e5e238 dea14646 c545d14a"], ["7a03ac92 77fdc74e c6cc392c fa53202a", "0f67100d 760b3cba 4fd84d3d 706a17c7"]], [["602a465f f9c6b5d7 16cc66cd c721b544", "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"], ["7a03ac92 77fdc74e c6cc392c fa53202a", "0f67100d 760b3cba 4fd84d3d 706a17c7"]]] }); }
                    }, ISO448: class extends v {
                        constructor($) { super({ id: "ISO448", ossl: null, type: "edwards", endian: "le", hash: "SHAKE256", prefix: "SigEd448", context: !0, prime: "p448", p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"], a: "1", d: ["d78b4bdc 7f0daf19 f24f38c2 9373a2cc", "ad461572 42a50f37 809b1da3 412a12e7", "9ccc9c81 264cfe9a d0809970 58fb61c4", "243cc32d baa156b9"], n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"], h: "4", z: "-1", g: [["79a70b2b 70400553 ae7c9df4 16c792c6", "1128751a c9296924 0c25a07d 728bdc93", "e21f7787 ed697224 9de732f3 8496cd11", "69871309 3e9c04fc"], ["7fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 80000000", "00000000 00000000 00000000 00000000", "00000000 00000001"], $], torsion: [[["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]]] }); }
                    }, ED448: class extends v {
                        constructor($) { super({ id: "ED448", ossl: "ED448", type: "edwards", endian: "le", hash: "SHAKE256", prefix: "SigEd448", context: !0, prime: "p448", p: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff"], a: "1", d: ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff ffff6756"], n: ["3fffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff ffffffff 7cca23e9", "c44edb49 aed63690 216cc272 8dc58f55", "2378c292 ab5844f3"], h: "4", z: "-1", g: [["4f1970c6 6bed0ded 221d15a6 22bf36da", "9e146570 470f1767 ea6de324 a3d3a464", "12ae1af7 2ab66511 433b80e1 8b00938e", "2626a82b c70cc05e"], ["693f4671 6eb6bc24 88762037 56c9c762", "4bea7373 6ca39840 87789c1e 05a0c2d7", "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad", "9808795b f230fa14"], $], torsion: [[["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"], ["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"]], [["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000001"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]], [["ffffffff ffffffff ffffffff ffffffff", "ffffffff ffffffff fffffffe ffffffff", "ffffffff ffffffff ffffffff ffffffff", "ffffffff fffffffe"], ["00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000 00000000 00000000", "00000000 00000000"]]] }); }
                    } }, P = { __proto__: null, P192: null, P224: null, P256: null, P384: null, P521: null, SECP256K1: null, BRAINPOOLP256: null, BRAINPOOLP384: null, BRAINPOOLP512: null, X25519: null, X448: null, MONT448: null, ED25519: null, ISO448: null, ED448: null }; function L($, y, C) { D($ instanceof e), D(!$.red), D(y >>> 0 === y), D(C >>> 0 === C); const A = new Array(C), U = $.bitLength() + 1, z = 1 | $.sign(); D(U <= C); for (let H = 0; H < C; H++)
                    A[H] = 0; let w, O = 0, q = 0; for (; O < U;)
                    $.bit(O) !== q ? (w = $.bits(O, y) + q, q = w >> y - 1 & 1, w -= q << y, A[O] = z * w, O += y) : O += 1; return D(q === 0), A; } function j($, y, C) { const A = function (z, w, O) { D(z instanceof e), D(w instanceof e), D(!z.red), D(!w.red), D(O >>> 0 === O); const q = [new Array(O), new Array(O)], H = Math.max(z.bitLength(), w.bitLength()) + 1, V = 1 | z.sign(), J = 1 | w.sign(); D(H <= O); let Z = 0, tt = 0; for (let nt = 0; nt < H; nt++) {
                    const rt = z.bits(nt, 3), it = w.bits(nt, 3);
                    let st = (3 & rt) + Z & 3, at = (3 & it) + tt & 3, ct = 0, lt = 0;
                    if (st === 3 && (st = -1), at === 3 && (at = -1), 1 & st) {
                        const pt = (7 & rt) + Z & 7;
                        ct = pt !== 3 && pt !== 5 || at !== 2 ? st : -st;
                    }
                    if (1 & at) {
                        const pt = (7 & it) + tt & 7;
                        lt = pt !== 3 && pt !== 5 || st !== 2 ? at : -at;
                    }
                    q[0][nt] = ct * V, q[1][nt] = lt * J, 2 * Z === ct + 1 && (Z = 1 - Z), 2 * tt === lt + 1 && (tt = 1 - tt);
                } for (let nt = H; nt < O; nt++)
                    q[0][nt] = 0, q[1][nt] = 0; return q; }($, y, C), U = new Array(C); for (let z = 0; z < C; z++) {
                    const w = A[0][z], O = A[1][z];
                    U[z] = u[3 * (w + 1) + (O + 1)];
                } return U; } function D($, y) { if (!$) {
                    const C = new Error(y || "Assertion failed");
                    throw Error.captureStackTrace && Error.captureStackTrace(C, D), C;
                } } function G($) { D($ instanceof e); try {
                    return [1, $.redSqrt()];
                }
                catch (y) {
                    if (y.message === "X is not a square mod P.")
                        return [0, $.clone()];
                    throw y;
                } } function W($, y) { D($ instanceof e), D(y instanceof e); try {
                    return [1, $.redDivSqrt(y)];
                }
                catch (C) {
                    if (C.message === "Not invertible." || C.message === "X is not a square mod P.")
                        return [0, $.clone()];
                    throw C;
                } } function X($) { const y = function (C) { D(C instanceof e), D(C.red); const A = C.red.m; if (A.cmpn(3) <= 0)
                    return C.clone(); if (A.modrn(3) === 2) {
                    const z = A.ushln(1).isubn(1).idivn(3);
                    return C.redPow(z);
                } const U = A.modrn(9); if (U === 4) {
                    const z = A.ushln(1).iaddn(1).idivn(9), w = C.redPow(z);
                    if (!w.redSqr().redMul(w).eq(C))
                        throw new Error("X is not a cube mod P.");
                    return w;
                } if (U === 7) {
                    const z = A.addn(2).idivn(9), w = C.redPow(z);
                    if (!w.redSqr().redMul(w).eq(C))
                        throw new Error("X is not a cube mod P.");
                    return w;
                } throw new Error("Not implemented."); }($); if ($.red.m.modrn(3) === 1) {
                    const C = new e(2).toRed($.red), A = new e(3).toRed($.red), U = C.redInvert(), z = A.redNeg().redSqrt().redMul(U), w = z.redNeg(), O = z.redSub(U), q = w.redSub(U), H = y.redMul(O), V = y.redMul(q);
                    return [y, H, V];
                } return [y]; } function Q($) { for (const y of X($))
                    if (y.redJacobi() >= 0)
                        return y; throw new Error("X^(1/3) is not a square mod P."); } function K($) { return e.randomBits($, 32).toNumber(); } function F($, y) { const C = new WeakMap; return function (A, U) { const z = 1 & U, w = C.get(A); if (w && w[z] !== null)
                    return w[z]; const O = $.call(y, A, U); return C.has(A) || C.set(A, [null, null]), C.get(A)[z] = O, O; }; } function Y($, y) { D($ instanceof e), D(y >>> 0 === y), 7 & y && (y += 8 - (7 & y)); const C = $.toString(16, y), A = [], U = []; D((7 & C.length) == 0); for (let z = 0; z < C.length; z += 8)
                    A.push(C.slice(z, z + 8)); for (let z = 0; z < A.length; z += 4)
                    U.push(A.slice(z, z + 4).join(" ")); return U; } m.Curve = o, m.Point = h, m.ShortCurve = a, m.ShortPoint = l, m.JPoint = p, m.MontCurve = g, m.MontPoint = b, m.XPoint = I, m.EdwardsCurve = v, m.EdwardsPoint = R, m.curves = B, m.curve = function ($, ...y) { D(typeof $ == "string"); const C = $.toUpperCase(); let A = P[C]; if (!A) {
                    const U = B[C];
                    if (!U)
                        throw new Error(`Curve not found: "${$}".`);
                    A = new U(...y), P[C] = A;
                } return A; }, m.register = function ($, y) { D(typeof $ == "string"), D(typeof y == "function"); const C = $.toUpperCase(); if (B[C])
                    throw new Error(`Curve already registered: "${$}".`); B[C] = y, P[C] = null; }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(1e3);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const { custom: r } = f(382), e = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], c = [0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], n = [0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176], t = { p192: null, p224: null, p521: null, k256: null, p251: null, p25519: null, p448: null }, s = 0, u = 1, i = 2, o = 3, h = 4, a = 7, l = typeof BigInt == "function"; class p {
                    constructor(w, O, q) { this.words = [0], this.length = 1, this.negative = 0, this.red = null, this.from(w, O, q); }
                    _iadd(w, O) { let q = 0, H = 0; for (w.length < O.length && ([w, O] = [O, w]), w !== this && this._alloc(w.length); H < O.length; H++) {
                        const V = (0 | w.words[H]) + (0 | O.words[H]) + q;
                        this.words[H] = 67108863 & V, q = V >>> 26;
                    } for (; q !== 0 && H < w.length; H++) {
                        const V = (0 | w.words[H]) + q;
                        this.words[H] = 67108863 & V, q = V >>> 26;
                    } if (this.length = w.length, q !== 0)
                        this._alloc(this.length + 1), this.words[this.length++] = q;
                    else if (w !== this)
                        for (; H < w.length; H++)
                            this.words[H] = w.words[H]; return this; }
                    _iaddn(w) { if (this.words[0] += w, this.words[0] < 67108864)
                        return this; let O = 0; for (this._alloc(this.length + 1), this.words[this.length] = 0; O < this.length && this.words[O] >= 67108864; O++)
                        this.words[O] -= 67108864, this.words[O + 1] += 1; return this.length = Math.max(this.length, O + 1), this; }
                    iadd(w) { if (P(p.isBN(w), "num", "bignum"), this.negative === w.negative)
                        this._iadd(this, w);
                    else {
                        const O = this.ucmp(w);
                        if (O === 0)
                            return this.words[0] = 0, this.length = 1, this.negative = 0, this;
                        O < 0 ? (this._isub(w, this), this.negative ^= 1) : this._isub(this, w);
                    } return this; }
                    iaddn(w) { P(X(w), "num", "smi"); const O = w < 0 | 0; return O && (w = -w), this.negative === O ? this._iaddn(w) : this.length === 1 && this.words[0] < w ? (this.words[0] = w - this.words[0], this.negative ^= 1) : this._isubn(w), this; }
                    add(w) { return P(p.isBN(w), "num", "bignum"), w.length > this.length ? w.clone().iadd(this) : this.clone().iadd(w); }
                    addn(w) { return this.clone().iaddn(w); }
                    _isub(w, O) { let q = 0, H = 0; for (B(w.length >= O.length), w !== this && this._alloc(w.length); H < O.length; H++) {
                        const V = (0 | w.words[H]) - (0 | O.words[H]) + q;
                        q = V >> 26, this.words[H] = 67108863 & V;
                    } for (; q !== 0 && H < w.length; H++) {
                        const V = (0 | w.words[H]) + q;
                        q = V >> 26, this.words[H] = 67108863 & V;
                    } if (B(q === 0), w !== this)
                        for (; H < w.length; H++)
                            this.words[H] = w.words[H]; return this.length = Math.max(this.length, H), this._strip(); }
                    _isubn(w) { if (this.words[0] -= w, this.words[0] >= 0)
                        return this._normalize(); B(this.length !== 1), this._alloc(this.length + 1); for (let O = 0; O < this.length && this.words[O] < 0; O++)
                        this.words[O] += 67108864, this.words[O + 1] -= 1; return this.words[this.length] = 0, this._strip(); }
                    isub(w) { if (P(p.isBN(w), "num", "bignum"), this.negative !== w.negative)
                        this._iadd(this, w);
                    else {
                        const O = this.ucmp(w);
                        if (O === 0)
                            return this.words[0] = 0, this.length = 1, this.negative = 0, this;
                        O < 0 ? (this._isub(w, this), this.negative ^= 1) : this._isub(this, w);
                    } return this; }
                    isubn(w) { P(X(w), "num", "smi"); const O = w < 0 | 0; return O && (w = -w), this.negative !== O ? this._iaddn(w) : this.length === 1 && this.words[0] < w ? (this.words[0] = w - this.words[0], this.negative ^= 1) : this._isubn(w), this; }
                    sub(w) { return this.clone().isub(w); }
                    subn(w) { return this.clone().isubn(w); }
                    _mul(w, O) { if (P(p.isBN(w), "num", "bignum"), P(p.isBN(O), "out", "bignum"), this.length === 10 && w.length === 10)
                        return U(this, w, O); const q = this.length + w.length; return q < 63 ? C(this, w, O) : q < 1024 ? A(this, w, O) : function (H, V, J) { if (!l || H.length + V.length > 82595519)
                        return A(H, V, J); const Z = BigInt(0), tt = BigInt(67108863), nt = BigInt(26); let rt = H.toBigInt() * V.toBigInt(); const it = rt < Z | 0; it && (rt = -rt); let st = 0; for (; rt > Z;)
                        J.words[st++] = Number(rt & tt), rt >>= nt; return st === 0 && (J.words[st++] = 0), J.length = st, J.negative = it, J; }(this, w, O); }
                    imul(w) { return this.mul(w)._move(this); }
                    imuln(w) { P(X(w), "num", "smi"); const O = w < 0 | 0; O && (w = -w); let q = 0; for (let H = 0; H < this.length; H++) {
                        const V = this.words[H] * w, J = (67108863 & V) + (67108863 & q);
                        q >>= 26, q += V / 67108864 | 0, q += J >>> 26, this.words[H] = 67108863 & J;
                    } return this.negative ^= O, q !== 0 ? (this._alloc(this.length + 1), this.words[this.length++] = q) : this._strip(), this; }
                    mul(w) { P(p.isBN(w), "num", "bignum"); const O = this.length + w.length, q = new p; q.words = new Array(O); for (let H = 0; H < O; H++)
                        q.words[H] = 0; return this._mul(w, q); }
                    muln(w) { return this.clone().imuln(w); }
                    mulShift(w, O) { P(p.isBN(w), "num", "bignum"), P(O >>> 0 === O, "bits", "uint32"); const q = this.mul(w), H = q.utestn(O - 1); return q.iushrn(O), this.negative ^ w.negative ? q.isubn(H) : q.iaddn(H); }
                    _div(w, O) { P(p.isBN(w), "num", "bignum"), B((O & a) === O), B(O !== s); const q = this, H = w; if (G(!H.isZero()), q.isZero())
                        return [new p(0), new p(0)]; const V = q.negative, J = H.negative; q.negative = 0, H.negative = 0; let Z = null, tt = null; return q.ucmp(H) < 0 ? (O & u && (Z = new p(0)), O & i && (tt = q.clone())) : H.length === 1 ? (O & u && (Z = q.quon(H.words[0])), O & i && (tt = q.remn(H.words[0]))) : [Z, tt] = q._wordDiv(H, O), q.negative = V, H.negative = J, O & u && (Z.negative = q.negative ^ H.negative, Z._normalize()), O & i && (tt.negative = q.negative, tt._normalize()), O & h && (O & u && (B((O & i) != 0), tt.negative !== 0 && (H.negative !== 0 ? Z.iaddn(1) : Z.isubn(1))), O & i && tt.negative !== 0 && (H.negative !== 0 ? tt.isub(H) : tt.iadd(H))), [Z, tt]; }
                    _wordDiv(w, O) { let q, H = this.clone(), V = w, J = null; const Z = 0 | V.words[V.length - 1], tt = 26 - K(Z); tt !== 0 ? (V = V.clone(), H.iushln(tt), V.iushln(tt), q = 0 | V.words[V.length - 1]) : q = Z; const nt = H.length - V.length; if (B(nt >= 0), O & u) {
                        J = new p(0), J.length = nt + 1, J.words = new Array(J.length);
                        for (let it = 0; it < J.length; it++)
                            J.words[it] = 0;
                    } const rt = H.clone(); rt._ishlnsubmul(V, 1, nt), rt.negative === 0 && (J && (J.words[nt] = 1), H = rt); for (let it = nt - 1; it >= 0; it--) {
                        const st = (67108864 * H.words[V.length + it] + H.words[V.length + it - 1]) / q | 0;
                        let at = Math.min(st, 67108863);
                        for (H._ishlnsubmul(V, at, it); H.negative !== 0;)
                            at -= 1, H.negative = 0, H._ishlnsubmul(V, 1, it), H.ineg();
                        J && (J.words[it] = at);
                    } return J && J._strip(), O & i && tt !== 0 && H.iushrn(tt), [J, H]; }
                    _ishlnsubmul(w, O, q) { let H = 0, V = 0; for (this._expand(w.length + q); V < w.length; V++) {
                        const J = (0 | this.words[V + q]) + H, Z = w.words[V] * O, tt = J - (67108863 & Z);
                        H = (tt >> 26) - (Z / 67108864 | 0), this.words[V + q] = 67108863 & tt;
                    } for (; V < this.length - q; V++) {
                        const J = (0 | this.words[V + q]) + H;
                        H = J >> 26, this.words[V + q] = 67108863 & J;
                    } if (H === 0)
                        return this._strip(); B(H === -1), H = 0; for (let J = 0; J < this.length; J++) {
                        const Z = -(0 | this.words[J]) + H;
                        H = Z >> 26, this.words[J] = 67108863 & Z;
                    } return this.negative = 1, this._strip(); }
                    quorem(w) { return this._div(w, o); }
                    iquo(w) { return this.quo(w)._move(this); }
                    iquon(w) { P(X(w), "num", "smi"), G(w !== 0); const O = w < 0 | 0; O && (w = -w); let q = 0; for (let H = this.length - 1; H >= 0; H--) {
                        const V = (0 | this.words[H]) + 67108864 * q;
                        this.words[H] = V / w | 0, q = V % w;
                    } return this.negative ^= O, this._strip(); }
                    quo(w) { return this._div(w, u)[0]; }
                    quon(w) { return this.clone().iquon(w); }
                    irem(w) { return this.rem(w)._move(this); }
                    iremn(w) { let O = this.remrn(w); return O < 0 && (O = -O), this.words[0] = O, this.length = 1, this._normalize(); }
                    rem(w) { return this._div(w, i)[1]; }
                    remn(w) { return this.clone().iremn(w); }
                    remrn(w) { P(X(w), "num", "smi"), G(w !== 0), w < 0 && (w = -w); const O = (1 << 26) % w; let q = 0; for (let H = this.length - 1; H >= 0; H--)
                        q = (O * q + (0 | this.words[H])) % w; return this.negative !== 0 ? 0 | -q : q; }
                    divmod(w) { return this._div(w, o | h); }
                    idiv(w) { return this.div(w)._move(this); }
                    idivn(w) { if (this.negative === 0)
                        return this.iquon(w); const O = this.remrn(w); return this.iquon(w), O < 0 && (w < 0 ? this.iaddn(1) : this.isubn(1)), this; }
                    div(w) { return this._div(w, o | h)[0]; }
                    divn(w) { return this.clone().idivn(w); }
                    imod(w) { return this.ucmp(w) < 0 ? (this.negative !== 0 && (this._isub(w, this), this.negative = 0), this) : this.mod(w)._move(this); }
                    imodn(w) { return this.words[0] = this.modrn(w), this.length = 1, this.negative = 0, this; }
                    mod(w) { return this._div(w, i | h)[1]; }
                    modn(w) { return this.clone().imodn(w); }
                    modrn(w) { P(X(w), "num", "smi"); let O = this.remrn(w); return O < 0 && (w < 0 ? O -= w : O += w), O; }
                    divRound(w) { const [O, q] = this.quorem(w); if (q.isZero())
                        return O; const H = 1 & w.words[0]; w.iushrn(1); const V = q.ucmp(w); return w.iushln(1), w.words[0] |= H, V < 0 || w.isOdd() && V === 0 ? O : this.negative ^ w.negative ? O.isubn(1) : O.iaddn(1); }
                    ipow(w) { return this.pow(w)._move(this); }
                    ipown(w) { return this.pown(w)._move(this); }
                    pow(w) { P(p.isBN(w), "num", "bignum"); let O = K(w.words[w.length - 1]), q = new p(1); for (let H = w.length - 1; H >= 0; H--) {
                        const V = w.words[H];
                        for (let J = O - 1; J >= 0; J--)
                            q = q.sqr(), V >> J & 1 && (q = q.mul(this));
                        O = 26;
                    } return q; }
                    pown(w) { if (P(X(w), "num", "smi"), w < 0 && (w = -w), w === 0)
                        return new p(1); if (w === 1)
                        return this.clone(); let O = this; for (let q = K(w) - 2; q >= 0; q--)
                        O = O.sqr(), w >> q & 1 && (O = O.mul(this)); return O; }
                    isqr() { return this.imul(this); }
                    sqr() { return this.mul(this); }
                    _rootrem(w, O) { if (P(w >>> 0 === w, "num", "uint32"), w === 0)
                        throw new RangeError("Zeroth root."); if (~w & this.negative)
                        throw new RangeError("Negative with even root."); if (this.ucmpn(1) <= 0)
                        return [this.clone(), new p(0)]; let q, H, V = new p(0), J = p.shift(1, this.bitLength() / w + 1 | 0); if (this.negative !== 0 && J.ineg(), w === 2)
                        do
                            V = J, J = this.quo(V), J.iadd(V), J.iushrn(1);
                        while (J.ucmp(V) < 0);
                    else
                        do
                            V = J, J = V.pown(w - 1), J = this.quo(J), q = V.muln(w - 1), J.iadd(q), J = J.quon(w);
                        while (J.ucmp(V) < 0); return O && (J = V.pown(w), H = this.sub(J)), [V, H]; }
                    rootrem(w) { return this._rootrem(w, 1); }
                    iroot(w) { return this.root(w)._move(this); }
                    root(w) { return this._rootrem(w, 0)[0]; }
                    isPower(w) { if (P(w >>> 0 === w, "num", "uint32"), w === 0 || ~w & this.negative)
                        return !1; const [, O] = this.rootrem(w); return O.sign() === 0; }
                    sqrtrem() { return this.rootrem(2); }
                    isqrt() { return this.sqrt()._move(this); }
                    sqrt() { return this.root(2); }
                    isSquare() { return this.isPower(2); }
                    iand(w) { P(p.isBN(w), "num", "bignum"); let O = this, q = w; if (O === q)
                        return O; if ((O.negative | q.negative) == 0)
                        return O.iuand(q); if ((O.negative & q.negative) == 1)
                        return O.iaddn(1), q.iaddn(1), O.iuor(q), O.isubn(1), q.isubn(1), O; O.negative !== 0 && ([O, q] = [q.clone(), O]); const H = O.bitLength(); return q.iaddn(1), q.inotn(H), O.iuand(q), q.inotn(H), q.isubn(1), O._move(this); }
                    iandn(w) { return P(X(w), "num", "smi"), (this.negative | w < 0) != 0 ? this.iand(new p(w)) : (this.words[0] &= w, this.length = 1, this); }
                    and(w) { return this.clone().iand(w); }
                    andn(w) { return this.clone().iandn(w); }
                    andrn(w) { if (P(X(w), "num", "smi"), (this.negative | w < 0) != 0) {
                        const O = this.iand(new p(w));
                        if (O.length > 1)
                            throw new RangeError("Number exceeds 26 bits.");
                        return O.negative !== 0 ? -O.words[0] : O.words[0];
                    } return this.words[0] & w; }
                    iuand(w) { P(p.isBN(w), "num", "bignum"), this.length = Math.min(this.length, w.length); for (let O = 0; O < this.length; O++)
                        this.words[O] &= w.words[O]; return this._strip(); }
                    iuandn(w) { return P(X(w), "num", "smi"), this.words[0] &= Math.abs(w), this.length = 1, this._normalize(); }
                    uand(w) { return this.clone().iuand(w); }
                    uandn(w) { return this.clone().iuandn(w); }
                    uandrn(w) { P(X(w), "num", "smi"); const O = this.words[0] & Math.abs(w); return this.negative !== 0 ? 0 | -O : O; }
                    ior(w) { P(p.isBN(w), "num", "bignum"); let O = this, q = w; return O === q ? O : (O.negative | q.negative) == 0 ? O.iuor(q) : (O.negative & q.negative) == 1 ? (O.iaddn(1), q.iaddn(1), O.iuand(q), O.isubn(1), q.isubn(1), O) : (q = q.clone(), O.negative !== 0 && ([O, q] = [q, O]), q.iaddn(1), O.inotn(q.bitLength()), q.iuand(O), q.isubn(1), q._move(this)); }
                    iorn(w) { return P(X(w), "num", "smi"), (this.negative | w < 0) != 0 ? this.ior(new p(w)) : (this.words[0] |= w, this); }
                    or(w) { return this.clone().ior(w); }
                    orn(w) { return this.clone().iorn(w); }
                    iuor(w) { P(p.isBN(w), "num", "bignum"), this._expand(w.length); for (let O = 0; O < w.length; O++)
                        this.words[O] |= w.words[O]; return this; }
                    iuorn(w) { return P(X(w), "num", "smi"), this.words[0] |= Math.abs(w), this; }
                    uor(w) { return this.clone().iuor(w); }
                    uorn(w) { return this.clone().iuorn(w); }
                    ixor(w) { P(p.isBN(w), "num", "bignum"); let O = this, q = w; return O === q ? (O.words[0] = 0, O.length = 1, O.negative = 0, O) : (O.negative | q.negative) == 0 ? O.iuxor(q) : (O.negative & q.negative) == 1 ? (O.iaddn(1), q.iaddn(1), O.iuxor(q), O.ineg(), q.isubn(1), O) : (O.negative !== 0 && ([O, q] = [q.clone(), O]), q.iaddn(1), O.iuxor(q), O.iaddn(1), O.ineg(), q.isubn(1), O._move(this)); }
                    ixorn(w) { return P(X(w), "num", "smi"), (this.negative | w < 0) != 0 ? this.ixor(new p(w)) : (this.words[0] ^= w, this); }
                    xor(w) { return this.clone().ixor(w); }
                    xorn(w) { return this.clone().ixorn(w); }
                    iuxor(w) { P(p.isBN(w), "num", "bignum"); let O = this, q = w; O.length < q.length && ([O, q] = [q, O]); let H = 0; for (; H < q.length; H++)
                        this.words[H] = O.words[H] ^ q.words[H]; if (O !== this)
                        for (this._alloc(O.length); H < O.length; H++)
                            this.words[H] = O.words[H]; return this.length = O.length, this._strip(); }
                    iuxorn(w) { return P(X(w), "num", "smi"), this.words[0] ^= Math.abs(w), this._normalize(); }
                    uxor(w) { return this.clone().iuxor(w); }
                    uxorn(w) { return this.clone().iuxorn(w); }
                    inot() { return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this; }
                    not() { return this.clone().inot(); }
                    inotn(w) { P(w >>> 0 === w, "width", "uint32"); const O = w % 26; let q = Math.ceil(w / 26), H = 0; for (this._expand(q), O > 0 && (q -= 1); H < q; H++)
                        this.words[H] ^= 67108863; return O > 0 && (this.words[H] ^= (1 << O) - 1), this._strip(); }
                    notn(w) { return this.clone().inotn(w); }
                    ishl(w) { return P(p.isBN(w), "bits", "bignum"), P(w.bitLength() <= 32, "bits", "uint32"), this.ishln(w.toNumber()); }
                    ishln(w) { return this.iushln(w); }
                    shl(w) { return this.clone().ishl(w); }
                    shln(w) { return this.clone().ishln(w); }
                    iushl(w) { return P(p.isBN(w), "bits", "bignum"), P(w.bitLength() <= 32, "bits", "uint32"), this.iushln(w.toNumber()); }
                    iushln(w) { P(w >>> 0 === w, "bits", "uint32"); const O = w % 26, q = (w - O) / 26, H = (1 << O) - 1 << 26 - O; if (O !== 0) {
                        let V = 0;
                        for (let J = 0; J < this.length; J++) {
                            const Z = this.words[J] & H, tt = (0 | this.words[J]) - Z << O;
                            this.words[J] = tt | V, V = Z >>> 26 - O;
                        }
                        V !== 0 && (this._alloc(this.length + 1), this.words[this.length++] = V);
                    } if (q !== 0) {
                        this._alloc(this.length + q);
                        for (let V = this.length - 1; V >= 0; V--)
                            this.words[V + q] = this.words[V];
                        for (let V = 0; V < q; V++)
                            this.words[V] = 0;
                        this.length += q;
                    } return this._strip(); }
                    ushl(w) { return this.clone().iushl(w); }
                    ushln(w) { return this.clone().iushln(w); }
                    _split(w, O) { const q = w % 26, H = Math.min((w - q) / 26, this.length), V = (1 << q) - 1; if (O) {
                        O._alloc(H);
                        for (let Z = 0; Z < H; Z++)
                            O.words[Z] = this.words[Z];
                        O.length = H;
                    } if (!(H === 0))
                        if (this.length > H) {
                            this.length -= H;
                            for (let Z = 0; Z < this.length; Z++)
                                this.words[Z] = this.words[Z + H];
                        }
                        else
                            this.words[0] = 0, this.length = 1; let J = 0; if (q !== 0)
                        for (let Z = this.length - 1; Z >= 0; Z--) {
                            const tt = 0 | this.words[Z];
                            this.words[Z] = J << 26 - q | tt >>> q, J = tt & V;
                        } return O && (J !== 0 ? (O._alloc(O.length + 1), O.words[O.length++] = J) : (O.length === 0 && (O.words[O.length++] = 0), O._strip())), this._strip(); }
                    ishr(w) { return P(p.isBN(w), "bits", "bignum"), P(w.bitLength() <= 32, "bits", "uint32"), this.ishrn(w.toNumber()); }
                    ishrn(w) { return P(w >>> 0 === w, "bits", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.iushrn(w), this.isubn(1), this) : this.iushrn(w); }
                    shr(w) { return this.clone().ishr(w); }
                    shrn(w) { return this.clone().ishrn(w); }
                    iushr(w) { return P(p.isBN(w), "bits", "bignum"), P(w.bitLength() <= 32, "bits", "uint32"), this.iushrn(w.toNumber()); }
                    iushrn(w) { return P(w >>> 0 === w, "bits", "uint32"), this._split(w, null); }
                    ushr(w) { return this.clone().iushr(w); }
                    ushrn(w) { return this.clone().iushrn(w); }
                    setn(w, O) { return P(w >>> 0 === w, "bit", "uint32"), this.negative !== 0 ? (this.iaddn(1), this.usetn(w, !O), this.isubn(1), this) : this.usetn(w, O); }
                    usetn(w, O) { P(w >>> 0 === w, "bit", "uint32"); const q = w % 26, H = (w - q) / 26; return this._expand(H + 1), O ? this.words[H] |= 1 << q : this.words[H] &= ~(1 << q), this._strip(); }
                    testn(w) { P(w >>> 0 === w, "bit", "uint32"); const O = w % 26, q = (w - O) / 26; if (this.length <= q)
                        return this.negative; const H = this.words[q], V = H >> O & 1; if (this.negative !== 0) {
                        if (O > 0 && H & (1 << O) - 1)
                            return 1 ^ V;
                        let J = q;
                        for (; J--;)
                            if (this.words[J] > 0)
                                return 1 ^ V;
                    } return V; }
                    utestn(w) { P(w >>> 0 === w, "bit", "uint32"); const O = w % 26, q = (w - O) / 26; return this.length <= q ? 0 : this.words[q] >> O & 1; }
                    imaskn(w) { return P(w >>> 0 === w, "bits", "uint32"), this.negative !== 0 && (this.iaddn(1), this.inotn(w + 1), this.ineg()), this.iumaskn(w); }
                    maskn(w) { return this.clone().imaskn(w); }
                    iumaskn(w) { P(w >>> 0 === w, "bits", "uint32"); const O = w % 26; let q = (w - O) / 26; return this.length <= q ? this : (O !== 0 && (q += 1), this.length = Math.min(q, this.length), O !== 0 && (this.words[this.length - 1] &= (1 << O) - 1), this.length === 0 && (this.words[this.length++] = 0), this._strip()); }
                    umaskn(w) { return this.clone().iumaskn(w); }
                    andln(w) { return this.words[0] & w; }
                    bit(w) { return this.utestn(w); }
                    bits(w, O) { P(w >>> 0 === w, "pos", "uint32"), P(O >>> 0 === O, "width", "uint32"), P(O <= 26, "width", "width"); const q = w % 26, H = (w - q) / 26; if (H >= this.length)
                        return 0; let V = this.words[H] >> q & (1 << O) - 1; if (q + O > 26 && H + 1 < this.length) {
                        const J = q + O - 26;
                        V |= (this.words[H + 1] & (1 << J) - 1) << 26 - q;
                    } return V; }
                    ineg() { return this.isZero() || (this.negative ^= 1), this; }
                    neg() { return this.clone().ineg(); }
                    iabs() { return this.negative = 0, this; }
                    abs() { return this.clone().iabs(); }
                    cmp(w) { if (P(p.isBN(w), "num", "bignum"), this.negative !== w.negative)
                        return w.negative - this.negative; const O = this.ucmp(w); return this.negative !== 0 ? 0 | -O : O; }
                    cmpn(w) { P(X(w), "num", "smi"); const O = w < 0 | 0; if (this.negative !== O)
                        return O - this.negative; const q = this.ucmpn(w); return this.negative !== 0 ? 0 | -q : q; }
                    eq(w) { return this.cmp(w) === 0; }
                    eqn(w) { return this.cmpn(w) === 0; }
                    gt(w) { return this.cmp(w) > 0; }
                    gtn(w) { return this.cmpn(w) > 0; }
                    gte(w) { return this.cmp(w) >= 0; }
                    gten(w) { return this.cmpn(w) >= 0; }
                    lt(w) { return this.cmp(w) < 0; }
                    ltn(w) { return this.cmpn(w) < 0; }
                    lte(w) { return this.cmp(w) <= 0; }
                    lten(w) { return this.cmpn(w) <= 0; }
                    sign() { return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1; }
                    isZero() { return this.length === 1 && this.words[0] === 0; }
                    isNeg() { return this.negative !== 0; }
                    isPos() { return this.negative === 0; }
                    isOdd() { return (1 & this.words[0]) == 1; }
                    isEven() { return (1 & this.words[0]) == 0; }
                    ucmp(w) { if (P(p.isBN(w), "num", "bignum"), this.length < w.length)
                        return -1; if (this.length > w.length)
                        return 1; for (let O = this.length - 1; O >= 0; O--) {
                        const q = 0 | this.words[O], H = 0 | w.words[O];
                        if (q !== H)
                            return (q > H) - (q < H);
                    } return 0; }
                    ucmpn(w) { if (P(X(w), "num", "smi"), this.length > 1)
                        return 1; const O = 0 | this.words[0]; return w < 0 && (w = -w), (O > w) - (O < w); }
                    legendre(w) { const O = l ? p.red(w) : p.mont(w); return this.toRed(O).redLegendre(); }
                    jacobi(w) { if (P(p.isBN(w), "num", "bignum"), w.isZero() || w.isEven())
                        throw new Error("jacobi: `num` must be odd."); let O = this._cloneNormal(), q = w.clone(), H = 1; for (q.isNeg() && (O.isNeg() && (H = -1), q.ineg()), (O.isNeg() || O.ucmp(q) >= 0) && O.imod(q); !O.isZero();) {
                        if (1 & O._makeOdd()) {
                            const J = q.andln(7);
                            J !== 3 && J !== 5 || (H = -H);
                        }
                        O.ucmp(q) < 0 && ([O, q] = [q, O], O.andln(3) === 3 && q.andln(3) === 3 && (H = -H)), O._isub(O, q).iushrn(1);
                        const V = q.andln(7);
                        V !== 3 && V !== 5 || (H = -H);
                    } return q.cmpn(1) !== 0 ? 0 : H; }
                    kronecker(w) { P(p.isBN(w), "num", "bignum"); const O = [0, 1, 0, -1, 0, -1, 0, 1]; let q = this._cloneNormal(), H = w.clone(), V = 1; if (H.isZero())
                        return q.ucmpn(1) === 0 ? V : 0; if (!q.isOdd() && !H.isOdd())
                        return 0; for (1 & H._makeOdd() && (V = O[q.andln(7)]), H.isNeg() && (q.isNeg() && (V = -V), H.ineg()); !q.isZero();)
                        1 & q._makeOdd() && (V *= O[H.andln(7)]), (q.words[0] ^ 67108863 * q.negative) & H.words[0] & 2 && (V = -V), H.imod(q), [q, H] = [H, q], H.negative = 0; return H.cmpn(1) !== 0 ? 0 : V; }
                    igcd(w) { return this.gcd(w)._move(this); }
                    gcd(w) { if (P(p.isBN(w), "num", "bignum"), this.isZero())
                        return w.abs(); if (w.isZero())
                        return this.abs(); let O = this.clone(), q = w.clone(); O.negative = 0, q.negative = 0; const H = O._factor2(q); for (H !== 0 && (O.iushrn(H), q.iushrn(H));;) {
                        O._makeOdd(), q._makeOdd();
                        const V = O.ucmp(q);
                        if (V < 0)
                            [O, q] = [q, O];
                        else if (V === 0 || q.ucmpn(1) === 0)
                            break;
                        O._isub(O, q);
                    } return q.iushln(H); }
                    ilcm(w) { return this.lcm(w)._move(this); }
                    lcm(w) { return P(p.isBN(w), "num", "bignum"), this.isZero() || w.isZero() ? new p(0) : this.quo(this.gcd(w)).mul(w).iabs(); }
                    egcd(w) { if (P(p.isBN(w), "num", "bignum"), this.isZero())
                        return [new p(0), new p(w.sign()), w.abs()]; if (w.isZero())
                        return [new p(this.sign()), new p(0), this.abs()]; const O = this.clone(), q = w.clone(); O.negative = 0, q.negative = 0; const H = new p(1), V = new p(0), J = new p(0), Z = new p(1), tt = O._factor2(q); tt !== 0 && (O.iushrn(tt), q.iushrn(tt)); const nt = q.clone(), rt = O.clone(); for (; !O.isZero();) {
                        let it = O._makeOdd(), st = q._makeOdd();
                        for (; it--;)
                            (H.isOdd() || V.isOdd()) && (H.iadd(nt), V.isub(rt)), H.iushrn(1), V.iushrn(1);
                        for (; st--;)
                            (J.isOdd() || Z.isOdd()) && (J.iadd(nt), Z.isub(rt)), J.iushrn(1), Z.iushrn(1);
                        O.cmp(q) >= 0 ? (O.isub(q), H.isub(J), V.isub(Z)) : (q.isub(O), J.isub(H), Z.isub(V));
                    } return this.negative !== 0 && J.ineg(), w.negative !== 0 && Z.ineg(), [J, Z, q.iushln(tt)]; }
                    iinvert(w) { return this.invert(w)._move(this); }
                    invert(w) { if (P(p.isBN(w), "num", "bignum"), L(w.sign() > 0, "invert"), w.isOdd())
                        return this._invertp(w); if (w.cmpn(1) === 0)
                        throw new RangeError("Not invertible."); const [O, , q] = this.egcd(w); if (q.cmpn(1) !== 0)
                        throw new RangeError("Not invertible."); return O.imod(w); }
                    ifermat(w) { return this.fermat(w)._move(this); }
                    fermat(w) { const O = l ? p.red(w) : p.mont(w); return this.toRed(O).redFermat().fromRed(); }
                    ipowm(w, O, q) { return this.powm(w, O, q)._move(this); }
                    powm(w, O, q) { const H = !l && q ? p.mont(O) : p.red(O); return this.toRed(H).redPow(w).fromRed(); }
                    ipowmn(w, O, q) { return this.powmn(w, O, q)._move(this); }
                    powmn(w, O, q) { const H = q ? p.mont(O) : p.red(O); return this.toRed(H).redPown(w).fromRed(); }
                    isqrtm(w) { return this.sqrtm(w)._move(this); }
                    sqrtm(w) { let O; return P(p.isBN(w), "p", "bignum"), O = w.andln(3) === 3 || w.andln(7) === 5 ? p.red(w) : p.mont(w), this.toRed(O).redSqrt().fromRed(); }
                    isqrtpq(w, O) { return this.sqrtpq(w, O)._move(this); }
                    sqrtpq(w, O) { const q = this.sqrtm(w), H = this.sqrtm(O), [V, J] = w.egcd(O), Z = H.mul(V).mul(w), tt = q.mul(J).mul(O), nt = w.mul(O); return Z.iadd(tt).imod(nt); }
                    isPrime(w, O, q) { return P(O >>> 0 === O, "reps", "uint32"), !!this.isPrimeMR(w, O + 1, !0) && !!this.isPrimeLucas(q); }
                    isPrimeMR(w, O, q = !1) { P(O >>> 0 === O, "reps", "uint32"), P(O > 0, "reps", "integer"), P(typeof q == "boolean", "force2", "boolean"); const H = this; if (H.cmpn(7) < 0)
                        return H.cmpn(2) === 0 || H.cmpn(3) === 0 || H.cmpn(5) === 0; if (H.isEven())
                        return !1; const V = H.subn(1), J = V.subn(2), Z = V.zeroBits(), tt = V.ushrn(Z), nt = p.red(H), rt = V.toRed(nt), it = new p(1).toRed(nt); t: for (let st = 0; st < O; st++) {
                        let at;
                        st === O - 1 && q ? at = new p(2) : (at = p.random(w, 0, J), at.iaddn(2));
                        let ct = at.toRed(nt).redPow(tt);
                        if (ct.cmp(it) !== 0 && ct.cmp(rt) !== 0) {
                            for (let lt = 1; lt < Z; lt++) {
                                if (ct = ct.redSqr(), ct.cmp(rt) === 0)
                                    continue t;
                                if (ct.cmp(it) === 0)
                                    return !1;
                            }
                            return !1;
                        }
                    } return !0; }
                    isPrimeLucas(w = 0) { P(w >>> 0 === w, "limit", "uint32"); const O = this; if (O.cmpn(1) <= 0)
                        return !1; if (O.isEven())
                        return O.cmpn(2) === 0; let q = 3; for (;;) {
                        if (q > 1e4)
                            throw new Error(`Cannot find (D/n) = -1 for ${O.toString(10)}.`);
                        if (w !== 0 && q > w)
                            return !1;
                        const nt = new p(q * q - 4).jacobi(O);
                        if (nt === -1)
                            break;
                        if (nt === 0)
                            return O.cmpn(q + 2) === 0;
                        if (q === 40 && O.isSquare())
                            return !1;
                        q += 1;
                    } const H = O.addn(1), V = H._makeOdd(), J = O.subn(2); let Z = new p(2), tt = new p(q); for (let nt = H.bitLength(); nt >= 0; nt--)
                        H.utestn(nt) ? (Z = Z.mul(tt).iadd(O).isubn(q).imod(O), tt = tt.sqr().iadd(J).imod(O)) : (tt = tt.mul(Z).iadd(O).isubn(q).imod(O), Z = Z.sqr().iadd(J).imod(O)); if (Z.cmpn(2) === 0 || Z.cmp(J) === 0) {
                        let nt = Z.muln(q), rt = tt.ushln(1);
                        if (nt.cmp(rt) < 0 && ([nt, rt] = [rt, nt]), nt.isub(rt).imod(O).isZero())
                            return !0;
                    } for (let nt = 0; nt < V - 1; nt++) {
                        if (Z.isZero())
                            return !0;
                        if (Z.cmpn(2) === 0)
                            return !1;
                        Z = Z.sqr().isubn(2).imod(O);
                    } return !1; }
                    toTwos(w) { return this.negative !== 0 ? this.abs().inotn(w).iaddn(1) : this.clone(); }
                    fromTwos(w) { return P(w >>> 0 === w, "width", "uint32"), L(w > 0, "width"), this.testn(w - 1) ? this.notn(w).iaddn(1).ineg() : this.clone(); }
                    toRed(w) { if (P(w instanceof M, "ctx", "reduction context"), this.red)
                        throw new Error("Already in reduction context."); return w.convertTo(this); }
                    fromRed() { return j(this.red, "fromRed"), this.red.convertFrom(this); }
                    forceRed(w) { if (P(w instanceof M, "ctx", "reduction context"), this.red) {
                        if (!w.m.eq(this.red.m) || w.mont !== this.red.mont)
                            throw new Error("Already in reduction context.");
                    }
                    else
                        L(this.negative === 0, "red"), L(this.ucmp(w.m) < 0, "red"); return this.clone()._forceRed(w); }
                    redIAdd(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redIAdd"), this.red.iadd(this, w); }
                    redAdd(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redAdd"), this.red.add(this, w); }
                    redIAddn(w) { return P(X(w), "num", "smi"), j(this.red, "redIAddn"), this.red.iaddn(this, w); }
                    redAddn(w) { return P(X(w), "num", "smi"), j(this.red, "redAddn"), this.red.addn(this, w); }
                    redISub(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redISub"), this.red.isub(this, w); }
                    redSub(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redSub"), this.red.sub(this, w); }
                    redISubn(w) { return P(X(w), "num", "smi"), j(this.red, "redISubn"), this.red.isubn(this, w); }
                    redSubn(w) { return P(X(w), "num", "smi"), j(this.red, "redSubn"), this.red.subn(this, w); }
                    redIMul(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redIMul"), this.red.imul(this, w); }
                    redMul(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redMul"), this.red.mul(this, w); }
                    redIMuln(w) { return P(X(w), "num", "smi"), j(this.red, "redIMuln"), this.red.imuln(this, w); }
                    redMuln(w) { return P(X(w), "num", "smi"), j(this.red, "redMuln"), this.red.muln(this, w); }
                    redIDiv(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redIDiv"), this.red.idiv(this, w); }
                    redDiv(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redDiv"), this.red.div(this, w); }
                    redIDivn(w) { return P(X(w), "num", "smi"), j(this.red, "redIDivn"), this.red.idivn(this, w); }
                    redDivn(w) { return P(X(w), "num", "smi"), j(this.red, "redDivn"), this.red.divn(this, w); }
                    redIPow(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redIPow"), D(!w.red, "redIPow"), this.red.ipow(this, w); }
                    redPow(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redPow"), D(!w.red, "redPow"), this.red.pow(this, w); }
                    redIPown(w) { return P(X(w), "num", "smi"), j(this.red, "redIPown"), this.red.ipown(this, w); }
                    redPown(w) { return P(X(w), "num", "smi"), j(this.red, "redPown"), this.red.pown(this, w); }
                    redISqr() { return j(this.red, "redISqr"), this.red.isqr(this); }
                    redSqr() { return j(this.red, "redSqr"), this.red.sqr(this); }
                    redISqrt() { return j(this.red, "redISqrt"), this.red.isqrt(this); }
                    redSqrt() { return j(this.red, "redSqrt"), this.red.sqrt(this); }
                    redIDivSqrt(w) { return j(this.red, "redIDivSqrt"), this.red.idivsqrt(this, w); }
                    redDivSqrt(w) { return j(this.red, "redDivSqrt"), this.red.divsqrt(this, w); }
                    redIsSquare() { return j(this.red, "redIsSquare"), this.red.isSquare(this); }
                    redIShl(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redIShl"), D(!w.red, "redIShl"), this.red.ishl(this, w); }
                    redShl(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redShl"), D(!w.red, "redShl"), this.red.shl(this, w); }
                    redIShln(w) { return P(w >>> 0 === w, "num", "uint32"), j(this.red, "redIShln"), this.red.ishln(this, w); }
                    redShln(w) { return P(w >>> 0 === w, "num", "uint32"), j(this.red, "redShln"), this.red.shln(this, w); }
                    redINeg() { return j(this.red, "redINeg"), this.red.ineg(this); }
                    redNeg() { return j(this.red, "redNeg"), this.red.neg(this); }
                    redEq(w) { return P(p.isBN(w), "num", "bignum"), j(this.red, "redEq"), this.red.eq(this, w); }
                    redEqn(w) { return P(X(w), "num", "smi"), j(this.red, "redEqn"), this.red.eqn(this, w); }
                    redIsHigh() { return j(this.red, "redIsHigh"), this.red.isHigh(this); }
                    redIsLow() { return j(this.red, "redIsLow"), this.red.isLow(this); }
                    redIsOdd() { return j(this.red, "redIsOdd"), this.red.isOdd(this); }
                    redIsEven() { return j(this.red, "redIsEven"), this.red.isEven(this); }
                    redLegendre() { return j(this.red, "redLegendre"), this.red.legendre(this); }
                    redJacobi() { return j(this.red, "redJacobi"), this.red.jacobi(this); }
                    redKronecker() { return j(this.red, "redKronecker"), this.red.kronecker(this); }
                    redIInvert() { return j(this.red, "redIInvert"), this.red.iinvert(this); }
                    redInvert() { return j(this.red, "redInvert"), this.red.invert(this); }
                    redIFermat() { return j(this.red, "redIFermat"), this.red.ifermat(this); }
                    redFermat() { return j(this.red, "redFermat"), this.red.fermat(this); }
                    _move(w) { return w.words = this.words, w.length = this.length, w.negative = this.negative, w.red = this.red, w; }
                    _alloc(w) { for (; this.words.length < w;)
                        this.words.push(0); return this; }
                    _expand(w) { for (this._alloc(w); this.length < w;)
                        this.words[this.length++] = 0; return this; }
                    _strip() { for (; this.length > 1 && this.words[this.length - 1] === 0;)
                        this.length -= 1; return this._normalize(); }
                    _normalize() { return B(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this; }
                    _check() { return B(this.length > 0), B(this.length <= this.words.length), this.length === 1 ? (this.words[0] === 0 && B(this.negative === 0), this) : (B(this.words[this.length - 1] !== 0), this); }
                    _invertp(w) { if (P(p.isBN(w), "p", "bignum"), L(w.sign() > 0, "invert"), B(w.isOdd()), w.cmpn(1) === 0)
                        throw new RangeError("Not invertible."); const O = this.clone(), q = w.clone(), H = new p(1), V = new p(0); for ((O.isNeg() || O.ucmp(q) >= 0) && O.imod(q); !O.isZero();) {
                        let J = O._makeOdd(), Z = q._makeOdd();
                        for (; J--;)
                            H.isOdd() && H._iadd(H, w), H.iushrn(1);
                        for (; Z--;)
                            V.isOdd() && V._iadd(V, w), V.iushrn(1);
                        O.ucmp(q) >= 0 ? (O._isub(O, q), H.ucmp(V) < 0 ? (H._isub(V, H), H._isub(w, H)) : H._isub(H, V)) : (q._isub(q, O), V.ucmp(H) < 0 ? (V._isub(H, V), V._isub(w, V)) : V._isub(V, H));
                    } if (q.cmpn(1) !== 0)
                        throw new RangeError("Not invertible."); return B(V.negative === 0), B(V.ucmp(w) < 0), V; }
                    _makeOdd() { const w = this.zeroBits(); return w > 0 && this.iushrn(w), w; }
                    _factor2(w) { if (1 & (this.words[0] | w.words[0]))
                        return 0; const O = Math.min(this.length, w.length); let q = 0; for (let H = 0; H < O; H++) {
                        const V = F(this.words[H] | w.words[H]);
                        if (q += V, V !== 26)
                            break;
                    } return q; }
                    _cloneNormal() { return this.red ? this.fromRed() : this.clone(); }
                    _forceRed(w) { return this.red = w, this; }
                    clone() { const w = new p; w.words = new Array(this.length); for (let O = 0; O < this.length; O++)
                        w.words[O] = this.words[O]; return w.length = this.length, w.negative = this.negative, w.red = this.red, w; }
                    inject(w) { P(p.isBN(w), "num", "bignum"), this._alloc(w.length); for (let O = 0; O < w.length; O++)
                        this.words[O] = w.words[O]; return this.length = w.length, this.negative = w.negative, this.red = w.red, this; }
                    set(w, O) { return this.fromNumber(w, O); }
                    swap(w) { P(p.isBN(w), "num", "bignum"); const O = this, q = w; return [O.words, q.words] = [q.words, O.words], [O.length, q.length] = [q.length, O.length], [O.negative, q.negative] = [q.negative, O.negative], [O.red, q.red] = [q.red, O.red], O; }
                    reverse() { const w = this.negative; return this.fromBuffer(this.toBuffer("be"), "le"), this.negative = w, this; }
                    byteLength() { return Math.ceil(this.bitLength() / 8); }
                    bitLength() { const w = K(this.words[this.length - 1]); return 26 * (this.length - 1) + w; }
                    zeroBits() { if (this.isZero())
                        return 0; if (this.isOdd())
                        return 0; let w = 0; for (let O = 0; O < this.length; O++) {
                        const q = F(this.words[O]);
                        if (w += q, q !== 26)
                            break;
                    } return w; }
                    isSafe() { return this.length <= 2 || this.length === 3 && this.words[2] === 1; }
                    word(w) { return P(w >>> 0 === w, "pos", "uint32"), w >= this.length ? 0 : this.words[w]; }
                    [r]() { let w = "BN"; return this.red && (w = "BN-R"), `<${w}: ${this.toString(10)}>`; }
                    csign() { return -2 * this.negative + 1 - this.czero(); }
                    czero() { const w = this.words[0] - 1 >>> 31; return this.length - 2 >>> 31 & w; }
                    cneg() { return this.negative; }
                    cpos() { return 1 ^ this.negative; }
                    ceq(w) { P(p.isBN(w), "num", "bignum"); let O = 0; for (let q = 0; q < w.length; q++)
                        O |= this.words[q % this.length] ^ w.words[q]; return O |= this.length ^ w.length, O |= this.negative ^ w.negative, O - 1 >>> 31; }
                    ceqn(w) { const O = w >> 31 & 1, q = (0 | w) * (1 | -O) & 67108863; let H = 0; return H |= this.words[0] ^ q, H |= 1 ^ this.length, H |= this.negative ^ O, H - 1 >>> 31; }
                    cswap(w, O) { P(p.isBN(w), "num", "bignum"); const q = this, H = w, V = 67108863 & -(1 & (O >> 31 | -O >> 31)); q._alloc(H.words.length), H._alloc(q.words.length); for (let tt = 0; tt < q.words.length; tt++) {
                        const nt = (q.words[tt] ^ H.words[tt]) & V;
                        q.words[tt] ^= nt, H.words[tt] ^= nt;
                    } const J = (q.length ^ H.length) & V, Z = (q.negative ^ H.negative) & V; return q.length ^= J, H.length ^= J, q.negative ^= Z, H.negative ^= Z, this; }
                    cinject(w, O) { P(p.isBN(w), "num", "bignum"); const q = this, H = w, V = 1 & (O >> 31 | -O >> 31), J = V - 1 & 67108863, Z = 67108863 & ~(V - 1); q._alloc(H.length); for (let tt = 0; tt < H.length; tt++)
                        q.words[tt] = q.words[tt] & J | H.words[tt] & Z; return q.length = q.length & J | H.length & Z, q.negative = q.negative & J | H.negative & Z, this; }
                    cset(w, O) { const q = 1 & (O >> 31 | -O >> 31), H = q - 1 & 67108863, V = 67108863 & ~(q - 1), J = w >> 31 & 1, Z = (0 | w) * (1 | -J) & 67108863; return this.words[0] = this.words[0] & H | Z & V, this.length = this.length & H | 1 & V, this.negative = this.negative & H | J & V, this; }
                    toNumber() { let w = this.words[0]; if (this.length === 2)
                        w += 67108864 * this.words[1];
                    else if (this.length === 3 && this.words[2] === 1)
                        w += 4503599627370496 + 67108864 * this.words[1];
                    else if (this.length > 2)
                        throw new RangeError("Number can only safely store up to 53 bits."); return this.negative !== 0 ? -w : w; }
                    toDouble() { let w = 0; for (let O = this.length - 1; O >= 0; O--)
                        w = 67108864 * w + this.words[O]; return this.negative !== 0 ? -w : w; }
                    valueOf() { return this.toDouble(); }
                    toBigInt() { if (!l)
                        throw new Error("BigInt is not supported!"); const w = BigInt(52), O = BigInt(26); let q = this.length - 1, H = BigInt(0); for (; q >= 1; q -= 2) {
                        const V = 67108864 * this.words[q], J = this.words[q - 1];
                        H = H << w | BigInt(V + J);
                    } return q >= 0 && (H = H << O | BigInt(this.words[0])), this.negative !== 0 ? -H : H; }
                    toBool() { return !this.isZero(); }
                    toString(w, O) { if (O == null && (O = 0), O === 0 && (O = 1), P((w = Q(w)) >>> 0 === w, "base", "uint32"), P(O >>> 0 === O, "padding", "uint32"), w < 2 || w > 36)
                        throw new RangeError("Base ranges between 2 and 36."); if (this._check(), w === 16) {
                        let Z = "", tt = 0, nt = 0;
                        for (let rt = 0; rt < this.length; rt++) {
                            const it = this.words[rt], st = (16777215 & (it << tt | nt)).toString(16);
                            nt = it >>> 24 - tt & 16777215, Z = nt !== 0 || rt !== this.length - 1 ? e[6 - st.length] + st + Z : st + Z, tt += 2, tt >= 26 && (tt -= 26, rt -= 1);
                        }
                        for (nt !== 0 && (Z = nt.toString(16) + Z); Z.length % O != 0;)
                            Z = "0" + Z;
                        return this.negative !== 0 && (Z = "-" + Z), Z;
                    } const q = c[w - 1], H = n[w - 1], V = this.clone(); let J = ""; for (V.negative = 0; !V.isZero();) {
                        const Z = V.remrn(H).toString(w);
                        V.iquon(H), J = V.isZero() ? Z + J : e[q - Z.length] + Z + J;
                    } for (this.isZero() && (J = "0"); J.length % O != 0;)
                        J = "0" + J; return this.negative !== 0 && (J = "-" + J), J; }
                    toJSON() { return this.toString(16, 2); }
                    toArray(w, O) { return this.toArrayLike(Array, w, O); }
                    toBuffer(w, O) { return this.toArrayLike(d, w, O); }
                    toArrayLike(w, O, q) { O == null && (O = "be"), q == null && (q = 0), P(typeof w == "function", "ArrayType", "function"), P(O === "be" || O === "le", "endian", "endianness"), P(q >>> 0 === q, "length", "uint32"), this._check(); const H = this.byteLength(), V = q || Math.max(1, H); if (H > V)
                        throw new RangeError("Byte array longer than desired length."); const J = function (Z, tt) { return Z.allocUnsafeSlow ? Z.allocUnsafeSlow(tt) : new Z(tt); }(w, V); if (O === "be") {
                        let Z = J.length - 1, tt = 0;
                        for (let nt = 0; nt < this.length; nt++) {
                            const rt = (3 & nt) << 1, it = this.words[nt] << rt | tt;
                            J[Z--] = 255 & it, Z >= 0 && (J[Z--] = it >>> 8 & 255), Z >= 0 && (J[Z--] = it >>> 16 & 255), rt === 6 ? (Z >= 0 && (J[Z--] = it >>> 24 & 255), tt = 0) : tt = it >>> 24;
                        }
                        if (Z >= 0) {
                            for (J[Z--] = tt; Z >= 0;)
                                J[Z--] = 0;
                            tt = 0;
                        }
                        B(tt === 0);
                    }
                    else {
                        let Z = 0, tt = 0;
                        for (let nt = 0; nt < this.length; nt++) {
                            const rt = (3 & nt) << 1, it = this.words[nt] << rt | tt;
                            J[Z++] = 255 & it, Z < J.length && (J[Z++] = it >>> 8 & 255), Z < J.length && (J[Z++] = it >>> 16 & 255), rt === 6 ? (Z < J.length && (J[Z++] = it >>> 24 & 255), tt = 0) : tt = it >>> 24;
                        }
                        if (Z < J.length) {
                            for (J[Z++] = tt; Z < J.length;)
                                J[Z++] = 0;
                            tt = 0;
                        }
                        B(tt === 0);
                    } return J; }
                    encode(w, O) { return this.toBuffer(w, O); }
                    of(w, O) { return this.fromNumber(w, O); }
                    fromNumber(w, O) { O == null && (O = "be"), P(W(w), "num", "integer"), P(O === "be" || O === "le", "endian", "endianness"); const q = w < 0 | 0; return q && (w = -w), w < 67108864 ? (this.words[0] = 67108863 & w, this.length = 1) : w < 4503599627370496 ? (this.words = [67108863 & w, w / 67108864 & 67108863], this.length = 2) : (this.words = [67108863 & w, w / 67108864 & 67108863, 1], this.length = 3), this.negative = q, O === "le" && this.reverse(), this; }
                    fromDouble(w, O) { O == null && (O = "be"), P(typeof w == "number", "num", "double"), P(O === "be" || O === "le", "endian", "endianness"), isFinite(w) || (w = 0); const q = w <= -1 | 0; for (w < 0 && (w = -w), w = Math.floor(w), this.words = []; w > 0;) {
                        const H = w % 67108864, V = (w - H) / 67108864;
                        this.words.push(H), w = V;
                    } return this.words.length === 0 && this.words.push(0), this.length = this.words.length, this.negative = q, O === "le" && this.reverse(), this; }
                    fromBigInt(w, O) { if (O == null && (O = "be"), P(typeof w == "bigint", "num", "bigint"), P(O === "be" || O === "le", "endian", "endianness"), !l)
                        throw new Error("BigInt is not supported!"); const q = w < BigInt(0) | 0; return this._fromHex(w.toString(16), q), this.negative = q, O === "le" && this.reverse(), this; }
                    fromBool(w) { return P(typeof w == "boolean", "value", "boolean"), this.words[0] = 0 | w, this.length = 1, this.negative = 0, this; }
                    fromString(w, O, q) { if (O !== "le" && O !== "be" || ([O, q] = [q, O]), O = Q(O), q == null && (q = "be"), P(typeof w == "string", "string", "string"), P(O >>> 0 === O, "base", "uint32"), P(q === "be" || q === "le", "endian", "endianness"), O < 2 || O > 36)
                        throw new Error("Base ranges between 2 and 36."); let H = 0; return (w = w.replace(/\s+/g, "")).length > 0 && w.charCodeAt(0) === 45 && (H = 1), O === 16 ? this._fromHex(w, H) : this._fromBase(w, O, H), this.negative = H, this._normalize(), q === "le" && this.reverse(), this; }
                    _fromHex(w, O) { this.length = Math.max(2, Math.ceil((w.length - O) / 6)), this.words = new Array(this.length); for (let J = 0; J < this.length; J++)
                        this.words[J] = 0; let q = 0, H = w.length - 6, V = 0; for (; H >= O; H -= 6) {
                        const J = Y(w, H, H + 6);
                        this.words[V] |= J << q & 67108863, this.words[V + 1] |= J >>> 26 - q & 4194303, q += 24, q >= 26 && (q -= 26, V += 1);
                    } if (H + 6 !== O) {
                        const J = Y(w, O, H + 6);
                        this.words[V] |= J << q & 67108863, this.words[V + 1] |= J >>> 26 - q & 4194303;
                    } return this._strip(); }
                    _fromBase(w, O, q) { this.words[0] = 0, this.length = 1, this.negative = 0; let H = 0, V = 1; for (; V <= 67108863; V *= O)
                        H += 1; H -= 1, V = V / O | 0; const J = w.length - q, Z = J % H, tt = Math.min(J, J - Z) + q; let nt = q; for (; nt < tt; nt += H) {
                        const rt = $(w, nt, nt + H, O);
                        this.imuln(V), this._iaddn(rt);
                    } if (Z !== 0) {
                        const rt = Math.pow(O, Z), it = $(w, nt, w.length, O);
                        this.imuln(rt), this._iaddn(it);
                    } return this; }
                    fromJSON(w) { if (p.isBN(w))
                        return w.red ? w.fromRed() : w.clone(); if (Array.isArray(w)) {
                        for (const O of w)
                            P(typeof O == "string", "chunk", "string");
                        w = w.join("");
                    } return this.fromString(w, 16); }
                    fromBN(w) { return this.inject(w); }
                    fromArray(w, O) { return P(Array.isArray(w), "data", "array"), this.fromArrayLike(w, O); }
                    fromBuffer(w, O) { return P(d.isBuffer(w), "data", "buffer"), this.fromArrayLike(w, O); }
                    fromArrayLike(w, O) { if (O == null && (O = "be"), P(w && w.length >>> 0 === w.length, "data", "array-like"), P(O === "be" || O === "le", "endian", "endianness"), w.length === 0)
                        return this.words[0] = 0, this.length = 1, this.negative = 0, this; this.length = Math.max(2, Math.ceil(w.length / 3)), this.words = new Array(this.length), this.negative = 0; for (let Z = 0; Z < this.length; Z++)
                        this.words[Z] = 0; const q = w.length % 3; let H = 0, V = 0, J = 0; if (O === "be") {
                        for (let Z = w.length - 1; Z >= 2; Z -= 3) {
                            const tt = w[Z] | w[Z - 1] << 8 | w[Z - 2] << 16;
                            this.words[V] |= tt << H & 67108863, this.words[V + 1] = tt >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, V += 1);
                        }
                        switch (q) {
                            case 2:
                                J = w[1] | w[0] << 8;
                                break;
                            case 1: J = w[0];
                        }
                    }
                    else {
                        const Z = w.length - q;
                        for (let tt = 0; tt < Z; tt += 3) {
                            const nt = w[tt] | w[tt + 1] << 8 | w[tt + 2] << 16;
                            this.words[V] |= nt << H & 67108863, this.words[V + 1] = nt >>> 26 - H & 67108863, H += 24, H >= 26 && (H -= 26, V += 1);
                        }
                        switch (q) {
                            case 2:
                                J = w[Z] | w[Z + 1] << 8;
                                break;
                            case 1: J = w[Z];
                        }
                    } return q > 0 && (this.words[V] |= J << H & 67108863, this.words[V + 1] = J >>> 26 - H & 67108863), this._strip(); }
                    decode(w, O) { return this.fromBuffer(w, O); }
                    from(w, O, q) { if (w == null)
                        return this; if (O !== "le" && O !== "be" || ([O, q] = [q, O]), typeof w == "number")
                        return this.fromNumber(w, q); if (typeof w == "bigint")
                        return this.fromBigInt(w, q); if (typeof w == "string")
                        return this.fromString(w, O, q); if (typeof w == "object") {
                        if (p.isBN(w))
                            return this.fromBN(w, q);
                        if (w.length >>> 0 === w.length)
                            return this.fromArrayLike(w, q);
                    } if (typeof w == "boolean")
                        return this.fromBool(w); throw new TypeError("Non-numeric object passed to BN."); }
                    static min(...w) { let O = null; for (const q of w)
                        P(p.isBN(q), "num", "bignum"), (!O || q.cmp(O) < 0) && (O = q); return O || new p(0); }
                    static max(...w) { let O = null; for (const q of w)
                        P(p.isBN(q), "num", "bignum"), (!O || q.cmp(O) > 0) && (O = q); return O || new p(0); }
                    static cmp(w, O) { return P(p.isBN(w), "a", "bignum"), w.cmp(O); }
                    static ucmp(w, O) { return P(p.isBN(w), "a", "bignum"), w.ucmp(O); }
                    static red(w) { return new M(w); }
                    static barrett(w) { return new N(w); }
                    static mont(w) { return new S(w); }
                    static _prime(w) { if (t[w])
                        return t[w]; let O; if (w === "p192")
                        O = new b;
                    else if (w === "p224")
                        O = new I;
                    else if (w === "p521")
                        O = new v;
                    else if (w === "k256")
                        O = new R;
                    else if (w === "p251")
                        O = new _;
                    else if (w === "p25519")
                        O = new k;
                    else {
                        if (w !== "p448")
                            throw new Error(`Unknown prime: "${w}".`);
                        O = new x;
                    } return t[w] = O, O; }
                    static prime(w) { return p._prime(w).p.clone(); }
                    static pow(w, O) { return w === 2 ? p.shift(1, O) : new p().fromNumber(w).pown(O); }
                    static shift(w, O) { return w === 1 ? new p(0).usetn(O, 1) : new p().fromNumber(w).ishln(O); }
                    static mask(w) { return p.shift(1, w).isubn(1); }
                    static randomBits(w, O) { if (P(w != null, "rng", "rng"), P(O >>> 0 === O, "bits", "uint32"), typeof w == "object") {
                        P(typeof w.randomBytes == "function", "rng", "rng");
                        const H = O + 7 >>> 3, V = 8 * H, J = w.randomBytes(H);
                        if (P(d.isBuffer(J), "bytes", "buffer"), J.length !== H)
                            throw new RangeError("Invalid number of bytes returned from RNG.");
                        const Z = p.fromBuffer(J);
                        return V > O && Z.iushrn(V - O), Z;
                    } P(typeof w == "function", "rng", "rng"); const q = w(O); if (P(p.isBN(q), "num", "bignum"), L(q.negative === 0, "RNG"), D(!q.red, "RNG"), q.bitLength() > O)
                        throw new RangeError("Invalid number of bits returned from RNG."); return q; }
                    static random(w, O, q) { if (O = p.cast(O, 16), q = p.cast(q, 16), O.cmp(q) > 0)
                        throw new RangeError("Minimum cannot be greater than maximum."); const H = q.sub(O).iabs(), V = H.bitLength(); if (V === 0)
                        return O.clone(); for (;;) {
                        const J = p.randomBits(w, V);
                        if (!(J.cmp(H) >= 0))
                            return J.iadd(O), J;
                    } }
                    static of(w, O) { return new p().of(w, O); }
                    static fromNumber(w, O) { return new p().fromNumber(w, O); }
                    static fromDouble(w, O) { return new p().fromDouble(w, O); }
                    static fromBigInt(w, O) { return new p().fromBigInt(w, O); }
                    static fromBool(w) { return new p().fromBool(w); }
                    static fromString(w, O, q) { return new p().fromString(w, O, q); }
                    static fromJSON(w) { return new p().fromJSON(w); }
                    static fromBN(w) { return new p().fromBN(w); }
                    static fromArray(w, O) { return new p().fromArray(w, O); }
                    static fromBuffer(w, O) { return new p().fromBuffer(w, O); }
                    static fromArrayLike(w, O) { return new p().fromArrayLike(w, O); }
                    static decode(w, O) { return new p().decode(w, O); }
                    static from(w, O, q) { return new p().from(w, O, q); }
                    static cast(w, O, q) { return p.isBN(w) ? w : new p(w, O, q); }
                    static isBN(w) { return w instanceof p; }
                } p.BN = p, p.wordSize = 26, p.native = 0; class g {
                    constructor(w, O) { this.name = w, this.p = new p(O, 16), this.n = this.p.bitLength(), this.k = p.shift(1, this.n).isub(this.p), this.lo = this.p.clone(), this.one = this.p.clone(); }
                    ireduce(w) { const O = w.negative !== 0; let q = w.bitLength(); for (B(q <= 2 * this.n), w.negative = 0; q > this.n;)
                        this.split(w, this.lo), this.imulK(w), w._iadd(w, this.lo), q = w.bitLength(); const H = q < this.n ? -1 : w.ucmp(this.p); return H === 0 ? (w.words[0] = 0, w.length = 1) : H > 0 && w._isub(w, this.p), O && !w.isZero() && w._isub(this.p, w), w; }
                    split(w, O) { w._split(this.n, O); }
                    imulK(w) { return w.imul(this.k); }
                } class b extends g {
                    constructor() { super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff"); }
                    imulK(w) { const O = this.one.inject(w); return w.iushln(64)._iadd(w, O); }
                } class I extends g {
                    constructor() { super("p224", "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001"); }
                    imulK(w) { const O = this.one.inject(w); return w.iushln(96)._isub(w, O); }
                } class v extends g {
                    constructor() { super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff"); }
                    imulK(w) { return w; }
                } class R extends g {
                    constructor() { super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f"); }
                    split(w, O) { const q = Math.min(w.length, 9); O._alloc(q + 1); for (let J = 0; J < q; J++)
                        O.words[J] = w.words[J]; if (O.length = q, w.length <= 9)
                        return O._strip(), w.words[0] = 0, void (w.length = 1); let H = w.words[9], V = 10; for (O.words[O.length++] = 4194303 & H, O._strip(); V < w.length; V++) {
                        const J = 0 | w.words[V];
                        w.words[V - 10] = (4194303 & J) << 4 | H >>> 22, H = J;
                    } H >>>= 22, w.words[V - 10] = H, H === 0 && w.length > 10 ? w.length -= 10 : w.length -= 9, w._strip(); }
                    imulK(w) { w._expand(w.length + 2); let O = 0; for (let q = 0; q < w.length; q++) {
                        const H = w.words[q];
                        O += 977 * H, w.words[q] = 67108863 & O, O = 64 * H + Math.floor(O / 67108864);
                    } return w.words[w.length - 1] === 0 && (w.length -= 1, w.words[w.length - 1] === 0 && (w.length -= 1)), w; }
                } class _ extends g {
                    constructor() { super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7"); }
                    imulK(w) { if (w.isZero())
                        return w; let O = 0; for (let q = 0; q < w.length; q++) {
                        const H = 9 * w.words[q] + O;
                        O = H >>> 26, w.words[q] = 67108863 & H;
                    } return O !== 0 && (w._alloc(w.length + 1), w.words[w.length++] = O), w; }
                } class k extends g {
                    constructor() { super("p25519", "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed"); }
                    imulK(w) { let O = 0; for (let q = 0; q < w.length; q++) {
                        const H = 19 * w.words[q] + O;
                        O = H >>> 26, w.words[q] = 67108863 & H;
                    } return O !== 0 && (w._alloc(w.length + 1), w.words[w.length++] = O), w; }
                } class x extends g {
                    constructor() { super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff"); }
                    imulK(w) { const O = this.one.inject(w); return w.iushln(224)._iadd(w, O); }
                } class M {
                    constructor(w) { let O = null; typeof w == "string" && (O = p._prime(w), w = O.p), P(p.isBN(w), "m", "bignum"), D(!w.red, "reduction"), L(w.sign() > 0, "reduction"), this.m = w, this.prime = O, this.mb = null, this.sm1 = null; }
                    _verify1(w) { L(w.negative === 0, "red"), j(w.red != null, "red"); }
                    _verify2(w, O) { L((w.negative | O.negative) == 0, "red"), j(w.red != null && w.red === O.red, "red"); }
                    get mont() { return !1; }
                    precompute() { if (this.sm1 === null && this.m.andln(7) === 5) {
                        const w = new p(2).toRed(this), O = this.m.subn(1).iushrn(2);
                        this.sm1 = this.pow(w, O);
                    } return this; }
                    convertTo(w) { const O = w.mod(this.m); return O.red = this, O; }
                    convertFrom(w) { const O = w.clone(); return O.red = null, O; }
                    intTo(w) { return w; }
                    intFrom(w) { return w; }
                    imod(w) { return this.prime ? this.prime.ireduce(w)._forceRed(this) : w.imod(this.m)._forceRed(this); }
                    iadd(w, O) { return this._verify2(w, O), w._iadd(w, O), w.ucmp(this.m) >= 0 && w._isub(w, this.m), w; }
                    add(w, O) { return w.length < O.length ? this.iadd(O.clone(), w) : this.iadd(w.clone(), O); }
                    iaddn(w, O) { return this._verify1(w), O < 0 ? this.isubn(w, -O) : (this.m.length === 1 && (O %= this.m.words[0]), w._iaddn(O), w.ucmp(this.m) >= 0 && w._isub(w, this.m), w); }
                    addn(w, O) { return this.iaddn(w.clone(), O); }
                    isub(w, O) { this._verify2(w, O); const q = w.ucmp(O); return q === 0 ? (w.words[0] = 0, w.length = 1, w) : (q < 0 ? (w._isub(O, w), w._isub(this.m, w)) : w._isub(w, O), w); }
                    sub(w, O) { return this.isub(w.clone(), O); }
                    isubn(w, O) { return this._verify1(w), O < 0 ? this.iaddn(w, -O) : (this.m.length === 1 && (O %= this.m.words[0]), w.length === 1 && w.words[0] < O ? (w.words[0] = O - w.words[0], w._isub(this.m, w)) : w._isubn(O), w); }
                    subn(w, O) { return this.isubn(w.clone(), O); }
                    imul(w, O) { return this._verify2(w, O), this.imod(w.imul(O)); }
                    mul(w, O) { return this._verify2(w, O), this.imod(w.mul(O)); }
                    imuln(w, O) { if (this._verify1(w), w.isZero())
                        return w; if (O === 0)
                        return w.words[0] = 0, w.length = 1, w; const q = O < 0; if (q && (O = -O), this.m.length === 1 && (O %= this.m.words[0]), w.imuln(O), O <= 16)
                        for (; w.ucmp(this.m) >= 0;)
                            w._isub(w, this.m);
                    else
                        this.imod(w); return q && this.ineg(w), w; }
                    muln(w, O) { return this.imuln(w.clone(), O); }
                    idiv(w, O) { return this.div(w, O)._move(w); }
                    div(w, O) { return this.mul(w, this.invert(O)); }
                    idivn(w, O) { return this.divn(w, O)._move(w); }
                    divn(w, O) { return this.div(w, this.convertTo(new p(O))); }
                    ipow(w, O) { return this.pow(w, O)._move(w); }
                    pow(w, O) { return this._verify1(w), O.isNeg() && (w = this.invert(w)), O.length === 1 ? this.pown(w, O.words[0]) : l && !this.prime ? this.powInt(w, O) : this.powNum(w, O); }
                    powNum(w, O) { const q = new Array(8); q[0] = this.sqrn(w, 3); for (let J = 1; J < 8; J++)
                        q[J] = this.mul(q[J - 1], w); let H = O.bitLength(), V = new p(1).toRed(this); for (; H >= 4;) {
                        const J = H - 4, Z = O.bits(J, 4);
                        Z < 8 ? (V = this.sqr(V), H -= 1) : (V = this.sqrn(V, 4), V = this.mul(V, q[-9 & Z]), H = J);
                    } if (H > 0) {
                        const J = O.bits(0, H);
                        for (; H--;)
                            V = this.sqr(V), J >> H & 1 && (V = this.mul(V, w));
                    } return V; }
                    powInt(w, O) { this.mb === null && (this.mb = this.m.toBigInt()); const q = function (V, J, Z) { const tt = new Array(8); tt[0] = y(V, 3, Z); for (let it = 1; it < 8; it++)
                        tt[it] = tt[it - 1] * V % Z; let nt = J.bitLength(), rt = BigInt(1); for (; nt >= 4;) {
                        const it = nt - 4, st = J.bits(it, 4);
                        st < 8 ? (rt = rt * rt % Z, nt -= 1) : (rt = y(rt, 4, Z), rt = rt * tt[-9 & st] % Z, nt = it);
                    } if (nt > 0) {
                        const it = J.bits(0, nt);
                        for (; nt--;)
                            rt = rt * rt % Z, it >> nt & 1 && (rt = rt * V % Z);
                    } return rt; }(this.intFrom(w.toBigInt()), O, this.mb), H = this.intTo(q); return p.fromBigInt(H)._forceRed(this); }
                    sqrn(w, O) { for (let q = 0; q < O; q++)
                        w = this.sqr(w); return w; }
                    ipown(w, O) { return this.pown(w, O)._move(w); }
                    pown(w, O) { if (this._verify1(w), O < 0 && (w = this.invert(w), O = -O), O === 0)
                        return new p(1).toRed(this); if (O === 1)
                        return w.clone(); let q = w; for (let H = K(O) - 2; H >= 0; H--)
                        q = this.sqr(q), O >> H & 1 && (q = this.mul(q, w)); return q; }
                    isqr(w) { return this.imul(w, w); }
                    sqr(w) { return this.mul(w, w); }
                    isqrt(w) { return this.sqrt(w)._move(w); }
                    sqrt(w) { return this._verify1(w), this.m.andln(3) === 3 ? this.sqrt3mod4(w) : this.m.andln(7) === 5 ? this.sm1 != null ? this.sqrt5mod8sm1(w) : this.sqrt5mod8(w) : this.sqrt0(w); }
                    sqrt3mod4(w) { const O = this.m.addn(1).iushrn(2), q = this.pow(w, O); if (!this.sqr(q).eq(w))
                        throw new Error("X is not a square mod P."); return q; }
                    sqrt5mod8(w) { const O = new p(1).toRed(this), q = this.m.ushrn(3), H = this.add(w, w), V = this.pow(H, q), J = this.mul(H, this.sqr(V)), Z = this.mul(this.mul(V, w), this.isub(J, O)); if (!this.sqr(Z).eq(w))
                        throw new Error("X is not a square mod P."); return Z; }
                    sqrt5mod8sm1(w) { const O = this.m.addn(3).iushrn(3), q = this.pow(w, O); if (this.sqr(q).eq(w))
                        return q; const H = this.mul(q, this.sm1); if (this.sqr(H).eq(w))
                        return H; throw new Error("X is not a square mod P."); }
                    sqrt0(w) { if (this.m.cmpn(1) === 0 || !this.m.isOdd())
                        throw new Error("Invalid prime."); switch (this.jacobi(w)) {
                        case -1: throw new Error("X is not a square mod P.");
                        case 0: return new p(0)._forceRed(this);
                    } const O = new p(1).toRed(this), q = this.m.subn(1), H = q._makeOdd(), V = new p(2).toRed(this); for (; this.jacobi(V) !== -1;)
                        this.iadd(V, O); let J = this.pow(w, q), Z = this.pow(V, q), tt = this.pow(w, q.iaddn(1).iushrn(1)), nt = H; for (;;) {
                        let rt = J, it = 0;
                        for (; rt.cmp(O) !== 0 && it < nt;)
                            rt = this.sqr(rt), it += 1;
                        if (it === 0)
                            break;
                        B(it < nt), rt = this.sqrn(Z, nt - it - 1), Z = this.sqr(rt), tt = this.mul(tt, rt), J = this.mul(J, Z), nt = it;
                    } return tt; }
                    idivsqrt(w, O) { return this.divsqrt(w, O)._move(w); }
                    divsqrt(w, O) { if (this._verify2(w, O), O.isZero())
                        throw new RangeError("Not invertible."); return this.m.andln(3) === 3 ? this.divsqrt3mod4(w, O) : this.sm1 != null && this.m.andln(7) === 5 ? this.divsqrt5mod8(w, O) : this.sqrt(this.div(w, O)); }
                    divsqrt3mod4(w, O) { const q = this.m.subn(3).iushrn(2), H = this.sqr(w), V = this.mul(H, w), J = this.mul(V, H), Z = this.mul(this.sqr(O), O), tt = this.pow(this.mul(J, Z), q), nt = this.mul(this.mul(V, O), tt); if (this.mul(O, this.sqr(nt)).cmp(w) === 0)
                        return nt; throw new Error("X is not a square mod P."); }
                    divsqrt5mod8(w, O) { const q = this.m.subn(5).iushrn(3), H = this.mul(this.sqr(O), O), V = this.mul(this.sqr(H), O), J = this.pow(this.mul(w, V), q), Z = this.mul(this.mul(w, H), J), tt = this.mul(O, this.sqr(Z)); if (tt.cmp(w) === 0)
                        return Z; if (this.ineg(tt).cmp(w) === 0)
                        return this.mul(Z, this.sm1); throw new Error("X is not a square mod P."); }
                    isSquare(w) { let O; return O = this.prime ? this.legendre(w) : this.m.isOdd() ? this.jacobi(w) : this.kronecker(w), Boolean(~O >>> 31); }
                    ishl(w, O) { return this._verify1(w), this.imod(w.iushl(O)); }
                    shl(w, O) { return this.ishl(w.clone(), O); }
                    ishln(w, O) { if (this._verify1(w), w.iushln(O), O <= 4)
                        for (; w.ucmp(this.m) >= 0;)
                            w._isub(w, this.m);
                    else
                        this.imod(w); return w; }
                    shln(w, O) { return this.ishln(w.clone(), O); }
                    ineg(w) { return this._verify1(w), w.isZero() || w._isub(this.m, w), w; }
                    neg(w) { return this.ineg(w.clone()); }
                    eq(w, O) { return this._verify2(w, O), w.ucmp(O) === 0; }
                    eqn(w, O) { if (this._verify1(w), this.m.length === 1)
                        return (O %= this.m.words[0]) < 0 && (O += this.m.words[0]), w.ucmpn(O) === 0; if (O < 0) {
                        this.m._isubn(-O);
                        const q = w.ucmp(this.m);
                        return this.m._iaddn(-O), q === 0;
                    } return w.ucmpn(O) === 0; }
                    isHigh(w) { return !this.isLow(w); }
                    isLow(w) { return this._verify1(w), w.ucmp(this.m.ushrn(1)) <= 0; }
                    isOdd(w) { return this._verify1(w), w.isOdd(); }
                    isEven(w) { return this._verify1(w), w.isEven(); }
                    legendre(w) { if (this._verify1(w), this.m.isEven())
                        throw new Error("legendre: `num` must be odd."); const O = this.m.subn(1).iushrn(1), q = this.pow(w, O), H = new p(1).toRed(this), V = q.czero(), J = q.ceq(H), Z = q.ceq(this.ineg(H)); if ((V | J | Z) == 0)
                        throw new Error("Invalid prime."); return B(V + J + Z === 1), J - Z; }
                    jacobi(w) { return this._verify1(w), w.jacobi(this.m); }
                    kronecker(w) { return this._verify1(w), w.kronecker(this.m); }
                    iinvert(w) { return this.invert(w)._move(w); }
                    invert(w) { return this._verify1(w), w.invert(this.m)._forceRed(this); }
                    ifermat(w) { return this.fermat(w)._move(w); }
                    fermat(w) { if (this._verify1(w), w.isZero() || this.m.cmpn(1) === 0)
                        throw new RangeError("Not invertible."); return this.pow(w, this.m.subn(2)); }
                    [r]() { return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`; }
                } class N extends M {
                    constructor(w) { super(w), this.prime = null, this.n = this.m.bitLength(), this.n % 26 != 0 && (this.n += 26 - this.n % 26), this.k = 2 * this.n, this.w = this.k / 26, this.b = p.shift(1, this.k).div(this.m); }
                    convertTo(w) { return w.length > this.w ? super.convertTo(w) : this.imod(w.clone()); }
                    _shift(w) { let O = 0, q = this.w; for (; q < w.length;)
                        w.words[O++] = w.words[q++]; O === 0 && (w.words[O++] = 0), w.length = O; }
                    imod(w) { const O = w.negative; B(w.length <= this.w), w.negative = 0; const q = w.mul(this.b); return this._shift(q), w._isub(w, q.mul(this.m)), w.ucmp(this.m) >= 0 && w._isub(w, this.m), O && !w.isZero() && w._isub(this.m, w), w.red = this, w; }
                } class S extends M {
                    constructor(w) { super(w), this.prime = null, this.n = 26 * this.m.length, this.r = p.shift(1, this.n), this.r2 = p.shift(1, 2 * this.n).imod(this.m), this.ri = this.r.invert(this.m), this.mi = this.r.mul(this.ri).isubn(1).div(this.m), this.rib = null; }
                    get mont() { return !0; }
                    convertTo(w) { return w.isNeg() || w.ucmp(this.m) >= 0 ? this.imod(w.ushln(this.n)) : this.mul(w, this.r2); }
                    convertFrom(w) { const O = this.mul(w, new p(1)); return O.red = null, O; }
                    intTo(w) { return (w << BigInt(this.n)) % this.mb; }
                    intFrom(w) { return this.rib === null && (this.rib = this.ri.toBigInt()), w * this.rib % this.mb; }
                    iaddn(w, O) { return this.iadd(w, this.convertTo(new p(O))); }
                    isubn(w, O) { return this.isub(w, this.convertTo(new p(O))); }
                    imul(w, O) { return this.mul(w, O)._move(w); }
                    mul(w, O) { if (w.isZero() || O.isZero())
                        return new p(0)._forceRed(this); const q = w.mul(O), H = q.umaskn(this.n).mul(this.mi).iumaskn(this.n), V = q.iadd(H.mul(this.m)).iushrn(this.n); return V.ucmp(this.m) >= 0 && V._isub(V, this.m), V._forceRed(this); }
                    imuln(w, O) { if (this._verify1(w), w.isZero())
                        return w; if (O === 0)
                        return w.words[0] = 0, w.length = 1, w; const q = O < 0; q && (O = -O), this.m.length === 1 && (O %= this.m.words[0]); const H = K(O); if (H > 5)
                        this.imul(w, this.convertTo(new p(O)));
                    else if ((O & O - 1) == 0)
                        for (let V = 0; V < H - 1; V++)
                            this.iadd(w, w);
                    else {
                        const V = w.clone();
                        for (let J = H - 2; J >= 0; J--)
                            this.iadd(w, w), O >> J & 1 && this.iadd(w, V);
                    } return q && this.ineg(w), w; }
                    eqn(w, O) { return this._verify1(w), O === 0 ? w.isZero() : w.ucmp(this.convertTo(new p(O))) === 0; }
                    isLow(w) { return this._verify1(w), this.convertFrom(w).ucmp(this.m.ushrn(1)) <= 0; }
                    isOdd(w) { return this._verify1(w), this.convertFrom(w).isOdd(); }
                    isEven(w) { return this._verify1(w), this.convertFrom(w).isEven(); }
                    invert(w) { return this._verify1(w), this.imod(w.invert(this.m).mul(this.r2)); }
                } function T(z, w, O) { const q = new z(w); return z.captureStackTrace && z.captureStackTrace(q, O), q; } function B(z, w) { if (!z)
                    throw T(Error, w || "Assertion failed.", B); } function P(z, w, O) { if (!z)
                    throw T(TypeError, `"${w}" must be a(n) ${O}.`, P); } function L(z, w) { if (!z)
                    throw T(RangeError, `"${w}" only works with positive numbers.`, L); } function j(z, w) { if (!z)
                    throw T(TypeError, `"${w}" only works with red numbers.`, j); } function D(z, w) { if (!z)
                    throw T(TypeError, `"${w}" only works with normal numbers.`, D); } function G(z) { if (!z)
                    throw T(RangeError, "Cannot divide by zero.", G); } function W(z) { return Number.isSafeInteger(z); } function X(z) { return W(z) && z >= -67108863 && z <= 67108863; } function Q(z) { if (z == null)
                    return 10; if (typeof z == "number")
                    return z; switch (z) {
                    case "bin": return 2;
                    case "oct": return 8;
                    case "dec": return 10;
                    case "hex": return 16;
                } return 0; } function K(z) { if (Math.clz32)
                    return 32 - Math.clz32(z); let w = z, O = 0; return w >= 4096 && (O += 13, w >>>= 13), w >= 64 && (O += 7, w >>>= 7), w >= 8 && (O += 4, w >>>= 4), w >= 2 && (O += 2, w >>>= 2), O + w; } function F(z) { if (z === 0)
                    return 26; let w = z, O = 0; return (8191 & w) == 0 && (O += 13, w >>>= 13), (127 & w) == 0 && (O += 7, w >>>= 7), (15 & w) == 0 && (O += 4, w >>>= 4), (3 & w) == 0 && (O += 2, w >>>= 2), (1 & w) == 0 && (O += 1), O; } function Y(z, w, O) { const q = Math.min(z.length, O); let H = 0, V = 0; for (let J = w; J < q; J++) {
                    const Z = z.charCodeAt(J) - 48;
                    let tt;
                    H <<= 4, tt = Z >= 49 && Z <= 54 ? Z - 49 + 10 : Z >= 17 && Z <= 22 ? Z - 17 + 10 : Z, H |= tt, V |= tt;
                } if (-16 & V)
                    throw new Error("Invalid string."); return H; } function $(z, w, O, q) { const H = Math.min(z.length, O); let V = 0; for (let J = w; J < H; J++) {
                    const Z = z.charCodeAt(J) - 48;
                    let tt;
                    if (V *= q, tt = Z >= 49 ? Z - 49 + 10 : Z >= 17 ? Z - 17 + 10 : Z, Z < 0 || Z > 207 || tt >= q)
                        throw new Error("Invalid string.");
                    V += tt;
                } return V; } function y(z, w, O) { for (let q = 0; q < w; q++)
                    z = z * z % O; return z; } function C(z, w, O) { const q = z.length + w.length; O.negative = z.negative ^ w.negative, O._alloc(q), O.length = q; const H = z.words[0] * w.words[0], V = 67108863 & H; let J = H / 67108864 | 0, Z = 1; for (O.words[0] = V; Z < O.length - 1; Z++) {
                    let tt = J >>> 26, nt = 67108863 & J;
                    const rt = Math.max(0, Z - z.length + 1), it = Math.min(Z, w.length - 1);
                    for (let st = rt; st <= it; st++) {
                        const at = Z - st, ct = z.words[at] * w.words[st] + nt;
                        tt += ct / 67108864 | 0, nt = 67108863 & ct;
                    }
                    O.words[Z] = 0 | nt, J = 0 | tt;
                } return J !== 0 ? O.words[Z] = 0 | J : O.length -= 1, O._strip(); } function A(z, w, O) { const q = z.length + w.length; O.negative = z.negative ^ w.negative, O._alloc(q), O.length = q; let H = 0, V = 0, J = 0; for (; J < O.length - 1; J++) {
                    let Z = V;
                    V = 0;
                    let tt = 67108863 & H;
                    const nt = Math.max(0, J - z.length + 1), rt = Math.min(J, w.length - 1);
                    for (let it = nt; it <= rt; it++) {
                        const st = J - it, at = z.words[st] * w.words[it];
                        let ct = 67108863 & at;
                        Z = Z + (at / 67108864 | 0) | 0, ct = ct + tt | 0, tt = 67108863 & ct, Z = Z + (ct >>> 26) | 0, V += Z >>> 26, Z &= 67108863;
                    }
                    O.words[J] = tt, H = Z, Z = V;
                } return H !== 0 ? O.words[J] = H : O.length -= 1, O._strip(); } function U(z, w, O) { const q = z.words, H = w.words, V = O.words, J = 0 | q[0], Z = 8191 & J, tt = J >>> 13, nt = 0 | q[1], rt = 8191 & nt, it = nt >>> 13, st = 0 | q[2], at = 8191 & st, ct = st >>> 13, lt = 0 | q[3], pt = 8191 & lt, mt = lt >>> 13, Tt = 0 | q[4], vt = 8191 & Tt, Rt = Tt >>> 13, Bt = 0 | q[5], wt = 8191 & Bt, kt = Bt >>> 13, Wt = 0 | q[6], Ct = 8191 & Wt, Ft = Wt >>> 13, te = 0 | q[7], jt = 8191 & te, Kt = te >>> 13, re = 0 | q[8], St = 8191 & re, Nt = re >>> 13, ne = 0 | q[9], Vt = 8191 & ne, qt = ne >>> 13, ee = 0 | H[0], Ot = 8191 & ee, ft = ee >>> 13, gt = 0 | H[1], bt = 8191 & gt, _t = gt >>> 13, Lt = 0 | H[2], Pt = 8191 & Lt, Mt = Lt >>> 13, Yt = 0 | H[3], Dt = 8191 & Yt, zt = Yt >>> 13, he = 0 | H[4], Gt = 8191 & he, Ut = he >>> 13, de = 0 | H[5], Zt = 8191 & de, Xt = de >>> 13, ie = 0 | H[6], Qt = 8191 & ie, $t = ie >>> 13, ye = 0 | H[7], se = 8191 & ye, Ht = ye >>> 13, dt = 0 | H[8], yt = 8191 & dt, ot = dt >>> 13, Et = 0 | H[9], It = 8191 & Et, At = Et >>> 13; let ut, et, ht, xt = 0; O.negative = z.negative ^ w.negative, O._alloc(20), O.length = 19, ut = Math.imul(Z, Ot), et = Math.imul(Z, ft), et = et + Math.imul(tt, Ot) | 0, ht = Math.imul(tt, ft); let Jt = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, ut = Math.imul(rt, Ot), et = Math.imul(rt, ft), et = et + Math.imul(it, Ot) | 0, ht = Math.imul(it, ft), ut = ut + Math.imul(Z, bt) | 0, et = et + Math.imul(Z, _t) | 0, et = et + Math.imul(tt, bt) | 0, ht = ht + Math.imul(tt, _t) | 0; let pe = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (pe >>> 26) | 0, pe &= 67108863, ut = Math.imul(at, Ot), et = Math.imul(at, ft), et = et + Math.imul(ct, Ot) | 0, ht = Math.imul(ct, ft), ut = ut + Math.imul(rt, bt) | 0, et = et + Math.imul(rt, _t) | 0, et = et + Math.imul(it, bt) | 0, ht = ht + Math.imul(it, _t) | 0, ut = ut + Math.imul(Z, Pt) | 0, et = et + Math.imul(Z, Mt) | 0, et = et + Math.imul(tt, Pt) | 0, ht = ht + Math.imul(tt, Mt) | 0; let fe = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (fe >>> 26) | 0, fe &= 67108863, ut = Math.imul(pt, Ot), et = Math.imul(pt, ft), et = et + Math.imul(mt, Ot) | 0, ht = Math.imul(mt, ft), ut = ut + Math.imul(at, bt) | 0, et = et + Math.imul(at, _t) | 0, et = et + Math.imul(ct, bt) | 0, ht = ht + Math.imul(ct, _t) | 0, ut = ut + Math.imul(rt, Pt) | 0, et = et + Math.imul(rt, Mt) | 0, et = et + Math.imul(it, Pt) | 0, ht = ht + Math.imul(it, Mt) | 0, ut = ut + Math.imul(Z, Dt) | 0, et = et + Math.imul(Z, zt) | 0, et = et + Math.imul(tt, Dt) | 0, ht = ht + Math.imul(tt, zt) | 0; let ce = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ce >>> 26) | 0, ce &= 67108863, ut = Math.imul(vt, Ot), et = Math.imul(vt, ft), et = et + Math.imul(Rt, Ot) | 0, ht = Math.imul(Rt, ft), ut = ut + Math.imul(pt, bt) | 0, et = et + Math.imul(pt, _t) | 0, et = et + Math.imul(mt, bt) | 0, ht = ht + Math.imul(mt, _t) | 0, ut = ut + Math.imul(at, Pt) | 0, et = et + Math.imul(at, Mt) | 0, et = et + Math.imul(ct, Pt) | 0, ht = ht + Math.imul(ct, Mt) | 0, ut = ut + Math.imul(rt, Dt) | 0, et = et + Math.imul(rt, zt) | 0, et = et + Math.imul(it, Dt) | 0, ht = ht + Math.imul(it, zt) | 0, ut = ut + Math.imul(Z, Gt) | 0, et = et + Math.imul(Z, Ut) | 0, et = et + Math.imul(tt, Gt) | 0, ht = ht + Math.imul(tt, Ut) | 0; let ue = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ue >>> 26) | 0, ue &= 67108863, ut = Math.imul(wt, Ot), et = Math.imul(wt, ft), et = et + Math.imul(kt, Ot) | 0, ht = Math.imul(kt, ft), ut = ut + Math.imul(vt, bt) | 0, et = et + Math.imul(vt, _t) | 0, et = et + Math.imul(Rt, bt) | 0, ht = ht + Math.imul(Rt, _t) | 0, ut = ut + Math.imul(pt, Pt) | 0, et = et + Math.imul(pt, Mt) | 0, et = et + Math.imul(mt, Pt) | 0, ht = ht + Math.imul(mt, Mt) | 0, ut = ut + Math.imul(at, Dt) | 0, et = et + Math.imul(at, zt) | 0, et = et + Math.imul(ct, Dt) | 0, ht = ht + Math.imul(ct, zt) | 0, ut = ut + Math.imul(rt, Gt) | 0, et = et + Math.imul(rt, Ut) | 0, et = et + Math.imul(it, Gt) | 0, ht = ht + Math.imul(it, Ut) | 0, ut = ut + Math.imul(Z, Zt) | 0, et = et + Math.imul(Z, Xt) | 0, et = et + Math.imul(tt, Zt) | 0, ht = ht + Math.imul(tt, Xt) | 0; let le = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (le >>> 26) | 0, le &= 67108863, ut = Math.imul(Ct, Ot), et = Math.imul(Ct, ft), et = et + Math.imul(Ft, Ot) | 0, ht = Math.imul(Ft, ft), ut = ut + Math.imul(wt, bt) | 0, et = et + Math.imul(wt, _t) | 0, et = et + Math.imul(kt, bt) | 0, ht = ht + Math.imul(kt, _t) | 0, ut = ut + Math.imul(vt, Pt) | 0, et = et + Math.imul(vt, Mt) | 0, et = et + Math.imul(Rt, Pt) | 0, ht = ht + Math.imul(Rt, Mt) | 0, ut = ut + Math.imul(pt, Dt) | 0, et = et + Math.imul(pt, zt) | 0, et = et + Math.imul(mt, Dt) | 0, ht = ht + Math.imul(mt, zt) | 0, ut = ut + Math.imul(at, Gt) | 0, et = et + Math.imul(at, Ut) | 0, et = et + Math.imul(ct, Gt) | 0, ht = ht + Math.imul(ct, Ut) | 0, ut = ut + Math.imul(rt, Zt) | 0, et = et + Math.imul(rt, Xt) | 0, et = et + Math.imul(it, Zt) | 0, ht = ht + Math.imul(it, Xt) | 0, ut = ut + Math.imul(Z, Qt) | 0, et = et + Math.imul(Z, $t) | 0, et = et + Math.imul(tt, Qt) | 0, ht = ht + Math.imul(tt, $t) | 0; let ve = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, ut = Math.imul(jt, Ot), et = Math.imul(jt, ft), et = et + Math.imul(Kt, Ot) | 0, ht = Math.imul(Kt, ft), ut = ut + Math.imul(Ct, bt) | 0, et = et + Math.imul(Ct, _t) | 0, et = et + Math.imul(Ft, bt) | 0, ht = ht + Math.imul(Ft, _t) | 0, ut = ut + Math.imul(wt, Pt) | 0, et = et + Math.imul(wt, Mt) | 0, et = et + Math.imul(kt, Pt) | 0, ht = ht + Math.imul(kt, Mt) | 0, ut = ut + Math.imul(vt, Dt) | 0, et = et + Math.imul(vt, zt) | 0, et = et + Math.imul(Rt, Dt) | 0, ht = ht + Math.imul(Rt, zt) | 0, ut = ut + Math.imul(pt, Gt) | 0, et = et + Math.imul(pt, Ut) | 0, et = et + Math.imul(mt, Gt) | 0, ht = ht + Math.imul(mt, Ut) | 0, ut = ut + Math.imul(at, Zt) | 0, et = et + Math.imul(at, Xt) | 0, et = et + Math.imul(ct, Zt) | 0, ht = ht + Math.imul(ct, Xt) | 0, ut = ut + Math.imul(rt, Qt) | 0, et = et + Math.imul(rt, $t) | 0, et = et + Math.imul(it, Qt) | 0, ht = ht + Math.imul(it, $t) | 0, ut = ut + Math.imul(Z, se) | 0, et = et + Math.imul(Z, Ht) | 0, et = et + Math.imul(tt, se) | 0, ht = ht + Math.imul(tt, Ht) | 0; let me = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, ut = Math.imul(St, Ot), et = Math.imul(St, ft), et = et + Math.imul(Nt, Ot) | 0, ht = Math.imul(Nt, ft), ut = ut + Math.imul(jt, bt) | 0, et = et + Math.imul(jt, _t) | 0, et = et + Math.imul(Kt, bt) | 0, ht = ht + Math.imul(Kt, _t) | 0, ut = ut + Math.imul(Ct, Pt) | 0, et = et + Math.imul(Ct, Mt) | 0, et = et + Math.imul(Ft, Pt) | 0, ht = ht + Math.imul(Ft, Mt) | 0, ut = ut + Math.imul(wt, Dt) | 0, et = et + Math.imul(wt, zt) | 0, et = et + Math.imul(kt, Dt) | 0, ht = ht + Math.imul(kt, zt) | 0, ut = ut + Math.imul(vt, Gt) | 0, et = et + Math.imul(vt, Ut) | 0, et = et + Math.imul(Rt, Gt) | 0, ht = ht + Math.imul(Rt, Ut) | 0, ut = ut + Math.imul(pt, Zt) | 0, et = et + Math.imul(pt, Xt) | 0, et = et + Math.imul(mt, Zt) | 0, ht = ht + Math.imul(mt, Xt) | 0, ut = ut + Math.imul(at, Qt) | 0, et = et + Math.imul(at, $t) | 0, et = et + Math.imul(ct, Qt) | 0, ht = ht + Math.imul(ct, $t) | 0, ut = ut + Math.imul(rt, se) | 0, et = et + Math.imul(rt, Ht) | 0, et = et + Math.imul(it, se) | 0, ht = ht + Math.imul(it, Ht) | 0, ut = ut + Math.imul(Z, yt) | 0, et = et + Math.imul(Z, ot) | 0, et = et + Math.imul(tt, yt) | 0, ht = ht + Math.imul(tt, ot) | 0; let _e = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, ut = Math.imul(Vt, Ot), et = Math.imul(Vt, ft), et = et + Math.imul(qt, Ot) | 0, ht = Math.imul(qt, ft), ut = ut + Math.imul(St, bt) | 0, et = et + Math.imul(St, _t) | 0, et = et + Math.imul(Nt, bt) | 0, ht = ht + Math.imul(Nt, _t) | 0, ut = ut + Math.imul(jt, Pt) | 0, et = et + Math.imul(jt, Mt) | 0, et = et + Math.imul(Kt, Pt) | 0, ht = ht + Math.imul(Kt, Mt) | 0, ut = ut + Math.imul(Ct, Dt) | 0, et = et + Math.imul(Ct, zt) | 0, et = et + Math.imul(Ft, Dt) | 0, ht = ht + Math.imul(Ft, zt) | 0, ut = ut + Math.imul(wt, Gt) | 0, et = et + Math.imul(wt, Ut) | 0, et = et + Math.imul(kt, Gt) | 0, ht = ht + Math.imul(kt, Ut) | 0, ut = ut + Math.imul(vt, Zt) | 0, et = et + Math.imul(vt, Xt) | 0, et = et + Math.imul(Rt, Zt) | 0, ht = ht + Math.imul(Rt, Xt) | 0, ut = ut + Math.imul(pt, Qt) | 0, et = et + Math.imul(pt, $t) | 0, et = et + Math.imul(mt, Qt) | 0, ht = ht + Math.imul(mt, $t) | 0, ut = ut + Math.imul(at, se) | 0, et = et + Math.imul(at, Ht) | 0, et = et + Math.imul(ct, se) | 0, ht = ht + Math.imul(ct, Ht) | 0, ut = ut + Math.imul(rt, yt) | 0, et = et + Math.imul(rt, ot) | 0, et = et + Math.imul(it, yt) | 0, ht = ht + Math.imul(it, ot) | 0, ut = ut + Math.imul(Z, It) | 0, et = et + Math.imul(Z, At) | 0, et = et + Math.imul(tt, It) | 0, ht = ht + Math.imul(tt, At) | 0; let ke = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, ut = Math.imul(Vt, bt), et = Math.imul(Vt, _t), et = et + Math.imul(qt, bt) | 0, ht = Math.imul(qt, _t), ut = ut + Math.imul(St, Pt) | 0, et = et + Math.imul(St, Mt) | 0, et = et + Math.imul(Nt, Pt) | 0, ht = ht + Math.imul(Nt, Mt) | 0, ut = ut + Math.imul(jt, Dt) | 0, et = et + Math.imul(jt, zt) | 0, et = et + Math.imul(Kt, Dt) | 0, ht = ht + Math.imul(Kt, zt) | 0, ut = ut + Math.imul(Ct, Gt) | 0, et = et + Math.imul(Ct, Ut) | 0, et = et + Math.imul(Ft, Gt) | 0, ht = ht + Math.imul(Ft, Ut) | 0, ut = ut + Math.imul(wt, Zt) | 0, et = et + Math.imul(wt, Xt) | 0, et = et + Math.imul(kt, Zt) | 0, ht = ht + Math.imul(kt, Xt) | 0, ut = ut + Math.imul(vt, Qt) | 0, et = et + Math.imul(vt, $t) | 0, et = et + Math.imul(Rt, Qt) | 0, ht = ht + Math.imul(Rt, $t) | 0, ut = ut + Math.imul(pt, se) | 0, et = et + Math.imul(pt, Ht) | 0, et = et + Math.imul(mt, se) | 0, ht = ht + Math.imul(mt, Ht) | 0, ut = ut + Math.imul(at, yt) | 0, et = et + Math.imul(at, ot) | 0, et = et + Math.imul(ct, yt) | 0, ht = ht + Math.imul(ct, ot) | 0, ut = ut + Math.imul(rt, It) | 0, et = et + Math.imul(rt, At) | 0, et = et + Math.imul(it, It) | 0, ht = ht + Math.imul(it, At) | 0; let Te = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, ut = Math.imul(Vt, Pt), et = Math.imul(Vt, Mt), et = et + Math.imul(qt, Pt) | 0, ht = Math.imul(qt, Mt), ut = ut + Math.imul(St, Dt) | 0, et = et + Math.imul(St, zt) | 0, et = et + Math.imul(Nt, Dt) | 0, ht = ht + Math.imul(Nt, zt) | 0, ut = ut + Math.imul(jt, Gt) | 0, et = et + Math.imul(jt, Ut) | 0, et = et + Math.imul(Kt, Gt) | 0, ht = ht + Math.imul(Kt, Ut) | 0, ut = ut + Math.imul(Ct, Zt) | 0, et = et + Math.imul(Ct, Xt) | 0, et = et + Math.imul(Ft, Zt) | 0, ht = ht + Math.imul(Ft, Xt) | 0, ut = ut + Math.imul(wt, Qt) | 0, et = et + Math.imul(wt, $t) | 0, et = et + Math.imul(kt, Qt) | 0, ht = ht + Math.imul(kt, $t) | 0, ut = ut + Math.imul(vt, se) | 0, et = et + Math.imul(vt, Ht) | 0, et = et + Math.imul(Rt, se) | 0, ht = ht + Math.imul(Rt, Ht) | 0, ut = ut + Math.imul(pt, yt) | 0, et = et + Math.imul(pt, ot) | 0, et = et + Math.imul(mt, yt) | 0, ht = ht + Math.imul(mt, ot) | 0, ut = ut + Math.imul(at, It) | 0, et = et + Math.imul(at, At) | 0, et = et + Math.imul(ct, It) | 0, ht = ht + Math.imul(ct, At) | 0; let Ce = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, ut = Math.imul(Vt, Dt), et = Math.imul(Vt, zt), et = et + Math.imul(qt, Dt) | 0, ht = Math.imul(qt, zt), ut = ut + Math.imul(St, Gt) | 0, et = et + Math.imul(St, Ut) | 0, et = et + Math.imul(Nt, Gt) | 0, ht = ht + Math.imul(Nt, Ut) | 0, ut = ut + Math.imul(jt, Zt) | 0, et = et + Math.imul(jt, Xt) | 0, et = et + Math.imul(Kt, Zt) | 0, ht = ht + Math.imul(Kt, Xt) | 0, ut = ut + Math.imul(Ct, Qt) | 0, et = et + Math.imul(Ct, $t) | 0, et = et + Math.imul(Ft, Qt) | 0, ht = ht + Math.imul(Ft, $t) | 0, ut = ut + Math.imul(wt, se) | 0, et = et + Math.imul(wt, Ht) | 0, et = et + Math.imul(kt, se) | 0, ht = ht + Math.imul(kt, Ht) | 0, ut = ut + Math.imul(vt, yt) | 0, et = et + Math.imul(vt, ot) | 0, et = et + Math.imul(Rt, yt) | 0, ht = ht + Math.imul(Rt, ot) | 0, ut = ut + Math.imul(pt, It) | 0, et = et + Math.imul(pt, At) | 0, et = et + Math.imul(mt, It) | 0, ht = ht + Math.imul(mt, At) | 0; let ae = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ae >>> 26) | 0, ae &= 67108863, ut = Math.imul(Vt, Gt), et = Math.imul(Vt, Ut), et = et + Math.imul(qt, Gt) | 0, ht = Math.imul(qt, Ut), ut = ut + Math.imul(St, Zt) | 0, et = et + Math.imul(St, Xt) | 0, et = et + Math.imul(Nt, Zt) | 0, ht = ht + Math.imul(Nt, Xt) | 0, ut = ut + Math.imul(jt, Qt) | 0, et = et + Math.imul(jt, $t) | 0, et = et + Math.imul(Kt, Qt) | 0, ht = ht + Math.imul(Kt, $t) | 0, ut = ut + Math.imul(Ct, se) | 0, et = et + Math.imul(Ct, Ht) | 0, et = et + Math.imul(Ft, se) | 0, ht = ht + Math.imul(Ft, Ht) | 0, ut = ut + Math.imul(wt, yt) | 0, et = et + Math.imul(wt, ot) | 0, et = et + Math.imul(kt, yt) | 0, ht = ht + Math.imul(kt, ot) | 0, ut = ut + Math.imul(vt, It) | 0, et = et + Math.imul(vt, At) | 0, et = et + Math.imul(Rt, It) | 0, ht = ht + Math.imul(Rt, At) | 0; let oe = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (oe >>> 26) | 0, oe &= 67108863, ut = Math.imul(Vt, Zt), et = Math.imul(Vt, Xt), et = et + Math.imul(qt, Zt) | 0, ht = Math.imul(qt, Xt), ut = ut + Math.imul(St, Qt) | 0, et = et + Math.imul(St, $t) | 0, et = et + Math.imul(Nt, Qt) | 0, ht = ht + Math.imul(Nt, $t) | 0, ut = ut + Math.imul(jt, se) | 0, et = et + Math.imul(jt, Ht) | 0, et = et + Math.imul(Kt, se) | 0, ht = ht + Math.imul(Kt, Ht) | 0, ut = ut + Math.imul(Ct, yt) | 0, et = et + Math.imul(Ct, ot) | 0, et = et + Math.imul(Ft, yt) | 0, ht = ht + Math.imul(Ft, ot) | 0, ut = ut + Math.imul(wt, It) | 0, et = et + Math.imul(wt, At) | 0, et = et + Math.imul(kt, It) | 0, ht = ht + Math.imul(kt, At) | 0; let Ie = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, ut = Math.imul(Vt, Qt), et = Math.imul(Vt, $t), et = et + Math.imul(qt, Qt) | 0, ht = Math.imul(qt, $t), ut = ut + Math.imul(St, se) | 0, et = et + Math.imul(St, Ht) | 0, et = et + Math.imul(Nt, se) | 0, ht = ht + Math.imul(Nt, Ht) | 0, ut = ut + Math.imul(jt, yt) | 0, et = et + Math.imul(jt, ot) | 0, et = et + Math.imul(Kt, yt) | 0, ht = ht + Math.imul(Kt, ot) | 0, ut = ut + Math.imul(Ct, It) | 0, et = et + Math.imul(Ct, At) | 0, et = et + Math.imul(Ft, It) | 0, ht = ht + Math.imul(Ft, At) | 0; let we = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, ut = Math.imul(Vt, se), et = Math.imul(Vt, Ht), et = et + Math.imul(qt, se) | 0, ht = Math.imul(qt, Ht), ut = ut + Math.imul(St, yt) | 0, et = et + Math.imul(St, ot) | 0, et = et + Math.imul(Nt, yt) | 0, ht = ht + Math.imul(Nt, ot) | 0, ut = ut + Math.imul(jt, It) | 0, et = et + Math.imul(jt, At) | 0, et = et + Math.imul(Kt, It) | 0, ht = ht + Math.imul(Kt, At) | 0; let Ee = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, ut = Math.imul(Vt, yt), et = Math.imul(Vt, ot), et = et + Math.imul(qt, yt) | 0, ht = Math.imul(qt, ot), ut = ut + Math.imul(St, It) | 0, et = et + Math.imul(St, At) | 0, et = et + Math.imul(Nt, It) | 0, ht = ht + Math.imul(Nt, At) | 0; let ge = (xt + ut | 0) + ((8191 & et) << 13) | 0; xt = (ht + (et >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, ut = Math.imul(Vt, It), et = Math.imul(Vt, At), et = et + Math.imul(qt, It) | 0, ht = Math.imul(qt, At); let be = (xt + ut | 0) + ((8191 & et) << 13) | 0; return xt = (ht + (et >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, V[0] = Jt, V[1] = pe, V[2] = fe, V[3] = ce, V[4] = ue, V[5] = le, V[6] = ve, V[7] = me, V[8] = _e, V[9] = ke, V[10] = Te, V[11] = Ce, V[12] = ae, V[13] = oe, V[14] = Ie, V[15] = we, V[16] = Ee, V[17] = ge, V[18] = be, xt !== 0 && (V[19] = xt, O.length += 1), O; } Math.imul || (U = C), p.Red = M, E.exports = p; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(1002);
            }, function (E, m, f) {
                "use strict";
                (function (d, r) { const e = f(42), c = d.crypto || d.msCrypto, n = c && typeof c.getRandomValues == "function", t = n ? c.getRandomValues.bind(c) : null, s = new Uint32Array(16); let u = 0; function i() { return (15 & u) == 0 && (o(s), u = 0), s[u++]; } function o(a) { if (!n)
                    throw new Error("Entropy source not available."); return t(a); } function h(a, l, p) { if (e(r.isBuffer(a)), e(a.buffer instanceof ArrayBuffer), e(a.byteOffset >>> 0 === a.byteOffset), e(a.byteLength >>> 0 === a.byteLength), e(l >>> 0 === l), e(p >>> 0 === p), e(l + p <= a.byteLength), p > 2 ** 31 - 1)
                    throw new RangeError('The value "size" is out of range.'); const g = a.byteOffset + l, b = new Uint8Array(a.buffer, g, p); if (b.length > 65536)
                    for (let I = 0; I < b.length; I += 65536) {
                        let v = I + 65536;
                        v > b.length && (v = b.length), o(b.subarray(I, v));
                    }
                else
                    b.length > 0 && o(b); } m.native = 0, m.randomBytes = function (a) { e(a >>> 0 === a); const l = r.alloc(a); return h(l, 0, a), l; }, m.randomFill = function (a, l, p) { return e(r.isBuffer(a)), l == null && (l = 0), e(l >>> 0 === l), p == null && (p = a.length - l), e(p >>> 0 === p), e(l + p <= a.length), h(a, l, p), a; }, m.randomInt = i, m.randomRange = function (a, l) { e(a >>> 0 === a), e(l >>> 0 === l), e(l >= a); const p = l - a; if (p === 0)
                    return a; const g = -p >>> 0; let b, I; do
                    b = i(), I = b % p;
                while (b - I > g); return I + a; }; }).call(this, f(10), f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42); function e(n) { r(d.isBuffer(n)); let t = 0; for (; t < n.length && n[t] === 0;)
                    t += 1; return n.slice(t); } function c(n) { r(d.isBuffer(n)); let t = n.length; for (; t > 0 && n[t - 1] === 0;)
                    t -= 1; return n.slice(0, t); } m.countLeft = function (n) { r(d.isBuffer(n)); let t = 0; for (; t < n.length && n[t] === 0;)
                    t += 1; let s = 8 * (n.length - t); if (s === 0)
                    return 0; s -= 8; let u = n[t]; for (; u;)
                    s += 1, u >>>= 1; return s; }, m.countRight = function (n) { r(d.isBuffer(n)); let t = n.length; for (; t > 0 && n[t - 1] === 0;)
                    t -= 1; let s = 8 * t; if (s === 0)
                    return 0; s -= 8; let u = n[t - 1]; for (; u;)
                    s += 1, u >>>= 1; return s; }, m.compareLeft = function (n, t) { r(d.isBuffer(n)), r(d.isBuffer(t)); let s = 0, u = n.length, i = 0, o = t.length; for (; u > 0 && n[s] === 0;)
                    s += 1, u -= 1; for (; o > 0 && t[i] === 0;)
                    i += 1, o -= 1; if (u < o)
                    return -1; if (u > o)
                    return 1; for (let h = 0; h < u; h++) {
                    if (n[s + h] < t[i + h])
                        return -1;
                    if (n[s + h] > t[i + h])
                        return 1;
                } return 0; }, m.compareRight = function (n, t) { r(d.isBuffer(n)), r(d.isBuffer(t)); let s = n.length, u = t.length; for (; s > 0 && n[s - 1] === 0;)
                    s -= 1; for (; u > 0 && t[u - 1] === 0;)
                    u -= 1; if (s < u)
                    return -1; if (s > u)
                    return 1; for (let i = s - 1; i >= 0; i--) {
                    if (n[i] < t[i])
                        return -1;
                    if (n[i] > t[i])
                        return 1;
                } return 0; }, m.trimLeft = e, m.trimRight = c, m.padLeft = function (n, t) { if (r(d.isBuffer(n)), r(t >>> 0 === t), n.length > t && (n = e(n)), n.length > t)
                    throw new RangeError(`Buffer expected to be ${t} bytes in size.`); const s = d.alloc(t, 0); return n.copy(s, t - n.length), s; }, m.padRight = function (n, t) { if (r(d.isBuffer(n)), r(t >>> 0 === t), n.length > t && (n = c(n)), n.length > t)
                    throw new RangeError(`Buffer expected to be ${t} bytes in size.`); const s = d.alloc(t, 0); return n.copy(s, 0), s; }; }).call(this, f(3).Buffer);
            }, function (E) { E.exports = JSON.parse('{"naf":{"width":9,"points":[["67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c","1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"],["49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233","5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"],["14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107","31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"],["357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c","7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"],["14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb","2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"],["107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed","12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"],["4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1","12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"],["7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a","6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"],["1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472","3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"],["6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716","6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"],["2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95","23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"],["794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455","71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"],["163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079","631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"],["39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d","4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"],["38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9","42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"],["5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1","54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"],["7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb","01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"],["05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3","6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"],["624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3","5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"],["1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9","5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"],["396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101","7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"],["53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50","2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"],["34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368","299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"],["5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618","680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"],["27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb","0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"],["0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a","42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"],["4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a","5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"],["1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817","0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"],["4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc","503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"],["3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6","62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"],["649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a","1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"],["3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56","15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"],["2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1","08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"],["642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385","21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"],["38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef","458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"],["372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db","32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"],["1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77","42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"],["38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5","1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"],["176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7","7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"],["042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6","42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"],["1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108","1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"],["613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5","3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"],["27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9","16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"],["769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2","22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"],["795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d","756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"],["644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46","173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"],["5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110","4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"],["296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848","0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"],["408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f","4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"],["07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07","6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"],["2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873","215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"],["1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a","5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"],["5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97","69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"],["24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb","6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"],["64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538","513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"],["47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e","7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"],["4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f","4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"],["3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5","689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"],["61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10","63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"],["03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414","74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"],["0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9","1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"],["797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe","5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"],["735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd","384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"],["6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac","61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"],["5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773","7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"],["31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8","1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"],["424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0","34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"],["33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247","37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"],["5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb","382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"],["3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036","09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"],["62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973","5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"],["0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3","6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"],["6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e","74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"],["4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f","41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"],["65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741","67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"],["1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8","7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"],["2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71","7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"],["1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6","153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"],["0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129","7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"],["01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4","60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"],["79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150","53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"],["220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498","05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"],["1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18","22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"],["35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b","155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"],["3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd","379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"],["6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf","1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"],["7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123","34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"],["354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf","7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"],["1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850","2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"],["533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d","6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"],["4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b","1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"],["3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265","025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"],["5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6","5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"],["2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9","2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"],["79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1","6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"],["57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63","14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"],["6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523","2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"],["749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9","7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"],["340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1","64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"],["4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109","3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"],["34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb","7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"],["820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e","756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"],["0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3","34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"],["5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b","54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"],["755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc","0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"],["5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b","6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"],["1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46","5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"],["4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d","45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"],["63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91","46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"],["5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87","3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"],["62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec","562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"],["14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556","447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"],["1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6","52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"],["5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3","41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"],["4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607","3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"],["62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08","4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"],["4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757","2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"],["5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3","547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"],["424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015","74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"],["54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd","6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"],["732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb","1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"],["74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb","501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"],["04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7","71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"],["2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794","2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"],["555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6","6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"],["4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6","2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"],["5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16","315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"]]},"doubles":{"step":4,"points":[["23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8","709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"],["5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556","0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"],["7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea","59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"],["5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565","2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"],["06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed","07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"],["0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77","21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"],["1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b","0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"],["4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb","6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"],["2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0","7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"],["0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5","3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"],["52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e","7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"],["52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52","50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"],["6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4","727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"],["71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4","39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"],["57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5","6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"],["6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202","0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"],["71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226","3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"],["1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f","779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"],["22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc","631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"],["608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4","3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"],["3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02","0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"],["69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5","3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"],["1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622","295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"],["51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0","35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"],["3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845","7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"],["1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f","0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"],["49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac","3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"],["4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b","6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"],["6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb","2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"],["4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424","314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"],["0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586","47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"],["4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824","5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"],["53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534","5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"],["7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6","1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"],["78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe","0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"],["2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91","7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"],["0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7","16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"],["1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a","7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"],["31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46","77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"],["543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031","0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"],["0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a","187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"],["7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a","0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"],["472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b","10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"],["04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a","3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"],["2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e","653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"],["0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325","3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"],["0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128","1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"],["1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d","61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"],["469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d","0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"],["5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb","505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"],["11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1","43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"],["3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb","2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"],["0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398","54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"],["1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c","299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"],["25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35","179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"],["75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f","696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"],["5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a","10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"],["7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07","604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"],["2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26","68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"],["28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787","552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"],["59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b","3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"],["5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f","67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"],["6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec","5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"],["53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699","404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"]]}}'); }, function (E, m, f) {
                "use strict";
                const d = f(1006), r = f(99), e = f(35);
                E.exports = (c, n = {}) => { const t = r(c), s = e.decode.fromReader(t.reader, n); let u = !1; const i = { read: async (o) => { const { value: h, done: a } = await t.reader.next(o); if (a && h.length < o)
                        throw new Error("Couldn't read enough bytes"); if (u = a, !h)
                        throw new Error("Value is null"); return h; }, readLP: async () => { const { value: o, done: h } = await s.next(); if (u = h, !o)
                        throw new Error("Value is null"); return o; }, readPB: async (o) => { const h = await i.readLP(); if (!h)
                        throw new Error("Value is null"); const a = d(h) ? h : h.slice(); return o.decode(a); }, write: o => { t.writer.push(o); }, writeLP: o => { i.write(e.encode.single(o, n)); }, writePB: (o, h) => { i.writeLP(h.encode(o)); }, pb: o => ({ read: () => i.readPB(o), write: h => i.writePB(h, o) }), unwrap: () => (t.rest(), t.stream) }; return i; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { return d != null && d.constructor != null && typeof d.constructor.isBuffer == "function" && d.constructor.isBuffer(d); };
            }, function (E, m, f) {
                "use strict";
                var d = f(1008);
                E.exports = function () { var r = d(), e = d(); return [{ source: r.source, sink: e.sink }, { source: e.source, sink: r.sink }]; };
            }, function (E, m, f) {
                "use strict";
                const d = f(192);
                E.exports = function () { let r, e; return { sink: async (c) => { if (r)
                        throw new Error("already piped"); r = d(c), e && e(r); }, source: { [Symbol.asyncIterator]() { return this; }, next: () => r ? r.next() : new Promise(c => { e = n => { e = null, c(n.next()); }; }) } }; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.XX = void 0;
                const d = f(3), r = f(57), e = f(387);
                class c extends e.AbstractHandshake {
                    initializeInitiator(t, s, u, i) { const o = this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256"); return this.mixHash(o, t), { ss: o, s, rs: u, psk: i, re: d.Buffer.alloc(32) }; }
                    initializeResponder(t, s, u, i) { const o = this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256"); return this.mixHash(o, t), { ss: o, s, rs: u, psk: i, re: d.Buffer.alloc(32) }; }
                    writeMessageA(t, s, u) { const i = d.Buffer.alloc(0); t.e = u || r.generateKeypair(); const o = t.e.publicKey; return this.mixHash(t.ss, o), { ne: o, ns: i, ciphertext: this.encryptAndHash(t.ss, s) }; }
                    writeMessageB(t, s) { t.e = r.generateKeypair(); const u = t.e.publicKey; this.mixHash(t.ss, u), this.mixKey(t.ss, this.dh(t.e.privateKey, t.re)); const i = d.Buffer.from(t.s.publicKey), o = this.encryptAndHash(t.ss, i); return this.mixKey(t.ss, this.dh(t.s.privateKey, t.re)), { ne: u, ns: o, ciphertext: this.encryptAndHash(t.ss, s) }; }
                    writeMessageC(t, s) { const u = d.Buffer.from(t.s.publicKey), i = this.encryptAndHash(t.ss, u); this.mixKey(t.ss, this.dh(t.s.privateKey, t.re)); const o = this.encryptAndHash(t.ss, s), h = { ne: this.createEmptyKey(), ns: i, ciphertext: o }, { cs1: a, cs2: l } = this.split(t.ss); return { h: t.ss.h, messageBuffer: h, cs1: a, cs2: l }; }
                    readMessageA(t, s) { return r.isValidPublicKey(s.ne) && (t.re = s.ne), this.mixHash(t.ss, t.re), this.decryptAndHash(t.ss, s.ciphertext); }
                    readMessageB(t, s) { if (r.isValidPublicKey(s.ne) && (t.re = s.ne), this.mixHash(t.ss, t.re), !t.e)
                        throw new Error("Handshake state `e` param is missing."); this.mixKey(t.ss, this.dh(t.e.privateKey, t.re)); const { plaintext: u, valid: i } = this.decryptAndHash(t.ss, s.ns); i && u.length === 32 && r.isValidPublicKey(u) && (t.rs = u), this.mixKey(t.ss, this.dh(t.e.privateKey, t.rs)); const { plaintext: o, valid: h } = this.decryptAndHash(t.ss, s.ciphertext); return { plaintext: o, valid: i && h }; }
                    readMessageC(t, s) { const { plaintext: u, valid: i } = this.decryptAndHash(t.ss, s.ns); if (i && u.length === 32 && r.isValidPublicKey(u) && (t.rs = u), !t.e)
                        throw new Error("Handshake state `e` param is missing."); this.mixKey(t.ss, this.dh(t.e.privateKey, t.rs)); const { plaintext: o, valid: h } = this.decryptAndHash(t.ss, s.ciphertext), { cs1: a, cs2: l } = this.split(t.ss); return { h: t.ss.h, plaintext: o, valid: i && h, cs1: a, cs2: l }; }
                    initSession(t, s, u) { const i = this.createEmptyKey(), o = d.Buffer.alloc(32); let h; return h = t ? this.initializeInitiator(s, u, o, i) : this.initializeResponder(s, u, o, i), { hs: h, i: t, mc: 0 }; }
                    sendMessage(t, s, u) { let i; if (t.mc === 0)
                        i = this.writeMessageA(t.hs, s, u);
                    else if (t.mc === 1)
                        i = this.writeMessageB(t.hs, s);
                    else if (t.mc === 2) {
                        const { h: o, messageBuffer: h, cs1: a, cs2: l } = this.writeMessageC(t.hs, s);
                        i = h, t.h = o, t.cs1 = a, t.cs2 = l;
                    }
                    else {
                        if (!(t.mc > 2))
                            throw new Error("Session invalid.");
                        if (t.i) {
                            if (!t.cs1)
                                throw new Error("CS1 (cipher state) is not defined");
                            i = this.writeMessageRegular(t.cs1, s);
                        }
                        else {
                            if (!t.cs2)
                                throw new Error("CS2 (cipher state) is not defined");
                            i = this.writeMessageRegular(t.cs2, s);
                        }
                    } return t.mc++, i; }
                    recvMessage(t, s) { let u = d.Buffer.alloc(0), i = !1; if (t.mc === 0)
                        ({ plaintext: u, valid: i } = this.readMessageA(t.hs, s));
                    else if (t.mc === 1)
                        ({ plaintext: u, valid: i } = this.readMessageB(t.hs, s));
                    else if (t.mc === 2) {
                        const { h: o, plaintext: h, valid: a, cs1: l, cs2: p } = this.readMessageC(t.hs, s);
                        u = h, i = a, t.h = o, t.cs1 = l, t.cs2 = p;
                    } return t.mc++, { plaintext: u, valid: i }; }
                }
                m.XX = c;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(1011);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42); function e(n, t, s) { return r(n && typeof n.id == "string"), t == null && (t = d.alloc(0)), s == null && (s = d.alloc(n.size, 0)), n.mac(t, s); } function c(n, t, s, u) { if (s == null && (s = d.alloc(0)), r(n && typeof n.id == "string"), r(d.isBuffer(t)), r(d.isBuffer(s)), r(u >>> 0 === u), t.length !== n.size)
                    throw new RangeError("Invalid PRK length."); const i = Math.ceil(u / n.size); if (i > 255)
                    throw new RangeError("Invalid output length."); const o = d.alloc(i * n.size), h = d.from([0]), a = n.hmac(); let l = d.alloc(0), p = 0; for (let g = 0; g < i; g++)
                    h[0] += 1, a.init(t), a.update(l), a.update(s), a.update(h), l = a.final(), p += l.copy(o, p); return o.slice(0, u); } m.native = 0, m.extract = e, m.expand = c, m.derive = function (n, t, s, u, i) { return c(n, e(n, t, s), u, i); }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42); E.exports = class {
                    constructor(e, c, n = [], t = []) { r(typeof e == "function"), r(c >>> 0 === c), r(Array.isArray(n)), r(Array.isArray(t)), this.hash = e, this.size = c, this.x = n, this.y = t, this.inner = new e, this.outer = new e; }
                    init(e) { if (r(d.isBuffer(e)), e.length > this.size) {
                        const n = new this.hash;
                        n.init(...this.x), n.update(e), e = n.final(...this.y), r(e.length <= this.size);
                    } const c = d.alloc(this.size); for (let n = 0; n < e.length; n++)
                        c[n] = 54 ^ e[n]; for (let n = e.length; n < c.length; n++)
                        c[n] = 54; this.inner.init(...this.x), this.inner.update(c); for (let n = 0; n < e.length; n++)
                        c[n] = 92 ^ e[n]; for (let n = e.length; n < c.length; n++)
                        c[n] = 92; return this.outer.init(...this.x), this.outer.update(c), this; }
                    update(e) { return this.inner.update(e), this; }
                    final() { return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y); }
                }; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                var d, r, e;
                r = [f(1014)], (e = typeof (d = function (c) { var n, t = c.Reader, s = c.Writer, u = c.util, i = c.roots.default || (c.roots.default = {}); return i.pb = ((n = {}).NoiseHandshakePayload = function () { function o(h) { if (h)
                    for (var a = Object.keys(h), l = 0; l < a.length; ++l)
                        h[a[l]] != null && (this[a[l]] = h[a[l]]); } return o.prototype.identityKey = u.newBuffer([]), o.prototype.identitySig = u.newBuffer([]), o.prototype.data = u.newBuffer([]), o.create = function (h) { return new o(h); }, o.encode = function (h, a) { return a || (a = s.create()), h.identityKey != null && h.hasOwnProperty("identityKey") && a.uint32(10).bytes(h.identityKey), h.identitySig != null && h.hasOwnProperty("identitySig") && a.uint32(18).bytes(h.identitySig), h.data != null && h.hasOwnProperty("data") && a.uint32(26).bytes(h.data), a; }, o.encodeDelimited = function (h, a) { return this.encode(h, a).ldelim(); }, o.decode = function (h, a) { h instanceof t || (h = t.create(h)); for (var l = a === void 0 ? h.len : h.pos + a, p = new i.pb.NoiseHandshakePayload; h.pos < l;) {
                    var g = h.uint32();
                    switch (g >>> 3) {
                        case 1:
                            p.identityKey = h.bytes();
                            break;
                        case 2:
                            p.identitySig = h.bytes();
                            break;
                        case 3:
                            p.data = h.bytes();
                            break;
                        default: h.skipType(7 & g);
                    }
                } return p; }, o.decodeDelimited = function (h) { return h instanceof t || (h = new t(h)), this.decode(h, h.uint32()); }, o.verify = function (h) { return typeof h != "object" || h === null ? "object expected" : h.identityKey != null && h.hasOwnProperty("identityKey") && !(h.identityKey && typeof h.identityKey.length == "number" || u.isString(h.identityKey)) ? "identityKey: buffer expected" : h.identitySig != null && h.hasOwnProperty("identitySig") && !(h.identitySig && typeof h.identitySig.length == "number" || u.isString(h.identitySig)) ? "identitySig: buffer expected" : h.data != null && h.hasOwnProperty("data") && !(h.data && typeof h.data.length == "number" || u.isString(h.data)) ? "data: buffer expected" : null; }, o.fromObject = function (h) { if (h instanceof i.pb.NoiseHandshakePayload)
                    return h; var a = new i.pb.NoiseHandshakePayload; return h.identityKey != null && (typeof h.identityKey == "string" ? u.base64.decode(h.identityKey, a.identityKey = u.newBuffer(u.base64.length(h.identityKey)), 0) : h.identityKey.length && (a.identityKey = h.identityKey)), h.identitySig != null && (typeof h.identitySig == "string" ? u.base64.decode(h.identitySig, a.identitySig = u.newBuffer(u.base64.length(h.identitySig)), 0) : h.identitySig.length && (a.identitySig = h.identitySig)), h.data != null && (typeof h.data == "string" ? u.base64.decode(h.data, a.data = u.newBuffer(u.base64.length(h.data)), 0) : h.data.length && (a.data = h.data)), a; }, o.toObject = function (h, a) { a || (a = {}); var l = {}; return a.defaults && (a.bytes === String ? l.identityKey = "" : (l.identityKey = [], a.bytes !== Array && (l.identityKey = u.newBuffer(l.identityKey))), a.bytes === String ? l.identitySig = "" : (l.identitySig = [], a.bytes !== Array && (l.identitySig = u.newBuffer(l.identitySig))), a.bytes === String ? l.data = "" : (l.data = [], a.bytes !== Array && (l.data = u.newBuffer(l.data)))), h.identityKey != null && h.hasOwnProperty("identityKey") && (l.identityKey = a.bytes === String ? u.base64.encode(h.identityKey, 0, h.identityKey.length) : a.bytes === Array ? Array.prototype.slice.call(h.identityKey) : h.identityKey), h.identitySig != null && h.hasOwnProperty("identitySig") && (l.identitySig = a.bytes === String ? u.base64.encode(h.identitySig, 0, h.identitySig.length) : a.bytes === Array ? Array.prototype.slice.call(h.identitySig) : h.identitySig), h.data != null && h.hasOwnProperty("data") && (l.data = a.bytes === String ? u.base64.encode(h.data, 0, h.data.length) : a.bytes === Array ? Array.prototype.slice.call(h.data) : h.data), l; }, o.prototype.toJSON = function () { return this.constructor.toObject(this, c.util.toJSONOptions); }, o; }(), n), i; }) == "function" ? d.apply(m, r) : d) === void 0 || (E.exports = e);
            }, function (E, m, f) {
                "use strict";
                E.exports = f(1015);
            }, function (E, m, f) {
                "use strict";
                var d = m;
                function r() { d.util._configure(), d.Writer._configure(d.BufferWriter), d.Reader._configure(d.BufferReader); }
                d.build = "minimal", d.Writer = f(385), d.BufferWriter = f(1024), d.Reader = f(386), d.BufferReader = f(1025), d.util = f(58), d.rpc = f(1026), d.roots = f(1028), d.configure = r, r();
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r) { for (var e = new Array(arguments.length - 1), c = 0, n = 2, t = !0; n < arguments.length;)
                    e[c++] = arguments[n++]; return new Promise(function (s, u) { e[c] = function (i) { if (t)
                    if (t = !1, i)
                        u(i);
                    else {
                        for (var o = new Array(arguments.length - 1), h = 0; h < o.length;)
                            o[h++] = arguments[h];
                        s.apply(null, o);
                    } }; try {
                    d.apply(r || null, e);
                }
                catch (i) {
                    t && (t = !1, u(i));
                } }); };
            }, function (E, m, f) {
                "use strict";
                var d = m;
                d.length = function (n) { var t = n.length; if (!t)
                    return 0; for (var s = 0; --t % 4 > 1 && n.charAt(t) === "=";)
                    ++s; return Math.ceil(3 * n.length) / 4 - s; };
                for (var r = new Array(64), e = new Array(123), c = 0; c < 64;)
                    e[r[c] = c < 26 ? c + 65 : c < 52 ? c + 71 : c < 62 ? c - 4 : c - 59 | 43] = c++;
                d.encode = function (n, t, s) { for (var u, i = null, o = [], h = 0, a = 0; t < s;) {
                    var l = n[t++];
                    switch (a) {
                        case 0:
                            o[h++] = r[l >> 2], u = (3 & l) << 4, a = 1;
                            break;
                        case 1:
                            o[h++] = r[u | l >> 4], u = (15 & l) << 2, a = 2;
                            break;
                        case 2: o[h++] = r[u | l >> 6], o[h++] = r[63 & l], a = 0;
                    }
                    h > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), h = 0);
                } return a && (o[h++] = r[u], o[h++] = 61, a === 1 && (o[h++] = 61)), i ? (h && i.push(String.fromCharCode.apply(String, o.slice(0, h))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, h)); }, d.decode = function (n, t, s) { for (var u, i = s, o = 0, h = 0; h < n.length;) {
                    var a = n.charCodeAt(h++);
                    if (a === 61 && o > 1)
                        break;
                    if ((a = e[a]) === void 0)
                        throw Error("invalid encoding");
                    switch (o) {
                        case 0:
                            u = a, o = 1;
                            break;
                        case 1:
                            t[s++] = u << 2 | (48 & a) >> 4, u = a, o = 2;
                            break;
                        case 2:
                            t[s++] = (15 & u) << 4 | (60 & a) >> 2, u = a, o = 3;
                            break;
                        case 3: t[s++] = (3 & u) << 6 | a, o = 0;
                    }
                } if (o === 1)
                    throw Error("invalid encoding"); return s - i; }, d.test = function (n) { return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(n); };
            }, function (E, m, f) {
                "use strict";
                function d() { this._listeners = {}; }
                E.exports = d, d.prototype.on = function (r, e, c) { return (this._listeners[r] || (this._listeners[r] = [])).push({ fn: e, ctx: c || this }), this; }, d.prototype.off = function (r, e) { if (r === void 0)
                    this._listeners = {};
                else if (e === void 0)
                    this._listeners[r] = [];
                else
                    for (var c = this._listeners[r], n = 0; n < c.length;)
                        c[n].fn === e ? c.splice(n, 1) : ++n; return this; }, d.prototype.emit = function (r) { var e = this._listeners[r]; if (e) {
                    for (var c = [], n = 1; n < arguments.length;)
                        c.push(arguments[n++]);
                    for (n = 0; n < e.length;)
                        e[n].fn.apply(e[n++].ctx, c);
                } return this; };
            }, function (E, m, f) {
                "use strict";
                function d(t) { return typeof Float32Array != "undefined" ? function () { var s = new Float32Array([-0]), u = new Uint8Array(s.buffer), i = u[3] === 128; function o(p, g, b) { s[0] = p, g[b] = u[0], g[b + 1] = u[1], g[b + 2] = u[2], g[b + 3] = u[3]; } function h(p, g, b) { s[0] = p, g[b] = u[3], g[b + 1] = u[2], g[b + 2] = u[1], g[b + 3] = u[0]; } function a(p, g) { return u[0] = p[g], u[1] = p[g + 1], u[2] = p[g + 2], u[3] = p[g + 3], s[0]; } function l(p, g) { return u[3] = p[g], u[2] = p[g + 1], u[1] = p[g + 2], u[0] = p[g + 3], s[0]; } t.writeFloatLE = i ? o : h, t.writeFloatBE = i ? h : o, t.readFloatLE = i ? a : l, t.readFloatBE = i ? l : a; }() : function () { function s(i, o, h, a) { var l = o < 0 ? 1 : 0; if (l && (o = -o), o === 0)
                    i(1 / o > 0 ? 0 : 2147483648, h, a);
                else if (isNaN(o))
                    i(2143289344, h, a);
                else if (o > 34028234663852886e22)
                    i((l << 31 | 2139095040) >>> 0, h, a);
                else if (o < 11754943508222875e-54)
                    i((l << 31 | Math.round(o / 1401298464324817e-60)) >>> 0, h, a);
                else {
                    var p = Math.floor(Math.log(o) / Math.LN2);
                    i((l << 31 | p + 127 << 23 | 8388607 & Math.round(o * Math.pow(2, -p) * 8388608)) >>> 0, h, a);
                } } function u(i, o, h) { var a = i(o, h), l = 2 * (a >> 31) + 1, p = a >>> 23 & 255, g = 8388607 & a; return p === 255 ? g ? NaN : l * (1 / 0) : p === 0 ? 1401298464324817e-60 * l * g : l * Math.pow(2, p - 150) * (g + 8388608); } t.writeFloatLE = s.bind(null, r), t.writeFloatBE = s.bind(null, e), t.readFloatLE = u.bind(null, c), t.readFloatBE = u.bind(null, n); }(), typeof Float64Array != "undefined" ? function () { var s = new Float64Array([-0]), u = new Uint8Array(s.buffer), i = u[7] === 128; function o(p, g, b) { s[0] = p, g[b] = u[0], g[b + 1] = u[1], g[b + 2] = u[2], g[b + 3] = u[3], g[b + 4] = u[4], g[b + 5] = u[5], g[b + 6] = u[6], g[b + 7] = u[7]; } function h(p, g, b) { s[0] = p, g[b] = u[7], g[b + 1] = u[6], g[b + 2] = u[5], g[b + 3] = u[4], g[b + 4] = u[3], g[b + 5] = u[2], g[b + 6] = u[1], g[b + 7] = u[0]; } function a(p, g) { return u[0] = p[g], u[1] = p[g + 1], u[2] = p[g + 2], u[3] = p[g + 3], u[4] = p[g + 4], u[5] = p[g + 5], u[6] = p[g + 6], u[7] = p[g + 7], s[0]; } function l(p, g) { return u[7] = p[g], u[6] = p[g + 1], u[5] = p[g + 2], u[4] = p[g + 3], u[3] = p[g + 4], u[2] = p[g + 5], u[1] = p[g + 6], u[0] = p[g + 7], s[0]; } t.writeDoubleLE = i ? o : h, t.writeDoubleBE = i ? h : o, t.readDoubleLE = i ? a : l, t.readDoubleBE = i ? l : a; }() : function () { function s(i, o, h, a, l, p) { var g = a < 0 ? 1 : 0; if (g && (a = -a), a === 0)
                    i(0, l, p + o), i(1 / a > 0 ? 0 : 2147483648, l, p + h);
                else if (isNaN(a))
                    i(0, l, p + o), i(2146959360, l, p + h);
                else if (a > 17976931348623157e292)
                    i(0, l, p + o), i((g << 31 | 2146435072) >>> 0, l, p + h);
                else {
                    var b;
                    if (a < 22250738585072014e-324)
                        i((b = a / 5e-324) >>> 0, l, p + o), i((g << 31 | b / 4294967296) >>> 0, l, p + h);
                    else {
                        var I = Math.floor(Math.log(a) / Math.LN2);
                        I === 1024 && (I = 1023), i(4503599627370496 * (b = a * Math.pow(2, -I)) >>> 0, l, p + o), i((g << 31 | I + 1023 << 20 | 1048576 * b & 1048575) >>> 0, l, p + h);
                    }
                } } function u(i, o, h, a, l) { var p = i(a, l + o), g = i(a, l + h), b = 2 * (g >> 31) + 1, I = g >>> 20 & 2047, v = 4294967296 * (1048575 & g) + p; return I === 2047 ? v ? NaN : b * (1 / 0) : I === 0 ? 5e-324 * b * v : b * Math.pow(2, I - 1075) * (v + 4503599627370496); } t.writeDoubleLE = s.bind(null, r, 0, 4), t.writeDoubleBE = s.bind(null, e, 4, 0), t.readDoubleLE = u.bind(null, c, 0, 4), t.readDoubleBE = u.bind(null, n, 4, 0); }(), t; }
                function r(t, s, u) { s[u] = 255 & t, s[u + 1] = t >>> 8 & 255, s[u + 2] = t >>> 16 & 255, s[u + 3] = t >>> 24; }
                function e(t, s, u) { s[u] = t >>> 24, s[u + 1] = t >>> 16 & 255, s[u + 2] = t >>> 8 & 255, s[u + 3] = 255 & t; }
                function c(t, s) { return (t[s] | t[s + 1] << 8 | t[s + 2] << 16 | t[s + 3] << 24) >>> 0; }
                function n(t, s) { return (t[s] << 24 | t[s + 1] << 16 | t[s + 2] << 8 | t[s + 3]) >>> 0; }
                E.exports = d(d);
            }, function (module, exports, __webpack_require__) {
                "use strict";
                function inquire(moduleName) { try {
                    var mod = eval("quire".replace(/^/, "re"))(moduleName);
                    if (mod && (mod.length || Object.keys(mod).length))
                        return mod;
                }
                catch (E) { } return null; }
                module.exports = inquire;
            }, function (E, m, f) {
                "use strict";
                var d = m;
                d.length = function (r) { for (var e = 0, c = 0, n = 0; n < r.length; ++n)
                    (c = r.charCodeAt(n)) < 128 ? e += 1 : c < 2048 ? e += 2 : (64512 & c) == 55296 && (64512 & r.charCodeAt(n + 1)) == 56320 ? (++n, e += 4) : e += 3; return e; }, d.read = function (r, e, c) { if (c - e < 1)
                    return ""; for (var n, t = null, s = [], u = 0; e < c;)
                    (n = r[e++]) < 128 ? s[u++] = n : n > 191 && n < 224 ? s[u++] = (31 & n) << 6 | 63 & r[e++] : n > 239 && n < 365 ? (n = ((7 & n) << 18 | (63 & r[e++]) << 12 | (63 & r[e++]) << 6 | 63 & r[e++]) - 65536, s[u++] = 55296 + (n >> 10), s[u++] = 56320 + (1023 & n)) : s[u++] = (15 & n) << 12 | (63 & r[e++]) << 6 | 63 & r[e++], u > 8191 && ((t || (t = [])).push(String.fromCharCode.apply(String, s)), u = 0); return t ? (u && t.push(String.fromCharCode.apply(String, s.slice(0, u))), t.join("")) : String.fromCharCode.apply(String, s.slice(0, u)); }, d.write = function (r, e, c) { for (var n, t, s = c, u = 0; u < r.length; ++u)
                    (n = r.charCodeAt(u)) < 128 ? e[c++] = n : n < 2048 ? (e[c++] = n >> 6 | 192, e[c++] = 63 & n | 128) : (64512 & n) == 55296 && (64512 & (t = r.charCodeAt(u + 1))) == 56320 ? (n = 65536 + ((1023 & n) << 10) + (1023 & t), ++u, e[c++] = n >> 18 | 240, e[c++] = n >> 12 & 63 | 128, e[c++] = n >> 6 & 63 | 128, e[c++] = 63 & n | 128) : (e[c++] = n >> 12 | 224, e[c++] = n >> 6 & 63 | 128, e[c++] = 63 & n | 128); return c - s; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { var c = e || 8192, n = c >>> 1, t = null, s = c; return function (u) { if (u < 1 || u > n)
                    return d(u); s + u > c && (t = d(c), s = 0); var i = r.call(t, s, s += u); return 7 & s && (s = 1 + (7 | s)), i; }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = r;
                var d = f(58);
                function r(t, s) { this.lo = t >>> 0, this.hi = s >>> 0; }
                var e = r.zero = new r(0, 0);
                e.toNumber = function () { return 0; }, e.zzEncode = e.zzDecode = function () { return this; }, e.length = function () { return 1; };
                var c = r.zeroHash = "\0\0\0\0\0\0\0\0";
                r.fromNumber = function (t) { if (t === 0)
                    return e; var s = t < 0; s && (t = -t); var u = t >>> 0, i = (t - u) / 4294967296 >>> 0; return s && (i = ~i >>> 0, u = ~u >>> 0, ++u > 4294967295 && (u = 0, ++i > 4294967295 && (i = 0))), new r(u, i); }, r.from = function (t) { if (typeof t == "number")
                    return r.fromNumber(t); if (d.isString(t)) {
                    if (!d.Long)
                        return r.fromNumber(parseInt(t, 10));
                    t = d.Long.fromString(t);
                } return t.low || t.high ? new r(t.low >>> 0, t.high >>> 0) : e; }, r.prototype.toNumber = function (t) { if (!t && this.hi >>> 31) {
                    var s = 1 + ~this.lo >>> 0, u = ~this.hi >>> 0;
                    return s || (u = u + 1 >>> 0), -(s + 4294967296 * u);
                } return this.lo + 4294967296 * this.hi; }, r.prototype.toLong = function (t) { return d.Long ? new d.Long(0 | this.lo, 0 | this.hi, Boolean(t)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t) }; };
                var n = String.prototype.charCodeAt;
                r.fromHash = function (t) { return t === c ? e : new r((n.call(t, 0) | n.call(t, 1) << 8 | n.call(t, 2) << 16 | n.call(t, 3) << 24) >>> 0, (n.call(t, 4) | n.call(t, 5) << 8 | n.call(t, 6) << 16 | n.call(t, 7) << 24) >>> 0); }, r.prototype.toHash = function () { return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24); }, r.prototype.zzEncode = function () { var t = this.hi >> 31; return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t) >>> 0, this.lo = (this.lo << 1 ^ t) >>> 0, this; }, r.prototype.zzDecode = function () { var t = -(1 & this.lo); return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t) >>> 0, this.hi = (this.hi >>> 1 ^ t) >>> 0, this; }, r.prototype.length = function () { var t = this.lo, s = (this.lo >>> 28 | this.hi << 4) >>> 0, u = this.hi >>> 24; return u === 0 ? s === 0 ? t < 16384 ? t < 128 ? 1 : 2 : t < 2097152 ? 3 : 4 : s < 16384 ? s < 128 ? 5 : 6 : s < 2097152 ? 7 : 8 : u < 128 ? 9 : 10; };
            }, function (E, m, f) {
                "use strict";
                E.exports = e;
                var d = f(385);
                (e.prototype = Object.create(d.prototype)).constructor = e;
                var r = f(58);
                function e() { d.call(this); }
                function c(n, t, s) { n.length < 40 ? r.utf8.write(n, t, s) : t.utf8Write ? t.utf8Write(n, s) : t.write(n, s); }
                e._configure = function () { e.alloc = r._Buffer_allocUnsafe, e.writeBytesBuffer = r.Buffer && r.Buffer.prototype instanceof Uint8Array && r.Buffer.prototype.set.name === "set" ? function (n, t, s) { t.set(n, s); } : function (n, t, s) { if (n.copy)
                    n.copy(t, s, 0, n.length);
                else
                    for (var u = 0; u < n.length;)
                        t[s++] = n[u++]; }; }, e.prototype.bytes = function (n) { r.isString(n) && (n = r._Buffer_from(n, "base64")); var t = n.length >>> 0; return this.uint32(t), t && this._push(e.writeBytesBuffer, t, n), this; }, e.prototype.string = function (n) { var t = r.Buffer.byteLength(n); return this.uint32(t), t && this._push(c, t, n), this; }, e._configure();
            }, function (E, m, f) {
                "use strict";
                E.exports = e;
                var d = f(386);
                (e.prototype = Object.create(d.prototype)).constructor = e;
                var r = f(58);
                function e(c) { d.call(this, c); }
                e._configure = function () { r.Buffer && (e.prototype._slice = r.Buffer.prototype.slice); }, e.prototype.string = function () { var c = this.uint32(); return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + c, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + c, this.len)); }, e._configure();
            }, function (E, m, f) {
                "use strict";
                m.Service = f(1027);
            }, function (E, m, f) {
                "use strict";
                E.exports = r;
                var d = f(58);
                function r(e, c, n) { if (typeof e != "function")
                    throw TypeError("rpcImpl must be a function"); d.EventEmitter.call(this), this.rpcImpl = e, this.requestDelimited = Boolean(c), this.responseDelimited = Boolean(n); }
                (r.prototype = Object.create(d.EventEmitter.prototype)).constructor = r, r.prototype.rpcCall = function e(c, n, t, s, u) { if (!s)
                    throw TypeError("request must be specified"); var i = this; if (!u)
                    return d.asPromise(e, i, c, n, t, s); if (i.rpcImpl)
                    try {
                        return i.rpcImpl(c, n[i.requestDelimited ? "encodeDelimited" : "encode"](s).finish(), function (o, h) { if (o)
                            return i.emit("error", o, c), u(o); if (h !== null) {
                            if (!(h instanceof t))
                                try {
                                    h = t[i.responseDelimited ? "decodeDelimited" : "decode"](h);
                                }
                                catch (a) {
                                    return i.emit("error", a, c), u(a);
                                }
                            return i.emit("data", h, c), u(null, h);
                        } i.end(!0); });
                    }
                    catch (o) {
                        return i.emit("error", o, c), void setTimeout(function () { u(o); }, 0);
                    }
                else
                    setTimeout(function () { u(Error("already ended")); }, 0); }, r.prototype.end = function (e) { return this.rpcImpl && (e || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this; };
            }, function (E, m, f) {
                "use strict";
                E.exports = {};
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42), e = f(1030), c = f(1031), n = d.alloc(16, 0); class t {
                    constructor() { this.chacha = new e, this.poly = new c, this.key = d.alloc(64), this.mode = -1, this.aadLen = 0, this.cipherLen = 0; }
                    init(o, h) { return r(d.isBuffer(o)), r(d.isBuffer(h)), this.key.fill(0), this.chacha.init(o, h, 0), this.chacha.encrypt(this.key), this.poly.init(this.key), this.mode = 0, this.aadLen = 0, this.cipherLen = 0, this; }
                    aad(o) { if (this.mode === -1)
                        throw new Error("Context is not initialized."); if (this.mode !== 0)
                        throw new Error("Invalid state for aad."); return this.poly.update(o), this.aadLen += o.length, this; }
                    encrypt(o) { if (this.mode === -1)
                        throw new Error("Context is not initialized."); if (this.mode !== 0 && this.mode !== 1)
                        throw new Error("Invalid state for encrypt."); return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 1), this.chacha.encrypt(o), this.poly.update(o), this.cipherLen += o.length, o; }
                    decrypt(o) { if (r(d.isBuffer(o)), this.mode === -1)
                        throw new Error("Context is not initialized."); if (this.mode !== 0 && this.mode !== 2)
                        throw new Error("Invalid state for decrypt."); return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 2), this.cipherLen += o.length, this.poly.update(o), this.chacha.encrypt(o), o; }
                    auth(o) { if (r(d.isBuffer(o)), this.mode === -1)
                        throw new Error("Context is not initialized."); if (this.mode !== 0 && this.mode !== 3)
                        throw new Error("Invalid state for auth."); return this.mode === 0 && (this._pad16(this.aadLen), this.mode = 3), this.cipherLen += o.length, this.poly.update(o), o; }
                    final() { if (this.mode === -1)
                        throw new Error("Context is not initialized."); const o = d.alloc(16); u(o, this.aadLen, 0), u(o, this.cipherLen, 8), this.mode === 0 && this._pad16(this.aadLen), this._pad16(this.cipherLen), this.poly.update(o); const h = this.poly.final(); return this.destroy(), h; }
                    destroy() { this.chacha.destroy(), this.poly.destroy(); for (let o = 0; o < 64; o++)
                        this.key[o] = 0; return this.mode = -1, this.aadLen = 0, this.cipherLen = 0, this; }
                    verify(o) { r(d.isBuffer(o)), r(o.length === 16); const h = this.final(); let a = 0; for (let l = 0; l < 16; l++)
                        a |= h[l] ^ o[l]; return a - 1 >>> 31 != 0; }
                    _pad16(o) { const h = 15 & o; h > 0 && this.poly.update(n.slice(0, 16 - h)); }
                    static encrypt(o, h, a, l) { const p = new t; return p.init(o, h), l && p.aad(l), p.encrypt(a), p.final(); }
                    static decrypt(o, h, a, l, p) { const g = new t; return g.init(o, h), p && g.aad(p), g.decrypt(a), g.verify(l); }
                    static auth(o, h, a, l, p) { const g = new t; return g.init(o, h), p && g.aad(p), g.auth(a), g.verify(l); }
                } function s(i, o, h) { return i[h++] = o, o >>>= 8, i[h++] = o, o >>>= 8, i[h++] = o, o >>>= 8, i[h++] = o, h; } function u(i, o, h) { const a = o * (1 / 4294967296) >>> 0; return s(i, o >>> 0, h + 0), s(i, a, h + 4), h + 8; } t.native = e.native, E.exports = t; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42), e = new Int8Array(new Int16Array([1]).buffer)[0] === 0; class c {
                    constructor() { this.state = new Uint32Array(16), this.stream = new Uint32Array(16), this.bytes = new Uint8Array(this.stream.buffer), this.pos = -1, e && (this.bytes = d.alloc(64)); }
                    init(o, h, a) { if (a == null && (a = 0), r(d.isBuffer(o)), r(d.isBuffer(h)), r(Number.isSafeInteger(a)), o.length !== 16 && o.length !== 32)
                        throw new RangeError("Invalid key size."); if (h.length >= 24 && (o = c.derive(o, h.slice(0, 16)), h = h.slice(16)), this.state[0] = 1634760805, this.state[1] = o.length < 32 ? 824206446 : 857760878, this.state[2] = o.length < 32 ? 2036477238 : 2036477234, this.state[3] = 1797285236, this.state[4] = s(o, 0), this.state[5] = s(o, 4), this.state[6] = s(o, 8), this.state[7] = s(o, 12), this.state[8] = s(o, 16 % o.length), this.state[9] = s(o, 20 % o.length), this.state[10] = s(o, 24 % o.length), this.state[11] = s(o, 28 % o.length), this.state[12] = a >>> 0, h.length === 8)
                        this.state[13] = a / 4294967296 >>> 0, this.state[14] = s(h, 0), this.state[15] = s(h, 4);
                    else if (h.length === 12)
                        this.state[13] = s(h, 0), this.state[14] = s(h, 4), this.state[15] = s(h, 8);
                    else {
                        if (h.length !== 16)
                            throw new RangeError("Invalid nonce size.");
                        this.state[12] = s(h, 0), this.state[13] = s(h, 4), this.state[14] = s(h, 8), this.state[15] = s(h, 12);
                    } return this.pos = 0, this; }
                    encrypt(o) { if (r(d.isBuffer(o)), this.pos === -1)
                        throw new Error("Context is not initialized."); for (let h = 0; h < o.length; h++)
                        (63 & this.pos) == 0 && (this._block(), this.pos = 0), o[h] ^= this.bytes[this.pos++]; return o; }
                    _block() { for (let o = 0; o < 16; o++)
                        this.stream[o] = this.state[o]; for (let o = 0; o < 10; o++)
                        n(this.stream, 0, 4, 8, 12), n(this.stream, 1, 5, 9, 13), n(this.stream, 2, 6, 10, 14), n(this.stream, 3, 7, 11, 15), n(this.stream, 0, 5, 10, 15), n(this.stream, 1, 6, 11, 12), n(this.stream, 2, 7, 8, 13), n(this.stream, 3, 4, 9, 14); for (let o = 0; o < 16; o++)
                        this.stream[o] += this.state[o]; if (e)
                        for (let o = 0; o < 16; o++)
                            u(this.bytes, this.stream[o], 4 * o); this.state[12] += 1, this.state[12] === 0 && (this.state[13] += 1); }
                    destroy() { for (let o = 0; o < 16; o++)
                        this.state[o] = 0, this.stream[o] = 0; if (e)
                        for (let o = 0; o < 64; o++)
                            this.bytes[o] = 0; return this.pos = -1, this; }
                    static derive(o, h) { if (r(d.isBuffer(o)), r(d.isBuffer(h)), o.length !== 16 && o.length !== 32)
                        throw new RangeError("Invalid key size."); if (h.length !== 16)
                        throw new RangeError("Invalid nonce size."); const a = new Uint32Array(16); a[0] = 1634760805, a[1] = o.length < 32 ? 824206446 : 857760878, a[2] = o.length < 32 ? 2036477238 : 2036477234, a[3] = 1797285236, a[4] = s(o, 0), a[5] = s(o, 4), a[6] = s(o, 8), a[7] = s(o, 12), a[8] = s(o, 16 % o.length), a[9] = s(o, 20 % o.length), a[10] = s(o, 24 % o.length), a[11] = s(o, 28 % o.length), a[12] = s(h, 0), a[13] = s(h, 4), a[14] = s(h, 8), a[15] = s(h, 12); for (let p = 0; p < 10; p++)
                        n(a, 0, 4, 8, 12), n(a, 1, 5, 9, 13), n(a, 2, 6, 10, 14), n(a, 3, 7, 11, 15), n(a, 0, 5, 10, 15), n(a, 1, 6, 11, 12), n(a, 2, 7, 8, 13), n(a, 3, 4, 9, 14); const l = d.alloc(32); return u(l, a[0], 0), u(l, a[1], 4), u(l, a[2], 8), u(l, a[3], 12), u(l, a[12], 16), u(l, a[13], 20), u(l, a[14], 24), u(l, a[15], 28), l; }
                } function n(i, o, h, a, l) { i[o] += i[h], i[l] = t(i[l] ^ i[o], 16), i[a] += i[l], i[h] = t(i[h] ^ i[a], 12), i[o] += i[h], i[l] = t(i[l] ^ i[o], 8), i[a] += i[l], i[h] = t(i[h] ^ i[a], 7); } function t(i, o) { return i << o | i >>> 32 - o; } function s(i, o) { return i[o++] + 256 * i[o++] + 65536 * i[o++] + 16777216 * i[o]; } function u(i, o, h) { return i[h++] = o, o >>>= 8, i[h++] = o, o >>>= 8, i[h++] = o, o >>>= 8, i[h++] = o, h; } c.native = 0, E.exports = c; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                (function (d) { const r = f(42); class e {
                    constructor() { this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.buffer = d.alloc(16), this.fin = -1, this.leftover = 0; }
                    init(s) { r(d.isBuffer(s) && s.length >= 32); const u = c(s, 0), i = c(s, 2), o = c(s, 4), h = c(s, 6), a = c(s, 8), l = c(s, 10), p = c(s, 12), g = c(s, 14); this.r[0] = 8191 & u, this.r[1] = 8191 & (u >>> 13 | i << 3), this.r[2] = 7939 & (i >>> 10 | o << 6), this.r[3] = 8191 & (o >>> 7 | h << 9), this.r[4] = 255 & (h >>> 4 | a << 12), this.r[5] = a >>> 1 & 8190, this.r[6] = 8191 & (a >>> 14 | l << 2), this.r[7] = 8065 & (l >>> 11 | p << 5), this.r[8] = 8191 & (p >>> 8 | g << 8), this.r[9] = g >>> 5 & 127; for (let b = 0; b < 10; b++)
                        this.h[b] = 0; for (let b = 0; b < 8; b++)
                        this.pad[b] = c(s, 16 + 2 * b); return this.fin = 0, this.leftover = 0, this; }
                    _blocks(s, u, i) { const o = this.fin ? 0 : 2048, h = new Uint32Array(10); for (; u >= 16;) {
                        const a = c(s, i + 0), l = c(s, i + 2), p = c(s, i + 4), g = c(s, i + 6), b = c(s, i + 8), I = c(s, i + 10), v = c(s, i + 12), R = c(s, i + 14);
                        this.h[0] += 8191 & a, this.h[1] += 8191 & (a >>> 13 | l << 3), this.h[2] += 8191 & (l >>> 10 | p << 6), this.h[3] += 8191 & (p >>> 7 | g << 9), this.h[4] += 8191 & (g >>> 4 | b << 12), this.h[5] += b >>> 1 & 8191, this.h[6] += 8191 & (b >>> 14 | I << 2), this.h[7] += 8191 & (I >>> 11 | v << 5), this.h[8] += 8191 & (v >>> 8 | R << 8), this.h[9] += R >>> 5 | o;
                        let _ = 0;
                        for (let k = 0; k < 10; k++) {
                            h[k] = _;
                            for (let x = 0; x < 10; x++) {
                                let M = this.h[x];
                                M *= x <= k ? this.r[k - x] : 5 * this.r[k + 10 - x], h[k] += M, x === 4 && (_ = h[k] >>> 13, h[k] &= 8191);
                            }
                            _ += h[k] >>> 13, h[k] &= 8191;
                        }
                        _ = (_ << 2) + _, _ += h[0], h[0] = 8191 & _, _ >>>= 13, h[1] += _;
                        for (let k = 0; k < 10; k++)
                            this.h[k] = h[k];
                        i += 16, u -= 16;
                    } }
                    update(s) { if (r(d.isBuffer(s)), this.fin === -1)
                        throw new Error("Context is not initialized."); let u = s.length, i = 0; if (this.leftover) {
                        let o = 16 - this.leftover;
                        o > u && (o = u);
                        for (let h = 0; h < o; h++)
                            this.buffer[this.leftover + h] = s[i + h];
                        if (u -= o, i += o, this.leftover += o, this.leftover < 16)
                            return this;
                        this._blocks(this.buffer, 16, 0), this.leftover = 0;
                    } if (u >= 16) {
                        const o = -16 & u;
                        this._blocks(s, o, i), i += o, u -= o;
                    } if (u) {
                        for (let o = 0; o < u; o++)
                            this.buffer[this.leftover + o] = s[i + o];
                        this.leftover += u;
                    } return this; }
                    final() { if (this.fin === -1)
                        throw new Error("Context is not initialized."); const s = d.alloc(16), u = new Uint16Array(10); if (this.leftover) {
                        let a = this.leftover;
                        for (this.buffer[a++] = 1; a < 16; a++)
                            this.buffer[a] = 0;
                        this.fin = 1, this._blocks(this.buffer, 16, 0);
                    } let i = this.h[1] >>> 13; this.h[1] &= 8191; for (let a = 2; a < 10; a++)
                        this.h[a] += i, i = this.h[a] >>> 13, this.h[a] &= 8191; this.h[0] += 5 * i, i = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += i, i = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += i, u[0] = this.h[0] + 5, i = u[0] >>> 13, u[0] &= 8191; for (let a = 1; a < 10; a++)
                        u[a] = this.h[a] + i, i = u[a] >>> 13, u[a] &= 8191; let o = (1 ^ i) - 1; for (let a = 0; a < 10; a++)
                        u[a] &= o; o = ~o; for (let a = 0; a < 10; a++)
                        this.h[a] = this.h[a] & o | u[a]; this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5); let h = this.h[0] + this.pad[0]; this.h[0] = h; for (let a = 1; a < 8; a++)
                        h = this.h[a] + this.pad[a] + (h >>> 16), this.h[a] = h; for (let a = 0; a < 8; a++)
                        n(s, this.h[a], 2 * a); return this.destroy(), s; }
                    destroy() { for (let s = 0; s < 10; s++)
                        this.r[s] = 0, this.h[s] = 0; for (let s = 0; s < 8; s++)
                        this.pad[s] = 0; for (let s = 0; s < 16; s++)
                        this.buffer[s] = 0; this.fin = -1, this.leftover = 0; }
                    verify(s) { r(d.isBuffer(s)), r(s.length === 16); const u = this.final(); let i = 0; for (let o = 0; o < 16; o++)
                        i |= u[o] ^ s[o]; return i - 1 >>> 31 != 0; }
                } function c(t, s) { return t[s++] + 256 * t[s]; } function n(t, s, u) { return t[u++] = s, t[u++] = s >>> 8, u; } e.native = 0, E.exports = e; }).call(this, f(3).Buffer);
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.IKHandshake = void 0;
                const d = f(1033), r = f(3), e = f(129), c = f(57), n = f(1034), t = f(101);
                m.IKHandshake = class {
                    constructor(s, u, i, o, h, a, l, p) { this.isInitiator = s, this.payload = r.Buffer.from(u), this.prologue = i, this.staticKeypair = o, this.connection = h, l && (this.remotePeer = l), this.ik = p || new d.IK, this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, a), this.remoteEarlyData = r.Buffer.alloc(0); }
                    async stage0() { if (t.logLocalStaticKeys(this.session.hs.s), t.logRemoteStaticKey(this.session.hs.rs), this.isInitiator) {
                        t.logger("IK Stage 0 - Initiator sending message...");
                        const s = this.ik.sendMessage(this.session, this.payload);
                        this.connection.writeLP(e.encode1(s)), t.logger("IK Stage 0 - Initiator sent message."), t.logLocalEphemeralKeys(this.session.hs.e);
                    }
                    else {
                        t.logger("IK Stage 0 - Responder receiving message...");
                        const s = await this.connection.readLP();
                        try {
                            const u = e.decode1(s.slice()), { plaintext: i, valid: o } = this.ik.recvMessage(this.session, u);
                            if (!o)
                                throw new Error("ik handshake stage 0 decryption validation fail");
                            t.logger("IK Stage 0 - Responder got message, going to verify payload.");
                            const h = await c.decodePayload(i);
                            this.remotePeer = this.remotePeer || await c.getPeerIdFromPayload(h), await c.verifySignedPayload(this.session.hs.rs, h, this.remotePeer), this.setRemoteEarlyData(h.data), t.logger("IK Stage 0 - Responder successfully verified payload!"), t.logRemoteEphemeralKey(this.session.hs.re);
                        }
                        catch (u) {
                            throw t.logger("Responder breaking up with IK handshake in stage 0."), new n.FailedIKError(s, "Error occurred while verifying initiator's signed payload: " + u.message);
                        }
                    } }
                    async stage1() { if (this.isInitiator) {
                        t.logger("IK Stage 1 - Initiator receiving message...");
                        const s = (await this.connection.readLP()).slice(), u = e.decode0(r.Buffer.from(s)), { plaintext: i, valid: o } = this.ik.recvMessage(this.session, u);
                        t.logger("IK Stage 1 - Initiator got message, going to verify payload.");
                        try {
                            if (!o)
                                throw new Error("ik stage 1 decryption validation fail");
                            const h = await c.decodePayload(i);
                            this.remotePeer = this.remotePeer || await c.getPeerIdFromPayload(h), await c.verifySignedPayload(u.ns.slice(0, 32), h, this.remotePeer), this.setRemoteEarlyData(h.data), t.logger("IK Stage 1 - Initiator successfully verified payload!"), t.logRemoteEphemeralKey(this.session.hs.re);
                        }
                        catch (h) {
                            throw t.logger("Initiator breaking up with IK handshake in stage 1."), new n.FailedIKError(s, "Error occurred while verifying responder's signed payload: " + h.message);
                        }
                    }
                    else {
                        t.logger("IK Stage 1 - Responder sending message...");
                        const s = this.ik.sendMessage(this.session, this.payload);
                        this.connection.writeLP(e.encode0(s)), t.logger("IK Stage 1 - Responder sent message..."), t.logLocalEphemeralKeys(this.session.hs.e);
                    } t.logCipherState(this.session); }
                    decrypt(s, u) { const i = this.getCS(u, !1); return this.ik.decryptWithAd(i, r.Buffer.alloc(0), s); }
                    encrypt(s, u) { const i = this.getCS(u); return this.ik.encryptWithAd(i, r.Buffer.alloc(0), s); }
                    getLocalEphemeralKeys() { if (!this.session.hs.e)
                        throw new Error("Ephemeral keys do not exist."); return this.session.hs.e; }
                    getCS(s, u = !0) { if (!s.cs1 || !s.cs2)
                        throw new Error("Handshake not completed properly, cipher state does not exist."); return this.isInitiator ? u ? s.cs1 : s.cs2 : u ? s.cs2 : s.cs1; }
                    setRemoteEarlyData(s) { s && (this.remoteEarlyData = r.Buffer.from(s.buffer, s.byteOffset, s.length)); }
                };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.IK = void 0;
                const d = f(3), r = f(57), e = f(387);
                class c extends e.AbstractHandshake {
                    initSession(t, s, u, i) { const o = this.createEmptyKey(); let h; return h = t ? this.initializeInitiator(s, u, i, o) : this.initializeResponder(s, u, i, o), { hs: h, i: t, mc: 0 }; }
                    sendMessage(t, s) { let u; if (t.mc === 0)
                        u = this.writeMessageA(t.hs, s);
                    else if (t.mc === 1) {
                        const { messageBuffer: i, h: o, cs1: h, cs2: a } = this.writeMessageB(t.hs, s);
                        u = i, t.h = o, t.cs1 = h, t.cs2 = a;
                    }
                    else {
                        if (!(t.mc > 1))
                            throw new Error("Session invalid.");
                        if (t.i) {
                            if (!t.cs1)
                                throw new Error("CS1 (cipher state) is not defined");
                            u = this.writeMessageRegular(t.cs1, s);
                        }
                        else {
                            if (!t.cs2)
                                throw new Error("CS2 (cipher state) is not defined");
                            u = this.writeMessageRegular(t.cs2, s);
                        }
                    } return t.mc++, u; }
                    recvMessage(t, s) { let u = d.Buffer.alloc(0), i = !1; if (t.mc === 0 && ({ plaintext: u, valid: i } = this.readMessageA(t.hs, s)), t.mc === 1) {
                        const { plaintext: o, valid: h, h: a, cs1: l, cs2: p } = this.readMessageB(t.hs, s);
                        u = o, i = h, t.h = a, t.cs1 = l, t.cs2 = p;
                    } return t.mc++, { plaintext: u, valid: i }; }
                    writeMessageA(t, s) { t.e = r.generateKeypair(); const u = t.e.publicKey; this.mixHash(t.ss, u), this.mixKey(t.ss, this.dh(t.e.privateKey, t.rs)); const i = d.Buffer.from(t.s.publicKey), o = this.encryptAndHash(t.ss, i); return this.mixKey(t.ss, this.dh(t.s.privateKey, t.rs)), { ne: u, ns: o, ciphertext: this.encryptAndHash(t.ss, s) }; }
                    writeMessageB(t, s) { t.e = r.generateKeypair(); const u = t.e.publicKey; this.mixHash(t.ss, u), this.mixKey(t.ss, this.dh(t.e.privateKey, t.re)), this.mixKey(t.ss, this.dh(t.e.privateKey, t.rs)); const i = this.encryptAndHash(t.ss, s), o = { ne: u, ns: this.createEmptyKey(), ciphertext: i }, { cs1: h, cs2: a } = this.split(t.ss); return { messageBuffer: o, cs1: h, cs2: a, h: t.ss.h }; }
                    readMessageA(t, s) { r.isValidPublicKey(s.ne) && (t.re = s.ne), this.mixHash(t.ss, t.re), this.mixKey(t.ss, this.dh(t.s.privateKey, t.re)); const { plaintext: u, valid: i } = this.decryptAndHash(t.ss, s.ns); i && u.length === 32 && r.isValidPublicKey(u) && (t.rs = u), this.mixKey(t.ss, this.dh(t.s.privateKey, t.rs)); const { plaintext: o, valid: h } = this.decryptAndHash(t.ss, s.ciphertext); return { plaintext: o, valid: i && h }; }
                    readMessageB(t, s) { if (r.isValidPublicKey(s.ne) && (t.re = s.ne), this.mixHash(t.ss, t.re), !t.e)
                        throw new Error("Handshake state should contain ephemeral key by now."); this.mixKey(t.ss, this.dh(t.e.privateKey, t.re)), this.mixKey(t.ss, this.dh(t.s.privateKey, t.re)); const { plaintext: u, valid: i } = this.decryptAndHash(t.ss, s.ciphertext), { cs1: o, cs2: h } = this.split(t.ss); return { h: t.ss.h, valid: i, plaintext: u, cs1: o, cs2: h }; }
                    initializeInitiator(t, s, u, i) { const o = this.initializeSymmetric("Noise_IK_25519_ChaChaPoly_SHA256"); return this.mixHash(o, t), this.mixHash(o, u), { ss: o, s, rs: u, re: d.Buffer.alloc(32), psk: i }; }
                    initializeResponder(t, s, u, i) { const o = this.initializeSymmetric("Noise_IK_25519_ChaChaPoly_SHA256"); return this.mixHash(o, t), this.mixHash(o, s.publicKey), { ss: o, s, rs: u, re: d.Buffer.alloc(32), psk: i }; }
                }
                m.IK = c;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.FailedIKError = void 0;
                class d extends Error {
                    constructor(e, c) { super(c), this.initialMsg = e, this.name = "FailedIKhandshake"; }
                }
                m.FailedIKError = d;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.XXFallbackHandshake = void 0;
                const d = f(3), r = f(383), e = f(57), c = f(101), n = f(129);
                class t extends r.XXHandshake {
                    constructor(u, i, o, h, a, l, p, g, b) { super(u, i, o, h, a, p, b), g && (this.ephemeralKeys = g), this.initialMsg = l; }
                    async propose() { if (this.isInitiator)
                        this.xx.sendMessage(this.session, d.Buffer.alloc(0), this.ephemeralKeys), c.logger("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator."), c.logLocalEphemeralKeys(this.session.hs.e);
                    else {
                        c.logger("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
                        const u = n.decode0(this.initialMsg), { valid: i } = this.xx.recvMessage(this.session, { ne: u.ne, ns: d.Buffer.alloc(0), ciphertext: d.Buffer.alloc(0) });
                        if (!i)
                            throw new Error("xx fallback stage 0 decryption validation fail");
                        c.logger("XX Fallback Stage 0 - Responder used received message from IK."), c.logRemoteEphemeralKey(this.session.hs.re);
                    } }
                    async exchange() { if (this.isInitiator) {
                        const u = n.decode1(this.initialMsg), { plaintext: i, valid: o } = this.xx.recvMessage(this.session, u);
                        if (!o)
                            throw new Error("xx fallback stage 1 decryption validation fail");
                        c.logger("XX Fallback Stage 1 - Initiator used received message from IK."), c.logRemoteEphemeralKey(this.session.hs.re), c.logRemoteStaticKey(this.session.hs.rs), c.logger("Initiator going to check remote's signature...");
                        try {
                            const h = await e.decodePayload(i);
                            this.remotePeer = this.remotePeer || await e.getPeerIdFromPayload(h), await e.verifySignedPayload(this.session.hs.rs, h, this.remotePeer), this.setRemoteEarlyData(h.data);
                        }
                        catch (h) {
                            throw new Error("Error occurred while verifying signed payload from responder: " + h.message);
                        }
                        c.logger("All good with the signature!");
                    }
                    else
                        c.logger("XX Fallback Stage 1 - Responder start"), await super.exchange(), c.logger("XX Fallback Stage 1 - Responder end"); }
                }
                m.XXFallbackHandshake = t;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.decryptStream = m.encryptStream = void 0;
                const d = f(3), r = f(211);
                m.encryptStream = function (e) { return async function* (c) { for await (const n of c) {
                    const t = d.Buffer.from(n.buffer, n.byteOffset, n.length);
                    for (let s = 0; s < t.length; s += r.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
                        let u = s + r.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
                        u > t.length && (u = t.length);
                        const i = e.encrypt(t.slice(s, u), e.session);
                        yield i;
                    }
                } }; }, m.decryptStream = function (e) { return async function* (c) { for await (const n of c) {
                    const t = d.Buffer.from(n.buffer, n.byteOffset, n.length);
                    for (let s = 0; s < t.length; s += r.NOISE_MSG_MAX_LENGTH_BYTES) {
                        let u = s + r.NOISE_MSG_MAX_LENGTH_BYTES;
                        u > t.length && (u = t.length);
                        const i = t.slice(s, u), { plaintext: o, valid: h } = await e.decrypt(i, e.session);
                        if (!h)
                            throw new Error("Failed to validate decrypted chunk");
                        yield o;
                    }
                } }; };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.KeyCache = void 0;
                const d = new class {
                    constructor() { this.storage = new Map; }
                    store(r, e) { this.storage.set(r.id, e); }
                    load(r) { return r && this.storage.get(r.id) || null; }
                    resetStorage() { this.storage.clear(); }
                };
                m.KeyCache = d;
            }, function (E, m, f) {
                "use strict";
                const { EventEmitter: d } = f(12), r = f(0), e = f(66), { MemoryDatastore: c } = f(11), n = f(20), t = f(1039), s = f(22), u = f(59), i = f(1042), o = f(1054), h = f(1078), a = f(1081), l = f(43), p = f(1082), g = f(1083), b = f(1085), I = e.Record;
                E.exports = class extends d {
                    constructor({ libp2p: v, dialer: R, peerId: _, peerStore: k, registrar: x, protocolPrefix: M = "/ipfs", forceProtocolLegacy: N = !1, datastore: S = new c, kBucketSize: T = u.K, clientMode: B = !1, concurrency: P = u.ALPHA, validators: L = {}, selectors: j = {}, randomWalk: D = {}, onPut: G = () => { }, onRemove: W = () => { } }) { if (super(), !R)
                        throw new Error("libp2p-kad-dht requires an instance of Dialer"); this.libp2p = v, this.dialer = R, this.peerId = _, this.peerStore = k, this.registrar = x, this.protocol = M + (N ? "" : u.PROTOCOL_DHT), this.kBucketSize = T, this._clientMode = B, this.concurrency = P, this.disjointPaths = Math.ceil(this.kBucketSize / 2), this.routingTable = new t(this.peerId, this.kBucketSize), this.datastore = S, this.providers = new p(this.datastore, this.peerId), this.validators = { pk: e.validator.validators.pk, ...L }, this.selectors = { pk: e.selection.selectors.pk, ...j }, this.network = new i(this), this._log = s.logger(this.peerId), this.randomWalk = new g(this, D), this._queryManager = new b, this._running = !1, this.contentFetching = o(this), this.contentRouting = h(this), this.peerRouting = a(this), this.onPut = G, this.onRemove = W; }
                    get isStarted() { return this._running; }
                    async start() { this._running = !0, this.providers.start(), this._queryManager.start(), await this.network.start(), this.randomWalk.start(); }
                    stop() { return this._running = !1, this.randomWalk.stop(), this.providers.stop(), this._queryManager.stop(), this.network.stop(); }
                    async put(v, R, _ = {}) { return this.contentFetching.put(v, R, _); }
                    async get(v, R = {}) { return this.contentFetching.get(v, R); }
                    async getMany(v, R, _ = {}) { return this.contentFetching.getMany(v, R, _); }
                    async removeLocal(v) { this._log("removeLocal: %b", v); const R = s.bufferToKey(v); try {
                        await this.datastore.delete(R);
                    }
                    catch (_) {
                        if (_.code === "ERR_NOT_FOUND")
                            return;
                        throw _;
                    } }
                    async provide(v) { return this.contentRouting.provide(v); }
                    async *findProviders(v, R = {}) { for await (const _ of this.contentRouting.findProviders(v, R))
                        yield _; }
                    async findPeer(v, R = {}) { return this.peerRouting.findPeer(v, R); }
                    async *getClosestPeers(v, R = { shallow: !1 }) { for await (const _ of this.peerRouting.getClosestPeers(v, R))
                        yield _; }
                    async getPublicKey(v) { return this.peerRouting.getPublicKey(v); }
                    _peerDiscovered(v, R) { this.emit("peer", { id: v, multiaddrs: R }); }
                    async _nearestPeersToQuery(v) { const R = await s.convertBuffer(v.key); return this.routingTable.closestPeers(R, this.kBucketSize).map(_ => { const k = this.peerStore.get(_); return { id: _, multiaddrs: k ? k.addresses.map(x => x.multiaddr) : [] }; }); }
                    async _betterPeersToQuery(v, R) { return this._log("betterPeersToQuery"), (await this._nearestPeersToQuery(v)).filter(_ => this._isSelf(_.id) ? (this._log.error("trying to return self as closer"), !1) : !_.id.isEqual(R)); }
                    async _checkLocalDatastore(v) { this._log("checkLocalDatastore: %b", v); const R = s.bufferToKey(v); let _; try {
                        _ = await this.datastore.get(R);
                    }
                    catch (x) {
                        if (x.code === "ERR_NOT_FOUND")
                            return;
                        throw x;
                    } const k = I.deserialize(_); if (!k)
                        throw r("Invalid record", "ERR_INVALID_RECORD"); return k.timeReceived == null || s.now() - k.timeReceived > u.MAX_RECORD_AGE ? (await this.datastore.delete(R), void this.onRemove(k)) : k; }
                    async _add(v) { await this.routingTable.add(v); }
                    async _verifyRecordLocally(v) { this._log("verifyRecordLocally"), await e.validator.verifyRecord(this.validators, v); }
                    _isSelf(v) { return v && n(this.peerId.id, v.id); }
                    async _putValueToPeer(v, R, _) { const k = new l(l.TYPES.PUT_VALUE, v, 0); if (k.record = R, !(await this.network.sendRequest(_, k)).record.value.equals(I.deserialize(R).value))
                        throw r(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID"); }
                    async _getValueOrPeers(v, R) { const _ = await this._getValueSingle(v, R), k = _.closerPeers, x = _.record; if (x) {
                        try {
                            await this._verifyRecordOnline(x);
                        }
                        catch (M) {
                            const N = "invalid record received, discarded";
                            throw this._log(N), r(new Error(N), "ERR_INVALID_RECORD");
                        }
                        return { record: x, peers: k };
                    } if (k.length > 0)
                        return { peers: k }; throw r(new Error("Not found"), "ERR_NOT_FOUND"); }
                    async _getValueSingle(v, R) { const _ = new l(l.TYPES.GET_VALUE, R, 0); return this.network.sendRequest(v, _); }
                    async _verifyRecordOnline(v) { await e.validator.verifyRecord(this.validators, v); }
                }, E.exports.multicodec = "/ipfs" + u.PROTOCOL_DHT;
            }, function (E, m, f) {
                "use strict";
                const d = f(1040), r = f(22);
                E.exports = class {
                    constructor(e, c) { this.self = e, this._onPing = this._onPing.bind(this), this._onInit(c); }
                    async _onInit(e) { const c = await r.convertPeerId(this.self); this.kb = new d({ localNodeId: c, numberOfNodesPerKBucket: e, numberOfNodesToPing: 1 }), this.kb.on("ping", this._onPing); }
                    _onPing(e, c) { const n = e[0]; this.kb.remove(n.id), this.kb.add(c); }
                    get size() { return this.kb.count(); }
                    async find(e) { const c = await r.convertPeerId(e), n = this.closestPeer(c); if (n && n.isEqual(e))
                        return n; }
                    closestPeer(e) { const c = this.closestPeers(e, 1); if (c.length > 0)
                        return c[0]; }
                    closestPeers(e, c) { return this.kb.closest(e, c).map(n => n.peer); }
                    async add(e) { const c = await r.convertPeerId(e); this.kb.add({ id: c, peer: e }); }
                    async remove(e) { const c = await r.convertPeerId(e); this.kb.remove(c); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(356), { EventEmitter: r } = f(12);
                function e(t, s) { if (t === s)
                    return !0; if (t.length !== s.length)
                    return !1; for (let u = 0, i = t.length; u < i; ++u)
                    if (t[u] !== s[u])
                        return !1; return !0; }
                function c(t, s) { if (!(s instanceof Uint8Array))
                    throw new TypeError(t + " is not a Uint8Array"); }
                class n extends r {
                    constructor(s = {}) { super(), this.localNodeId = s.localNodeId || d(20), this.numberOfNodesPerKBucket = s.numberOfNodesPerKBucket || 20, this.numberOfNodesToPing = s.numberOfNodesToPing || 3, this.distance = s.distance || n.distance, this.arbiter = s.arbiter || n.arbiter, this.metadata = Object.assign({}, s.metadata), c("option.localNodeId as parameter 1", this.localNodeId), this.root = { contacts: [], dontSplit: !1, left: null, right: null }; }
                    static arbiter(s, u) { return s.vectorClock > u.vectorClock ? s : u; }
                    static distance(s, u) { let i = 0, o = 0; const h = Math.min(s.length, u.length), a = Math.max(s.length, u.length); for (; o < h; ++o)
                        i = 256 * i + (s[o] ^ u[o]); for (; o < a; ++o)
                        i = 256 * i + 255; return i; }
                    add(s) { c("contact.id", (s || {}).id); let u = 0, i = this.root; for (; i.contacts === null;)
                        i = this._determineNode(i, s.id, u++); const o = this._indexOf(i, s.id); return o >= 0 ? (this._update(i, o, s), this) : i.contacts.length < this.numberOfNodesPerKBucket ? (i.contacts.push(s), this.emit("added", s), this) : i.dontSplit ? (this.emit("ping", i.contacts.slice(0, this.numberOfNodesToPing), s), this) : (this._split(i, u), this.add(s)); }
                    closest(s, u = 1 / 0) { if (c("id", s), !Number.isInteger(u) && u !== 1 / 0 || u <= 0)
                        throw new TypeError("n is not positive number"); let i = []; for (let o = [this.root], h = 0; o.length > 0 && i.length < u;) {
                        const a = o.pop();
                        if (a.contacts === null) {
                            const l = this._determineNode(a, s, h++);
                            o.push(a.left === l ? a.right : a.left), o.push(l);
                        }
                        else
                            i = i.concat(a.contacts);
                    } return i.map(o => [this.distance(o.id, s), o]).sort((o, h) => o[0] - h[0]).slice(0, u).map(o => o[1]); }
                    count() { let s = 0; for (const u = [this.root]; u.length > 0;) {
                        const i = u.pop();
                        i.contacts === null ? u.push(i.right, i.left) : s += i.contacts.length;
                    } return s; }
                    _determineNode(s, u, i) { const o = i >> 3, h = i % 8; return u.length <= o && h !== 0 ? s.left : u[o] & 1 << 7 - h ? s.right : s.left; }
                    get(s) { c("id", s); let u = 0, i = this.root; for (; i.contacts === null;)
                        i = this._determineNode(i, s, u++); const o = this._indexOf(i, s); return o >= 0 ? i.contacts[o] : null; }
                    _indexOf(s, u) { for (let i = 0; i < s.contacts.length; ++i)
                        if (e(s.contacts[i].id, u))
                            return i; return -1; }
                    remove(s) { c("the id as parameter 1", s); let u = 0, i = this.root; for (; i.contacts === null;)
                        i = this._determineNode(i, s, u++); const o = this._indexOf(i, s); if (o >= 0) {
                        const h = i.contacts.splice(o, 1)[0];
                        this.emit("removed", h);
                    } return this; }
                    _split(s, u) { s.left = { contacts: [], dontSplit: !1, left: null, right: null }, s.right = { contacts: [], dontSplit: !1, left: null, right: null }; for (const o of s.contacts)
                        this._determineNode(s, o.id, u).contacts.push(o); s.contacts = null; const i = this._determineNode(s, this.localNodeId, u); (s.left === i ? s.right : s.left).dontSplit = !0; }
                    toArray() { let s = []; for (const u = [this.root]; u.length > 0;) {
                        const i = u.pop();
                        i.contacts === null ? u.push(i.right, i.left) : s = s.concat(i.contacts);
                    } return s; }
                    _update(s, u, i) { if (!e(s.contacts[u].id, i.id))
                        throw new Error("wrong index for _update"); const o = s.contacts[u], h = this.arbiter(o, i); h === o && o !== i || (s.contacts.splice(u, 1), s.contacts.push(h), this.emit("updated", o, h)); }
                }
                E.exports = n;
            }, function (E, m, f) {
                "use strict";
                var d = function (s, u) { return u || (u = {}), s.split("").forEach(function (i, o) { i in u || (u[i] = o); }), u; }, r = { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", charmap: { 0: 14, 1: 8 } };
                r.charmap = d(r.alphabet, r.charmap);
                var e = { alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ", charmap: { O: 0, I: 1, L: 1 } };
                e.charmap = d(e.alphabet, e.charmap);
                var c = { alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", charmap: {} };
                function n(s) { if (this.buf = [], this.shift = 8, this.carry = 0, s) {
                    switch (s.type) {
                        case "rfc4648":
                            this.charmap = m.rfc4648.charmap;
                            break;
                        case "crockford":
                            this.charmap = m.crockford.charmap;
                            break;
                        case "base32hex":
                            this.charmap = m.base32hex.charmap;
                            break;
                        default: throw new Error("invalid type");
                    }
                    s.charmap && (this.charmap = s.charmap);
                } }
                function t(s) { if (this.buf = "", this.shift = 3, this.carry = 0, s) {
                    switch (s.type) {
                        case "rfc4648":
                            this.alphabet = m.rfc4648.alphabet;
                            break;
                        case "crockford":
                            this.alphabet = m.crockford.alphabet;
                            break;
                        case "base32hex":
                            this.alphabet = m.base32hex.alphabet;
                            break;
                        default: throw new Error("invalid type");
                    }
                    s.alphabet ? this.alphabet = s.alphabet : s.lc && (this.alphabet = this.alphabet.toLowerCase());
                } }
                c.charmap = d(c.alphabet, c.charmap), n.prototype.charmap = r.charmap, n.prototype.write = function (s) { var u = this.charmap, i = this.buf, o = this.shift, h = this.carry; return s.toUpperCase().split("").forEach(function (a) { if (a != "=") {
                    var l = 255 & u[a];
                    (o -= 5) > 0 ? h |= l << o : o < 0 ? (i.push(h | l >> -o), h = l << (o += 8) & 255) : (i.push(h | l), o = 8, h = 0);
                } }), this.shift = o, this.carry = h, this; }, n.prototype.finalize = function (s) { return s && this.write(s), this.shift !== 8 && this.carry !== 0 && (this.buf.push(this.carry), this.shift = 8, this.carry = 0), this.buf; }, t.prototype.alphabet = r.alphabet, t.prototype.write = function (s) { var u, i, o, h = this.shift, a = this.carry; for (o = 0; o < s.length; o++)
                    u = a | (i = s[o]) >> h, this.buf += this.alphabet[31 & u], h > 5 && (u = i >> (h -= 5), this.buf += this.alphabet[31 & u]), a = i << (h = 5 - h), h = 8 - h; return this.shift = h, this.carry = a, this; }, t.prototype.finalize = function (s) { return s && this.write(s), this.shift !== 3 && (this.buf += this.alphabet[31 & this.carry], this.shift = 3, this.carry = 0), this.buf; }, m.encode = function (s, u) { return new t(u).finalize(s); }, m.decode = function (s, u) { return new n(u).finalize(s); }, m.Decoder = n, m.Encoder = t, m.charmap = d, m.crockford = e, m.rfc4648 = r, m.base32hex = c;
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(27), e = f(35), c = f(62), { consume: n } = f(55), t = f(1043), s = f(1045), u = f(59), i = f(43), o = f(22);
                E.exports = class {
                    constructor(h) { this.dht = h, this.readMessageTimeout = u.READ_MESSAGE_TIMEOUT, this._log = o.logger(this.dht.peerId, "net"), this._rpc = s(this.dht), this._onPeerConnected = this._onPeerConnected.bind(this), this._running = !1; }
                    async start() { if (this._running)
                        return; if (!this.dht.isStarted)
                        throw d(new Error("Can not start network"), "ERR_CANNOT_START_NETWORK"); this._running = !0, this.dht._clientMode === !1 && this.dht.registrar.handle(this.dht.protocol, this._rpc); const h = new t({ multicodecs: [this.dht.protocol], handlers: { onConnect: this._onPeerConnected, onDisconnect: () => { } } }); this._registrarId = await this.dht.registrar.register(h); }
                    async stop() { (this.dht.isStarted || this.isStarted) && (this._running = !1, await this.dht.registrar.unregister(this._registrarId)); }
                    get isStarted() { return this._running; }
                    get isConnected() { return this.dht.isStarted && this.isStarted; }
                    async _onPeerConnected(h) { await this.dht._add(h), this._log("added to the routing table: %s", h.toB58String()); }
                    async sendRequest(h, a) { if (!this.isConnected)
                        throw d(new Error("Network is offline"), "ERR_NETWORK_OFFLINE"); const l = h.toB58String(); this._log("sending to: %s", l); let p = this.dht.registrar.connectionManager.get(h); p || (p = await this.dht.dialer.connectToPeer(h)); const { stream: g } = await p.newStream(this.dht.protocol); return this._writeReadMessage(g, a.serialize()); }
                    async sendMessage(h, a) { if (!this.isConnected)
                        throw d(new Error("Network is offline"), "ERR_NETWORK_OFFLINE"); const l = h.toB58String(); this._log("sending to: %s", l); let p = this.dht.registrar.connectionManager.get(h); p || (p = await this.dht.dialer.connectToPeer(h)); const { stream: g } = await p.newStream(this.dht.protocol); return this._writeMessage(g, a.serialize()); }
                    async _writeReadMessage(h, a) { return c(async function (l, p) { const g = await r([p], e.encode(), l, e.decode(), async (b) => { for await (const I of b)
                        return I.slice(); }); if (g.length === 0)
                        throw d(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED"); return i.deserialize(g); }(h, a), this.readMessageTimeout); }
                    _writeMessage(h, a) { return r([a], e.encode(), h, n); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = f(1044);
                E.exports = d(class extends r {
                    constructor({ min: e, max: c, multicodecs: n, handlers: t }) { if (super({ min: e, max: c, handlers: t }), !n)
                        throw new Error("one or more multicodec should be provided"); if (!t)
                        throw new Error("the handlers should be provided"); if (typeof t.onConnect != "function")
                        throw new Error("the 'onConnect' handler must be provided"); if (typeof t.onDisconnect != "function")
                        throw new Error("the 'onDisconnect' handler must be provided"); this.multicodecs = Array.isArray(n) ? n : [n], this._registrar = void 0, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerConnect = this._onPeerConnect.bind(this); }
                    set registrar(e) { this._registrar = e, this._registrar.peerStore.on("change:protocols", this._onProtocolChange), this._registrar.connectionManager.on("peer:connect", this._onPeerConnect), this._updatePeers(this._registrar.peerStore.peers.values()); }
                    _updatePeers(e) { for (const { id: c, protocols: n } of e)
                        if (this.multicodecs.filter(t => n.includes(t)).length) {
                            this.peers.add(c.toB58String());
                            const t = this._registrar.getConnection(c);
                            t && this._onConnect(c, t);
                        }
                        else
                            this.peers.delete(c.toB58String()); }
                    _onProtocolChange({ peerId: e, protocols: c }) { const n = this.peers.has(e.toB58String()), t = c.filter(s => this.multicodecs.includes(s)); n && t.length === 0 && this._onDisconnect(e); for (const s of c)
                        if (this.multicodecs.includes(s)) {
                            const u = this._registrar.peerStore.get(e);
                            return void this._updatePeers([u]);
                        } }
                    _onPeerConnect(e) { const c = e.remotePeer, n = this._registrar.peerStore.protoBook.get(c); n && this.multicodecs.find(t => n.includes(t)) && (this.peers.add(c.toB58String()), this._onConnect(c, e)); }
                }, { className: "MulticodecTopology", symbolName: "@libp2p/js-interfaces/topology/multicodec-topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = () => { };
                E.exports = d(class {
                    constructor({ min: e = 0, max: c = 1 / 0, handlers: n = {} }) { this.min = e, this.max = c, this._onConnect = n.onConnect || r, this._onDisconnect = n.onDisconnect || r, this.peers = new Set; }
                    set registrar(e) { this._registrar = e; }
                    disconnect(e) { this._onDisconnect(e); }
                }, { className: "Topology", symbolName: "@libp2p/js-interfaces/topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(27), r = f(35), e = f(43), c = f(1047), n = f(22);
                E.exports = t => { const s = n.logger(t.peerId, "rpc"), u = c(t); async function i(o, h) { const a = u(h.type); try {
                    await t._add(o);
                }
                catch (l) {
                    s.error("Failed to update the kbucket store", l);
                } if (a)
                    return a(o, h); s.error("no handler found for message type: " + h.type); } return async function ({ stream: o, connection: h }) { const a = h.remotePeer; try {
                    await t._add(a);
                }
                catch (p) {
                    s.error(p);
                } const l = a.toB58String(); s("from: %s", l), await d(o.source, r.decode(), p => async function* () { for await (const g of p) {
                    const b = e.deserialize(g.slice()), I = await i(a, b);
                    I && (yield I.serialize());
                } }(), r.encode(), o.sink); }; };
            }, function (E, m, f) {
                "use strict";
                E.exports = `// can't use, because protocol-buffers doesn't support imports
// so we have to duplicate for now :(
// import "record.proto";

message Record {
  // adjusted for javascript
  optional bytes key = 1;
  optional bytes value = 2;
  optional bytes author = 3;
  optional bytes signature = 4;
  optional string timeReceived = 5;
}

message Message {
  enum MessageType {
    PUT_VALUE = 0;
    GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
    FIND_NODE = 4;
    PING = 5;
  }

  enum ConnectionType {
    // sender does not have a connection to peer, and no extra information (default)
    NOT_CONNECTED = 0;

    // sender has a live connection to peer
    CONNECTED = 1;

    // sender recently connected to peer
    CAN_CONNECT = 2;

    // sender recently tried to connect to peer repeatedly but failed to connect
    // ("try" here is loose, but this should signal "made strong effort, failed")
    CANNOT_CONNECT = 3;
  }

  message Peer {
    // ID of a given peer.
    optional bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

    // used to signal the sender's connection capabilities to the peer
    optional ConnectionType connection = 3;
  }

  // defines what type of message it is.
  optional MessageType type = 1;

  // defines what coral cluster level this query/response belongs to.
  // in case we want to implement coral's cluster rings in the future.
  optional int32 clusterLevelRaw = 10;

  // Used to specify the key associated with this message.
  // PUT_VALUE, GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  // adjusted for javascript
  optional bytes key = 2;

  // Used to return a value
  // PUT_VALUE, GET_VALUE
  // adjusted Record to bytes for js
  optional bytes record = 3;

  // Used to return peers closer to a key in a query
  // GET_VALUE, GET_PROVIDERS, FIND_NODE
  repeated Peer closerPeers = 8;

  // Used to return Providers
  // GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  repeated Peer providerPeers = 9;
}`;
            }, function (E, m, f) {
                "use strict";
                const d = f(43).TYPES;
                E.exports = r => { const e = { [d.GET_VALUE]: f(1048)(r), [d.PUT_VALUE]: f(1049)(r), [d.FIND_NODE]: f(1050)(r), [d.ADD_PROVIDER]: f(1051)(r), [d.GET_PROVIDERS]: f(1052)(r), [d.PING]: f(1053)(r) }; return function (c) { return e[c]; }; };
            }, function (E, m, f) {
                "use strict";
                const { Record: d } = f(66), r = f(0), e = f(43), c = f(22);
                E.exports = n => { const t = c.logger(n.peerId, "rpc:get-value"); return async function (s, u) { const i = u.key; if (t("key: %b", i), !i || i.length === 0)
                    throw r(new Error("Invalid key"), "ERR_INVALID_KEY"); const o = new e(e.TYPES.GET_VALUE, i, u.clusterLevel); if (c.isPublicKeyKey(i)) {
                    t("is public key");
                    const l = c.fromPublicKeyKey(i);
                    let p;
                    if (n._isSelf(l))
                        p = n.peerId;
                    else {
                        const g = n.peerStore.get(l);
                        p = g && g.id;
                    }
                    if (p && p.pubKey)
                        return t("returning found public key"), o.record = new d(i, p.pubKey.bytes), o;
                } const [h, a] = await Promise.all([n._checkLocalDatastore(i), n._betterPeersToQuery(u, s)]); return h && (t("got record"), o.record = h), a.length > 0 && (t("got closer %s", a.length), o.closerPeers = a), o; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(22), r = f(0);
                E.exports = e => { const c = d.logger(e.peerId, "rpc:put-value"); return async function (n, t) { const s = t.key; c("key: %b", s); const u = t.record; if (!u) {
                    const o = "Empty record from: " + n.toB58String();
                    throw c.error(o), r(new Error(o), "ERR_EMPTY_RECORD");
                } await e._verifyRecordLocally(u), u.timeReceived = new Date; const i = d.bufferToKey(u.key); return await e.datastore.put(i, u.serialize()), e.onPut(u, n), t; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(20), r = f(43), e = f(22);
                E.exports = c => { const n = e.logger(c.peerId, "rpc:find-node"); return async function (t, s) { let u; n("start"), u = d(s.key, c.peerId.id) ? [{ id: c.peerId }] : await c._betterPeersToQuery(s, t); const i = new r(s.type, new Uint8Array(0), s.clusterLevel); return u.length > 0 ? i.closerPeers = u : n("handle FindNode %s: could not find anything", t.toB58String()), i; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), e = f(22);
                E.exports = c => { const n = e.logger(c.peerId, "rpc:add-provider"); return async function (t, s) { if (n("start"), !s.key || s.key.length === 0)
                    throw r(new Error("Missing key"), "ERR_MISSING_KEY"); let u; try {
                    u = new d(s.key);
                }
                catch (i) {
                    const o = "Invalid CID: " + i.message;
                    throw r(new Error(o), "ERR_INVALID_CID");
                } return s.providerPeers.forEach(i => { if (i.id.isEqual(t)) {
                    if (!(i.multiaddrs.length < 1))
                        return n("received provider %s for %s (addrs %s)", t.toB58String(), u.toBaseEncodedString(), i.multiaddrs.map(o => o.toString())), c._isSelf(i.id) ? void 0 : (c.peerStore.addressBook.add(i.id, i.multiaddrs), c.providers.addProvider(u, i.id));
                    n("no valid addresses for provider %s. Ignore", t.toB58String());
                }
                else
                    n("invalid provider peer %s from %s", i.id.toB58String(), t.toB58String()); }), c.providers.addProvider(u, t); }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(0), e = f(43), c = f(22);
                E.exports = n => { const t = c.logger(n.peerId, "rpc:get-providers"); return async function (s, u) { let i; try {
                    i = new d(u.key);
                }
                catch (I) {
                    throw r(new Error("Invalid CID: " + I.message), "ERR_INVALID_CID");
                } t("%s", i.toBaseEncodedString()); const o = c.bufferToKey(i.bytes), [h, a, l] = await Promise.all([n.datastore.has(o), n.providers.getProviders(i), n._betterPeersToQuery(u, s)]), p = a.map(I => ({ id: I })), g = l.map(I => ({ id: I.id })); h && p.push({ id: n.peerId }); const b = new e(u.type, u.key, u.clusterLevel); return p.length > 0 && (b.providerPeers = p), g.length > 0 && (b.closerPeers = g), t("got %s providers %s closerPeers", p.length, g.length), b; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(22);
                E.exports = r => { const e = d.logger(r.peerId, "rpc:ping"); return function (c, n) { return e("from %s", c.toB58String()), n; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(62), e = f(20), c = f(66), n = f(59), t = f(214), s = f(22), u = c.Record;
                E.exports = i => { const o = async (h, a) => i.datastore.put(s.bufferToKey(h), a); return { _putLocal: async (h, a) => o(h, a), async put(h, a, l = {}) { i._log("PutValue %b", h); const p = await s.createPutRecord(h, a); await o(h, p); let g = 0, b = 0; await s.mapParallel(i.getClosestPeers(h, { shallow: !0 }), async (v) => { try {
                        g += 1, await i._putValueToPeer(h, p, v), b += 1;
                    }
                    catch (R) {
                        i._log.error("Failed to put to peer (%b): %s", v.id, R);
                    } }); const I = l.minPeers || g; if (I > b) {
                        const v = d(new Error(`Failed to put value to enough peers: ${b}/${I}`), "ERR_NOT_ENOUGH_PUT_PEERS");
                        throw i._log.error(v), v;
                    } }, async get(h, a = {}) { a.timeout = a.timeout || n.minute, i._log("_get %b", h); const l = await i.getMany(h, n.GET_MANY_RECORD_COUNT, a), p = l.map(I => I.val); let g = 0; try {
                        g = c.selection.bestRecord(i.selectors, h, p);
                    }
                    catch (I) {
                        if (I.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")
                            throw I;
                    } const b = p[g]; if (i._log("GetValue %b %s", h, b), !b)
                        throw d(new Error("best value was not found"), "ERR_NOT_FOUND"); return await (async (I, v, R) => { const _ = await s.createPutRecord(I, R); return Promise.all(v.map(async (k) => { if (!e(k.val, R))
                        if (i._isSelf(k.from))
                            try {
                                await i._putLocal(I, _);
                            }
                            catch (x) {
                                i._log.error("Failed error correcting self", x);
                            }
                        else
                            try {
                                await i._putValueToPeer(I, _, k.from);
                            }
                            catch (x) {
                                i._log.error("Failed error correcting entry", x);
                            } })); })(h, l, b), b; }, async getMany(h, a, l = {}) { l.timeout = l.timeout || n.minute, i._log("getMany %b (%s)", h, a); let p, g = []; try {
                        p = await (async (k) => { i._log("getLocal %b", k); const x = await i.datastore.get(s.bufferToKey(k)); i._log("found %b in local datastore", k); const M = u.deserialize(x); return await i._verifyRecordLocally(M), M; })(h);
                    }
                    catch (k) {
                        if (a === 0)
                            throw k;
                    } if (p && g.push({ val: p.value, from: i.peerId }), g.length >= a)
                        return g; const b = [], I = await s.convertBuffer(h), v = i.routingTable.closestPeers(I, this.kBucketSize); if (i._log("peers in rt: %d", v.length), v.length === 0) {
                        const k = "Failed to lookup key! No peers from routing table!";
                        if (i._log.error(k), g.length === 0)
                            throw d(new Error(k), "ERR_NO_PEERS_IN_ROUTING_TABLE");
                        return g;
                    } const R = new t(i, h, (k, x) => { const M = s.pathSize(a - g.length, x), N = []; return b.push(N), async (S) => { let T, B, P; try {
                        const j = await i._getValueOrPeers(S, h);
                        T = j.record, B = j.peers;
                    }
                    catch (j) {
                        if (j.code !== "ERR_INVALID_RECORD")
                            throw j;
                        P = j;
                    } const L = { closerPeers: B }; return (T && T.value || P) && N.push({ val: T && T.value, from: S }), N.length >= M && (L.pathComplete = !0), L; }; }); let _; try {
                        await r(R.run(v), l.timeout);
                    }
                    catch (k) {
                        _ = k;
                    } if (R.stop(), g = [].concat.apply(g, b).slice(0, a), _ && g.length === 0)
                        throw _; return g; } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(1056), r = f(12), e = f(1057), c = f(1061), n = f(22);
                E.exports = class extends r {
                    constructor(t) { super(), this.query = t, this.running = !1, this.workers = [], this.peersSeen = new Set, this.errors = [], this.peersQueried = null; }
                    stop() { if (this.running) {
                        this.running = !1;
                        for (const t of this.workers)
                            t.stop();
                    } }
                    async execute(t) { const s = [], u = Math.min(this.query.dht.disjointPaths, t.length); for (let o = 0; o < u; o++)
                        s.push(new e(this, this.query.makePath(o, u))); t.forEach((o, h) => { s[h % u].addInitialPeer(o); }), await this.executePaths(s); const i = { finalSet: new Set(this.peersQueried.peers), paths: [] }; for (const o of s)
                        o.res && (o.res.pathComplete || o.res.queryComplete) && (o.res.success = !0, i.paths.push(o.res)); return i; }
                    async executePaths(t) { this.running = !0, this.emit("start"); try {
                        await Promise.all(t.map(s => s.execute()));
                    }
                    finally {
                        this.stop(), this.emit("complete");
                    } if (this.errors.length === this.peersSeen.size)
                        throw this.errors[0]; }
                    async workerQueue(t) { await this.init(), await this.startWorker(t); }
                    async startWorker(t) { const s = new c(this.query.dht, this, t, this.query._log); this.workers.push(s), await s.execute(); }
                    async init() { this.peersQueried || (this.peersQueriedPromise ? await this.peersQueriedPromise : (this.peersQueriedPromise = (async () => { const t = await n.convertBuffer(this.query.key); this.peersQueried = new d(t, this.query.dht.kBucketSize); })(), await this.peersQueriedPromise, delete this.peersQueriedPromise)); }
                    async continueQuerying(t) { if (this.peersQueried.length < this.peersQueried.capacity)
                        return !0; const s = t.queue.workersList().map(u => u.data); return !!await this.peersQueried.anyCloser(s); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(212), r = f(22), e = f(213), c = f(20);
                E.exports = class {
                    constructor(n, t) { this.originDhtKey = n, this.capacity = t, this.peerDistances = []; }
                    get length() { return this.peerDistances.length; }
                    get peers() { return this.peerDistances.map(n => n.peerId); }
                    async add(n) { if (this.peerDistances.find(u => c(u.peerId.id, n.id)))
                        return; const t = await r.convertPeerId(n), s = { peerId: n, distance: d(this.originDhtKey, t) }; this.peerDistances.push(s), this.peerDistances.sort((u, i) => d.compare(u.distance, i.distance)), this.peerDistances = this.peerDistances.slice(0, this.capacity); }
                    async anyCloser(n) { if (!n.length)
                        return !1; if (!this.length)
                        return !0; const t = await e(n, u => r.convertPeerId(u)), s = this.peerDistances[this.peerDistances.length - 1].distance; for (const u of t) {
                        const i = d(this.originDhtKey, u);
                        if (d.compare(i, s) < 0)
                            return !0;
                    } return !1; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1058), r = f(22);
                E.exports = class {
                    constructor(e, c) { if (this.run = e, this.queryFunc = r.withTimeout(c, 3e4), !this.queryFunc)
                        throw new Error("Path requires a `queryFn` to be specified"); if (typeof this.queryFunc != "function")
                        throw new Error("Path expected `queryFn` to be a function. Got " + typeof this.queryFunc); this.initialPeers = [], this.peersToQuery = null; }
                    addInitialPeer(e) { this.initialPeers.push(e); }
                    async execute() { const e = await d.fromKey(this.run.query.key); this.peersToQuery = e, await Promise.all(this.initialPeers.map(c => this.addPeerToQuery(c))), await this.run.workerQueue(this); }
                    async addPeerToQuery(e) { this.run.query.dht._isSelf(e) || this.run.peersSeen.has(e.toB58String()) || await this.peersToQuery.enqueue(e); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1059), r = f(212), e = f(1), c = f(22), n = e("libp2p:dht:peer-queue");
                class t {
                    static async fromPeerId(u) { const i = await c.convertPeerId(u); return new t(i); }
                    static async fromKey(u) { const i = await c.convertBuffer(u); return new t(i); }
                    constructor(u) { n("create: %b", u), this.from = u, this.heap = new d(c.xorCompare); }
                    async enqueue(u) { n("enqueue %s", u.toB58String()); const i = await c.convertPeerId(u), o = { id: u, distance: r(this.from, i) }; this.heap.push(o); }
                    dequeue() { const u = this.heap.pop(); return n("dequeue %s", u.id.toB58String()), u.id; }
                    get length() { return this.heap.size(); }
                }
                E.exports = t;
            }, function (E, m, f) {
                "use strict";
                E.exports = f(1060);
            }, function (E, m, f) {
                "use strict";
                var d, r, e;
                (function () { var c, n, t, s, u, i, o, h, a, l, p, g, b, I, v; t = Math.floor, l = Math.min, n = function (R, _) { return R < _ ? -1 : R > _ ? 1 : 0; }, a = function (R, _, k, x, M) { var N; if (k == null && (k = 0), M == null && (M = n), k < 0)
                    throw new Error("lo must be non-negative"); for (x == null && (x = R.length); k < x;)
                    M(_, R[N = t((k + x) / 2)]) < 0 ? x = N : k = N + 1; return [].splice.apply(R, [k, k - k].concat(_)), _; }, i = function (R, _, k) { return k == null && (k = n), R.push(_), I(R, 0, R.length - 1, k); }, u = function (R, _) { var k, x; return _ == null && (_ = n), k = R.pop(), R.length ? (x = R[0], R[0] = k, v(R, 0, _)) : x = k, x; }, h = function (R, _, k) { var x; return k == null && (k = n), x = R[0], R[0] = _, v(R, 0, k), x; }, o = function (R, _, k) { var x; return k == null && (k = n), R.length && k(R[0], _) < 0 && (_ = (x = [R[0], _])[0], R[0] = x[1], v(R, 0, k)), _; }, s = function (R, _) { var k, x, M, N, S, T; for (_ == null && (_ = n), S = [], x = 0, M = (N = function () { T = []; for (var B = 0, P = t(R.length / 2); 0 <= P ? B < P : B > P; 0 <= P ? B++ : B--)
                    T.push(B); return T; }.apply(this).reverse()).length; x < M; x++)
                    k = N[x], S.push(v(R, k, _)); return S; }, b = function (R, _, k) { var x; if (k == null && (k = n), (x = R.indexOf(_)) !== -1)
                    return I(R, 0, x, k), v(R, x, k); }, p = function (R, _, k) { var x, M, N, S, T; if (k == null && (k = n), !(M = R.slice(0, _)).length)
                    return M; for (s(M, k), N = 0, S = (T = R.slice(_)).length; N < S; N++)
                    x = T[N], o(M, x, k); return M.sort(k).reverse(); }, g = function (R, _, k) { var x, M, N, S, T, B, P, L, j; if (k == null && (k = n), 10 * _ <= R.length) {
                    if (!(N = R.slice(0, _).sort(k)).length)
                        return N;
                    for (M = N[N.length - 1], S = 0, B = (P = R.slice(_)).length; S < B; S++)
                        k(x = P[S], M) < 0 && (a(N, x, 0, null, k), N.pop(), M = N[N.length - 1]);
                    return N;
                } for (s(R, k), j = [], T = 0, L = l(_, R.length); 0 <= L ? T < L : T > L; 0 <= L ? ++T : --T)
                    j.push(u(R, k)); return j; }, I = function (R, _, k, x) { var M, N, S; for (x == null && (x = n), M = R[k]; k > _ && x(M, N = R[S = k - 1 >> 1]) < 0;)
                    R[k] = N, k = S; return R[k] = M; }, v = function (R, _, k) { var x, M, N, S, T; for (k == null && (k = n), M = R.length, T = _, N = R[_], x = 2 * _ + 1; x < M;)
                    (S = x + 1) < M && !(k(R[x], R[S]) < 0) && (x = S), R[_] = R[x], x = 2 * (_ = x) + 1; return R[_] = N, I(R, T, _, k); }, c = function () { function R(_) { this.cmp = _ !== null && _ !== void 0 ? _ : n, this.nodes = []; } return R.push = i, R.pop = u, R.replace = h, R.pushpop = o, R.heapify = s, R.updateItem = b, R.nlargest = p, R.nsmallest = g, R.prototype.push = function (_) { return i(this.nodes, _, this.cmp); }, R.prototype.pop = function () { return u(this.nodes, this.cmp); }, R.prototype.peek = function () { return this.nodes[0]; }, R.prototype.contains = function (_) { return this.nodes.indexOf(_) !== -1; }, R.prototype.replace = function (_) { return h(this.nodes, _, this.cmp); }, R.prototype.pushpop = function (_) { return o(this.nodes, _, this.cmp); }, R.prototype.heapify = function () { return s(this.nodes, this.cmp); }, R.prototype.updateItem = function (_) { return b(this.nodes, _, this.cmp); }, R.prototype.clear = function () { return this.nodes = []; }, R.prototype.empty = function () { return this.nodes.length === 0; }, R.prototype.size = function () { return this.nodes.length; }, R.prototype.clone = function () { var _; return (_ = new R).nodes = this.nodes.slice(0), _; }, R.prototype.toArray = function () { return this.nodes.slice(0); }, R.prototype.insert = R.prototype.push, R.prototype.top = R.prototype.peek, R.prototype.front = R.prototype.peek, R.prototype.has = R.prototype.contains, R.prototype.copy = R.prototype.clone, R; }(), r = [], (e = typeof (d = function () { return c; }) == "function" ? d.apply(m, r) : d) === void 0 || (E.exports = e); }).call(void 0);
            }, function (E, m, f) {
                "use strict";
                const d = f(1062), r = f(1075);
                E.exports = class {
                    constructor(e, c, n, t) { this.dht = e, this.run = c, this.path = n, this.log = t, this.concurrency = this.dht.concurrency, this.queue = this.setupQueue(), this.execution = null; }
                    setupQueue() { const e = d((c, n) => { r(this.processNext(c))(n); }, this.concurrency); return e.error = c => { this.log.error("queue", c), this.stop(c); }, e.drain = () => { this.log("queue:drain"), this.stop(); }, e.unsaturated = () => { this.running && this.fill(); }, e.buffer = 0, e; }
                    stop(e) { this.running && (this.running = !1, this.queue.kill(), this.log("worker:stop, %d workers still running", this.run.workers.filter(c => c.running).length), e ? this.execution.reject(e) : this.execution.resolve()); }
                    async execute() { this.running = !0, this.execution = {}; const e = new Promise((c, n) => Object.assign(this.execution, { resolve: c, reject: n })); this.fill(), await e; }
                    fill() { for (; this.queue.running() + this.queue.length() < this.concurrency && this.path.peersToQuery.length > 0;)
                        this.queue.push(this.path.peersToQuery.dequeue()); }
                    async processNext(e) { if (!this.running)
                        return; if (this.run.peersSeen.has(e.toB58String()))
                        return; let c, n, t, s; try {
                        c = await this.run.continueQuerying(this);
                    }
                    catch (u) {
                        n = u;
                    } if (this.running) {
                        if (n)
                            throw n;
                        if (c) {
                            if (!this.run.peersSeen.has(e.toB58String())) {
                                this.run.peersSeen.add(e.toB58String()), this.log("queue:work");
                                try {
                                    t = await this.execQuery(e);
                                }
                                catch (u) {
                                    s = u;
                                }
                                if (this.running) {
                                    if (this.log("queue:work:done", s, t), s)
                                        throw s;
                                    if (t && t.queryComplete)
                                        return this.log("query:complete"), void this.run.stop();
                                    t && t.pathComplete && this.stop();
                                }
                            }
                        }
                        else
                            this.stop();
                    } }
                    async execQuery(e) { let c, n; try {
                        c = await this.path.queryFunc(e);
                    }
                    catch (t) {
                        n = t;
                    } if (this.running)
                        if (n)
                            this.run.errors.push(n);
                        else {
                            if (await this.run.peersQueried.add(e), c.pathComplete || c.queryComplete)
                                return this.path.res = c, { pathComplete: c.pathComplete, queryComplete: c.queryComplete };
                            c.closerPeers && c.closerPeers.length > 0 && await Promise.all(c.closerPeers.map(async (t) => { this.dht._isSelf(t.id) || (this.dht._peerDiscovered(t.id, t.multiaddrs), await this.path.addPeerToQuery(t.id)); }));
                        } }
                };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (c, n) { var t = (0, r.default)(c); return (0, d.default)(function (s, u) { t(s[0], u); }, n, 1); };
                var d = e(f(1063)), r = e(f(390));
                function e(c) { return c && c.__esModule ? c : { default: c }; }
                E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (i, o, h) { if (o == null)
                    o = 1;
                else if (o === 0)
                    throw new Error("Concurrency must not be zero"); var a = (0, s.default)(i), l = 0, p = [], g = !1; function b(_, k, x) { if (x != null && typeof x != "function")
                    throw new Error("task callback must be a function"); if (R.started = !0, (0, r.default)(_) || (_ = [_]), _.length === 0 && R.idle())
                    return (0, n.default)(function () { R.drain(); }); for (var M = 0, N = _.length; M < N; M++) {
                    var S = { data: _[M], callback: x || e.default };
                    k ? R._tasks.unshift(S) : R._tasks.push(S);
                } g || (g = !0, (0, n.default)(function () { g = !1, R.process(); })); } function I(_) { return function (k) { l -= 1; for (var x = 0, M = _.length; x < M; x++) {
                    var N = _[x], S = (0, d.default)(p, N, 0);
                    S === 0 ? p.shift() : S > 0 && p.splice(S, 1), N.callback.apply(N, arguments), k != null && R.error(k, N.data);
                } l <= R.concurrency - R.buffer && R.unsaturated(), R.idle() && R.drain(), R.process(); }; } var v = !1, R = { _tasks: new t.default, concurrency: o, payload: h, saturated: e.default, unsaturated: e.default, buffer: o / 4, empty: e.default, drain: e.default, error: e.default, started: !1, paused: !1, push: function (_, k) { b(_, !1, k); }, kill: function () { R.drain = e.default, R._tasks.empty(); }, unshift: function (_, k) { b(_, !0, k); }, remove: function (_) { R._tasks.remove(_); }, process: function () { if (!v) {
                        for (v = !0; !R.paused && l < R.concurrency && R._tasks.length;) {
                            var _ = [], k = [], x = R._tasks.length;
                            R.payload && (x = Math.min(x, R.payload));
                            for (var M = 0; M < x; M++) {
                                var N = R._tasks.shift();
                                _.push(N), p.push(N), k.push(N.data);
                            }
                            l += 1, R._tasks.length === 0 && R.empty(), l === R.concurrency && R.saturated();
                            var S = (0, c.default)(I(_));
                            a(k, S);
                        }
                        v = !1;
                    } }, length: function () { return R._tasks.length; }, running: function () { return l; }, workersList: function () { return p; }, idle: function () { return R._tasks.length + l === 0; }, pause: function () { R.paused = !0; }, resume: function () { R.paused !== !1 && (R.paused = !1, (0, n.default)(R.process)); } }; return R; };
                var d = u(f(1064)), r = u(f(1068)), e = u(f(1069)), c = u(f(1070)), n = u(f(388)), t = u(f(1071)), s = u(f(390));
                function u(i) { return i && i.__esModule ? i : { default: i }; }
                E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                var d = f(1065), r = f(1066), e = f(1067);
                E.exports = function (c, n, t) { return n == n ? e(c, n, t) : d(c, r, t); };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e, c) { for (var n = d.length, t = e + (c ? 1 : -1); c ? t-- : ++t < n;)
                    if (r(d[t], t, d))
                        return t; return -1; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { return d != d; };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { for (var c = e - 1, n = d.length; ++c < n;)
                    if (d[c] === r)
                        return c; return -1; };
            }, function (E, m, f) {
                "use strict";
                var d = Array.isArray;
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                E.exports = function () { };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (d) { return function () { if (d === null)
                    throw new Error("Callback was already called."); var r = d; d = null, r.apply(this, arguments); }; }, E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                function d() { this.head = this.tail = null, this.length = 0; }
                function r(e, c) { e.length = 1, e.head = e.tail = c; }
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = d, d.prototype.removeLink = function (e) { return e.prev ? e.prev.next = e.next : this.head = e.next, e.next ? e.next.prev = e.prev : this.tail = e.prev, e.prev = e.next = null, this.length -= 1, e; }, d.prototype.empty = function () { for (; this.head;)
                    this.shift(); return this; }, d.prototype.insertAfter = function (e, c) { c.prev = e, c.next = e.next, e.next ? e.next.prev = c : this.tail = c, e.next = c, this.length += 1; }, d.prototype.insertBefore = function (e, c) { c.prev = e.prev, c.next = e, e.prev ? e.prev.next = c : this.head = c, e.prev = c, this.length += 1; }, d.prototype.unshift = function (e) { this.head ? this.insertBefore(this.head, e) : r(this, e); }, d.prototype.push = function (e) { this.tail ? this.insertAfter(this.tail, e) : r(this, e); }, d.prototype.shift = function () { return this.head && this.removeLink(this.head); }, d.prototype.pop = function () { return this.tail && this.removeLink(this.tail); }, d.prototype.toArray = function () { for (var e = Array(this.length), c = this.head, n = 0; n < this.length; n++)
                    e[n] = c.data, c = c.next; return e; }, d.prototype.remove = function (e) { for (var c = this.head; c;) {
                    var n = c.next;
                    e(c) && this.removeLink(c), c = n;
                } return this; }, E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (s) { return (0, r.default)(function (u, i) { var o; try {
                    o = s.apply(this, u);
                }
                catch (h) {
                    return i(h);
                } (0, d.default)(o) && typeof o.then == "function" ? o.then(function (h) { n(i, null, h); }, function (h) { n(i, h.message ? h : new Error(h)); }) : i(null, o); }); };
                var d = c(f(1073)), r = c(f(1074)), e = c(f(388));
                function c(s) { return s && s.__esModule ? s : { default: s }; }
                function n(s, u, i) { try {
                    s(u, i);
                }
                catch (o) {
                    (0, e.default)(t, o);
                } }
                function t(s) { throw s; }
                E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d) { var r = typeof d; return d != null && (r == "object" || r == "function"); };
            }, function (E, m, f) {
                "use strict";
                Object.defineProperty(m, "__esModule", { value: !0 }), m.default = function (c) { return function () { var n = (0, e.default)(arguments), t = n.pop(); c.call(this, n, t); }; };
                var d, r = f(389), e = (d = r) && d.__esModule ? d : { default: d };
                E.exports = m.default;
            }, function (E, m, f) {
                "use strict";
                var d = f(1076), r = f(1077);
                E.exports = function (e) { if (!d(e.then))
                    throw new TypeError("Expected a promise"); return function (c) { e.then(function (n) { r(c, null, n); }, function (n) { r(c, n); }); }; };
            }, function (E, m, f) {
                "use strict";
                var d = Object.prototype.toString;
                E.exports = function (r) { return d.call(r) === "[object Function]"; };
            }, function (E, m, f) {
                "use strict";
                E.exports = typeof setImmediate == "function" ? setImmediate : function () { var d = [].slice.apply(arguments); d.splice(1, 0, 0), setTimeout.apply(null, d); };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(62), e = f(59), c = f(1079), n = f(43), t = f(214), s = f(22);
                E.exports = u => ({ async provide(i) { u._log("provide: %s", i.toBaseEncodedString()); const o = []; await u.providers.addProvider(i, u.peerId); const h = u.libp2p ? u.libp2p.multiaddrs : [], a = new n(n.TYPES.ADD_PROVIDER, i.bytes, 0); if (a.providerPeers = [{ id: u.peerId, multiaddrs: h }], await s.mapParallel(u.getClosestPeers(i.bytes), async (l) => { u._log("putProvider %s to %s", i.toBaseEncodedString(), l.toB58String()); try {
                        await u.network.sendMessage(l, a);
                    }
                    catch (p) {
                        o.push(p);
                    } }), o.length)
                        throw d(new Error(`Failed to provide to ${o.length} of ${u.kBucketSize} peers`, "ERR_SOME_PROVIDES_FAILED"), { errors: o }); }, async *findProviders(i, o = {}) { const h = o.timeout || e.minute, a = o.maxNumProviders || e.K; u._log("findProviders %s", i.toBaseEncodedString()); const l = new c(a); if ((await u.providers.getProviders(i)).forEach(I => { const v = u.peerStore.get(I) || {}; l.push({ id: v.id || I, multiaddrs: (v.addresses || []).map(R => R.multiaddr) }); }), l.length >= a) {
                        for (const I of l.toArray())
                            yield I;
                        return;
                    } const p = [], g = new t(u, i.bytes, (I, v) => { const R = s.pathSize(a - l.length, v), _ = new c(R); return p.push(_), async (k) => { const x = await (async (N, S) => { const T = new n(n.TYPES.GET_PROVIDERS, S.bytes, 0); return u.network.sendRequest(N, T); })(k, i), M = x.providerPeers; return u._log("(%s) found %s provider entries", u.peerId.toB58String(), M.length), M.forEach(N => { _.push({ id: N.id }); }), _.length >= R ? { pathComplete: !0 } : { closerPeers: x.closerPeers }; }; }), b = u.routingTable.closestPeers(i.bytes, u.kBucketSize); try {
                        await r(g.run(b), h);
                    }
                    catch (I) {
                        if (I.name !== r.TimeoutError.name)
                            throw I;
                    }
                    finally {
                        g.stop();
                    } if (p.forEach(I => { I.toArray().forEach(v => { l.push(v); }); }), l.length === 0)
                        throw d(new Error("no providers found"), "ERR_NOT_FOUND"); for (const I of l.toArray())
                        yield I; } });
            }, function (E, m, f) {
                "use strict";
                const d = f(1080);
                E.exports = class extends d {
                    constructor(r) { super(), this.limit = r; }
                    push(r) { return this.length < this.limit && super.push(r); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = class {
                    constructor() { this.list = []; }
                    push(d) { return !this.has(d.id) && (this.list.push(d), !0); }
                    has(d) { const r = this.list.find(e => e.id.isEqual(d)); return Boolean(r); }
                    toArray() { return this.list.slice(); }
                    pop() { return this.list.pop(); }
                    get length() { return this.list.length; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(0), r = f(62), e = f(7), c = f(39), n = f(59), t = f(43), s = f(214), u = f(22);
                E.exports = i => { const o = async (h) => { const a = u.keyForPublicKey(h), l = await (async (g, b) => { const I = new t(t.TYPES.GET_VALUE, b, 0); return i.network.sendRequest(g, I); })(h, a); if (!l.record || !l.record.value)
                    throw d("Node not responding with its public key: " + h.toB58String(), "ERR_INVALID_RECORD"); const p = e.createFromPubKey(l.record.value); if (!p.isEqual(h))
                    throw d("public key does not match id", "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID"); return p.pubKey; }; return { async _findPeerSingle(h, a) { i._log("findPeerSingle %s", h.toB58String()); const l = new t(t.TYPES.FIND_NODE, a.id, 0); return i.network.sendRequest(h, l); }, async findPeer(h, a = {}) { a.timeout = a.timeout || n.minute, i._log("findPeer %s", h.toB58String()); const l = await (async (k) => { i._log("findPeerLocal %s", k.toB58String()); const x = await i.routingTable.find(k), M = x && i.peerStore.get(x); if (M)
                        return { id: M.id, multiaddrs: M.addresses.map(N => N.multiaddr) }; })(h); if (l != null)
                        return i._log("found local"), l; const p = await u.convertPeerId(h), g = i.routingTable.closestPeers(p, i.kBucketSize); if (g.length === 0)
                        throw d(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED"); if (g.find(k => k.isEqual(h))) {
                        const k = i.peerStore.get(h);
                        if (k)
                            return i._log("found in peerStore"), { id: k.id, multiaddrs: k.addresses.map(x => x.multiaddr) };
                    } const b = new s(i, h.id, () => async (k) => { const x = await this._findPeerSingle(k, h), M = x.closerPeers.find(N => N.id.isEqual(h)); return M ? { peer: M, queryComplete: !0 } : { closerPeers: x.closerPeers }; }); let I, v; try {
                        v = await r(b.run(g), a.timeout);
                    }
                    catch (k) {
                        I = k;
                    } if (b.stop(), I)
                        throw I; let R = !1; if (v.paths.forEach(k => { k.success && (R = !0, i.peerStore.addressBook.add(k.peer.id, k.peer.multiaddrs)); }), i._log("findPeer %s: %s", h.toB58String(), R), !R)
                        throw d(new Error("No peer found"), "ERR_NOT_FOUND"); const _ = i.peerStore.get(h); return { id: _.id, multiaddrs: _.addresses.map(k => k.multiaddr) }; }, async *getClosestPeers(h, a = { shallow: !1 }) { i._log("getClosestPeers to %b", h); const l = await u.convertBuffer(h), p = i.routingTable.closestPeers(l, i.kBucketSize), g = new s(i, h, () => async (v) => ({ closerPeers: await (async (R, _) => (i._log("closerPeersSingle %b from %s", R, _.toB58String()), (await i.peerRouting._findPeerSingle(_, new e(R))).closerPeers.filter(k => !i._isSelf(k.id)).map(k => (i.peerStore.addressBook.add(k.id, k.multiaddrs), k))))(h, v), pathComplete: !!a.shallow || void 0 })), b = await g.run(p); if (!b || !b.finalSet)
                        return []; const I = await u.sortClosestPeers(Array.from(b.finalSet), l); for (const v of I.slice(0, i.kBucketSize))
                        yield v; }, async getPublicKey(h) { i._log("getPublicKey %s", h.toB58String()); const a = i.peerStore.get(h); if (a && a.id.pubKey)
                        return i._log("getPublicKey: found local copy"), a.id.pubKey; let l; try {
                        l = await o(h);
                    }
                    catch (g) {
                        const b = u.keyForPublicKey(h), I = await i.get(b);
                        l = c.keys.unmarshalPublicKey(I);
                    } a.id = new e(h.id, null, l); const p = a.addresses.map(g => g.multiaddr); return i.peerStore.addressBook.add(a.id, p), i.peerStore.keyBook.set(a.id, l), l; } }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(112), r = f(19), e = f(7), { Key: c } = f(11), { default: n } = f(86), t = f(59), s = f(22);
                function u(h) { return h = typeof h == "string" ? h : s.encodeBase32(h.bytes), t.PROVIDERS_KEY_PREFIX + h; }
                function i(h) { const a = h.toString().split("/"); if (a.length !== 4)
                    throw new Error("incorrectly formatted provider entry key in datastore: " + h); return { cid: a[2], peerId: a[3] }; }
                function o(h) { return r.decode(h); }
                E.exports = class {
                    constructor(h, a, l) { this.datastore = h, this._log = s.logger(a, "providers"), this.cleanupInterval = t.PROVIDERS_CLEANUP_INTERVAL, this.provideValidity = t.PROVIDERS_VALIDITY, this.lruCacheSize = l || t.PROVIDERS_LRU_CACHE_SIZE, this.providers = d(this.lruCacheSize), this.syncQueue = new n({ concurrency: 1 }); }
                    start() { this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval); }
                    stop() { clearInterval(this._cleaner), this._cleaner = null; }
                    _cleanup() { return this.syncQueue.add(async () => { this._log("start cleanup"); const h = Date.now(); let a = 0, l = 0; const p = new Map, g = this.datastore.batch(), b = this.datastore.query({ prefix: t.PROVIDERS_KEY_PREFIX }); for await (const I of b)
                        try {
                            const { cid: v, peerId: R } = i(I.key), _ = o(I.value), k = Date.now(), x = k - _, M = x > this.provideValidity;
                            if (this._log("comparing: %d - %d = %d > %d %s", k, _, x, this.provideValidity, M ? "(expired)" : ""), M) {
                                l++, g.delete(I.key);
                                const N = p.get(v) || new Set;
                                N.add(R), p.set(v, N);
                            }
                            a++;
                        }
                        catch (v) {
                            this._log.error(v.message);
                        } this._log("deleting %d / %d entries", l, a), p.size && await g.commit(); for (const [I, v] of p) {
                        const R = u(I), _ = this.providers.get(R);
                        if (_) {
                            for (const k of v)
                                _.delete(k);
                            _.size === 0 ? this.providers.remove(R) : this.providers.set(R, _);
                        }
                    } this._log("Cleanup successful (%dms)", Date.now() - h); }); }
                    async _getProvidersMap(h) { const a = u(h); let l = this.providers.get(a); return l || (l = await async function (p, g) { const b = new Map, I = p.query({ prefix: u(g) }); for await (const v of I) {
                        const { peerId: R } = i(v.key);
                        b.set(R, o(v.value));
                    } return b; }(this.datastore, h), this.providers.set(a, l)), l; }
                    async addProvider(h, a) { return this.syncQueue.add(async () => { this._log("addProvider %s", h.toBaseEncodedString()); const l = await this._getProvidersMap(h); this._log("loaded %s provs", l.size); const p = Date.now(); l.set(s.encodeBase32(a.id), p); const g = u(h); return this.providers.set(g, l), async function (b, I, v, R) { const _ = [u(I), "/", s.encodeBase32(v.id)].join(""), k = new c(_), x = Uint8Array.from(r.encode(R)); return b.put(k, x); }(this.datastore, h, a, p); }); }
                    async getProviders(h) { return this.syncQueue.add(async () => (this._log("getProviders %s", h.toBaseEncodedString()), [...(await this._getProvidersMap(h)).keys()].map(a => new e(s.decodeBase32(a))))); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(39), r = f(16), e = f(7), c = f(47), n = f(0), t = f(1084), s = f(59), { logger: u } = f(22);
                E.exports = class {
                    constructor(i, o) { if (!i)
                        throw new Error("Random Walk needs an instance of the Kademlia DHT"); this._kadDHT = i, this._options = { ...s.defaultRandomWalk, ...o }, this.log = u(i.peerId, "random-walk"), this._timeoutId = void 0; }
                    start() { !this._timeoutId && this._options.enabled && (this._timeoutId = setTimeout(() => { this._runPeriodically(); }, this._options.delay)); }
                    stop() { this._timeoutId && (clearTimeout(this._timeoutId), this._timeoutId = void 0), this._controller && this._controller.abort(); }
                    async _runPeriodically() { for (; this._timeoutId;) {
                        try {
                            await this._walk(this._options.queriesPerPeriod, this._options.timeout);
                        }
                        catch (i) {
                            this._kadDHT._log.error("random-walk:error", i);
                        }
                        await new Promise(i => { this._timeoutId = setTimeout(i, this._options.interval); });
                    } }
                    async _walk(i, o) { this.log("start"), this._controller = new c; try {
                        await t(i, async (h) => { this.log("running query %d", h); try {
                            const a = await this._randomPeerId();
                            if (!this._controller)
                                return;
                            await this._query(a, { timeout: o, signal: this._controller.signal });
                        }
                        catch (a) {
                            if (a && a.code !== "ETIMEDOUT")
                                throw this.log.error("query %d finished with error", h, a), a;
                        } this.log("finished query %d", h); });
                    }
                    finally {
                        this._controller = null, this.log("finished queries");
                    } }
                    async _query(i, o) { let h; this.log("query:%s", i.toB58String()); try {
                        h = await this._kadDHT.findPeer(i, o);
                    }
                    catch (a) {
                        if (a && a.code === "ERR_NOT_FOUND")
                            return;
                        throw a;
                    } throw this.log("query:found", h), n(`random-walk: ACTUALLY FOUND PEER: ${h}, ${i.toB58String()}`, "ERR_FOUND_RANDOM_PEER"); }
                    async _randomPeerId() { const i = await r(d.randomBytes(16), "sha2-256"); return new e(i); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(213), r = async (e, c, n) => d(new Array(e).fill(), (t, s) => c(s), n);
                E.exports = r, E.exports.default = r;
            }, function (E, m, f) {
                "use strict";
                E.exports = class {
                    constructor() { this.queries = new Set, this.running = !1; }
                    queryStarted(d) { this.queries.add(d); }
                    queryCompleted(d) { this.queries.delete(d); }
                    start() { this.running = !0; }
                    stop() { this.running = !1; for (const d of this.queries)
                        d.stop(); this.queries.clear(); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(13), e = f(60), { EventEmitter: c } = f(12), n = f(1), t = n("libp2p:bootstrap");
                t.error = n("libp2p:bootstrap:error"), (E.exports = class extends c {
                    constructor(s = {}) { if (!s.list || !s.list.length)
                        throw new Error("Bootstrap requires a list of peer addresses"); super(), this._list = s.list, this._interval = s.interval || 1e4, this._timer = null; }
                    start() { this._timer || (this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval), this._discoverBootstrapPeers()); }
                    _discoverBootstrapPeers() { this._timer && this._list.forEach(s => { if (!e.P2P.matches(s))
                        return t.error("Invalid multiaddr"); const u = r(s), i = d.createFromB58String(u.getPeerId()); try {
                        this.emit("peer", { id: i, multiaddrs: [u] });
                    }
                    catch (o) {
                        t.error("Invalid bootstrap peer id", o);
                    } }); }
                    stop() { clearInterval(this._timer), this._timer = null; }
                }).tag = "bootstrap";
            }, function (E, m, f) {
                "use strict";
                const d = f(1088), r = f(324), e = f(13), c = f(0);
                class n {
                    constructor(i, o, h) { this.peerId = i, this.libp2p = o, this.bitswap = h; }
                    static async start({ peerId: i, repo: o, print: h, options: a }) { o.closed && await o.open(); const l = await o.config.getAll(), p = r({ options: a, repo: o, peerId: i, multiaddrs: t(i, l), config: l, keychainConfig: void 0 }); p.keychain && await p.loadKeychain(), await p.start(); for (const b of p.transportManager.getAddrs())
                        h(`Swarm listening on ${b}/p2p/${i.toB58String()}`); const g = new d(p, o.blocks, { statsEnabled: !0 }); return await g.start(), new n(i, p, g); }
                    static async stop(i) { await Promise.all([i.bitswap.stop(), i.libp2p.stop()]); }
                }
                E.exports = n;
                const t = (u, i) => { const o = u.toB58String(), h = [], a = i.Addresses && i.Addresses.Swarm || []; for (const l of a) {
                    let p = e(l);
                    if (p.protoCodes().includes(s))
                        throw c(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
                    const g = p.getPeerId();
                    g && g !== o && (p = p.encapsulate("/p2p/" + o)), h.push(p);
                } return h; }, s = 479;
            }, function (E, m, f) {
                "use strict";
                const d = f(1089), r = f(1096), e = f(1099), c = f(1104), n = f(46).logger, t = f(1105), s = f(47), u = f(137), i = { statsEnabled: !1, statsComputeThrottleTimeout: 1e3, statsComputeThrottleMaxQueueSize: 1e3 }, o = ["blocksReceived", "dataReceived", "dupBlksReceived", "dupDataReceived", "blocksSent", "dataSent", "providesBufferLength", "wantListLength", "peerCount"];
                E.exports = class {
                    constructor(h, a, l) { this._libp2p = h, this._log = n(this.peerId), this._options = Object.assign({}, i, l), this._stats = new t(o, { enabled: this._options.statsEnabled, computeThrottleTimeout: this._options.statsComputeThrottleTimeout, computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize }), this.network = new r(h, this, {}, this._stats), this.blockstore = a, this.engine = new e(this.peerId, a, this.network, this._stats), this.wm = new d(this.peerId, this.network, this._stats), this.notifications = new c(this.peerId); }
                    get peerId() { return this._libp2p.peerId; }
                    async _receiveMessage(h, a) { try {
                        await this.engine.messageReceived(h, a);
                    }
                    catch (g) {
                        this._log("failed to receive message", a);
                    } if (a.blocks.size === 0)
                        return; const l = Array.from(a.blocks.values()), p = l.filter(g => this.wm.wantlist.contains(g.cid)).map(g => g.cid); this.wm.cancelWants(p), await Promise.all(l.map(async (g) => { const b = p.includes(g.cid); await this._handleReceivedBlock(h, g, b); })); }
                    async _handleReceivedBlock(h, a, l) { this._log("received block"); const p = await this.blockstore.has(a.cid); this._updateReceiveCounters(h.toB58String(), a, p), l && await this.put(a); }
                    _updateReceiveCounters(h, a, l) { this._stats.push(h, "blocksReceived", 1), this._stats.push(h, "dataReceived", a.data.length), l && (this._stats.push(h, "dupBlksReceived", 1), this._stats.push(h, "dupDataReceived", a.data.length)); }
                    _receiveError(h) { this._log.error("ReceiveError: %s", h.message); }
                    _onPeerConnected(h) { this.wm.connected(h); }
                    _onPeerDisconnected(h) { this.wm.disconnected(h), this.engine.peerDisconnected(h), this._stats.disconnected(h); }
                    enableStats() { this._stats.enable(); }
                    disableStats() { this._stats.disable(); }
                    wantlistForPeer(h) { return this.engine.wantlistForPeer(h); }
                    ledgerForPeer(h) { return this.engine.ledgerForPeer(h); }
                    async get(h, a = {}) { const l = (v, R) => (this.wm.wantBlocks([v], R), this.notifications.wantBlock(v, R)); let p = !1; const g = new s, b = u([a.signal, g.signal]), I = await Promise.race([this.notifications.wantBlock(h, { signal: b }), (async (v, R) => { try {
                            return await this.blockstore.get(v, R);
                        }
                        catch (_) {
                            if (_.code !== "ERR_NOT_FOUND")
                                throw _;
                            return p || (p = !0, this.network.findAndConnect(v).catch(k => this._log.error(k))), l(v, R);
                        } })(h, { signal: b })]); return g.abort(), I; }
                    async *getMany(h, a = {}) { for await (const l of h)
                        yield this.get(l, a); }
                    unwant(h) { Array.isArray(h) || (h = [h]), this.wm.unwantBlocks(h), h.forEach(a => this.notifications.unwantBlock(a)); }
                    cancelWants(h) { Array.isArray(h) || (h = [h]), this.wm.cancelWants(h); }
                    async put(h) { await this.blockstore.put(h), this._sendHaveBlockNotifications(h); }
                    async *putMany(h) { for await (const a of this.blockstore.putMany(h))
                        this._sendHaveBlockNotifications(a), yield a; }
                    _sendHaveBlockNotifications(h) { this.notifications.hasBlock(h), this.engine.receivedBlocks([h]), this.network.provide(h.cid).catch(a => { this._log.error("Failed to provide: %s", a.message); }); }
                    getWantlist() { return this.wm.wantlist.entries(); }
                    peers() { return this.engine.peers(); }
                    stat() { return this._stats; }
                    start() { this.wm.start(), this.network.start(), this.engine.start(); }
                    stop() { this._stats.stop(), this.wm.stop(), this.network.stop(), this.engine.stop(); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(102), r = f(130), e = f(131), c = f(1094), n = f(46).logger;
                E.exports = class {
                    constructor(t, s, u) { this.peers = new Map, this.wantlist = new r(u), this.network = s, this._stats = u, this._peerId = t, this._log = n(t, "want"); }
                    _addEntries(t, s, u) { const i = t.map((o, h) => new d.Entry(o, e.kMaxPriority - h, d.WantType.Block, s)); i.forEach(o => { o.cancel ? u ? this.wantlist.removeForce(o.cid) : this.wantlist.remove(o.cid) : (this._log("adding to wl"), this.wantlist.add(o.cid, o.priority)); }); for (const o of this.peers.values())
                        o.addEntries(i); }
                    _startPeerHandler(t) { let s = this.peers.get(t.toB58String()); if (s)
                        return void s.refcnt++; s = new c(this._peerId, t, this.network); const u = new d(!0); for (const i of this.wantlist.entries())
                        u.addEntry(i[1].cid, i[1].priority); return s.addMessage(u), this.peers.set(t.toB58String(), s), s; }
                    _stopPeerHandler(t) { const s = this.peers.get(t.toB58String()); s && (s.refcnt--, s.refcnt > 0 || this.peers.delete(t.toB58String())); }
                    wantBlocks(t, s = {}) { this._addEntries(t, !1), s && s.signal && s.signal.addEventListener("abort", () => { this.cancelWants(t); }); }
                    unwantBlocks(t) { this._log("unwant blocks: %s", t.length), this._addEntries(t, !0, !0); }
                    cancelWants(t) { this._log("cancel wants: %s", t.length), this._addEntries(t, !0); }
                    connectedPeers() { return Array.from(this.peers.keys()); }
                    connected(t) { this._startPeerHandler(t); }
                    disconnected(t) { this._stopPeerHandler(t); }
                    start() { }
                    stop() { this.peers.forEach(t => this.disconnected(t.peerId)), clearInterval(this.timer); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(19);
                E.exports = r => { if (!(r instanceof Uint8Array))
                    throw new Error("arg needs to be a Uint8Array"); const e = []; for (; r.length > 0;) {
                    const c = d.decode(r);
                    e.push(c), r = r.slice(d.decode.bytes);
                } return e; };
            }, function (E, m, f) {
                "use strict";
                const d = f(21);
                E.exports = d(`
  message Message {
    message Wantlist {
      enum WantType {
        Block = 0;
        Have = 1;
      }

      message Entry {
        // changed from string to bytes, it makes a difference in JavaScript
        optional bytes block = 1;      // the block cid (cidV0 in bitswap 1.0.0, cidV1 in bitswap 1.1.0)
        optional int32 priority = 2;    // the priority (normalized). default to 1
        optional bool cancel = 3;       // whether this revokes an entry
        WantType wantType = 4;         // Note: defaults to enum 0, ie Block
        bool sendDontHave = 5;        // Note: defaults to false
      }

      repeated Entry entries = 1;       // a list of wantlist entries
      optional bool full = 2;           // whether this is the full wantlist. default to false
    }

    message Block {
      optional bytes prefix = 1;        // CID prefix (cid version, multicodec and multihash prefix (type + length)
      optional bytes data = 2;
    }

    enum BlockPresenceType {
      Have = 0;
      DontHave = 1;
    }
    message BlockPresence {
      bytes cid = 1;
      BlockPresenceType type = 2;
    }

    optional Wantlist wantlist = 1;
    repeated bytes blocks = 2;          // used to send Blocks in bitswap 1.0.0
    repeated Block payload = 3;         // used to send Blocks in bitswap 1.1.0
    repeated BlockPresence blockPresences = 4;
    int32 pendingBytes = 5;
  }
`);
            }, function (E, m, f) {
                "use strict";
                const d = f(130).Entry;
                E.exports = class {
                    constructor(r, e, c, n, t) { this.entry = new d(r, e, c), this.cancel = Boolean(n), this.sendDontHave = Boolean(t); }
                    get cid() { return this.entry.cid; }
                    set cid(r) { this.entry.cid = r; }
                    get priority() { return this.entry.priority; }
                    set priority(r) { this.entry.priority = r; }
                    get wantType() { return this.entry.wantType; }
                    set wantType(r) { this.entry.wantType = r; }
                    get [Symbol.toStringTag]() { return `BitswapMessageEntry ${this.cid.toString("base58btc")} <cancel: ${this.cancel}, priority: ${this.priority}>`; }
                    equals(r) { return this.cancel === r.cancel && this.sendDontHave === r.sendDontHave && this.wantType === r.wantType && this.entry.equals(r.entry); }
                };
            }, function (E, m, f) {
                "use strict";
                class d {
                    constructor(e, c, n) { this._refCounter = 1, this.cid = e, this.priority = c || 1, this.wantType = n; }
                    inc() { this._refCounter += 1; }
                    dec() { this._refCounter = Math.max(0, this._refCounter - 1); }
                    hasRefs() { return this._refCounter > 0; }
                    get [Symbol.toStringTag]() { return `WantlistEntry <key: ${this.cid.toString("base58btc")}, priority: ${this.priority}, refs: ${this._refCounter}>`; }
                    equals(e) { return this._refCounter === e._refCounter && this.cid.equals(e.cid) && this.priority === e.priority && this.wantType === e.wantType; }
                }
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(1095), r = f(102), e = f(46).logger, { wantlistSendDebounceMs: c } = f(131);
                E.exports = class {
                    constructor(n, t, s) { this.peerId = t, this.network = s, this.refcnt = 1, this._entries = [], this._log = e(n, "msgqueue", t.toB58String().slice(0, 8)), this.sendEntries = d(this._sendEntries.bind(this), c); }
                    addMessage(n) { n.empty || this.send(n); }
                    addEntries(n) { this._entries = this._entries.concat(n), this.sendEntries(); }
                    _sendEntries() { if (!this._entries.length)
                        return; const n = new r(!1); this._entries.forEach(t => { t.cancel ? n.cancel(t.cid) : n.addEntry(t.cid, t.priority); }), this._entries = [], this.addMessage(n); }
                    async send(n) { try {
                        await this.network.connectTo(this.peerId);
                    }
                    catch (t) {
                        return void this._log.error("cant connect to peer %s: %s", this.peerId.toB58String(), t.message);
                    } this._log("sending message to peer %s", this.peerId.toB58String()), this.network.sendMessage(this.peerId, n).catch(t => { this._log.error("send error: %s", t.message); }); }
                };
            }, function (E, m, f) {
                "use strict";
                E.exports = function (d, r, e) { var c; return function () { if (!r)
                    return d.apply(this, arguments); var n = this, t = arguments, s = e && !c; return clearTimeout(c), c = setTimeout(function () { if (c = null, !s)
                    return d.apply(n, t); }, r), s ? d.apply(this, arguments) : void 0; }; };
            }, function (E, m, f) {
                "use strict";
                const d = f(35), r = f(27), e = f(1097), c = f(102), n = f(131), t = f(46).logger;
                E.exports = class {
                    constructor(s, u, i, o) { this._log = t(s.peerId, "network"), i = i || {}, this.libp2p = s, this.bitswap = u, this.protocols = ["/ipfs/bitswap/1.0.0"], i.b100Only || (this.protocols.unshift("/ipfs/bitswap/1.1.0"), this.protocols.unshift("/ipfs/bitswap/1.2.0")), this._stats = o, this._running = !1, this._onPeerConnect = this._onPeerConnect.bind(this), this._onPeerDisconnect = this._onPeerDisconnect.bind(this), this._onConnection = this._onConnection.bind(this); }
                    start() { this._running = !0, this.libp2p.handle(this.protocols, this._onConnection); const s = new e({ multicodecs: this.protocols, handlers: { onConnect: this._onPeerConnect, onDisconnect: this._onPeerDisconnect } }); this._registrarId = this.libp2p.registrar.register(s); for (const u of this.libp2p.peerStore.peers.values()) {
                        const i = this.libp2p.connectionManager.get(u.id);
                        i && this._onPeerConnect(i.remotePeer);
                    } }
                    stop() { this._running = !1, this.libp2p.unhandle(this.protocols), this.libp2p.registrar.unregister(this._registrarId); }
                    async _onConnection({ protocol: s, stream: u, connection: i }) { if (this._running) {
                        this._log("incoming new bitswap %s connection from %s", s, i.remotePeer.toB58String());
                        try {
                            await r(u, d.decode(), async (o) => { for await (const h of o)
                                try {
                                    const a = await c.deserialize(h.slice());
                                    await this.bitswap._receiveMessage(i.remotePeer, a);
                                }
                                catch (a) {
                                    this.bitswap._receiveError(a);
                                    break;
                                } });
                        }
                        catch (o) {
                            this._log(o);
                        }
                    } }
                    _onPeerConnect(s) { this.bitswap._onPeerConnected(s); }
                    _onPeerDisconnect(s) { this.bitswap._onPeerDisconnected(s); }
                    findProviders(s, u, i = {}) { return this.libp2p.contentRouting.findProviders(s, { maxTimeout: n.providerRequestTimeout, maxNumProviders: u, signal: i.signal }); }
                    async findAndConnect(s, u) { const i = []; for await (const o of this.findProviders(s, n.maxProvidersPerRequest, u))
                        this._log("connecting to providers", o.id.toB58String()), i.push(this.connectTo(o, u)); await Promise.all(i); }
                    async provide(s, u) { await this.libp2p.contentRouting.provide(s, u); }
                    async sendMessage(s, u) { if (!this._running)
                        throw new Error("network isn't running"); const i = s.toB58String(); this._log("sendMessage to %s", i, u); const { stream: o, protocol: h } = await this._dialPeer(s); let a; switch (h) {
                        case "/ipfs/bitswap/1.0.0":
                            a = u.serializeToBitswap100();
                            break;
                        case "/ipfs/bitswap/1.1.0":
                        case "/ipfs/bitswap/1.2.0":
                            a = u.serializeToBitswap110();
                            break;
                        default: throw new Error("Unknown protocol: " + h);
                    } !async function (l, p, g) { try {
                        await r([p], d.encode(), l);
                    }
                    catch (b) {
                        g(b);
                    } }(o, a, this._log), this._updateSentStats(s, u.blocks); }
                    async connectTo(s, u) { if (!this._running)
                        throw new Error("network isn't running"); return this.libp2p.dial(s, u); }
                    _dialPeer(s) { return this.libp2p.dialProtocol(s, ["/ipfs/bitswap/1.2.0", "/ipfs/bitswap/1.1.0", "/ipfs/bitswap/1.0.0"]); }
                    _updateSentStats(s, u) { const i = s.toB58String(); this._stats && (u.forEach(o => this._stats.push(i, "dataSent", o.data.length)), this._stats.push(i, "blocksSent", u.size)); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = f(1098);
                E.exports = d(class extends r {
                    constructor({ min: e, max: c, multicodecs: n, handlers: t }) { if (super({ min: e, max: c, handlers: t }), !n)
                        throw new Error("one or more multicodec should be provided"); if (!t)
                        throw new Error("the handlers should be provided"); if (typeof t.onConnect != "function")
                        throw new Error("the 'onConnect' handler must be provided"); if (typeof t.onDisconnect != "function")
                        throw new Error("the 'onDisconnect' handler must be provided"); this.multicodecs = Array.isArray(n) ? n : [n], this._registrar = void 0, this._onProtocolChange = this._onProtocolChange.bind(this), this._onPeerConnect = this._onPeerConnect.bind(this); }
                    set registrar(e) { this._registrar = e, this._registrar.peerStore.on("change:protocols", this._onProtocolChange), this._registrar.connectionManager.on("peer:connect", this._onPeerConnect), this._updatePeers(this._registrar.peerStore.peers.values()); }
                    _updatePeers(e) { for (const { id: c, protocols: n } of e)
                        if (this.multicodecs.filter(t => n.includes(t)).length) {
                            this.peers.add(c.toB58String());
                            const t = this._registrar.getConnection(c);
                            t && this._onConnect(c, t);
                        }
                        else
                            this.peers.delete(c.toB58String()); }
                    _onProtocolChange({ peerId: e, protocols: c }) { const n = this.peers.has(e.toB58String()), t = c.filter(s => this.multicodecs.includes(s)); n && t.length === 0 && this._onDisconnect(e); for (const s of c)
                        if (this.multicodecs.includes(s)) {
                            const u = this._registrar.peerStore.get(e);
                            return void this._updatePeers([u]);
                        } }
                    _onPeerConnect(e) { const c = e.remotePeer, n = this._registrar.peerStore.protoBook.get(c); n && this.multicodecs.find(t => n.includes(t)) && (this.peers.add(c.toB58String()), this._onConnect(c, e)); }
                }, { className: "MulticodecTopology", symbolName: "@libp2p/js-interfaces/topology/multicodec-topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(26), r = () => { };
                E.exports = d(class {
                    constructor({ min: e = 0, max: c = 1 / 0, handlers: n = {} }) { this.min = e, this.max = c, this._onConnect = n.onConnect || r, this._onDisconnect = n.onDisconnect || r, this.peers = new Set; }
                    set registrar(e) { this._registrar = e; }
                    disconnect(e) { this._onDisconnect(e); }
                }, { className: "Topology", symbolName: "@libp2p/js-interfaces/topology" });
            }, function (E, m, f) {
                "use strict";
                const d = f(4), r = f(102), e = r.WantType, c = f(130), n = f(1100), t = f(1101), s = f(1103), { logger: u } = f(46);
                E.exports = class {
                    constructor(i, o, h, a, l) { this._log = u(i, "engine"), this.blockstore = o, this.network = h, this._stats = a, this._opts = this._processOpts(l), this.ledgerMap = new Map, this._running = !1, this._requestQueue = new t(s); }
                    _processOpts(i) { return { maxSizeReplaceHasWithBlock: 1024, targetMessageSize: 16384, ...i }; }
                    _scheduleProcessTasks() { setTimeout(() => { this._processTasks(); }); }
                    async _processTasks() { if (!this._running)
                        return; const { peerId: i, tasks: o, pendingSize: h } = this._requestQueue.popTasks(this._opts.targetMessageSize); if (o.length === 0)
                        return; const a = new r(!1); a.setPendingBytes(h); const l = [], p = new Map; for (const b of o) {
                        const I = new d(b.topic);
                        b.data.haveBlock ? b.data.isWantBlock ? (l.push(I), p.set(b.topic, b.data)) : a.addHave(I) : a.addDontHave(I);
                    } const g = await this._getBlocks(l); for (const [b, I] of p) {
                        const v = g.get(b);
                        if (v)
                            a.addBlock(v);
                        else if (I.sendDontHave) {
                            const R = new d(b);
                            a.addDontHave(R);
                        }
                    } if (a.empty)
                        return this._requestQueue.tasksDone(i, o), void this._scheduleProcessTasks(); try {
                        await this.network.sendMessage(i, a);
                        for (const b of g.values())
                            this.messageSent(i, b);
                    }
                    catch (b) {
                        this._log.error(b);
                    } this._requestQueue.tasksDone(i, o), this._scheduleProcessTasks(); }
                    wantlistForPeer(i) { const o = i.toB58String(); return this.ledgerMap.has(o) ? this.ledgerMap.get(o).wantlist.sortedEntries() : new Map; }
                    ledgerForPeer(i) { const o = i.toB58String(), h = this.ledgerMap.get(o); return h ? { peer: h.partner.toPrint(), value: h.debtRatio(), sent: h.accounting.bytesSent, recv: h.accounting.bytesRecv, exchanged: h.exchangeCount } : null; }
                    peers() { return Array.from(this.ledgerMap.values()).map(i => i.partner); }
                    receivedBlocks(i) { i.length && (this.ledgerMap.forEach(o => { i.forEach(h => { const a = o.wantlistContains(h.cid); if (!a)
                        return; const l = h.data.length, p = this._sendAsBlock(a.wantType, l); let g = l; p || (g = r.blockPresenceSize(a.cid)), this._requestQueue.pushTasks(o.partner, [{ topic: a.cid.toString(), priority: a.priority, size: g, data: { blockSize: l, isWantBlock: p, haveBlock: !0, sendDontHave: !1 } }]); }); }), this._scheduleProcessTasks()); }
                    async messageReceived(i, o) { const h = this._findOrCreate(i); if (o.empty)
                        return; if (o.full && (h.wantlist = new c), this._updateBlockAccounting(o.blocks, h), o.wantlist.size === 0)
                        return void this._scheduleProcessTasks(); const a = [], l = []; o.wantlist.forEach(p => { p.cancel ? (h.cancelWant(p.cid), a.push(p.cid)) : (h.wants(p.cid, p.priority, p.wantType), l.push(p)); }), this._cancelWants(i, a), await this._addWants(i, l), this._scheduleProcessTasks(); }
                    _cancelWants(i, o) { for (const h of o)
                        this._requestQueue.remove(h.toString(), i); }
                    async _addWants(i, o) { const h = await this._getBlockSizes(o.map(l => l.cid)), a = []; for (const l of o) {
                        const p = l.cid.toString(), g = h.get(p);
                        if (g == null)
                            l.sendDontHave && a.push({ topic: p, priority: l.priority, size: r.blockPresenceSize(l.cid), data: { isWantBlock: l.wantType === e.Block, blockSize: 0, haveBlock: !1, sendDontHave: l.sendDontHave } });
                        else {
                            const b = this._sendAsBlock(l.wantType, g);
                            let I = g;
                            b || (I = r.blockPresenceSize(l.cid)), a.push({ topic: p, priority: l.priority, size: I, data: { isWantBlock: b, blockSize: g, haveBlock: !0, sendDontHave: l.sendDontHave } });
                        }
                        this._requestQueue.pushTasks(i, a);
                    } }
                    _sendAsBlock(i, o) { return i === e.Block || o <= this._opts.maxSizeReplaceHasWithBlock; }
                    async _getBlockSizes(i) { const o = await this._getBlocks(i); return new Map([...o].map(([h, a]) => [h, a.data.length])); }
                    async _getBlocks(i) { const o = new Map; return await Promise.all(i.map(async (h) => { try {
                        const a = await this.blockstore.get(h);
                        o.set(h.toString(), a);
                    }
                    catch (a) {
                        a.code !== "ERR_NOT_FOUND" && this._log.error("failed to query blockstore for %s: %s", h, a);
                    } })), o; }
                    _updateBlockAccounting(i, o) { i.forEach(h => { this._log("got block (%s bytes)", h.data.length), o.receivedBytes(h.data.length); }); }
                    messageSent(i, o) { const h = this._findOrCreate(i); h.sentBytes(o ? o.data.length : 0), o && o.cid && h.wantlist.remove(o.cid); }
                    numBytesSentTo(i) { return this._findOrCreate(i).accounting.bytesSent; }
                    numBytesReceivedFrom(i) { return this._findOrCreate(i).accounting.bytesRecv; }
                    peerDisconnected(i) { }
                    _findOrCreate(i) { const o = i.toB58String(); if (this.ledgerMap.has(o))
                        return this.ledgerMap.get(o); const h = new n(i); return this.ledgerMap.set(o, h), this._stats && this._stats.push(o, "peerCount", 1), h; }
                    start() { this._running = !0; }
                    stop() { this._running = !1; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(130);
                E.exports = class {
                    constructor(r) { this.partner = r, this.wantlist = new d, this.exchangeCount = 0, this.sentToPeer = new Map, this.accounting = { bytesSent: 0, bytesRecv: 0 }; }
                    sentBytes(r) { this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesSent += r; }
                    receivedBytes(r) { this.exchangeCount++, this.lastExchange = new Date().getTime(), this.accounting.bytesRecv += r; }
                    wants(r, e, c) { this.wantlist.add(r, e, c); }
                    cancelWant(r) { this.wantlist.remove(r); }
                    wantlistContains(r) { return this.wantlist.contains(r); }
                    debtRatio() { return this.accounting.bytesSent / (this.accounting.bytesRecv + 1); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(1102), r = { hasNewInfo: () => !1, merge() { } };
                class e {
                    constructor(t, s) { this.peerId = t, this._taskMerger = s, this._activeTotalSize = 0, this._pending = new c, this._active = new Set; }
                    pushTasks(t) { for (const s of t)
                        this._pushTask(s); }
                    _pushTask(t) { if (!this._taskHasMoreInfoThanActiveTasks(t))
                        return; const s = this._pending.get(t.topic); if (s)
                        return t.priority > s.priority && this._pending.updatePriority(t.topic, t.priority), void this._taskMerger.merge(t, s); this._pending.add(t); }
                    _taskHasMoreInfoThanActiveTasks(t) { const s = []; for (const u of this._active)
                        u.topic === t.topic && s.push(u); return s.length === 0 || this._taskMerger.hasNewInfo(t, s); }
                    popTasks(t) { let s = 0; const u = [], i = this._pending.tasks(); for (let o = 0; o < i.length && s < t; o++) {
                        const h = i[o];
                        u.push(h), s += h.size, this._pending.delete(h.topic), this._activeTotalSize += h.size, this._active.add(h);
                    } return { tasks: u, pendingSize: this._pending.totalSize }; }
                    taskDone(t) { this._active.has(t) && (this._activeTotalSize -= t.size, this._active.delete(t)); }
                    remove(t) { this._pending.delete(t); }
                    isIdle() { return this._pending.length === 0 && this._active.length === 0; }
                    static compare(t, s) { return t[1]._pending.length === 0 ? 1 : s[1]._pending.length === 0 ? -1 : t[1]._activeTotalSize === s[1]._activeTotalSize ? s[1]._pending.length - t[1]._pending.length : t[1]._activeTotalSize - s[1]._activeTotalSize; }
                }
                class c {
                    constructor() { this._tasks = new d([], this._compare); }
                    get length() { return this._tasks.size; }
                    get totalSize() { return [...this._tasks.values()].reduce((t, s) => t + s.task.size, 0); }
                    get(t) { return (this._tasks.get(t) || {}).task; }
                    add(t) { this._tasks.set(t.topic, { created: Date.now(), task: t }); }
                    delete(t) { this._tasks.delete(t); }
                    tasks() { return [...this._tasks.values()].map(t => t.task); }
                    updatePriority(t, s) { const u = this._tasks.get(t); if (!u)
                        return; const i = this._tasks.indexOf(t); u.task.priority = s, this._tasks.update(i); }
                    _compare(t, s) { return t[1].task.priority === s[1].task.priority ? t[1].created - s[1].created : s[1].task.priority - t[1].task.priority; }
                }
                E.exports = class {
                    constructor(n) { this._taskMerger = n || r, this._byPeer = new d([], e.compare, !0); }
                    pushTasks(n, t) { let s = this._byPeer.get(n.toB58String()); s || (s = new e(n, this._taskMerger)), s.pushTasks(t), this._byPeer.set(n.toB58String(), s); }
                    popTasks(n) { if (this._byPeer.size === 0)
                        return { tasks: [], pendingSize: 0 }; const t = this._head(), { tasks: s, pendingSize: u } = t.popTasks(n); if (s.length === 0)
                        return { tasks: s, pendingSize: u }; const i = t.peerId; return t.isIdle() ? this._byPeer.delete(i.toB58String()) : this._byPeer.update(0), { peerId: i, tasks: s, pendingSize: u }; }
                    _head() { for (const [, n] of this._byPeer)
                        return n; }
                    remove(n, t) { const s = this._byPeer.get(t.toB58String()); s && s.remove(n); }
                    tasksDone(n, t) { const s = this._byPeer.get(n.toB58String()); if (!s)
                        return; const u = this._byPeer.indexOf(n.toB58String()); for (const i of t)
                        s.taskDone(i); this._byPeer.update(u); }
                };
            }, function (E, m, f) {
                "use strict";
                class d extends Map {
                    constructor(e, c) { super(), this._cmp = c || this._defaultSort, this._keys = []; for (const [n, t] of e || [])
                        this.set(n, t); }
                    update(e) { if (e < 0 || e >= this._keys.length)
                        return; const c = this._keys[e]; this._keys.splice(e, 1); const n = this._find(c); this._keys.splice(n, 0, c); }
                    set(e, c) { if (this.has(e)) {
                        const t = this.indexOf(e);
                        this._keys.splice(t, 1);
                    } super.set(e, c); const n = this._find(e); this._keys.splice(n, 0, e); }
                    clear() { super.clear(), this._keys = []; }
                    delete(e) { if (!this.has(e))
                        return; const c = this.indexOf(e); this._keys.splice(c, 1), super.delete(e); }
                    indexOf(e) { if (!this.has(e))
                        return -1; const c = this._find(e); if (this._keys[c] === e)
                        return c; for (let n = 1; n < this._keys.length; n++) {
                        if (this._keys[c + n] === e)
                            return c + n;
                        if (this._keys[c - n] === e)
                            return c - n;
                    } return -1; }
                    _find(e) { let c = 0, n = this._keys.length; for (; c < n;) {
                        const t = c + n >>> 1, s = this._kCmp(this._keys[t], e);
                        if (s < 0)
                            c = t + 1;
                        else {
                            if (!(s > 0))
                                return t;
                            n = t;
                        }
                    } return c; }
                    *keys() { for (const e of this._keys)
                        yield e; }
                    *values() { for (const e of this._keys)
                        yield this.get(e); }
                    *entries() { for (const e of this._keys)
                        yield [e, this.get(e)]; }
                    *[Symbol.iterator]() { yield* this.entries(); }
                    forEach(e, c) { if (e)
                        for (const n of this._keys)
                            e.apply(c, [[n, this.get(n)]]); }
                    _defaultSort(e, c) { return e[0] < c[0] ? -1 : c[0] < e[0] ? 1 : 0; }
                    _kCmp(e, c) { return this._cmp([e, this.get(e)], [c, this.get(c)]); }
                }
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const d = { hasNewInfo(r, e) { let c = !1, n = !1; for (const t of e)
                        t.data.haveBlock && (c = !0), t.data.isWantBlock && (n = !0); return !(n || !r.data.isWantBlock) || !(c || !r.data.haveBlock); }, merge(r, e) { const c = r.data, n = e.data; !n.haveBlock && c.haveBlock && (n.haveBlock = c.haveBlock, n.blockSize = c.blockSize), !n.isWantBlock && c.isWantBlock && (n.isWantBlock = !0, n.haveBlock && !c.haveBlock || (n.haveBlock = c.haveBlock, e.size = r.size)), n.isWantBlock && n.haveBlock && (e.size = n.blockSize); } };
                E.exports = d;
            }, function (E, m, f) {
                "use strict";
                const d = f(12).EventEmitter, r = f(93), e = f(20), c = f(5), n = f(131), t = f(46).logger, s = i => "unwant:" + c(i.multihash, "base64"), u = i => "block:" + c(i.multihash, "base64");
                E.exports = class extends d {
                    constructor(i) { super(), this.setMaxListeners(n.maxListeners), this._log = t(i, "notif"); }
                    hasBlock(i) { const o = u(i.cid); this._log(o), this.emit(o, i); }
                    wantBlock(i, o = {}) { if (!i)
                        throw new Error("Not a valid cid"); const h = u(i), a = s(i); return this._log("wantBlock:" + i), new Promise((l, p) => { const g = () => { this.removeListener(h, b), p(new Error(`Block for ${i} unwanted`)); }, b = I => { if (this.removeListener(a, g), !e(i.multihash, I.cid.multihash))
                        return p(new Error("Incorrect block received for " + i)); i.version === I.cid.version && i.codec === I.cid.codec || (I = new r(I.data, i)), l(I); }; this.once(a, g), this.once(h, b), o && o.signal && o.signal.addEventListener("abort", () => { this.removeListener(h, b), this.removeListener(a, g), p(new Error(`Want for ${i} aborted`)); }); }); }
                    unwantBlock(i) { const o = s(i); this._log(o), this.emit(o); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(1106), e = { movingAverageIntervals: [6e4, 3e5, 9e5] };
                E.exports = class extends d {
                    constructor(c, n) { super(); const t = Object.assign({}, e, n); if (typeof t.computeThrottleTimeout != "number")
                        throw new Error("need computeThrottleTimeout"); if (typeof t.computeThrottleMaxQueueSize != "number")
                        throw new Error("need computeThrottleMaxQueueSize"); this._initialCounters = c, this._options = t, this._enabled = this._options.enabled, this._global = new r(c, t), this._global.on("update", s => this.emit("update", s)), this._peers = new Map; }
                    enable() { this._enabled = !0, this._options.enabled = !0, this._global.enable(); }
                    disable() { this._enabled = !1, this._options.enabled = !1, this._global.disable(); }
                    stop() { this._enabled = !1, this._global.stop(); for (const c of this._peers)
                        c[1].stop(); }
                    get snapshot() { return this._global.snapshot; }
                    get movingAverages() { return this._global.movingAverages; }
                    forPeer(c) { return c.toB58String && (c = c.toB58String()), this._peers.get(c); }
                    push(c, n, t) { if (this._enabled && (this._global.push(n, t), c)) {
                        let s = this._peers.get(c);
                        s || (s = new r(this._initialCounters, this._options), this._peers.set(c, s)), s.push(n, t);
                    } }
                    disconnected(c) { const n = c.toB58String(), t = this._peers.get(n); t && (t.stop(), this._peers.delete(n)); }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(12), r = f(30), e = f(342);
                E.exports = class extends d {
                    constructor(c, n) { super(), this._options = n, this._queue = [], this._stats = {}, this._frequencyLastTime = Date.now(), this._frequencyAccumulators = {}, this._movingAverages = {}, this._update = this._update.bind(this), c.forEach(t => { this._stats[t] = r(0), this._movingAverages[t] = {}, this._options.movingAverageIntervals.forEach(s => { (this._movingAverages[t][s] = e(s)).push(this._frequencyLastTime, 0); }); }), this._enabled = this._options.enabled; }
                    enable() { this._enabled = !0; }
                    disable() { this._disabled = !0; }
                    stop() { this._timeout && clearTimeout(this._timeout); }
                    get snapshot() { return Object.assign({}, this._stats); }
                    get movingAverages() { return Object.assign({}, this._movingAverages); }
                    push(c, n) { this._enabled && (this._queue.push([c, n, Date.now()]), this._resetComputeTimeout()); }
                    _resetComputeTimeout() { this._timeout && clearTimeout(this._timeout), this._timeout = setTimeout(this._update, this._nextTimeout()); }
                    _nextTimeout() { const c = this._queue.length / this._options.computeThrottleMaxQueueSize; return Math.max(this._options.computeThrottleTimeout * (1 - c), 0); }
                    _update() { if (this._timeout = null, this._queue.length) {
                        let c;
                        for (; this._queue.length;) {
                            const n = c = this._queue.shift();
                            this._applyOp(n);
                        }
                        this._updateFrequency(c[2]), this.emit("update", this._stats);
                    } }
                    _updateFrequency(c) { const n = c - this._frequencyLastTime; n && Object.keys(this._stats).forEach(t => { this._updateFrequencyFor(t, n, c); }), this._frequencyLastTime = c; }
                    _updateFrequencyFor(c, n, t) { const s = this._frequencyAccumulators[c] || 0; this._frequencyAccumulators[c] = 0; const u = s / n * 1e3; let i = this._movingAverages[c]; i || (i = this._movingAverages[c] = {}), this._options.movingAverageIntervals.forEach(o => { let h = i[o]; h || (h = i[o] = e(o)), h.push(t, u); }); }
                    _applyOp(c) { const n = c[0], t = c[1]; if (typeof t != "number")
                        throw new Error("invalid increment number:", t); let s; s = Object.prototype.hasOwnProperty.call(this._stats, n) ? this._stats[n] : this._stats[n] = r(0), this._stats[n] = s.plus(t), this._frequencyAccumulators[n] || (this._frequencyAccumulators[n] = 0), this._frequencyAccumulators[n] += t; }
                };
            }, function (E, m, f) {
                "use strict";
                const d = f(291);
                E.exports = ({ path: r, repoOwner: e }) => d(r, { singleProcess: e !== !1 });
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = { success: !0, time: 0, text: "" }, e = f(2);
                E.exports = ({ network: c }) => e(async function* (n, t = {}) { const { libp2p: s } = await c.use(); t.count = t.count || 10, d.isPeerId(n) || (n = d.createFromCID(n)); let u = s.peerStore.get(n); u || (yield { ...r, text: "Looking up peer " + n }, u = await s.peerRouting.findPeer(n)), yield { ...r, text: "PING " + u.id.toB58String() }; let i = 0, o = 0; for (let h = 0; h < t.count; h++)
                    try {
                        const a = await s.ping(u.id);
                        o += a, i++, yield { ...r, time: a };
                    }
                    catch (a) {
                        yield { ...r, success: !1, text: a.toString() };
                    } if (i) {
                    const h = o / i;
                    yield { ...r, text: `Average latency: ${h}ms` };
                } });
            }, function (E, m, f) {
                "use strict";
                const d = f(7), r = f(4), e = f(0), { NotEnabledError: c } = f(111), n = f(164), t = f(2);
                E.exports = ({ network: i, repo: o }) => { const { get: h, put: a, findProvs: l, findPeer: p, provide: g, query: b } = { async get(I, v = {}) { const { libp2p: R } = await u(i, v); return R._dht.get(s(I), v); }, async *put(I, v, R) { const { libp2p: _ } = await u(i, R); yield* _._dht.put(s(I), v); }, async *findProvs(I, v = {}) { const { libp2p: R } = await u(i, v); v.numProviders && (v.maxNumProviders = v.numProviders); for await (const _ of R._dht.findProviders(s(I), v))
                        yield { id: _.id.toB58String(), addrs: _.addrs }; }, async findPeer(I, v) { const { libp2p: R } = await u(i, v); typeof I == "string" && (I = d.createFromCID(I)); const _ = await R._dht.findPeer(I); return { id: _.id.toB58String(), addrs: _.multiaddrs }; }, async *provide(I, v = {}) { const { libp2p: R } = await u(i, v); for (var _ in I = Array.isArray(I) ? I : [I])
                        if (typeof I[_] == "string")
                            try {
                                I[_] = new r(I[_]);
                            }
                            catch (k) {
                                throw e(k, "ERR_INVALID_CID");
                            } if (!(await Promise.all(I.map(k => o.blocks.has(k)))).every(k => k))
                        throw e(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND"); if (v.recursive)
                        throw e(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET"); for (const k of I)
                        yield R._dht.provide(k); }, async *query(I, v) { const { libp2p: R } = await u(i, v); typeof I == "string" && (I = d.createFromCID(I)); for await (const _ of R._dht.getClosestPeers(I.toBytes()))
                        yield { id: _.toB58String(), addrs: [] }; } }; return { get: t(h), put: t(a), findProvs: t(l), findPeer: t(p), provide: t(g), query: t(b) }; };
                const s = i => i instanceof Uint8Array ? i : (o => { try {
                    const h = o.toString().split("/").filter(a => a && a !== "ipfs" && a !== "ipns")[0];
                    return new r(h).bytes;
                }
                catch (h) {
                    throw e(h, "ERR_INVALID_CID");
                } })(i), u = async (i, o) => { const h = await i.use(o); if (n(h.libp2p, "_config.dht.enabled", !1))
                    return h; throw new c("dht not enabled"); };
            }]);
    });
});
export default Fe();
